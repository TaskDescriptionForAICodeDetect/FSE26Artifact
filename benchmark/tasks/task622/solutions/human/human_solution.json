[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\n\nint counter = 1;\nvector<bool> visited;\nvector<int> ord, par, low;\n\nstruct Graph {\n  size_t n;\n  int cnt;\n  vector<vector<int>> g;\n  vector<bool> isArt;\n  vector<int> ord, low;\n  vector<pair<int, int>> bridges;\n\n  Graph(size_t n) : n(n), cnt(0), g(n), ord(n, -1), low(n, -1), isArt(n, false) {}\n\n  void addEdge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  void dfs(int u) {\n    ord[u] = low[u] = cnt++;\n    for (auto&& v : g[u]) {\n      if (ord[v] == -1) {\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n        if (ord[u] <= low[v]) isArt[u] = (ord[u] > 0) || (ord[v] > 1);\n        if (ord[u] < low[v]) bridges.push_back({min(u, v), max(u, v)});\n      } else {\n        low[u] = min(low[u], ord[v]);\n      }\n    }\n  }\n  void biconnectedComponents() {\n    for (int i = 0; i < n; ++i) {\n      if (ord[i] == -1) dfs(i);\n    }\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int m; cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int s, t; cin >> s >> t;\n    g.addEdge(s, t);\n  }\n  g.biconnectedComponents();\n  for (int i = 0; i < n; ++i) {\n    if (g.isArt[i]) cout << i << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<double, double> P;\n\nint dfs(int u, int prev, int *cnt, int *prenum, int *lowest, vector< vector<int> > &v, vector<P> &res){\n  prenum[u] = lowest[u] = ++(*cnt);\n  REP(i, v[u].size()){\n    int next = v[u][i];\n    if(prenum[next] == -1){\n      lowest[u] = min(lowest[u], dfs(next, u, cnt, prenum, lowest, v, res));\n      if(lowest[next] == prenum[next]) res.push_back(P(min(u, next), max(u, next)));\n    }\n    else if(prev != next)\n      lowest[u] = min(lowest[u], lowest[next]);\n  }\n  return lowest[u];\n}\n\nvector<P> articulation_points(int V, int E, vector< vector<int> > &v){\n  int prenum[V], lowest[V];\n  memset(prenum, -1, sizeof(prenum));\n  int tmp = 1;\n  vector<P> res;\n  dfs(0, -1, &tmp, prenum, lowest, v, res);\n  return res;\n}\n\nint main() {\n  int V, E; cin >>V >>E;\n  vector< vector<int> > es(V);\n  REP(i, E){\n    int f, t; cin >>f >>t;\n    es[f].push_back(t);\n    es[t].push_back(f);\n  }\n  vector<P> ans = articulation_points(V, E, es);\n  SORT(ans);\n  REP(i, ans.size()) cout <<ans[i].first <<\" \" <<ans[i].second <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n// shoki(N)で初期化\n\n// add_edge(x,y) でx<->yに枝追加 x!=y 多重辺OK\n// [0,N)でグラフは連結\n\n// shori()で実行\n\n// same(x,y)で二つが同じ強連結成分に入ってるか\n// id(x)で頂点xの連結成分番号\n\n\nstruct hasi{\nprivate:\n\tint cnt=0;\n\tpublic:\nint V;\n\tvector<vector<int>> gr,Cgr;\n\tvector<pa> eda;\n\tvector<int> eda_shu,imo,oya_eda,bridge,id;\n\tvector<bool> vis;\n\tint component_size;\n\tvoid shoki(int N){\n\t\tV=N;\n\t\timo.resize(N,0);\n\t\tgr.resize(N,{});\n\t\tvis.resize(N,false);\n\t\tid.resize(N);\n\t\toya_eda.resize(N);\n\t}\n\t\n\tvoid add_edge(int x,int y){\n\t\teda.pb(mp(x,y));\n\t\teda_shu.pb(0);\n\t\tgr[x].pb(cnt);\n\t\tgr[y].pb(cnt);\n\t\tcnt++;\n\t}\n\t\n\t\n\t\n\tvoid dfs(int r){\n\t\tvis[r]=1;\n\t\tfor(auto v:gr[r]){\n\t\t\tif(eda_shu[v]!=0)continue;\n\t\t\tint to=r^eda[v].first^eda[v].second;\n\t\t\tif(vis[to]){\n\t\t\t\teda_shu[v]=2;\n\t\t\t\timo[r]++;\n\t\t\t\timo[to]--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\teda_shu[v]=1;\n\t\t\t\tif(eda[v].first!=r)swap(eda[v].first,eda[v].second);\n\t\t\t\toya_eda[to]=v;\n\t\t\t\tdfs(to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint imo_dfs(int r){\n\t\tfor(auto v:gr[r])if(eda_shu[v]==1 && eda[v].first==r)imo[r]+=imo_dfs(eda[v].second);\n\t\tif(r!=0 && imo[r]==0){\n\t\t\tbridge.pb(oya_eda[r]);\n\t\t}\n\t\treturn imo[r];\n\t}\n\t\n\tvoid dfs_group(int r){\n\t\tfor(auto v:gr[r])if(eda_shu[v]==1 && eda[v].first==r){\n\t\t\tif(imo[eda[v].second]==0){\n\t\t\t\tcnt++;\n\t\t\t\tid[eda[v].second]=cnt;\n\t\t\t\tCgr[cnt].pb(id[r]);\n\t\t\t\tCgr[id[r]].pb(cnt);\n\t\t\t}\n\t\t\telse id[eda[v].second]=id[r];\n\t\t\tdfs_group(eda[v].second);\n\t\t}\n\t}\n\t\n\n\t\n\tvoid shori(){\n\t\tdfs(0);\n\t\timo_dfs(0);\n\t\t\n\t\t\n\t\tvector<pa>R;\n\t\tfor(auto v:bridge)R.pb(mp(min(eda[v].first,eda[v].second),max(eda[v].first,eda[v].second)));\n\t\tsort(R.begin(),R.end());\n\t\tfor(auto v:R)cout<<v.first<<\" \"<<v.second<<endl;\n\t\t\n\t\tcomponent_size=bridge.size()+1;\n\t\tcnt=0;\n\t\tid[0]=0;\n\t\tCgr.resize(component_size,{});\n\t\tdfs_group(0);\n\t\t\n\t}\n\n\t\n\t\n\n};\n\nsigned main(){\n\t\n\t\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\t\nint n,m;\n\tcin>>n>>m;\n\thasi ss;\n\tss.shoki(n);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tss.add_edge(a,b);\n\t}\n\tss.shori();\n\treturn 0; \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nstruct UndirComp {\n    bool operator()(const Edge &e, const Edge &f) const {\n        if (min(e.src, e.dst) != min(f.src, f.dst)) {\n            return min(e.src, e.dst) < min(f.src, f.dst);\n        } else {\n            return max(e.src, e.dst) < max(f.src, f.dst);\n        }\n    }\n} undircomp;\n\nvoid visit(\n    const Graph &g, size_t v ,size_t u, Edges &bridge,\n    stack<size_t> &roots, stack<size_t> &s, vector<bool> &stacked,\n    vector<size_t> &num, int &time\n) {\n    num[v] = ++time;\n    s.push(v), stacked[v] = true;\n    roots.push(v);\n    for (const Edge &e: g[v]) {\n        size_t w=e.dst;\n        if (!num[w]) {\n            visit(g, w, v, bridge, roots, s, stacked, num, time);\n        } else if (u != w && stacked[w]) {\n            while (num[roots.top()] > num[w]) roots.pop();\n        }\n    }\n\n    if (v == roots.top()) {\n        bridge.push_back(Edge(u, v));\n        while (true) {\n            size_t w=s.top(); s.pop(), stacked[w]=false;\n            if (v == w) break;\n        }\n        roots.pop();\n    }\n}\n\nEdges get_bridge(const Graph &g) {\n    size_t V=g.size();\n    vector<size_t> num(V);\n    vector<bool> stacked(V);\n    stack<size_t> roots, s;\n    int time=0;\n\n    Edges bridge;\n    for (size_t u=0; u<V; ++u) if (!num[u]) {\n        visit(g, u, V, bridge, roots, s, stacked, num, time);\n        bridge.pop_back();\n    }\n\n    return bridge;\n}\n\nint main() {\n    size_t V, E;\n    scanf(\"%zu %zu\", &V, &E);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        scanf(\"%zu %zu\", &s, &t);\n\n        join(g, s, t);\n    }\n\n    Edges bridge=get_bridge(g);\n    for (Edge &e: bridge)\n        if (e.src > e.dst)\n            swap(e.src, e.dst);\n\n    sort(bridge.begin(), bridge.end(), undircomp);\n\n    for (Edge &e: bridge)\n        printf(\"%zu %zu\\n\", e.src, e.dst);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d, vector<int> &depth, vector<int> &lowlink, vector<bool> &visited){\n    visited[u] = true;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1, depth, lowlink, visited);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    for(int i=0; i<V; i++)\n        sort(G[i].begin(), G[i].end());\n    \n    vector<int> depth(V, -1), lowlink(V, -1);\n    vector<bool> visited(V, false);\n    dfs(G, -1, 0, 0, depth, lowlink, visited);\n    \n    for(int s=0; s<V; s++){\n        for(auto t: G[s]) if(s<t && (depth[s]<lowlink[t))){\n            cout << s << \" \" << t << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nstruct Edge {\n\tint src;\n\tint dst;\n\tint id;\n};\n\n// res: bridges\n// v: current node\n// from: parent node\nint dfs2(vector<vector<Edge>>&g, vector<int>& res, int v, int& count, int from_id, vector<int>& low, vector<int>& pre) {\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (auto it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = it->dst;\n\t\tif (pre[to] == -1) {\n\t\t\t// destination has not been visited\n\t\t\t// visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs2(g, res, to, count, it->id, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t// edge is not contained in a closed path -> bridge\n\t\t\t\t//res.push_back(it->id);\n\t\t\t\tres[it->id] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from_id == it->id) {\n\t\t\t\t// ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// Calculate bridges in a undirected graph.\n// Assume graph is connected and has no parallel edges or self-loops.\n// g: adjacency list\n// V: number of nodes\nvoid  bridges(vector<vector<Edge>>&g, int V, vector<int>&res) {\n\n\tif (V > 0) {\n\t\t// assume at least the first vertex exists\n\t\tvector<int> low(V, -1);  // lowest reacheable index\n\t\tvector<int> pre(V, -1);  // pre-order index\n\t\tint count = 0;  // pre-order index counter\n\t\tdfs2(g, res, 0, count, -1, low, pre);  // start dfs from vertex 0\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<Edge>>es(V);\n\tvector<Edge>eids;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tif (s > t)swap(s, t);\n\t\tes[s].push_back(Edge{ s,t,i });\n\t\tes[t].push_back(Edge{ t,s,i });\n\t\teids.push_back(Edge{ s,t,i });\n\t}\n\tvector<int>res(V);\n\tbridges(es, V, res);\n\tvector<Edge>bris;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (res[i])bris.push_back(eids[i]);\n\t}\n\tsort(bris.begin(), bris.end(), [=](const Edge&l, const Edge&r) {\n\t\treturn l.src == r.src ? l.dst < r.dst : l.src < r.src;\n\t});\n\tfor (int i = 0; i < bris.size(); ++i) {\n\t\tcout << bris[i].src << \" \" << bris[i].dst << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = uint32_t;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(auto i = 0 * n; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\n\nstruct Edge{ uint32_t to, id; };\ntypedef vector<vector<Edge>> Graph;\n// ??????????????????\nstruct Bridge {\n#define PB push_back\n\ttypedef uint32_t T;\n\ttypedef vector<T> vt;\n\texplicit Bridge(const Graph & g) : v2cmp(g.size()) {\n\t\tT n = g.size(), k = 0;\n\t\tvt ord(n, 0), low(n), stk;\n\t\tfunction<void(T, T, T)> f = [&](T c, T p, T id) {\n\t\t\tord[c] = low[c] = ++k;\n\t\t\tstk.PB(c);\n\t\t\tfor (auto e : g[c]) {\n\t\t\t\tif (!ord[e.to]) {\n\t\t\t\t\tf(e.to, c, e.id);\n\t\t\t\t\tlow[c] = min(low[c], low[e.to]);\n\t\t\t\t} else if (e.id != id) {\n\t\t\t\t\tlow[c] = min(low[c], ord[e.to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (low[c] == ord[c]) {\n\t\t\t\tif (p != n) bridge.PB({ id, min(c, p), max(c, p) });\n\t\t\t\tcomponent.PB({});\n\t\t\t\tT v; do {\n\t\t\t\t\tv2cmp[v = stk.back()] = component.size() - 1;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t\tcomponent.back().PB(v);\n\t\t\t\t} while (v != c);\n\t\t\t}\n\t\t};\n\t\tfor (T i = 0; i < n; ++i) if (!ord[i]) f(i, n, T(-1));\n\t}\n\t// BridgeEdge : u < v ?????????????????????\n\t// v2cmp[v]   : ?????? v ????±?????????????????????????????????????????????????\n\tstruct BridgeEdge { T id, u, v; };\n\tvt v2cmp;\n\tvector<BridgeEdge> bridge;\n\tvector<vt> component;\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tuint n, m; cin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tuint s, t; cin >> s >> t;\n\t\tg[s].push_back({t, i});\n\t\tg[t].push_back({s, i});\n\t}\n\tBridge brid(g);\n\tsort(ALL(brid.bridge), [](Bridge::BridgeEdge l, Bridge::BridgeEdge r) {\n\t\tif (l.u != r.u) return l.u < r.u;\n\t\treturn l.v < r.v;\n\t});\n\tfor (auto b : brid.bridge) {\n\t\tcout << b.u << \" \" << b.v << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n\nclass Node {\npublic:\n\tNode():number(i++), order(-1), min(0), edges(0), parent(0), art(false) {};\n\tvoid add_edge(Node *);\n\tstd::vector<Node*> &get_edge() { return edges; }\n\tbool operator==(const Node &other) { return number == other.number; }\n\tint order, min, number, parent;\n\tbool art;\n\tbool arti() { return art || edges.size() == 1; }\nprivate:\n\tstatic int i;\n\tstd::vector<Node*> edges;\n};\nint Node::i = 0 ;\nvoid Node::add_edge(Node *other) { edges.push_back(other); }\nint dfs(Node &current, int &order) {\n\tint min = order;\n\tint count = 0;\n\tfor (auto &node : current.get_edge()) {\n\t\tint temp;\n\t\tif (node->order == -1) {\n\t\t\tnode->order = ++order;\n\t\t\tnode->parent = current.number;\n\t\t\ttemp = dfs(*node, order);\n\t\t\tif (temp == current.order) {\n\t\t\t\tcurrent.art = true;\n\t\t\t}\n\n\t\t\t++count;\n\t\t}\n\t\telse {\n\t\t\ttemp = node->order;\n\t\t}\n\t\tif (min > temp) {\n\t\t\tmin = temp;\n\t\t}\n\t}\n\tif (current.number == 0) {\n\t\tif (count > 1) {\n\t\t\tcurrent.art = true;\n\t\t}\n\t\telse {\n\t\t\tcurrent.art = false;\n\t\t}\n\t}\n\tcurrent.min = min;\n\treturn min;\n}\nclass Edge {\npublic:\n\tEdge(const int &sn = 0, const int &tn = 0, Node *s = nullptr, Node *e = nullptr) : s_num(sn), t_num(tn), start{ s }, end{ e }, number(i++) {};\n\tbool suspect() { return (start->arti() && end->arti()) && (start->parent == end->number || start->number == end->parent); }\n\tbool operator<(const Edge &other) { return (s_num < other.s_num) || (s_num == other.s_num && t_num < other.t_num); }\n\tvoid show() { std::cout << s_num << \" \" << t_num << \"\\n\"; }\nprivate:\n\tNode *start, *end;\n\tint s_num, t_num, number;\n\tstatic int i;\n};\nint Edge::i(0);\nvoid sort(std::vector<Edge> &vector, const int left, const int right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (vector.at(l) < pivot)++l;\n\t\t\twhile (pivot < vector.at(r))--r;\n\t\t\tif (l <= r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, l, right);\n\t}\n}\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tstd::vector<Node> node(v);\n\tstd::vector<Edge> edge(e);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\t\tif (t < s) {\n\t\t\tauto temp = s;\n\t\t\ts = t; t = temp;\n\t\t}\n\t\tedge.at(i) = Edge(s, t, &node.at(s), &node.at(t));\n\t\tnode.at(s).add_edge(&node.at(t));\n\t\tnode.at(t).add_edge(&node.at(s));\n\t}\n\tnode.at(0).order = 0;\n\tint order = 0;\n\tdfs(node.at(0), order);\n\tsort(edge, 0, edge.size() - 1);\n\tfor (auto v : node) {\n\t\t//std::cout << v.number << \"--art= \" << v.arti() << \"--min= \" << v.min << \"--order= \" << v.order << \"--parent= \" << v.parent << std::endl;\n\t}\n\tfor (auto e : edge) {\n\t\tif (e.suspect()) {\n\t\t\te.show();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool usedV[MAX_V],usedE[MAX_V][MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v){\t//make ord and lowlink\n\tusedV[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!usedV[to]){\n\t\t\tusedE[v][to] = true;\n\t\t\tdfs(to);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(!usedE[to][v]){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0);\n\t\n\trep(i,e){\n\t\tif(ord[edges[i].first]<lowlink[edges[i].second])cout<<edges[i].first<<\" \"<<edges[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > low[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n      // e is bridge!\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    es.emplace_back(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()){\n    if (bd.edge_group[i].size() == 1) bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  int n;\n  BiconectedGraph(){}\n  BiconectedGraph(int n):n(n){\n    G.clear();\n    C.clear();\n    T.clear();\n    G.resize(n);\n    C.resize(n);\n    T.resize(n);\n  }\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.clear();\n    low.clear();\n    belong.clear();\n    ord.resize(n,-1);\n    low.resize(n);\n    belong.resize(n,-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  bcc.input(e,0);\n  bcc.build();\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}\n\n/*\n  verified on 2017/10/21\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\n\nvoid visit(int cur, int prev, vector<pii> &brg, vector<vector<int>> &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n\torder[cur] = ++k;\n\tS.push(cur); inS[cur] = true;\n\troots.push(cur);\n\t\n\trep(i,G[cur].size()){\n\t\tint to = G[cur][i];\n\t\tif(order[to]==0){\n\t\t\tvisit(to,cur,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t\telse if(to!=prev && inS[to]){\t//?????????????????????\n\t\t\twhile(order[roots.top()] > order[to]) roots.pop();\t//cur???to?????§(to???????????????)????????????roots????????¨??????\n\t\t}\n\t}\n\n\tif(cur==roots.top()&&prev!=-1){\n\t\tbrg.pb(pii(prev,cur));\n\t\tvector<int> bcc;\n\t\twhile(1){\n\t\t\tint node = S.top(); S.pop(); inS[node] = false;\n\t\t\tbcc.pb(node);\n\t\t\tif(node==cur)break;\n\t\t}\n\t\teach_bcc.pb(bcc);\n\t\troots.pop();\n\t}\n}\n\n\nvoid bridge(int V, vector<pii> &brg, vector<vector<int>> &each_bcc){\n\tvector<int> order(V);\n\tvector<bool> inS(V);\n\tstack<int> roots, S;\n\tint k=0;\n\trep(i,V){\n\t\tif(order[i]==0){\n\t\t\tvisit(i,-1,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t}\n}\n\n\n\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tvector<pii> brg;\n\tvector<vector<int>> each_bcc;\n\t\n\tbridge(v,brg,each_bcc);\n\t\n\tvector<pii> ans;\n\trep(i,brg.size()){\n\t\tans.pb(pii(brg[i].first,brg[i].second));\n\t}\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 10000\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint par[MAX_V],pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[MAX_V]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      par[nx]=v;\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n    int from,to;\n    Edge(int f,int t) : from(f), to(t){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass LowLink {\n    public:\n        LowLink(int n) : mGraph(n), mOrd(n), mLow(n), mUsed(n,false) {}\n        void add_edge(int u, int v){\n            mGraph[u].emplace_back(u,v);\n            mGraph[v].emplace_back(v,u);\n        }\n        // e(u,v)が橋　<=> ord[u] < low[v]\n        // 頂点vが関節点 <=> ord[u] <= low[v]となるvの子uが存在\n        int dfs(int v,int pv,int k){\n            mUsed[v] = true;\n            mOrd[v] = mLow[v] = k++; // 訪れた順\n            bool is_articulation = false;\n            int cnt = 0;\n            for(Edge nv : mGraph[v]){\n                if(!mUsed[nv.to]){ // まだ訪れてない\n                    ++cnt;\n                    k = dfs(nv.to,v,k);\n                    mLow[v] = min(mLow[v], mLow[nv.to]);\n\n                    is_articulation |= ~pv && mOrd[v] <= mLow[nv.to];\n                    if(mOrd[v] < mLow[nv.to]) mBridges.emplace_back(v,nv.to);\n                } else if(nv.to != pv){ // 後退辺だったら\n                    mLow[v] = min(mLow[v], mOrd[nv.to]);\n                }\n            }\n            is_articulation |= pv == -1 && cnt > 1;\n            if(is_articulation) mArticulationPoints.push_back(v);\n\n            return k;\n        }\n\n        void Init(){\n            int k = 0;\n            for(int i = 0; i < mGraph.size(); ++i){\n                if(!mUsed[i]) k = dfs(i,k,-1);\n            }\n        }\n\n        vector<pair<int,int> > GetBridges(){ return mBridges;}\n        vector<int> GetArticulationPoints(){ return mArticulationPoints;}\n\n    private:\n        Graph mGraph;\n        vector<int> mOrd;\n        vector<int> mLow;\n        vector<bool> mUsed;\n        vector<pair<int,int> > mBridges;\n        vector<int> mArticulationPoints;\n};\n\n\nint main(){\n    int V,E,s,t;\n    cin >> V >> E;\n    LowLink lowlink(V);\n    for(int i = 0; i < E; ++i){\n        cin >> s >> t;\n        lowlink.add_edge(s,t);\n    }\n    lowlink.Init();\n    auto ans = lowlink.GetBridges();\n    sort(ans.begin(),ans.end());\n    for(auto e : ans){ cout << e.first << \" \" << e.second << endl;}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nbool disconnected (Graph g, Edge disconnectedEdge) {\n    vector<bool> seen(g.size(), false);\n    int counter = g.size();\n    queue<int> front;\n    front.push(0);\n\n    while (! front.empty()) {\n        int u = front.front();\n        front.pop();\n\n        if (! seen[u]) {\n            seen[u] = true;\n            counter--;\n            for(int v: g[u])\n                if ((v != disconnectedEdge.u || u != disconnectedEdge.v) && (v != disconnectedEdge.v || u != disconnectedEdge.u))\n                    front.push(v);\n        }\n    }\n\n    return counter != 0;\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> edges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n        edges.push_back(Edge{s, t});\n    }\n\n    sort(edges.begin(), edges.end());\n\n    vector<Edge> bridges;\n    for(Edge e : edges)\n        if (disconnected(g, e)) bridges.push_back(e);\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint V,E;\nvector<int> g[100100];\nint dep[100100],low[100100],ord[100100];\nint cnt = 0;\nvoid dfs(int v,int p,int d){\n\tdep[v] = d;\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tfor(int i=0;i<g[v].size();i++){\n\t\tif(g[v][i]==p)continue;\n\t\tint ch = g[v][i];\n\t\tif(ord[ch]==-1){\n\t\t\tdfs(ch,v,d+1);\n\t\t\tlow[v] = min(low[v],low[ch]);\n\t\t}else{\n\t\t\tlow[v] = min(low[v],ord[ch]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&V,&E);\n\tvector<P> es(E);\n\tfor(int i=0;i<E;i++){\n\t\tint s,t;\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tg[s].pb(t);\n\t\tg[t].pb(s);\n\t\tes[i]=P(s,t);\n\t}\n\tmemset(ord,-1,sizeof(ord));\n\tdfs(0,-1,0);\n\tvector<P> ans;\n\tfor(int i=0;i<E;i++){\n\t\tint s = es[i].fi,t = es[i].sec;\n\t\tif(dep[s]>dep[t])swap(s,t);\n\t\tif(ord[s]<low[t])ans.pb(es[i]);\t\n\t}\n\tfor(int i=0;i<ans.size();i++)printf(\"%d %d\\n\",ans[i].fi,ans[i].sec);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nvint G[111111];\nbool vis[111111];\nint ord[111111],low[111111];\nvpint bridge;\nvoid dfs(int v,int p,int &k){\n    ord[v]=k++;\n    low[v]=ord[v];\n    vis[v]=true;\n    for(auto u:G[v]){\n        if(vis[u]){\n            if(u!=p)chmin(low[v],ord[u]);\n        }\n        else{\n            dfs(u,v,k);\n            if(ord[v]<low[u])bridge.pb({min(v,u),max(v,u)});\n            chmin(low[v],low[u]);\n        }\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,M){\n        int a,b;cin>>a>>b;\n        G[a].pb(b);G[b].pb(a);\n    }\n    int k=0;dfs(0,-1,k);\n    sort(all(bridge));\n    rep(i,bridge.size())cout<<bridge[i].fi<<\" \"<<bridge[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nstruct LowLink {\n    ll N;\n    const VV<ll> &edges;\n    V<ll> low, ord;\n    V<bool> visited;\n    V<bool> is_articulation;\n    ll dfs_counter;\n\n    LowLink(const VV<ll> &edges)\n        : N(edges.size()), edges(edges), low(edges.size()), ord(edges.size()), \n          visited(edges.size()), is_articulation(edges.size()), dfs_counter(0)\n    {\n        for (ll i = 0; i < N; i++) if (!visited[i]) dfs(i, -1);\n    }\n\n    void dfs(ll cur, ll pre) {\n        visited[cur] = true;\n        ord[cur] = dfs_counter++;\n        low[cur] = ord[cur];\n        ll children = 0;\n        bool art = false;\n        for (ll nxt : edges[cur]) {\n            if (!visited[nxt]) {\n                children++;\n                dfs(nxt, cur);\n                chmin(low[cur], low[nxt]);\n                art |= (pre == -1 ? 2 <= children : ord[cur] <= low[nxt]);\n            } else if (nxt != pre) {\n                chmin(low[cur], ord[nxt]);\n            }\n        }\n        is_articulation[cur] = art;\n    }\n\n    bool is_art(ll cur) { return is_articulation[cur]; }\n\n    // u -> v\n    bool is_bridge(ll from, ll to) { return ord[from] < low[to]; }\n\n    V<PLL> enum_bridges() {\n        V<PLL> ret;\n        for (ll from = 0; from < N; from++) {\n            for (ll to : edges[from]) {\n                if (!(from < to)) continue;\n                if (is_bridge(from, to)) ret.emplace_back(from, to);\n            }\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    VV<ll> edges(N);\n    for (ll i = 0; i < M; i++) {\n        ll a, b;\n        cin >> a >> b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    for (auto &&v : edges) sort(ALL(v));\n\n    LowLink lowlink(edges);\n\n    // for (ll i = 0; i < N; i++) if (lowlink.is_art(i)) cout << i << endl;\n    for (ll i = 0; i < N; i++) for (ll j : edges[i]) {\n        if (!(i < j)) continue;\n        if (lowlink.is_bridge(i, j) || lowlink.is_bridge(j, i)) cout << i << ' ' << j << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e6+10;\nvector<int> G[N];\nint order[N];\nint low[N];\nint p[N];\nint child=0;\nint cnt=0;\nvector<pair<int,int> > ans;\n\nvoid add(int s,int t)\n{\n    G[s].push_back(t);\n    G[t].push_back(s);\n}\n\nvoid dfs(int v)\n{\n    order[v]=low[v]=++cnt;\n    for(int i=0;i<G[v].size();i++)\n    {\n        int u=G[v][i];\n        if(!order[u])\n        {\n            if(v==0) child++;\n            p[u]=v;\n            dfs(u);\n            low[v]=min(low[v],low[u]);\n            if(low[u]>order[v]) ans.push_back(make_pair(min(u,v),max(u,v)));\n        }else if(p[v]!=u)\n        {\n            low[v]=min(low[v],order[u]);\n        }\n    }\n}\n\nint main()\n{\n    int v,e;\n    cin>>v>>e;\n\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        add(s,t);\n    }\n\n    dfs(0);\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<ans.size();i++)\n    {\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nclock_t START, END;\n\nint V, E, r;\nint dfs_clock;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int u, int v) :from(u), to(v) {}\n};\n\nbool cmp(Edge a, Edge b) {\n\tif (a.from == b.from)\n\t\treturn a.to < b.to;\n\treturn a.from < b.from;\n}\n\nstruct Dijkstra {\n\tint n, m;\n\tvector<Edge> edges;\n\tvector<int> G[NUM];\n\t\n\tint pre[NUM], low[NUM];\n\tbool isbridge[NUM];\n\tvector<Edge> bridge;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\tedges.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t\tisbridge[i] = false;\n\t\t\tlow[i] = -1;\n\t\t}\n\t}\n\n\tvoid AddEdge(int from, int to) {\n\t\tedges.push_back(Edge(from, to));\n\t\tm = edges.size();\n\t\tG[from].push_back(m - 1);\n\t}\n\n\tint dfs(int u, int fa) {\n\t\tint lowu = pre[u] = ++dfs_clock;\n\t\tint child = 0;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = edges[G[u][i]].to;\n\t\t\tif (!pre[v]) {\n\t\t\t\tchild++;\n\t\t\t\tint lowv = dfs(v, u);\n\t\t\t\tlowu = min(lowu, lowv);\n\t\t\t\tif (lowv > pre[u])\n\t\t\t\t\tisbridge[G[u][i]] = true;\n\t\t\t}\n\t\t\telse if (pre[v] < pre[u] && v != fa)\n\t\t\t\tlowu = min(lowu, pre[v]);\n\t\t}\n\t\tlow[u] = lowu;\n\t\treturn lowu;\n\t}\n\n\tvoid print() {\n\t\tfor (int i = 0; i < edges.size(); i++) {\n\t\t\tif (isbridge[i]) {\n\t\t\t\tif (edges[i].from > edges[i].to)\n\t\t\t\t\tswap(edges[i].from, edges[i].to);\n\t\t\t\tbridge.push_back(edges[i]);\n\t\t\t}\n\t\t}\n\t\tsort(bridge.begin(), bridge.end(), cmp);\n\t\tfor (vector<Edge>::iterator it = bridge.begin(); it != bridge.end(); it++)\n\t\t\tcout << it->from << \" \" << it->to << endl;\n\t}\n};\n\nDijkstra solve;\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint s, t;\n\tcin >> V >> E;\n\tsolve.init(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tsolve.AddEdge(s, t);\n\t\tsolve.AddEdge(t, s);\n\t}\n\tsolve.dfs(0, -1);\n\tsolve.print();\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nvoid Lowlink(BiDGraph& g,vector<int>& lowlink, vector<int>& orb) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int,int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) continue;\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first,cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0,-1);\n\treturn;\n}\n\nvoid Bridge(BiDGraph& g, vector<pii>& bridges) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({i, itr.first});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Joint(BiDGraph& g, vector<int>& joints) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr : bridges) {\n\t\tif (itr.first < itr.second) swap(itr.first, itr.second);\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  c/temp.cpp file\n//  Last Updated: 2018-10-23 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n\n#define coutYN(a) cout<<((a)?\"YES\":\"NO\")<<endl;\n#define coutYn(a) cout<<((a)?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<((a)?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\n//const long long INF=114514191911451419;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<typename T> istream &operator >> (istream &is, vector<T> &v){for(T &x:v) is>>x;return is;}\ntemplate<typename T> ostream &operator << (ostream &os, vector<T> &v){int i=0;for(T &x:v) os<<(i++?\" \":\"\")<<x;return os;}\n\nll rev(ll n){ll x=0;for(;n>0;){x=x*10+n%10;n/=10;}return x;}\n\nll upper(ll n,ll m){return (n+m-1)/m;};\nll rounding(ll n){return (long double)n+0.5;};\n\nbool inG(ll x,ll n){return 0<=x && x<n;}\nbool outG(ll x,ll n){return x<0 || n<=x;}\n\ninline int qp(int a,ll b){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\ninline ll fac(ll k,ll n){ll a=1;for(int i=0;i<n;i++)a*=k--;return a;}\ninline ll fac(ll k,ll n,int mo){ll a=1;for(int i=0;i<n;i++)a*=k--,a%=mo;return a;}\n\ninline int dsum(ll n){int a=0;for(;n;n/=10)a+=n%10;return a;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"です\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←？\"<<endl;}\n//ori_func S\n\n//ori_func E\n#else\ntemplate<typename T>void deb(T a){}\n#define debl\nvoid what_cr(){}void t_t(){}\n#endif\n\nvi G[250000];\nvi dfsT[250000];\nvi ord(250000,INF),low(250000,INF);\n\nvoid lowlink(int u,int k=0,int f=-1){\n\n  ord[u]=low[u]=k++;\n\n  REP(i,G[u].size()){\n\n    int v=G[u][i];\n\n    if(ord[v] == INF){\n\n      dfsT[u].pb(v);\n      lowlink(v,k,u);\n      low[u]=min(low[u],low[v]);\n\n    }\n    else if(f != v) low[u]=min(low[u],ord[v]);\n\n  }\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  int v,e;\n  cin>>v>>e;\n\n  REP(i,e){\n\n    int s,t;\n    cin>>s>>t;\n\n    G[s].pb(t);\n    G[t].pb(s);\n\n  }\n\n  lowlink(0);\n\n  vector <pii> ans;\n\n  REP(i,v){\n\n    REP(j,dfsT[i].size())\n      if(ord[i] < low[dfsT[i][j]]){\n\n        vi a;\n        a.pb(i);\n        a.pb(dfsT[i][j]);\n        sort(ALL(a));\n        ans.pb(mp(a[0],a[1]));\n\n      }\n\n  }\n\n  sort(ALL(ans));\n\n  for(pii e:ans) cout<<e.fi<<\" \"<<e.se<<endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (isBridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or isBridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tfor (int v : g[u]) {\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tdfs(0, -1, 0);\n\t\n\tfor (pii now : bridge) printf(\"%d %d\\n\", now.first, now.second);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<i_i, int> p_i;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\n\nvvi edge;\nvi prenum;\nvi lowest;\nvi parent;\nint timer;\n\nvoid dfs(int u, int prev) {\n  prenum[u] = timer;\n  lowest[u] = timer;\n  timer += 1;\n\n  for (auto v : edge[u]) {\n    if (prenum[v] < 0) {\n      parent[v] = u;\n      dfs(v, u);\n      lowest[u] = min(lowest[u], lowest[v]);\n    } else if (v != prev) {\n      lowest[u] = min(lowest[u], prenum[v]);\n    }\n  }\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n  edge.resize(v);\n  prenum.resize(v, -1);\n  lowest.resize(v);\n  parent.resize(v);\n  rep (i, e) {\n    int s, t;\n    cin >> s >> t;\n    edge[s].pb(t);\n    edge[t].pb(s);\n  }\n  timer = 0;\n  dfs(0, -1);\n\n  set<vi> ans;\n  FOR(i, 1, v) {\n    if (prenum[parent[i]] < lowest[i]) {\n      int mi = min(parent[i], i);\n      int ma = max(parent[i], i);\n      ans.insert({mi, ma});\n    }\n  }\n  for (auto e : ans) {\n    printf(\"%d %d\\n\", e[0], e[1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n    const int V;\n};\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const Graph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            if (ord[i] == -1) {\n                bridge_dfs(g_, i);\n            }\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const\n    {\n        return bridge;\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    const vector<pair<int, int>> getBridge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? (ord[i] < low[j]) : (ord[j] < low[i]);\n    }\n\nprivate:\n    void bridge_dfs(const Graph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const int to : g_.edge[s]) {\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n                if (isBridge(s, to)) {\n                    bridge.push_back(make_pair(s, to));\n                }\n            }\n        }\n    }\n\n    void comp_dfs(const Graph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const int to : g_.edge[s]) {\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n\n    int num;\n    int comp_num;\n    const int size;\n    vector<pair<int, int>> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) {\n            swap(s, t);\n        }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    for (int i = 0; i < E; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n        if (bic.isBridge(u, v)) {\n            cout << u << \" \" << v << endl;\n        }\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<double, double> P;\n\nint dfs(int u, int prev, int *cnt, int *prenum, int *lowest, vector< vector<int> > &v, vector<P> &res){\n  prenum[u] = lowest[u] = ++(*cnt);\n  REP(i, v[u].size()){\n    int next = v[u][i];\n    if(prenum[next] == -1){\n      lowest[u] = min(lowest[u], dfs(next, u, cnt, prenum, lowest, v, res));\n      if(lowest[next] == prenum[next]) res.push_back(P(u, next));\n    }\n    else if(prev != next)\n      lowest[u] = min(lowest[u], lowest[next]);\n  }\n  return lowest[u];\n}\n\nvector<P> articulation_points(int V, int E, vector< vector<int> > &v){\n  int prenum[V], lowest[V];\n  memset(prenum, -1, sizeof(prenum));\n  int tmp = 1;\n  vector<P> res;\n  dfs(0, -1, &tmp, prenum, lowest, v, res);\n  return res;\n}\n\nint main() {\n  int V, E; cin >>V >>E;\n  vector< vector<int> > es(V);\n  REP(i, E){\n    int f, t; cin >>f >>t;\n    es[f].push_back(t);\n    es[t].push_back(f);\n  }\n  vector<P> ans = articulation_points(V, E, es);\n  SORT(ans);\n  REP(i, ans.size()) cout <<ans[i].first <<\" \" <<ans[i].second <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;// 998244353;\nconstexpr long long INF = numeric_limits<LL>::max() / 2;\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<vector<LL>>g;\nvector<edge>edges;\nvector<LL>v;\nmap<LL, LL>ma;\nset<Pll>st;\nLL h, w, n, m, k, t, s, p, q, last, cnt, sum[210000], ans, dp[210000], a[210000], b[210000];\nstring str, ss;\nbool f;\nchar c;\nstruct lowlink {\n\tvector<vector<LL>>g;\n\tvector<LL>low, ord;\n\tvector<bool>visited;\n\tset<Pll>bridge;\n\tLL n = 0, cnt;\n\tlowlink(vector<vector<LL>>G) :g(G), n(G.size()) {\n\t\tlow.resize(n);\n\t\tord.resize(n);\n\t\tvisited.resize(n);\n\t\trep(i, n)low[i] = INF;\n\t\tdfs(0, -1);\n\t\trep(i, n)rep(j, g[i].size()) {\n\t\t\tif (ord[i] < low[g[i][j]]) {\n\t\t\t\tbridge.insert(Pll(min(i, g[i][j]), max(i, g[i][j])));\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(LL cur, LL par) {\n\t\tvisited[cur] = 1;\n\t\tord[cur] = cnt;\n\t\tlow[cur] = ord[cur];\n\t\tcnt++;\n\t\trep(i, g[cur].size()) {\n\t\t\tLL u = g[cur][i];\n\t\t\tif (u == par)continue;\n\t\t\tif (visited[u]) {\n\t\t\t\tlow[cur] = min(low[cur], ord[u]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdfs(u, cur);\n\t\t\t\tlow[cur] = min(low[cur], low[u]);\n\t\t\t}\n\t\t}\n\t}\n\tbool is_bridge(LL u, LL v) {\n\t\tif (bridge.count(Pll(min(u, v), max(u, v))))return 1;\n\t\treturn 0;\n\t}\n\tvoid print() {\n\t\tfor (auto it = bridge.begin(); it != bridge.end(); it++) {\n\t\t\tcout << it->first << \" \" << it->second << endl;\n\t\t}\n\t}\n};\nint main() {\n\tcin >> n >> m;\n\tg.resize(n);\n\trep(i, m) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tlowlink low(g);\n\tlow.print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct calc_bridge_and_articulation{\n    const int size;\n    vector<vector<int>> graph;\n    vector<bool> used_v;\n    vector<vector<bool>> used_e;\n    vector<int> ord,lowlink,articulations;\n    vector<pair<int,int>> bridges;\n\n    calc_bridge_and_articulation(const vector<vector<int>> &graph):graph(graph),size(graph.size()){\n        used_v.resize(size);\n        used_e.resize(size);\n        rep(i,0,size) used_e[i].resize(size);\n        ord.resize(size);\n        lowlink.resize(size);\n        int k;\n        rep(i,0,size) if(!used_v[i]) dfs(i,-1,k);\n    }\n\n    void dfs(int v,int p,int &k){ //v???????????¨???p=-1\n        used_v[v]=true;\n        ord[v]=lowlink[v]=k++;\n\n        bool is_articulation=false;\n        int count=0;\n        for(int u:graph[v]){\n            if(!used_v[u]){\n                ++count;\n                used_e[v][u]=true;\n                dfs(u,v,k);\n                lowlink[v]=min(lowlink[v],lowlink[u]);\n\n                if(ord[v]<lowlink[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n                if(p!=-1 and ord[v]<=lowlink[u]) is_articulation=true;\n            }else if(!used_e[u][v]) lowlink[v]=min(lowlink[v],ord[u]);\n        }\n\n        if(p==-1 and count>1) is_articulation=true;\n        if(is_articulation) articulations.push_back(v);\n    }\n};\n\nvoid solve(){\n    int size_v,size_e;\n    cin >> size_v >> size_e;\n    vector<vector<int>> graph(size_v);\n    rep(i,0,size_e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n    }\n    calc_bridge_and_articulation cba(graph);\n    auto ans=cba.bridges;\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size()) cout << ans[i].first << \" \" << ans[i].second << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int SIZE=100000;\nint N,M;\nvector<int>G[SIZE];\n\nvector<pair<int,int>>bridge;\nint ord[100000],low[100000];\nbool vis[100000];\n\nvoid dfs(int v,int p,int &k){\n    vis[v]=true;\n    ord[v]=k++;\n    low[v]=ord[v];\n\n    for(auto u:G[v]){\n        if(!vis[u]){\n            dfs(u,v,k);\n            low[v]=min(low[v],low[u]);\n            if(ord[v]<low[u])bridge.push_back(pair<int,int>(min(v,u),max(v,u)));\n        }\n        else if(u!=p){\n            low[v]=min(low[v],ord[u]);\n        }\n    }\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        a--;b--;\n        G[a].push_back(b);G[b].push_back(a);\n    }\n    int K=0;\n    dfs(0,0,K);\n    sort(bridge.begin(),bridge.end());\n    for(int i=0;i<bridge.size();i++){\n        printf(\"%lld %lld\\n\",bridge[i].first+1,bridge[i].second+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by Vignesh Manoharan\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<vi> vvi;\n\nconst int INF = 1000000000;\nconst ll LINF = 1e17;\nconst double PI =3.141592653589793238;\n#pragma unused(INF,PI,LINF)\n#define F(i,a,n) for(int i=(a);i<(n);i++)\n\ntemplate<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream &s,vector<T> t){\n    for(int i=0;i<(t).size();i++)s<<t[i]<<((i<(t).size()-1)?\" \":\"\");return s; }\ntemplate<typename T> ostream& operator<<(ostream &s,set<T> t){for(T x:t) s<<x<<\" \";return s; }\ntemplate<typename T> istream& operator>>(istream &s,vector<T> &t){\n    for(int _i=0;_i<t.size();_i++) s>>t[_i];return s; }\n\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nvector<int> low,idx,visited,parent;\nint counter=0;\nvector<vector<int>> graph;\nvector<ii> bridges;\nvoid find_bridges(int u){\n    low[u]=idx[u]=counter++;\n    for(int v:graph[u]){\n        if(!visited[v]){\n            parent[v]=u;\n            visited[v]=1;\n            find_bridges(v);\n            if(low[v]>idx[u])\n                bridges.pb(mp(u,v));\n            low[u]=min(low[u],low[v]);\n        } else if(v!=parent[u])\n            low[u]=min(low[u],idx[v]);\n    }\n}\nint main(int argc, const char * argv[]) {\n#ifdef local_test\n    //    input\n    //    freopen(\"input\",\"w\",stdout);\n    //    cout<<\"1 \\n 100 10 \\n\";\n     freopen(\"input\",\"r\",stdin);\n     freopen(\"output\",\"w\",stdout);\n#endif\n    int n,m;\n    cin>>n>>m;\n    graph = vvi(n,vi());\n    low=vi(n);\n    idx=vi(n);\n    visited=vi(n,0);\n    parent=vi(n,-1);\n    F(i,0,m){\n        int u,v;\n        cin>>u>>v;\n        graph[u].pb(v);\n        graph[v].pb(u);\n    }\n    for(int i=0;i<n;i++) if(!visited[i]) find_bridges(i);\n//    cout<<bridges<<\"\\n\";\n    for(int i=0;i<bridges.size();i++){\n        ii e=bridges[i];\n        bridges[i]=mp(min(e.first,e.second),max(e.first,e.second));\n    }\n    sort(all(bridges));\n    for(ii e:bridges){\n        cout<<e.first<<\" \"<<e.second<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass Bridge {\nprivate:\n\tint size_, cnt0; vector<vector<int>>x; vector<int> ord, low, used; vector<pair<int, int>>brd;\npublic:\n\tBridge() : size_(0), x(vector<vector<int>>()) {};\n\tBridge(int size__) : size_(size__) {\n\t\tx.resize(size__);\n\t\tord.resize(size__);\n\t\tlow.resize(size__);\n\t\tused.resize(size__);\n\t}\n\tvoid unite(int a1, int a2) {\n\t\tx[a1].push_back(a2);\n\t\tx[a2].push_back(a1);\n\t}\n\tvoid dfs(int p, int k) {\n\t\tlow[p] = cnt0; used[p] = 1;\n\t\tord[p] = cnt0; cnt0++;\n\t\tfor (int i = 0; i < x[p].size(); i++) {\n\t\t\tint to = x[p][i];\n\t\t\tif (used[to] == 0) {\n\t\t\t\tdfs(to, p);\n\t\t\t\tlow[p] = min(low[p], low[to]);\n\t\t\t\tif (ord[p] < low[to]) {\n\t\t\t\t\tint aa1 = p, aa2 = to; if (aa1 > aa2)swap(aa1, aa2);\n\t\t\t\t\tbrd.push_back(make_pair(aa1, aa2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (to != k) {\n\t\t\t\tlow[p] = min(low[p], ord[to]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<pair<int, int>> bridge(int size__, int st) {\n\t\tbrd.clear(); cnt0 = 0;\n\t\tfor (int i = 0; i < size__; i++) { ord[i] = 0; low[i] = 0; used[i] = 0; }\n\t\tdfs(st, -1);\n\t\treturn brd;\n\t}\n\tint size() { return size_; }\n};\nint main() {\n\tint n, m, a, b; cin >> n >> m;\n\tBridge B(n + 1);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b; B.unite(a, b);\n\t}\n\tvector<pair<int, int>>W = B.bridge(n + 1, 1);\n\tsort(W.begin(), W.end());\n\tfor (int i = 0; i < W.size(); i++)cout << W[i].first << ' ' << W[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\n// ??¢??????????±??????? (artPoints)\n// ???????±??????? (bridges)\n\n// ??¢?????????????????????????????¨????????£?????§???????????£???????????????????????????????????¨\n// ????????????????????????????????£?????§???????????£????????????????????????????????¨\n\ntemplate <typename T>\nstruct graphLink {\n    vector<int> ord, low, parent;\n    vector< vector< Edge<T> > > G;\n    vector< pair<int, int> > bridges;\n    int cnt, v;\n\n    // init\n    graphLink(int _n) : ord(_n, -1), low(_n, 0),\n                        parent(_n, -1), G(_n), cnt(0), v(_n) {}\n\n    // ?????§??????????????????\n    bool is_bridge(int x, int y) {\n        if(ord[x] > ord[y]) swap(x, y);\n        return ord[x] < low[y];\n    }\n\n    // dfs ??¨???????????¨????????????\n    // usage: dfs(root);\n    void dfs(int cur, int prev=-1) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n\n        for(auto x : G[cur]) {\n            if(x.to == prev) continue;\n            if(ord[x.to] < 0) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n            if(is_bridge(cur, x.to)) {\n                int a = min(cur, x.to);\n                int b = max(cur, x.to);\n                bridges.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    // ??¢??????????±??????? (root ??? dfs ??¨??? root ??¨?????´?????????)\n    // root ????????? 2 ????????£???????????°??¢???????????????\n    // ????????\\?????????????????¢????????? ord[parent] <= low[i] ?????¨?????¢???????????????\n    // (lowlink ??§??????????????±????????????????????????????????????????????????)\n    set<int> artPoints(int root) {\n        set<int> se;\n        int num = 0;\n        rep(i,0,v) {\n            if(parent[i] < 0) continue;\n            if(parent[i] == root) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num >= 2) se.insert(0);\n        return se;\n    }\n};\n\nsigned main() {\n    int V, E; cin >> V >> E;\n    graphLink<int> gr(V);\n    rep(i,0,E) {\n        int s, t; cin >> s >> t;\n        gr.G[s].push_back(Edge<int>(t, 1));\n        gr.G[t].push_back(Edge<int>(s, 1));\n    }\n    gr.dfs(0);\n    sort(gr.bridges.begin(), gr.bridges.end());\n    for(auto x : gr.bridges) printf(\"%lld %lld\\n\", x.first, x.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 100010\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef vector<ii>   vii;\ntypedef vector<int>   vi;\nconst int DFS_WHITE = -1; // unvisited\nconst int DFS_BLACK =  1; // visited\n\nint V,E;\nint dfsNumberCounter,rootChildren,dfsRoot;\nvi dfs_num,dfs_low,dfs_parent,articulation_vertex;\nvii AdjList[MAX_V];// ii(neighbor,weight)\n\nvii ans;\n\nvoid articulationPointAndBridge(int u)\n{\n  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;\n  for(int j=0;j<(int)AdjList[u].size();j++)\n    {\n      ii v = AdjList[u][j];\n      if(dfs_num[v.first] == DFS_WHITE)\n\t{\n\t  dfs_parent[v.first] = u;\n\t  if(u == dfsRoot)rootChildren++;\n\n\t  articulationPointAndBridge(v.first);\n\n\t  if(dfs_low[v.first] >= dfs_num[u])\n\t    articulation_vertex[u] = true;\n\t  if(dfs_low[v.first] >  dfs_num[u])\n\t    ans.push_back(ii(min(u,v.first),max(u,v.first)));\n\t    //printf(\"Edge (%d,%d) is a bridge\\n\",u,v.first);\n\t  dfs_low[u] = min(dfs_low[u],dfs_low[v.first]);\n\n\t}\n      else if(v.first != dfs_parent[u])\n\tdfs_low[u] = min(dfs_low[u],dfs_num[v.first]);\n    }\n}\n\nvoid compute()\n{\n  dfsNumberCounter = 0; dfs_num.assign(V,DFS_WHITE); dfs_low.assign(V,0);\n  dfs_parent.assign(V,0); articulation_vertex.assign(V,0);\n  //puts(\"Bridges:\");\n  for(int i = 0; i < V; i++)\n    if(dfs_num[i] == DFS_WHITE)\n      {\n\tdfsRoot = i; rootChildren = 0;\n\tarticulationPointAndBridge(i);\n\tarticulation_vertex[dfsRoot] = (rootChildren > 1);// special case\n      }\n  //puts(\"Articulation Points\");\n  //for(int i = 0; i < V; i++)\n  //if(articulation_vertex[i])\n      //printf(\"Vertex %d\\n\",i);\n}\n\nint main()\n{\n  scanf(\"%d%d\",&V,&E);\n  rep(i,V)AdjList[i].clear();\n  rep(i,E)\n    {\n      int s,t;\n      scanf(\"%d%d\",&s,&t);\n      AdjList[s].push_back(ii(t,1));\n      AdjList[t].push_back(ii(s,1));\n    }\n\n  ans.clear();\n  compute();\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  rep(i,ans.size())cout << ans[i].first << \" \" << ans[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\nusing namespace std;\nclass LowLink{\nprivate:\n    vector<vector<int>> Graph;\n    vector<bool> visited; \n    vector<int> order, low;\n\n    void dfs(int u = 0 , int ord = 0, int par = -1){\n        visited[u] = true;\n        order[u] = ord;\n        low[u] = ord;\n        bool is_articulation = false;\n        int deg = 0;\n        for(int& v : Graph[u]){\n            if(par == v) continue;\n            if(visited[v] == false){\n                deg++;\n                dfs(v, ord+1, u);\n                is_articulation |= (par != -1 && order[u] <= low[v]);\n                low[u] = min(low[u], low[v]);\n                if(order[u] < low[v]) bridge.emplace_back(make_pair(min(u, v), max(u,v)));\n            } else {\n                low[u] = min(low[u], order[v]);\n            }\n        }\n        is_articulation |= (par == -1 && deg > 1);\n        if(is_articulation) articulation.emplace_back(u);\n    }\npublic:\n    vector<int> articulation;\n    vector<pair<int, int>> bridge;\n    LowLink() = delete;\n    LowLink(vector<vector<int>>& G) :  Graph(G){\n        visited.assign(Graph.size(), false);\n        order.resize(Graph.size());\n        low.resize(Graph.size());\n        dfs(); \n    }\n\n    vector<int> get_articulation(){\n        return articulation;\n    }\n\n    vector<pair<int,int>> get_bridge(){\n        return bridge;\n    }\n};\n\n#include<iostream>\nint main(){\n    int V, E, u, v;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for(int i = 0; i < E; i++){\n        cin >> u >> v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    LowLink lowlink(G);\n    auto bridges = lowlink.get_bridge();\n    sort(bridges.begin(), bridges.end());\n    for(auto& v : bridges){\n        cout << v.first << \" \" << v.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nusing UnweightedGraph = vector<vector<int>>;\n\nstruct LowLink {\n    vector<pair<int, int>> brs; // 橋\n    vector<int> aps; // 関節点\n\n    const UnweightedGraph &g;\n    vector<int> ord, low;\n\n    LowLink(const UnweightedGraph &g) : g(g) {}\n\n    void dfs(int u, int &k, int p = -1) {\n        low[u] = ord[u] = k++;\n\n        // 関節点の判定に使用\n        int num_of_child = 0;\n        bool exist = false;\n\n        for (auto &v : g[u]) if (v != p) {\n            if (ord[v] >= 0) {\n                low[u] = min(low[u], ord[v]);   // back edge\n                continue;\n            }\n            dfs(v, k, u);\n            low[u] = min(low[u], low[v]);   // forward edge\n            if (ord[u] < low[v]) brs.emplace_back(min(u, v), max(u, v));\n            if (ord[u] <= low[v]) exist = true;\n            ++num_of_child;\n        }\n        if ((p == -1 && num_of_child > 1) || (p != -1 && exist))\n            aps.emplace_back(u);\n    }\n\n    // 前処理\n    void build() {\n        const int n = g.size();\n        ord.assign(n, -1);\n        low.resize(n);\n        int k = 0;\n        for (int i = 0; i < n; ++i) {\n            if (ord[i] < 0) dfs(i, k);\n        }\n        sort(brs.begin(), brs.end());\n        sort(aps.begin(), aps.end());\n    }\n};\n\nvoid _main() {\n    int V, E;\n    cin >> V >> E;\n    UnweightedGraph g(V);\n    REP(i, E) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    LowLink ll(g);\n    ll.build();\n    for (auto br : ll.brs) {\n        cout << br << endl;\n    }\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i'))\n            freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o'))\n            freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 橋を求める\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD 1000000007\n#define INF 1e9\n#define INFL 1e12\n \ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntypedef pair<int, bool> edge;\n\nint v, e;\nvector<vector<edge>> G;\nvector<int> ord, low;\nset<pair<int, int>> ans;\nvector<bool> seen;\nint k;\nint zero_degree;\n\nvoid dfs(int u, int r){\n    // pr(u);\n    seen[u] = true;\n    ord[u] = k; k++;\n    low[u] = ord[u];\n    for(edge &ed: G[u]){\n        int v = ed.first;\n        if(v==r) continue;\n        if(!seen[v]){\n            ed.second = true;\n            dfs(v, u);\n            chmin(low[u], low[v]);\n            if(ord[u] < low[v]){\n                if(u<=v) ans.insert({u, v});\n                else ans.insert({v, u});\n            }\n        }else if(ed.second==false){\n            chmin(low[u], ord[v]);\n        }\n    }\n}\n \nint main()\n{\n    cin >> v >> e;\n    G.resize(v); ord.resize(v), low.resize(v); seen.resize(v);\n\n    int a, b;\n    rep(i, e){\n        cin >> a >> b;\n        G[a].push_back({b, false});\n        G[b].push_back({a, false});\n    }\n    rep(i, v) seen[i]=false;\n    int k = 0;\n\n    dfs(0, 0 );\n\n    // rep(i, v) seen[i] = false;\n    // dfs_search(0);\n\n    // int tmp=0;\n    // for(edge ed: G[0]){\n    //     if(ed.second) tmp++;\n    // }\n    // if(tmp>1) ans.insert(0);\n\n    for(pair<int, int> c: ans){\n        printf(\"%d %d\\n\", c.first, c.second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        const auto is_bridge = [&](const int i, const int j) { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; };\n        const auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (is_bridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        const auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or is_bridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "class biconnected{\npublic:\n\tvector<vector<int> > G ,graph;\n\tvector<int> check,ord,low,cmp;\n\tvector<P> bridge;\n\tvector<bool> visit;\n\tint V;\n\tbiconnected(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V);\n\t\tcheck.resize(V),ord.resize(V),low.resize(V);\n\t\tcmp.resize(V),visit.resize(V,false);\n\t}\n\tvoid build(){\n\t\tint id = 0;\n\t\trep(i,V){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(i,-1,id);\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,int p,int &k)\n\t{\n\t\tvisit[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\trep(i,(int)G[v].size()){\n\t\t\tint w = w;\n\t\t\tif(!visit[w]){\n\t\t\t\tdfs(w,v,k);\n\t\t\t\tlow[v] = min(low[v],low[w]);\n\t\t\t\tif(ord[v] < low[w]){\n\t\t\t\t\tbridge.push_back(P(v,w));\n\t                check[v][i].second = 1;\n\t                check[w][check[v][i].first].second = 1;\n\t\t\t\t}\n\t\t\t//(v,w)????????????\n\t\t\t}else if(w != p){\n\t\t\t\tlow[v] = min(low[v],ord[w]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid add_edge(int u,int v)\n\t{\n\t    G[u].push_back(v),G[v].push_back(u);\n\t    check[u].push_back(P((int)check[v].size(),0));\n\t    check[v].push_back(P((int)check[u].size()-1,0));\n\t}\n\tvoid restrict_dfs(int u,int p,int kind,queue<int>& que)\n\t{\n\t    visit[u] = true;\n\t    cmp[u] = kind;\n\t    rep(i,(int)G[u].size()){\n\t\t\tint w = G[u][i];\n\t        if(check[u][i].second){\n\t            if(!visit[w]){\n\t                que.push(w);\n\t            }\n\t        }else if(!visit[w]){\n\t            restrict_dfs(w,u,kind,que);\n\t        }\n\t    }\n\t}\n\t//????????°?????????\n\tint make_bcgraph()\n\t{\n\t\tgraph.resize(V);\n\t    int num = 0;\n\t    rep(i,node_size){\n\t        if(!visit[i]){\n\t            dfs(i,-1,num);\n\t        }\n\t    }\n\t    fill(visit,visit+node_size,false);\n\t    int kind = 0;\n\t    rep(i,node_size){\n\t        if(!visit[i]){\n\t            queue<int> que;\n\t            que.push(i);\n\t            while(!que.empty()){\n\t                int p = que.front();\n\t                que.pop();\n\t                restrict_dfs(p,-1,kind,que);\n\t                kind++;\n\t            }\n\t        }\n\t    }\n\t    rep(i,(int)bridge.size()){\n\t        int a = cmp[bridge[i].first];\n\t        int b = cmp[bridge[i].second];\n\t        graph[a].push_back(b), graph[b].push_back(a);\n\t    }\n\t    return kind;\n\t}\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n#include <vector>\n#include <set>\n#include <functional>\nusing namespace std;\n\nvector<pair<int,int>> lowlink(const vector<vector<int>>& G){\n  vector<pair<int,int>> bridge;\n  //vector<int> articulation;\n  int n = G.size();\n  vector<int> used(n,false),ord(n,0),low(n,0);\n  function<int(int,int,int)> dfs = [&](int v,int k,int f){\n    used[v] = true;\n    ord[v] = k++;\n    low[v] = ord[v];\n    int cnt = 0;\n    bool is_articulation = false;\n    for(auto & to : G[v]){\n      if(!used[to]){\n        cnt++;\n        k = dfs(to,k,v);\n        low[v] = min(low[v] , low[to]);\n        is_articulation |= (f != -1) && low[to] >= ord[v]; \n        if(ord[v] < low[to]) bridge.push_back({min(v,to),max(v,to)});\n      }\n      else if(to != f){\n        low[v] = min(low[v] , ord[to]);\n      }\n    }\n    is_articulation |= f == -1 && cnt > 1;\n    //if(is_articulation) articulation.push_back(v);\n    return k;\n  };\n  dfs(0,0,-1);\n  return bridge;\n}\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  vector<vector<int>> G(N);\n\n  rep(i,0,M - 1){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  auto ans = lowlink(G);\n\n  sort(all(ans));\n  for(auto p : ans){\n    cout << p.first << \" \" << p.second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Graph {\n    Graph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n    const int V;\n};\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const Graph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            if (ord[i] == -1) {\n                bridge_dfs(g_, i);\n            }\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const\n    {\n        return bridge;\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    const vector<pair<int, int>> getBridge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? (ord[i] < low[j]) : (ord[j] < low[i]);\n    }\n\nprivate:\n    void bridge_dfs(const Graph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const int to : g_.edge[s]) {\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n                if (isBridge(s, to)) {\n                    bridge.push_back(make_pair(s, to));\n                }\n            }\n        }\n    }\n\n    void comp_dfs(const Graph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const int to : g_.edge[s]) {\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n\n    int num;\n    int comp_num;\n    const int size;\n    vector<pair<int, int>> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) {\n            swap(s, t);\n        }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) {\n            swap(p.first, p.second);\n        }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nvector<Edge> g[100001];\nint prenum[100001],parent[100001],lowest[100001],visited[100001],cnt = 1,child[100001];\n\nvoid Articulation_Points(int k,int p){\n  visited[k] = true;\n  prenum[k] = cnt;\n  lowest[k] = cnt;\n  ++cnt;\n  for (auto&& n : g[k]) {\n    if(!visited[n.to]){\n      parent[n.to] = k;\n      Articulation_Points(n.to,k);\n      child[k]++;\n      lowest[k] = min(lowest[k],lowest[n.to]);\n    }\n    else if(n.to != p){\n      lowest[k] = min(lowest[k],prenum[n.to]);\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n ,a,b,e;\n  cin >> n >> e;\n  rep(i,e){\n    cin >> a >> b;\n    g[a].push_back({b,0LL});\n    g[b].push_back({a,0LL});\n  }\n  Articulation_Points(0,-1);\n  set<int> art;\n  set<pair<int,int>> ans;\n  int np = 0;\n  for (int i = 1; i < n; i++) {\n    int p = parent[i];\n    if(p == 0){\n      ++np;\n    }\n    else{\n      if(prenum[p] <= lowest[i]){\n        art.insert(p);\n      }\n    }\n  }\n  if(np > 1) art.insert(0);\n  rep(i,n){\n    if(g[i].size() == 1)\n      art.insert(i);\n  }\n  rep(i,n){\n    for (auto&& k : g[i]) {\n      if(art.find(i) != art.end() && art.find(k.to) != art.end() && prenum[k.to] <= lowest[i]){\n        if(i < k.to){\n          ans.insert({i,k.to});\n        }\n        else\n          ans.insert({k.to,i});\n      }\n    }\n  }\n  for (auto&& k : ans) {\n    std::cout << k.fi << ' ' << k.se << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[cmp[p]].pb(x+1);G2[x+1].pb(cmp[p]);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));x++;\n\t\t\t}else chmax(mx, build(G[p][i], cmp[p]));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nvector<vector<int> > G, G2;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tG.resize(n);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t\tG[v].pb(u);G[u].pb(v);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G2 = low.G2;\n\tvector<int> cmp = low.cmp;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tint from = cmp[i], to = cmp[G[i][j]];\n\t\t\tif(from != to and i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\tZIP(ans);\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <limits>\n#include <set>\n#include <algorithm>\n\ntemplate <typename F>\nauto fix(F&& f) {\n\treturn [f = std::forward<F>(f)](auto&&... args) {\n\t\treturn f(f, std::forward<decltype(args)>(args)...);\n\t};\n}\n\nint main() {\n\tint V, E;\n\tstd::cin >> V >> E;\n\n\tstd::vector<std::vector<int>> edges(V);\n\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\n\t\tedges[s].push_back(t);\n\t\tedges[t].push_back(s);\n\t}\n\n\tstd::set<std::pair<int, int>> bridges;\n\n\tconstexpr int Inf = std::numeric_limits<int>::max();\n\tstd::vector<int> pre(V, Inf), low(V, Inf);\n\n\tfix([&](auto dfs, int x, int prev, int count) -> int {\n\t\tpre[x] = low[x] = count;\n\t\t\n\t\tfor (auto&& t : edges[x]) {\n\t\t\tif (pre[t] != Inf) {\n\t\t\t\tif (t != prev)\n\t\t\t\t\tlow[x] = std::min(low[x], low[t]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcount = dfs(dfs, t, x, count + 1);\n\n\t\t\t\tlow[x] = std::min(low[x], low[t]);\n\n\t\t\t\tif (low[t] == pre[t])\n\t\t\t\t\tbridges.insert(std::minmax(x, t));\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t})(0, -1, 0);\n\n\tfor (auto&& b : bridges)\n\t\tstd::cout << b.first << \" \" << b.second << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct edge{\n    int f, t;\n};\n\nconst int V_MAX = (int)1e5 + 10;\nvector<int> edges[V_MAX];\nint ord[V_MAX];\nint low[V_MAX];\nbool used_v[V_MAX];\nvector<edge> ans;\n\nbool comp(edge e1, edge e2){\n    if(e1.f == e2.f){\n        return e1.t < e2.t;\n    } else {\n        return e1.f < e2.f;\n    }\n}\n\nvoid dfs(int u, int prev, int k){\n    low[u] = ord[u] = k;\n    k += 1;\n    used_v[u] = true;\n\n    for(int i=0; i<edges[u].size(); i++){\n        int next = edges[u][i];\n\n        if(not used_v[next]){\n            dfs(next, u, k);\n            low[u] = min(low[u], low[next]);\n\n            if(low[next] > ord[u]){\n                edge e;\n                e.f = min(u, next); e.t = max(u, next);\n                ans.push_back(e);\n            }\n        } else if(prev != next){\n            low[u] = min(low[u], ord[next]);\n        }\n    }\n    return ;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int v, e; \n    cin >> v >> e;\n\n    for(int i=0; i<e; i++) {\n        int a, b;\n//        scanf(\"%d %d\", &a, &b);\n        cin >> a >> b;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    dfs(0, -1, 1);\n\n    sort(ans.begin(), ans.end(), comp);\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i].f << \" \" << ans[i].t << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int> G[100010];\nbool used[100010];\nint par[100010];\nint dep[100010];\nint low[100010];\n\nvoid dfs(int v,int p,int d){\n    used[v] = true;\n    par[v] = p;\n    dep[v] = d;\n    low[v] = d;\n    for(int i = 0 ; i < G[v].size() ; i ++){\n        if(G[v][i] == p)continue;\n        if(used[G[v][i]]){\n            low[v] = min ( low[v] , dep[G[v][i]] );\n        }\n        else {\n            dfs(G[v][i],v,d+1);\n            low[v] = min ( low[v] , low[G[v][i]] );\n        }\n    }\n}\n\nint main(){\n    int V,E;\n    int s[100010],t[100010];\n    scanf(\"%d%d\",&V,&E);\n    for(int i = 0 ; i < E ; i ++){\n        scanf(\"%d%d\",&s[i],&t[i]);\n        G[s[i]].push_back(t[i]);\n        G[t[i]].push_back(s[i]);\n        if(s[i] > t[i])swap(s[i],t[i]);\n    }\n    for(int i = 0 ; i < 100010 ; i ++){\n        used[i] = false;\n    }\n    dfs(0,-1,0);\n    \n    vector<pair<int,int>> ans;\n    for(int i = 0 ; i < E ; i ++){\n        if(par[s[i]] == t[i]){\n            if(low[s[i]] > dep[t[i]])ans.push_back(pair<int,int>(s[i],t[i]));\n        }\n        else if(par[t[i]] == s[i]){\n            if(low[t[i]] > dep[s[i]])ans.push_back(pair<int,int>(s[i],t[i]));\n        }\n    }\n    sort(ans.begin(),ans.end());\n    for(int i = 0 ; i < ans.size() ; i ++){\n        printf(\"%d %d%c\",ans[i].first,ans[i].second,10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n// typedef __int128_t Int;\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n// Bridges in a undirected graph\nstruct Bridge {\n  int V;\n  vector<vector<int>> G;\n  vector<int> visited, lowest, parent, prenum;\n  Bridge() {}\n  Bridge(int V) : V(V), G(V), visited(V), prenum(V), parent(V), lowest(V) {}\n  void add_edge(int s, int t) {\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  void dfs(int cur, int prev, vector<pair<int, int>> &b) {\n    static int time = 0;\n    visited[cur] = true;\n    prenum[cur] = lowest[cur] = ++time;\n    for (auto next : G[cur]) {\n      if (not visited[next]) {\n        parent[next] = cur;\n        dfs(next, cur, b);\n        lowest[cur] = min(lowest[cur], lowest[next]);\n        if (lowest[next] > prenum[cur]) {\n          b.push_back(make_pair(cur, next));\n        }\n      } else if (next != prev) {\n        lowest[cur] = min(lowest[cur], lowest[next]);\n      }\n    }\n  }\n  vector<pair<int, int>> bridges() {\n    fill(all(visited), false);\n    vector<pair<int, int>> b;\n    for (int i = 0; i < V; i++) {\n      if (not visited[i]) {\n        dfs(i, -1, b);\n      }\n    }\n    return b;\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int V, E;\n  cin >> V >> E;\n  Bridge g(V);\n  loop(E) {\n    int s, t;\n    cin >> s >> t;\n    g.add_edge(s, t);\n  }\n  auto b = g.bridges();\n  for (auto e : b) {\n    if (e.first > e.second)\n      swap(e.first, e.second);\n  }\n  sort(all(b));\n  for (auto e : b) {\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) { g[s].emplace_back(s, d, w); }\n\n\n//????´?????????£?????°????????????\nEdges bridges(const Graph &g, int root = 0) {\n\t/*\n\te(u, v) ????????§?????? <=> ord[u] >= low[v]\n\te(u, v) ?????? <=> ord[u] < low[v]\n\t*/\n\tint n = g.size();\n\tvector<bool> vis(n);\n\tvector<int> ord(n);\n\tvector<int> low(n);\n\tEdges bri;\n\tint o = 0;\n\tfunction<void(int, int)> dfs = [&](int u, int p) {\n\t\tif (vis[u])return;\n\t\tvis[u] = true;\n\t\tord[u] = o++;\n\t\tlow[u] = ord[u];\n\t\tbool is_art = false;\n\t\tfor (auto &e : g[u]) {\n\t\t\tif (!vis[e.d]) {\n\t\t\t\tdfs(e.d, u);\n\t\t\t\tchmin(low[u], low[e.d]);\n\t\t\t\tif (ord[u] < low[e.d])bri.emplace_back(u, e.d);\n\t\t\t}\n\t\t\telse if (e.d != p) {\n\t\t\t\tchmin(low[u], ord[e.d]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(root, -1);\n\treturn bri;\n}\n\n//s <= d ?????? s1 <= s2 ?????? d1 <= d2 ??????????????????????????????\nvoid sort(Edges &es) {\n\tfor (auto &e : es)\n\t\tif (e.s > e.d)\n\t\t\tswap(e.s, e.d);\n\tsort(es.begin(), es.end(), [](Edge e1, Edge e2) {return e1.s == e2.s ? e1.d < e2.d : e1.s < e2.s; });\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M; cin >> N >> M;\n\tGraph g(N);\n\trep(i, 0, M) {\n\t\tint s, t; cin >> s >> t;\n\t\tadd_edge(g, s, t);\n\t}\n\tEdges bri = bridges(g);\n\tsort(bri);\n\trep(i, 0, bri.size()) {\n\t\tcout << bri[i].s << \" \" << bri[i].d << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint mark[maxn];\nint par[maxn];\nint hig[maxn];\nint zir[maxn];\nint dp[maxn];\nint minDpKids[maxn];\nint minHig[maxn];\n\nvector<int> adj[maxn];\nvector< pair<int,int> > output;\n\nvoid dfs (int v) {\n    mark[v] = 1;\n    zir[v] = 1;\n\n    for (int u : adj[v] ) {\n        if ( !mark[u] ) {\n            par[u] = v;\n            hig[u] = hig[v] + 1;\n            dfs(u);\n            zir[v] += zir[u];\n            dp[v] = min (dp[v] , dp[u]);\n        }\n        else if ( u != par[v] && hig[u] < hig[v]) {\n            dp[v] = min(hig[u] , dp[v]);\n        }\n    }\n\n    if (dp[v] >= hig[v] && dp[v] + hig[v] != 0){\n\n        pair<int,int> outy (min (par[v] , v) , max (par[v] , v)) ;\n        output.push_back(outy);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n , m;\n    cin >> n >> m;\n\n    for(int i=1; i<n; i++)\n        dp[i] = 100005;\n\n    for (int i = 0; i<m; i++) {\n        int u, v;\n        cin >> u >> v;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(0);\n\n    sort (output.begin() , output.end());\n\n    for(int i = 0; i < output.size(); i++)\n        cout << output[i].first << ' ' << output[i].second << endl;\n\n    return 0;\n}\n\n/*\n\n4 4\n0 1\n0 2\n1 2\n2 3\n----------\n5 4\n0 1\n1 2\n2 3\n3 4\n----------\n6 5\n0 1\n0 2\n0 3\n1 4\n4 5\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<set>\n\nusing namespace std;\n\nstruct Edge {\n\tint from, to; //if you want cost, etc., you should care about the \"emplace_back\"(line36,line118).\n\tEdge(int f, int t) {\n\t\tfrom = f;\n\t\tto = t;\n\t}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nvector<int>ArticulationPoint(const Graph& g) {\n\tint n = g.size(), idx = 0;\n\tvector<int>low(n), ord(n), art;\n\tfunction<void(int)>dfs = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[w] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v]))\n\t\t\t\t\tart.push_back(v);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\treturn art;\n}\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nvector<int> kosaraju(const Graph& g) {\n\tint n = g.size(), sz = 0;\n\tGraph rg(n);\n\tvector<int>stk, cmp(n, -1), added(n), visited(n), ord(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es)rg[e.to].emplace_back(e.to, e.from);\n\t\tsz += es.size();\n\t}\n\tstk.resize(n + sz);\n\tsz = 0;\n\tfor (int i = 0; i<n; ++i) {\n\t\tif (visited[i])continue;\n\t\tint s = 0;\n\t\tstk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : g[v]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tif (!visited[to]) {\n\t\t\t\t\tstk[s++] = to;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pushed)continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) {\n\t\t\t\tadded[t] = true;\n\t\t\t\tord[n - ++sz] = t;\n\t\t\t}\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1)continue;\n\t\tint s = 0;\n\t\tstk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s];\n\t\t\tcmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint t = e.to;\n\t\t\t\tif (cmp[t] == -1)stk[s++] = t;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tGraph g(V);\n\tfor (int i = 0; i<E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].emplace_back(s, t);\n\t\tg[t].emplace_back(t, s);\n\t}\n\tEdges es = bridge(g).second;\n\tset<pair<int, int>>s;\n\tfor (auto x : es) {\n\t\tif (x.from > x.to)continue;\n\t\ts.insert(pair<int, int>(x.from, x.to));\n\t}\n\tfor (auto x : s) {\n\t\tcout << x.first << \" \"  << x.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nvector<Edge> g[100001];\nint prenum[100001],parent[100001],lowest[100001],visited[100001],cnt = 1,child[100001];\n\nvoid Articulation_Points(int k,int p){\n  visited[k] = true;\n  prenum[k] = cnt;\n  lowest[k] = cnt;\n  ++cnt;\n  for (auto&& n : g[k]) {\n    if(!visited[n.to]){\n      parent[n.to] = k;\n      Articulation_Points(n.to,k);\n      child[k]++;\n      lowest[k] = min(lowest[k],lowest[n.to]);\n    }\n    else if(n.to != p){\n      lowest[k] = min(lowest[k],prenum[n.to]);\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n ,a,b,e;\n  cin >> n >> e;\n  rep(i,e){\n    cin >> a >> b;\n    g[a].push_back({b,0LL});\n    g[b].push_back({a,0LL});\n  }\n  Articulation_Points(0,-1);\n  set<int> art;\n  set<pair<int,int>> ans;\n  int np = 0;\n  for (int i = 1; i < n; i++) {\n    int p = parent[i];\n    if(p == 0){\n      ++np;\n    }\n    else{\n      if(prenum[p] <= lowest[i]){\n        art.insert(p);\n      }\n    }\n  }\n  if(np > 1) art.insert(0);\n  rep(i,n){\n    if(g[i].size() == 1)\n      art.insert(i);\n  }\n  rep(i,n){\n    for (auto&& k : g[i]) {\n      if(art.find(i) != art.end() && art.find(k.to) != art.end()){\n        if(i < k.to){\n          ans.insert({i,k.to});\n        }\n        else\n          ans.insert({k.to,i});\n      }\n    }\n  }\n  for (auto&& k : ans) {\n    std::cout << k.fi << ' ' << k.se << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n  \n#include <iostream>\n#include <vector>\n#include <string>\n#include <functional>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e9;\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    vector<pair<int, int>> bridge;\n    vector<int> depth(n, INF), ub(n, INF);\n    function<void(int, int, int)> dfs = [&](int v, int p, int d) {\n        depth[v] = d;\n        ub[v] = d;\n        for(int nv : adj[v]) {\n            if(nv == p) continue;\n            if(depth[nv] != INF) {\n                ub[v] = min(ub[v], depth[nv]);\n                continue;\n            }\n            dfs(nv, v, d + 1);\n            ub[v] = min(ub[v], ub[nv]);\n            if(ub[nv] > depth[v])\n                bridge.emplace_back(min(v, nv), max(v, nv));\n        }\n    };\n    dfs(0, -1, 0);\n    sort(bridge.begin(), bridge.end());\n    for(auto p : bridge) cout << p.first << ' ' << p.second << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct LowLink\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< int > used, ord, low, parent;\n\n  LowLink(size_t v) : g(v), used(v, 0), ord(v), low(v), uf(v), parent(v, -1) {}\n\n  virtual void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        parent[to] = idx;\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  void dfs()\n  {\n    int k = 0;\n    dfs(0, k);\n  }\n};\n\nstruct ArticulationPoints : LowLink\n{\n  ArticulationPoints(size_t v) : LowLink(v) {}\n\n  vector< int > build()\n  {\n    LowLink::dfs();\n    vector< int > vs;\n    int sum = 0;\n    for(int i = g.size() - 1; i >= 1; i--) {\n      if(parent[i] == 0) ++sum;\n      else if(ord[parent[i]] <= low[i]) vs.push_back(parent[i]);\n    }\n    if(sum > 1)vs.push_back(0);\n    sort(begin(vs), end(vs));\n    vs.erase(unique(begin(vs), end(vs)), end(vs));\n    return (vs);\n  }\n};\n\nstruct BiConnectedComponents : LowLink\n{\n  vector< pair< int, int > > edges;\n  vector< int > comp;\n\n  BiConnectedComponents(size_t v) : LowLink(v), comp(v) {}\n\n  void add_edge(int x, int y)\n  {\n    LowLink::add_edge(x, y);\n    edges.push_back(minmax(x, y));\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  vector< pair< int, int > > build(vector< vector< int > > &t)\n  {\n    LowLink::dfs();\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    vector< pair< int, int > > vs;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      vs.emplace_back(e.first, e.second);\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n    sort(begin(vs), end(vs));\n    return (vs);\n  }\n};\n\n\nvoid solve()\n{\n  int V, E;\n  cin >> V >> E;\n  BiConnectedComponents graph(V);\n  vector< vector< int > > malta;\n  for(int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph.add_edge(s, t);\n  }\n  for(auto &p : graph.build(malta)) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\n\n\nstruct LowLink{\n    vector<vector<int>>& edges;\n    // 関節点\n    vector<int> art;\n    vector<pair<int,int>> bridge;\n\n    vector<int> used, ord, low;\n    int k;\n\n    void dfs(int idx, int par){\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_art = false;\n        int cnt = 0;\n        for(auto& to : edges[idx]){\n            if(ord[to] == -1){\n                ++cnt;\n                dfs(to, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_art |= par != -1 && low[to] >= ord[idx];\n                if(ord[idx] < low[to])\n                    bridge.emplace_back(idx, to);\n            }else if(to != par)\n                low[idx] = min(low[idx], ord[to]);\n        }\n        is_art |= (par == -1 && cnt > 1);\n        if(is_art)\n            art.emplace_back(idx);\n    }\n\n    LowLink(vector<vector<int>>& edges) :\n        edges(edges),\n        ord(edges.size(), -1),\n        low(edges.size(), 0),\n        k(0)\n    {\n        for(int i = 0; i < edges.size(); ++i)\n            if(ord[i] == -1)\n                dfs(i, -1);\n        for(auto& b : bridge)\n            b = make_pair(min(b.first, b.second), max(b.first, b.second));\n        sort(art.begin(), art.end());\n        sort(bridge.begin(), bridge.end());\n    }\n};\n\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int,int>> v(m);\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < m; ++i){\n        vector<int> l(2);\n        for(auto& x : l)\n            cin >> x;\n        sort(l.begin(), l.end());\n        v[i] = make_pair(l.front(), l.back());\n        edges[l[0]].emplace_back(l[1]);\n        edges[l[1]].emplace_back(l[0]);\n    }\n    LowLink ll(edges);\n    for(auto& x : ll.bridge)\n        cout << x.first << \" \" << x.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u, Edges& brdg, vector< vector<int> >& tecomp, stack<int>& roots, stack<int>& S, vector<bool>& inS, vector<int>& num, int& time)\n{\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  vrep(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 1));\n    tecomp.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      tecomp.back().push_back(w);\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\n\nvoid Bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp)\n{\n  const int n = g.size();\n  vector<int> num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  rep(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint V, E;\nint s, t;\n\nint main()\n{\n  cin >> V >> E;\n  Graph g(V);\n  Edges brdg;\n  vector<vi> tecomp;\n  rep(i, E){\n    cin >> s >> t;\n    g[s].pb(Edge(s, t, 1));\n    g[t].pb(Edge(t, s, 1));\n  }\n\n  Bridge(g, brdg, tecomp);\n\n  sort(ALL(brdg));\n\n  vrep(v, brdg) if(v->src > v->dst) swap(v->src, v->dst);\n  vrep(v, brdg) cout << v->src << \" \" << v->dst << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 100005\n\nint n, m;\n\nclass edge\n{\n\tprivate:\n\t\tint fr, to;\n\t\t\n\tpublic:\t\n\t\tedge(void) {};\n\t\tedge(int u, int v)\n\t\t{\n\t\t\tfr = min(u, v);\n\t\t\tto = max(u, v);\n\t\t}\n\t\t\n\t\tint u(void)\n\t\t{\n\t\t\treturn fr;\n\t\t}\n\t\t\n\t\tint v(void)\n\t\t{\n\t\t\treturn to;\n\t\t}\n\t\t\n\t\tint another(int one)\n\t\t{\n\t\t\treturn one == fr ? to : fr;\n\t\t}\n\t\t\n\t\tfriend bool operator < (const edge &a, const edge &b)\n\t\t{\n\t\t\treturn a.fr != b.fr ? a.fr < b.fr : a.to < b.to;\n\t\t}\n}E[N];\n\nvector<int> to[N];\n\nvector<edge> answer;\n\nint dfn[N], low[N], tim;\n\nvoid tarjan(int u, int f)\n{\n\tdfn[u] = low[u] = ++tim;\n\t\n\tfor (auto i : to[u])\n\t\tif (i != f)\n\t\t{\n\t\t\tedge e = E[i];\n\t\t\tint v = e.another(u);\n\t\t\t\n\t\t\tif (!dfn[v])\n\t\t\t{\n\t\t\t\ttarjan(v, i);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlow[u] = min(low[u], dfn[v]);\n\t\t}\n\t\t\n\tif (u && dfn[u] <= low[u])\n\t\tanswer.push_back(E[f]);\n}\n\nsigned main(void) \n{\n\tcin >> n >> m;\n\t\n\tfor (int u, v; m--; )\n\t{\n\t\tcin >> u >> v;\n\t\tE[m] = edge(u, v);\n\t\tto[u].push_back(m);\n\t\tto[v].push_back(m);\n\t}\n\t\n\ttarjan(0, -1);\n\t\n\tsort(begin(answer), end(answer));\n\t\n\tfor (auto e : answer)\n\t\tcout << e.u() << \" \" << e.v() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nvector<int> biconnected_component(const graph& G) {\n\tint n = G.size(), idx = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), stk, rts(n), cmp(n);\n\tvector<bool> onS(n);\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk.push_back(v);\n\t\tonS[v] = true;\n\t\trts[t++] = v;\n\t\tfor (int w : G[v]) {\n\t\t\tif (ord[w] == -1) dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[rts[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif (v == rts[t - 1]) {\n\t\t\twhile (true) {\n\t\t\t\tint w = stk.back(); stk.pop_back();\n\t\t\t\tonS[w] = false; cmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; ++u) {\n\t\tif (ord[u] == -1) dfs(u, -1);\n\t}\n\treturn cmp;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tgraph G(n);\n\tvector<pair<int, int>> es;\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tif (s > t) swap(s, t);\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t\tes.emplace_back(s, t);\n\t}\n\tauto bc = biconnected_component(G);\n\tsort(es.begin(), es.end());\n\tfor (auto& p : es) if (bc[p.first] != bc[p.second]) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n    int s;\n    int t;\n    bool operator < (const Edge& tgt) const {\n\tif( s == tgt.s )\n\t    return t < tgt.t;\n\treturn s < tgt.s;\n    }\n};\n\n\n\nint Bridges_dfs(const vector<vector<Edge>>& g, vector<int>& order,\n\t\tvector<Edge>& ans, int u, int& cnt_v, Edge pre) {\n    if( order[u] != -1 ) { //?¨????????????¨?????????\n\treturn order[u];\n    }\n    // ??????????¨???????\n    order[u] = cnt_v; cnt_v++;\n    // ??£??\\???????????????\n    int min_v = order[u];\n    for(auto e : g[u]) { // u ?????????????????????????????????????????????\n\tif( e.t == pre.s and e.s == pre.t ) continue; \n\tmin_v = min(Bridges_dfs(g, order, ans, e.t, cnt_v, e), min_v);\n    }\n    if( min_v == order[u] and pre.s != -1 ) {\n\tif(pre.s > pre.t) pre = Edge{pre.t,pre.s};\n\tans.push_back(pre);\n    }\n    return min_v;\n}\n\nvector<Edge> Bridges(const vector<vector<Edge>>& g) {\n    vector<Edge> ans;\n    const int V = g.size();\n    vector<int> order(V,-1);\n    \n    // 0??????DFS\n    int cnt_v = 0;\n    Edge tmp{-1,-1};\n    Bridges_dfs(g, order, ans, 0, cnt_v, tmp);\n    assert(cnt_v == V); // ??£???????????°?????????????????????\n    return ans;\n}\n\nint main () {\n    int V,E;\n    cin >> V >> E;\n    vector<vector<Edge>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t; \n\tg[s].push_back(Edge{s,t});\n\tg[t].push_back(Edge{t,s});\n    }\n    vector<Edge> ans = Bridges(g);\n    sort(ans.begin(), ans.end());\n    for(auto& e : ans) {\n\tcout << e.s << \" \"<< e.t << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nvector<int> g[300005];\nbitset<300005> vis;\nint tin[300005], low[300005], timer;\nset<pair<int, int>> wtf;\nvoid dfs(int u, int p = -1) {\n  vis[u] = 1;\n  tin[u] = low[u] = timer++;\n  for (int v : g[u]) {\n    if (v == p)\n      continue;\n    if (vis[v]) {\n      low[u] = min(low[u], tin[v]);\n    } else {\n      dfs(v, u);\n      low[u] = min(low[u], low[v]);\n      if (low[v] > tin[u]) {\n        wtf.insert({min(u, v), max(u, v)});\n      }\n    }\n  }\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  for (int i = 0; i < n; i++)\n    if (!vis[i])\n      dfs(i);\n  for (pair<int, int> i : wtf) {\n    cout << i.first << ' ' << i.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    for (int i = 0; i < g[current].size(); i++) {\n      int to = g[current][i];\n      if(node[to].order == -1){\n        dfs(to, current);\n        node[current].min_order =\n          min(node[current].min_order,\n              node[to].min_order);\n      }else{\n        if(previous == to)continue;\n        node[current].min_order =\n          min(node[current].min_order,\n              node[to].min_order);\n      }\n    }\n    if(previous != -1 and node[current].min_order == node[previous].order){\n      brige.insert(pii(current, to));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<int> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//BEGIN CUT HERE\nstruct LowLink{\n  int n,pos;\n  vector<int> ord,low,par,blg,num;\n  vector<vector<int> > G,C,T;\n  vector<vector<pair<int, int> > > E;\n  \n  vector<int> ap;\n  vector<pair<int, int> > bs,cand;\n\n  LowLink(int n):n(n),pos(0),ord(n,-1),low(n),\n                 par(n,-1),blg(n,-1),num(n,1),G(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n\n  void dfs(int v){\n    ord[v]=low[v]=pos++;\n    for(int u:G[v]){\n      if(u==par[v]) continue;      \n      if(ord[u]<ord[v])\n        cand.emplace_back(min(u,v),max(u,v));      \n      if(~ord[u]){\n        low[v]=min(low[v],ord[u]);\n        continue;\n      }\n      par[u]=v;\n      dfs(u);\n      num[v]+=num[u];\n      low[v]=min(low[v],low[u]);\n      if(is_bridge(u,v)) bs.emplace_back(u,v);\n      if(low[u]>=ord[v]){\n        E.emplace_back();\n        while(1){\n          auto e=cand.back();\n          cand.pop_back();\n          E.back().emplace_back(e);\n          if(make_pair(min(u,v),max(u,v))==e) break;          \n        }\n      }\n    }\n  }\n\n  void fill_component(int v){\n    C[blg[v]].emplace_back(v);\n    for(int u:G[v]){\n      if(~blg[u]||is_bridge(u,v)) continue;\n      blg[u]=blg[v];\n      fill_component(u);\n    }\n  }\n\n  void add_component(int v,int &k){\n    if(~blg[v]) return;\n    blg[v]=k++;\n    C.emplace_back();\n    fill_component(v);\n  }\n  \n  int build(){\n    for(int i=0;i<n;i++)\n      if(ord[i]<0) dfs(i);\n    \n    vector<int> cnt(n,0);\n    for(int i=0;i<n;i++){\n      int p=par[i];\n      if(p<0) continue;\n      if(par[p]<0) cnt[p]++;\n      else if(ord[p]<=low[i]) ap.emplace_back(p);\n    }\n    \n    for(int i=0;i<n;i++)\n      if(cnt[i]>1) ap.emplace_back(i);\n\n    sort(ap.begin(),ap.end());\n    ap.erase(unique(ap.begin(),ap.end()),ap.end());\n\n    int k=0;    \n    for(int i=0;i<n;i++) add_component(i,k);\n\n    T.assign(k,vector<int>());    \n    for(auto e:bs){\n      int u=blg[e.first],v=blg[e.second];\n      T[u].emplace_back(v);\n      T[v].emplace_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  int size(int x){\n    return r[find(x)];\n  }\n  int count() const{\n    return num;\n  }\n};\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n};\n\n\ntemplate<typename M>\nstruct Enumeration{\n  static vector<M> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned GRL_3_A(){\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  LowLink G(n);\n  for(int i=0;i<m;i++){\n    int u,v;\n    scanf(\"%d %d\",&u,&v);\n    G.add_edge(u,v);\n  }\n  G.build();\n  auto ap=G.ap;\n  sort(ap.begin(),ap.end());\n  for(int v:ap) printf(\"%d\\n\",v);\n  return 0;\n}\n/*\n  verified on 2019/05/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=jp\n*/\n\nsigned GRL_3_B(){\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  \n  LowLink G(n);\n  for(int i=0;i<m;i++){\n    int u,v;\n    scanf(\"%d %d\",&u,&v);\n    G.add_edge(u,v);\n  }\n  G.build();\n  \n  auto bs=G.bs;\n  for(auto &e:bs)\n    if(e.first>e.second) swap(e.first, e.second);\n  \n  sort(bs.begin(),bs.end());\n  for(auto e:bs) printf(\"%d %d\\n\",e.first, e.second);\n  \n  return 0;\n}\n/*\n  verified on 2019/03/23\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/\n\nsigned AOJ_0377(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  int n,m;\n  cin>>n>>m;\n  LowLink bg(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    bg.add_edge(a,b);\n  }\n  int k=bg.build();\n  auto& G=bg.T;\n  \n  vector<int> c(k);\n  for(int i=0;i<k;i++) c[i]=bg.C[i].size();\n  vector<vector<int> > dp(2,vector<int>(k,0));\n  vector<int> used(k,0);\n  function<void(int,int)> dfs=[&](int v,int p){\n    if(used[v]) return;\n    used[v]=1;\n    dp[0][v]=0;\n    dp[1][v]=c[v];\n    for(int u:G[v]){\n      if(u==p) continue;\n      dfs(u,v);\n      dp[0][v]+=max(dp[0][u],dp[1][u]);\n      dp[1][v]+=dp[0][u];\n    }\n    return;\n  };\n  int ans=0;\n  for(int i=0;i<k;i++){\n    if(used[i]) continue;\n    dfs(i,-1);\n    ans+=max(dp[0][i],dp[1][i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n/*\n  verified on 2019/05/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0377\n*/\n\nsigned ARC045_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n    \n  int n;\n  cin>>n;\n  vector<int> xs(2*n+1),ys(2*n+1);\n  for(int i=0;i<2*n+1;i++) cin>>xs[i]>>ys[i];\n\n  vector<vector<int> > R(2*n+2),C(2*n+2);\n  for(int i=0;i<2*n+1;i++) R[xs[i]].emplace_back(i);\n  for(int i=0;i<2*n+1;i++) C[ys[i]].emplace_back(i);\n\n  UnionFind uf(2*n+1);\n  for(auto &v:R)\n    for(auto u:v) uf.unite(v[0],u);\n  for(auto &v:C)\n    for(auto u:v) uf.unite(v[0],u);\n\n  vector<int> vs;\n  for(int i=0;i<2*n+1;i++){\n    if(uf.find(i)!=i) continue;\n    if(uf.size(i)&1) vs.emplace_back(i);\n  }\n  assert(!vs.empty());\n  \n  if(vs.size()>1u){\n    for(int i=0;i<2*n+1;i++) cout<<\"NG\\n\";\n    cout<<flush;\n    return 0;    \n  }\n  \n  LowLink G(2*n+1);\n  auto add_edge=\n    [&](auto &V)->void{\n      for(auto &v:V){\n        if(v.empty()) continue;\n        if(!uf.same(vs[0],v[0])) continue;\n        if(v.size()>0u) for(auto u:v) G.add_edge(v[0],u);\n        if(v.size()>1u) for(auto u:v) G.add_edge(v[1],u);\n      }\n    };\n  add_edge(R);\n  add_edge(C);\n\n  G.build();\n  auto ap=G.ap; \n  \n  vector<int> ans(2*n+1,0);\n  for(int i=0;i<2*n+1;i++)\n    if(uf.same(vs[0],i)) ans[i]=1;\n\n  for(int v:ap){\n    if(!uf.same(vs[0],v)) continue;\n    for(int u:G.G[v]){\n      if(G.par[u]!=v) continue;    \n      if(~G.par[v]&&G.ord[v]>G.low[u]) continue;     \n      if(G.num[u]&1) ans[v]=0;\n    }\n  }\n  \n  for(int i=0;i<2*n+1;i++) cout<<(ans[i]?\"OK\\n\":\"NG\\n\");\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2019/03/23\n  https://atcoder.jp/contests/arc045/tasks/arc045_d\n*/\n\n\nsigned ARC062_F(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  int n,m,k;\n  cin>>n>>m>>k;\n\n  using P = pair<int, int>;\n  map<P, int> idx;\n  \n  LowLink G(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G.add_edge(a,b);\n    idx[P(a,b)]=idx[P(b,a)]=i;\n  }\n\n  G.build();\n  \n  UnionFind uf(m);\n  for(auto vs:G.E)\n    for(auto p:vs) uf.unite(idx[p],idx[vs[0]]);  \n\n  vector<set<int>> cnt(m);  \n  for(auto vs:G.E){\n    for(auto p:vs){\n      cnt[uf.find(idx[p])].emplace(p.first);     \n      cnt[uf.find(idx[p])].emplace(p.second);\n    }\n  }\n  \n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(1000);\n  \n  auto calc1=\n    [&](int x)->M{     \n      M res{0};\n      \n      for(int i=0;i<x;i++)\n        res+=M(k).pow(__gcd(i,x));\n      \n      res*=E::invs[x];\n      return res;\n    };\n\n  M ans{1};\n  for(int i=0;i<m;i++){\n    if(uf.find(i)!=i) continue;\n    if(uf.size(i)< (int)cnt[i].size()) ans*=M(k).pow(uf.size(i));\n    if(uf.size(i)==(int)cnt[i].size()) ans*=calc1(uf.size(i));\n    if(uf.size(i)> (int)cnt[i].size()) ans*=E::H(k,uf.size(i));\n  }  \n  cout<<ans.v<<endl;\n  return 0;\n}\n/*\n  verified on 2019/05/29\n  https://atcoder.jp/contests/arc062/tasks/arc062_d\n*/\n\n\nsigned main(){\n  //GRL_3_A();\n  GRL_3_B();\n  //AOJ_0377();\n  //ARC045_D();  \n  //ARC062_F();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// グラフ\n\n// 隣接リスト\n\n// cycle を検出 ⇔ 強連結成分の個数をチェック\n\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cfloat>\n#include<tuple>\n#include<set>\n#include<stack>\n\nconst double INF = DBL_MAX / 3.0;\n\n// Edge\nclass Edge {\npublic:\n    Edge() {}\n    Edge(const int f, const int t, const double w) :from_(f), to_(t), weight_(w) {}\n    int from() const {return from_;}\n    int to() const {return to_;}\n    double weight() const {return weight_;}\n    bool operator<(const Edge& e) const {\n        if(from() != e.from()) return from() < e.from();\n        if(to() != e.to()) return to() < e.to();\n        return weight() < e.weight();\n    }\nprivate:\n    int from_, to_;\n    double weight_;\n};\n\n// Graph\nclass Graph {\npublic:\n    explicit Graph(int s) :size_(s) {edge_.resize(s);}\n\n    int size() const {return size_;}\n    const std::vector<Edge>& edge(const int v) const {return edge_[v];}\n\n    void add(const Edge& e);\n    void add(const int from, const int to, const double weight);\n    double Dijkstra(const int start, const int goal) const;\n    double BellmanFord(const int start, const int goal) const;\n    bool cut_vertex(const int v, const std::set<int>& visited) const;\n    std::vector<std::vector<int>> Kosaraju() const;\nprivate:\n    void cut_vertex_reachability(const int from, std::set<int>& visited) const;\n    void Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const;\n    std::vector<int> Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const;\n\n    int size_;\n    std::vector<std::vector<Edge>> edge_;\n};\n\n// implements\nvoid Graph::add(const Edge& e) {edge_[e.from()].push_back(e);}\n\nvoid Graph::add(const int from, const int to, const double weight) {edge_[from].push_back(Edge(from, to, weight));}\n\ndouble Graph::Dijkstra(const int start, const int goal) const {\n    enum {COST, VERTEX};\n    typedef std::tuple<double, int> Node;\n\n    std::vector<int> visited(size(), 0);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        double cost = std::get<COST>(q.top());\n        int from = std::get<VERTEX>(q.top());\n        q.pop();\n        if(from == goal) return cost;\n        if(visited[from]) continue;\n        visited[from] = 1;\n        for(const auto& e: edge(from)) q.push(Node(cost + e.weight(), e.to()));\n    }\n    return INF;\n}\n\ndouble Graph::BellmanFord(const int start, const int goal) const {\n    std::vector<double> distance(size(), INF);\n    distance[start] = 0;\n    for(int step = 0; step <= size(); ++step) {\n        for(int from = 0; from < size(); ++from) {\n            for(const auto& e: edge(from)) {\n                if(distance[from] + e.weight() >= distance[e.to()]) continue;\n                if(step == size()) return INF;\n                distance[e.to()] = distance[from] + e.weight();\n            }\n        }\n    }\n    return distance[goal];\n}\n\nbool Graph::cut_vertex(const int v, const std::set<int>& visited = std::set<int>()) const {\n    std::set<int> dup = visited;\n    for(const auto& e: edge(v)) {\n        if(dup.count(e.to())) continue;\n        cut_vertex_reachability(e.to(), dup);\n        return dup.size() != size();\n    }\n    return dup.size() != size();\n}\nvoid Graph::cut_vertex_reachability(const int from, std::set<int>& visited) const {\n    visited.insert(from);\n    for(const auto& e: edge(from)) if(!visited.count(e.to())) cut_vertex_reachability(e.to(), visited);\n}\n\nstd::vector<std::vector<int>> Graph::Kosaraju() const {\n    std::vector<std::vector<int>> result;\n\n    std::vector<bool> visited(size(), false);\n    std::stack<int> order;\n    for(int v = 0; v < size(); ++v) if(!visited[v]) Kosaraju_dfs_postorder(v, visited, order);\n\n    std::vector<std::vector<Edge>> reverse_edge(size(), std::vector<Edge>());\n    for(int v = 0; v < size(); ++v) for(const auto& e: edge(v)) reverse_edge[e.to()].push_back(Edge(e.to(), e.from(), e.weight()));\n\n    visited = std::vector<bool>(size(), false);\n    while(!order.empty()) {\n        int v = order.top();\n        order.pop();\n        if(visited[v]) continue;\n        result.push_back(Kosaraju_dfs_decompose(reverse_edge, v, visited));\n    }\n    return result;\n}\nvoid Graph::Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const {\n    visited[from] = true;\n    for(const auto& e: edge(from)) if(!visited[e.to()]) Kosaraju_dfs_postorder(e.to(), visited, order);\n    order.push(from);\n}\nstd::vector<int> Graph::Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const {\n    std::vector<int> result;\n    result.push_back(from);\n    visited[from] = true;\n    for(const auto& e: reverse_edge[from]) {\n        if(visited[e.to()]) continue;\n        std::vector<int> add = Kosaraju_dfs_decompose(reverse_edge, e.to(), visited);\n        result.insert(result.end(), add.begin(), add.end());\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// 無向木の最遠点対\n//     ある頂点から最も遠い点を u とし, u から最も遠い点を v とすると (u, v) が最遠点対\n// 有向だとダメ && cycle があると死ぬ\nstd::tuple<double, int> diameter_of_unoriented_tree_dfs(const Graph& g, const int previous, const int current) {\n    std::tuple<double, int> result(0.0, current);\n    for(const auto& e: g.edge(current)) {\n        if(e.to() == previous) continue;\n        double w; int v;\n        std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, current, e.to());\n        w += e.weight();\n        if(std::get<0>(result) < w) result = std::make_tuple(w, v);\n    }\n    return result;\n}\ndouble diameter_of_unoriented_tree(const Graph& g) {\n    double w; int v;\n    std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, -1, 0);\n    std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, -1, v);\n    return w;\n}\n\n// 連結グラフの cut vertex の集合を返す\n//     Algorithmics: theory and practice, Gilles Brassard and Paul Bratley\nvoid cut_vertex_dfs(const Graph& g, const int prev, const int current, int& timer, std::vector<int>& prenum, std::vector<int>& parent, std::vector<int>& lowest) {\n    prenum[current] = timer;\n    lowest[current] = timer;\n    parent[current] = prev;\n    for(const auto& e: g.edge(current)) {\n        if(prenum[e.to()] == -1) {\n            cut_vertex_dfs(g, current, e.to(), ++timer, prenum, parent, lowest);\n            lowest[current] = std::min(lowest[current], lowest[e.to()]);\n        } else if(e.to() != prev) {\n            lowest[current] = std::min(lowest[current], prenum[e.to()]);\n        }\n    }\n}\nstd::set<int> cut_vertex(const Graph& g) {\n    std::vector<int> prenum(g.size(), -1);\n    std::vector<int> parent(g.size(), -1);\n    std::vector<int> lowest(g.size(), 1000000000);\n    int timer = 0;\n    cut_vertex_dfs(g, -1, 0, timer, prenum, parent, lowest);\n    std::set<int> result;\n    int count = 0;\n    for(const auto& p: parent) if(p == 0) count++;\n    if(count >= 2) result.insert(0);\n    for(int v = 1; v < g.size(); ++v) {\n        if(parent[v] == 0) continue;\n        if(prenum[parent[v]] <= lowest[v]) result.insert(parent[v]);\n    }\n    return result;\n}\n\n// 無向グラフの bridge の集合を返す\nvoid bridge_dfs(const Graph& g, const int prev, const int current, int& timer, std::vector<int>& prenum, std::vector<int>& parent, std::vector<int>& lowest) {\n    prenum[current] = timer;\n    lowest[current] = timer;\n    parent[current] = prev;\n    for(const auto& e: g.edge(current)) {\n        if(prenum[e.to()] == -1) {\n            cut_vertex_dfs(g, current, e.to(), ++timer, prenum, parent, lowest);\n            lowest[current] = std::min(lowest[current], lowest[e.to()]);\n        } else if(e.to() != prev) {\n            lowest[current] = std::min(lowest[current], prenum[e.to()]);\n        }\n    }\n}\n#include<iostream>\nusing namespace std;\nstd::set<Edge> bridge(const Graph& g) {\n    std::vector<int> prenum(g.size(), -1);\n    std::vector<int> parent(g.size(), -1);\n    std::vector<int> lowest(g.size(), 1000000000);\n    int timer = 0;\n    bridge_dfs(g, -1, 0, timer, prenum, parent, lowest);\n    std::set<Edge> result;\n    for(int v = 0; v < g.size(); ++v) {\n        for(const auto& e: g.edge(v)) {\n            if(prenum[e.from()] < lowest[e.to()]) result.insert(e);\n        }\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for(int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        g.add(s, t, 1);\n        g.add(t, s, 1);\n    }\n    for(const auto& e: bridge(g)) cout << e.from() << \" \" << e.to() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t i64;\ntypedef uint64_t ui64;\n\nclass graph{\npublic:\n    struct adj{\n        int index;\n        int start;\n        int to;\n        i64 cost;\n    };\n    int nd;\n    int eg;\n    vector<adj> *node;\n    vector<adj> edge;\n    graph(int n,int m){\n        nd=n;\n        eg=m;\n        node=new vector<adj>[nd]{};\n        edge={};\n    }\n    void add_dir(int i,int s,int t,i64 c){\n        node[s].push_back({i,s,t,c});\n        edge.push_back({i,s,t,c});\n    }\n    void add_undir(int i,int s,int t,i64 c){\n        node[s].push_back({i,s,t,c});\n        node[t].push_back({i,t,s,c});\n        edge.push_back({i,s,t,c});\n    }\n    void refr(void){\n        for(int i=0;i<nd;i++) vector<adj>().swap(node[i]);\n        delete[] node;\n        vector<adj>().swap(edge);\n    }\n    bool IsLink(void);\n    void DFS(int r,i64 *&p,bool *&vst);\n    bool IsPlus(void);\n    void BellmanFord(int s,i64 *&d);\n    void Dijkstra(int s,i64 *&d);\n    void BFS(int s,i64 *&d);\n    void WarshallFloyd_dir(i64 **&d);\n    void WarshallFloyd_undir(i64 **&d);\n    i64 WMST_dir(int r);\n    i64 WMST_undir(void);\n    void Edmonds(int r,vector<adj> &p);\n    void Kruscal(vector<adj> &p);\n    void Prim(vector<adj> &p);\n    void Artic(vector<int> &p);\n    void Artic_sub(int r,int &k,int par,vector<int> &p,int *&ord,int *&low,bool *&vst);\n    void Bridge(vector<adj> &p);\n    void Bridge_sub(int r,int &k,int par,vector<adj> &p,int *&ord,int *&low,bool *&vst);\n    void Cumul(int s,i64 *&d);\n};\n\nvoid graph::Bridge(vector<adj> &p){\n    int *ord=new int[nd]{};\n    int *low=new int[nd]{};\n    bool *vst=new bool[nd]{};\n    int k=0;\n    Bridge_sub(0,k,-1,p,ord,low,vst);\n    delete[] ord;\n    delete[] low;\n    delete[] vst;\n}\n\nvoid graph::Bridge_sub(int r,int &k,int par,vector<graph::adj> &p,int *&ord,int *&low,bool *&vst){\n    vst[r]=1;\n    ord[r]=low[r]=k;\n    k++;\n    for(const auto &i:node[r]){\n        if(!vst[i.to]){\n            Bridge_sub(i.to,k,r,p,ord,low,vst);\n            low[r]=min(low[r],low[i.to]);\n            if(ord[r]<low[i.to]) p.push_back({i.index,i.start,i.to,i.cost});\n        }\n        else if(i.to!=par){\n            low[r]=min(low[r],ord[i.to]);\n        }\n    }\n}\n\nint main(void){\n    int v,e;\n    scanf(\"%i%i\",&v,&e);\n    graph g(v,e);\n    int s,t;\n    for(int i=0;i<e;i++){\n        scanf(\"%i%i\",&s,&t);\n        g.add_undir(i,s,t,1);\n    }\n    vector<graph::adj> p;\n    g.Bridge(p);\n    for(auto &i:p){\n        if(i.start>i.to){\n            int t=i.start;\n            i.start=i.to;\n            i.to=t;\n        }\n    }\n    sort(p.begin(),p.end(),[](const graph::adj &p1,const graph::adj &p2){\n        if(p1.start<p2.start) return 1;\n        else if(p1.start>p2.start) return 0;\n        else{\n            if(p1.to<p2.to) return 1;\n            else return 0;\n        }\n    });\n    for(const auto &i:p) printf(\"%i %i\\n\",i.start,i.to);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    using namespace std;\n    size_t V, E;\n    cin >> V >> E;\n    vector<size_t> low(V, V + 1), depth(V);\n    vector<vector<pair<size_t, size_t>>> edge(V);\n    for(size_t i = 0, s, t; i < E; ++i){\n        cin >> s >> t;\n        edge[s].emplace_back(t, s);\n        edge[t].emplace_back(s, t);\n    }\n    for(auto& i : edge)sort(i.begin(), i.end());\n    [rec = [&low, &depth, &edge](auto f, auto now, auto prev, auto& t) -> long{\n        depth[now] = ++t;\n        for(const auto i : edge[now])if(i.first != prev){\n            if(depth[i.first] == 0)low[now] = min(low[now], low[f(f, i.first, now, t)]);\n            low[now] = min(low[now], depth[i.first]);\n        }\n        return now;\n    }](auto root){auto t = 0;rec(rec, root, root, t);}(0UL);\n    vector<pair<size_t, size_t>> ans;\n    for(const auto& i : edge)for(const auto& j : i)if(low[j.first] > depth[j.second])ans.emplace_back(min(j.first, j.second), max(j.first, j.second));\n    sort(ans.begin(), ans.end());\n    for(const auto& i : ans)cout << i.first << \" \" << i.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int max_n = 1000001, inf = 9999999;\nvector<int>adj[max_n];\nint dp[max_n], depath[max_n], from[max_n], to[max_n];\nbool vis[max_n];\nvoid dfs(int v, int de, int p){\n\tdepath[v] = de;\n\tvis[v] = 1;\n\tfor (int e : adj[v]){\n\t\tint a = from[e] ^ to[e] ^ v;\n\t\tif (e == p)\n\t\t\tcontinue;\n\t\tif (vis[a])\n\t\t\tdp[v] = min(dp[v], depath[a]);\n\t\telse{\n\t\t\tdfs(a, de + 1, e);\n\t\t\tdp[v] = min(dp[a], dp[v]);\n\t\t}\n\t}\n\tif (dp[v] >= de  &&p!=-1)\n\t\tcout << from[p]<<' '<<to[p] << endl;\n}\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < max_n; i++)\n\t\tdp[i] = inf;\n\tfor (int i = 1; i <= m; i++){\n\t\tcin >> from[i]>> to[i];\n\t\tfrom[i];\n\t\tto[i];\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tdfs(0, 0, -1);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> Mat;\nstruct ArticulationPoint {\n    vector<int> ord, low, art;\n    int cnt;\n    //vector<pair<int, int> > bridge;\n\n    ArticulationPoint(const Mat&G) {\n        int n = G.size();\n        cnt = 0;\n        ord.assign(n, -1); low.assign(n, 0); art.assign(n, 0);\n        for (int i=0; i<n; i++) {\n            if (ord[i] == -1) {\n                dfs(G, i, -1);\n                if (art[i]) art[i]--;\n            }\n        }\n    }\n\n    void dfs(const Mat&G, int v, int p) {\n        ord[v] = low[v] = cnt++;\n        for (int i=0; i<(int)G[v].size(); i++) {\n            int w = G[v][i];\n            if (ord[w] == -1) {\n                dfs(G, w, v);\n                low[v] = min(low[v], low[w]);\n                if (ord[v] <= low[w]) art[v]++;\n                //if (ord[v] < low[w]) bridge.push_back(make_pair(min(v, w), max(v, w)));\n            } else if (w != p) low[v] = min(low[v], ord[w]);\n        }\n    }\n\n    // {v, w} must be an edge\n\n    bool is_bridge(int v, int w) { return ord[v] < low[w] || ord[w] < low[v]; }\n\n    // the number of increasing CC\n\n    int is_art(int v) { return art[v]; }\n};\n\nvector<int> G[100000];\n\nint main(){\n    int v,e;\n    cin >> v >> e;\n    vector<int> a(e),b(e);\n    for(int i = 0; i < e; i++){\n        cin >> a[i] >> b[i];\n        G[a[i]].push_back(b[i]);\n        G[b[i]].push_back(a[i]);\n    }\n\n    Mat M;\n    for(int i = 0; i < v; i++) M.push_back(G[i]);\n\n    ArticulationPoint art(M);\n    for(int i = 0; i < v; i++) for(int j = i + 1; j < v; j++) if(art.is_bridge(i, j)) printf(\"%d %d\\n\", i, j);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\nusing namespace std;\nconst int maxn = 100001;\n\nvector<int> G[maxn];\nstruct Edge\n{\n    int u, v;\n};\n\nvector<Edge> ans;\nbool cmp(Edge a, Edge b)\n{\n    if(a.u != b.u)\n        return a.u < b.u;\n    else\n        return a.v < b.v;\n}\nint n, e;\nint prenum[maxn], parent[maxn], lowest[maxn], vis[maxn];\nint cnt;\nvoid dfs(int i,int Father)\n{\n    parent[i]=Father;\n    prenum[i]=lowest[i]=cnt++;\n    for(int j=0;j<G[i].size();++j)\n    {\n        int k=G[i][j];\n        if(prenum[k]==-1)\n        {\n            dfs(k,i);\n            lowest[i]=min(lowest[i],lowest[k]);\n        }\n        else if(Father!=k)\n            lowest[i]=min(lowest[i],prenum[k]);\n    }\n}\n\nvoid bridge()\n{\n    for(int i = 0; i < n; i++)\n        prenum[i] = -1;\n    cnt = 0;\n    parent[0] = -1;\n    dfs(0, -1);\n    int rootCnt = 0;\n\n    for(int i = 1; i < n; i++)\n    {\n        int p = parent[i];\n        if(p == 0) rootCnt++;\n        if(prenum[p] < lowest[i])\n        {\n            Edge e;\n            if(p < i)\n            {\n                e.u = p;\n                e.v = i;\n            }\n            else\n            {\n                e.u = i;\n                e.v = p;\n            }\n            ans.push_back(e);\n        }\n    }\n\n    sort(ans.begin(), ans.end(), cmp);\n    for(int i = 0; i < ans.size(); i++)\n        cout << ans[i].u << \" \" << ans[i].v << endl;\n}\n\nint main()\n{\n    cin >> n >> e;\n    for(int i = 0; i < e; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    bridge();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100001\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> G[N];\nvector<P> ans;\nint cnt[N],dep[N];\n\nvoid dfs(int pos,int pre){\n  for(int i=0;i<G[pos].size();i++){\n    int nx=G[pos][i];\n    if(nx==pre||dep[nx]>dep[pos]) continue;\n\n    if(dep[nx]!=-1&&dep[nx]<dep[pos])cnt[nx]--,cnt[pos]++;\n    else{ \n      dep[nx]=dep[pos]+1;\n      dfs(nx,pos);\n      if(cnt[nx]==0) ans.push_back(P(min(pos,nx),max(pos,nx)));\n      cnt[pos]+=cnt[nx];\n    } \n  }\n}\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(dep,-1,sizeof(dep));\n  dep[0]=0;\n  dfs(0,-1);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)cout <<ans[i].first<<\" \"<<ans[i].second<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define all(c) c.begin(),c.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\nconstexpr int INF = 1001001001001001001LL;\n\n// ret: {ord, low}\npair<vi, vi> ord_lowlink(vvi &g, vector<pii> *bridge = nullptr, vi *artics = nullptr) {\n    int N = sz(g);\n    vector<bool> vis(N, false);\n    vi ord(N), low(N);\n    int k = 0;\n    auto dfs = [&](auto f, int v, int p) -> void {\n        vis[v] = true;\n        ord[v] = low[v] = k++;\n        int cnt = 0;\n        bool is_artic = false;\n        for (int w : g[v]) {\n            if (!vis[w]) {\n                cnt++;\n                f(f, w, v);\n                low[v] = min(low[v], low[w]);\n                if (p != -1 && ord[v] <= low[w]) is_artic = true;\n                if (bridge && ord[v] < low[w]) bridge->push_back({v, w});\n            } else if (w != p) {\n                low[v] = min(low[v], ord[w]);\n            }\n        }\n        if (p == -1 && cnt > 1) is_artic = true;\n        if (is_artic && artics) artics->push_back(v);\n    };\n    dfs(dfs, 0, -1);\n    return {ord, low};\n}\n\nsigned main() {\n    int V, E;\n    cin >> V >> E;\n    vvi G(V);\n    rep(i, 0, E) {\n        int vs, vt;\n        cin >> vs >> vt;\n        G[vs].push_back(vt);\n        G[vt].push_back(vs);\n    }\n    vector<pii> ans;\n    ord_lowlink(G, &ans, nullptr);\n    for (pii &p : ans) {\n        if (p.first > p.second) swap(p.first, p.second);\n    }\n    sort(all(ans));\n    for (pii x : ans) cout << x.first << \" \" << x.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cerr << x << \" \";} cerr << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cerr << x << \" \";}cerr << endl;}\n#define printP(p) cerr << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int>      Edge;   // (a < b: undirected)\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vi depth;\n    vi par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvi cmp;\n\tint num_cc;\n\tvi size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    void bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\t// rep(i, n) {\n\t\t// \tint size_cc = extractCC(i, num_cc);\n\t\t// \tif (size_cc > 0) {\n\t\t// \t\tsize_of_vertex.emplace_back(size_cc);\n\t\t// \t\tnum_cc++;\n\t\t// \t}\n\t\t// }\n        //\n        // r<set<int>> G_cc_st(num_cc);\n\t\t// for (auto&& p : EdgeType) {\n        //     Edge e;\n        //     int type;\n        //     tie(e, type) = p;\n        //     if (type == BRIDGE) {\n\t\t// \t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t// \t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n        //     }\n        // }\n        //\n\t\t// rep(i, num_cc) {\n\t\t// \tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t// }\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n    BICC bicc(V);\n    rep(i, E) {\n        int a, b;\n        cin >> a >> b;\n        bicc.addEdge(a, b);\n    }\n\n    bicc.bicc();\n    auto bridges = bicc.getBridges();\n    // printVP(bridges);\n    for (auto&& e : bridges) {\n        cout << e.first << \" \" << e.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint n, m;\nint low[100000];\nint ord[100000];\nbool used[100000];\nvector<Pair> ans;\nvector<int> es[100000];\n\nvoid dfs(int v, int p, int &idx) {\n    used[v] = true;\n    low[v] = ord[v] = idx++;\n\n    for (int i=0; i<es[v].size(); i++) {\n        int u = es[v][i];\n        if (!used[u]) {\n            dfs(u, v, idx);\n            low[v] = min(low[v], low[u]);\n            if (ord[v] < low[u]) {\n                int s = min(u, v);\n                int t = max(u, v);\n                ans.push_back(Pair(s, t));\n            }\n        } else if (u != p) {\n            low[v] = min(low[v], ord[u]);\n        }\n    }\n}\n    \n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i=0; i<m; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        es[a].push_back(b);\n        es[b].push_back(a);\n    }\n\n    int _ = 0;\n    dfs(0, 0, _);\n\n    sort(ans.begin(), ans.end());\n    for (int i=0; i<ans.size(); i++) {\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\n\nconst int MAX_V = 100000;\n\nclass Node{\n    public:\n        bool isUsed;\n        int prenum; //DFS????¨?????????????\n        int parent; //DFS Tree???????????????\n        int lowest; //min(?????????prenum, ?????????????????´????????????prenum, ??????????????????lowest)\n        Node(){ this->isUsed = 0; }\n};\n\nint cnt = 1;\nvector<Node> node(MAX_V);\nvector<int> edge[MAX_V];\nvector<pair<int, int>> bridge;\n\nvoid dfs(int current, int prev){\n    node[current].prenum = node[current].lowest = cnt;\n    cnt++;\n\n    node[current].isUsed = true;\n\n    int next;\n    rep(i,edge[current].size()){\n        next = edge[current][i];\n        if(not node[next].isUsed){\n            node[next].parent = current;\n            dfs(next, current);\n            node[current].lowest = min(node[current].lowest, node[next].lowest);\n            if(node[current].prenum < node[next].lowest){\n                bridge.emplace_back(make_pair(min(current, next), max(current, next)));\n            }\n        }else if(next != prev){\n            node[current].lowest = min(node[current].lowest, node[next].prenum);\n        }\n    }\n}\n\nvoid art_points(int v){\n    dfs(0, -1); // 0 == root\n\n    set<int> ap;\n    int np = 0;\n    range(i,1,v){\n        int p = node[i].parent;\n        if(p == 0) np++;\n        else if(node[p].prenum <= node[i].lowest) ap.insert(p);\n    }\n    if(np > 1) ap.insert(0);\n    //for(auto it:ap){ cout << it << endl; } //??¢???????????¨??????\n    sort(all(bridge));\n    for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //????????¨??????\n\n}\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n    rep(i,e){\n        int a, b;\n        cin >> a >> b;\n        edge[a].emplace_back(b);\n        edge[b].emplace_back(a);\n    }\n    art_points(v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tfor (int v : g[u]) {\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tfor (pii now : bridge) printf(\"%d %d\\n\", now.first, now.second);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nbool disconnected (Graph g, Edge disconnectedEdge) {\n    vector<bool> seen(g.size(), false);\n    int counter = g.size();\n    queue<int> front;\n    front.push(0);\n\n    while (! front.empty()) {\n        int u = front.front();\n        front.pop();\n\n        if (! seen[u]) {\n            seen[u] = true;\n            counter--;\n            for(int v: g[u])\n                if ((v != disconnectedEdge.u || u != disconnectedEdge.v) && (v != disconnectedEdge.v || u != disconnectedEdge.u))\n                    front.push(v);\n        }\n    }\n\n    return counter != 0;\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> edges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n        edges.push_back(Edge{min(s, t), max(s, t)});\n    }\n\n    sort(edges.begin(), edges.end());\n\n    vector<Edge> bridges;\n    for(Edge e : edges)\n        if (disconnected(g, e)) bridges.push_back(e);\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Graph {\n    Graph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n    const int V;\n};\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const Graph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            if (ord[i] == -1) {\n                bridge_dfs(g_, i);\n            }\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const\n    {\n        return bridge;\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    const vector<pair<int, int>> getBridge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? (ord[i] < low[j]) : (ord[j] < low[i]);\n    }\n\nprivate:\n    void bridge_dfs(const Graph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const int to : g_.edge[s]) {\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n                if (isBridge(s, to)) {\n                    bridge.push_back(make_pair(s, to));\n                }\n            }\n        }\n    }\n\n    void comp_dfs(const Graph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const int to : g_.edge[s]) {\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n\n    int num;\n    int comp_num;\n    const int size;\n    vector<pair<int, int>> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) {\n            swap(s, t);\n        }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    for (int i = 0; i < E; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n    }\n    vector<P> b = bic.getBridge();\n    sort(b.begin(), b.end());\n    for (const auto& p : b) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass Bridge {\npublic:\n\tvector<vector<int>> G;\n\tvector<int> ord, low;\n\tvector<pair<int, int>> bridges;\n\tint k;\n\n\tBridge(int N):k(0) {\n\t\tG.resize(N); ord.resize(N, -1); low.resize(N, -1);\n\t}\n\tvoid clear() { G.clear();ord.clear();low.clear(); }\n\tvoid add_edge(int s, int t) {\n\t\tG[s].emplace_back(t); \n\t\tG[t].emplace_back(s);\n\t}\n\n\tbool is_bridge(int u, int v)const {\n\t\tif (ord[u] > ord[v])swap(u, v);\n\t\treturn ord[u] < low[v];\n\t}\n\n\t/* Lowlink */\n\tvoid dfs(int u,int rev = -1) {\n\t\tord[u] = low[u] = k;\n\t\tk++;\n\t\tfor (auto v : G[u]) {\n\t\t\tif (v == rev)continue;\n\t\t\tif (ord[v] < 0) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t\tif (is_bridge(u, v)) {\n\t\t\t\tint s = u, t = v;\n\t\t\t\tif (s > t) swap(s, t);\n\t\t\t\tbridges.push_back({ s,t });\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tdfs(0);\n\t\tsort(bridges.begin(), bridges.end());\n\t}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tBridge b(V);\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tb.add_edge(s, t);\n\t}\n\tb.solve();\n\tfor (auto bridge : b.bridges) {\n\t\tcout << bridge.first << \" \" << bridge.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\ntemplate <class F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <class... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\n\ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n\n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n\n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n\ntemplate <typename Weight>\nclass graph: public std::vector<std::vector<edge<Weight>>> {\npublic:\n  using value_type = Weight;\n\nprivate:\n  size_t M_size = 0;\n  std::vector<size_t> M_ord, M_low;\n  std::vector<size_t> M_articulation_point;\n  std::vector<edge<value_type>> M_bridge;\n\n  void M_lowlink_dfs(size_t s) {\n    size_t count = 0;\n    make_fix_point([&](auto f, size_t v, size_t p) -> void {\n        M_low[v] = M_ord[v] = count++;\n        size_t deg = 0;  // in terms of the dfs tree\n        bool ap = false;\n        for (auto const& e: (*this)[v]) {\n          if (e.dst == p) continue;\n          if (M_ord[e.dst]+1 != 0) {\n            M_low[e.src] = std::min(M_low[e.src], M_ord[e.dst]);\n          } else {\n            f(e.dst, e.src);\n            M_low[e.src] = std::min(M_low[e.src], M_low[e.dst]);\n            ++deg;\n            if (M_ord[e.src] > 0 && M_ord[e.src] <= M_low[e.dst]) ap = true;\n            if (M_ord[e.src] < M_low[e.dst]) M_bridge.push_back(e);\n          }\n        }\n        if (M_ord[v] == 0 && deg > 1) ap = true;\n        if (ap) M_articulation_point.push_back(v);\n    })(s, -1);\n  }\n\n  void M_lowlink() {\n    if (!M_ord.empty()) return;\n    M_ord.resize(M_size, -1);\n    M_low.resize(M_size, -1);\n    for (size_t i = 0; i < M_size; ++i)\n      if (M_ord[i]+1 == 0) M_lowlink_dfs(i);\n  }\n\npublic:\n  graph() = default;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n), M_size(n) {}\n\n  void connect_to(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n  }\n\n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    connect_to(src, dst, cost);\n    connect_to(dst, src, cost);\n  }\n\n  std::vector<edge<value_type>> bridge() {\n    M_lowlink();\n    return M_bridge;\n  }\n\n  std::vector<size_t> articulation_point() {\n    M_lowlink();\n    return M_articulation_point;\n  }\n};\n\nint main() {\n  size_t n, m;\n  scanf(\"%zu %zu\", &n, &m);\n\n  graph<int> g(n);\n  for (size_t i = 0; i < m; ++i) {\n    size_t s, t;\n    scanf(\"%zu %zu\", &s, &t);\n    g.connect_with(s, t);\n  }\n\n  auto bridge = g.bridge();\n  std::vector<std::pair<size_t, size_t>> res;\n  for (auto const& e: bridge)\n    res.push_back(std::minmax(e.src, e.dst));\n\n  std::sort(res.begin(), res.end());\n  for (auto const& e: res)\n    printf(\"%zu %zu\\n\", e.first, e.second);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nstruct node {\n\tbool done;\n\tvi to;\n\tint id, from;\n\tint pre, low;\n};\n\nclass lowlink {\n\tint ord;\npublic:\n\tvector<node> nodes;\n\tset<P> bridges;\n\tset<int> arts; //articulation point\n\tlowlink(vector<node> A) {\n\t\tord = 0;\n\t\tnodes = A;\n\t}\n\tvoid dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tdfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) {\n\t\t\t\t\tint s = min(a, b), t = max(a, b);\n\t\t\t\t\tbridges.insert({ s,t });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\tif (cnt > (a == root ? 1 : 0)) arts.insert(a);\n\t\treturn;\n\t}\n\tvoid find_bridges_and_arts() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) dfs(i, i);\n\t\t}\n\t}\n};\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tvector<node> nodes(v);\n\tLoop(i, v) nodes[i] = { 0,{}, i,-1,-1,-1 };\n\tLoop(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].to.push_back(t);\n\t\tnodes[t].to.push_back(s);\n\t}\n\tlowlink lk(nodes);\n\tlk.find_bridges_and_arts();\n\t/*\n\tauto itr = lk.arts.begin();\n\tLoop(i, lk.arts.size()) {\n\t\tcout << *itr << endl;\n\t\titr++;\n\t}*/\n\tauto itr = lk.bridges.begin();\n\tLoop(i, lk.bridges.size()) {\n\t\tcout << (*itr).first << \" \" << (*itr).second << endl;\n\t\titr++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nstruct Edge {\n\tint src;\n\tint dst;\n\tint id;\n};\n\n// res: bridges\n// v: current node\n// from: parent node\nint dfs2(vector<vector<Edge>>&g, vector<int>& res, int v, int& count, int from_id, vector<int>& low, vector<int>& pre) {\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (auto it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = it->dst;\n\t\tif (pre[to] == -1) {\n\t\t\t// destination has not been visited\n\t\t\t// visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs2(g, res, to, count, it->id, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t// edge is not contained in a closed path -> bridge\n\t\t\t\t//res.push_back(it->id);\n\t\t\t\tres[it->id] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from_id == it->id) {\n\t\t\t\t// ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// Calculate bridges in a undirected graph.\n// Assume graph is connected and has no parallel edges or self-loops.\n// g: adjacency list\n// V: number of nodes\nvoid  bridges(vector<vector<Edge>>&g, int V, vector<int>&res) {\n\n\tif (V > 0) {\n\t\t// assume at least the first vertex exists\n\t\tvector<int> low(V, -1);  // lowest reacheable index\n\t\tvector<int> pre(V, -1);  // pre-order index\n\t\tint count = 0;  // pre-order index counter\n\t\tdfs2(g, res, 0, count, -1, low, pre);  // start dfs from vertex 0\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<Edge>>es(V);\n\tvector<Edge>eids;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tif (s > t)swap(s, t);\n\t\tes[s].push_back(Edge{ s,t,i });\n\t\tes[t].push_back(Edge{ t,s,i });\n\t\teids.push_back(Edge{ s,t,i });\n\t}\n\tvector<int>res(E);\n\tbridges(es, V, res);\n\tvector<Edge>bris;\n\tfor (int i = 0; i <E; ++i) {\n\t\tif (res[i])bris.push_back(eids[i]);\n\t}\n\tsort(bris.begin(), bris.end(), [=](const Edge&l, const Edge&r) {\n\t\treturn l.src == r.src ? l.dst < r.dst : l.src < r.src;\n\t});\n\tfor (int i = 0; i < bris.size(); ++i) {\n\t\tcout << bris[i].src << \" \" << bris[i].dst << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨?????????u(???root)???????????????lowlink[u] > prenum[u??????] ??? u?????? --> u??????\n//lowlink[u] > prenum[u??????] ??? u??????u???????????¢????????????????????? ??? u??¨u????????????????????????????????¨u??????u????????????????????? ??? [u?????? --> u]???????????¨?????£??? ??? [u?????? --> u]??????\n//lowlink[u] <= prenum[u??????] ???u??????u??????????????\\??????????????? ??? u??¨u?????????????????????????????£??????u??????u?????????????????? ??? [u?????? --> u]????????£????????£??? ??? [u?????? --> u]????????§?????????\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse if (parent[u] != v) {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (prenum[parent[i]] < lowest[i]) {\n\t\t\tans.push_back(Edge(min(parent[i], i), max(parent[i], i)));\n\t\t}\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n//グラフのlowlinkを取得する他、関節点と橋を列挙する\n//計算量 O(|V|+|E|)\nvoid lowlink(vector<int>graph[], int n, vector<int>& low, vector<pair<int, int>>& br, vector<int>& jnt) {\n\tlow.resize(n);\n\tvector<int>ord(n);//DFSの順番\n\tvector<bool>vis(n);//訪れたかどうか\n\t//再帰ラムダ式\n\tfunction<void(int, int, int&)>dfs = [&](int v, int p, int& k) {\n\t\tvis[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\tbool joint = false;\n\t\tint cnt = 0;\n\t\tfor (auto nxt : graph[v]) {\n\t\t\tif (!vis[nxt]) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, v, k);\n\t\t\t\tlow[v] = min(low[v], low[nxt]);\n\t\t\t\tif (p >= 0 && ord[v] <= low[nxt]) joint = true;\n\t\t\t\tif (ord[v] < low[nxt])br.push_back({ min(v,nxt),max(v,nxt) });\n\t\t\t}\n\t\t\telse if (nxt != p) {\n\t\t\t\tlow[v] = min(low[v], ord[nxt]);\n\t\t\t}\n\t\t}\n\t\tif (p < 0 && cnt > 1) joint = true;\n\t\tif (joint) jnt.push_back(v);\n\t};\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])dfs(i, -1, k);\n}\n\nint V, E;\nvector<int>G[123456];\n\nint main() {\n\tcin >> V >> E;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tvector<int>low, jnt;\n\tvector<pair<int, int>>br;\n\tlowlink(G, V, low, br, jnt);\n\tsort(br.begin(), br.end());\n\tfor (auto p : br) {\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 10000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  if (ord[s] > ord[t]) swap(s, t);\n  return ord[s] < lowlink[t];\n}\n\nvoid init_bridge() {\n  memset(vis, false, sizeof(vis));\n  timer = 1;\n  dfs(0, -1);\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    edges.push_back(make_pair(s, t));\n  }\n  sort(edges.begin(), edges.end());\n  init_bridge();\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Low-Link を用いた、橋・関節点列挙\n//\n// cf.\n//   hos: グラフ探索アルゴリズムとその応用\n//     http://hos.ac/slides/20110504_graph.pdf\n//\n// verified:\n//   AOJ Course GRL_3_B Connected Components - Bridges\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n//\n//   Connected Components - Articulation Points\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=jp\n//\n//\n\n\n/*\n \n \n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nusing Graph = vector<vector<int> >;\nstruct LowLink {\n    // main results\n    vector<int> aps; // articulation points\n    vector<pair<int,int> > brs; // brideges\n    \n    // intermediate results\n    vector<int> seen, ord, low;\n    void dfs_lowlink(const Graph &G, int v, int p = -1) {\n        static int time = 0;\n        seen[v] = true;\n        ord[v] = low[v] = time++;\n        for (auto to : G[v]) {\n            if (seen[to]) {\n                if (to != p) low[v] = min(low[v], low[to]);\n                continue;\n            }\n            dfs_lowlink(G, to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > ord[v]) brs.push_back(make_pair(v, to));\n        }\n    }\n    void solve(const Graph &G) {\n        int N = (int)G.size();\n        seen.assign(N, 0); ord.resize(N); low.resize(N);\n        aps.clear(); brs.clear();\n        for (int v = 0; v < N; ++v) if (!seen[v]) dfs_lowlink(G, v);\n    }\n};\n\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    LowLink ll;\n    ll.solve(G);\n    \n    // 橋\n    for (auto &br : ll.brs) if (br.first > br.second) swap(br.first, br.second);\n    sort(ll.brs.begin(), ll.brs.end());\n    for (auto br : ll.brs) cout << br.first << \" \" << br.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> E[100010];\nvector<int> res;\nchar pass[100010][100010];\nint o[100010];\n\nint dfs(int i,int n) {\n    if(o[i]) {\n        o[i] = min(o[i], n);\n        return o[i];\n    }\n    o[i] = n;\n    for(vector<int>::iterator it=E[i].begin(); it != E[i].end(); it++) {\n        if(pass[i][*it]) continue;\n        pass[i][*it] = pass[*it][i] = true;\n        o[i] = min(o[i], dfs(*it, n+1));\n    }\n    return o[i];\n}\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0; i<e; i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        E[s].push_back(t);\n        E[t].push_back(s);\n    }\n    for(int i=0; i<v; i++)\n        sort(E[i].begin(), E[i].end());\n\n    dfs(0,1);\n\n    for(int i=0; i<v; i++)\n        for(vector<int>::iterator it = E[i].begin(); it != E[i].end(); it++) {\n            if(i > *it) continue;\n            if(o[i] == o[*it]) continue;\n            printf(\"%d %d\\n\",i,*it);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\ntemplate< typename G >\nstruct LowLink {\n  const G &g;\n  vector< int > used, ord, low;\n  vector< int > articulation;\n  vector< pair< int, int > > bridge;\n\n  LowLink(const G &g) : g(g), used(g.size()), ord(g.size()), low(g.size()) {}\n\n  int build(int idx = 0, int k = 0, int par = -1) {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n    bool is_articulation = false;\n    int cnt = 0, ordmax = k;\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        ++cnt;\n        ordmax = build(to, ordmax, idx);\n        low[idx] = min(low[idx], low[to]);\n        is_articulation |= ~par && low[to] >= ord[idx];\n        if(ord[idx] < low[to]) bridge.emplace_back(minmax(idx, to));\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n    is_articulation |= par == -1 && cnt > 1;\n    if(is_articulation) articulation.push_back(idx);\n    return ordmax;\n  }\n};\n\n\nint main() {\n  int V, E;\n  scanf(\"%d %d\", &V, &E);\n  UnWeightedGraph g(V);\n  for(int i = 0; i < E; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  LowLink< UnWeightedGraph > lowlink(g);\n  lowlink.build();\n  sort(lowlink.bridge.begin(), lowlink.bridge.end());\n  for(auto &p : lowlink.bridge) printf(\"%d %d\\n\", p.first, p.second);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN -2147483648\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int,int> P;\n\nstruct node {\n\tbool done;\n\tvi to;\n\tint id, from;\n\tint pre, low;\n};\n\nclass lowlink {\n\tvector<node> nodes;\n\tint ord;\n\tvector<P> bridges;\npublic:\n\tlowlink(vector<node> A) {\n\t\tnodes = A;\n\t}\n\n\tvoid dfs(int a) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = ord;\n\t\tnodes[a].low = ord;\n\t\tord++;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tdfs(b);\n\t\t\t}\n\t\t\tif (nodes[a].low > nodes[b].low) nodes[a].low = nodes[b].low;\n\t\t\tif (nodes[a].pre < nodes[b].low) bridges.push_back({ nodes[a].id,nodes[b].id });\n\t\t}\n\t\treturn;\n\t}\n\tvoid find_bridge() {\n\t\tord = 0;\n\t\tdfs(0);\n\t\tLoop(i, bridges.size()) {\n\t\t\tif (bridges[i].first > bridges[i].second) swap(bridges[i].first, bridges[i].second);\n\t\t}\n\t\tsort(bridges.begin(), bridges.end());\n\t\tLoop(i, bridges.size()) {\n\t\t\tcout << bridges[i].first << \" \" << bridges[i].second << endl;\n\t\t}\n\t}\n};\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tvector<node> nodes(v);\n\tLoop(i, v) nodes[i] = { 0,{}, i,-1,-1,-1 };\n\tLoop(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].to.push_back(t);\n\t\tnodes[t].to.push_back(s);\n\t}\n\tlowlink lk(nodes);\n\tlk.find_bridge();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        from[i]=a,to[i]=b;\n        vec[a].push_back(i);\n        vec[b].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nclass LowLink {\n    const int N;\n    vector<vector<int>> G;\n    set<int> used_v;\n    vector<int> ord, low, parent;\n\n    void dfs(int v, int &k)\n    {\n        used_v.insert(v);\n        ord[v] = low[v] = k++;\n\n        for (auto u : G[v]) {\n            if (u == parent[v]) continue;\n            if (!used_v.count(u)) {\n                parent[u] = v;\n                dfs(u, k);\n                low[v] = min(low[v], low[u]);\n            } else {\n                low[v] = min(low[v], ord[u]);\n            }\n\n            if (ord[v] < low[u]) bridges.emplace_back(min(u, v), max(u, v));\n        }\n    }\n\npublic:\n    vector<PII> bridges;\n    LowLink(int _N) : N(_N), G(_N), ord(_N), low(_N), parent(_N) {}\n\n    void compute_bridge()\n    {\n        int k = 0;\n        bridges.clear();\n        dfs(0, k);\n    }\n\n    void add_edge(int u, int v)\n    {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n};\n\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    LowLink llink(N);\n\n    rep(i, M) {\n        int U, V;\n        cin >> U >> V;\n        llink.add_edge(U, V);\n    }\n\n    llink.compute_bridge();\n    sort(llink.bridges.begin(), llink.bridges.end());\n\n    for (auto p : llink.bridges) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    /*\n    rep(i, N) {\n        cout << ord[i] << \" \" <<  lowlink[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nvector<int>X[1 << 17]; int used[1 << 17]; int N, M, A, B; queue<int>Q;\nint main() {\n\tcin >> N >> M; for (int i = 0; i < M; i++) { cin >> A >> B; X[A].push_back(B); X[B].push_back(A); }\n\tfor (int i = 0; i < N; i++) { sort(X[i].begin(), X[i].end()); }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint a1 = i, a2 = X[i][j]; for (int k = 0; k < N; k++) { used[k] = 0; }used[0] = 1; Q.push(0); int cnt = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint to = Q.front(); Q.pop();\n\t\t\t\tfor (int k = 0; k < X[to].size(); k++) {\n\t\t\t\t\tint A1 = to, A2 = X[to][k]; if (A1 == a1 && A2 == a2) { continue; }if (A1 == a2 && A2 == a1) { continue; }\n\t\t\t\t\tif (used[X[to][k]] == 0) { used[X[to][k]] = 1; Q.push(X[to][k]); cnt++; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != N && a1 < a2) { cout << a1 << ' ' << a2 << endl; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<iterator>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Graph{\n    public:\n    typedef struct Edge{\n        ll from, to, cost;\n        Edge(ll f, ll t, ll c): from(f),to(t),cost(c){}\n    } Edge;\n\n    bool isDirected;\n    ll INF = 1LL << 62;\n    ll v; // 頂点数\n    std::vector<Edge> edges;  // 辺のリスト\n    std::vector<std::vector<std::pair<ll,ll>>> list;  // 隣接リスト\n    //std::vector<std::vector<ll>> matrix; // 隣接行列\n\n    Graph(ll n, bool isDirected=false) : isDirected(isDirected) { init(n); }\n    void init(ll n){\n        v=n;\n        edges.clear();\n        list.assign(n, std::vector<std::pair<ll,ll>>());\n        //matrix.assign(n, std::vector<ll>(n, INF));\n    }\n    void connect(ll from, ll to){\n        con(from, to, 1);\n        if(!isDirected) con(to, from, 1);\n    }\n    void connect(ll from, ll to, ll cost){\n        con(from, to, cost);\n        if(!isDirected) con(to, from, cost);\n    }\n    void con(ll from, ll to, ll cost){\n        edges.push_back(Edge(from,to,cost));\n        list[from].push_back(std::make_pair(to, cost));\n        //matrix[from][to] = cost;\n    }\n};\n\nclass lowlink{\n    public:\n    Graph G; // 無向グラフ\n    std::vector<ll> used, ord, low;\n    std::vector<ll> articulation; // 連結点\n    std::vector<Graph::Edge> bridge; // 橋\n\n    lowlink(Graph G) : G(G){\n        used.assign(G.v, 0);\n        ord.assign(G.v, 0);\n        low.assign(G.v, 0);\n    }\n\n    ll dfs(ll idx, ll k, ll parent){\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool isArticulation = false;\n        int child_num = 0;\n        for(auto to : G.list[idx]){\n            if(!used[to.first]){\n                child_num++;\n                k = dfs(to.first, k, idx);\n                low[idx] = min(low[idx], low[to.first]);\n                isArticulation |= (parent != -1 && low[to.first] >= ord[idx]);\n                if(ord[idx] < low[to.first]){\n                    if(idx < to.first)bridge.push_back(Graph::Edge(idx, to.first, to.second));\n                    else bridge.push_back(Graph::Edge(to.first, idx, to.second));\n                }\n            }\n            else if(to.first != parent){\n                low[idx] = std::min(low[idx], ord[to.first]);\n            }\n        }\n        isArticulation |= (parent==-1 && child_num>1);\n        if(isArticulation) articulation.push_back(idx);\n        return k;\n    }\n    void build(){\n        ll k=0;\n        for(ll i=0; i<G.v; i++){\n            if(!used[i]) k = dfs(i, k, -1);\n        }\n        std::sort(articulation.begin(), articulation.end());\n        std::sort(bridge.begin(), bridge.end(), [](Graph::Edge a, Graph::Edge b){return (a.from==b.from) ? a.to<b.to : a.from<b.from;});\n    }\n};\n\nint main(){\n    ll v,e,s,t;\n    cin >> v >> e;\n    Graph G(v);\n    REP(i,e){\n        cin >> s >> t;\n        G.connect(s,t);\n    }\n    lowlink low(G);\n    low.build();\n    for(auto i : low.bridge){\n        cout << i.from << \" \" << i.to << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\nstruct bridge{\n\tvector<int>ord,low;\n\tvector<bool>art;\n\tvector<pair<int,int> >bridges;\n\tvector<vector<int> >G;\n\tbridge(int n_=0):ord(n_,-1),low(n_),art(n_,false),G(n_){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool operator[](int a){return art[a];}\n\tbool is_bridge(int a,int b)\n\t{\n\t\tif(ord[a]>ord[b])swap(a,b);\n\t\treturn ord[a]<low[b];\n\t}\n\tvoid dfs(int u,int p,int&cnt)\n\t{\n\t\tlow[u]=ord[u]=cnt++;\n\t\tfor(int&v:G[u])\n\t\t{\n\t\t\tif(ord[v]==-1)\n\t\t\t{\n\t\t\t\tdfs(v,u,cnt);\n\t\t\t\tlow[u]=min(low[u],low[v]);\n\t\t\t\tart[u]=art[u]|ord[u]<=low[v];\n\t\t\t\tif(ord[u]<low[v])bridges.push_back(u<v?make_pair(u,v):make_pair(v,u));\n\t\t\t}\n\t\t\telse if(v!=p)\n\t\t\t{\n\t\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tint k=1,cnt=0;\n\t\tlow[0]=ord[0]=0;\n\t\tfor(int&v:G[0])if(ord[v]==-1)\n\t\t{\n\t\t\tdfs(v,0,k);\n\t\t\tif(ord[0]<low[v])bridges.push_back(make_pair(0,v));\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>=2)art[0]=true;\n\t}\n};\n\nmain()\n{\n\tint n,m;cin>>n>>m;\n\tbridge P(n);\n\tvector<pair<int,int> >e;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\tP.add_edge(a,b);\n\t\te.push_back(a<b?make_pair(a,b):make_pair(b,a));\n\t}\n\tP.build();\n\tsort(e.begin(),e.end());\n\tfor(int i=0;i<e.size();i++)if(P.is_bridge(e[i].first,e[i].second))cout<<e[i].first<<\" \"<<e[i].second<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Have FUN\n\nusing namespace std;\n\n#include<bits/stdc++.h>\n\nconst int maxn=1e5+10;\n\nbool mark[maxn];\nint n,m,s,t,h[maxn],up[maxn],par[maxn];\nvector <int> a[maxn];\n\nvoid input()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t}\n}\n\nvoid dfs(int x)\n{\n\tmark[x]=true;\n\tint minn=h[x];\n\tfor(int i=0;i<a[x].size();i++)\n\t{\n\t\tint child=a[x][i];\n\t\tif(!mark[child])\n\t\t{\n\t\t    par[child]=x;\n\t\t\th[child]=h[x]+1;\n\t\t\tdfs(child);\n\t\t\tif(up[child]!=x)\n                minn=min(minn,up[child]);\n\n\t\t}\n\t}\n\tfor(int i=0;i<a[x].size();i++)\n\t{\n\t    if(a[x][i]!=par[x])\n            minn=min(minn,h[a[x][i]]);\n\t}\n\n\tup[x]=minn;\n\n\n}\n\nint main ()\n{\n\tinput();\n\tdfs(0);\n\tfor(int i=0;i<n;i++)\n    {\n\t\tfor(int j=0;j<a[i].size();j++)\n\t\t{\n\t    if( (h[i]>h[a[i][j]]) && (up[i] > h[a[i][j]]) )\n            {\n                cout<<a[i][j]<<\" \"<<i<<endl;\n            }\n\t\t}\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    std::cout << brige.size() << std::endl;\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1) dfs(to, current);\n      if(previous == to)continue;\n      node[current].min_order =\n        min(node[current].min_order,\n            node[to].min_order);\n    }\n    if(node[current].min_order == node[current].order and\n       previous != -1){\n      brige.insert(pii(previous, current));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nvoid DFS(Graph &g, int u, int &clock, vector<int> &low, vector<int> &disc, vector<bool> &seen, vector<int> &parent, vector<Edge> &bridges) {\n    stack<int> s;\n    for(int v: g[u]) {\n        if (! seen[v]) {\n            clock++;\n\n            disc[v] = clock;\n            low[v] = clock;\n            seen[v] = true;\n            parent[v] = u;\n\n            DFS(g, v, clock, low, disc, seen, parent, bridges);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u])\n                bridges.push_back(Edge{min(u, v), max(u, v)});\n        } else if (v != parent[u]) {\n            low[u]  = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> bridges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    int clock = 2;\n    vector<int> low(V, 0);\n    vector<int> disc(V, 0);\n    vector<int> parent(V, -1);\n    vector<bool> seen(V, false);\n    disc[0] = 1;\n    low[0] = 1;\n    seen[0] = true;\n\n    DFS(g, 0, clock, low, disc, seen, parent, bridges);\n\n    sort(bridges.begin(), bridges.end());\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int v = 0, int par = -1){\t//橋の検出\n\t\tif(pre[v] >= 0)return pre[v];\n\t\tpre[v] = low[v] = cnt1++;\n\t\trep(i,G[v].size())if(par != G[v][i]){\n\t\t\tint res = dfs(G[v][i], v);\n\t\t\tlow[v] = min(low[v], res);\n\t\t}\n\t\treturn low[v];\n\t}\n\tint build(int v = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[v] = x;\n\t\tused[v] = 1;\n\t\trep(i,G[v].size())if(!used[G[v][i]]){\n\t\t\tif(pre[G[v][i]] == low[G[v][i]]){\t\t\t//橋\n\t\t\t\tG2[cmp[v]].pb(x+1);G2[x+1].pb(cmp[v]);\n\t\t\t\tchmax(mx, build(G[v][i], x+1));x++;\n\t\t\t}else chmax(mx, build(G[v][i], cmp[v]));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nvector<vector<int> > G, G2;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tG.resize(n);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t\tG[v].pb(u);G[u].pb(v);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G2 = low.G2;\n\tvector<int> cmp = low.cmp;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tint from = cmp[i], to = cmp[G[i][j]];\n\t\t\tif(from != to and i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\tZIP(ans);\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dfs(vvi& g, vector<pi>& res, int v, int& count, int from, vi& low, vi& pre)\n{\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (vi::iterator it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = *it;\n\t\tif (pre[to] == -1) {\n\t\t\tlow[v] = min(low[v], dfs(g, res, to, count, v, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\tres.push_back(make_pair(v, to));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\nvector<pi> bridges(vvi& g, int v) {\n\tvector<pi> res;\n\tif (v > 0) {\n\t\tvi low(v, -1);\n\t\tvi pre(v, -1); \n\t\tint count = 0; \n\t\tdfs(g, res, 0, count, -1, low, pre); //start dfs from vetex 0\n\t}\n\treturn res;\n}\n\nvvi G;\nvector<pi> ans;\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tG.resize(v);\n\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\n\tans = bridges(G, v);\n\tsort(ans.begin(), ans.end());\n\t\n\trep(i, ans.size())\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 77777\nvector<int>X[MAX_N];\nint used[MAX_N];\nint N, M, A, B; queue<int>Q;\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> A >> B; X[A].push_back(B);\n\t\tX[B].push_back(A);\n\t}\n\tif (N == 1) { return 0; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint a1 = i, a2 = X[i][j];\n\t\t\tfor (int k = 0; k < N; k++) { used[i] = 0; }\n\t\t\tused[0] = 1; Q.push(0); int cnt = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint to = Q.front(); Q.pop();\n\t\t\t\tfor (int k = 0; k < X[to].size(); k++) {\n\t\t\t\t\tif (used[X[to][k]] == 0 && (to != i || k != j) ) {\n\t\t\t\t\t\tused[X[to][k]] = 1; Q.push(X[to][k]); cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != N && a1 < a2) { cout << a1 << ' ' << a2 << endl; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nstruct edge {\n    Int from, to, c;\n};\n\nclass Lowlink {\n    int N;\n    vector<int> ord, low;\n\npublic:\n    vector<int> articlulation;\n    vector<pair<int, int>> bridge;\n    vector<vector<int>> G;\n\n    Lowlink(int N) : N(N) {\n        ord.resize(N, -1);\n        low.resize(N, -1);\n        G.resize(N);\n    };\n\n    //　is_undirected : グラフが無向グラフかどうか\n    void add_edge(int from, int to, bool is_undirected = true) {\n        G[from].push_back(to);\n        if (is_undirected) {\n            G[to].push_back(from);\n        }\n    }\n\n\n    void dfs(int v, int &k, int p = -1) {\n        ord[v] = k++;\n        low[v] = ord[v];\n\n        bool is_articulation = false;\n        int ct = 0; // dfs-tree 上の頂点vの子供の数\n\n        for (auto to : G[v]) {\n            if (ord[to] == -1) {\n                ct++;\n                dfs(to, k, v);\n                chmin(low[v], low[to]);\n\n                if (p == -1 && ord[v] <= low[to]) is_articulation = true;\n                if (ord[v] < low[to]) bridge.emplace_back(v, to);\n            }\n            if (to != p) {\n                chmin(low[v], ord[to]);\n            }\n\n        }\n\n        if (p == -1 && ct > 1) is_articulation = true;\n        if (is_articulation) articlulation.push_back(v);\n\n    }\n\n    // 頂点vを根とするdfs木を作成しつつ、lowlink等を求める\n    void compute(int v = 0) {\n        fill(ord.begin(), ord.end(), -1);\n        fill(low.begin(), low.end(), -1);\n\n        int k = 0;\n        dfs(v, k);\n    }\n\n};\n\nclass Solve {\n\npublic:\n    void solve() {\n        Int N, M;\n        cin >> N >> M;\n\n        Lowlink lowlink(N);\n        for (int i = 0; i < M; ++i) {\n            int s, t;\n            cin >> s >> t;\n            lowlink.add_edge(s, t);\n        }\n\n        lowlink.compute();\n\n        auto ans = lowlink.bridge;\n        for (auto &e : ans) {\n            if (e.first > e.second) {\n                swap(e.first, e.second);\n            }\n        }\n\n        sort(all(ans));\n\n        for (auto e : ans) {\n            cout << e.first << \" \" << e.second << endl;\n        }\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, g);\n\n\tfor( auto e : es ){\n\t\tif(???order[e.a] < order[e.b] ){\n\t\t\tcout << e.a << \" \" << e.b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing ll = long long;\nusing namespace std;\n\nstruct edge{\n    int f, t;\n};\n\nconst int V_MAX = (int)1e5;\nconst int E_MAX = (int)1e5;\nvector<int> edges[V_MAX];\nint ord[V_MAX];\nint low[V_MAX];\nbool used_v[V_MAX], used_e[V_MAX][V_MAX];\nvector<edge> ans;\n\nbool comp(edge e1, edge e2){\n    if(e1.f == e2.f){\n        return e1.t < e2.t;\n    } else {\n        return e1.f < e2.f;\n    }\n}\n\nvoid dfs(int u, int k){\n    low[u] = ord[u] = k;\n    k += 1;\n    used_v[u] = true;\n\n    for(int i=0; i<edges[u].size(); i++){\n        int next = edges[u][i];\n\n        if(not used_v[next]){\n            used_e[u][next] = used_e[next][u] = true;\n            dfs(next, k);\n            low[u] = min(low[u], low[next]);\n\n            if(low[next] > ord[u]){\n                edge e;\n                e.f = min(u, next); e.t = max(u, next);\n                ans.push_back(e);\n            }\n        } else if(not used_e[u][next]){\n            low[u] = min(low[u], ord[next]);\n\n        }\n    }\n    return ;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int v, e; \n    cin >> v >> e;\n    memset(used_v, false, sizeof(used_v));\n\n    for(int i=0; i<e; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    dfs(0, 1);\n\n    sort(ans.begin(), ans.end(), comp);\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i].f << \" \" << ans[i].t << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Lowlink{\n    int n,time;\n    vector<int> ord,low;\n    vector<vector<int>> G;\n    vector<int> articulation;\n    vector<pair<int,int>> bridge;\n    Lowlink(int n):n(n),time(0),ord(n,-1),low(n),G(n){}\n    void add_edge(int u,int v){\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    void dfs(int v,int p){\n        ord[v]=low[v]=time++;\n        bool is_articulation=false;\n        int cnt=0;\n        for (int u:G[v]){\n            if (u==p) continue;\n            if (~ord[u]){\n                low[v]=min(low[v],ord[u]);\n                continue;\n            }\n            ++cnt;\n            dfs(u,v);\n            low[v]=min(low[v],low[u]);\n            is_articulation|=(~p&&ord[v]<=low[u]);\n            if (ord[v]<low[u]) bridge.emplace_back(v,u);\n        }\n        is_articulation|=(p<0&&cnt>1);\n        if (is_articulation) articulation.emplace_back(v);\n    }\n    void build(){\n        for (int v=0;v<n;++v){\n            if (ord[v]<0) dfs(v,-1);\n        }\n    }\n};\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_A\n\nvoid GRL_3_A(){\n    int V,E; cin >> V >> E;\n    Lowlink L(V);\n    for (int i=0;i<E;++i){\n        int s,t; cin >> s >> t;\n        L.add_edge(s,t);\n    }\n    L.build();\n    vector<int> ans=L.articulation;\n    sort(ans.begin(),ans.end());\n    for (int v:ans) cout << v << '\\n';\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_B\n\nvoid GRL_3_B(){\n    int V,E; cin >> V >> E;\n    Lowlink L(V);\n    for (int i=0;i<E;++i){\n        int s,t; cin >> s >> t;\n        L.add_edge(s,t);\n    }\n    L.build();\n    vector<pair<int,int>> ans=L.bridge;\n    for (auto &e:ans) if (e.second<e.first)\n        swap(e.first,e.second);\n    sort(ans.begin(),ans.end());\n    for (auto e:ans) cout << e.first << ' ' << e.second << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    GRL_3_B();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\nvector<int> pa[maxn];\nint vis[maxn],low[maxn],dfn[maxn];\nint ind ;\nvector<int> g[maxn];\nvoid tarjan(int u,int p)\n{\n    dfn[u]=low[u]=++ind;\n    vis[u]=1;\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(v==p) continue;\n        if(!vis[v])\n        {\n            tarjan(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u]<low[v])\n                pa[u].push_back(v);\n        }\n        else low[u]=min(low[u],dfn[v]);\n    }\n}\nint v,e;\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    tarjan(0,-1);\n    for(int i=0;i<v;i++)\n    {\n        if(pa[i].size()>0)\n        {\n            for(int j=0;j<pa[i].size();j++)\n            {\n                int ma=max(i,pa[i][j]);\n                printf(\"%d %d\\n\",i+pa[i][j]-ma,ma);\n            }\n\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tbool operator<(const struct Edge &arg) const{\n\t\tif(s != arg.s){\n\t\t\treturn s < arg.s;\n\t\t}else{\n\t\t\treturn t < arg.t;\n\t\t}\n\t}\n\tint s,t;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_edge_id){\n\t\tto = arg_to;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n};\n\nint V,E,number;\nint order[100000],lowlink[100000];\nbool visited[100000];\nEdge edge[100000];\nvector<Info> G[100000];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tnext_node = G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&edge[i].s,&edge[i].t);\n\t\tif(edge[i].s > edge[i].t){\n\t\t\tswap(edge[i].s,edge[i].t);\n\t\t}\n\t\tG[edge[i].s].push_back(Info(edge[i].t,i));\n\t\tG[edge[i].t].push_back(Info(edge[i].s,i));\n\t}\n\n\tsort(edge,edge+E);\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\n\trecursive(0);\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tfrom = edge[i].s;\n\t\tto = edge[i].t;\n\n\t\tif(order[edge[i].s] > order[edge[i].t]){\n\t\t\tswap(from,to);\n\t\t}\n\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"%d %d\\n\",edge[i].s,edge[i].t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint n, m; // number of nodes, edges\n\nvvi edge;\nvvi g;\nvi prenum;\nvi lowest;\nvi parent;\nint timer;\n\nset<pii> bridge() {\n  sort(all(edge));\n  prenum.assign(n, -1);\n  lowest.assign(n, 0);\n  parent.assign(n, 0);\n  deque<pii> stk;\n  stk.push_back(make_pair(0, -1)); // (current, previous)\n  parent[0] = -1;\n  for (int timer = 0; !stk.empty(); ++timer) {\n    auto state = stk.back();\n    if (prenum[state.first] < 0) {\n      prenum[state.first] = lowest[state.first] = timer;\n      timer += 1;\n      for (auto v : g[state.first]) {\n        if (prenum[v] >= 0) {\n          if (v == state.second) {\n            continue;\n          } else {\n            lowest[state.first] = min(lowest[state.first], lowest[v]);\n          }\n        } else {\n          stk.push_back(make_pair(v, state.first));\n          parent[v] = state.first;\n        }\n      }\n    }\n    if (stk.back() == state) {\n      stk.pop_back();\n    }\n  }\n\n  set<pii> ret;\n  FOR(i, 1, n) {\n    if (prenum[parent[i]] < lowest[i]) {\n      int mi = min(parent[i], i);\n      int ma = max(parent[i], i);\n      ret.insert(make_pair(mi, ma));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  edge.assign(m, vi(2, 0));\n  g.resize(n);\n  rep (i, m) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    if (s > t) {\n      swap(s, t);\n    }\n    edge[i][0] = s;\n    edge[i][1] = t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  sort(all(edge));\n  auto ans = bridge();\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX=100000;\n\nint n;\nvector<int> G[MAX];\nint order[MAX]={};\nbool inS[MAX]={};\nstack<int> roots,S;\nint k;\nvector<P> brg;\nvector<vector<int>> each_bcc;\n\nvoid visit(int v,int p)\n{\n\torder[v]=++k;\n\tS.push(v);\n\tinS[v]=true;\n\troots.push(v);\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint to=G[v][i];\n\t\tif(order[to]==0)\n\t\t{\n\t\t\tvisit(to,v);\n\t\t}\n\t\telse if(to!=p&&inS[to])\n\t\t{\n\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top())\n\t{\n\t\tif(p!=-1)brg.push_back(P(p,v));\n\t\tvector<int> bcc;\n\t\twhile(1)\n\t\t{\n\t\t\tint node=S.top();S.pop();\n\t\t\tinS[node]=false;\n\t\t\tbcc.push_back(node);\n\t\t\tif(node==v)break;\n\t\t}\n\t\teach_bcc.push_back(bcc);\n\t\troots.pop();\n\t}\n\treturn;\n}\n\nvoid bridge()\n{\n\tk=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(order[i]==0)\n\t\t{\n\t\t\tvisit(i,-1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tcin>>n;\n\tint e;\n\tcin>>e;\n\tint u,v;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbridge();\n\tsort(brg.begin(),brg.end());\n\tfor(int i=0;i<brg.size();i++)cout<<brg[i].first<<\" \"<<brg[i].second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <math.h>\n\n#define ll long long\n#define Int int\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(Int x = start; x > end; x--)\n\nusing namespace std;\n\n#define MAX_V 10000\n\nvector<Int> graph[MAX_V];\nbool used_v[MAX_V],used_e[MAX_V][MAX_V];\nInt ord[MAX_V],lowlink[MAX_V];\nInt k=0;\nvector<pair<Int, Int> > bridges;\n\nbool compare (pair<Int, Int> a, pair<Int, Int> b) {\n  if (a.first != b.first)  return a.first < b.first;\n  if (a.second != b.second) return a.second < b.second;\n  return false;\n}\n\nvoid dfs(Int v, Int parent) {\n  used_v[v] = true;\n  ord[v]=lowlink[v]=k++;\n  \n  for (Int u: graph[v]) {\n    if(!used_v[u]) {\n      used_e[v][u] = true;\n      dfs(u, v);\n      lowlink[v] = min(lowlink[v], lowlink[u]);\n      if (ord[v] < lowlink[u]) {\n        if (v < u) bridges.push_back(make_pair(v, u));\n        else bridges.push_back(make_pair(u, v));\n      }\n    }\n    else if(!used_e[u][v]) {\n      lowlink[v] = min(lowlink[v], ord[u]);\n    }\n  }\n}\n\nInt main(void) {\n  Int n, e, u, v;\n  cin >> n >> e;\n  loop(i,0,e) {\n    cin >> u >> v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  dfs(0, -1);\n  sort(bridges.begin(), bridges.end(), compare);\n  for (auto b: bridges) cout << b.first << ' ' << b.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'000LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\ni64 ipow(i64 x, i64 e) {\n    assert(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& e) { e = v; });\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nstruct IDENTITY {\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n#ifdef PROCON_LOCAL\n    cerr.flush();\n#endif\n    cout.flush();\n    _Exit(0);\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_ARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n#define DBG_ARRAY(expr) DBG_ARRAY_IMPL(__LINE__, #expr, (expr))\n#define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, #first, #last, (first), (last))\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// graph (container が必要) {{{\n\nvector<vector<i64>> graph_make_unweighted(i64 n) {\n    return vector<vector<i64>>(n);\n}\n\n// TODO: 重みあり/なし両対応\n// (関節点リスト,橋リスト) を返す\ntuple<vector<i64>,vector<pair<i64,i64>>> graph_lowlink(const vector<vector<i64>>& g) {\n    i64 n = SIZE(g);\n    vector<i64> ord(n, -1);\n    vector<i64> low(n, -1);\n\n    vector<i64>           articulations;\n    vector<pair<i64,i64>> bridges;\n\n    auto dfs = FIX([&g,&ord,&low,&articulations,&bridges](auto self, i64 v, i64 parent, i64 k) -> void {\n        low[v] = ord[v] = k;\n\n        bool arti = false;\n        i64 n_child = 0;\n        for(i64 to : g[v]) {\n            // 親または後退辺\n            if(ord[to] != -1) {\n                if(to != parent)\n                    chmin(low[v], ord[to]);\n                continue;\n            }\n\n            // 子を辿り、low[v] を更新\n            ++n_child;\n            self(to, v, k+1);\n            chmin(low[v], low[to]);\n\n            // 関節点判定(根でない場合)\n            if(parent != -1 && low[to] >= ord[v])\n                arti = true;\n\n            // 橋判定\n            if(low[to] > ord[v])\n                bridges.emplace_back(minmax(v,to));\n        }\n        // 関節点判定(根の場合)\n        if(parent == -1 && n_child > 1)\n            arti = true;\n\n        if(arti)\n            articulations.emplace_back(v);\n    });\n    dfs(0, -1, 0);\n\n    return make_tuple(articulations, bridges);\n}\n\n// }}}\n\n//--------------------------------------------------------------------\n\n\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 M; RD(M);\n\n    auto G = graph_make_unweighted(N);\n    REP(_, M) {\n        i64 s,t; RD(s); RD(t);\n        G[s].emplace_back(t);\n        G[t].emplace_back(s);\n    }\n\n    vector<pair<i64,i64>> bridges;\n    tie(ignore,bridges) = graph_lowlink(G);\n\n    ALL(sort, bridges);\n\n    ALL(for_each, bridges, GENERIC(PRINTLN));\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\npair<int, int> a[200010];\nint s[100001];\nint g[100001];\nint n[100001];\nint p[100001];\nint l[100001];\nint u[100001]={};\nint c, t;\nint x, y;\nint k;\n\nvoid dfs(int f, int z)\n{\n\tn[f]=t;\n\tl[f]=t;\n\tt++;\n\tu[f]=1;\n\tfor(int i=s[f]; i<=g[f]; i++)\n\t{\n\t\tif(u[a[i].second]==0)\n\t\t{\n\t\t\tp[a[i].second]=f;\n\t\t\tdfs(a[i].second, f);\n\t\t\tl[f]=min(l[f], l[a[i].second]);\n\t\t}\n\t\telse if(a[i].second!=z)\n\t\t{\n\t\t\tl[f]=min(l[f], n[a[i].second]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tfor(int i=0; i<e; i++)\n\t{\n\t\tcin >> x >> y;\n\t\ta[2*i]=make_pair(x, y);\n\t\ta[2*i+1]=make_pair(y, x);\n\t}\n\tsort(a, a+(2*e));\n\ts[0]=0;\n\tg[v-1]=2*e-1;\n\tc=0;\n\tfor(int i=1; i<2*e; i++)\n\t{\n\t\tif(a[i].first>a[i-1].first)\n\t\t{\n\t\t\tg[c]=i-1;\n\t\t\tc++;\n\t\t\ts[c]=i;\n\t\t}\n\t}\n\tt=0;\n\tdfs(0, -1);\n\tk=0;\n\tfor(int i=1; i<v; i++)\n\t{\n\t\tif(p[i]==0)\n\t\t{\n\t\t\tk++;\n\t\t}\n\t}\n\tif(k>1)\n\t{\n\t\tfor(int i=s[0]; i<=g[0]; i++)\n\t\t{\n\t\t\tif(p[a[i].second]=0)\n\t\t\t{\n\t\t\t\tcout << 0 << \" \" << a[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if(s[0]==g[0])\n\t{\n\t\tcout << 0 << \" \" << a[g[0]].second << endl;\n\t}\n\tfor(int i=s[1]; i<2*e; i++)\n\t{\n\t\tif(a[i].first<a[i].second)\n\t\t{\n\t\t\tif(p[a[i].first]==a[i].second)\n\t\t\t{\n\t\t\t\tif(n[a[i].second]<=l[a[i].first])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p[a[i].second]==a[i].first)\n\t\t\t{\n\t\t\t\tif(n[a[i].first]<=l[a[i].second])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v,int p){\t//make ord and lowlink\n\tused[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!used[to]){\n\t\t\tdfs(to,v);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(used[to]&&to!=p){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\nvector<pii> enumerateBridge(int e){\t//????????????\n\tvector<pii> ret;\n\t\n\trep(i,MAX_V){\n\t\trep(j,G[i].size()){\n\t\t\tint from = i, to = G[i][j];\n\t\t\tif(ord[from]>ord[to])continue;\n\t\t\tif(ord[from]<lowlink[to])ret.pb(pii(from,to));\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0,-1);\n\t\n\tvector<pii> ans = enumerateBridge(e);\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#line 2 \"lib/graph/lowlink.cpp\"\n\n#line 2 \"lib/graph/graph.cpp\"\n\n#line 2 \"lib/template.cpp\"\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing VLL = vector<ll>;\nusing VVLL = vector<vector<ll>>;\nusing VB = vector<bool>;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\nconstexpr int INF = 1000000007;\nconstexpr ll INF_LL = 1'000'000'000'000'000'007;\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define newl '\\n'\n\n// loops rep(until) / rep(var, until) / rep(var, from, until) / repr (reversed order)\n#define OVERLOAD3(_1, _2, _3, name, ...) name\n#define rep(...) OVERLOAD3(__VA_ARGS__, REPEAT_FROM_UNTIL, REPEAT_UNTIL, REPEAT)(__VA_ARGS__)\n#define REPEAT(times) REPEAT_CNT(_repeat, __COUNTER__, times)\n#define REPEAT_CNT(_repeat, cnt, times) REPEAT_CNT_CAT(_repeat, cnt, times)\n#define REPEAT_CNT_CAT(_repeat, cnt, times) REPEAT_FROM_UNTIL(_repeat ## cnt, 0, times)\n#define REPEAT_UNTIL(name, times) REPEAT_FROM_UNTIL(name, 0, times)\n#define REPEAT_FROM_UNTIL(name, from, until) for (int name = from, name ## __until = (until); name < name ## __until; name++)\n#define repr(...) OVERLOAD3(__VA_ARGS__, REPR_FROM_UNTIL, REPR_UNTIL, REPEAT)(__VA_ARGS__)\n#define REPR_UNTIL(name, times) REPR_FROM_UNTIL(name, 0, times)\n#define REPR_FROM_UNTIL(name, from, until) for (int name = (until)-1, name ## __from = (from); name >= name ## __from; name--)\n\ntemplate <typename T, typename U>\nbool chmin(T& var, U x) { if (var > x) { var = x; return true; } else return false; }\ntemplate <typename T, typename U>\nbool chmax(T& var, U x) { if (var < x) { var = x; return true; } else return false; }\nll power(ll e, ll t, ll mod = INF_LL) {\n  ll res = 1; for (; t; t >>= 1, (e *= e) %= mod) if (t & 1) (res *= e) %= mod; return res;\n}\ntemplate <typename T, typename U> T divceil(T m, U d) { return (m + d - 1) / d; }\ntemplate <typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_v(size_t a, Ts... ts) {\n  return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\n// debugging stuff\n#define repi(it, ds) for (auto it = ds.begin(); it != ds.end(); it++)\nclass DebugPrint { public: template <typename T> DebugPrint& operator <<(const T& v) {\n#ifdef LOCAL\n    cerr << v;\n#endif\nreturn *this; } } debugos; template <typename T> DebugPrint& operator<<(DebugPrint& os, const\nvector<T>& vec) { os << \"{\"; for (int i = 0; i < vec.size(); i++) os << vec[i] << (i + 1 ==\nvec.size() ? \"\" : \", \"); os << \"}\"; return os; } template <typename T, typename U> DebugPrint&\noperator<<(DebugPrint& os, const map<T, U>& map_var) { os << \"{\"; repi(itr, map_var) { os << *\nitr; itr++; if (itr != map_var.end()) os << \", \"; itr--; } os << \"}\"; return os; } template <\ntypename T> DebugPrint& operator<<(DebugPrint& os, const set<T>& set_var) { os << \"{\"; repi(\nitr, set_var) { os << *itr; itr++; if (itr != set_var.end()) os << \", \"; itr--; } os << \"}\";\nreturn os; } template <typename T, typename U> DebugPrint& operator<<(DebugPrint& os, const\npair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; } void dump_func(\n) { debugos << newl; } template <class Head, class... Tail> void dump_func(Head &&head, Tail\n&&... tail) { debugos << head; if (sizeof...(Tail) > 0) { debugos << \", \"; } dump_func(forward\n<Tail>(tail)...); }\n#ifdef LOCAL\n#define dump(...) debugos << \"  \" << string(#__VA_ARGS__) << \": \" << \"[\" << to_string(__LINE__) \\\n<< \":\" << __FUNCTION__ << \"]\" << newl << \"    \", dump_func(__VA_ARGS__)\n#else\n#define dump(...) ((void)0)\n#endif\n\n\n#line 4 \"lib/graph/graph.cpp\"\n\nstruct Edge {\n  int to; ll cost;\n  Edge(int _to) : to(_to), cost(1) {}\n  Edge(int _to, ll _cost) : to(_to), cost(_cost) {}\n  operator int() const { return to; }\n};\n\nusing Graph = vector<vector<Edge>>;\n#line 4 \"lib/graph/lowlink.cpp\"\n\nstruct LowLink {\n  int n, root;\n  VI ord, low, par;\n  VB cutv;\n  LowLink(const Graph& graph, int root_ = 0)\n      : n(graph.size()), root(root_), ord(n, -1), low(n), par(n, -1), cutv(n) {\n    int t = 0;\n    auto dfs = [&](auto f, int v) -> void {\n      ord[v] = low[v] = t++;\n      for (auto e : graph[v])\n        if (e.to != par[v]) {\n          if (ord[e.to] == -1) par[e.to] = v, f(f, e.to), chmin(low[v], low[e.to]);\n          else chmin(low[v], ord[e.to]);\n        }\n    };\n    dfs(dfs, root);\n    int root_deg = 0;\n    rep(i, n) root_deg += par[i] == root;\n    cutv[root] = root_deg > 1;\n    rep(i, n) if (i != root and par[i] != root and ord[par[i]] <= low[i]) cutv[par[i]] = true;\n    dump(par);\n    dump(ord);\n    dump(low);\n  }\n  bool is_bridge(int u, int v) {\n    if (u != par[v]) swap(u, v);\n    assert(u == par[v]);\n    return ord[u] < low[v];\n  }\n  bool is_bridge(int v) {\n    return ord[par[v]] < low[v];\n  }\n  bool is_cutv(int v) { return cutv[v]; }\n};\n#line 2 \"main.cpp\"\n\nint main() {\n  cin.tie(0); ios_base::sync_with_stdio(0);\n\n  int v, e; cin >> v >> e;\n  Graph graph(v);\n  rep(e) {\n    int u, v; cin >> u >> v;\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n  }\n  auto l = LowLink(graph);\n  vector<PII> res;\n  rep(i, 1, v) if (l.is_bridge(i)) res.emplace_back(minmax(l.par[i], i));\n  sort(all(res));\n  rep(i, res.size()) printf(\"%d %d\\n\", res[i].first, res[i].second);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nset< pair<int,int> > bad;\n\nint dfs(int x, int p, Edge e, const vector< vector<Edge> > &g){\n\tvisited[x] = ++currentTime;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, e, g));\n\t\t}\n\t}\n\tif( p != -1 && ans > visited[p] ){\n\t\tbad.insert({x,p});\n\t\tbad.insert({p,x});\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, {}, g);\n\n\tvector< pair<int,int> > a;\n\tfor( auto e : es ){\n\t\tif( bad.count({e.a, e.b}) ){\n\t\t\ta.push_back({e.a,e.b});\n\t\t}\n\t}\n\tsort(a.begin(),a.end());\n\tfor( auto p : a ){\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n// typedef __int128_t Int;\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n// Bridges in a undirected graph\nstruct Bridge {\n  int V;\n  vector<vector<int>> G;\n  vector<int> visited, lowest, parent, prenum;\n  Bridge() {}\n  Bridge(int V) : V(V), G(V), visited(V), prenum(V), parent(V), lowest(V) {}\n  void add_edge(int s, int t) {\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  void dfs(int cur, int prev, vector<pair<int, int>> &b) {\n    static int time = 0;\n    visited[cur] = true;\n    prenum[cur] = lowest[cur] = ++time;\n    for (auto next : G[cur]) {\n      if (not visited[next]) {\n        parent[next] = cur;\n        dfs(next, cur, b);\n        lowest[cur] = min(lowest[cur], lowest[next]);\n        if (lowest[next] > prenum[cur]) {\n          b.push_back(make_pair(cur, next));\n        }\n      } else if (next != prev) {\n        lowest[cur] = min(lowest[cur], lowest[next]);\n      }\n    }\n  }\n  vector<pair<int, int>> bridges() {\n    fill(all(visited), false);\n    vector<pair<int, int>> b;\n    for (int i = 0; i < V; i++) {\n      if (not visited[i]) {\n        dfs(i, -1, b);\n      }\n    }\n    return b;\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int V, E;\n  cin >> V >> E;\n  Bridge g(V);\n  loop(E) {\n    int s, t;\n    cin >> s >> t;\n    g.add_edge(s, t);\n  }\n  auto b = g.bridges();\n  for (auto &e : b) {\n    if (e.first > e.second)\n      swap(e.first, e.second);\n  }\n  sort(all(b));\n  for (auto e : b) {\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nvoid Lowlink(BiDGraph& g,vector<int>& lowlink, vector<int>& orb) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int,int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) continue;\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first,cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0,-1);\n\treturn;\n}\n\nvoid Bridge(BiDGraph& g, vector<pii>& bridges) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({i, itr.first});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Joint(BiDGraph& g, vector<int>& joints) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr : bridges) {\n\t\tif (itr.first > itr.second) swap(itr.first, itr.second);\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int MAX_n = 1e5, MAX_m = 1e5;\n\nint n, m;\nvector<int> adj[MAX_n];\nint h[MAX_n], f[MAX_n];\nbool mark[MAX_n] = {};\nvector<pii> ceg;\n\nvoid add(int a, int b) {\n\tif (a > b) swap(a, b);\n\tceg.push_back(pii(a, b));\n}\n\nvoid DFS(int v, int p) {\n\tif (mark[v]) return;\n\tmark[v] = true;\n\tf[v] = h[v];\n\tfor (int u : adj[v]) {\n\t\tif (!mark[u]) {\n\t\t\th[u] = h[v] + 1;\n\t\t\tDFS(u, v);\n\t\t\tif (f[u] > h[v]) add(u, v);\n\t\t\telse f[v] = min(f[v], f[u]);\n\t\t}\n\t\telse if (u != p)\n\t\t\tf[v] = min(f[v], h[u]);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\th[0] = 0;\n\tDFS(0, -1);\n\tsort(ceg.begin(), ceg.end());\n\tfor (pii i : ceg)\n\t\tcout << i.first << ' ' << i.second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, g);\n\n\tfor( auto e : es ){\n\t\tif( !visited[e.a] || !visited[e.b] || order[e.a] < order[e.b] ){\n\t\t\tcout << e.a << \" \" << e.b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n\tlow[v]=min(low[v],ord[u]);\n      }else{\n\tdfs(u,v,k);\n\tlow[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(v,u)) B.push_back(P(v,u));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(v,u)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  bcc.input(e,0);\n  bcc.build();\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}\n\n/*\n  verified on 2017/12/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<pair<ll,ll> > vpll;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<ll> > vvll;\ntypedef map<int, int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define itn int\n// #define endl '\\n';\n#define fi first\n#define se second\n#define NONVOID [[nodiscard]]\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ntemplate <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\\n':' ');}}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\n\nclass Bridge {\n    int N, num = 0;\n    vvi G;\n    vi pre, low;\n    vb isPassed;\n    vpii bridges;\n\n    int culcLow(const int v, const int bef) {\n        int nowLow = num;\n        low[v] = pre[v] = nowLow;\n        for(auto ne : G[v]) {\n            if(ne == bef) continue;\n            if(ne == 0) {\n                low[0] = -1;\n            }\n            if(pre[ne] == -1) {\n                num++;\n                culcLow(ne, v);\n            }\n            chmin(nowLow, low[ne]);\n        }\n        return low[v] = nowLow;\n    }\n\n    void traceGraph(const int v, const int bef) {\n        for(auto ne : G[v]) {\n            if(ne == bef) continue;\n            if(!isPassed[ne]) {\n                if(low[ne] == pre[ne]) {\n                    bridges.emplace_back(min(v, ne), max(v, ne));\n                }\n                isPassed[ne] = true;\n                traceGraph(ne, v);\n            }\n        }\n    }\n\npublic:\n    Bridge(const int _n, const vvi _G) : N(_n), G(_G) {\n        pre = vi(N, -1);\n        low = vi(N, INF);\n        isPassed = vb(N, false);\n        isPassed[0] = true;\n    }\n\n    void findBridges() {\n        culcLow(0, -1);\n        traceGraph(0, -1);\n        Sort(bridges);\n    }\n\n    void show() {\n        for(auto p : bridges) {\n            cout << p.fi << \" \" << p.se << endl; \n        }\n    }\n};\n\nint main() {\n\n    int v, e;\n    cin >> v >> e;\n    vvi g(v);\n    rep(i, e) {\n        int s, t;\n        cin >> s >> t;\n        g[s].pb(t);\n        g[t].pb(s);\n    }\n    Bridge bg(v, g);\n    bg.findBridges();\n    bg.show();\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rnk;\n\nvoid init(int n){\n    parent.clear();\n    rnk.clear();\n    for(int i=0; i<n; i++){\n        parent.push_back(i);\n        rnk.push_back(0);\n    }\n}\n\nint find(int x){\n    if(x == parent[x]){\n        return x;\n    } else {\n        return parent[x] = find(parent[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    if(x == y) return;\n\n    if(rnk[x] < rnk[y]){\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct edge{\n    int from, to;\n};\n\nbool comp(edge& e1, edge e2){\n    if(e1.from == e2.from){\n        return e1.to < e2.to;\n    } else {\n        return e1.from < e2.from;\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector<edge> es(e);\n    for(int i=0; i<e; i++){\n        edge ed;\n        cin >> ed.from >> ed.to;\n        es[i] = ed;\n    }\n\n    sort(es.begin(), es.end(), comp);\n\n    int cnt = 0;\n    for(int i=0; i<e; i++){\n        init(v);\n        for(int j=0; j<e; j++){\n            if(i == j) continue;\n            edge e = es[j];\n            unite(e.from, e.to);\n        }\n\n        bool is_same = true;\n        for(int j=0; j<v-1 && is_same; j++){\n            if(!same(j, j+1)){\n                is_same = false;\n                edge e = es[i];\n                cout << e.from << \" \" << e.to << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dfs(vvi& g, vector<pi>& res, int v, int& count, int from, vi& low, vi& pre)\n{\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (vi::iterator it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = *it;\n\t\tif (pre[to] == -1) {\n\t\t\n\t\t\tlow[v] = min(low[v], dfs(g, res, to, count, v, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\tres.push_back(make_pair(min(to,v), max(to,v)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// g: adjacency list\n// v:number of nodes\n\nvector<pi> bridges(vvi& g, int v) {\n\tvector<pi> res;\n\tif (v > 0) {\n\t\t\n\t\tvi low(v, -1); \n\t\tvi pre(v, -1); \n\t\tint count = 0; \n\t\tdfs(g, res, 0, count, -1, low, pre); \n\t}\n\treturn res;\n}\n\nvvi G;\nvector<pi> ans;\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tG.resize(v);\n\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\n\tans = bridges(G, v);\n\tsort(ans.begin(), ans.end());\n\t\n\trep(i, ans.size())\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> g[100010];\n\nint zeit, dis[MAXN], fin[MAXN], low[MAXN], par[MAXN], dep[MAXN];\nint kodat[MAXN], koptr[MAXN + 1];\nvoid dfsInfo(int u,int oy,int d){\n\tdis[u] = low[u] = zeit++; par[u] = oy; dep[u] = d;\n\tint v;\n\trep(i,sz(g[u])) if((v = g[u][i]) != oy){\n\t\tif(!~dis[v]){\n\t\t\tdfsInfo(v, u, d + 1);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], dis[v]);\n\t\t}\n\t}\n\tfin[u] = zeit++;\n}\n\nvoid dfsInfos(){\n\tmemset(dis, ~0, n*4); zeit = 0;\n\trep(u,n) if(!~dis[u]) dfsInfo(u, -1, 0);\n\trep(u,n){\n\t\tint &j = koptr[u + 1] = koptr[u];\n\t\trep(i,sz(g[u])) if(u == par[g[u][i]]) kodat[j++] = g[u][i];\n\t}\n}\n\nbool produce(int u,int v){\n\treturn (dis[u] <= dis[v] && fin[u] >= fin[v]);\n}\n\nint related(int u,int v){\n\tint s = koptr[u], e = koptr[u+1], h;\n\twhile(s+1 < e){\n\t\th = (s + e) >> 1;\n\t\t(dis[kodat[h]] <= dis[v]) ? s = h : e = h;\n\t}\n\treturn kodat[s];\n}\n\nbool isBridge(int u,int v){\n\tif(dis[u] > dis[v]) swap(u, v);\n\treturn (u == par[v] && dis[v] <= low[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\n\tint m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\trep(i,n)sort(g[i].begin(),g[i].end());\n\tdfsInfos();\n\trep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && isBridge(i,g[i][j]))cout<<i<<\" \"<<g[i][j]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = int_fast64_t;\n\nclass edge{\npublic:\n\tInt cost;\n\tsize_t from, to;\n\tedge(Int c, size_t f, size_t t){\n\t\tcost = c;\n\t\tfrom = f;\n\t\tto = t;\n\t}\n};\nusing edges = vector<edge>;\nusing graph = vector<edges>;\nvoid readgraph(graph &g, size_t E, bool D, bool C, bool Z){ // E:num_of_edges, D:directed, C:costed, Z:already 0-indexed\n\tfor(size_t i=0; i<E; ++i){\n\t\tedge e(1, 0, 0);\n\t\tif(!C) cin >> e.from >> e.to;\n\t\telse cin >> e.from >> e.to >> e.cost;\n\t\tif(!Z){\n\t\t\t--e.from;\n\t\t\t--e.to;\n\t\t}\n\t\tg[e.from].push_back(e);\n\t\tif(!D){\n\t\t\tswap(e.from, e.to);\n\t\t\tg[e.from].push_back(e);\n\t\t}\n\t}\n}\nclass tree{\npublic:\n\tInt n;\n\tInt root;\n\tgraph g;\n\tvector<Int> parent;\n\tvector<vector<Int>> child;\n\n\ttree(Int _n) : n(_n) {root = -1; parent.resize(n, -1); child.resize(n);}\n\ttree(Int r, vector<Int> p) : n(p.size()), root(r), parent(p) {}\n\ttree(graph _g) : n(_g.size()), g(_g) {}\n\n\tvoid set_root(Int r){\n\t\troot = r;\n\t\tparent.resize(n, -1);\n\t\tparent[r] = r;\n\t\tchild.resize(n, vector<Int>());\n\t\tqueue<Int> q;\n\t\tq.push(r);\n\t\twhile(!q.empty()){\n\t\t\tInt p = q.front(); q.pop();\n\t\t\tfor(auto i:g[p]){\n\t\t\t\tInt t = i.to;\n\t\t\t\tif(parent[t] == -1){\n\t\t\t\t\tparent[t] = p;\n\t\t\t\t\tchild[p].push_back(t);\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid find_children(Int r){\n\t\troot = r;\n\t\tchild.resize(n, vector<Int>());\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tif(parent[i] != i)\n\t\t\t\tchild[parent[i]].push_back(i);\n\t}\n};\nclass graph_util{\npublic:\n\tstatic void rec_dfs(graph &g, tree &t, vector<Int> &ord, vector<Int> &low, Int &cnt, Int v, Int p){\n\t\tt.parent[v] = p;\n\t\tord[v] = cnt;\n\t\t++cnt;\n\t\tlow[v] = ord[v];\n\t\tfor(auto i:g[v]){\n\t\t\tInt to = i.to;\n\t\t\tif(ord[to] == -1){\n\t\t\t\trec_dfs(g, t, ord, low, cnt, to, v);\n\t\t\t\tlow[v] = min(low[v], low[to]);\n\t\t\t}else if(p != to){\n\t\t\t\tlow[v] = min(low[v], ord[to]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic tree build_dfs_tree(graph &g, Int s, vector<Int> &ord, vector<Int> &low){\n\t\ttree t(g.size());\n\t\tord.resize(g.size(), -1);\n\t\tlow.resize(g.size(), g.size());\n\t\tInt cnt = 0;\n\t\trec_dfs(g, t, ord, low, cnt, s, s);\n\t\tt.find_children(s);\n\t\treturn t;\n\t}\n\tstatic vector<Int> find_articulation_point(tree &dfs_tree, vector<Int> &ord, vector<Int> &low){\n\t\tvector<Int> res;\n\t\tif((Int)dfs_tree.child[dfs_tree.root].size() > 1) res.push_back(dfs_tree.root);\n\t\tfor(Int i=0; i<(Int)ord.size(); ++i){\n\t\t\tif(i == dfs_tree.root) continue;\n\t\t\tfor(auto j:dfs_tree.child[i]){\n\t\t\t\tif(ord[i] <= low[j]){\n\t\t\t\t\tres.push_back(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tstatic vector<pair<Int, Int>> find_bridge(tree &dfs_tree, vector<Int> &ord, vector<Int> &low){\n\t\tvector<pair<Int, Int>> res;\n\t\tfor(Int i=0; i<(Int)ord.size(); ++i){\n\t\t\tif(i == dfs_tree.root) continue;\n\t\t\tInt p = dfs_tree.parent[i];\n\t\t\tif(ord[p] < low[i]) res.push_back(make_pair(p, i));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tInt v, e; cin >> v >> e;\n\tgraph g(v);\n\treadgraph(g, e, false, false, true);\n\tvector<Int> ord, low;\n\ttree dfs_tree(graph_util::build_dfs_tree(g, 0, ord, low));\n\tvector<pair<Int, Int>> bridges(graph_util::find_bridge(dfs_tree, ord, low));\n\tfor(auto &i:bridges) if(i.first > i.second) swap(i.first, i.second);\n\tsort(bridges.begin(), bridges.end());\n\tfor(auto i:bridges) cout << i.first << \" \" << i.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (isBridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or isBridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nvoid Lowlink(BiDGraph& g,vector<int>& lowlink, vector<int>& orb) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int,int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) continue;\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first,cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0,-1);\n\treturn;\n}\n\nvoid Bridge(BiDGraph& g, vector<pii>& bridges) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({i, itr.first});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Joint(BiDGraph& g, vector<int>& joints) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr : bridges) {\n\t\tif (itr.first > itr.second) swap(itr.first, itr.second);\n\t}\n\tsort(ALL(bridges));\n\tfor (auto itr : bridges) {\n\t\tif (itr.first > itr.second) swap(itr.first, itr.second);\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int ord, low;\n};\n\nclass BridgeFind{\npublic:\n  BridgeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  vector<pii> find(){\n    if(v_ord == 0)dfs();\n    return bridge;\n  }\nprivate:\n  void dfs(int v  = 0,\n           int previous = -1){\n    node[v].ord = node[v].low = v_ord++;\n    int to;\n    for (int i = 0; i < g[v].size(); i++) {\n      to = g[v][i];\n      if(previous == to)continue;\n      if(node[to].ord == -1) dfs(to, v);\n      node[v].low = min(node[v].low, node[to].low);\n    }\n    if(node[v].low == node[v].ord and previous != -1){\n      if(previous > v)bridge.emplace_back(pii(v, previous)); \n      else bridge.emplace_back(pii(previous, v));      \n    }\n\n  }\n  int v_ord = 0;\n  vector<pii> bridge;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BridgeFind bf(g);\n  vector<pii> bridge = bf.find();\n  sort(bridge.begin(), bridge.end());\n  for (int i = 0; i < bridge.size(); i++) {\n    std::cout << bridge[i].first << \" \" << bridge[i].second << std::endl;\n  }\n  // for (auto i: bridge){\n  //   std::cout << i.first << \" \" << i.second << std::endl;\n  // }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int src, int to, T cost): src(src), to(to), cost(cost) {}\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\ntemplate<typename T>\nstruct LowLink {\n    const int inf = 1000000000;\n    int sz;\n    std::vector<int> pre, low;\n    std::vector<bool> sel;\n    std::vector<std::pair<int, int>> bridge;\n    std::vector<int> articulation;\n\n    LowLink(const Graph<T> &g) {\n        sz = g.size();\n        pre.resize(sz, inf);\n        low.resize(sz, inf);\n        sel.resize(sz, false);\n        int cnt = 0;\n        dfs(g, 0, -1, cnt);\n    }\n\n    void dfs(const Graph<T> &g, int now, int prev, int &cnt) {\n        if(pre[now] != inf) {\n            low[prev] = min(low[prev], pre[now]);\n            return;\n        }\n        pre[now] = cnt;\n        low[now] = cnt;\n        cnt++;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int nxt = g[now][i].to;\n            //if g is an undirected graph\n            if(nxt == prev) continue;\n            dfs(g, nxt, now, cnt);\n        }\n        if(prev != -1) low[prev] = min(low[prev], low[now]);\n        if(prev != -1 && pre[prev] < low[now]) {\n            bridge.emplace_back(make_pair(prev, now));\n        }\n    }\n\n    void get_articulation(const Graph<T> &g, int now, int prev) {\n        sel[now] = true;\n        int art = 0;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int nxt = g[now][i].to;\n            //cout << now << \":\" << nxt << endl;\n            if(sel[nxt]) continue;\n            // if g is an undirected graph\n            if(nxt == prev) continue;\n            if(now == 0 || pre[now] <= low[nxt]) art++;\n            get_articulation(g, nxt, now);\n        }\n        if((now == 0 && art >= 2) || (now != 0 && art >= 1)) articulation.push_back(now);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    \n    int n, m; cin >> n >> m;\n    Graph<int> g(n);\n    REP(i, m) {\n        int u, v; cin >> u >> v;\n        g[u].push_back(edge<int>(u, v, 1));\n        g[v].push_back(edge<int>(v, u, 1));\n    }\n\n    LowLink<int> link(g);\n    // link.get_articulation(g, 0, -1);\n    \n/*     cout << \"low\" << endl;\n    for(const auto &e: link.low) {\n        cout << e << endl;\n    }\n    cout << \"pre\" << endl;\n    for(const auto &e: link.pre) {\n        cout << e << endl;\n    }\n    cout << \"art\" << endl; */\n\n    for(auto &e: link.bridge) {\n        if(e.first > e.second) swap(e.first, e.second);\n    }\n    sort(link.bridge.begin(), link.bridge.end());\n    for(const auto &e: link.bridge) {\n        cout << e.first << \" \" << e.second << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\n\nvoid visit(int cur, int prev, vector<pii> &brg, vector<vector<int>> &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n\torder[cur] = ++k;\n\tS.push(cur); inS[cur] = true;\n\troots.push(cur);\n\t\n\trep(i,G[cur].size()){\n\t\tint to = G[cur][i];\n\t\tif(order[to]==0){\n\t\t\tvisit(to,cur,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t\telse if(to!=prev && inS[to]){\t//?????????????????????\n\t\t\twhile(order[roots.top()] > order[to]) roots.pop();\t//cur???to?????§(to???????????????)????????????roots????????¨??????\n\t\t}\n\t}\n\n\tif(cur==roots.top()&&prev!=-1){\n\t\tbrg.pb(pii(prev,cur));\n\t\tvector<int> bcc;\n\t\twhile(1){\n\t\t\tint node = S.top(); S.pop(); inS[node] = false;\n\t\t\tbcc.pb(node);\n\t\t\tif(node==cur)break;\n\t\t}\n\t\teach_bcc.pb(bcc);\n\t\troots.pop();\n\t}\n}\n\n\nvoid bridge(int V, vector<pii> &brg, vector<vector<int>> &each_bcc){\n\tvector<int> order(V);\n\tvector<bool> inS(V);\n\tstack<int> roots, S;\n\tint k=0;\n\trep(i,V){\n\t\tif(order[i]==0){\n\t\t\tvisit(i,-1,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t}\n}\n\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tvector<pii> brg;\n\tvector<vector<int>> each_bcc;\n\t\n\tbridge(v,brg,each_bcc);\n\t\n\tvector<pii> ans;\n\n\trep(i,brg.size()){\n\t\tif(brg[i].first<brg[i].second)ans.pb(pii(brg[i].first,brg[i].second));\n\t\telse ans.pb(pii(brg[i].second,brg[i].first));\n\t}\n\t\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint dfs(vvi& g, vector<pi>& res, int v, int& count, int from, vi& low, vi& pre)\n{\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (vi::iterator it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = *it;\n\t\tif (pre[to] == -1) {\n\t\t\tlow[v] = min(low[v], dfs(g, res, to, count, v, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\tres.push_back(make_pair(v, to));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\nvector<pi> bridges(vvi& g, int v) {\n\tvector<pi> res;\n\tif (v > 0) {\n\t\tvi low(v, -1);\n\t\tvi pre(v, -1); \n\t\tint count = 0;\n\t\tdfs(g, res, 0, count, -1, low, pre); \n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tvvi g(v);\n\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\n\tvector<pi> ans = bridges(g, v);\n\tsort(ans.begin(), ans.end());\n\n\t\n\tfor (int i = 0; i < e-1; i++) {\n\t\tfor (int j = i + 1; j < e; j++) {\n\t\t\tif (ans[i].first == ans[j].first) {\n\t\t\t\tif (ans[i].second > ans[j].second)\n\t\t\t\t\tswap(ans[i], ans[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, ans.size())\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nstruct twoEdgeComponents {\n    int n;\n    vector<vector<int>> g;        // グラフの隣接リスト\n    vector<int> cmp;              // 頂点iがどの連結成分に属するか\n    vector<vector<int>> each_bcc; // i番目の連結成分の属する頂点\n    vector<pair<int,int>> bridge; // i番目の橋\n    vector<int> order;\n    vector<bool> inS;\n    stack<int> roots, S;\n\n    void dfs(int cur, int prev, int &k) {\n        order[cur] = ++k;\n        S.push(cur); inS[cur] = true;\n        roots.push(cur);\n\n        for(auto to: g[cur]) {\n            if(order[to]==0) dfs(to, cur, k);\n            else if(to!=prev && inS[to]) {\n                while(order[roots.top()] > order[to]) roots.pop();\n            }\n        }\n\n        if(cur == roots.top()) {\n            if(prev!=-1) bridge.push_back({prev, cur});\n            vector<int> bcc;\n            while(1) {\n                int node = S.top(); S.pop(); inS[node] = false;\n                bcc.push_back(node);\n                if(node==cur) break;\n            }\n            each_bcc.push_back(bcc);\n            roots.pop();\n        }\n    }\n\n    twoEdgeComponents() {}\n    twoEdgeComponents(int n) : n(n), g(n) {}\n\n    void add_edge(int p, int q) {\n        g[p].push_back(q);\n        g[q].push_back(p);\n    }\n    // 二重辺連結成分分解を行う\n    void bcc() {\n        order.assign(n, 0);\n        inS.assign(n, false);\n        cmp.assign(n, -1);\n        int k = 0;\n        for(int i=0; i<n; ++i) {\n            if(order[i] == 0) {\n                dfs(i, -1, k);\n            }\n        }\n        for(int i=0; i<(int)each_bcc.size(); ++i) {\n            for(auto j: each_bcc[i]) {\n                cmp[j] = i;\n            }\n        }\n    }\n    // 分解したあとの木を求める\n    vector<vector<int>> getbcc() {\n        vector<vector<int>> h(each_bcc.size(), vector<int>());\n        for(auto i: bridge) {\n            int a = cmp[i.first], b = cmp[i.second];\n            h[a].push_back(b);\n            h[b].push_back(a);\n        }\n        return h;\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m;\n    cin >> n >> m;\n    twoEdgeComponents graph(n);\n    REP(i, m) {\n        ll a, b;\n        cin >> a >> b;\n        graph.add_edge(a, b);\n    }\n    graph.bcc();\n\n    for(auto &e: graph.bridge) if(e.first > e.second) swap(e.first, e.second);\n    sort(ALL(graph.bridge));\n    for(auto e: graph.bridge) cout << e.first << \" \" << e.second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n// res: bridges\n// v: current node\n// from: parent node\n\nint dfs(vvi& g, vector<pi>& res, int v, int& count, int from, vi& low, vi& pre)\n{\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (vi::iterator it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = *it;\n\t\tif (pre[to] == -1) {\n\t\t\t//destination has not been visited\n\t\t\t//visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs(g, res, to, count, v, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t//edge is not contained in a closed path -> bridge\n\t\t\t\tres.push_back(make_pair(v, to));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from == to) {\n\t\t\t\t//ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// g: adjacency list\n// v:number of nodes\n\nvector<pi> bridges(vvi& g, int v) {\n\tvector<pi> res;\n\tif (v > 0) {\n\t\t//assume at least the first vertex exists\n\t\tvi low(v, -1); //lowest reacheable index\n\t\tvi pre(v, -1); //pre-order index\n\t\tint count = 0; //pre-order index counter\n\t\tdfs(g, res, 0, count, -1, low, pre); //start dfs from vetex 0\n\t}\n\treturn res;\n}\n\nvvi G;\nvector<pi> ans;\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tG.resize(v);\n\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\n\tans = bridges(G, v);\n\tsort(ans.begin(), ans.end());\n\t\n\t\n\tfor (int i = 0; i < ans.size()-1; i++) {\n\t\tfor (int j = i + 1; j < ans.size(); j++) {\n\t\t\tif (ans[i].first == ans[j].first) {\n\t\t\t\tif (ans[i].second > ans[j].second)\n\t\t\t\t\tswap(ans[i], ans[j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, ans.size())\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool usedV[MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v,int p){\t//make ord and lowlink\n\tusedV[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!usedV[to]){\n\t\t\tdfs(to,v);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(usedV[to]&&to!=p){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0,-1);\n\t\n\tvector<pii> ans;\n\t\n\trep(i,e){\n\t\tint a = edges[i].first, b = edges[i].second;\n\t\tif(ord[a]>ord[b])swap(a,b);\n\t\tif(ord[a]<lowlink[b])ans.pb(pii(edges[i].first,edges[i].second));\n\t}\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n  \n#include <iostream>\n#include <vector>\n#include <string>\n#include <functional>\nusing namespace std;\nconst int INF = 1e9;\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    vector<pair<int, int>> bridge;\n    vector<int> depth(n, INF), ub(n, INF);\n    function<void(int, int, int)> dfs = [&](int v, int p, int d) {\n        depth[v] = d;\n        ub[v] = d;\n        for(int nv : adj[v]) {\n            if(nv == p) continue;\n            if(depth[nv] != INF) {\n                ub[v] = min(ub[v], depth[nv]);\n                continue;\n            }\n            dfs(nv, v, d + 1);\n            ub[v] = min(ub[v], ub[nv]);\n            if(ub[nv] > depth[v])\n                bridge.emplace_back(min(v, nv), max(v, nv));\n        }\n    };\n    dfs(0, -1, 0);\n    sort(bridge.begin(), bridge.end());\n    for(auto p : bridge) cout << p.first << ' ' << p.second << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class Data> struct Graph;\n\nstruct DefData {\n  struct VData {};\n  struct GData {};\n\n  using Len = int;\n  struct EData {\n    Len len;\n    EData() : len(1) {}\n  };\n  static const Len INF = 0x33433433;\n};\n\ntemplate<class Data=DefData>\nstruct Graph {\n  using VData = typename Data::VData;\n  using EData = typename Data::EData;\n  using GData = typename Data::GData;\n  struct Edge {\n    int to;\n    int rev_idx;\n    bool is_es;\n    EData dat;\n  };\n  using Len = decltype(EData::len);\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  Len INF = Data::INF;\n\n  int n;\n  GData gdat;\n  vector<VData> vdat;\n  vector<Es> es;\n  vector<Es> res;\n  vector<Ls> cost;\n  \n  Graph() {}\n  Graph(int sz) {\n    Init(sz);\n  }\n\n  void Init(int sz) {\n    n = sz;\n    vdat.resize(sz);\n    es.resize(sz);\n    res.resize(sz);\n  }\n\n  void AddEdge(int u, int v, EData d, EData r) {\n    es[u].emplace_back(Edge{v, 0, true, d});\n    res[v].emplace_back(Edge{u, 0, false, r});\n    es[u].back().rev_idx = res[v].size()-1;\n    res[v].back().rev_idx = es[u].size()-1;\n  }\n\n  void AddEdge(int u, int v, EData d=EData()) {\n    AddEdge(u, v, d, d);\n  }\n\n  Edge *GetRevEdge(Edge *e) {\n    int v = e->to;\n    if (e->is_es) return &res[v][e->rev_idx];\n    return &es[v][e->rev_idx];\n  }\n\n  // should be tested\n  template<class Cmp>\n  void EraseMultipleEdge(Cmp cmp, bool really_erase) {\n    auto same = [](const Edge &a, const Edge &b) {\n      return a.to == b.to;\n    };\n\n    vector<Es> new_res(n);\n    for (int v=0; v<n; v++) {\n      auto &ves = es[v];\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n      for (int i=0; i<ves.size(); i++) {\n        auto &e = ves[i];\n        int u = e.to;\n        new_res[u].emplace_back(Edge{v, i, false, GetRevEdge(e)->dat});\n      }\n    }\n    res.swap(new_res);\n  }\n\n  void CreateAdjMat() {\n    cost.clear();\n    cost.resize(n, Ls(n, INF));\n\n    auto cmp = [](const Edge &a, const Edge &b) {\n      if (a.to != b.to) return a.to < b.to;\n      return a.dat.len < b.dat.len;\n    };\n    EraseMultipleEdge(cmp, false);\n\n    for (int i=0; i<n; i++) {\n      int prev = -1;\n      for (auto e : es[i]) {\n        int v = e.to;\n        if (prev > v) break;\n        cost[i][v] = min(cost[i][v], e.dat.len);\n        prev = v;\n      }\n    }\n  }\n\n  void DijkstraV(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    if (cost.empty()) CreateAdjMat();\n\n    vector<bool> used(n, false);\n    for (int i=0; i<n; i++) {\n      int v = -1;\n      for (int u=0; u<n; u++) {\n        if (used[u]) continue;\n        if (v == -1 || d[u] < d[v]) {\n          v = u;\n        }\n      }\n      if (v == -1) return;\n\n      used[v] = true;\n      for (int u=0; u<n; u++) {\n        d[u] = mind(d[u], d[v] + cost[v][u]);\n      }\n    }\n\n    // must not reach here\n    assert(0);\n  }\n\n  void DijkstraE(vector<int> &starts, Ls &d) {\n    using Pair = pair<Len, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.dat.len) {\n          d[u] = d[v] + e.dat.len;\n          q.push(Pair(d[u], u));\n        }\n      }\n    }\n  }\n\n  // return true if the graph has a negative cycle\n  bool SPFA(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n\n    queue<int> q;\n    vector<bool> inq(n);\n    vector<int> cnt(n);\n    for (int s : starts) {\n      inq[s] = true;\n      q.push(s);\n      d[s] = 0;\n    }\n\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      inq[v] = false;\n      cnt[v]++;\n      if (cnt[v] > n) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.to) {\n          d[u] = d[v] + e.to;\n          if (inq[u]) continue;\n          inq[u] = true;\n          q.push(u);\n        }\n      }\n    }\n\n    // do DFS if you need the concrete contents of such cycles\n    for (int i=0; i<n; i++) {\n      if (cnt[i] >= n) return true;\n    }\n\n    return false;\n  }\n\n  void DijkstraV(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraV(ss, d);\n  }\n\n  void DijkstraE(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraE(ss, d);\n  }\n\n  void SPFA(int s, Ls &d) {\n    vector<int> ss(1, s);\n    SPFA(ss, d);\n  }\n\n  // Create \"Shortest Path Graph\", which should be DAG\n  Graph<Data> RestoreShortestPaths(Ls &d) {\n    Graph<Data> ret(n);\n\n    for (int i=0; i<n; i++) {\n      for (auto e : es[i]) {\n        int v = e.to;\n        if (d[v] == d[i] + e.dat.len) {\n          ret.AddEdge(i, e.to, e.dat, GetRevEdge(&e)->dat);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void WarshallFloyd(vector<Ls> &ds) {\n    if (cost.empty()) CreateAdjMat();\n\n    ds.clear();\n    ds.resize(cost);\n    for (int i=0; i<n; i++) {\n      ds[i][i] = min(ds[i][i], 0);\n    }\n\n    for (int k=0; k<n; k++) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n          if (ds[i][j] > ds[i][k] + ds[k][j]) {\n            ds[i][j] = ds[i][k] + ds[k][j];\n          }\n        }\n      }\n    }\n  }\n\n  // Karp's Algorithm O(NM)\n  // should be tested\n  // should be used for SCC\n  double MinimumMeanCycle() {\n    vector<Ls> dp(n+1, Ls(n, INF));\n\n    dp[0][0] = 0;\n    for (int i=1; i<=n; i++) {\n      for (int v=0; v<n; v++) {\n        for (auto e : es[v]) {\n          int u = e.to;\n          dp[i][u] = min(dp[i][u], dp[i-1][v] + e.dat.len);\n        }\n      }\n    }\n\n    double ret = 1.0/0.0;\n    for (int v=0; v<n; v++) {\n      double alpha = (-1.0)/0.0;\n      for (int i=1; i<n; i++) {\n        if (dp[n][v] == INF) continue;\n        if (dp[i][v] == INF) continue;\n        alpha = max(alpha, (dp[n][v]-dp[i][v])/double(n-i));\n      }\n      ret = min(ret, alpha);\n    }\n    return ret;\n  }\n};\n\ntemplate<class Data=DefData>\nstruct DFSForest {\n  using G = Graph<Data>;\n  using Edge = typename G::Edge;\n  using Brid = pair<int, Edge*>;\n\n  int grp;\n  vector<int> ord;\n  vector<int> low;\n  vector<int> belong;\n  vector<int> artic;\n  vector<Brid> bridge;\n\n  DFSForest(G &g, bool is_directed) {\n    int k = 0;\n    int idx = 0;\n    int n = g.n;\n    vector<int> st(n);\n\n    grp = 0;\n    ord.resize(n, -1);\n    low.resize(n);\n    belong.resize(n, -1);\n\n    function<void(int,int,Edge*)> dfs;\n    // to deal with multiple edges, it uses a pointer\n    auto update = [&](int v, Edge *e, bool &is_artic, int &cnt) {\n      int u = e->to;\n      if (ord[u] != -1) {\n        if (belong[u] == -1) low[v] = min(low[v], ord[u]);\n      } else {\n        cnt++;\n        dfs(u, v, e);\n        low[v] = min(low[v], low[u]);\n        if (ord[v] <= low[u]) is_artic = true;\n        if (ord[v] < low[u]) bridge.emplace_back(Brid(v, e));\n      }\n    };\n\n    dfs = [&](int v, int p, Edge *par) {\n      bool is_artic = false;\n      int cnt = 0;\n\n      st[idx++] = v;\n      low[v] = ord[v] = k++;\n\n      for (auto &e : g.es[v]) {\n        if (g.GetRevEdge(&e) == par) continue;\n        update(v, &e, is_artic, cnt);\n      }\n\n      if (!is_directed) {\n        for (auto &e : g.res[v]) {\n          if (g.GetRevEdge(&e) == par) continue;\n          update(v, &e, is_artic, cnt);\n        }\n      }\n\n      if (p == -1) is_artic = (cnt > 1);\n      if (is_artic) artic.emplace_back(v);\n\n      if (low[v] != ord[v]) return;\n      while (1) {\n        int u = st[--idx];\n        belong[u] = grp;\n        if (u == v) break;\n      }\n      grp++;\n    };\n\n    for (int i=0; i<n; i++) {\n      if (ord[i] == -1) dfs(i, -1, NULL);\n    }\n  }\n};\n\n\ntemplate<class Data=DefData>\nstruct SCC : Graph<SCC<Data> > {\n  using VD = typename Data::VData;\n  using ED = typename Data::EData;\n  using GD = typename Data::GData;\n  using G = Graph<Data>;\n\n  struct VData {\n    G g; // the graph consisting of contracted nodes in one component\n    vector<int> cont2orig; // the correspondence of the node index: v on SCCVData::g -> cont2orig[v] on the original graph(G)\n    VData(int n) : g(n) {}\n  };\n\n  struct EData : ED {\n    int s;\n    int t;\n    EData(int a, int b, const ED &dat) : ED(dat), s(a), t(b) {}\n  };\n\n  struct GData {\n    vector<int> orig2cont; // the correspondence of the node index: v on G -> orig2cont[v] on G's SCC::vdat[belong[v]].g\n  };\n\n  DFSForest<Data> df;\n  SCC(G &g) : df(g, true), Graph<SCC<Data> >(df.grp) {\n    int n = g.n;\n\n    auto &gdat = this->gdat;\n    auto &vdat = this->vdat;\n\n    gdat.orig2cont.resize(n);\n    for (int v=0; v<n; v++) {\n      auto &vd = vdat[df.belong[v]];\n      gdat.orig2cont[v] = vd.cont2orig.size();\n      vd.cont2orig.emplace_back(v);\n    }\n\n    for (int i=0; i<df.grp; i++) {\n      auto &vd = vdat[i];\n      vd.g.Init(vd.cont2orig.size());\n    }\n    \n    for (int v=0; v<n; v++) {\n      for (auto &e : g.es[v]) {\n        int u = e.to;\n        ED &rd = g.GetRevEdge(&e)->dat;\n        int bv = df.belong[v];\n        int bu = df.belong[u];\n\n        if (bv == bu) {\n          auto &vd = vdat[bv];\n          auto &dic = gdat.orig2cont;\n          vd.g.AddEdge(dic[v], dic[u], e.dat, rd);\n        } else {\n          AddEdge(bv, bu, Edata(v, u, e.data), EData(u, v, rd));\n        }\n      }\n    }\n  }\n};\n\nint n;\nint m;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Graph<> g(n);\n\n  while (m--) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    g.AddEdge(s, t);\n  }\n\n  DFSForest<> df(g, false);\n  //SCC<> scc(g);\n  auto &bridge = /*scc.*/df.bridge;\n  using A = DFSForest<>::Brid;\n  sort(bridge.begin(), bridge.end(), [&](const A &a, const A &b) {\n    int av = a.first;\n    int au = a.second->to;\n    if (av > au) swap(av, au);\n    int bv = b.first;\n    int bu = b.second->to;\n    if (bv > bu) swap(bv, bu);\n    if (av != bv) return av < bv;\n    return au < bu;\n  });\n\n  for (auto &a : /*scc.*/df.bridge) {\n    int av = a.first;\n    int au = a.second->to;\n    if (av > au) swap(av, au);\n    printf(\"%d %d\\n\", av, au);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nclass Finding_Bridges {\nprivate:\n\tstruct node {\n\t\tint id; bool done; vi to; int from; int pre; int low;\n\t};\n\tvector<node> nodes;\n\tint n, m;\n\tint ord;\n\tvector<P> result;\n\tvoid lowlink_dfs(int a) {\n\t\tnodes[a].done = true;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tlowlink_dfs(b);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre < nodes[b].low) {\n\t\t\t\t\tif (a < b) result.push_back({ a,b });\n\t\t\t\t\telse result.push_back({ b,a });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\npublic:\n\tFinding_Bridges(const vvi &lst) {\n\t\tn = lst.size();\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { i, false,{}, -1, -1, -1 };\n\t\tLoop(i, n) {\n\t\t\tForeach(j, lst[i]) {\n\t\t\t\tnodes[i].to.push_back(j);\n\t\t\t}\n\t\t}\n\t\tord = 0;\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) lowlink_dfs(i);\n\t\t}\n\t\tsort(result.begin(), result.end());\n\t}\n\tvector<P> get_bridges() {\n\t\treturn result;\n\t}\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvvi lst(n);\n\tLoop(i, m) {\n\t\tint s, t; cin >> s >> t;\n\t\tlst[s].push_back(t);\n\t\tlst[t].push_back(s);\n\t}\n\tFinding_Bridges fb(lst);\n\tvector<P> ans = fb.get_bridges();\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].fst << \" \" << ans[i].snd << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INFLL=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int max_v=100000;\nvector<int> graph[max_v];\nbool used_v[max_v];\nmap<int,bool> used_e[max_v];\nint ord[max_v],lowlink[max_v];\nvector<pii> bridges;\n\nvoid dfs(int v,int &k){\n    used_v[v]=true;\n    ord[v]=lowlink[v]=k++;\n    for(int u:graph[v]){\n        if(!used_v[u]){\n            used_e[v][u]=true;\n            dfs(u,k);\n            lowlink[v]=min(lowlink[v],lowlink[u]);\n            if(ord[v]<lowlink[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n        }else if(!used_e[u][v]) lowlink[v]=min(lowlink[v],ord[u]);\n    }\n}\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    \n    vector<pii> edges(e);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n        if(s>t) swap(s,t);\n        edges[i]=make_pair(s,t);\n    }\n    \n    int k=0;\n    dfs(0,k);\n    \n    sort(bridges.begin(),bridges.end());\n    \n    for(auto &e:bridges) cout << e.first << \" \" << e.second << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M, A[1 << 17], B[1 << 17], pre[1 << 17], low[1 << 17], cnts;\nvector<int> G[1 << 17]; vector<pair<int, int>> E;\n\nvoid dfs(int pos, int prevs) {\n\tcnts++; pre[pos] = cnts; low[pos] = cnts;\n\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tif (pre[G[pos][i]] == 0) {\n\t\t\tdfs(G[pos][i], pos);\n\t\t\tif (low[G[pos][i]] == pre[G[pos][i]]) {\n\t\t\t\tint u1 = pos, u2 = G[pos][i]; if (u1 > u2) swap(u1, u2);\n\t\t\t\tE.push_back(make_pair(u1, u2));\n\t\t\t}\n\t\t\tlow[pos] = min(low[pos], low[G[pos][i]]);\n\t\t}\n\t\telse {\n\t\t\tif (G[pos][i] != prevs) low[pos] = min(low[pos], low[G[pos][i]]);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= M; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tG[A[i]].push_back(B[i]);\n\t\tG[B[i]].push_back(A[i]);\n\t}\n\tdfs(1, 0);\n\tsort(E.begin(), E.end());\n\tfor (int i = 0; i < E.size(); i++) printf(\"%d %d\\n\", E[i].first, E[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<int>E[100000];\nint s[100000],t[100000];\nint ord[100000],low[100000],k;\nbool used[100000];\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tlow[v]=ord[v]=k++;\n\tfor(auto u:E[v]){\n\t\tif(!used[u]){\n\t\t\tdfs(u,v);\n\t\t\tlow[v]=min(low[v],low[u]);\n\t\t}\n\t\telse if(p!=u){\n\t\t\tlow[v]=min(low[v],ord[u]);\n\t\t}\n\t}\n}\nint main(){\n\tint v,e;scanf(\"%d%d\",&v,&e);\n\trep(i,e){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);\n\t\tE[s[i]].push_back(t[i]);\n\t\tE[t[i]].push_back(s[i]);\n\t}\n\tdfs(0,-1);\n\tvector<P>V;\n\trep(i,e){\n\t\tif(ord[s[i]]>ord[t[i]])swap(s[i],t[i]);\n\t\tif(low[s[i]]<low[t[i]]){\n\t\t\tV.push_back(P(min(s[i],t[i]),max(s[i],t[i])));\n\t\t}\n\t}\n\tsort(V.begin(),V.end());\n\tfor(auto p:V){\n\t\tcout<<p.first<<' '<<p.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 100000\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[MAX_V]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  //bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  auto begin() { return g.begin(); }\n  auto end() { return g.end(); }\n};\n\nclass TwoEdgeConnectedComponents {\npublic:\n  Graph g;\n  Edges bridges;\n  vector<int> cmp;\n\n  TwoEdgeConnectedComponents(const Graph &g) : g(g) {\n    int n = g.size();\n    cmp.resize(n);\n    stack<int> s, roots;\n    vector<int> ord(n, -1);\n    int id = 0, k = 0;\n    vector<int> onS(n), cmp(n);\n    function<void(int, int)> dfs = [&](int v, int u) {\n      ord[v] = id++;\n\n      s.emplace(v);\n      onS[v] = true;\n      roots.emplace(v);\n      for (auto &e : g[v]) {\n        int w = e.dst;\n        if (ord[w] == -1) {\n          dfs(w, v);\n        } else if (u != w && onS[w]) {\n          while (ord[roots.top()] > ord[w]) roots.pop();\n        }\n      }\n      if (v == roots.top()) {\n        bridges.emplace_back(u, v, 0);\n        while (true) {\n          int w = s.top();\n          s.pop();\n          onS[w] = false;\n          cmp[w] = k;\n          if (v == w) break;\n        }\n        roots.pop();\n        k++;\n      }\n    };\n\n    rep(i, n) {\n      if (ord[i] != -1) continue;\n      dfs(i, n);\n      bridges.pop_back();\n    }\n  }\n};\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  rep(i, m) {\n    int s, t;\n    cin >> s >> t;\n    g.addEdge(s, t);\n  }\n  TwoEdgeConnectedComponents tecc(g);\n  vector<pair<int, int>> es;\n  for (auto &e : tecc.bridges) es.emplace_back(e.src, e.dst);\n  for (auto &e : es) {\n    if (e.first > e.second) swap(e.first, e.second);\n  }\n  sort(all(es));\n  for (auto &e : es) cout << e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,t,A[N],used[N],depth[N];\nvector<int> G[N];\nvector<P> ans;\n\nvoid dfs(int x,int d,int prev){\n  depth[x]=d;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(nx==prev)continue;\n    if(!used[nx]){\n      used[nx]=true;\n      dfs(nx,d+1,x);\n      if(!A[nx])\n\tans.push_back(P(min(x,nx),max(x,nx)));\n      A[x]+=A[nx];\n    }\n    else if(d>depth[nx])A[nx]--,A[x]++;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  used[0]=1;\n  dfs(0,0,0);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i].first<<' '<<ans[i].second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nvector<vector<int> > g;\nvector<int> ord, low;\nvector<bool> is_articulation;\nvector<P> bridges;\n\nvoid dfs(int u, int par, int &k){\n    ord[u] = k;\n    k++;\n    low[u] = ord[u];\n    int cnt = 0;\n    for(auto v : g[u]){\n        if(ord[v] == -1){\n            cnt++;\n            dfs(v, u, k);\n            low[u] = min(low[u], low[v]);\n            if(par!=-1 && ord[u] <= low[v]){\n                is_articulation[u] = true;\n            }\n            if(ord[u] < low[v]){\n                bridges.push_back(make_pair(min(u,v), max(u,v)));\n            }\n        }\n        else if(v != par)low[u] = min(low[u], ord[v]);\n    }\n    if(par == -1){\n        is_articulation[u] = cnt >= 2;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    g.resize(n);\n    ord.resize(n, -1);\n    low.resize(n);\n    is_articulation.resize(n, false);\n    for(int i=0;i<m;i++){\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int k = 0;\n    dfs(0, -1, k);\n    sort(bridges.begin(), bridges.end());\n    for(auto e : bridges){\n        cout << e.first << \" \" << e.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<tuple>\n#include<iostream>\nusing namespace std;\n\n/*\nenumerate non-bridge\n*/\n\nusing pint=pair<int,int>;\n\nstruct EnumerateBridges{\n\tvector<vector<pint>>G;\n\tint N,M;\n\n\tvector<int>vis,ord,low;\n\n\tEnumerateBridges(int n):N(n),M(0),G(n),vis(n),ord(n),low(n){}\n\n\tvoid addEdge(int a,int b){\n\t\tG[a].emplace_back(b,M);\n\t\tG[b].emplace_back(a,M);\n\t\tM++;\n\t}\n\n\tvoid dfs(int v,int p,int &k,vector<int>&bridge){\n\t\tvis[v]=true;\n\t\tord[v]=k;\n\t\tlow[v]=ord[v];\n\n\t\tk++;\n\t\t\n\t\tfor(auto &e:G[v]){\n\t\t\tint u,id;\n\t\t\ttie(u,id)=e;\n\n\t\t\tif(u==p)continue;\n\n\t\t\tif(!vis[u]){\n\t\t\t\tdfs(u,v,k,bridge);\n\t\t\t\tlow[v]=min(low[v],low[u]);\n\t\t\t\tif(ord[v]<low[u])bridge.push_back(id);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlow[v]=min(low[v],ord[u]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int>enumerate(){\n\t\tvector<int>bridge;\n\t\tint k=0;\n\t\tdfs(0,-1,k,bridge);\n\t\treturn bridge;\n\t}\n};\n\n//O(M)\nvector<int>enumerate(int N,vector<int>&A,vector<int>&B,vector<int>&used){\n\tint M=A.size();\n\tEnumerateBridges eb(N);\n\tfor(int i=0;i<M;i++){\n\t\tif(used[i])continue;\n\t\teb.addEdge(A[i],B[i]);\n\t}\n\n\tvector<int>nb(M,1);\n\tauto bs=eb.enumerate();\n\tfor(auto k:bs)nb[k]=0;\n\n\tvector<int>ret;\n\tfor(int i=0;i<M;i++)if(nb[i])ret.push_back(i);\n\treturn ret;\n}\n\n/*\nA[i]--B[i] i=1,2,...,M\nC[i]--D[i] i=1,2,...,M\n*/\nint solve(int N,vector<int>&A,vector<int>&B,vector<int>&C,vector<int>&D){\n\tint M=A.size();\n\tfor(int i=0;i<M;i++){\n\t\tA[i]--;B[i]--;C[i]--;D[i]--;\n\t}\n\tvector<int>used(M);\n\n\twhile(true){\n\n\t\tauto src=enumerate(N,A,B,used);\n\t\tauto snk=enumerate(N,C,D,used);\n\n\t\t//exchange graph\n\t\tvector<vector<int>>EG(M);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(!used[i])continue;\n\t\t\tused[i]=false;\n\n\t\t\tauto listY1=enumerate(N,A,B,used);\n\t\t\tauto listY2=enumerate(N,C,D,used);\n\t\t\tfor(auto j:listY1)EG[i].push_back(j);\n\t\t\tfor(auto j:listY2)EG[j].push_back(i);\n\n\t\t\tused[i]=true;\n\t\t}\n\t}\n}\n\nint main(){\n\tint N,M;cin>>N>>M;\n\tvector<int>A(M),B(M);\n\tEnumerateBridges eb(N);\n\tfor(int i=0;i<M;i++){\n\t\tcin>>A[i]>>B[i];\n\t\teb.addEdge(A[i],B[i]);\n\t\tif(A[i]>B[i])swap(A[i],B[i]);\n\t}\n\n\tauto bs=eb.enumerate();\n\tvector<pint>ans;\n\tfor(auto k:bs)ans.emplace_back(A[k],B[k]);\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint v, e;\nstruct Edge {\n  Edge() : isBridge(true) {}\n  Edge(int src_, int dest_) : src(src_), dest(dest_), isBridge(true) {}\n  int src;\n  int dest;\n  bool isBridge;\n};\nstd::vector<Edge> graph[112345];\n\nvoid load() {\n  scanf(\"%d %d\", &v, &e);\n  for(int i = 0; i < e; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    graph[a].push_back(Edge(a, b));\n    graph[b].push_back(Edge(b, a));\n  }\n}\n\nint dfi[112345];\nint parent[112345];\nint dfiid = 1;\nstd::vector<int> backEdges[112345];\nstd::vector<int> ascNodes;\n\nvoid dfs(int i, int prev) {\n  dfi[i] = dfiid;\n  dfiid += 1;\n  ascNodes.push_back(i);\n  for(Edge edge : graph[i]) {\n    int src = edge.src;\n    int dest = edge.dest;\n    if( dest == prev ) continue;\n    if( dfi[dest] == 0 ) {\n      dfs(dest, src);\n      parent[dest] = src;\n    }\n    else {\n      // backEdge\n      backEdges[dest].push_back(src);\n      // printf(\"backEdge %d %d\\n\", src, dest);\n    }\n  }\n}\n\nbool visited[112345];\nbool traversed[112345];\nvoid traverse(int id) {\n  if( visited[id] ) return;\n  visited[id] = true;\n  traversed[id] = true;\n  traverse(parent[id]);\n}\nvoid calcChains() {\n  for(int id : ascNodes) {\n    visited[id] = true;\n    for(int parent : backEdges[id]) {\n      traverse(parent);\n    }\n  }\n}\n\nint main() {\n  load();\n  parent[0] = -1;\n  dfs(0, -1);\n  // for(int i = 0; i < v; ++i) {\n  //   printf(\"(v, parent, dfi) = (%d, %d, %d)\\n\", i, parent[i], dfi[i]);\n  // }\n  calcChains();\n  std::vector<std::pair<int, int>> res;\n  for(int i = 0 + 1; i < v; ++i) {\n    if( not traversed[i] ) {\n      res.push_back(std::make_pair(std::min(i, parent[i]), std::max(i, parent[i])));\n    }\n  }\n  std::sort(res.begin(), res.end());\n  for(std::pair<int, int> st : res) {\n    printf(\"%d %d\\n\", st.first, st.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n\nconst int MAX_V = 1e5;\nvector<int> G[MAX_V];\n\nset<int> used_v;\nset<PII> used_e;\nint ord[MAX_V], lowlink[MAX_V];\nint k = 0;\n\nvoid calc_lowlink(int v)\n{\n    used_v.insert(v);\n    ord[v] = lowlink[v] = k++;\n\n    for (auto u : G[v]) {\n        if (!used_v.count(u)) {\n            used_e.insert(PII(v, u));\n            calc_lowlink(u);\n            lowlink[v] = min(lowlink[v], lowlink[u]);\n        } else if (!used_e.count(PII(u, v))) {\n            // backward edge\n            lowlink[v] = min(lowlink[v], ord[u]);\n        }\n    }\n}\n\nvector<PII> calc_bridge(int N)\n{\n    vector<PII> res;\n    for (int v=0; v<N; v++) {\n        for (auto u : G[v]) {\n            if (ord[v] < lowlink[u]) {\n                res.emplace_back(min(v, u), max(v, u));\n            }\n        }\n    }\n    return res;\n}\n\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    rep(i, M) {\n        int U, V;\n        cin >> U >> V;\n        // U--, V--;\n        G[U].push_back(V);\n        G[V].push_back(U);\n    }\n\n    calc_lowlink(0);\n    vector<PII> bridges = calc_bridge(N);\n    sort(bridges.begin(), bridges.end());\n\n    for (auto p : bridges) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    /*\n    rep(i, N) {\n        cout << ord[i] << \" \" <<  lowlink[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\nconst int MAX = 100005;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nint N, M;\nint cnt = 0;\nvector<int> ord(MAX, NIL), lowLink(MAX);\nvector<vector<int> > G(MAX, vector<int>());\n/* function */\nvoid dfs(int from, int parent) {\n    ord[from] = lowLink[from] = cnt++;\n    for (int to : G[from]) {\n        // DFS木の親を訪れようとしたら何もしない\n        if (to == parent) continue;\n        if (ord[to] == NIL) {\n            // nodeが使われていないならdfs\n            dfs(to, from);\n            // dfsが戻ってきたらlowlinkの更新\n            lowLink[from] = min(lowLink[from], lowLink[to]);\n        }\n        // 使われている頂点まだ使ってない辺でを訪れようとした場合\n        else {\n            // これが後退辺となるのでusedEは0のままにしておく\n            // lowlinkの更新\n            lowLink[from] = min(lowLink[from], ord[to]);\n        }\n    }\n    return ;\n}\nvoid bridge(vector<pii> edges) {\n    int from, to;\n    for (pii edge : edges) {\n        from = edge.first, to = edge.second;\n        if (ord[from] < lowLink[to] || ord[to] < lowLink[from])\n            cout << from << ' ' << to << '\\n';\n    }\n}\n/* main */\nint main(){\n    cin >> N >> M;\n    int u, v;\n    vector<pii> edges;\n    for (int i = 0; i < M; i++) {\n        cin >> u >> v;\n        if (u > v) swap(u, v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n        edges.push_back(pii(u, v));\n    }\n    dfs(0, -1);\n    sort(edges.begin(), edges.end());\n    bridge(edges);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nvector<int> biconnected_component(const graph& G) {\n\tint n = G.size(), idx = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), stk, rts(n), cmp(n);\n\tvector<bool> onS(n);\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk.push_back(v);\n\t\tonS[v] = true;\n\t\trts[t++] = v;\n\t\tfor (int w : G[v]) {\n\t\t\tif (ord[w] == -1) dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[rts[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif (v == rts[t - 1]) {\n\t\t\twhile (true) {\n\t\t\t\tint w = stk.back(); stk.pop_back();\n\t\t\t\tonS[w] = false; cmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; ++u) {\n\t\tif (ord[u] == -1) dfs(u, -1);\n\t}\n\treturn cmp;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tgraph G(n);\n\tvector<int> s(m), t(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> s[i] >> t[i];\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tauto bc = biconnected_component(G);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (bc[s[i]] != bc[t[i]]) {\n\t\t\tcout << s[i] << ' ' << t[i] << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> g[100010];\n\nint zeit, dis[MAXN], fin[MAXN], low[MAXN], par[MAXN], dep[MAXN];\nint kodat[MAXN], koptr[MAXN + 1];\nvoid dfsInfo(int u,int oy,int d){\n\tdis[u] = low[u] = zeit++; par[u] = oy; dep[u] = d;\n\tint v;\n\trep(i,sz(g[u])) if((v = g[u][i]) != oy){\n\t\tif(!~dis[v]){\n\t\t\tdfsInfo(v, u, d + 1);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], dis[v]);\n\t\t}\n\t}\n\tfin[u] = zeit++;\n}\n\nvoid dfsInfos(){\n\tmemset(dis, ~0, n*4); zeit = 0;\n\trep(u,n) if(!~dis[u]) dfsInfo(u, -1, 0);\n\trep(u,n){\n\t\tint &j = koptr[u + 1] = koptr[u];\n\t\trep(i,sz(g[u])) if(u == par[g[u][i]]) kodat[j++] = g[u][i];\n\t}\n}\n\nbool produce(int u,int v){\n\treturn (dis[u] <= dis[v] && fin[u] >= fin[v]);\n}\n\nint related(int u,int v){\n\tint s = koptr[u], e = koptr[u+1], h;\n\twhile(s+1 < e){\n\t\th = (s + e) >> 1;\n\t\t(dis[kodat[h]] <= dis[v]) ? s = h : e = h;\n\t}\n\treturn kodat[s];\n}\n\nbool isBridge(int u,int v){\n\tif(dis[u] > dis[v]) swap(u, v);\n\treturn (u == par[v] && dis[v] <= low[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\n\tint m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\trep(i,n)sort(g[i].begin(),g[i].end());\n\tdfsInfos();\n\t/*rep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && isBridge(i,g[i][j]))cout<<i<<\" \"<<g[i][j]<<endl;\n\t}*/\n\trep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && dis[i] < low[g[i][j]])cout<<i<<\" \"<<g[i][j]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > ord[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n\n  vector<int> visit(V, -1);\n  \n  int num_cc = edge_group.size();\n  REP(s, V) if (visit[s] == -1){\n    visit[s] = num_cc;\n    queue<int> que;\n    while (!que.empty()){\n      int v = que.front(); que.pop();\n      for (int w : G[v]){\n        if (visit[w] == -1){\n          visit[w] = num_cc;\n          que.push(w);\n        }\n      }\n    }\n    num_cc++;\n  }\n  edge_group.resize(num_cc);\n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (visit[e.fst] == visit[e.snd]) edge_group[visit[e.fst]].push_back(i);\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    if (u > v) swap(u, v);\n    es.emplace_back(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()) if (bd.edge_group[i].size() == 1) {\n    bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tbool operator<(const struct Edge &arg) const{\n\t\tif(s != arg.s){\n\t\t\treturn s < arg.s;\n\t\t}else{\n\t\t\treturn t < arg.t;\n\t\t}\n\t}\n\tint s,t;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_edge_id){\n\t\tto = arg_to;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n};\n\nint V,E,number;\nint order[100000],lowlink[100000];\nbool visited[100000];\nEdge edge[100000];\nvector<Info> G[100000];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tnext_node = G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&edge[i].s,&edge[i].t);\n\t\tif(edge[i].s > edge[i].t){\n\t\t\tswap(edge[i].s,edge[i].t);\n\t\t}\n\t\tG[edge[i].s].push_back(Info(edge[i].t,i));\n\t\tG[edge[i].t].push_back(Info(edge[i].s,i));\n\t}\n\n\tsort(edge,edge+E);\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\n\trecursive(0);\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tfrom = edge[i].s;\n\t\tto = edge[i].t;\n\n\t\tif(order[edge[i].s] > order[edge[i].t]){\n\t\t\tswap(from,to);\n\t\t}\n\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"%d %d\\n\",edge[i].s,edge[i].t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<set>\n\nusing namespace std;\n\nstruct Edge {\n\tint from, to; //if you want cost, etc., you should care about the \"emplace_back\"(line36,line118).\n\tEdge(int f, int t) {\n\t\tfrom = f;\n\t\tto = t;\n\t}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nvector<int>ArticulationPoint(const Graph& g) {\n\tint n = g.size(), idx = 0;\n\tvector<int>low(n), ord(n), art;\n\tfunction<void(int)>dfs = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[w] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v]))\n\t\t\t\t\tart.push_back(v);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\treturn art;\n}\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nvector<int> kosaraju(const Graph& g) {\n\tint n = g.size(), sz = 0;\n\tGraph rg(n);\n\tvector<int>stk, cmp(n, -1), added(n), visited(n), ord(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es)rg[e.to].emplace_back(e.to, e.from);\n\t\tsz += es.size();\n\t}\n\tstk.resize(n + sz);\n\tsz = 0;\n\tfor (int i = 0; i<n; ++i) {\n\t\tif (visited[i])continue;\n\t\tint s = 0;\n\t\tstk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : g[v]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tif (!visited[to]) {\n\t\t\t\t\tstk[s++] = to;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pushed)continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) {\n\t\t\t\tadded[t] = true;\n\t\t\t\tord[n - ++sz] = t;\n\t\t\t}\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1)continue;\n\t\tint s = 0;\n\t\tstk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s];\n\t\t\tcmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint t = e.to;\n\t\t\t\tif (cmp[t] == -1)stk[s++] = t;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tGraph g(V);\n\tfor (int i = 0; i<E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].emplace_back(s, t);\n\t\tg[t].emplace_back(t, s);\n\t}\n\tEdges es = bridge(g).second;\n\tvector<pair<int, int>>v;\n\tfor (auto x : es) {\n\t\tif (x.from > x.to)continue;\n\t\tv.push_back(pair<int, int>(x.from, x.to));\n\t}\n\tsort(v.begin(), v.end());\n\tfor (auto x : v) {\n\t\tcout << x.first << \" \"  << x.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int MAX=1000*1000+1000,INF=1000*1000*1000;\nvector<int> adj[MAX];\nvector<pii> ans;\nint dp[MAX],from[MAX],to[MAX],depth[MAX];\nbool vis[MAX];\nvoid dfs(int v,int f,int p){\n\tvis[v]=1;\n\tdepth[v]=f;\n\tfor(int e:adj[v]){\n\t\tint u=from[e]^to[e]^v;\n\t\tif(u==p)\n\t\t\tcontinue;\n\t\tif(vis[u]==0){\n\t\t\tdfs(u,f+1,v);\n\t\t\tdp[v]=min(dp[v],dp[u]);\n\t\t}\n\t\telse\n\t\t\tdp[v]=min(dp[v],depth[u]);\n\t}\n\tif(p!=v and dp[v]>depth[v]){\n\t\tif(p>v)\n\t\t\tswap(p,v);\n\t\tans.push_back({p,v});\n\t}\n\treturn;\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>from[i]>>to[i];\n\t\tif(from[i]>to[i])\n\t\t\tswap(from[i],to[i]);\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tfill(dp,dp+n,INF);\n\tdfs(0,0,0);\n\tsort(ans.begin(),ans.end());\n\tfor(pii k:ans)\n\t\tcout<<k.first<<\" \"<<k.second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\n#define B\n\nconst int vmax=100010;\n\nvector<int> graph[vmax],ord,low,scc,par;\nstack<int>s;\n\nvoid dfs(int v,int p,int &k){\n\tord[v]=k++;\n\tlow[v]=ord[v];\n\tpar[v]=p;\n\t#ifdef S\n\t\ts.push(v);\n\t#endif\n\tfor(auto &i:graph[v]){\n\t\tif(ord[i]==-1){\n\t\t\tdfs(i,v,k);\n\t\t\tlow[v]=min(low[v],low[i]);\n\n\t\t#ifdef S\n\t\t\t}else if(scc[i]==-1){\n\t\t#else\n\t\t\t}else if(i!=p){\n\t\t#endif\n\t\t\tlow[v]=min(low[v],ord[i]);\n\t\t}\n\t}\n\t#ifdef S\n\t\tif(ord[v]==low[v]){\n\t\t\twhile(1){\n\t\t\t\tint u=s.top();s.pop();\n\t\t\t\tscc[u]=v;\n\t\t\t\tif(u==v) break;\n\t\t\t}\n\t\t}\n\t#endif\n}\n\nvoid lowlink(int n){\n\tint k=0;\n\tord.assign(n,-1),low.resize(n);\n\tscc.assign(n,-1),par.resize(n);\n\trep(i,n) if(ord[i]==-1) dfs(i,-1,k);\n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\trep(loop,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\t#ifdef S\n\t\t#else\n\t\t\tgraph[b].push_back(a); // B,A\n\t\t#endif\n\t}\n\tlowlink(v);\n\n/*\trep(i,v){\n\t\tcout << \"ord[\" << i << \"]=\" << ord[i]  << endl;\n\t\tcout << \"low[\" << i << \"]=\" << low[i]  << endl;\n\t}\n*/\n\n// Bridge\n#ifdef B\n\tvector<pair<int,int>> bridge;\n\trep(i,v){\n\t\tint j=par[i];\n\t\tif(j==-1)\n\t\t\tcontinue;\n\t\tif(ord[i] < low[j] || ord[j] < low[i] ){\n\t\t\tauto in=make_pair(i,j);\n\t\t\tif(in.second<=in.first) swap(in.first,in.second);\n\t\t\tbridge.push_back(in);\n\t\t}\n\t}\n\tsort(bridge.begin(),bridge.end());\n\tfor(auto &i:bridge)\n\t\tcout << i.first << \" \" << i.second << endl;\n#endif\n\n// Articulation Points\n#ifdef A\n\tvector<int> articulation_point;\n\trep(i,v){\n\t\tif(i){\n\t\t\tbool ok=false;\n\t\t\tfor(auto &j:graph[i]){\n\t\t\t\tif(i==par[j]&&ord[i]<=low[j])\n\t\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(ok) articulation_point.push_back(i);\n\t\t}else{\n\t\t\tint d=0;\n\t\t\trep(j,v) if(par[j]==0) d++;\n\t\t\tif(d>=2) articulation_point.push_back(i);\n\t\t}\n\t}\n\tsort(articulation_point.begin(),articulation_point.end());\n\tfor(auto &i:articulation_point)\n\t\tcout << i << endl;\n#endif\n// Strongly Connected Components\n#ifdef S\n\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << (scc[a]==scc[b]) << endl;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u, Edges& brdg, vector< vector<int> >& tecomp, stack<int>& roots, stack<int>& S, vector<bool>& inS, vector<int>& num, int& time)\n{\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  vrep(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 1));\n    tecomp.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      tecomp.back().push_back(w);\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\n\nvoid Bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp)\n{\n  const int n = g.size();\n  vector<int> num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  rep(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint V, E;\nint s, t;\n\nint main()\n{\n  cin >> V >> E;\n  Graph g(V);\n  Edges brdg;\n  vector<vi> tecomp;\n  rep(i, E){\n    cin >> s >> t;\n    g[s].pb(Edge(s, t, 1));\n    g[t].pb(Edge(t, s, 1));\n  }\n\n  Bridge(g, brdg, tecomp);\n\n  sort(ALL(brdg));\n\n  vrep(v, brdg) cout << v->src << \" \" << v->dst << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 10000\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint par[MAX_V],pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[MAX_V]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      par[nx]=v;\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  reverse(bridge.begin(),bridge.end());\n  //sort(bridge.begin(),bridge.end());\n  //bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nclass Graph{\n\tprivate:\n\tint GV,GE;\n\tvvi List;\n\tvoid bridgefunc(int x,vb& used,vi& disc,vi& low,vi& par){\n\t\tstatic int time=0;\n\t\tused[x]=1;\n\t\tdisc[x]=low[x]=++time;\n\t\tfor(int i=0;i<List[x].size();i++){\n\t\t\tint v=List[x][i];\n\t\t\tif(!used[v]){\n\t\t\t\tpar[v]=x;\n\t\t\t\tbridgefunc(v,used,disc,low,par);\n\t\t\t\tlow[x]=min(low[x],low[v]);\n\t\t\t\tif(low[v]>disc[x]){\n\t\t\t\t\tif(v<x) br.push_back(P(v,x));\n\t\t\t\t\telse br.push_back(P(x,v));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(v!=par[x]) low[x]=min(low[x],disc[v]);\n\t\t}\n\t}\n\tpublic:\n\tvp br;\n\tGraph(int v,int e){\n\t\tGV=v;\n\t\tGE=e;\n\t\tList=vvi(v);\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t\tList[y].push_back(x);\n\t}\n\tvoid bridge(){\n\t\tvb used(GV);\n\t\tvi disc(GV),low(GV),par(GV,-1);\n\t\tfor(int i=0;i<GV;i++){\n\t\t\tif(!used[i]) bridgefunc(i,used,disc,low,par);\n\t\t}\n\t}\n};\n\nint V,E;\n\nint main(){\n\tcin>>V>>E;\n\tGraph gra(V,E);\n\tint s,t;\n\tfor(int i=0;i<E;i++){\n\t\tcin>>s>>t;\n\t\tgra.add_edge(s,t);\n\t}\n\tgra.bridge();\n\tsort(gra.br.begin(),gra.br.end());\n\tfor(int i=0;i<gra.br.size();i++){\n\t\tcout<<gra.br[i].first<<' '<<gra.br[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n//O(|V|+|E|)\n\ntemplate<class graph_type> class bridge_and_articulation{\npublic:\n    const int size;\n    graph_type graph;\n    vector<bool> used,is_art;\n    vector<int> ord,low,articulations;\n    vector<pair<int,int>> bridges;\n\n    bridge_and_articulation(const graph_type &graph):graph(graph),size(graph.size()),used(size),is_art(size),ord(size),low(size){\n        int k=0;\n        for(int i=0; i<size; ++i) if(!used[i]) dfs(i,-1,k);\n    }\n\n    void dfs(int v,int p,int &k){ //v???????????¨???p=-1\n        used[v]=true;\n        ord[v]=low[v]=k++;\n\n        int count=0;\n        for(const auto &edge:graph[v]){\n            const int u=edge.to;\n            if(!used[u]){\n                ++count;\n                dfs(u,v,k);\n                low[v]=min(low[v],low[u]);\n\n                if(ord[v]<low[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n                if(p!=-1 and ord[v]<=low[u]) is_art[v]=true;\n            }else if(u!=p) low[v]=min(low[v],ord[u]);\n        }\n\n        if(p==-1 and count>1) is_art[v]=true;\n        if(is_art[v]) articulations.push_back(v);\n    }\n\n    bool is_bridge(int u,int v)const{\n        if(ord[u]>ord[v]) swap(u,v);\n        return ord[u]<low[v];\n    }\n\n    bool is_articulation(int v)const{\n        return is_art[v];\n    }\n};\n\nstruct edge{\n    int to;\n};\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<edge>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(edge({t}));\n        graph[t].push_back(edge({s}));\n    }\n    bridge_and_articulation<vector<vector<edge>>> ba(graph);\n    vector<pair<int,int>> ans=ba.bridges;\n    sort(ans.begin(),ans.end());\n    for(auto &e:ans) cout << e.first << \" \" << e.second << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u,\n    Edges& brdg, vector< vector<int> >& tecomp,\n    stack<int>& roots, stack<int>& S, vector<bool>& inS,\n    vector<int>& num, int& time) {\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  FOR(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 0));\n    tecomp.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      tecomp.back().push_back(w);\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\nvoid bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp) {\n  const int n = g.size();\n  vector<int> num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  REP(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint main(){\n\tint V,E,s,t;\n\tscanf(\"%d%d\",&V,&E);\n\tGraph g(V);\n\tEdges brdg;\n\tvector<vector<int> > tecomp;\n\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(Edge(s,t,0)),g[t].push_back(Edge(t,s,0));\n\tbridge(g,brdg,tecomp);\n\tsort(ALL(brdg));\n\tFOR(e, brdg)printf(\"%d %d\\n\",e->src,e->dst);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\nset<int> pa[maxn];\nset<int> ::iterator it;\nint vis[maxn],low[maxn],dfn[maxn];\nint ind ;\nvector<int> g[maxn];\nvoid tarjan(int u,int p)\n{\n    dfn[u]=low[u]=++ind;\n    vis[u]=1;\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(v==p) continue;\n        if(!vis[v])\n        {\n            tarjan(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u]<low[v])\n                pa[u].insert(v);\n        }\n        else low[u]=min(low[u],dfn[v]);\n    }\n}\nint v,e;\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    tarjan(0,-1);\n    for(int i=0;i<v;i++)\n    {\n        if(pa[i].size()>0)\n        {\n            for(it=pa[i].begin();it!=pa[i].end();it++)\n            {\n                int ma=max(i,*it);\n                    printf(\"%d %d\\n\",i+*it-ma,ma);\n            }\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int>P;\nint n,m,s,t,low[N],used[N],depth[N];\nvector<int> G[N];\nset<P>ans;\n \nvoid dfs(int x,int d,int prev){\n  depth[x]=d;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(nx==prev)continue;\n    if(!used[nx]){\n      used[nx]=true;\n      dfs(nx,d+1,x);\n      if(!low[nx])\n      ans.insert(P(min(x,nx),max(x,nx)));\n      low[x]+=low[nx];\n    }\n    else if(d>depth[nx])low[nx]--,low[x]++;\n  }\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  used[0]=1;\n  dfs(0,0,0);\n  set<P>::iterator it=ans.begin();\n  while(it!=ans.end()){\n    cout<<(*it).first<<' '<<(*it).second<<endl;\n    it++;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <vector>\n\n// instance: an undirected and not necessarily simple graph\nclass two_edge_connected_component\n{\n    using size_t = unsigned;\n    static constexpr size_t nil = -1;\n    bool made;\n    std::vector<size_t> stack, low, comp;\n    std::vector<std::vector<size_t>> graph, tree, memb;\n\n    void make(size_t now, size_t pre)\n    {\n        size_t ord = low[now] = stack.size();\n        stack.emplace_back(now);\n        std::vector<size_t> brid;\n        for(size_t to : graph[now])\n        {\n            if(to == pre) { pre = nil; continue; }\n            if(low[to] == nil) make(to, now);\n            if(low[to] > ord)\n            {\n                brid.emplace_back(to);\n                graph[to].emplace_back(now);\n            }\n            else if(low[now] > low[to]) low[now] = low[to];\n        }\n        brid.swap(graph[now]);\n        if(ord == low[now])\n        {\n            auto pos = stack.end();\n            tree.resize(tree.size() + 1);\n            auto &adjc = tree.back();\n            do\n            {\n                --pos;\n                comp[*pos] = memb.size();\n                for(size_t u : graph[*pos]) adjc.emplace_back(comp[u]);\n            } while(*pos != now);\n            memb.emplace_back(pos, stack.end());\n            stack.erase(pos, stack.end());\n        }\n    }\n\npublic:\n    two_edge_connected_component(size_t n) : made(false), comp(n), graph(n)\n    {\n        stack.reserve(n); comp.reserve(n);\n        tree.reserve(n); memb.reserve(n);\n    }\n\n    void add_edge(size_t u, size_t v)\n    {\n        assert(u < size()), assert(v < size());\n        graph[u].emplace_back(v), graph[v].emplace_back(u);\n        made = false;\n    }\n\n    void make()\n    {\n        if(made) return;\n        made = true;\n        low.assign(size(), nil);\n        for(size_t v = 0; v != size(); ++v) if(low[v] == nil) make(v, nil);\n    }\n\n    size_t size() const { return graph.size(); }\n\n    size_t size(size_t i) { make(); assert(i < count()); return memb[i].size(); }\n\n    size_t count() { make(); return memb.size(); }\n\n    size_t operator[](size_t v) { make(); assert(v < size()); return comp[v]; }\n\n    const std::vector<size_t> &bridge(size_t v) { make(); assert(v < size()); return graph[v]; }\n\n    const std::vector<size_t> &component(size_t i) { make(); assert(i < count()); return memb[i]; }\n\n    const std::vector<std::vector<size_t>> &bridge_tree() { make(); return tree; }\n}; // class two_edge_connected_component\n\n\n#include <cstdio>\n#include <algorithm>\n\nmain()\n{\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    two_edge_connected_component becc(v);\n    for(int a,b; e--;)\n    {\n        scanf(\"%d%d\",&a,&b);\n        becc.add_edge(a,b);\n    }\n    becc.make();\n    for(int i=0; i<v; i++)\n    {\n        std::vector<int> brid;\n        for(int u: becc.bridge(i))\n        {\n            if(i<u) brid.emplace_back(u);\n        }\n        std::sort(brid.begin(),brid.end());\n        for(int u: brid)\n        {\n            printf(\"%d %d\\n\",i,u);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\n#define N 101000\nvii G(N); //グラフの隣接リスト表現\n\nvoid lowlink_dfs(int now, int par, int k, vector<bool> &used, vi &ord, vi &lowlink, vii &ch) {\n  used[now] = true;\n  ord[now] = lowlink[now] = k++;\n  for (int i = 0; i < G[now].size(); i++) {\n    int v = G[now][i];\n    if (v == par) continue;\n    if (!used[v]) {\n      ch[now].push_back(v);\n      lowlink_dfs(v, now, k, used, ord, lowlink, ch);\n      lowlink[now] = min(lowlink[now], lowlink[v]);\n    }\n    else {\n      lowlink[now] = min(lowlink[now], ord[v]);\n    }\n  }\n  return;\n}\n\nvector<pii> bridge(int n) {\n  vector<bool> used(n);\n  vi ord(n), lowlink(n);\n  vii ch(n);\n  \n  int k = 0;\n  rep (i, n) {\n    if (!used[i])\n      lowlink_dfs(i, -1, k, used, ord, lowlink, ch);\n  }\n\n  vector<pii> bri;\n  rep (u, n) {\n    for (int v: G[u]) {\n      if (ord[u] > ord[v]) continue;\n      if (ord[u] < lowlink[v]) \n        bri.push_back(pii(u, v));\n    }\n  }\n  return bri;\n}\n\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  rep (i, m) {\n    int u, v;\n    cin >> u >> v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  auto bri = bridge(n);\n  rep (i, bri.size()) {\n    if (bri[i].first > bri[i].second) swap(bri[i].first, bri[i].second);\n  }\n \n  sort(all(bri));\n \n  rep (i, bri.size()) {\n    cout << bri[i].first << \" \" << bri[i].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nclass Graph {\nprivate:\n\tstruct node {\n\t\tbool done;\n\t\tvi to, cost;\n\t\tint id, from;\n\t\tll d;\n\t\tint pre, low;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint ord, n;\n\tvoid reset() {\n\t\tLoop(i, n) {\n\t\t\tnodes[i].done = false;\n\t\t\tnodes[i].from = -1;\n\t\t\tnodes[i].d = INFLL;\n\t\t}\n\t\tfill(result.begin(), result.end(), 0);\n\t}\n\tvoid lowlink_dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tlowlink_dfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) bridges.push_back({ a,b });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\tif (cnt >(a == root ? 1 : 0)) arts.insert(a);\n\t\treturn;\n\t}\npublic:\n\tvll result;\n\tvvll result2;\n\tvector<P> bridges;\n\tset<int> arts;\n\tGraph(vector<vector<P>> data) {\n\t\tn = data.size();\n\t\tresult.resize(n);\n\t\tnodes.resize(n);\n\t\tord = 0;\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { false,{},{}, i, -1, INFLL, -1, -1 };\n\t\t\tLoop(j, data[i].size()) {\n\t\t\t\tnodes[i].to.push_back(data[i][j].first);\n\t\t\t\tnodes[i].cost.push_back(data[i][j].second);\n\t\t\t}\n\t\t}\n\t}\n\t//mode=>dijkstra, !mode=>prim\n\tvoid mainalgo(int start, int mode) {\n\t\treset();\n\t\tpriority_queue<node> pq;\n\t\tnodes[start].d = 0;\n\t\tpq.push(nodes[start]);\n\t\twhile (pq.size()) {\n\t\t\tnode a = pq.top(); pq.pop();\n\t\t\tif (nodes[a.id].done) continue;\n\t\t\tnodes[a.id].done = true;\n\t\t\tLoop(j, a.to.size()) {\n\t\t\t\tnode *b = &nodes[a.to[j]];\n\t\t\t\tif ((*b).done) continue;\n\t\t\t\tll cand = (mode ? a.d : 0) + a.cost[j];\n\t\t\t\tif (cand < (*b).d) {\n\t\t\t\t\t(*b).d = cand;\n\t\t\t\t\t(*b).from = a.id;\n\t\t\t\t\tpq.push(*b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLoop(i, n) result[i] = nodes[i].d;\n\t}\n\t//false=>negative_cycle\n\tbool bellman_ford(int start) {\n\t\treset();\n\t\tnodes[start].d = 0;\n\t\tLoop(k, n) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnode *a = &nodes[i];\n\t\t\t\tLoop(j, (*a).to.size()) {\n\t\t\t\t\tnode *b = &nodes[(*a).to[j]];\n\t\t\t\t\tif ((*a).d != INFLL && (*a).d + (*a).cost[j] < (*b).d) {\n\t\t\t\t\t\t(*b).d = (*a).d + (*a).cost[j];\n\t\t\t\t\t\t(*b).from = (*a).id;\n\t\t\t\t\t\tif (k == n - 1) return false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLoop(i, n) result[i] = nodes[i].d;\n\t\treturn true;\n\t}\n\t//false=>negative_cycle\n\tbool warshall_floyd() {\n\t\tresult2 = vvll(n, vll(n, INFLL));\n\t\tLoop(i, n) {\n\t\t\tresult2[i][i] = 0;\n\t\t\tLoop(j, nodes[i].to.size()) {\n\t\t\t\tresult2[i][nodes[i].to[j]] = nodes[i].cost[j];\n\t\t\t}\n\t\t}\n\t\tLoop(i, n) {\n\t\t\tLoop(j, n) {\n\t\t\t\tLoop(k, n) {\n\t\t\t\t\tif (result2[j][i] == INFLL || result2[i][k] == INFLL) continue;\n\t\t\t\t\tresult2[j][k] = min(result2[j][k], result2[j][i] + result2[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLoop(i, n) {\n\t\t\tif (result2[i][i] < 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tvoid find_bridges_and_arts() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) lowlink_dfs(i, i);\n\t\t}\n\t\tLoop(i, bridges.size()) {\n\t\t\tif (bridges[i].first > bridges[i].second) swap(bridges[i].first, bridges[i].second);\n\t\t}\n\t\tsort(bridges.begin(), bridges.end());\n\t}\n};\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<P>> data(n);\n\tLoop(i, m) {\n\t\tint s, t; cin >> s >> t;\n\t\tdata[s].push_back({ t,1 });\n\t\tdata[t].push_back({ s,1 });\n\t}\n\tGraph g(data);\n\tg.find_bridges_and_arts();\n\tLoop(i, g.bridges.size()) {\n\t\tcout << g.bridges[i].first << \" \" << g.bridges[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back//also for STRING\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n#define ps push//TMP//stack,(priority) queue,\n#define fr front//TMP//queue//for priority, use top().\ntypedef pair<int,int> pii;\n//Add other types in the same way.\nvoid chmin(int &x,int y){\tx=min(x,y);\treturn;\t}\n\n#define MAX_N 100000\n\nint d[MAX_N],md[MAX_N];\nvector<int> g[MAX_N];\n\nvoid dfs(int u,int v){\n\tmd[v]=d[v];\n\tfor(int j=0;j<g[v].size();++j){\n\t\tint w=g[v][j];\n\t\tif(w==u) continue;\n\t\tif(d[w]<0){\n\t\t\td[w]=d[v]+1;\n\t\t\tdfs(v,w);\n\t\t\tchmin(md[v],md[w]);\n\t\t}else chmin(md[v],d[w]);\n\t}\n}\n\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tvector<pii> es(e);\n\tfor(int j=0;j<e;++j){\n\t\tint v,w;\n\t\tcin>>v>>w;\n\t\tg[v].pb(w);\n\t\tg[w].pb(v);\n\t\tes[j]=mp(min(v,w),max(v,w));\n\t}\n\tfill(d,d+n,-1);\n\td[0]=0;\n\tdfs(-1,0);\n//\tfor(int v=0;v<n;++v){\n//\t\tprintf(\"v=%d,d[v]=%d,md[v]=%d\\n\",v,d[v],md[v]);\n//\t}\n\tvector<pii> ans;\n\tfor(int j=0;j<e;++j){\n\t\tint v=es[j].fi,w=es[j].sc;\n\t\tif((d[v]<=d[w]&&d[v]<md[w])||(d[v]>d[w]&&d[v]>md[w])) ans.pb(es[j]);\n\t}\n\tsort(ans.begin(),ans.end());\n\tfor(int j=0;j<ans.size();++j) cout<<ans[j].fi<<\" \"<<ans[j].sc<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 100010\n\nvector<int> G[MAX_N];\nint n,m;\nint num[MAX_N],par[MAX_N],low[MAX_N];\nint cnt;\nvector<pair<int,int> > res;\n\nvoid bridge(int v,int prev){\n\tnum[v]=low[v]=++cnt;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i];\n\t\tif(num[nv]==-1){\n\t\t\tpar[nv]=v;\n\t\t\tbridge(nv,v);\n\t\t\tlow[v]=min(low[v],low[nv]);\n\t\t\tif(num[v]<low[nv]){\n\t\t\t\tres.push_back(make_pair(min(v,nv),max(v,nv)));\n\t\t\t}\n\t\t}else if(nv!=prev){\n\t\t\tlow[v]=min(low[v],num[nv]);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tG[a].pb(b); G[b].pb(a);\n\t}\n\tmemset(num,-1,sizeof(num));\n\tcnt=0;\n\tbridge(0,-1);\n\tsort(all(res));\n\trep(i,res.size()){\n\t\tcout<<res[i].fi<<\" \"<<res[i].se<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    std::cout << brige.size() << std::endl;\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1) dfs(to, current);\n      if(previous == to)continue;\n      node[current].min_order =\n        min(node[current].min_order,\n            node[to].min_order);\n    }\n    if(node[current].min_order == node[current].order and\n       previous != -1){\n      brige.insert(pii(previous, current));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LowLink {\n    struct Edge {\n        int to;\n        Edge(int to) : to(to) { }\n    };\n    vector<vector<Edge>> graph;\n    int v;\n    vector<int> used, order, low_link, articulation_points;\n    vector<pair<int, int>> bridges;\n    LowLink(int v) : v(v), graph(v),  used(v, 0), order(v, 0), low_link(v, 0) {}\n    void add_edge(int start, int to) {\n        graph[start].emplace_back(to);\n        graph[to].emplace_back(start);\n    }\n    void build() {\n        int current_order = 0;\n        for (int i = 0; i < v; ++i) {\n            if (!used[i]) current_order = dfs(i, current_order, -1);\n        }\n    }\n    int dfs(int id, int current_order, int parent) {\n        used[id] = true;\n        order[id] = current_order++;\n        low_link[id] = order[id];\n        bool is_articulation_points = false;\n        int child_count = 0;\n        for (Edge& e : graph[id]) {\n            if (!used[e.to]) {\n                ++child_count;\n                current_order = dfs(e.to, current_order, id);\n                low_link[id] = min(low_link[id], low_link[e.to]);\n                if (parent != -1 && order[id] <= low_link[e.to]) is_articulation_points = true;\n                if (order[id] < low_link[e.to]) bridges.emplace_back(id, e.to);\n            } else {\n                if (e.to != parent) {\n                    low_link[id] = min(low_link[id], order[e.to]);\n                }\n            }\n        }\n        if (parent == -1 && child_count >= 2) is_articulation_points = true;\n        if (is_articulation_points) articulation_points.push_back(id);\n        return current_order;\n    }\n};\n\n/*\n    verified http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n    verified http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=jp\n*/\nint main() {\n    int V, E; cin >> V >> E;\n    LowLink low_link(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t; cin >> s >> t;\n        low_link.add_edge(s, t);\n    }\n    low_link.build();\n    for (auto& bridge : low_link.bridges) if (bridge.first > bridge.second) swap(bridge.first, bridge.second);\n    sort(low_link.bridges.begin(), low_link.bridges.end());\n    for (auto bridge : low_link.bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n//#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nusing Edges = std::vector<std::vector<int>>;\n\nstruct Memo {\n    int cnt;\n    int parent;\n    int low;\n};\n\nint dfs(int i, const Edges& edges, std::vector<Memo>& memo, int& cnt) {\n    memo[i].cnt = cnt++;\n    int ans = memo[i].cnt;\n    for(auto v: edges[i]) {\n        if(memo[v].cnt < 0) {\n            memo[v].parent = i;\n            ans = std::min(ans, dfs(v, edges, memo, cnt));\n        } else {\n            if(v != memo[i].parent) ans = std::min(ans, memo[v].cnt);\n        }\n    }\n    memo[i].low = ans;\n    return ans;\n}\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    Edges edges(V, std::vector<int>());\n    while(E--) {\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n        edges[t].push_back(s);\n    }\n\n    std::vector<Memo> memo(V, Memo{-1, -1, -1});\n    int cnt = 0;\n    dfs(0, edges, memo, cnt);\n\n    std::vector<std::pair<int, int>> ans;\n    ans.reserve(V);\n    for(int i = 0; i < V; ++i) {\n        if(0 <= memo[i].parent && memo[memo[i].parent].low < memo[i].low) {\n            if(i < memo[i].parent) ans.push_back(std::make_pair(i, memo[i].parent));\n            else ans.push_back(std::make_pair(memo[i].parent, i));\n        }\n    }\n\n    std::sort(begin(ans), end(ans), [](auto x, auto y){return x.first == y.first ? x.second < y.second : x.first < y.first;});\n\n    for(auto val: ans) {\n        std::cout << val.first << \" \" << val.second << \"\\n\";\n    }\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n    int s;\n    int t;\n    bool operator < (const Edge& tgt) const {\n\tif( s == tgt.s )\n\t    return t < tgt.t;\n\treturn s < tgt.s;\n    }\n};\n\n\n\nint Bridges_dfs(const vector<vector<Edge>>& g, vector<int>& order,\n\t\tvector<Edge>& ans, int u, int& cnt_v, Edge pre) {\n    if( order[u] != -1 ) { //?¨????????????¨?????????\n\treturn order[u];\n    }\n    // ??????????¨???????\n    order[u] = cnt_v; cnt_v++;\n    // ??£??\\???????????????\n    int min_v = order[u];\n    for(auto e : g[u]) { // u ?????????????????????????????????????????????\n\tif( e.t == pre.s and e.s == pre.t ) continue; \n\tmin_v = min(Bridges_dfs(g, order, ans, e.t, cnt_v, e), min_v);\n    }\n    if( min_v == order[u] and pre.s != -1 ) {\n\tans.push_back(pre);\n    }\n    return min_v;\n}\n\nvector<Edge> Bridges(const vector<vector<Edge>>& g) {\n    vector<Edge> ans;\n    const int V = g.size();\n    vector<int> order(V,-1);\n    \n    // 0??????DFS\n    int cnt_v = 0;\n    Edge tmp{-1,-1};\n    Bridges_dfs(g, order, ans, 0, cnt_v, tmp);\n    assert(cnt_v == V); // ??£???????????°?????????????????????\n    return ans;\n}\n\nint main () {\n    int V,E;\n    cin >> V >> E;\n    vector<vector<Edge>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t; \n\tg[s].push_back(Edge{s,t});\n\tg[t].push_back(Edge{t,s});\n    }\n    vector<Edge> ans = Bridges(g);\n    sort(ans.begin(), ans.end());\n    for(auto& e : ans) {\n\tcout << e.s << \" \"<< e.t << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\nstruct graphLink {\n    vector<bool> isthrough;\n    vector<int> ord, low, parent;\n    Graph G;\n    int cnt, v;\n\n    // init\n    graphLink(int _n) : isthrough(_n, false), ord(_n, 0), low(_n, 0), parent(_n, 0), G(_n), cnt(0), v(_n) {}\n\n    // example: dfs(0, -1);\n    void dfs(int cur, int prev) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n        isthrough[cur] = true;\n\n        for(auto x : G[cur]) {\n            if(!isthrough[x.to]) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else if(x.to != prev) {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n        }\n    }\n    set<int> artPoints() {\n        set<int> se;\n        int num = 0;\n        rep(i,0,v) {\n            // printf(\"%lld: %lld %lld\\n\", i, ord[parent[i]], low[i]);\n            if(parent[i] == 0) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num > 2) se.insert(0);\n        return se;\n    }\n\n    set<pii> bridges(vector<pii> vp) {\n        set<pii> se;\n        rep(i,0,vp.size()) {\n            if(ord[vp[i].fr] < low[vp[i].sc] || ord[vp[i].sc] < low[vp[i].fr]) se.insert(vp[i]);\n        }\n        return se;\n    }\n};\n\nsigned main() {\n    int v, e; cin >> v >> e;\n    graphLink gr(v);\n    vector<pii> vp;\n\n    int s, t;\n    rep(i,0,e) {\n        cin >> s >> t;\n        gr.G[s].pb(Edge(t,1));\n        gr.G[t].pb(Edge(s,1));\n        vp.pb(pii(s, t));\n    }\n    gr.dfs(0, -1);\n\n    // set<int> ret = gr.artPoints();\n    set<pii> ret2 = gr.bridges(vp);\n    // for(auto x : ret) cout << x << endl;\n    for(auto x : ret2) printf(\"%lld %lld\\n\", x.fr, x.sc);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define ff first\n#define ss second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=100005;\n\nint n,m,tot;\nint vis[N],low[N];\nvector<int>G[N];\nvector<pii>ans;\n\nvoid dfs(int u,int p) {\n    vis[u]=low[u]=++tot;\n    for (int v:G[u]) {\n        if (v == p) continue;\n        if (!vis[v]) {\n            dfs(v,u);\n            low[u]=min(low[u],low[v]);\n            if (low[v]>vis[u]) ans.pb({min(u,v),max(u,v)});\n        }\n        low[u]=min(low[u],vis[v]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin>>n>>m;\n    while (m--) {\n        int u,v; cin>>u>>v,\n        G[u].pb(v),\n        G[v].pb(u);\n    }\n    for (int i=0;i<n;++i) if (!vis[i]) dfs(i,-1);\n    sort(ans.begin(),ans.end());\n    for (auto p:ans) cout<<p.ff<<' '<<p.ss<<'\\n';\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nint ord[100010], low[100010];\nint k;\nvector<int> G[100010];\nvector<pair<int, int>> bridge;\nvector<int> articulation;\nbool visit[100010] = {};\n\nvoid dfs(int v, int p, int &k) {\n    visit[v] = 1;\n    ord[v] = k++;\n    low[v] = ord[v];\n\n    bool isArticulation = 0;\n\tint ct = 0;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (!visit[G[v][i]]) {\n            ct++;\n            dfs(G[v][i], v, k);\n            low[v] = min(low[v], low[G[v][i]]);\n            if (~p && ord[v] <= low[G[v][i]]) isArticulation = 1;\n            if (ord[v] < low[G[v][i]]) \n                bridge.emplace_back(min(v, G[v][i]), max(v, G[v][i]));\n        }\n        else if (G[v][i] != p) {\n            low[v] = min(low[v], low[G[v][i]]);\n        }\n    }\n    if (p == -1 && ct > 1) isArticulation = 1;\n\tif (isArticulation) articulation.push_back(v);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < m; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n\n    int k = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) dfs(i, -1, k);\n\t}\n    sort(bridge.begin(), bridge.end());\n\tsort(articulation.begin(), articulation.end());\n\n    for (int i = 0; i < bridge.size(); i++) {\n        cout << bridge[i].first << \" \" << bridge[i].second << endl;\n    }\n    for (int i = 0; i < articulation.size(); i++) {\n        //cout << articulation[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct edge{\n    int f, t;\n};\n\nconst int V_MAX = (int)1e5;\nvector<int> edges[V_MAX];\nint ord[V_MAX];\nint low[V_MAX];\nbool used_v[V_MAX], used_e[V_MAX][V_MAX];\nvector<edge> ans;\n\nbool comp(edge e1, edge e2){\n    if(e1.f == e2.f){\n        return e1.t < e2.t;\n    } else {\n        return e1.f < e2.f;\n    }\n}\n\nvoid dfs(int u, int k){\n    low[u] = ord[u] = k;\n    k += 1;\n    used_v[u] = true;\n\n    for(int i=0; i<edges[u].size(); i++){\n        int next = edges[u][i];\n\n        if(not used_v[next]){\n            used_e[u][next] = used_e[next][u] = true;\n            dfs(next, k);\n            low[u] = min(low[u], low[next]);\n\n            if(low[next] > ord[u]){\n                edge e;\n                e.f = min(u, next); e.t = max(u, next);\n                ans.push_back(e);\n            }\n        } else if(not used_e[u][next]){\n            low[u] = min(low[u], ord[next]);\n\n        }\n    }\n    return ;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int v, e; \n    cin >> v >> e;\n\n    for(int i=0; i<e; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    dfs(0, 1);\n\n    sort(ans.begin(), ans.end(), comp);\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i].f << \" \" << ans[i].t << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\n\nusing namespace std;\nconst int maxN=1e5+100;\n\nmap <pair<int,int>, bool> iscut;\nint dfs_num;\nvector<int> g[maxN];\nvector<pair<int,int> > ans;\nbool mark[maxN];\nint high[maxN];\nint n,m;\n\n#define mp make_pair\n\n\nvoid input()\n{\n  cin>>n>>m;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2;\n      cin>>k1>>k2;\n      g[k1+1].push_back(k2+1);\n      g[k2+1].push_back(k1+1);\n    }\n\t\n}\nvoid dfs(int v,int parent)\n{\n  int copydfsnum=dfs_num;\n  high[v]=dfs_num++;\n  mark[v]=true;\n  \n  \n  for(int i=0;i<g[v].size();i++){\n    if(!mark[g[v][i]])\n      dfs(g[v][i],v);\n    if(g[v][i]!=parent)\n    high[v]=min(high[v],high[g[v][i]]);\n    if(high[g[v][i]]>copydfsnum){\n      //if(v<g[v][i])\n      ans.push_back(mp(min(v,g[v][i]),max(v,g[v][i])));\n      //      iscut[mp(v,g[v][i])]=true;\n      //iscut[mp(g[v][i],v)]=true; // age jahat dar hast graph ino comment kon\n\n    }\n    // cout<<v<<\" \"<<g[v][i]<<\" \"<<high[g[v][i]]<<\" \"<<copydfsnum<<endl;\n  }\n}\n\nvoid show()\n{\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i].first-1<<\" \"<<ans[i].second-1<<endl;\n}\nint main()\n{\n  input();\n  dfs(1,0);\n  show(); \n} "
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxn=100005,inf=200000;\nint n,m,mark[maxn],par[maxn],high[maxn],mini[maxn],minimomesh[maxn],dp[maxn],mark2[maxn];\nvector<int> adj[maxn];\nvector<pair<int,int>> v;\npair<int ,int > kol[maxn];\nvoid dfs(int v)\n{\n    mark[v]=1;\n\n    for(int u=0; u<adj[v].size(); u++)\n    {\n        int r=adj[v][u];\n        if(mark[r]==0)\n        {\n\n\n            par[r]=v;\n            high[r]=high[v]+1;\n\n            dfs(r);\n           // dp[v]=min(dp[r],dp[v]);\n\n\n\n\n        }\n\n    }\n\n\n\n\n}\nvoid dfs2(int v)\n{\n    mark2[v]=1;\n\n\n    for(int c=0; c<adj[v].size(); c++)\n    {\n        int z=adj[v][c];\n        if(mark2[z]==0)\n        {\n            dfs2(z);\n            dp[v]=min(dp[z],dp[v]);\n        }\n    }\n\n}\nvoid minyab(int v)\n{\n    dp[v]=inf;\n    for(int e=0; e<adj[v].size(); e++)\n    {\n        int t=adj[v][e];\n        if(t!=par[v])\n        {\n\n\n        dp[v]=min(high[t],dp[v]);\n    }\n    }\n    return;\n}\n\n\nint main()\n{\n\n\n    cin>>n>>m;\n    for(int i=0; i<m; i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    dfs(0);\n\n    for(int i=0; i<n; i++)\n    {\n       minyab(i);\n\n    }\n    dfs2(0);\n\n\n  /*  for(int i=0; i<n; i++)\n    {\n        cout<<mini[i]<<' '<<high[i]<<' '<<high[par[i]]<<' '<<dp[i]<<' '<<minimomesh[i]<<endl;\n    }*/\n\n    for(int i=1; i<n; i++)\n    {\n        if(dp[i]>high[par[i]])\n        {\n\n\n            kol[i].first=i;\n            kol[i].second=par[i];\n            if(kol[i].first>kol[i].second)\n            {\n                swap(kol[i].first,kol[i].second);\n            }\n            v.push_back(kol[i]);\n        }\n    }\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++)\n    {\n        cout<<v[i].first<<' '<<v[i].second<<endl;\n    }\n\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<complex>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \n#include <numeric>\nusing namespace std;\nusing Complex = complex<double>;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\nconst double EPS = 1e-10;\ndouble PI = acos(-1.0);\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\n\nconst int MAX_N = 202020;\nvector<int>e[MAX_N + 5];\nvector<int>ap;\nvector<pair<int, int>>br;\nint ord[MAX_N + 5], low[MAX_N + 5], state[MAX_N + 5];\nint cnt = 0;\nvoid orddfs(int now,int parent) {\n\tstate[now] = 1;\n\tord[now] = cnt;\n\tcnt++;\n\tint ccnt = 0;\n\tint appended = 0;\n\tint clow = 1e9 + 5;\n\tint ordlow = 1e9 + 5;\n\tfore(x, e[now]) { \n\t\tif (state[x] == 1) {\n\t\t\t//後退辺はx→uを含まない\n\t\t\tif(x != parent)ordlow = min(ordlow, ord[x]);\n\t\t}\n\t\telse {\n\t\t\torddfs(x,now);\n\t\t\tclow = min(clow,low[x]);\n\t\t\t//関節点(根以外)\n\t\t\tif (parent != -1 && low[x] >= ord[now] && appended == 0) {\n\t\t\t\tap.pb(now);\n\t\t\t\tappended = 1;\n\t\t\t}\n\t\t\t//橋\n\t\t\tif (low[x] > ord[now])br.pb({min(now,x),max(now,x)});\n\t\t\tccnt++;\n\t\t}\n\t} \n\tif (parent == -1 && ccnt >= 2)ap.pb(now);\n\tlow[now] = min(min(clow,ordlow),ord[now]);\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint V, E;\n\tcin >> V >> E;\n\tfor (int i = 0; i < E; i++){\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\te[s].pb(t);\n\t\te[t].pb(s);\n\t}\n\torddfs(0,-1);\n\tsort(all(br));\n\tfore(x, br)cout << x.first << \" \" << x.second << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n \nvector<int>E[100000];\nint s[100000],t[100000];\nint dep[100000],low[100000],k;\nbool used[100000];\nvector<P>V;\n \nvoid dfs(int v,int p,int d){\n    used[v]=true;\n    low[v]=dep[v]=d;\n    for(auto u:E[v]){\n        if(!used[u]){\n            dfs(u,v,d+1);\n            low[v]=min(low[v],low[u]);\n            if(dep[v]<low[u])V.push_back(P(min(u,v),max(u,v)));\n        }\n        else if(p!=u){\n            low[v]=min(low[v],dep[u]);\n        }\n    }\n}\nint main(){\n    int v,e;scanf(\"%d%d\",&v,&e);\n    rep(i,e){\n        scanf(\"%d%d\",&s[i],&t[i]);\n        E[s[i]].push_back(t[i]);\n        E[t[i]].push_back(s[i]);\n    }\n    dfs(0,-1,0);\n    sort(V.begin(),V.end());\n    for(auto p:V){\n        cout<<p.first<<' '<<p.second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\npair<int, int> a[200010];\nint s[100001];\nint g[100001];\nint n[100001];\nint p[100001];\nint l[100001];\nint u[100001]={};\nint c, t;\nint x, y;\nint k;\n\nvoid dfs(int f, int z)\n{\n\tn[f]=t;\n\tl[f]=t;\n\tt++;\n\tu[f]=1;\n\tfor(int i=s[f]; i<=g[f]; i++)\n\t{\n\t\tif(u[a[i].second]==0)\n\t\t{\n\t\t\tp[a[i].second]=f;\n\t\t\tdfs(a[i].second, f);\n\t\t\tl[f]=min(l[f], l[a[i].second]);\n\t\t}\n\t\telse if(a[i].second!=z)\n\t\t{\n\t\t\tl[f]=min(l[f], n[a[i].second]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tfor(int i=0; i<e; i++)\n\t{\n\t\tcin >> x >> y;\n\t\ta[2*i]=make_pair(x, y);\n\t\ta[2*i+1]=make_pair(y, x);\n\t}\n\tsort(a, a+(2*e));\n\ts[0]=0;\n\tg[v-1]=2*e-1;\n\tc=0;\n\tfor(int i=1; i<2*e; i++)\n\t{\n\t\tif(a[i].first>a[i-1].first)\n\t\t{\n\t\t\tg[c]=i-1;\n\t\t\tc++;\n\t\t\ts[c]=i;\n\t\t}\n\t}\n\tt=0;\n\tdfs(0, -1);\n\tk=0;\n\tfor(int i=1; i<v; i++)\n\t{\n\t\tif(p[i]==0)\n\t\t{\n\t\t\tk++;\n\t\t}\n\t}\n\tif(k>1)\n\t{\n\t\tfor(int i=s[0]; i<=g[0]; i++)\n\t\t{\n\t\t\tif(p[a[i].second]==0)\n\t\t\t{\n\t\t\t\tcout << 0 << \" \" << a[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if(s[0]==g[0])\n\t{\n\t\tcout << 0 << \" \" << a[g[0]].second << endl;\n\t}\n\tfor(int i=s[1]; i<2*e; i++)\n\t{\n\t\tif(a[i].first<a[i].second)\n\t\t{\n\t\t\tif(p[a[i].first]==a[i].second)\n\t\t\t{\n\t\t\t\tif(n[a[i].second]<=l[a[i].first])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p[a[i].second]==a[i].first)\n\t\t\t{\n\t\t\t\tif(n[a[i].first]<=l[a[i].second])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_V = 1e5+10;\n\nvector<vector<int> > g(MAX_V);\nvector<pair<int, int> > bridge;\nint n;\nbool visited[MAX_V];\nint ord[MAX_V], low[MAX_V], timer;\n\nvoid dfs(int v, int p){\n\tord[v] = low[v] = timer++;\n\tvisited[v] = true;\n\tfor (int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tint to = g[v][i];\n\t\tif (to == p) continue;\n\t\tif (visited[to]) low[v] = min(low[v], ord[to]);\n\t\telse {\n\t\t\tdfs(to, v);\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t\tif (ord[v] < low[to]) bridge.push_back(make_pair(min(v,to),max(v, to)));\n\t\t}\n\t}\n}\n\nvoid find_bridge(){\n\tfor (int i = 0; i < n; ++i) visited[i] = false;\n\n\ttimer = 0;\n    dfs(0,-1);\n    sort(bridge.begin(), bridge.end());\n\tbridge.erase(unique(bridge.begin(), bridge.end()), bridge.end());\n}\n\nint main(int argc, char const *argv[])\n{\n\tint m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\n\tfind_bridge();\n\n\tfor (int i = 0; i < bridge.size(); ++i) cout << bridge[i].first << ' ' << bridge[i].second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\n\nstruct edge{ int to,cost; };\nstruct Bridge_Decomposition{\n  vector<vector<edge>> G,Tree,NewTree; //グラフ, グラフ->木(後退辺を消す), 木->色をまとめた木\n  vector<int> dp,depth,cmp; //葉から根までの累積和, 木の深さ, 色(同じ色で強連結)\n  vector<pair<int,int>> bridge; //橋\n  int color = 1;\n\n  Bridge_Decomposition(vector<vector<edge>> G):G(G){\n    int n = G.size();\n    Tree.resize(n); NewTree.resize(n);\n    dp.resize(n,0); depth.resize(n,-1); cmp.resize(n,0);\n    dfs(0,-1,0); //木の構築\n    dfs2(0,-1); //累積和\n    dfs3(0,-1); //色塗り\n    dfs4(0,-1); //同じ色をまとめた木にする, 橋の列挙, 関節点の列挙\n  }\n\n  void dfs(int u,int pre,int d){\n    depth[u] = d;\n    for(edge e : G[u]){\n      if(e.to == pre) continue;\n      if(depth[e.to] == -1){\n        dfs(e.to,u,d+1);\n        Tree[u].push_back(e);\n        Tree[e.to].push_back({u,e.cost});\n      }else {\n        if(depth[e.to] < depth[u]){\n          dp[u]++;\n          dp[e.to]--;\n        }\n      }\n    }\n    return;\n  }\n\n  void dfs2(int u,int pre){\n    for(edge e : Tree[u]){\n      if(e.to == pre) continue;\n      dfs2(e.to,u);\n      dp[u] += dp[e.to];\n    }\n    return;\n  }\n\n  void dfs3(int u,int pre){\n    for(edge e : Tree[u]){\n      if(e.to == pre) continue;\n      if(dp[e.to] == 0){\n        cmp[e.to] = color++;\n      }else {\n        cmp[e.to] = cmp[u];\n      }\n      dfs3(e.to,u);\n    }\n    return;\n  }\n\n  void dfs4(int u,int pre){\n    for(edge e : Tree[u]){\n      if(e.to == pre) continue;\n      int x = cmp[u], y = cmp[e.to];\n      if(x != y){\n        NewTree[x].push_back({y,e.cost});\n        NewTree[y].push_back({x,e.cost});\n        bridge.push_back(minmax(u,e.to));\n      }\n      dfs4(e.to,u);\n    }\n    return;\n  }\n};\n\nsigned main(){\n\n  int n,m; cin >> n >> m;\n  vector<vector<edge>> G(n);\n  for(int i = 0; i < m; i++){\n    int x,y; cin >> x >> y;\n    G[x].push_back({y,1});\n    G[y].push_back({x,1});\n  }\n\n  Bridge_Decomposition bd(G);\n  sort(bd.bridge.begin(),bd.bridge.end());\n  for(auto p : bd.bridge){\n    cout << p.first << \" \" << p.second << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1){\n        dfs(to, current);\n        node[current].min_order =\n          min(node[current].min_order,\n              node[to].min_order);\n      }else{\n        if(previous == to)continue;\n        node[current].min_order =\n          min(node[current].min_order,\n              node[to].min_order);\n      }\n    }\n    if(previous != -1 and node[current].min_order == node[previous].order){\n      brige.insert(pii(current, to));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  typedef int weight_type;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\ntypedef Edge::weight_type Weight;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Weights;\ntypedef std::vector<int> Path;\n}\ntypedef std::vector<graph::Edges> Graph;\n}\n#endif\n//}}}\n//{{{ bridge.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\nnamespace bridge_internal {\nstruct BridgeImpl {\n  const Graph& G;\n  int k;\n  std::vector<int> ord, low;\n  Edges bridges;\n  BridgeImpl(const Graph& g) : G(g), k(0), ord(g.size(), -1), low(g.size()) {}\n  void dfs(int v, int p = -1) {\n    low[v] = ord[v] = k++;\n    for (const auto& e : G[v]) {\n      int u = e.to;\n      if (u == p) continue;\n      if (ord[u] >= 0) {\n        low[v] = std::min(low[v], ord[u]);\n      } else {\n        dfs(u, v);\n        low[v] = std::min(low[v], low[u]);\n      }\n      if (ord[v] < low[u]) bridges.emplace_back(e);\n    }\n  }\n  Edges get() {\n    dfs(0);\n    return std::move(bridges);\n  }\n};\n}\nEdges bridges(const Graph& g) {\n  return std::move(bridge_internal::BridgeImpl(g).get());\n}\n}\n}\n//}}}\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\nint main() {\n  int V = in(), E = in();\n  orliv::Graph g(V);\n  for (int i = 0; i < E; i++) {\n    int s = in(), t = in();\n    g[s].emplace_back(s, t, 1);\n    g[t].emplace_back(t, s, 1);\n  }\n  auto bridges = orliv::graph::bridges(g);\n  for (auto& e : bridges) {\n    if (e.from > e.to) swap(e.from, e.to);\n  }\n  sort(bridges.begin(), bridges.end());\n  for (auto& e : bridges) {\n    cout << e.from << \" \" << e.to << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint V,E;\nvector<int> G[MAX];\n\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\n\nvector<P> ans;\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to]==0)ans.push_back( P( min(pos,to) , max(pos,to) ) );\n    }else if(depth[to]<depth[pos]){\n      cnt[pos]++;\n      cnt[to]--;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  sort(ans.begin(),ans.end());\n  \n  for(int i=0;i<(int)ans.size();i++)\n    printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to){ \n\tgraph[from].push_back({to});\n}\n\n// Description: ????????°??????????????????Low_Link \n// TimeComplexity: $ \\mathcal{O}(V + E) $\n// Verifyed: AOJ GRL_3_A GRL_3_B \n\nauto low_link(const G& graph){\n    int n=graph.size(),k=0;\n    vector<int> par(n),ord(n,-1),low(n),root(n,0);\n\n    auto dfs=[&](int v,int p,int &k){\n        auto func=[&](int v,int p,int &k,auto func)->void{\n            ord[v]=k++,low[v]=ord[v],par[v]=p;\n            for(auto &e:graph[v]){\n                if(e.to==p) continue;\n                if(ord[e.to]==-1)\n                    func(e.to,v,k,func),chmin(low[v],low[e.to]);\n                else\n                    chmin(low[v],ord[e.to]);\n            }\n        };\n        return func(v,p,k,func);\n    };\n\n    rep(v,n) if(ord[v]==-1) dfs(v,-1,k),root[v]=1;\n    return make_tuple(par,ord,low,root);\n}\n\n\n// Description: ????????°????????????????????? \n// TimeComplexity: $ \\mathcal{O}(V + E) $\n// Verifyed: AOJ GRL_3_B\n// Required: Low-link\n\nauto bridge(const G& graph){\n    const int n=graph.size();\n    vector<int> par,ord,low,root;\n    tie(par,ord,low,root)=low_link(graph);\n\n    using state=tuple<int,int>;\n    vector<state> res;\n    rep(v,n){\n        if(par[v]==-1) continue;\n        if(ord[v]<low[par[v]]||ord[par[v]]<low[v]){\n            auto in=state(v,par[v]);\n            if(get<1>(in)<=get<0>(in)) swap(get<0>(in),get<1>(in));\n            res.push_back(in);\n        }\n    }\n    sort(_all(res));\n    return res;      \n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_edge(graph,a,b);\n\t\tadd_edge(graph,b,a);\n\t}\n\n\tauto res=bridge(graph);\n\t\n    for(auto &it:res){\n        int a,b;\n        tie(a,b)=it;\n        cout << a << \" \" << b << endl;\n    } \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\nvector<int> S[MAX];\nint N,ord[MAX],low[MAX],visit[MAX],par[MAX],timer;\n\nvoid DFS(int cur,int mae){\n    \n    ord[cur]=low[cur]=timer;\n    par[cur]=mae;\n    visit[cur]=1;\n    timer++;\n    \n    for(int i=0;i<S[cur].size();i++){\n        int a=S[cur][i];\n        if(a==mae) continue;\n        if(visit[a]){\n            low[cur]=min(low[cur],ord[a]);\n            continue;\n        }\n        DFS(a,cur);\n        low[cur]=min(low[cur],low[a]);\n    }\n}\n\nvoid search(int u){//u==0なら関節点、1なら橋\n    for(int i=0;i<N;i++){\n        visit[i]=0;\n        par[i]=-1;\n    }\n    timer=1;\n    \n    DFS(0,-1);\n    \n    if(u==0){\n        set<int> se;\n        int cnt=0;\n        for(int i=1;i<N;i++){\n            if(par[i]==0) cnt++;\n            else if(ord[par[i]]<=low[i]) se.insert(par[i]);\n        }\n        if(cnt>1) se.insert(0);\n        \n        for(auto it=se.begin();it!=se.end();it++){\n            cout<<*it<<endl;\n        }\n    }else{\n        set<pair<int,int>> se;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<S[i].size();j++){\n                int x=S[i][j];\n                if(ord[i]<low[x]){\n                    int a=i,b=x;\n                    if(a>b) swap(a,b);\n                    se.insert(make_pair(a,b));\n                }\n            }\n        }\n        \n        for(auto it=se.begin();it!=se.end();it++){\n            cout<<(*it).first<<\" \"<<(*it).second<<endl;\n        }\n    }\n}\n\nint main(){\n\n    int M;cin>>N>>M;\n    for(int i=0;i<M;i++){\n        int a,b;cin>>a>>b;\n        S[a].push_back(b);\n        S[b].push_back(a);\n    }\n    \n    search(1);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nvector<bool> check(V_MAX,false);\nvector<int> pre(V_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(check[s]==true){return;}\n\tcheck[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(G[s][i]!=p && low[G[s][i]]<low[s]){\n\t\t\tlow[s]=low[G[s][i]];\n\t\t}\n\t\tif(check[G[s][i]]==false){\n\t\t\tdfs(G[s][i],s);\n\t\t}\n\t}\n\t\n\tif(!(s==0&&p==0) && pre[s]==low[s]){\n\t\tedge e;\n\t\te.from=p;\n\t\te.to=s;\n\t\tresult.push_back(e);\n\t\t//cout << p << \" \" << s << endl;\n\t}\n\t\n\t\n\t\n\tif(low[p]>low[s]){\n\t\tlow[p]=low[s];\n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(long long i=0; i<(n); i++)\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll cnt = 0;\nvector<pair<ll,ll>> res;\nvector<ll> ord(100005, -1), pre(100005, -1);\nvector<vector<ll>> edge(100005);\n\nvoid dfs(ll i, ll j){\n    ord[i] = cnt;\n    pre[i] = cnt;\n    cnt++;\n    for(ll x : edge[i]){\n        if(x == j) continue;\n        if(ord[x] > -1) chmin(pre[i], pre[x]);\n        else dfs(x, i);\n    }\n    if(j > -1) chmin(pre[j], pre[i]);\n    if(j > -1 && pre[i] > ord[j]) res.push_back({min(i, j), max(i, j)});\n    return;\n}\n\nint main(){\n    ll v,e; cin>>v>>e;\n    rep(i, e){\n        ll s,t; \n        cin>>s>>t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n    vector<ll> ord(v, -1), pre(v, -1);\n    dfs(0, -1);\n    sort(res.begin(), res.end());\n    for(pair<ll,ll> p : res){\n        cout<<p.first<<' '<<p.second<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kNil = -1;\n\nenum class Color {\n  kWhite,\n  kGrey,\n  kBlack,\n};\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\nvoid BridgesVisit(\n    const typename vector<Edge>::size_type node_now,\n    typename vector<Edge>::size_type & time,\n    const vector<vector<Edge>> & adjacency_list,\n    vector<int> & d,\n    vector<int> & low,\n    vector<Color> & color,\n    vector<int> & parent) {\n  color[node_now] = Color::kGrey;\n  d[node_now] = time;\n  low[node_now] = time++;\n  for (const auto & e: adjacency_list[node_now]) {\n    if (color[e.v] == Color::kWhite) {\n      parent[e.v] = e.u;\n      BridgesVisit(e.v, time, adjacency_list, d, low, color, parent);\n      low[e.u] = min(low[e.u], low[e.v]);\n    } else if (parent[e.u] != e.v) {\n      low[e.u] = min(low[e.u], d[e.v]);\n    }\n  }\n  color[node_now] = Color::kBlack;\n}\n\ntemplate <class Edge>\ndecltype(auto) Bridges(vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n\n  vector<vector<Edge>> adjacency_list(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency_list[e.u].push_back(e);\n  }\n\n  size_type time = 0;\n  vector<int> d(node_num);\n  vector<int> low(node_num);\n  vector<Color> color(node_num, Color::kWhite);\n  vector<int> parent(node_num, kNil);\n\n  for (unsigned i = 0; i < node_num; ++i) {\n    if (color[i] == Color::kWhite) {\n      BridgesVisit(i, time, adjacency_list, d, low, color, parent);\n    }\n  }\n\n  vector<Edge> bridges;\n  for (const auto & e: edges) {\n    if (d[e.u] < low[e.v]) {\n      if (e.u < e.v) {\n        bridges.push_back(e);\n      } else {\n        bridges.emplace_back(e.v, e.u, e.w);\n      }\n    }\n  }\n\n  sort(bridges.begin(), bridges.end());\n\n  return bridges;\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = unsigned;\n\n  vector<Edge<w_type>> edges;\n  unsigned V, E;\n  cin >> V >> E;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    w_type w;\n    cin >> u >> v;\n    edges.emplace_back(u, v, 1);\n    edges.emplace_back(v, u, 1);\n  }\n\n  auto bridges = Bridges(edges, V);\n  for (const auto & e: bridges) {\n    cout << e.u << \" \" << e.v << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nvoid DFS(Graph g, int u, int &clock, vector<int> &low, vector<int> &disc, vector<bool> &seen, vector<int> &parent, vector<Edge> &bridges) {\n    stack<int> s;\n    for(int v: g[u]) {\n        if (! seen[v]) {\n            clock++;\n\n            disc[v] = clock;\n            low[v] = clock;\n            seen[v] = true;\n            parent[v] = u;\n\n            DFS(g, v, clock, low, disc, seen, parent, bridges);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u])\n                bridges.push_back(Edge{min(u, v), max(u, v)});\n        } else if (v != parent[u]) {\n            low[u]  = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> bridges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    int clock = 2;\n    vector<int> low(V, 0);\n    vector<int> disc(V, 0);\n    vector<int> parent(V, -1);\n    vector<bool> seen(V, false);\n    disc[0] = 1;\n    low[0] = 1;\n    seen[0] = true;\n\n    DFS(g, 0, clock, low, disc, seen, parent, bridges);\n\n    sort(bridges.begin(), bridges.end());\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef pair<lint, pii> plp;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 1e9+7;\nconst lint INF = mod*mod;\nconst int MAX = 5010;\n\ntypedef struct UnionFindTree{\n    vector<int> par;\n\n    UnionFindTree(int n){\n        par.resize(n, -1);\n    }\n\n    int find(int x){\n        if(par[x] < 0) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n}UF;\n\ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c){\n        from = f; to = t; cost = c;\n    }\n};\n\ntemplate<class T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n\n    Graph(int n_){\n        n = n_;\n        G.resize(n);\n    }\n\n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n\n    pair<bool, vector<T>> bellman_ford(int s){\n        T INF = numeric_limits<T>::max();\n        vector<T> d(n, INF);\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        d[s] = 0;\n        rep(i, n)for(edge<T> &e: E){\n            if(d[e.from] != INF && d[e.from] + e.cost < d[e.to]){\n                d[e.to] = d[e.from] + e.cost;\n                if(i == n-1) return make_pair(true, d);\n            }\n        }\n        return make_pair(false, d);\n    }\n\n    vector<T> dijkstra(int s){\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<T> d(n, numeric_limits<T>::max());\n        d[s] = 0;\n        que.push(P((T)0, s));\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(edge<T> &e : G[v]){\n                if(d[e.to] > d[v] + e.cost){\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n        return d;\n    }\n\n    pair<bool, vector<vector<T>>> warshall_floyd(){\n        T INF = numeric_limits<T>::max();\n        vector<vector<T>> d = vector<vector<T>>(n, vector<T>(n, INF));\n        rep(i, n){\n            for(edge<T> &e: G[i]) d[i][e.to] = e.cost;\n            d[i][i] = 0;\n        }\n        rep(k, n)rep(i, n)rep(j, n)if(d[i][k] < INF && d[k][j] < INF){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        rep(i, n)if(d[i][i] < 0) return make_pair(true, d);\n        return make_pair(false, d);\n    }\n\n    T kruskal(){\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        sort(E.begin(), E.end(), [](const edge<T> &e1, const edge<T> &e2){return e1.cost < e2.cost;});\n        UF uf(n);\n        T res = 0;\n        for(edge<T> &e: E){\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        return res;\n    }\n\n    pair<bool, vector<int>> toposo(){\n        vector<int> ret(n, -1), in(n, 0);\n        rep(i, n)for(edge<T> &e: G[i]) ++in[e.to];\n        int cur = 0;\n        stack<int> st;\n        rep(i, n)if(!in[i]) st.push(i);\n        if(st.empty()) return make_pair(false, ret);\n        while(!st.empty()){\n            int v = st.top(); st.pop();\n            ret[cur++] = v;\n            for(edge<T> &e: G[v]){\n                if(!in[e.to]) return make_pair(false, ret);\n                --in[e.to];\n                if(!in[e.to]) st.push(e.to);\n            }\n        }\n        return make_pair(cur==n, ret);\n    }\n\n    bool has_cycle(){\n        return !toposo().fi;\n    }\n\n    void scc_dfs(int v, vector<bool> &used, vector<int> &vs){\n        used[v] = true;\n        for(edge<T> &e: G[v])if(!used[e.to]) scc_dfs(e.to, used, vs);\n        vs.push_back(v);\n    }\n\n    void scc_rdfs(int v, int k, vector<int> &cmp, vector<bool> &used, vector<vector<int>> &rG){\n        used[v] = true;\n        cmp[v] = k;\n        for(int nv: rG[v])if(!used[nv]) scc_rdfs(nv, k, cmp, used, rG);\n    }\n\n    pair<int, vector<int>> scc(){\n        vector<vector<int>> rG(n);\n        rep(i, n)for(edge<T> &e: G[i]) rG[e.to].push_back(i);\n        vector<bool> used(n, false);\n        vector<int> vs;\n        vector<int> cmp(n);\n        rep(i, n)if(!used[i]) scc_dfs(i, used, vs);\n        fill(used.begin(), used.end(), false);\n        int k = 0;\n        rrep(i, n)if(!used[vs[i]]) scc_rdfs(vs[i], k++, cmp, used, rG);\n        return make_pair(k, cmp);\n    }\n\n    int bridge_dfs(int v, int pv, int &idx, vector<int> &ord, vector<int> &low, vector<pii> &bridge){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=pv){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], bridge_dfs(nv, v, idx, ord, low, bridge));\n                if(low[nv]>ord[v]) bridge.emplace_back(min(v, nv), max(v, nv));\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<pii> get_bridge(){\n        vector<int> ord(n, -1), low(n, -1);\n        vector<pii> bridge;\n        int idx=0;\n        bridge_dfs(0, -1, idx, ord, low, bridge);\n        sort(bridge.begin(), bridge.end());\n        bridge.erase(unique(bridge.begin(), bridge.end()), bridge.end());\n        return bridge;\n    }\n};\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    Graph<int> gr(n);\n    rep(i, m){\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        gr.add_edge(a, b, 1);\n        gr.add_edge(b, a, 1);\n    }\n    auto bridge=gr.get_bridge();\n    for(pii e: bridge) printf(\"%d %d\\n\", e.fi, e.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        cin>>from[i]>>to[i];\n        if(from[i]>to[i] )\n            swap(from[i],to[i]);\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n\n}"
  },
  {
    "language": "C++",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias P = Tuple!(int, int);\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\twriteln(p[0], \" \", p[1]);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1e5+10;\nint n,m,H[M];\nvector<int>g[M];\nbool cv[M],mark[M];\nvector<pair<int,int> >ans;\nint dfs(int v,int par,int h)\n{\n  int up=h;\n  mark[v]=true;\n  H[v]=h;\n  for(auto u:g[v])\n    if(!mark[u])\n      {\n\tint d=dfs(u,v,h+1);\n\tup=min(up,d);\n\tif(d>h)ans.push_back({min(u,v),max(u,v)});\n      }\n    else if(u!=par)\n      up=min(up,H[u]);\n  return up;\n}\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<m;i++)\n    {\n      int u,v;\n      cin>>u>>v;\n      u++,v++;\n      g[u].push_back(v);\n      g[v].push_back(u);\n    }\n  dfs(1,1,0);\n  sort(ans.begin(),ans.end());\n  for(auto p:ans)\n    cout<<p.first-1<<\" \"<<p.second-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nstruct low_link {\npublic :\n\tvector<int> articulation;\n\tvector<pair<int, int>> bridge;\nprivate :\n\tstruct edge {\n\t\tint to, idx;\n\t\tedge (int to, int idx) : to(to), idx(idx) { }\n\t};\n\tint n, edge_index = 0;\n\tvector<vector<edge>> g;\n\tvector<int> order, low;\n\tvector<bool> seen;\n\n\tint dfs (int v, int p, int ord) {\n\t\tseen[v] = true;\n\t\torder[v] = ord++;\n\t\tlow[v] = order[v];\n\t\tint child = 0;\n\t\tbool isart = false;\n\t\tfor (const edge &e : g[v]) if (p != e.idx) {\n\t\t\tif (seen[e.to]) {\n\t\t\t\tlow[v] = min(low[v], order[e.to]);\n\t\t\t} else {\n\t\t\t\tchild++;\n\t\t\t\tord = dfs(e.to, e.idx, ord);\n\t\t\t\tlow[v] = min(low[v], low[e.to]);\n\t\t\t\tif (p != -1) isart |= (order[v] <= low[e.to]);\n\t\t\t\tif (order[v] < low[e.to]) {\n\t\t\t\t\tbridge.push_back(minmax(v, e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisart |= (p == -1 and child >= 2);\n\t\tif (isart) articulation.push_back(v);\n\t\treturn ord;\n\t}\n\npublic :\n\tlow_link (int n) : n(n), g(n), order(n), low(n), seen(n) { }\n\n\tvoid add_edge (int v, int u) {\n\t\tg[v].emplace_back(u, edge_index);\n\t\tg[u].emplace_back(v, edge_index);\n\t\tedge_index++;\n\t}\n\n\tvoid build (int r = 0) {\n\t\tbridge.clear(); articulation.clear();\n\t\tfill(seen.begin(), seen.end(), false);\n\t\tfor (int s = 0; s < g.size(); s++) {\n\t\t\tif (not seen[s]) dfs(s, -1, 0);\n\t\t}\n\t}\n\n};\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tlow_link g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg.add_edge(a, b);\n\t}\n\t\n\tg.build();\n\tsort(g.bridge.begin(), g.bridge.end());\n\tfor (pair<int, int> e : g.bridge) {\n\t\tcout << e.first << ' ' << e.second << '\\n';\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from = -1, int to = -1, T cost = 1) : from(from), to(to), cost(cost) {}\n\n    bool operator<(const Edge<T>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<T>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class T = int>\nclass Graph {\npublic:\n    explicit Graph(int N = 0) : size(N) { path.resize(size); }\n    void span(int u, int v, T cost = 1) { path[u].push_back(Edge<T>(u, v, cost)); }\n    std::vector<Edge<T>> operator[](int v) const { return path[v]; }\n\n    int size;\n    std::vector<std::vector<Edge<T>>> path;\n};\n\ntemplate <class T = int>\nclass Lowlink {\npublic:\n    Graph<T> graph;\n    int cur;\n    std::vector<int> order, low;\n    std::vector<int> artics;\n    std::vector<Edge<T>> bridges;\n\n    void dfs(int v, int r) {\n        order[v] = low[v] = cur++;\n        int deg = 0;\n        bool is_artic = false;\n\n        for (auto e : graph[v]) {\n            if (order[e.to] < 0) {\n                ++deg;\n                dfs(e.to, e.from);\n                low[e.from] = std::min(low[e.from], low[e.to]);\n\n                if (order[e.from] <= low[e.to]) is_artic = true;\n                if (order[e.from] < low[e.to]) bridges.push_back(e);\n            } else if (e.to != r) {\n                // eは後退辺 1回だけ遡る\n                low[e.from] = std::min(low[e.from], order[e.to]);\n            }\n        }\n\n        if (r < 0) is_artic = (deg > 1);\n        if (is_artic) artics.push_back(v);\n    }\n\n    explicit Lowlink(const Graph<T> graph)\n        : graph(graph), order(graph.size, -1), low(graph.size, graph.size) {\n        cur = 0;\n        for (int v = 0; v < graph.size; ++v) {\n            if (order[v] < 0) dfs(v, -1);\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n    Graph<> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        graph.span(u, v);\n        graph.span(v, u);\n    }\n\n    Lowlink<> lowlink(graph);\n    std::vector<std::pair<int, int>> ans;\n    for (auto e : lowlink.bridges) {\n        if (e.from > e.to) std::swap(e.from, e.to);\n        ans.emplace_back(e.from, e.to);\n    }\n\n    std::sort(ans.begin(), ans.end());\n    for (auto p : ans) {\n        std::cout << p.first << \" \" << p.second << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n//#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nusing Edges = std::vector<std::vector<int>>;\n\nstruct Memo {\n    int cnt;\n    int parent;\n    int low;\n};\n\nint dfs(int i, const Edges& edges, std::vector<Memo>& memo, int& cnt) {\n    memo[i].cnt = cnt++;\n    int ans = memo[i].cnt;\n    for(auto v: edges[i]) {\n        if(memo[v].cnt < 0) {\n            memo[v].parent = i;\n            ans = std::min(ans, dfs(v, edges, memo, cnt));\n        } else {\n            if(v != memo[i].parent) ans = std::min(ans, memo[v].cnt);\n        }\n    }\n    memo[i].low = ans;\n    return ans;\n}\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    Edges edges(V, std::vector<int>());\n    while(E--) {\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n        edges[t].push_back(s);\n    }\n\n    std::vector<Memo> memo(V, Memo{-1, -1, -1});\n    int cnt = 0;\n    dfs(0, edges, memo, cnt);\n\n    std::vector<std::pair<int, int>> ans;\n    ans.reserve(V);\n    for(int i = 0; i < V; ++i) {\n        if(0 <= memo[i].parent && memo[memo[i].parent].low < memo[i].low) {\n            if(i < memo[i].parent) ans.push_back(std::make_pair(i, memo[i].parent));\n            else ans.push_back(std::make_pair(memo[i].parent, i));\n        }\n    }\n\n    std::sort(begin(ans), end(ans), [](auto x, auto y){return x.first == y.first ? x.second < y.second : x.first < y.first;});\n\n    for(auto val: ans) {\n        std::cout << val.first << \" \" << val.second << \"\\n\";\n    }\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[x].pb(x+1);G2[x+1].pb(x);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));\n\t\t\t}\n\t\t\tchmax(mx, build(G[p][i], x));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G = low.G2;\n\trep(i,size){\n\t\trep(j,G[i].size()){\n\t\t\tif(i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\t//printf(\"%lld\\n\", size);\n\tsort(all(ans));\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100010\n#define INF 1e9\ntypedef vector<int> Vec;\ntypedef pair<int,int> pii;\n\nint low[MAX_V],ord[MAX_V];\nint V,E;\nVec G[MAX_V];\nvector<pii> bridge;\n\nvoid dfs(int v,int prev,int &k){\n    ord[v] = low[v] = k++;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(to == prev) continue;\n        if(ord[to] == -1){\n            dfs(to, v, k);\n            low[v] = min(low[v], low[to]);\n            if(ord[v] < low[to]){\n                int a = min(v, to),b = max(v, to);\n                bridge.push_back(pii(a,b));\n            }\n        }\n        low[v] = min(low[v], ord[to]);\n    }\n}\n\nvoid init(){\n    bridge.clear();\n    for(int i = 0 ; i < V ; i++){\n        G[i].clear();\n        ord[i] = -1; low[i] = INF;\n    }\n}\n\nint main(){\n    int s,t;\n    cin >> V >> E; init();\n    for(int i = 0 ; i < E ; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    int k = 0;\n    for(int i = 0 ; i < V ; i++){\n        if(ord[i] == -1){\n            dfs(i, -1, k);\n        }\n    }\n    sort(bridge.begin(),bridge.end());\n    for(int i = 0 ; i < (int)bridge.size() ; i++){\n        cout << bridge[i].first << \" \" << bridge[i].second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\n//Articulation Points(AOJ)\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=jp\n//about 1hr\n//問題を見ただけでは全く解法がわからなかったので下記サイトを参照した。\n//http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad09/ad09-13.pdf\n//https://kagamiz.hatenablog.com/entry/2013/10/05/005213\n\nvvin edge(100020);\nvpii bridge;\nvin articulation;\nvin order(100020),low(100020);\nvbo visit(100020,false);\n\nvoid dfs(int v,int p,int &res){\n    visit[v]=true;\n    order[v]=res;\n    res++;\n    low[v]=order[v];\n    bool isArticulation=false;\n    int cnt=0;\n    for(auto e:edge[v]){\n        if(!visit[e]){\n            cnt++;\n            dfs(e,v,res);\n            low[v]=min(low[v],low[e]);\n            if(p!=-1&&order[v]<=low[e])isArticulation=true;\n            if(order[v]<low[e])bridge.push_back(mp(min(v,e),max(v,e)));\n        }\n        else if(e!=p)low[v]=min(low[v],order[e]);\n    }\n    if(p==-1&&cnt>1)isArticulation=true;\n    if(isArticulation)articulation.push_back(v);\n}\n\nint main(){\n    int v,e;cin>>v>>e;\n    int s,t;//1-indexならそれぞれ-1する. そして出力で+1\n    rep(i,e){\n        cin>>s>>t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n    int res=0;\n    rep(i,v)if(!visit[i])dfs(i,-1,res);\n    //sort(all(articulation));\n    sort(all(bridge));\n    //rep(i,articulation.size())cout<<articulation[i]<<endl;\n    rep(i,bridge.size())cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// ord := rootを0とした時、DFSを行った時の順序番号\n// lowlink := 頂点vからDFS木の葉方向の辺を0回以上、後退辺を0回以上1回以下通っていける頂点のordの最小値\n\nvector<int> G[100010];\nvector<pair<int, int>> bridge;\nvector<int> Articulation;\nint ord[100010], lowlink[100010];\nbool visited[100010];\nvoid dfs(int v, int p, int &k)\n{\n  visited[v] = true;\n\n  ord[v] = k++;\n  lowlink[v] = ord[v];\n\n  bool isArticulation = false;\n  int ct = 0;\n\n  for (int i = 0; i < G[v].size(); i++)\n  {\n    if (!visited[G[v][i]])\n    {\n      ct++;\n      dfs(G[v][i], v, k);\n      lowlink[v] = min(lowlink[v], lowlink[G[v][i]]);\n\n      if (~p && ord[v] <= lowlink[G[v][i]])\n        isArticulation = true;\n\n      if (ord[v] < lowlink[G[v][i]])\n        bridge.push_back(make_pair(min(v, G[v][i]), max(v, G[v][i])));\n    }\n    else if (G[v][i] != p)\n    {\n      lowlink[v] = min(lowlink[v], ord[G[v][i]]);\n    }\n  }\n\n  //根の場合子が一つなら関節点ではなく、そうでなければ関節点\n  if (p == -1 && ct > 1)\n    isArticulation = true;\n\n  if (isArticulation)\n    Articulation.push_back(v);\n}\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < m; i++)\n  {\n    int x, y;\n    cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  int k = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (!visited[i])\n      dfs(i, -1, k);\n  }\n\n  sort(bridge.begin(), bridge.end());\n  for (int i = 0; i < bridge.size(); i++)\n  {\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n  }\n  return 0;\n}\n\n// Varify\n// 関節点の列挙: https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_A\n// 橋の列挙: https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_B\n// 参考\n// npca2014年部誌 競技プログラミングで使えるグラフ理論の基本\n// http://kagamiz.hatenablog.com/entry/2013/10/05/005213\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 10000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  if (ord[s] > ord[t]) swap(s, t);\n  return ord[s] < lowlink[t];\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    edges.push_back(make_pair(s, t));\n  }\n  dfs(0, -1);\n  sort(edges.begin(), edges.end());\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        cin>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 10000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  bool ok = false;\n  for (int i = 0; i < graph[s].size(); i++) {\n    if (graph[s][i] == t) {\n      ok = true;\n      break;\n    }\n  }\n  if (!ok) return false;\n  if (ord[s] > ord[t]) swap(s, t);\n  return ord[s] < lowlink[t];\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    edges.push_back(make_pair(s, t));\n  }\n  dfs(0, -1);\n  sort(edges.begin(), edges.end());\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool usedV[MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v,int p){\t//make ord and lowlink\n\tusedV[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!usedV[to]){\n\t\t\tdfs(to,v);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(usedV[to]&&to!=p){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0,-1);\n\t\n\trep(i,e){\n\t\tif(ord[edges[i].first]<lowlink[edges[i].second])cout<<edges[i].first<<\" \"<<edges[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nstruct Graph {\n    Graph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n    const int V;\n};\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const Graph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            if (ord[i] == -1) {\n                bridge_dfs(g_, i);\n            }\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const\n    {\n        return bridge;\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    const vector<pair<int, int>> getBridge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? (ord[i] < low[j]) : (ord[j] < low[i]);\n    }\n\nprivate:\n    void bridge_dfs(const Graph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const int to : g_.edge[s]) {\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n                if (isBridge(s, to)) {\n                    bridge.push_back(make_pair(s, to));\n                }\n            }\n        }\n    }\n\n    void comp_dfs(const Graph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const int to : g_.edge[s]) {\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n\n    int num;\n    int comp_num;\n    const int size;\n    vector<pair<int, int>> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) {\n            swap(s, t);\n        }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    for (int i = 0; i < E; i++) {\n        const int u = edge[i].first;\n        const int v = edge[i].second;\n    }\n    const vector<P> b = bic.getBridge();\n    sort(b.begin(), b.end());\n    for (const auto& p : b) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int>P;\nint n,m,s,t,low[N],used[N],depth[N];\nvector<int> G[N];\nset<P>ans;\nvoid dfs(int x,int d,int prev){\n  depth[x]=d;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(nx==prev)continue;\n    if(!used[nx]){\n      used[nx]=true;\n      dfs(nx,d+1,x);\n      if(!low[nx])\n      ans.insert(P(min(x,nx),max(x,nx)));\n      low[x]+=low[nx];\n    }\n    else if(d>depth[nx])low[nx]--,low[x]++;\n  }\n}\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  used[0]=1;\n  dfs(0,0,0);\n  set<P>::iterator it=ans.begin();\n  while(it!=ans.end()){\n    cout<<(*it).first<<' '<<(*it).second<<endl;\n    it++;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Edge{\n    int from,to;\n};\nusing Graph=vector<vector<Edge>>;\nnamespace ProconLib{\n    \n    //no multiple Edges\n    //undirected edges graph\n    template<typename edge_t,typename graph_t>\n    vector<edge_t> bridgeDetection(graph_t &g){\n        int n=g.size();\n        vector<int> pre(n,-1),low(n,-1);\n        int k=0;\n        vector<edge_t> res;\n        function<int(int,int)> dfs=[&](int v,int pv){\n            pre[v]=k++;\n            low[v]=pre[v];\n            for(auto &e:g[v]){\n                int to=e.to;\n                if(to==pv) continue;\n                if(pre[to]==-1){\n                    low[v]=min(low[v],dfs(to,v));\n                    if(low[to]==pre[to]){\n                        res.push_back(e);\n                    }\n                }\n                else{\n                    low[v]=min(low[v],low[to]);\n                }\n            }\n            return low[v];\n        };\n        for(int i=0;i<n;i++){\n            if(pre[i]==-1){\n                dfs(i,-1);\n            }\n        }\n        return res;\n    }\n}\n\n//verify\nusing namespace ProconLib;\nusing Graph=vector<vector<Edge>>;\nint main(){\n    int v,e;\n    cin>>v>>e;\n    Graph g(v);\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(Edge{s,t});\n        g[t].push_back(Edge{t,s});\n    }\n    vector<Edge> res=bridgeDetection<Edge>(g);\n    for(auto &e:res){\n        if(e.from>e.to) swap(e.from,e.to);\n    }\n    sort(res.begin(),res.end(),[](Edge lhs,Edge rhs){return make_pair(lhs.from,lhs.to)<make_pair(rhs.from,rhs.to);});\n    for(auto &e:res){\n        cout<<min(e.from,e.to)<<\" \"<<max(e.from,e.to)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\n\nconst int mx = 100005;\n\nint dtime = 0;\nint n, m, par[mx], low[mx], start[mx];\nvector<int> adj[mx];\nbool vis[mx];\nvector<pair<int, int>> bdg;\n\nvoid dfs(int n, int p = -1) {\n  vis[n] = true;\n  par[n] = p;\n  start[n] = dtime++;\n  low[n] = start[n];\n  \n  for (int h : adj[n]) {\n    if (!vis[h]) {\n      dfs(h, n);\n      // printf(\"Low[%d] = min(%d, %d) = %d\\n\", n, low[n], low[h], min(low[n], low[h]));\n      low[n] = min(low[h], low[n]);\n      if (low[h] > low[n]) {\n\tbdg.push_back({n, h});\n      }\n    } else if (h != p) {\n      low[n] = min(low[n], start[h]);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    adj[u].pb(v); adj[v].pb(u);\n  }\n  dfs(0);\n  sort(bdg.begin(), bdg.end());\n  for (auto p : bdg) cout << p.first << \" \" << p.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define ff first\n#define ss second\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=100005;\n\nint n,m,tot;\nint vis[N],low[N];\nvector<int>G[N];\nvector<pii>ans;\n\nvoid dfs(int u,int p) {\n    vis[u]=low[u]=++tot;\n    for (int v:G[u]) {\n        if (v==p) continue;\n        if (!vis[v]) {\n            dfs(v,u);\n            low[u]=min(low[u],low[v]);\n            if (low[v]>vis[u]) ans.pb({min(u,v),max(u,v)});\n        }\n        low[u]=min(low[u],low[v]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n    cin>>n>>m;\n    while (m--) {\n        int u,v; cin>>u>>v,\n        G[u].pb(v),\n        G[v].pb(u);\n    }\n    for (int i=0;i<n;++i) if (!vis[i]) dfs(i,-1);\n    sort(ans.begin(),ans.end());\n    for (auto p:ans) cout<<p.ff<<' '<<p.ss<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n    int s;\n    int t;\n    bool operator < (const Edge& tgt) const {\n\tif( s == tgt.s )\n\t    return t < tgt.t;\n\treturn s < tgt.s;\n    }\n};\n\n\n\nint Bridges_dfs(const vector<vector<Edge>>& g, vector<int>& order,\n\t\tvector<Edge>& ans, int u, int& cnt_v, Edge pre) {\n\n    if( order[u] != -1 ) { //?¨????????????¨?????????\n\treturn order[u];\n    }\n    // ??????????¨???????\n    order[u] = cnt_v; cnt_v++;\n    // ??£??\\???????????????\n    int min_v = order[u];\n    for(auto& e : g[u]) {\n\tif( e.t == pre.s and e.s == pre.t ) continue;\n\tmin_v = min(Bridges_dfs(g, order, ans, e.t, cnt_v, e), min_v);\n    }\n    if( min_v == order[u] and u != 0 ) {\n\tans.push_back(pre);\n    }\n}\n\nvector<Edge> Bridges(const vector<vector<Edge>>& g) {\n    vector<Edge> ans;\n    const int V = g.size();\n    vector<int> order(V,-1);\n    \n    // 0??????DFS\n    int cnt_v = 0;\n    Edge tmp{-1,-1};\n    Bridges_dfs(g, order, ans, 0, cnt_v, tmp);\n    return ans;\n}\n\nint main () {\n    int V,E;\n    cin >> V >> E;\n    vector<vector<Edge>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t; \n\tg[s].push_back(Edge{s,t});\n\tg[t].push_back(Edge{t,s});\n    }\n    vector<Edge> ans = Bridges(g);\n    sort(ans.begin(), ans.end());\n    for(auto& e : ans) {\n\tcout << e.s << \" \"<< e.t << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph =  vector< vector<Edge> >;\n\nvoid add_edge(Graph& graph, int u, int v, int cost = 0){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvoid lowlink(int u, int p, int& num, const Graph& G, VI& ord, VI& low,\n\t\t\t VI& art, vector<pair<int,int>>& brd){\n  ord[u] = low[u] = num++;\n  int chd_num = 0, chd_low_mx = -1;\n\n  for(unsigned int i=0;i<G[u].size();++i){\n\tauto& e =  G[u][i];\n\tint to = e.to;\n\tif(to == p) continue;\n\tif(ord[to] < 0){\n\t  lowlink(to, u, num, G, ord, low, art, brd);\n\t  low[u] = min(low[u], low[to]);\n\t  if(ord[u] < low[to]){\n\t\tbrd.push_back(MP(u, i));\n\t  }\n\t  ++chd_num;\n\t  chd_low_mx = max(chd_low_mx, low[to]);\n\t}\n\telse{\n\t  low[u] = min(low[u], ord[to]);\n\t}\n  }\n\n  if(p == -1){\n\tif(chd_num > 1)\n\t  art.push_back(u);\n  }\n  else{\n\tif(ord[u] <= chd_low_mx)\n\t  art.push_back(u);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  REP(i,E){\n\tint u, v;\n\tcin >> u >> v;\n\tadd_edge(G, u, v);\n  }\n\n  int num = 0;\n  VI ord(V, -1);\n  VI low(V, -1);\n  vector<PII> brd;\n  VI art;\n  lowlink(0, -1, num, G, ord, low, art, brd);\n\n  vector<PII> ans;\n  for(auto& p: brd){\n\tint u = p.FF;\n\tint v = G[u][p.SS].to;\n\tif(u > v) swap(u, v);\n\tans.EB(u, v);\n  }\n  SORT(ans);\n  for(auto e: ans) cout << e << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        cin>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tbool operator<(const struct Edge &arg) const{\n\t\tif(s != arg.s){\n\t\t\treturn s < arg.s;\n\t\t}else{\n\t\t\treturn t < arg.t;\n\t\t}\n\t}\n\tint s,t;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_edge_id){\n\t\tto = arg_to;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n};\n\nint V,E,number;\nint order[100000],lowlink[100000];\nbool visited[100000];\nEdge edge[100000];\nvector<Info> G[100000];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tnext_node = G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&edge[i].s,&edge[i].t);\n\t\tG[edge[i].s].push_back(Info(edge[i].t,i));\n\t\tG[edge[i].t].push_back(Info(edge[i].s,i));\n\t}\n\n\tsort(edge,edge+E);\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\n\trecursive(0);\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tfrom = edge[i].s;\n\t\tto = edge[i].t;\n\n\t\tif(order[edge[i].s] > order[edge[i].t]){\n\t\t\tswap(from,to);\n\t\t}\n\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"%d %d\\n\",edge[i].s,edge[i].t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ll INF = 1e15;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\nnamespace SOLVE {\n\tvector<VI> edges;\n\tvector<VI> ans;\n\tVI lowlink;\n\tVI visited;\n\tVI firstvisit;\n\tint time = 0;\n\tint children = 0;\n\n\tvoid dfs(int at, int previous) {\n\t\tfirstvisit[at] = time;\n\t\tlowlink[at] = time;\n\t\ttime++;\n\n\t\tvisited[at] = 1;\n\t\tif (previous == 0) {\n\t\t\tchildren++;\n\t\t}\n\n\n\t\tfor (int to : edges[at]) {\n\t\t\tif (!visited[to]) {\n\t\t\t\tdfs(to, at);\n\t\t\t\tlowlink[at] = min(lowlink[at], lowlink[to]);\n\t\t\t\t\n\t\t\t\tif (lowlink[to] > firstvisit[at]) {\n\t\t\t\t\tans[min(at, to)].push_back(max(at, to));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (to != previous) {\n\t\t\t\t\tlowlink[at] = min(lowlink[at], firstvisit[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid main() {\n\t\tint n, m, a, b;\n\t\tcin >> n >> m;\n\t\tans.resize(n);\n\t\tedges.resize(n);\n\t\tREP(i, 0, m) {\n\t\t\tcin >> a >> b;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tfirstvisit.resize(n);\n\t\tlowlink.resize(n);\n\t\tvisited.resize(n);\n\t\tans.resize(n);\n\n\t\tdfs(0, -1);\n\n\t\tREP(i, 0, n) {\n\t\t\tsort(ans[i].begin(), ans[i].end());\n\t\t\tREP(j, 0, sz(ans[i])) {\n\t\t\t\tcout << i << ' ' << ans[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Bridge{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;\n  vector<int> low;\n  int ok;\n\n  Bridge():V(-1),ok(false){};\n  Bridge(int V):V(V),G(V),ord(V),low(V),ok(false){};\n  \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a >=0 && b >= 0 && a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void build(){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    \n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      if(ord[pos] != -1) return low[pos];\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) if(to != pre) low[pos] = min(low[pos], dfs(to, pos));\n      return low[pos];\n    };\n\n    for(int i=0;i<V;i++) low[i] = dfs(i, -1);\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int V,E;\n  cin>>V>>E;\n  \n  Bridge A(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    A.add_edge(a,b);\n  }\n\n  A.build();\n  typedef pair<int,int> P;\n  vector<P> ans;\n  for(int i=0;i<V;i++)\n    for(int j:A.G[i]) if(i < j && A.isBridge(i, j)) ans.push_back(P(i,j));\n  \n  sort(ans.begin(),ans.end());\n  for(auto p:ans) cout<<p.first<<\" \"<<p.second<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nstruct edge {\n\tint from,to;\n\tbool used;\n};\nstd::vector<int> G[100000];\nbool used_v[100000];\nedge es[100000];\nbool used_e[100000];\nbool bridge[100000];\nint ord[100000],lowlink[100000];\nint V,E;\nint k=0;\nvoid dfs(int v);\nbool check_edge(int from,int to);\nvoid set_edge(int from,int to);\nint main(void){\n\tstd::cin>>V>>E;\n\tfor(int i=0;i<E;i++){\n\t\tint from,to;\n\t\tstd::cin>>from>>to;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tes[i].from=from;\n\t\tes[i].to=to;\n\t}\n\tfor(int i=0;i<V;i++){\n\t\tused_v[i]=false;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tused_e[i]=false;\n\t\tbridge[i]=false;\n\t}\n\tdfs(0);\n\tfor(int i=0;i<V;i++){\n\t\tused_v[i]=false;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tif(es[i].from>es[i].to){\n\t\t\tstd::swap(es[i].from,es[i].to);\n\t\t}\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tfor(int j=i;j<E;j++){\n\t\t\tif(es[j].from<es[i].from){\n\t\t\t\tstd::swap(es[i].from,es[j].from);\n\t\t\t\tstd::swap(es[i].to,es[j].to);\t\t\t\t\n\t\t\t}else if(es[j].from==es[i].from){\n\t\t\t\tif(es[j].to<es[i].to){\n\t\t\t\t\tstd::swap(es[i].from,es[j].from);\n\t\t\t\t\tstd::swap(es[i].to,es[j].to);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tstd::cout<<ord[i]<<\" \"<<lowlink[i]<<std::endl;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint parent,child;\n\t\tif(ord[es[i].from]>ord[es[i].to]){\n\t\t\tparent=es[i].to;\n\t\t\tchild=es[i].from;\n\t\t}else {\n\t\t\tparent=es[i].from;\n\t\t\tchild=es[i].to;\n\t\t}\n\t\tif(ord[parent]<lowlink[child]){\n\t\t\tstd::cout<<es[i].from<<\" \"<<es[i].to<<std::endl;\n\t\t}\n//\t\tstd::cout<<es[i].from<<\" \"<<es[i].to<<std::endl;\n\t}\n\treturn 0;\n}\n/*void bridge_dfs(int v){\n\tused_v[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(used_v[G[v][i]]==false){\n\t\t\tset_edge(v,G[v][i]);\n\t\t\tdfs(G[v][i]);\n\t\t\tlowlink[v]=std::min(lowlink[v],lowlink[G[v][i]]);\n\t\t}else if(!check_edge(G[v][i],v)){\n\t\t\tlowlink[v]=std::min(lowlink[v],ord[G[v][i]]);\n\t\t}\n\t}\n}*/\nvoid dfs(int v){\n\tused_v[v]=true;\n\tord[v]=k;\n\tlowlink[v]=k;\n\tk++;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(used_v[G[v][i]]==false){\n\t\t\tset_edge(v,G[v][i]);\n\t\t\tdfs(G[v][i]);\n\t\t\tlowlink[v]=std::min(lowlink[v],lowlink[G[v][i]]);\n\t\t}else if(!check_edge(G[v][i],v)){\n\t\t\tlowlink[v]=std::min(lowlink[v],ord[G[v][i]]);\n\t\t}\n\t}\n}\nvoid set_edge(int from,int to){\n\tfor(int i=0;i<E;i++){\n\t\tif(es[i].from==from){\n\t\t\tif(es[i].to==to){\n\t\t\t\tused_e[i]=true;\n\t\t\t}\n\t\t}else if(es[i].to==from){\n\t\t\tif(es[i].from==to){\n\t\t\t\tused_e[i]=true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool check_edge(int from,int to){\n\tfor(int i=0;i<E;i++){\n\t\tif(es[i].from==from){\n\t\t\tif(es[i].to==to){\n\t\t\t\treturn used_e[i];\n\t\t\t}\n\t\t}else if(es[i].to==from){\n\t\t\tif(es[i].from==to){\n\t\t\t\treturn used_e[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn false;//????????????\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int ord, low;\n};\n\nclass BridgeFind{\npublic:\n  BridgeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  vector<pii> find(){\n    if(v_ord == 0)dfs();\n    return bridge;\n  }\nprivate:\n  void dfs(int v  = 0,\n           int previous = -1){\n    node[v].ord = node[v].low = v_ord++;\n    int to;\n    for (int i = 0; i < g[v].size(); i++) {\n      to = g[v][i];\n      if(previous == to)continue;\n      if(node[to].ord == -1) dfs(to, v);\n      node[v].low = min(node[v].low, node[to].low);\n    }\n    if(node[v].low == node[v].ord and previous != -1)\n      bridge.emplace_back(pii(previous, v));\n  }\n  int v_ord = 0;\n  vector<pii> bridge;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BridgeFind bf(g);\n  vector<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nusing P = pair<int,int>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nclass BECC{\nprivate:\n    int N;\n    vvec<int> G;\n    vec<int> order,inS;\n    stack<int> S,roots;\n    vec<int> cmp;\npublic:\n    vec<P> bridge;\n    vvec<int> bccs;\n    vvec<int> dcmp;\n    BECC(int n,vvec<int> graph){\n        N = n;\n        G = graph;\n        order = inS = cmp = vec<int>(N,0);\n    }\n    void dfs(int cur,int prev,int k){\n        order[cur] = ++k; //訪問順に番号付け\n        S.push(cur); inS[cur] = true;//訪問した頂点の集合に追加\n        roots.push(cur);//各bccの根を管理\n        for(auto to:G[cur]){\n            if(order[to]==0) dfs(to,cur,k);\n            else if(to!=prev && inS[to]){//後退辺なら\n                while(order[roots.top()]>order[to]) roots.pop();//(to,cur]を捨てる\n            }\n        }\n        if(cur==roots.top()){\n            if(prev!=-1) bridge.emplace_back(prev,cur);//根でないなら橋になる\n            vec<int> bcc;\n            while(true){\n                int node = S.top(); S.pop(); inS[node] = false;//nodeを捨てる\n                bcc.emplace_back(node);//nodeをbccに追加\n                cmp[node] = bccs.size();\n                if(node==cur) break;\n            }\n            bccs.emplace_back(bcc);\n            roots.pop();\n        }\n    }\n    void bridge_detection(){\n        int k = 0;\n        for(int i=0;i<N;i++) if(order[i]==0) dfs(i,-1,k);\n    }\n    int find(int n){return cmp[n];}\n    int cmp_size(int n){return bccs[cmp[n]].size();}\n    void decomposition(){\n        int k = 0;\n        for(int i=0;i<N;i++) if(order[i]==0) dfs(i,-1,k);\n        dcmp = vvec<int>(bccs.size()+1);\n        for(auto x:bridge){\n            dcmp[cmp[x.first]].push_back(cmp[x.second]);\n            dcmp[cmp[x.second]].push_back(cmp[x.first]);\n        }\n    }\n};\n\nint N,M;\nint main(){\n    cin >> N >> M;\n    vector<vector<int>> v(N+1);\n    int a,b;\n    for(int i=0;i<M;i++){\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    BECC becc(N,v);\n    becc.bridge_detection();\n    for(auto& x:becc.bridge) if(x.first>x.second) swap(x.first,x.second);\n    sort(becc.bridge.begin(),becc.bridge.end());\n    for(auto& x:becc.bridge) cout << x.first << \" \" << x.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Constraints\n * 1 ≤ |V| ≤ 100,000\n * 0 ≤ |E| ≤ 100,000\n * The graph is connected\n * There are no parallel edges\n * There are no self-loops\n */\n\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\n\n#define MAXM 100010\n#define MAXN 100010\n\nusing namespace std;\n\nstruct {\n  int to, next;\n} E[4 * MAXM];\n\nint LE[MAXN + MAXM];\n\npair<int, int> orig_edges[MAXM];\n\nint main() {\n  fill(LE, LE + MAXN + MAXM, -1);\n  int n, m;\n  cin >> n >> m;\n  for (int src, dst, i = 0; i < m; i++) {\n    cin >> src >> dst;\n    // split each edge with an intermediate node\n    E[4 * i] = {n + i, LE[src]};\n    LE[src] = 4 * i;\n    E[4 * i + 1] = {n + i, LE[dst]};\n    LE[dst] = 4 * i + 1;\n    E[4 * i + 2] = {src, LE[n + i]};\n    LE[n + i] = 4 * i + 2;\n    E[4 * i + 3] = {dst, LE[n + i]};\n    LE[n + i] = 4 * i + 3;\n\n    orig_edges[i] = {src, dst};\n  }\n\n  vector<int> cut_nodes;\n\n  constexpr int big_n = MAXN + MAXM;\n  int low[big_n]{0}, pre[big_n]{0}, parent[big_n]{0};\n  fill(parent, parent + big_n, -1);\n  int clk = 0;\n  struct dfsdata {\n    int id, parent;\n    bool after;\n  };\n  stack<dfsdata> dfs;\n\n  for (int i = 0; i < n + m; ++i) {\n    if (pre[i])\n      continue;\n    dfs.push({i, -1, false});\n    while (!dfs.empty()) {\n      dfsdata d = dfs.top();\n      dfs.pop();\n      if (pre[d.id] && !d.after && d.parent != -1)\n        low[d.parent] = min(low[d.parent], pre[d.id]);\n      if (pre[d.id] && d.after && d.parent != -1)\n        low[d.parent] = min(low[d.parent], low[d.id]);\n      if (!pre[d.id]) {\n        pre[d.id] = ++clk;\n        low[d.id] = pre[d.id];\n        parent[d.id] = d.parent;\n        dfs.push({d.id, d.parent, true});\n        for (int j = LE[d.id]; j != -1; j = E[j].next)\n          dfs.push({E[j].to, d.id, false});\n      }\n    }\n  }\n\n  int n_children[big_n]{0};\n  for (int i = 0; i < n + m; ++i)\n    if (parent[i] != -1)\n      ++n_children[parent[i]];\n\n  for (int i = 0; i < n + m; ++i) {\n    if (parent[i] == -1 && n_children[i] > 1)\n      cut_nodes.push_back(i);\n    if (parent[i] != -1 && parent[parent[i]] != -1 && low[i] >= pre[parent[i]])\n      cut_nodes.push_back(parent[i]);\n  }\n\n  set<pair<int, int>> cut_edges;\n  for (int u : cut_nodes) {\n    if (u >= n) {\n      int src = orig_edges[u - n].first;\n      int dst = orig_edges[u - n].second;\n      cut_edges.insert({min(src, dst), max(src, dst)});\n    }\n  }\n  for (auto p : cut_edges) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <forward_list>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define MAX 100000\n\nint cnt;\nint pre[MAX];\nint low[MAX];\nvector<pair<int,int>> ans;\n\nclass EDGE{\npublic:\n    int v;\n    int w;\n    EDGE(int vin,int win):v(vin),w(win){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    int E;\n    vector<forward_list<int>> adj_list;\n    void addedge(int v,int w);\n    void BridgeR(EDGE e);\n    Graph(int v,int e):V(v),E(e){adj_list.resize(v);}\n};\n\nvoid Graph::addedge(int v,int w){\n    adj_list[v].push_front(w);\n    adj_list[w].push_front(v);\n}\n\nvoid Graph::BridgeR(EDGE e){\n    pre[e.w] = cnt++;\n    low[e.w] = pre[e.w];\n    int t;\n    for(auto n = adj_list[e.w].cbegin();n != adj_list[e.w].cend();++n){\n        t = *n;\n        if(pre[t] == -1){\n            BridgeR(EDGE(e.w,t));\n            if(low[t] < low[e.w]) low[e.w] = low[t];\n            if(low[t] == pre[t]) {\n                if(t > e.w) ans.push_back(make_pair(e.w,t));\n                else ans.push_back(make_pair(t,e.w));\n            }\n        }\n        else if(t != e.v){\n            low[e.w] = min(pre[t],low[e.w]);\n        }\n    }\n}\n\nvoid solution(Graph &G){\n    cnt = 0;\n    for(int i = 0; i < G.V;i++){\n        if(pre[i] == -1){\n            G.BridgeR(EDGE(i,i));\n        }\n    }\n}\n\nint main(){\n    int V,E,s,t;\n    scanf(\"%d %d\",&V,&E);\n    Graph G(V,E);\n    for(int i = 0; i < E;i++){\n        scanf(\"%d %d\",&s,&t);\n        G.addedge(s,t);\n    }\n\n    for(int i = 0;i < V;i++){\n        pre[i] = -1;\n        low[i] = -1;\n    }\n\n    solution(G);\n    sort(ans.begin(),ans.end());\n    for(auto &a:ans){\n        printf(\"%d %d\\n\",a.first,a.second);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nvector<bool> visited;\nvector<int> depth, lowlink, pars;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d){\n    visited[u] = true;\n    pars[u] = p;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    \n    depth.assign(V, -1), lowlink.assign(V, -1);\n    visited.assign(V, false);\n    pars.assign(V, -1);\n    dfs(G, -1, 0, 0);\n    \n    vector<pair<int, int>> ans;\n    vector<vector<int>> tree(V);\n    for(int i=0; i<V; i++){\n        int p = pars[i];\n        if(p != -1 && depth[p]<lowlink[i]){\n            if(p < i)\n                ans.emplace_back(p, i);\n            else\n                ans.emplace_back(i, p);\n        }\n    }\n    sort(ans.begin(), ans.end());\n    \n    for(auto p: ans)\n        cout << p.first << \" \" << p.second;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n// clang-format off\n#pragma GCC optimize \"O3,omit-frame-pointer,inline\"\n#pragma GCC target \"tune=native\"\n#define ARG4(_1, _2, _3, _4, ...) _4\n#define rep(...) ARG4(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define REP(i, a) FOR(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(...) ARG4(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define RREP(i, a) RFOR(i, 0, a)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= (int)(a); --i)\n#define ALL(c) (c).begin(), (c).end()\n#define TEN(n) ((ll)(1e##n))\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define USE1(T) template<typename T>inline\n#define USE2(T, U) template<typename T,typename U>inline\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T>using duo=std::pair<T,T>;\ntemplate<typename T>using vec=std::vector<T>;\nusing ll=long long;\nusing pii=duo<int>;\nUSE2(T,U)bool chmax(T&x,U a){return x<a&&(x=a,1);}\nUSE2(T,U)bool chmin(T&x,U a){return a<x&&(x=a,1);}\nUSE1(T=int)T in(){T x;std::cin>>x;return x;}\nUSE1(T=int)vec<T>in(int n){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>());return v;}\nUSE1(T=int)vec<T>in(int n,T a){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>()+a);return v;}\nUSE1(T)vec<std::pair<T,int>>enume(const vec<T>&x,int s=0){int N=x.size();vec<std::pair<T,int>>v;v.reserve(N);rep(i,N)v.pb(x[i],s+i);return v;}\nUSE1(T)vec<T>ndvec(T v,int n){return vec<T>(n,v);}\nUSE2(T,...Ts)auto ndvec(T v,int n,Ts...ns)->vec<decltype(ndvec(v,ns...))>{return ndvec(ndvec(v,ns...),n);}\nUSE1(T)void pr(T x){std::cout<<x<<'\\n';}\nUSE2(T,...Ts)void pr(T x,Ts...xs){std::cout<<x<<' ';pr(xs...);}\nUSE1(T=int)T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\nUSE1(T=int)void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n// }}}\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(10);\n    std::cerr.precision(10);\n  }\n} iosetup; //}}}\n#include <vector>\nnamespace copr {\ntemplate <typename T>\nstruct Edge {\n  using value_type = T;\n  int from, to;\n  value_type val;\n  Edge(int from, int to, value_type val = 1) : from(from), to(to), val(val) {}\n  bool operator<(const Edge& rhs) const {\n    if (val != rhs.val) return val < rhs.val;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n  bool operator>(const Edge& rhs) const { return rhs < *this; }\n};\ntemplate <typename T>\nusing Edges = std::vector<Edge<T>>;\n} // namespace copr\nnamespace copr {\ntemplate <typename CostType>\nstruct Graph {\n  using value_type = std::vector<Edges<CostType>>;\n  const int V;\n  value_type G;\n  Graph(int V) : V(V), G(V) {}\n  void add_edge(int from, int to, CostType cost, bool undirected = true) {\n    G[from].emplace_back(from, to, cost);\n    if (undirected) G[to].emplace_back(to, from, cost);\n  }\n};\n} // namespace copr\n\n#include <algorithm>\nnamespace copr {\ntemplate <typename GraphType>\nstruct Lowlink {\n  const GraphType& graph;\n  std::vector<int> ord, low, art;\n  Edges<int> bridges;\n  int k = 0;\n\n  Lowlink(const GraphType& graph) : graph(graph), ord(graph.V, -1), low(graph.V), art(graph.V) {\n    for (int u = 0; u < graph.V; ++u) {\n      if (ord[u] >= 0) continue;\n      dfs(u);\n    }\n  }\n  bool is_bridge(int u, int v) const {\n    if (ord[u] > ord[v]) std::swap(u, v);\n    return ord[u] < low[v];\n  }\n  bool is_articulation(int u) { return art[u]; }\n  void dfs(int u, int p = -1) {\n    ord[u] = low[u] = k;\n    ++k;\n    int deg = 0;\n    for (auto&& e : graph.G[u]) {\n      int v = e.to;\n      if (v == p) continue;\n      if (ord[v] >= 0) {\n        low[u] = std::min(low[u], ord[v]);\n      } else {\n        dfs(v, u);\n        deg++;\n        low[u] = std::min(low[u], low[v]);\n        if (p >= 0 && ord[u] <= low[v]) art[u] = 1;\n        if (ord[u] < low[v]) bridges.emplace_back(u, v);\n      }\n    }\n    if (p == -1 && deg > 1) art[u] = 1;\n  }\n};\ntemplate <typename T>\nLowlink<T> lowlink(const T& graph) {\n  return Lowlink<T>(graph);\n}\n} // namespace copr\nusing namespace std;\nconst int inf = 1001001001;\nconst ll infl = 1001001001001001001ll;\nconst int dd[] = {0, 1, 0, -1, 0};\n\nsigned main() { //\n  int V = in(), E = in();\n  copr::Graph<int> G(V);\n  rep(i, E) {\n    int s = in(), t = in();\n    G.add_edge(s, t, 1);\n  }\n  auto bridges = copr::lowlink(G).bridges;\n  for (auto& e : bridges) {\n    if (e.from > e.to) swap(e.from, e.to);\n  }\n  sort(ALL(bridges));\n  for (auto&& e : bridges) {\n    pr(e.from, e.to);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define LOOP(i) while(i--)\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nclass RootedNode{\npublic:\n\tvector<ll> parent;\n\tll depth,dist;\n\tRootedNode():depth(0),dist(0){}\n};\n\nclass RootedTree{\n\tint parent_size;\n\tvector<int> pre,low;\n\tint pre_count{0};\n\n\tvoid DFS(ConnectNodeInfo& connection,ll child,ll parent,ll dep,ll dist){\n\t\tpre[child] = low[child] = pre_count++;\n\n\t\tnode[child].parent[0] = parent;\n\t\tnode[child].depth = dep;\n\t\tnode[child].dist = dist;\n\n\t\tbool isArticulation = false;\n\t\tint ct = 0;\n\n\t\tfor(int i = 0;i < connection[child].size();i++){\n\t\t\tll next_child = connection[child][i].first;\n\t\t\tif(pre[next_child]<0){\n\t\t\t\tct++;\n\t\t\t\tDFS(connection,next_child,child,dep+1,dist+connection[child][i].second);\n\t\t\t\tlow[child] = min(low[next_child],low[child]);\n\t\t\t\tif (~parent && pre[child] <= low[next_child]) isArticulation = true;\n\t\t\t\tif (pre[child]<low[next_child]) bridge.emplace_back(min(child,next_child),max(child,next_child));\n\t\t\t}\n\t\t\telse if(next_child != parent){\n\t\t\t\tlow[child] = min(low[child],pre[next_child]);\n\t\t\t}\n\t\t}\n\n\t\tif(parent==-1 && ct>1) isArticulation = true;\n\t\tif(isArticulation) articulation.push_back(child);\n\t}\npublic:\n\tvector<RootedNode> node;\n\tvector<pair<ll,ll>> bridge;\n\tvector<ll> articulation;\n\n\tRootedTree(ConnectNodeInfo& connection){\n\t\tauto connection_size = connection.size();\n\t\tparent_size = 1;\n\t\twhile((1LL<<parent_size)<connection_size) parent_size++;\n\n\t\tnode.resize(connection_size);\n\t\tpre.resize(connection_size,-1);\n\t\tlow.resize(connection_size);\n\t\tfor(auto& x:node) x.parent.resize(parent_size,-1);\n\t\tDFS(connection,0,-1,0,0);\n\t\tfor(int k=0;k<parent_size-1;k++){\n\t\t\tfor(int v=0,ev=connection_size;v<ev;v++){\n\t\t\t\tif(node[v].parent[k] < 0) node[v].parent[k+1] = -1;\n\t\t\t\telse node[v].parent[k+1] = node[node[v].parent[k]].parent[k];\n\t\t\t}\n\t\t}\n\t}\n\tll FindLCA(ll u,ll v){\n\t\tif(node[u].depth > node[v].depth) swap(u,v);\n\t\tfor(int k=0;k<parent_size;k++){\n\t\t\tif((node[v].depth - node[u].depth) & (1LL<<k)){\n\t\t\t\tv = node[v].parent[k];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return u;\n\t\tfor(int k=parent_size-1;k>=0;k--){\n\t\t\tif(node[u].parent[k] != node[v].parent[k]){\n\t\t\t\tu = node[u].parent[k];\n\t\t\t\tv = node[v].parent[k];\n\t\t\t}\n\t\t}\n\t\treturn node[u].parent[0];\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tint N=in(),M=in();\n\tConnectNodeInfo connect(N);\n\tREP(i,M){\n\t\tint u=in(),v=in();\n\t\tconnect.AddNonDirectionalConnection(u,v,1);\n\t}\n\tRootedTree tree(connect);\n\tsort(ALL(tree.bridge),[](pair<ll,ll>& l,pair<ll,ll>& r){return l.first==r.first ? l.second<r.second : l.first<r.first;});\n\tfor(auto& x:tree.bridge){\n\t\tout(x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nbool mark[MAX_N];\nifstream in(\"in1.txt\");\nofstream out(\"out1.txt\");\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            dp[v]=min(dp[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            dp[v]=min(dp[v],dp[u]);\n        }\n    }\n    if(dp[v]>=depth[v]&&l!=-1)\n        out<<from[l]<<\" \"<<to[l]<<'\\n';\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    in>>n>>m;\n    //fill(dp,dp+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        if(i>=m){\n            dp[i]=INF;\n            continue;\n        }\n        dp[i]=INF;\n        in>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  math2do\n *    created: 12.04.2020 22:47:18\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n \n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n \n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n \n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n \n  undigraph(int _n) : graph<T>(_n) {\n  }\n \n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector <int> bridge(const undigraph <T> &g) {\n  vector <bool> seen(g.n, false);\n  vector <int> low(g.n, 0);\n  vector <int> dis(g.n, 0);\n  vector <int> pv(g.n, -1);\n  int timer = 0;\n  vector <int> ans;\n  function <void(int)> dfs = [&](int u) {\n    seen[u] = true;\n    dis[u] = low[u] = ++timer;\n    for (int id : g.g[u]) {\n      int v = g.edges[id].from ^ g.edges[id].to ^ u;\n      if (!seen[v]) {\n        pv[v] = u;\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n        if (low[v] > dis[u]) {\n          ans.push_back(id);\n        }\n      } else if (v != pv[u]) {\n        low[u] = min(low[u], dis[v]);\n      }\n    }\n  };\n  dfs(0);\n  return ans;\n  // return edge id's of bridges\n} \n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  undigraph <int> g(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    g.add(x, y);\n  }\n\n  vector <int> bri = bridge(g);\n  vector <pair <int, int> > ans;\n  for (int id : bri) {\n    auto &e = g.edges[id];\n    int x = min(e.from, e.to);\n    int y = max(e.from, e.to);\n    ans.emplace_back(x, y);\n  }\n  sort(ans.begin(), ans.end());\n  for (auto &P : ans) {\n    cout << P.first << \" \" << P.second << '\\n';\n  } \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int SIZE = 100013;\n\ntypedef pair<int, int> pii;\n\nbool visited[SIZE];\nint disc[SIZE], low[SIZE], parent[SIZE];\n\nvector<int> G[SIZE];\n\n\nvoid bridges(int u, priority_queue<pii, vector<pii>, greater<pii> > *bridge){\n  static int time = 0;\n  int children = 0;\n  visited[u] = true;\n  disc[u] = low[u] = ++time;\n  for(int i = 0; i < G[u].size(); i++){\n    int v = G[u][i];\n    if(!visited[v]){\n      children++;\n      parent[v] = u;\n      bridges(v, bridge);\n      low[u] = min(low[u], low[v]);\n      if(low[v] > disc[u]) bridge->push({min(u,v),max(u,v)});\n    }\n    else if(v != parent[u])\n      low[u] = min(low[u], disc[v]);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n,m;\n  cin>>n>>m;\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n  }\n  priority_queue<pii, vector<pii>, greater<pii> > bridge;\n  for(int i = 0; i < SIZE; i++)\n    parent[i] = -1;\n  bridges(0, &bridge);\n  while(!bridge.empty()){\n    cout<<bridge.top().first<<\" \"<<bridge.top().second<<\"\\n\";\n    bridge.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class Data> struct Graph;\n\nstruct DefData {\n  struct VData {};\n  struct GData {};\n\n  using Len = int;\n  struct EData {\n    Len len;\n    EData() : len(1) {}\n  };\n  static const Len INF = 0x33433433;\n};\n\ntemplate<class Data=DefData>\nstruct Graph {\n  using VData = typename Data::VData;\n  using EData = typename Data::EData;\n  using GData = typename Data::GData;\n  struct Edge {\n    int to;\n    int rev_idx;\n    bool is_es;\n    EData dat;\n  };\n  using Len = decltype(EData::len);\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  Len INF = Data::INF;\n\n  int n;\n  GData gdat;\n  vector<VData> vdat;\n  vector<Es> es;\n  vector<Es> res;\n  vector<Ls> cost;\n  \n  Graph() {}\n  Graph(int sz) {\n    Init(sz);\n  }\n\n  void Init(int sz) {\n    n = sz;\n    vdat.resize(sz);\n    es.resize(sz);\n    res.resize(sz);\n  }\n\n  void AddEdge(int u, int v, EData d, EData r) {\n    es[u].emplace_back(Edge{v, 0, true, d});\n    res[v].emplace_back(Edge{u, 0, false, r});\n    es[u].back().rev_idx = res[v].size()-1;\n    res[v].back().rev_idx = es[u].size()-1;\n  }\n\n  void AddEdge(int u, int v, EData d=EData()) {\n    AddEdge(u, v, d, d);\n  }\n\n  Edge *GetRevEdge(Edge *e) {\n    int v = e->to;\n    if (e->is_es) return &res[v][e->rev_idx];\n    return &es[v][e->rev_idx];\n  }\n\n  // should be tested\n  template<class Cmp>\n  void EraseMultipleEdge(Cmp cmp, bool really_erase) {\n    auto same = [](const Edge &a, const Edge &b) {\n      return a.to == b.to;\n    };\n\n    vector<Es> new_res(n);\n    for (int v=0; v<n; v++) {\n      auto &ves = es[v];\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n      for (int i=0; i<ves.size(); i++) {\n        auto &e = ves[i];\n        int u = e.to;\n        new_res[u].emplace_back(Edge{v, i, false, GetRevEdge(e)->dat});\n      }\n    }\n    res.swap(new_res);\n  }\n\n  void CreateAdjMat() {\n    cost.clear();\n    cost.resize(n, Ls(n, INF));\n\n    auto cmp = [](const Edge &a, const Edge &b) {\n      if (a.to != b.to) return a.to < b.to;\n      return a.dat.len < b.dat.len;\n    };\n    EraseMultipleEdge(cmp, false);\n\n    for (int i=0; i<n; i++) {\n      int prev = -1;\n      for (auto e : es[i]) {\n        int v = e.to;\n        if (prev > v) break;\n        cost[i][v] = min(cost[i][v], e.dat.len);\n        prev = v;\n      }\n    }\n  }\n\n  void DijkstraV(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    if (cost.empty()) CreateAdjMat();\n\n    vector<bool> used(n, false);\n    for (int i=0; i<n; i++) {\n      int v = -1;\n      for (int u=0; u<n; u++) {\n        if (used[u]) continue;\n        if (v == -1 || d[u] < d[v]) {\n          v = u;\n        }\n      }\n      if (v == -1) return;\n\n      used[v] = true;\n      for (int u=0; u<n; u++) {\n        d[u] = mind(d[u], d[v] + cost[v][u]);\n      }\n    }\n\n    // must not reach here\n    assert(0);\n  }\n\n  void DijkstraE(vector<int> &starts, Ls &d) {\n    using Pair = pair<Len, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.dat.len) {\n          d[u] = d[v] + e.dat.len;\n          q.push(Pair(d[u], u));\n        }\n      }\n    }\n  }\n\n  // return true if the graph has a negative cycle\n  bool SPFA(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n\n    queue<int> q;\n    vector<bool> inq(n);\n    vector<int> cnt(n);\n    for (int s : starts) {\n      inq[s] = true;\n      q.push(s);\n      d[s] = 0;\n    }\n\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      inq[v] = false;\n      cnt[v]++;\n      if (cnt[v] > n) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.to) {\n          d[u] = d[v] + e.to;\n          if (inq[u]) continue;\n          inq[u] = true;\n          q.push(u);\n        }\n      }\n    }\n\n    // do DFS if you need the concrete contents of such cycles\n    for (int i=0; i<n; i++) {\n      if (cnt[i] >= n) return true;\n    }\n\n    return false;\n  }\n\n  void DijkstraV(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraV(ss, d);\n  }\n\n  void DijkstraE(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraE(ss, d);\n  }\n\n  void SPFA(int s, Ls &d) {\n    vector<int> ss(1, s);\n    SPFA(ss, d);\n  }\n\n  // Create \"Shortest Path Graph\", which should be DAG\n  Graph<Data> RestoreShortestPaths(Ls &d) {\n    Graph<Data> ret(n);\n\n    for (int i=0; i<n; i++) {\n      for (auto e : es[i]) {\n        int v = e.to;\n        if (d[v] == d[i] + e.dat.len) {\n          ret.AddEdge(i, e.to, e.dat, GetRevEdge(&e)->dat);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void WarshallFloyd(vector<Ls> &ds) {\n    if (cost.empty()) CreateAdjMat();\n\n    ds.clear();\n    ds.resize(cost);\n    for (int i=0; i<n; i++) {\n      ds[i][i] = min(ds[i][i], 0);\n    }\n\n    for (int k=0; k<n; k++) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n          if (ds[i][j] > ds[i][k] + ds[k][j]) {\n            ds[i][j] = ds[i][k] + ds[k][j];\n          }\n        }\n      }\n    }\n  }\n\n  // Karp's Algorithm O(NM)\n  // should be tested\n  // should be used for SCC\n  double MinimumMeanCycle() {\n    vector<Ls> dp(n+1, Ls(n, INF));\n\n    dp[0][0] = 0;\n    for (int i=1; i<=n; i++) {\n      for (int v=0; v<n; v++) {\n        for (auto e : es[v]) {\n          int u = e.to;\n          dp[i][u] = min(dp[i][u], dp[i-1][v] + e.dat.len);\n        }\n      }\n    }\n\n    double ret = 1.0/0.0;\n    for (int v=0; v<n; v++) {\n      double alpha = (-1.0)/0.0;\n      for (int i=1; i<n; i++) {\n        if (dp[n][v] == INF) continue;\n        if (dp[i][v] == INF) continue;\n        alpha = max(alpha, (dp[n][v]-dp[i][v])/double(n-i));\n      }\n      ret = min(ret, alpha);\n    }\n    return ret;\n  }\n};\n\ntemplate<class Data=DefData>\nstruct DFSForest {\n  using G = Graph<Data>;\n  using Edge = typename G::Edge;\n  using Brid = pair<int, Edge*>;\n\n  int grp;\n  vector<int> ord;\n  vector<int> low;\n  vector<int> belong;\n  vector<int> artic;\n  vector<Brid> bridge;\n\n  DFSForest(G &g, bool is_directed) {\n    int k = 0;\n    int idx = 0;\n    int n = g.n;\n    vector<int> st(n);\n\n    grp = 0;\n    ord.resize(n, -1);\n    low.resize(n);\n    belong.resize(n, -1);\n\n    function<void(int,int,Edge*)> dfs;\n    // to deal with multiple edges, it uses a pointer\n    auto update = [&](int v, Edge *e, bool &is_artic, int &cnt) {\n      int u = e->to;\n      if (ord[u] != -1) {\n        if (belong[u] == -1) low[v] = min(low[v], ord[u]);\n      } else {\n        cnt++;\n        dfs(u, v, e);\n        low[v] = min(low[v], low[u]);\n        if (ord[v] <= low[u]) is_artic = true;\n        if (ord[v] < low[u]) bridge.emplace_back(Brid(v, e));\n      }\n    };\n\n    dfs = [&](int v, int p, Edge *par) {\n      bool is_artic = false;\n      int cnt = 0;\n\n      st[idx++] = v;\n      low[v] = ord[v] = k++;\n\n      for (auto &e : g.es[v]) {\n        if (g.GetRevEdge(&e) == par) continue;\n        update(v, &e, is_artic, cnt);\n      }\n\n      if (!is_directed) {\n        for (auto &e : g.res[v]) {\n          if (g.GetRevEdge(&e) == par) continue;\n          update(v, &e, is_artic, cnt);\n        }\n      }\n\n      if (p == -1) is_artic = (cnt > 1);\n      if (is_artic) artic.emplace_back(v);\n\n      if (low[v] != ord[v]) return;\n      while (1) {\n        int u = st[--idx];\n        belong[u] = grp;\n        if (u == v) break;\n      }\n      grp++;\n    };\n\n    for (int i=0; i<n; i++) {\n      if (ord[i] == -1) dfs(i, -1, NULL);\n    }\n  }\n};\n\n\ntemplate<class Data=DefData>\nstruct SCC : Graph<SCC<Data> > {\n  using VD = typename Data::VData;\n  using ED = typename Data::EData;\n  using GD = typename Data::GData;\n  using G = Graph<Data>;\n\n  struct VData {\n    G g; // the graph consisting of contracted nodes in one component\n    vector<int> cont2orig; // the correspondence of the node index: v on SCCVData::g -> cont2orig[v] on the original graph(G)\n    VData(int n) : g(n) {}\n  };\n\n  struct EData : ED {\n    int s;\n    int t;\n    EData(int a, int b, const ED &dat) : ED(dat), s(a), t(b) {}\n  };\n\n  struct GData {\n    vector<int> orig2cont; // the correspondence of the node index: v on G -> orig2cont[v] on G's SCC::vdat[belong[v]].g\n  };\n\n  DFSForest<Data> df;\n  SCC(G &g) : df(g, true), Graph<SCC<Data> >(df.grp) {\n    int n = g.n;\n\n    auto &gdat = this->gdat;\n    auto &vdat = this->vdat;\n\n    gdat.orig2cont.resize(n);\n    for (int v=0; v<n; v++) {\n      auto &vd = vdat[df.belong[v]];\n      gdat.orig2cont[v] = vd.cont2orig.size();\n      vd.cont2orig.emplace_back(v);\n    }\n\n    for (int i=0; i<df.grp; i++) {\n      auto &vd = vdat[i];\n      vd.g.Init(vd.cont2orig.size());\n    }\n    \n    for (int v=0; v<n; v++) {\n      for (auto &e : g.es[v]) {\n        int u = e.to;\n        ED &rd = g.GetRevEdge(&e)->dat;\n        int bv = df.belong[v];\n        int bu = df.belong[u];\n\n        if (bv == bu) {\n          auto &vd = vdat[bv];\n          auto &dic = gdat.orig2cont;\n          vd.g.AddEdge(dic[v], dic[u], e.dat, rd);\n        } else {\n          AddEdge(bv, bu, Edata(v, u, e.data), EData(u, v, rd));\n        }\n      }\n    }\n  }\n};\n\nint n;\nint m;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Graph<> g(n);\n\n  while (m--) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    g.AddEdge(s, t);\n  }\n\n  DFSForest<> df(g, true);\n  //SCC<> scc(g);\n  auto &bridge = /*scc.*/df.bridge;\n  using A = DFSForest<>::Brid;\n  sort(bridge.begin(), bridge.end(), [&](const A &a, const A &b) {\n      int av = a.first;\n      int au = a.second->to;\n      if (av > au) swap(av, au);\n      int bv = b.first;\n      int bu = b.second->to;\n      if (bv > bu) swap(bv, bu);\n      if (av != bv) return av < bv;\n      return au < bu;\n      });\n\n  for (auto &a : /*scc.*/df.bridge) {\n    int av = a.first;\n    int au = a.second->to;\n    if (av > au) swap(av, au);\n    printf(\"%d %d\\n\", av, au);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  typedef int weight_type;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\ntypedef Edge::weight_type Weight;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Weights;\ntypedef std::vector<int> Path;\n}\ntypedef std::vector<graph::Edges> Graph;\n}\n#endif\n//}}}\n//{{{ bridge.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\nnamespace bridge_internal {\nstruct BridgeImpl {\n  const Graph& G;\n  int k;\n  std::vector<int> ord, low;\n  Edges bridges;\n  BridgeImpl(const Graph& g) : G(g), k(0), ord(g.size(), -1), low(g.size()) {}\n  void dfs(int v, int p = -1) {\n    low[v] = ord[v] = k++;\n    for (const auto& e : G[v]) {\n      int u = e.to;\n      if (u == p) continue;\n      if (ord[u] >= 0) {\n        low[v] = std::min(low[v], ord[u]);\n      } else {\n        dfs(u, v);\n        low[v] = std::min(low[v], low[u]);\n      }\n      if (ord[v] < low[u]) bridges.emplace_back(e);\n    }\n  }\n  Edges get() {\n    dfs(0);\n    return std::move(bridges);\n  }\n};\n}\nEdges bridges(const Graph& g) {\n  return std::move(bridge_internal::BridgeImpl(g).get());\n}\n}\n}\n//}}}\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\nint main() {\n  int V = in(), E = in();\n  orliv::Graph g(V);\n  for (int i = 0; i < E; i++) {\n    int s = in(), t = in();\n    g[s].emplace_back(s, t, 1);\n    g[t].emplace_back(t, s, 1);\n  }\n  auto bridges = orliv::graph::bridges(g);\n  for (auto& e : bridges) {\n    if (e.from > e.to) swap(e.from, e.to);\n  }\n  sort(bridges.begin(), bridges.end());\n  for (auto& e : bridges) {\n    cout << e.from << \" \" << e.to << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    std::cout << brige.size() << std::endl;\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1) dfs(to, current);\n      if(previous == to)continue;\n      node[current].min_order =\n        min(node[current].min_order,\n            node[to].min_order);\n    }\n    if(node[current].min_order == node[current].order and\n       previous != -1){\n      brige.insert(pii(previous, current));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Just GRL_3_A with added search for bridges\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\n#define all(x) x.begin(), x.end()\n#define rep(i,a,b) for(int i = a; i < b; i++)\n\nint V, E;\nvvi conn(100002);\nvi vis(100002);\nvb trail(100002);\nvpii bridges(0);\n\nint dfs_min(int v, int depth, int parent) {\n  if(vis[v] > 0) return vis[v];\n  vis[v] = depth;\n  trail[v] = true;\n\n  int minHit = depth;\n  rep(i,0,(int)conn[v].size()) {\n    if(conn[v][i] != parent && (vis[conn[v][i]] == 0 || trail[conn[v][i]])) {\n      int hit = dfs_min(conn[v][i], depth+1, v);\n      minHit = min(minHit, hit);\n      if(hit > depth)\n\tbridges.push_back(make_pair(min(v,conn[v][i]), max(v,conn[v][i])));\n    }\n  }\n\n  trail[v] = false;\n  return minHit;\n}\n\nint main() {\n  cin >> V;\n  cin >> E;\n  rep(e,0,E) {\n    int s, t;\n    cin >> s;\n    cin >> t;\n    conn[s].push_back(t);\n    conn[t].push_back(s);\n  }\n\n  dfs_min(0, 1, -1);\n  /*if(V > 1) {\n    cut[0] = false;\n    bool remember = cut[1];\n    fill(all(vis), 0);\n    dfs_min(1, 1, -1);\n    cut[1] = remember;\n    }*/\n\n\n  /*rep(v,0,V) {\n    if(!(cut[v] || conn[v].size() == 1)) continue;\n    rep(i,0,(int)conn[v].size())\n      if(v < conn[v][i] && (cut[conn[v][i]] || conn[conn[v][i]].size() == 1))\n\tbridges.push_back(to_string(v)+\" \"+to_string(conn[v][i]));\n\t}*/\n  sort(all(bridges));\n  rep(b,0,(int)bridges.size())\n    cout << bridges[b].first << ' ' << bridges[b].second << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// グラフ\n\n// 隣接リスト\n\n// cycle を検出 ⇔ 強連結成分の個数をチェック\n\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cfloat>\n#include<tuple>\n#include<set>\n#include<stack>\n\nconst double INF = DBL_MAX / 3.0;\n\n// Edge\nclass Edge {\npublic:\n    Edge() {}\n    Edge(const int f, const int t, const double w) :from_(f), to_(t), weight_(w) {}\n    int from() const {return from_;}\n    int to() const {return to_;}\n    double weight() const {return weight_;}\n    bool operator<(const Edge& e) const {\n        if(from() != e.from()) return from() < e.from();\n        if(to() != e.to()) return to() < e.to();\n        return weight() < e.weight();\n    }\nprivate:\n    int from_, to_;\n    double weight_;\n};\n\n// Graph\nclass Graph {\npublic:\n    explicit Graph(int s) :size_(s) {edge_.resize(s);}\n\n    int size() const {return size_;}\n    const std::vector<Edge>& edge(const int v) const {return edge_[v];}\n\n    void add(const Edge& e);\n    void add(const int from, const int to, const double weight);\n    double Dijkstra(const int start, const int goal) const;\n    double BellmanFord(const int start, const int goal) const;\n    bool cut_vertex(const int v, const std::set<int>& visited) const;\n    std::vector<std::vector<int>> Kosaraju() const;\nprivate:\n    void cut_vertex_reachability(const int from, std::set<int>& visited) const;\n    void Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const;\n    std::vector<int> Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const;\n\n    int size_;\n    std::vector<std::vector<Edge>> edge_;\n};\n\n// implements\nvoid Graph::add(const Edge& e) {edge_[e.from()].push_back(e);}\n\nvoid Graph::add(const int from, const int to, const double weight) {edge_[from].push_back(Edge(from, to, weight));}\n\ndouble Graph::Dijkstra(const int start, const int goal) const {\n    enum {COST, VERTEX};\n    typedef std::tuple<double, int> Node;\n\n    std::vector<int> visited(size(), 0);\n    std::priority_queue<Node, std::vector<Node>, std::greater<Node>> q;\n    q.push(Node(0, start));\n    while(!q.empty()) {\n        double cost = std::get<COST>(q.top());\n        int from = std::get<VERTEX>(q.top());\n        q.pop();\n        if(from == goal) return cost;\n        if(visited[from]) continue;\n        visited[from] = 1;\n        for(const auto& e: edge(from)) q.push(Node(cost + e.weight(), e.to()));\n    }\n    return INF;\n}\n\ndouble Graph::BellmanFord(const int start, const int goal) const {\n    std::vector<double> distance(size(), INF);\n    distance[start] = 0;\n    for(int step = 0; step <= size(); ++step) {\n        for(int from = 0; from < size(); ++from) {\n            for(const auto& e: edge(from)) {\n                if(distance[from] + e.weight() >= distance[e.to()]) continue;\n                if(step == size()) return INF;\n                distance[e.to()] = distance[from] + e.weight();\n            }\n        }\n    }\n    return distance[goal];\n}\n\nbool Graph::cut_vertex(const int v, const std::set<int>& visited = std::set<int>()) const {\n    std::set<int> dup = visited;\n    for(const auto& e: edge(v)) {\n        if(dup.count(e.to())) continue;\n        cut_vertex_reachability(e.to(), dup);\n        return dup.size() != size();\n    }\n    return dup.size() != size();\n}\nvoid Graph::cut_vertex_reachability(const int from, std::set<int>& visited) const {\n    visited.insert(from);\n    for(const auto& e: edge(from)) if(!visited.count(e.to())) cut_vertex_reachability(e.to(), visited);\n}\n\nstd::vector<std::vector<int>> Graph::Kosaraju() const {\n    std::vector<std::vector<int>> result;\n\n    std::vector<bool> visited(size(), false);\n    std::stack<int> order;\n    for(int v = 0; v < size(); ++v) if(!visited[v]) Kosaraju_dfs_postorder(v, visited, order);\n\n    std::vector<std::vector<Edge>> reverse_edge(size(), std::vector<Edge>());\n    for(int v = 0; v < size(); ++v) for(const auto& e: edge(v)) reverse_edge[e.to()].push_back(Edge(e.to(), e.from(), e.weight()));\n\n    visited = std::vector<bool>(size(), false);\n    while(!order.empty()) {\n        int v = order.top();\n        order.pop();\n        if(visited[v]) continue;\n        result.push_back(Kosaraju_dfs_decompose(reverse_edge, v, visited));\n    }\n    return result;\n}\nvoid Graph::Kosaraju_dfs_postorder(const int from, std::vector<bool>& visited, std::stack<int>& order) const {\n    visited[from] = true;\n    for(const auto& e: edge(from)) if(!visited[e.to()]) Kosaraju_dfs_postorder(e.to(), visited, order);\n    order.push(from);\n}\nstd::vector<int> Graph::Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, const int from, std::vector<bool>& visited) const {\n    std::vector<int> result;\n    result.push_back(from);\n    visited[from] = true;\n    for(const auto& e: reverse_edge[from]) {\n        if(visited[e.to()]) continue;\n        std::vector<int> add = Kosaraju_dfs_decompose(reverse_edge, e.to(), visited);\n        result.insert(result.end(), add.begin(), add.end());\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// 無向木の最遠点対\n//     ある頂点から最も遠い点を u とし, u から最も遠い点を v とすると (u, v) が最遠点対\n// 有向だとダメ && cycle があると死ぬ\nstd::tuple<double, int> diameter_of_unoriented_tree_dfs(const Graph& g, const int previous, const int current) {\n    std::tuple<double, int> result(0.0, current);\n    for(const auto& e: g.edge(current)) {\n        if(e.to() == previous) continue;\n        double w; int v;\n        std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, current, e.to());\n        w += e.weight();\n        if(std::get<0>(result) < w) result = std::make_tuple(w, v);\n    }\n    return result;\n}\ndouble diameter_of_unoriented_tree(const Graph& g) {\n    double w; int v;\n    std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, -1, 0);\n    std::tie(w, v) = diameter_of_unoriented_tree_dfs(g, -1, v);\n    return w;\n}\n\n// 連結グラフの cut vertex の集合を返す\n//     Algorithmics: theory and practice, Gilles Brassard and Paul Bratley\nvoid cut_vertex_dfs(const Graph& g, const int prev, const int current, int& timer, std::vector<int>& prenum, std::vector<int>& parent, std::vector<int>& lowest) {\n    prenum[current] = timer;\n    lowest[current] = timer;\n    parent[current] = prev;\n    for(const auto& e: g.edge(current)) {\n        if(prenum[e.to()] == -1) {\n            cut_vertex_dfs(g, current, e.to(), ++timer, prenum, parent, lowest);\n            lowest[current] = std::min(lowest[current], lowest[e.to()]);\n        } else if(e.to() != prev) {\n            lowest[current] = std::min(lowest[current], prenum[e.to()]);\n        }\n    }\n}\nstd::set<int> cut_vertex(const Graph& g) {\n    std::vector<int> prenum(g.size(), -1);\n    std::vector<int> parent(g.size(), -1);\n    std::vector<int> lowest(g.size(), 1000000000);\n    int timer = 0;\n    cut_vertex_dfs(g, -1, 0, timer, prenum, parent, lowest);\n    std::set<int> result;\n    int count = 0;\n    for(const auto& p: parent) if(p == 0) count++;\n    if(count >= 2) result.insert(0);\n    for(int v = 1; v < g.size(); ++v) {\n        if(parent[v] == 0) continue;\n        if(prenum[parent[v]] <= lowest[v]) result.insert(parent[v]);\n    }\n    return result;\n}\n\n// 無向グラフの bridge の集合を返す\nvoid bridge_dfs(const Graph& g, const int prev, const int current, int& timer, std::vector<int>& prenum, std::vector<int>& parent, std::vector<int>& lowest) {\n    prenum[current] = timer;\n    lowest[current] = timer;\n    parent[current] = prev;\n    for(const auto& e: g.edge(current)) {\n        if(prenum[e.to()] == -1) {\n            cut_vertex_dfs(g, current, e.to(), ++timer, prenum, parent, lowest);\n            lowest[current] = std::min(lowest[current], lowest[e.to()]);\n        } else if(e.to() != prev) {\n            lowest[current] = std::min(lowest[current], prenum[e.to()]);\n        }\n    }\n}\n#include<iostream>\nusing namespace std;\nstd::set<Edge> bridge(const Graph& g) {\n    std::vector<int> prenum(g.size(), -1);\n    std::vector<int> parent(g.size(), -1);\n    std::vector<int> lowest(g.size(), 1000000000);\n    int timer = 0;\n    bridge_dfs(g, -1, 0, timer, prenum, parent, lowest);\n    std::set<Edge> result;\n    for(int v = 0; v < g.size(); ++v) {\n        for(const auto& e: g.edge(v)) {\n//             if(prenum[e.from()] < lowest[e.to()]) result.insert(e);\n            if(prenum[e.from()] < lowest[e.to()]) result.insert(Edge(std::min(e.from(), e.to()), std::max(e.from(), e.to()), e.weight()));\n        }\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for(int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        g.add(s, t, 1);\n        g.add(t, s, 1);\n    }\n    for(const auto& e: bridge(g)) cout << e.from() << \" \" << e.to() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n\ntemplate< typename T >\nstruct LowLink {\n  const WG<T> &g;\n  vector< int > used, ord, low;\n  vector< int > articulation;\n  vector< pair< int, int > > bridge;\n \n  LowLink(const WG<T> &g) : g(g) {}\n \n  int dfs(int idx, int k, int par) {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n    bool is_articulation = false;\n    int cnt = 0;\n    for(auto &e : g[idx]) {\n      if(!used[e.to]) {\n        ++cnt;\n        k = dfs(e.to, k, idx);\n        low[idx] = min(low[idx], low[e.to]);\n        is_articulation |= ~par && low[e.to] >= ord[idx];\n        if(ord[idx] < low[e.to]) bridge.emplace_back(minmax(idx, (int) e.to));\n      } else if(e.to != par) {\n        low[idx] = min(low[idx], ord[e.to]);\n      }\n    }\n    is_articulation |= par == -1 && cnt > 1;\n    if(is_articulation) articulation.push_back(idx);\n    return k;\n  }\n \n  virtual void build() {\n    used.assign(g.size(), 0);\n    ord.assign(g.size(), 0);\n    low.assign(g.size(), 0);\n    int k = 0;\n    for(int i = 0; i < g.size(); i++) {\n      if(!used[i]) k = dfs(i, k, -1);\n    }\n  }\n};\n\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,m;\n  cin>>n>>m;\n  WG<int> es(n);\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    es[a].PB(edge<int>(b,0));\n    es[b].PB(edge<int>(a,0));\n  }\n\n  LowLink<int> lowlink(es);\n  lowlink.build();\n  sort(all(lowlink.bridge));\n  for(P p:lowlink.bridge){\n    cout<<p.F<<' '<<p.S<<endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct lowlink{\n  vector<int> ord,low,used;\n  vector<vector<int>> adj,tree;\n  int root,n;\n  lowlink(){}\n  lowlink(vector<vector<int>> const& a,int r):adj(a),root(r){\n    n = adj.size();\n    ord.resize(n);\n    low.resize(n);\n    used.resize(n);\n    tree.reserve(n);\n    int k=0;\n    dfs(root,-1,k);\n  }\n  void dfs(int cur,int par,int& k){\n    ord[cur] = k++;\n    low[cur] = ord[cur];\n    used[cur] = 1;\n    for(auto nxt:adj[cur]){\n      if(used[nxt]==0){\n        dfs(nxt,cur,k);\n        tree[cur].emplace_back(nxt);\n        low[cur] = min(low[cur],low[nxt]);\n      }\n      else if(ord[nxt]<ord[cur]&&nxt!=par){\n        low[cur] = min(low[cur],ord[nxt]);\n      }\n    }\n  }\n  vector<int> articulation_points(){\n    // 関節点 := 頂点u,子vについて、ord[u] <= low[v] or 根の次数>1\n    vector<int> res;\n    if(tree[root].size()>1)res.emplace_back(root);\n    for(int u=0;u<n;++u){\n      if(u==root)continue;\n      for(auto v:tree[u]){\n        if(ord[u]<=low[v]){\n          res.emplace_back(u);\n          break;\n        }\n      }\n    }\n    return res;\n  }\n  vector<pair<int,int>> bridges(){\n    // 橋 := 辺uvについて、ord[u]<low[v]\n    vector<pair<int,int>> res;\n    for(int u=0;u<n;++u){\n      for(auto v:tree[u]){\n        if(ord[u]<low[v]){\n          res.emplace_back(min(u,v),max(u,v));\n        }\n      }\n    }\n    sort(res.begin(),res.end());\n    return res;\n  }\n  void dump(){\n    cout<<\"idx : \";\n    for(int i=0;i<n;++i)cout<<i<<(i+1<n?\" \":\"\\n\");\n    cout<<\"ord : \";\n    for(int i=0;i<n;++i)cout<<ord[i]<<(i+1<n?\" \":\"\\n\");\n    cout<<\"low : \";\n    for(int i=0;i<n;++i)cout<<low[i]<<(i+1<n?\" \":\"\\n\");\n  }\n};\n\nsigned main(){\n\n  int n,m;\n  cin>>n>>m;\n  vector<vector<int>> adj(n);\n  for(int i=0;i<m;++i){\n    int u,v;cin>>u>>v;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n\n  lowlink g(adj,0);\n  for(auto ans:g.bridges()){\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\nint n, m; // number of nodes, edges\n\nvvi edge;\nvvi g;\nvi prenum;\nvi lowest;\nvi parent;\nint timer;\n\nvoid lowlink_dfs(int u, int prev) {\n  prenum[u] = timer;\n  lowest[u] = timer;\n  timer += 1;\n\n  for (auto v : g[u]) {\n    if (prenum[v] < 0) {\n      parent[v] = u;\n      lowlink_dfs(v, u);\n      lowest[u] = min(lowest[u], lowest[v]);\n    } else if (v != prev) {\n      lowest[u] = min(lowest[u], prenum[v]);\n    }\n  }\n}\n\nvoid lowlink() {\n  prenum.assign(n, -1);\n  lowest.assign(n, 0);\n  parent.assign(n, 0);\n  timer = 0;\n  lowlink_dfs(0, -1);\n}\n\n// call after lowlink()\nset<pii> bridge() {\n  set<pii> ret;\n  FOR(i, 1, n) {\n    if (prenum[parent[i]] < lowest[i]) {\n      int mi = min(parent[i], i);\n      int ma = max(parent[i], i);\n      ret.insert(make_pair(mi, ma));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  edge.assign(m, vi(2, 0));\n  g.resize(n);\n  rep (i, m) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    if (s > t) {\n      swap(s, t);\n    }\n    edge[i][0] = s;\n    edge[i][1] = t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  sort(all(edge));\n  lowlink();\n  auto ans = bridge();\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = ~(1 << 31);\n\n//bridge\nvector< vector< int > > edge;\nvector< int > dfs, lw, pr;\nvector< pair< int, int > > br;\nint v, e, s, t, cnt;\nint root = 0;\n\nint rec(int v){\n\t\n\tdfs[v] = cnt;\n\t++cnt;\n\t\n\tint lmin = dfs[v];\n\t\n\tfor(vector< int >::iterator it = edge[v].begin(); it != edge[v].end(); ++it){\n\t\tif(dfs[*it] == 0){\n\t\t\tpr[*it] = v;\n\t\t\tint l = rec(*it);\n\t\t\t\n\t\t\tlmin = min(lmin, l);\n\t\t\t\n\t\t\tif(l >= dfs[*it]) br.push_back(make_pair< int, int >(v, *it));\n\t\t\t\n\t\t}else if(*it != pr[v]){\n\t\t\tlmin = min(lmin, dfs[*it]);\n\t\t}\n\t}\n\t\n\t\n\tlw[v] = lmin;\n\t\n\treturn lw[v];\n}\n\nvoid swap(int *a, int *b){\n\tif(*a != *b){\n\t\t*a ^= *b;\n\t\t*b ^= *a;\n\t\t*a ^= *b;\n\t}\n}\n\nint main(){\n\t\n\tcin >> v >> e;\n\tedge.resize(v);\n\tdfs.resize(v);\n\tlw.resize(v);\n\tpr.resize(v);\n\tbr.clear();\n\t\n\tfor(int i = 0; i < e; ++i){\n\t\tcin >> s >> t;\n\t\tedge[s].push_back(t);\n\t\tedge[t].push_back(s);\n\t}\n\t\n\tcnt = 1;\n\trec(root);\n\t\n\tfor(vector< pair< int, int > >::iterator it = br.begin(); it != br.end(); ++it){\n\t\tif(it->first >= it->second){\n\t\t\tswap(&(it->first), &(it->second));\n\t\t}\n\t}\n\t\n\tsort(br.begin(), br.end());\n\t\n\tfor(vector< pair< int, int > >::iterator it = br.begin(); it != br.end(); ++it){\n\t\tcout << it->first << \" \" << it->second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int SIZE = 100013;\n\ntypedef pair<int, int> pii;\n\nbool visited[SIZE];\nint disc[SIZE], low[SIZE], parent[SIZE];\n\nvector<int> G[SIZE];\n\n\nvoid bridges(int u, priority_queue<pii, vector<pii>, greater<pii> > *bridge){\n  static int time = 0;\n  int children = 0;\n  visited[u] = true;\n  disc[u] = low[u] = ++time;\n  for(int i = 0; i < G[u].size(); i++){\n    int v = G[u][i];\n    if(!visited[v]){\n      children++;\n      parent[v] = u;\n      bridges(v, bridge);\n      low[u] = min(low[u], low[v]);\n      if(low[v] > disc[u]) bridge->push({u,v});\n    }\n    else if(v != parent[u])\n      low[u] = min(low[u], disc[v]);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n,m;\n  cin>>n>>m;\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n  }\n  priority_queue<pii, vector<pii>, greater<pii> > bridge;\n  for(int i = 0; i < SIZE; i++)\n    parent[i] = -1;\n  bridges(0, &bridge);\n  while(!bridge.empty()){\n    cout<<bridge.top().first<<\" \"<<bridge.top().second<<\"\\n\";\n    bridge.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nstruct TwoEdgeConnectedComponents{\n\tT G;\n\tvector<int> cmp,depth,s;\n\tvector<vector<int>> tecc;\n\tstack<int> vs;\n\tusing pii = pair<int,int>;\n\tvector<pii> bridge;\n\n\tTwoEdgeConnectedComponents(const T &G) : G(G),cmp(G.size()),depth(G.size(),-1),s(G.size()){}\n\n\tvoid dfs(int v,int par,int d){\n\t\tdepth[v] = d;\n\t\tvs.push(v);\n\t\tfor(const auto &e : G[v]){\n\t\t\tint to = (int)e;\n\t\t\tif(depth[to] == -1){\n\t\t\t\tdfs(to,v,d + 1);\n\t\t\t\ts[v] += s[to];\n\t\t\t}else if(to != par && depth[v] > depth[to]) s[to]--,s[v]++;\n\t\t}\n\t\tif(!s[v]){\n\t\t\tif(par != -1) bridge.push_back(minmax(v,par));\n\t\t\ttecc.emplace_back();\n\t\t\twhile(1){\n\t\t\t\tint u = vs.top(); vs.pop();\n\t\t\t\ttecc.back().push_back(u);\n\t\t\t\tcmp[u] = tecc.size() - 1;\n\t\t\t\tif(u == v) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid build(){\n\t\tfor(int i = 0;i < G.size();i++) if(depth[i] == -1) dfs(i,-1,0);\n\t}\n};\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tGraph G(n);\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tTwoEdgeConnectedComponents<Graph> tecc(G);\n\ttecc.build();\n\tsort(tecc.bridge.begin(),tecc.bridge.end());\n\tfor(const auto &e : tecc.bridge) cout << e.first << \" \" << e.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct AP {\n    int n;\n    vector<vector<int>> g;\n    set<int> points;\n    vector<int> parent;\n    vector<int> discTime;\n    vector<int> lowTime;\n    vector<bool> visited;\n    vector<pair<int, int>> bridges;\n    int time = 0;\n    \n    AP(int n): n(n) {\n        g.assign(n, vector<int>());\n        parent.assign(n, -1);\n        discTime.assign(n, 0);\n        lowTime.assign(n, n + 1);\n        visited.assign(n, false);\n    }\n    \n    void addEdge(int from, int to) {\n        g[from].push_back(to);\n        g[to].push_back(from);\n    }\n    \n    int solve() {\n        dfs(0, -1);\n        \n        int son = 0;\n        for (int i = 1; i < n; i++) {\n            int p = parent[i];\n            if (p == 0) {\n                son++;\n            }\n            else if (discTime[p] <= lowTime[i]) {\n                points.insert(p);\n            }\n            //For bridges\n            if (discTime[p] < lowTime[i]) {\n                bridges.push_back(make_pair(min(p, i), max(p, i)));\n            }\n        }\n        if (son > 1) {\n            points.insert(0);\n        }\n//        for (int point: points) {\n//            cout << point << endl;\n//        }\n        return points.size();\n    } \n    \n    void dfs(int u, int p) {\n        discTime[u] = time++;\n        lowTime[u] = discTime[u];\n        visited[u] = true;\n        for (int v : g[u]) {\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v, u);\n                lowTime[u] = min(lowTime[u], lowTime[v]);\n            }\n            else if (v != p) {\n                lowTime[u] = min(lowTime[u], discTime[v]);\n            }\n        }\n    }   \n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    AP ap(n);\n    \n    for (int i = 0; i < m; i++) {\n        int from, to;\n        cin >> from >> to;\n        ap.addEdge(from, to);\n    }\n    \n    int ans = ap.solve();\n    sort(ap.bridges.begin(), ap.bridges.end());\n    for (pair<int, int> p : ap.bridges) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 1000\n#define V_MAX 1000\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n\nclass TSort{\npublic:\n  int V;\n  vector<set<int> > in,out;\n  vector<int> sorted;\n  TSort(){V = -1;}\n  TSort(int V){\n    in.resize(V);\n    out.resize(V);\n    this->V = V;\n  }\n  \n  void add_edge(int from,int to){\n    assert(from < V && to < V);\n    assert(out[from].count(to) == 0);\n    assert(in[to].count(from) == 0);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  void erase_edge(int from,int to){\n    out[from].erase(to);\n    in[to].erase(from);\n  }\n\n  void sort(){\n    sorted.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n\n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      sorted.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in[i].empty()) sorted.clear(); // exist loop\n  }\n};\n\ntypedef pair<int,int> P;\nclass Bridges{\npublic:\n  int V;\n  vector<int> G[V_MAX];\n  int depth[V_MAX];\n  int cnt[V_MAX];\n  int visited[V_MAX];\n  vector<P> ans;\n  \n  Bridges(){V = -1;}\n  Bridges(int V){this->V = V;}\n  \n  void add_edge(int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void erase_edge(int a,int b){\n    for(int i=0;i<(int)G[a].size();i++) if(G[a][i] == b) {G[a].erase(G[a].begin()+i);break;}\n    for(int i=0;i<(int)G[b].size();i++) if(G[b][i] == a) {G[b].erase(G[b].begin()+i);break;}\n  }\n  \n  void dfs(int pos,int prev){\n    visited[pos]=true;\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(to==prev)continue;\n      if(!visited[to]){\n        depth[to]=depth[pos]+1;\n        dfs(to,pos);\n        cnt[pos]+=cnt[to];\n        if(cnt[to]==0)ans.push_back( P( min(pos,to) , max(pos,to) ) );\n      }else if(depth[to]<depth[pos]){\n        cnt[pos]++;\n        cnt[to]--;\n      }\n    }\n  }\n\n  void bridge(){\n    memset(depth,0,sizeof(depth));\n    memset(cnt,0,sizeof(cnt));\n    memset(visited,0,sizeof(visited));\n    ans.clear();\n    dfs(0,-1);\n    sort(ans.begin(),ans.end());\n  }\n\n  bool isBridge(int u,int v){\n    for(P e:ans) if((e.first==u&&e.second==v )|| (e.second==v&&e.first==u)) return 1;\n    return 0;\n  }\n};\n \nset<int> G[N];\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  TSort T(n);\n  Bridges B(n);\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;a--,b--;\n    T.add_edge(a,b);\n    B.add_edge(a,b);\n    assert(G[b].count(a)== 0);\n    G[a].insert(b);\n  }\n  \n  int ans = 0;\n  for(int from=0;from<n;from++)\n    for(int to:G[from]){\n      B.bridge();\n      if(B.isBridge(from,to)) continue;\n      T.erase_edge(from,to);\n      B.erase_edge(from,to);\n\n      T.sort();\n      B.bridge();\n\n      if(T.sorted.size() && (int)B.ans.size()>=2)ans = 1;\n\n      T.add_edge(from,to);\n      B.add_edge(from,to);\n    }\n  cout<<(ans?\"YES\":\"NO\")<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nvector<int> biconnected_component(const graph& G) {\n\tint n = G.size(), idx = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), stk, rts(n), cmp(n);\n\tvector<bool> onS(n);\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk.push_back(v);\n\t\tonS[v] = true;\n\t\trts[t++] = v;\n\t\tfor (int w : G[v]) {\n\t\t\tif (ord[w] == -1) dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[rts[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif (v == rts[t - 1]) {\n\t\t\twhile (true) {\n\t\t\t\tint w = stk.back(); stk.pop_back();\n\t\t\t\tonS[w] = false; cmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; ++u) {\n\t\tif (ord[u] == -1) dfs(u, -1);\n\t}\n\treturn cmp;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tgraph G(n);\n\tvector<int> s(m), t(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> s[i] >> t[i];\n\t\tG[s[i]].push_back(t[i]);\n\t\tG[t[i]].push_back(s[i]);\n\t}\n\tauto bc = biconnected_component(G);\n\tvector<pair<int, int>> res;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (bc[s[i]] != bc[t[i]]) {\n\t\t\tres.emplace_back(s[i], t[i]);\n\t\t}\n\t}\n\tsort(res.begin(), res.end());\n\tfor (auto& p : res) {\n\t\tcout << p.first << ' ' << p.second << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 77777\nvector<int>X[MAX_N];\nint used[MAX_N];\nint N, M, A, B; queue<int>Q;\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> A >> B; X[A].push_back(B);\n\t\tX[B].push_back(A);\n\t}\n\tif (N == 1) { return 0; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint a1 = i, a2 = X[i][j];\n\t\t\tfor (int k = 0; k < N; k++) { used[k] = 0; }\n\t\t\tused[0] = 1; Q.push(0); int cnt = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint to = Q.front(); Q.pop();\n\t\t\t\tfor (int k = 0; k < X[to].size(); k++) {\n\t\t\t\t\tint A1 = to, A2 = X[to][k];\n\t\t\t\t\tif (A1 == a1 && A2 == a2) { continue; }\n\t\t\t\t\tif (A1 == a2 && A2 == a1) { continue; }\n\t\t\t\t\tif (used[X[to][k]] == 0) {\n\t\t\t\t\t\tused[X[to][k]] = 1;\n\t\t\t\t\t\tQ.push(X[to][k]);\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != N && a1 < a2) {\n\t\t\t\tcout << a1 << ' ' << a2 << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector<pair<int, int>> bridge(const vector<vector<int>> &G) {\n  const int N = G.size();\n  vector<bool> vis(N, false);\n  vector<int> parent(N);\n  vector<int> indeg(N, 0);\n  vector<int> imos(N, 0);\n  stack<int> S;\n  S.push(0);\n  parent[0] = -1;\n  while(!S.empty()) {\n    int v = S.top(); S.pop();\n    if(vis[v]) continue;\n    vis[v] = true;\n    for(int u : G[v]) {\n      if(u == parent[v]) continue;\n      if(vis[u]) {\n        imos[v]++;\n        imos[u]--;\n        indeg[u]--;\n      }\n      else {\n        parent[u] = v;\n        indeg[v]++;\n        S.push(u);\n      }\n    }\n  }\n  queue<int> Q;\n  for(int i = 0; i < N; ++i) {\n    if(indeg[i] == 0) Q.push(i);\n  }\n  vector<pair<int, int>> ret;\n  while(!Q.empty()) {\n    int v = Q.front(); Q.pop();\n    if(parent[v] == -1) break;\n    int u = parent[v];\n    if(imos[v] == 0) ret.emplace_back(v, u);\n    imos[u] += imos[v];\n    indeg[u]--;\n    if(indeg[u] == 0) Q.push(u);\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  int V, E; cin >> V >> E;\n  vector<vector<int>> G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t; cin >> s >> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  auto &&ret = bridge(G);\n  for(auto &&item : ret) {\n    if(item.first > item.second) swap(item.first, item.second);\n  }\n  sort(ret.begin(), ret.end());\n  for(auto &&item : ret) {\n    cout << item.first << ' ' << item.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nconst int MAX_V = 100010;\n\nvector<vector<int>> G(MAX_V);\nvector<pair<int, int>> bridge;\nvector<int> articulation;\nint ord[MAX_V], low[MAX_V];\nbool visited[MAX_V];\n\nvoid dfs(int cv, int pv, int &k){\n    visited[cv] = true;\n\n    ord[cv] = k++;\n    low[cv] = ord[cv];\n\n    bool isArticulation = false;\n    int cnt = 0;\n\n    for(int i=0; i<G[cv].size(); i++){\n        int nv = G[cv][i];\n\n        if(!visited[nv]){\n            cnt++;\n            dfs(nv, cv, k);\n            low[cv] = min(low[cv], low[nv]);\n            if(~pv && ord[cv] <= low[nv]) isArticulation = true;\n            if(ord[cv] < low[nv]) bridge.emplace_back(minmax(cv, nv));\n        }\n        else if(nv != pv){\n            low[cv] = min(low[cv], ord[nv]);\n        }\n    }\n\n    if(pv == -1 && 1 < cnt) isArticulation = true;\n    if(isArticulation) articulation.emplace_back(cv);\n}\n\nint main(){\n    int n, m; cin>>n>>m;\n    for(int i=0; i<m; i++){\n        int s, t; cin>>s>>t;\n        G[s].emplace_back(t);\n        G[t].emplace_back(s);\n    }\n\n    int k = 0;\n    for(int i=0; i<n; i++){\n        if(!visited[i]) dfs(i, -1, k);\n    }\n\n    sort(articulation.begin(), articulation.end());\n    sort(bridge.begin(), bridge.end());\n\n    /*\n    for(auto i:articulation){\n        cout << i << endl;\n    }\n    */\n    for(auto i:bridge){\n        cout << i.first << \" \" << i.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\n\nvi graph[vmax],ord,low,scc,par;\nstack<int>s;\n\nvoid add_edge(int f,int t){ graph[f].pb(t);}\nvoid add_both_edges(int f,int t){add_edge(f,t);add_edge(t,f);}\n\nvoid dfs(int v,int p,int &k){\n\tord[v]=k++;\n\tlow[v]=ord[v];\n\tpar[v]=p;\n//\ts.push(v);\n\tfor(auto &i:graph[v]){\n\t\tif(ord[i]==-1){\n\t\t\tdfs(i,v,k);\n\t\t\tlow[v]=min(low[v],low[i]);\n\t\t}else if(i!=p /*scc[i]==-1*/)\n\t\t\tlow[v]=min(low[v],ord[i]);\n\t}\n\t/*if(ord[v]==low[v]){\n\t\twhile(1){\n\t\t\tint u=s.top();s.pop();\n\t\t\tscc[u]=v;\n\t\t\tif(u==v) break;\n\t\t}\n\t}*/\n}\n\nvoid lowlink(int n){\n\tint k=0;\n\tord.assign(n,-1),low.resize(n);\n\tscc.assign(n,-1),par.resize(n);\n\trep(i,n) if(ord[i]==-1) dfs(i,-1,k);\n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\trep(loop,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_both_edges(a,b);\n\t}\n\tlowlink(v);\n\n/*\trep(i,v){\n\t\tcout << \"ord[\" << i << \"]=\" << ord[i]  << endl;\n\t\tcout << \"low[\" << i << \"]=\" << low[i]  << endl;\n\t}\n*/\n\n// Bridge\n\tvector<pii> bridge;\n\trep(i,v){\n\t\tint j=par[i];\n\t\tif(j==-1)\n\t\t\tcontinue;\n\t\tif(ord[i] < low[j] || ord[j] < low[i] ){\n\t\t\tpii ok(i,j);\n\t\t\tbridge.pb(ok);\n\t\t}\n\t}\n\tsort(bridge.begin(),bridge.end());\n\tfor(auto &i:bridge){\n\t\tif(i.second<=i.first) swap(i.first,i.second);\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\n// SCC\n/*\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << (scc[a]==scc[b]) << endl;\n\t}\n*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by Vignesh Manoharan\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<vi> vvi;\n\nconst int INF = 1000000000;\nconst ll LINF = 1e17;\nconst double PI =3.141592653589793238;\n#pragma unused(INF,PI,LINF)\n#define F(i,a,n) for(int i=(a);i<(n);i++)\n\ntemplate<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream &s,vector<T> t){\n    for(int i=0;i<(t).size();i++)s<<t[i]<<((i<(t).size()-1)?\" \":\"\");return s; }\ntemplate<typename T> ostream& operator<<(ostream &s,set<T> t){for(T x:t) s<<x<<\" \";return s; }\ntemplate<typename T> istream& operator>>(istream &s,vector<T> &t){\n    for(int _i=0;_i<t.size();_i++) s>>t[_i];return s; }\n\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nvector<int> low,idx,visited,parent;\nint counter=0;\nvector<vector<int>> graph;\nvector<ii> bridges;\nvoid find_bridges(int u){\n    low[u]=idx[u]=counter++;\n    for(int v:graph[u]){\n        if(!visited[v]){\n            parent[v]=u;\n            visited[v]=1;\n            find_bridges(v);\n            if(low[v]>idx[u])\n                bridges.pb(mp(u,v));\n            low[u]=min(low[u],low[v]);\n        } else if(v!=parent[u])\n            low[u]=min(low[u],idx[v]);\n    }\n}\nint main(int argc, const char * argv[]) {\n#ifdef local_test\n    //    input\n    //    freopen(\"input\",\"w\",stdout);\n    //    cout<<\"1 \\n 100 10 \\n\";\n     freopen(\"input\",\"r\",stdin);\n     freopen(\"output\",\"w\",stdout);\n#endif\n    int n,m;\n    cin>>n>>m;\n    graph = vvi(n,vi());\n    low=vi(n);\n    idx=vi(n);\n    visited=vi(n,0);\n    parent=vi(n,-1);\n    F(i,0,m){\n        int u,v;\n        cin>>u>>v;\n        graph[u].pb(v);\n        graph[v].pb(u);\n    }\n    for(int i=0;i<n;i++) if(!visited[i]) find_bridges(i);\n    sort(all(bridges));\n    for(ii e:bridges){\n        cout<<min(e.first,e.second)<<\" \"<<max(e.first,e.second)<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint V, E;\nstd::vector< int > graph[112345];\n\nconst int INF = (1 << 30);\n\nint dfnum[112345];\n\nstd::vector< std::tuple<int, int> > res;\n\nconst uint32_t FLAG_ROOT = 0x00000001;\ntemplate<uint32_t flags = 0>\nstd::tuple<int, bool> dfs(int prev, int id, int depth) {\n  dfnum[id] = depth;\n  bool isArtPoint = false;\n  int L = dfnum[id];\n  int Nc = 0;\n  std::vector<int> ArtCs;\n  for(int next : graph[id]) {\n    if( next == prev ) continue;\n    if( dfnum[next] != INF ) {\n      L = std::min(L, dfnum[next]);\n      continue;\n    }\n    int Lc;\n    bool isArtC;\n    std::tie(Lc, isArtC) = dfs<>(id, next, depth + 1);\n    L = std::min(L, Lc);\n    if( not ( flags & FLAG_ROOT ) and dfnum[id] <= Lc ) {\n      isArtPoint = true;\n    }\n    if( isArtC ) ArtCs.push_back(next);\n    Nc += 1;\n  }\n  if( ( flags & FLAG_ROOT ) and Nc >= 2 ) {\n    isArtPoint = true;\n  }\n  if( isArtPoint or ((flags & FLAG_ROOT))) {\n    for(int next : ArtCs) {\n      int s = std::min(id, next);\n      int t = std::max(id, next);\n      res.push_back(std::tuple<int, int>(s, t));\n    }\n  }\n  return std::tuple<int, bool>(L, isArtPoint or Nc == 0);  \n}\n\nint main() {\n  for(int& I : dfnum) I = INF;\n  scanf(\"%d %d\", &V, &E);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n  }\n\n  dfs<FLAG_ROOT>(-1, 0, 1);\n\n  std::sort(res.begin(), res.end());\n  for(std::tuple<int, int> I : res) {\n    int s, t;\n    std::tie(s, t) = I;\n    printf(\"%d %d\\n\", s, t);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int,int> ii;\n\nconst int MAXN = 100000;\n\nint N, E, num[MAXN], low[MAXN], cnt = 1;\nbool vis[MAXN];\nvector<int> adjList[MAXN];\nvector<ii> ans;\n \nvoid dfs(int u, int par) {\n    vis[u] = true;\n    low[u] = num[u] = cnt++;\n    for (int i = 0; i < adjList[u].size(); i++) {\n        int v = adjList[u][i];\n\n        if (!vis[v]) {\n            dfs(v, u);\n            if (low[v] > num[u]) {\n                int s = min(v, u);\n                int t = max(v, u);\n                ans.push_back(ii(s,t));\n            }\n            low[u] = min(low[u], low[v]);\n        }\n        else if (v != par) low[u] = min(low[u], num[v]);\n    }\n}\n     \n \nint main() {\n\n    scanf(\"%d%d\",&N,&E);\n    for (int i = 0, u, v; i < E; i++) {\n        scanf(\"%d%d\",&u,&v);\n\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n \n    dfs(0, 0);\n \n    sort(ans.begin(), ans.end());\n    for (int i = 0; i < ans.size(); i++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\nint n, m; // number of nodes, edges\n\nvvi edge;\nvvi g;\nvi prenum;\nvi lowest;\nvi parent;\nint timer;\n\nvoid lowlink_dfs(int u, int prev) {\n  prenum[u] = timer;\n  lowest[u] = timer;\n  timer += 1;\n\n  for (auto v : g[u]) {\n    if (prenum[v] < 0) {\n      parent[v] = u;\n      lowlink_dfs(v, u);\n      lowest[u] = min(lowest[u], lowest[v]);\n    } else if (v != prev) {\n      lowest[u] = min(lowest[u], prenum[v]);\n    }\n  }\n}\n\nvoid lowlink() {\n  prenum.assign(n, -1);\n  lowest.assign(n, 0);\n  parent.assign(n, 0);\n  timer = 0;\n  lowlink_dfs(0, -1);\n}\n\nbool is_bridge(int x, int y) {\n  return (prenum[x] < lowest[y] || prenum[y] < lowest[x]);\n}\n\n// call after lowlink()\nset<pii> bridge() {\n  set<pii> ret;\n  rep (i, m) {\n    int x = edge[i][0];\n    int y = edge[i][1];\n    if (is_bridge(x, y)) {\n      if (x > y) {\n        swap(x, y);\n      }\n      ret.insert(make_pair(x, y));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  edge.assign(m, vi(2, 0));\n  g.resize(n);\n  rep (i, m) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    if (s > t) {\n      swap(s, t);\n    }\n    edge[i][0] = s;\n    edge[i][1] = t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  sort(all(edge));\n  lowlink();\n  auto ans = bridge();\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100000;\n\nvector<int> G[MAX_N];\nvector<pair<int, int> > bridge;\nint ord[MAX_N];\t//?¨??????????\nint low[MAX_N]; //low[u]???u????????????1???????????????????????£?????????????????????????????????ord???????°????\nbool visit[MAX_N]; //?¨?????????????????????????????????°\n\nvoid dfs(int v,int p,int &k) //&??????????????¨??§k???????????§?????? p???v??????\n{\n\tvisit[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!visit[G[v][i]]){\n\t\t\tdfs(G[v][i],v,k);\n\t\t\tlow[v] = min(low[v],low[G[v][i]]);\t//??????????????????low??¨????????????\n\t\t\tif(ord[v] < low[G[v][i]]){\n\t\t\t\tbridge.push_back(make_pair(min(v,G[v][i]), max(v,G[v][i])));\n\t\t\t}\n\t\t}else if(G[v][i] != p){\n\t\t\tlow[v] = min(low[v],ord[G[v][i]]); //???????????§????????£??????????¨????????????¨????????????\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tint k = 0;\n\tfill(visit,visit+n,false);\n\tfor(int i=0;i<n;i++){\n\t\tif(!visit[i]) dfs(i,-1,k);\n\t}\n\tsort(bridge.begin(), bridge.end());\n\tfor(int i=0;i<bridge.size();i++){\n\t\tprintf(\"%d %d\\n\",bridge[i].first,bridge[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\n\nLL h, w, n, m, k, t, s, p, q, last, cnt, ans, sum,dp[100][100], a[2], b[20000];\nstring str, ss;\nbool f[1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nstruct Head { LL head, tail, s[4]; };\nvector<LL>vec[110000];\nvector<vector<Head>>head[110000];\nvector<Pll>v[110000];\nmap<string, LL>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct LowLink {\n\tint n;\n\tvector<vector<int>> G;\n\tvector<pair<int, int> > bridge;\n\tvector<int> articulation;\n\tvector<int> ord, low;\n\tvector<bool> vis;\n\tLowLink(int _n) :n(_n) {\n\t\tG.resize(_n);\n\t\tord.resize(_n);\n\t\tlow.resize(_n);\n\t\tvis.resize(_n);\n\t}\n\tvoid add_Edge(int x, int y) {\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvoid build() {\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!vis[i]) dfs(i, -1, k);\n\t\t}\n\n\t\tsort(bridge.begin(), bridge.end());\n\t\tsort(articulation.begin(), articulation.end());\n\n\t\t\n\t}\n\n\tvoid dfs(int v, int p, int &k)\n\t{\n\t\tvis[v] = true;\n\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\n\t\tbool isArticulation = false;\n\t\tint ct = 0;\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tif (!vis[G[v][i]]) {\n\t\t\t\tct++;\n\t\t\t\tdfs(G[v][i], v, k);\n\t\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\t\tif (~p && ord[v] <= low[G[v][i]]) isArticulation = true;\n\t\t\t\tif (ord[v] < low[G[v][i]]) bridge.push_back(make_pair(min(v, G[v][i]), max(v, G[v][i])));\n\t\t\t}\n\t\t\telse if (G[v][i] != p) {\n\t\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t\t}\n\t\t}\n\t\tif (p == -1 && ct > 1) isArticulation = true;\n\t\tif (isArticulation) articulation.push_back(v);\n\t}\n\tvoid print() {\n\t\tcout << \"関節点の個数\" << endl;\n\t\tcout << articulation.size() <<\"個\"<< endl;\n\t\tfor (int i = 0; i < articulation.size(); i++)\n\t\t\tcout << articulation[i] << endl;\n\t\tcout << \"橋の個数\" << endl;\n\t\tcout << bridge.size() <<\"個\"<< endl;\n\t\tfor (int i = 0; i < bridge.size(); i++)\n\t\t\tcout << bridge[i].first<<\"-\"<<bridge[i].second << endl;\n\t}\n};\nint main() {\n\n\tcin >> n >> m;\n\tLowLink loli(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tloli.add_Edge(x, y);\n\t}\n\tloli.build();\n\tfor (int i = 0; i < loli.bridge.size(); i++)\n\t\tcout << loli.bridge[i].first << \" \" <<loli.bridge[i].second << endl;\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<pair<int, int> > bridge;\nvector<int> graph[100010];\npair<int, int> edge[200010];\nvector<pair<int, int> > treeGraph[200010];\n\nint pre[100010];\nint low[100010];\nint com[100010];\nint n, m;\nint visited_cnt = 0;\n\nint dis_dfs(int idx, int from){\n    pre[idx] = visited_cnt;\n    visited_cnt++;\n    low[idx] = pre[idx];\n\n    for(int i = 0;i < graph[idx].size();i++){\n        int to = graph[idx][i];\n        if(pre[to] == -1){\n            low[idx] = min(low[idx], dis_dfs(to, idx));\n            if(low[to] == pre[to]){\n                //bridge.push_back(make_pair(min(idx, to), max(idx, to)));\n            }\n        }else{\n            if(from != to){\n                low[idx] = min(low[idx], low[to]);\n            }\n        }\n    }\n\n    return low[idx];\n}\n\nvoid disGraph(){\n    memset(pre, -1, sizeof(pre));\n    memset(low, -1, sizeof(low));\n\n    dis_dfs(0, -1);\n\n    for(int i = 0;i < m;i++){\n        int fi = edge[i].first;\n        int se = edge[i].second;\n        if(pre[fi] < low[se] || pre[se] < low[fi]){\n            bridge.push_back(make_pair(min(fi, se), max(se, fi)));\n        }\n    }\n\n}\n\nint main(){\n    cin >> n >> m;\n\n    for(int i = 0;i < m;i++){\n        cin >> edge[i].first >> edge[i].second;\n        //edge[i].first--, edge[i].second--;\n        graph[edge[i].first].push_back(edge[i].second);\n        graph[edge[i].second].push_back(edge[i].first);\n    }\n\n    disGraph();\n\n    sort(bridge.begin(), bridge.end());\n\n    for(int i = 0;i < bridge.size();i++){\n        cout << bridge[i].first << \" \" << bridge[i].second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n\nstruct low_link {\n    int n;\n    std::vector<std::vector<int>> adj;\n    std::vector<int> ord, low;\n    std::vector<int> articulations;\n    std::vector<std::pair<int, int>> bridges;\n    low_link(const std::vector<std::vector<int>> &adj) : n(adj.size()), adj(adj), ord(n), low(n) {\n        std::vector<bool> visited(n);\n        int k = 0;\n        auto dfs = [&](auto &&self, int cur, int par) -> void {\n            visited[cur] = true;\n            ord[cur] = k++;\n            low[cur] = ord[cur];\n            int cnt = 0;\n            bool is_articulation = false;\n            for (int to : adj[cur]) {\n                if (!visited[to]) {\n                    self(self, to, cur);\n                    low[cur] = std::min(low[cur], low[to]);\n                    is_articulation |= ord[cur] <= low[to];\n                    if (ord[cur] < low[to]) { bridges.emplace_back(std::minmax(cur, to)); }\n                } else if (to != par) { low[cur] = std::min(low[cur], ord[to]); }\n            }\n            if (par == -1) { is_articulation = cnt >= 2; }\n            if (is_articulation) { articulations.emplace_back(cur); }\n        };\n        dfs(dfs, 0, -1);\n    }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> adj(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        adj[s].emplace_back(t);\n        adj[t].emplace_back(s);\n    }\n    low_link ll(adj);\n    sort(ll.bridges.begin(), ll.bridges.end());\n    for (auto p:ll.bridges) { cout << p.first << \" \" << p.second << endl; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class VData, class EData, class GData>\nstruct Graph;\n\nstruct DefVData {};\n\nstruct DefEData {\n  int len;\n  DefEData() : len(1) {}\n};\n\ntemplate<class VData=DefVData, class EData=DefEData, class GData=int>\nstruct SCCVData {\n  Graph<VData, EData, GData> g;\n  vector<int> cont2orig; // v on g -> cont2orig[v] on the original graph(G)\n  SCCVData(int n) : g(n) {}\n};\n\n// the actual edge(before contracted) is s -> t\nstruct SCCEData {\n  int len;\n  int s;\n  int t;\n  SCCEData() : len(1) {}\n  SCCEData(int a, int b) : len(1), s(a), t(b) {}\n};\n\nstruct SCCGData {\n  vector<int> orig2cont; // v on G -> orig2cont[v] on G.SCC.vdat[belong[v]].g\n};\n\ntemplate<class VData=DefVData, class EData=DefEData, class GData=int>\nstruct Graph {\n  struct Edge {\n    int to;\n    int rev_idx;\n    EData dat;\n  };\n  using Len = decltype(EData::len);\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  using Brid = pair<int, int>;\n  Len INF;\n\n  int n;\n  int grp; // the number of SCC\n  GData gdat;\n  vector<VData> vdat;\n  vector<Es> es;\n  vector<Es> res;\n  vector<Ls> cost;\n  vector<int> ord;\n  vector<int> low;\n  vector<int> belong;\n  vector<int> artic;\n  vector<Brid> bridge;\n  \n  Graph() {}\n  Graph(int sz, Len inf) {\n    Init(sz, inf);\n  }\n\n  void Init(int sz, Len inf) {\n    INF = inf;\n    n = sz;\n    vdat.resize(sz);\n    es.resize(sz);\n    res.resize(sz);\n  }\n\n  void AddEdge(int u, int v, EData d, EData r) {\n    es[u].emplace_back(Edge{v, 0, d});\n    res[v].emplace_back(Edge{u, 0, r});\n    es[u].back().rev_idx = res[v].size()-1;\n    res[v].back().rev_idx = es[u].size()-1;\n  }\n\n  void AddEdge(int u, int v, EData d=EData()) {\n    AddEdge(u, v, d, d);\n  }\n\n  Edge *GetRevEdge(Edge *e, bool is_es) {\n    int v = e->to;\n    if (is_es) return &res[v][e->rev_idx];\n    return &es[v][e->rev_idx];\n  }\n\n  // should be tested\n  template<class Cmp>\n  void EraseMultipleEdge(Cmp cmp, bool really_erase) {\n    auto same = [](const Edge &a, const Edge &b) {\n      return a.to == b.to;\n    };\n\n    for (auto &ves : es) {\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n    }\n\n    for (auto &ves : res) {\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n    }\n  }\n\n  void CreateDFSForest(bool is_directed) {\n    int k = 0;\n    int idx = 0;\n    vector<int> st(n);\n\n    grp = 0;\n    ord.resize(n, -1);\n    low.resize(n);\n    belong.resize(n, -1);\n\n    function<void(int,int,Edge*)> dfs;\n    // to deal with multiple edges, it needs to be a pointer\n    auto update = [&](int v, Edge *e, bool &is_artic, int &cnt) {\n      int u = e->to;\n      if (ord[u] != -1) {\n        if (belong[u] == -1) low[v] = min(low[v], ord[u]);\n      } else {\n        cnt++;\n        dfs(u, v, e);\n        low[v] = min(low[v], low[u]);\n        if (ord[v] <= low[u]) is_artic = true;\n        // FIXME\n        if (ord[v] < low[u]) bridge.emplace_back(Brid(v, e - &es[v][0]));\n      }\n    };\n\n    dfs = [&](int v, int p, Edge *par) {\n      bool is_artic = false;\n      int cnt = 0;\n\n      st[idx++] = v;\n      low[v] = ord[v] = k++;\n\n      for (auto &e : es[v]) {\n        if (GetRevEdge(&e, true) == par) continue;\n        assert(e.to != p);\n        update(v, &e, is_artic, cnt);\n      }\n\n      if (!is_directed) {\n        for (auto &e : res[v]) {\n          if (GetRevEdge(&e, false) == par) continue;\n          assert(e.to != p);\n          update(v, &e, is_artic, cnt);\n        }\n      }\n\n      if (p == -1) is_artic = (cnt > 1);\n      if (is_artic) artic.emplace_back(v);\n\n      if (low[v] != ord[v]) return;\n      while (1) {\n        int u = st[--idx];\n        belong[u] = grp;\n        if (u == v) break;\n      }\n      grp++;\n    };\n\n    for (int i=0; i<n; i++) {\n      if (ord[i] == -1) dfs(i, -1, NULL);\n    }\n\n    sort(bridge.begin(), bridge.end(), [&](const Brid &a, const Brid &b) {\n      int av = a.first;\n      int bv = b.first;\n      int au = es[av][a.second].to;\n      int bu = es[bv][b.second].to;\n      if (av > au) swap(av, au);\n      if (bv > bu) swap(bv, bu);\n      if (av != bv) return av < bv;\n      return au < bu;\n    });\n  }\n\n  using DE = SCCEData;\n  using G = Graph<SCCVData<VData, EData, GData>, DE, SCCGData>;\n  G CreateSCC() {\n    if (belong.empty()) CreateDFSForest(true);\n\n    G ret(grp);\n    ret.gdat.orig2cont.resize(n);\n    for (int v=0; v<n; v++) {\n      auto &vd = ret.vdat[belong[v]];\n      ret.gdat.orig2cont[v] = ret.vd.cont2orig.size();\n      vd.cont2orig.emplace_back(v);\n    }\n\n    for (int i=0; i<grp; i++) {\n      auto &vd = ret.vdat[i];\n      vd.g.Init(vd.cont2orig.size(), 0x33433433);\n    }\n    \n    for (int v=0; v<n; v++) {\n      for (auto &e : es[v]) {\n        int u = e.to;\n\n        if (belong[v] == belong[v]) {\n          auto &vd = ret.vdat[belong[v]];\n          auto &dic = ret.gdat.orig2cont;\n          vd.g.AddEdge(dic[v], dic[u], e.dat, GetRevEdge(&e, true)->dat);\n        } else {\n          ret.AddEdge(belong[v], belong[u], DE(v, u), DE(u, v));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void CreateAdjMat() {\n    cost.clear();\n    cost.resize(n, Ls(n, INF));\n\n    auto cmp = [](const Edge &a, const Edge &b) {\n      if (a.to != b.to) return a.to < b.to;\n      return a.dat.len < b.dat.len;\n    };\n    EraseMultipleEdge(cmp, false);\n\n    for (int i=0; i<n; i++) {\n      int prev = -1;\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (prev > v) break;\n        cost[i][v] = min(cost[i][v], e.dat.len);\n        prev = v;\n      }\n    }\n  }\n\n  void DijkstraV(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    if (cost.empty()) CreateAdjMat();\n\n    vector<bool> used(n, false);\n    for (int i=0; i<n; i++) {\n      int v = -1;\n      for (int u=0; u<n; u++) {\n        if (used[u]) continue;\n        if (v == -1 || d[u] < d[v]) {\n          v = u;\n        }\n      }\n      if (v == -1) return;\n\n      used[v] = true;\n      for (int u=0; u<n; u++) {\n        d[u] = mind(d[u], d[v] + cost[v][u]);\n      }\n    }\n\n    // must not reach here\n    assert(0);\n  }\n\n  void DijkstraE(vector<int> &starts, Ls &d) {\n    using Pair = pair<Len, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.dat.len) {\n          d[u] = d[v] + e.dat.len;\n          q.push(Pair(d[u], u));\n        }\n      }\n    }\n  }\n\n  // return true if the graph has a negative cycle\n  bool SPFA(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n\n    queue<int> q;\n    vector<bool> inq(n);\n    vector<int> cnt(n);\n    for (int s : starts) {\n      inq[s] = true;\n      q.push(s);\n      d[s] = 0;\n    }\n\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      inq[v] = false;\n      cnt[v]++;\n      if (cnt[v] > n) continue;\n      for (auto &e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.to) {\n          d[u] = d[v] + e.to;\n          if (inq[u]) continue;\n          inq[u] = true;\n          q.push(u);\n        }\n      }\n    }\n\n    // do DFS if you need the concrete contents of such cycles\n    for (int i=0; i<n; i++) {\n      if (cnt[i] >= n) return true;\n    }\n\n    return false;\n  }\n\n  void DijkstraV(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraV(ss, d);\n  }\n\n  void DijkstraE(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraE(ss, d);\n  }\n\n  void SPFA(int s, Ls &d) {\n    vector<int> ss(1, s);\n    SPFA(ss, d);\n  }\n\n  // Create \"Shortest Path Graph\", which should be DAG\n  Graph<VData, EData, GData> RestoreShortestPaths(Ls &d) {\n    Graph<VData, EData, GData> ret(n);\n\n    for (int i=0; i<n; i++) {\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (d[v] == d[i] + e.dat.len) {\n          ret.AddEdge(i, e.to, e.dat, GetRevEdge(&e, true)->dat);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void WarshallFloyd(vector<Ls> &ds) {\n    if (cost.empty()) CreateAdjMat();\n\n    ds.clear();\n    ds.resize(cost);\n    for (int i=0; i<n; i++) {\n      ds[i][i] = min(ds[i][i], 0);\n    }\n\n    for (int k=0; k<n; k++) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n          if (ds[i][j] > ds[i][k] + ds[k][j]) {\n            ds[i][j] = ds[i][k] + ds[k][j];\n          }\n        }\n      }\n    }\n  }\n\n  // Karp's Algorithm O(NM)\n  // should be tested\n  // should be used for SCC\n  double MinimumMeanCycle() {\n    vector<Ls> dp(n+1, Ls(n, INF));\n\n    dp[0][0] = 0;\n    for (int i=1; i<=n; i++) {\n      for (int v=0; v<n; v++) {\n        for (auto &e : es[v]) {\n          int u = e.to;\n          dp[i][u] = min(dp[i][u], dp[i-1][v] + e.dat.len);\n        }\n      }\n    }\n\n    double ret = 1.0/0.0;\n    for (int v=0; v<n; v++) {\n      double alpha = (-1.0)/0.0;\n      for (int i=1; i<n; i++) {\n        if (dp[n][v] == INF) continue;\n        if (dp[i][v] == INF) continue;\n        alpha = max(alpha, (dp[n][v]-dp[i][v])/double(n-i));\n      }\n      ret = min(ret, alpha);\n    }\n    return ret;\n  }\n};\n\n// will be edited later\ntemplate<class Len>\nstruct Tree {\n  struct Edge {\n    int to;\n    Len len;\n  };\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  Len INF;\n\n  int n;\n  vector<Es> es;\n\n  Tree(int sz, Len inf) : INF(inf) {}\n\n  Len GetTreeDiameter() {\n    using Pair = pair<Len, int>;\n    auto dfs = [&](int v, int p) {\n      Pair ret{0, v};\n      for (auto &e : es[v]) {\n        if (e.to == p) continue;\n        Pair p = dfs(e.to, v);\n        p.first += e.len;\n        ret = max(ret, p);\n      }\n      return ret;\n    };\n\n    Pair p = dfs(0, 0);\n    return dfs(p.second, p.second).first;\n  }\n};\n\nint n;\nint m;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Graph<> g(n, 0x33433433);\n\n  while (m--) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    g.AddEdge(s, t);\n  }\n\n  g.CreateDFSForest(false);\n  for (auto &b : g.bridge) {\n    int v = b.first;\n    int u = g.es[b.first][b.second].to;\n    if (v > u) swap(v, u);\n    printf(\"%d %d\\n\", v, u);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 100001\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[v]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  //bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\n\nconst int MAX_N = 112345;\nvector<int> g[MAX_N];\n\nint ord[MAX_N]; // 訪れた順につける番号\nint low[MAX_N]; // DFS 木の葉方向の辺を 0 回以上、後退辺を 1 回以下でたどり着ける ord の最小値\nbool isArticulation[MAX_N];\n\nvoid dfs(int u, int p, int &ordc) {\n  low[u] = ord[u] = ordc++;\n  int deg = 0;\n  bool isa = false;\n  for (int v : g[u]) if (v != p) {\n    if (ord[v] == -1) { // まだ訪れてない\n      deg++;\n      dfs(v, u, ordc);\n      low[u] = min(low[u], low[v]);\n      if (ord[u] <= low[v]) isa = true;\n    } else { // まだ (u,v) を使ってない\n      // このとき (u,v) は後退辺\n      low[u] = min(low[u], ord[v]);\n    }\n  }\n\n  // 頂点 u が関節点 <=> u が DFS 木の根なら次数 > 1 かどうか、uがそれ以外なら ord[u] <= low[v] なる u の子 v が存在するかどうか\n  isArticulation[u] = (p == -1 ? deg >= 2 : isa);\n}\nvoid lowlink(int N) {\n  CLR(ord, -1);\n  CLR(isArticulation, 0);\n  int ordc = 0;\n  REP(u, N) if (ord[u] == -1) {\n    dfs(u, -1, ordc);\n  }\n}\n// DFS 木の辺 e(u, v) が橋 <=> ord[u] < low[v]\nbool isBridge(int u, int v) {\n  if (ord[u] > ord[v]) swap(u, v);\n  return ord[u] < low[v];\n}\n\nint main2() {\n  REP(i, MAX_N) g[i].clear();\n  int N = nextInt();\n  int M = nextInt();\n  REP(i, M) {\n    int a = nextInt();\n    int b = nextInt();\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  lowlink(N);\n\n  vector<pair<int,int>> bridges;\n  REP(i, N) {\n    for (int j : g[i]) if (i < j) {\n      if (isBridge(i, j)) bridges.push_back({i, j});\n    }\n  }\n  sort(ALL(bridges));\n  for (auto b : bridges) printf(\"%d %d\\n\", b.first, b.second);\n\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to){ \n\tgraph[from].push_back({to});\n}\n\n// Description: ????????°????????????????????? \n// TimeComplexity: $ \\mathcal{O}(V + E) $\n// Verifyed: AOJ GRL_3_B\n\nauto bridge(const G& graph){\n    int n=graph.size(),k=0;\n    vector<int> par(n),ord(n,-1),low(n),root(n,0);\n\n    auto dfs=[&](int v,int p,int &k){\n        auto func=[&](int v,int p,int &k,auto func)->void{\n            ord[v]=k++,low[v]=ord[v],par[v]=p;\n            for(auto &e:graph[v]){\n                if(e.to==p) continue;\n                if(ord[e.to]==-1)\n                    func(e.to,v,k,func),chmin(low[v],low[e.to]);\n                else\n                    chmin(low[v],ord[e.to]);\n            }\n        };\n        return func(v,p,k,func);\n    };\n\n    rep(v,n) if(ord[v]==-1) dfs(v,-1,k),root[v]=1;\n\n    using state=tuple<int,int>;\n    vector<state> res;\n    rep(v,n){\n        if(par[v]==-1) continue;\n        if(ord[v]<low[par[v]]||ord[par[v]]<low[v]){\n            auto in=state(v,par[v]);\n            if(get<1>(in)<=get<0>(in)) swap(get<0>(in),get<1>(in));\n            res.push_back(in);\n        }\n    }\n    sort(_all(res));\n    return res;      \n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_edge(graph,a,b);\n\t\tadd_edge(graph,b,a);\n\t}\n\n\tauto res=bridge(graph);\n\t\n    for(auto &it:res){\n        int a,b;\n        tie(a,b)=it;\n        cout << a << \" \" << b << endl;\n    } \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨??????root??????????????????u???lowest???root??\\?????????root -> u??????\n//???DFS??¨?????????????????????u???????????????u?????????prenum <= u???lowest ??? u??¨u??????????????????????????????\n//??????????¨???????u --> ?????¨????????????u?????? (u --> u??????) ???????????????????????????\n// ( ???????¨????????????¶?¨????????????????u?????????????????????u --> ?????¨??????????????????u --> u????\\????x??¨??????????????§???lowest[u] <= prenum[x]????????????x???prenum < u?????????prenum?????????????????????)\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse if (parent[u] != v) {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (parent[i] == 0) {\n\t\t\tif (lowest[i] != 0) { ans.push_back(Edge(0, i)); }\n\t\t}\n\t\telse if (prenum[parent[i]] <= lowest[i]) {\n\t\t\tans.push_back(Edge(parent[i], i));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\t\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v, e;\npair<int, int> a[200010];\nint s[100001];\nint g[100001];\nint n[100001];\nint p[100001];\nint l[100001];\nint u[100001]={};\nint c, t;\nint x, y;\nint k;\n\nvoid dfs(int f, int z)\n{\n\tn[f]=t;\n\tl[f]=t;\n\tt++;\n\tu[f]=1;\n\tfor(int i=s[f]; i<=g[f]; i++)\n\t{\n\t\tif(u[a[i].second]==0)\n\t\t{\n\t\t\tp[a[i].second]=f;\n\t\t\tdfs(a[i].second, f);\n\t\t\tl[f]=min(l[f], l[a[i].second]);\n\t\t}\n\t\telse if(a[i].second!=z)\n\t\t{\n\t\t\tl[f]=min(l[f], n[a[i].second]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> v >> e;\n\tfor(int i=0; i<e; i++)\n\t{\n\t\tcin >> x >> y;\n\t\ta[2*i]=make_pair(x, y);\n\t\ta[2*i+1]=make_pair(y, x);\n\t}\n\tsort(a, a+(2*e));\n\ts[0]=0;\n\tg[v-1]=2*e-1;\n\tc=0;\n\tfor(int i=1; i<2*e; i++)\n\t{\n\t\tif(a[i].first>a[i-1].first)\n\t\t{\n\t\t\tg[c]=i-1;\n\t\t\tc++;\n\t\t\ts[c]=i;\n\t\t}\n\t}\n\tt=0;\n\tdfs(0, -1);\n\tk=0;\n\tfor(int i=1; i<v; i++)\n\t{\n\t\tif(p[i]==0)\n\t\t{\n\t\t\tk++;\n\t\t}\n\t}\n\tif(k>1)\n\t{\n\t\tfor(int i=s[0]; i<=g[0]; i++)\n\t\t{\n\t\t\tif(p[a[i].second]==0)\n\t\t\t{\n\t\t\t\tcout << 0 << \" \" << a[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse if(s[0]==g[0])\n\t{\n\t\tcout << 0 << \" \" << a[g[0]].second << endl;\n\t}\n\tfor(int i=s[1]; i<2*e; i++)\n\t{\n\t\tif(a[i].first<a[i].second)\n\t\t{\n\t\t\tif(p[a[i].first]==a[i].second)\n\t\t\t{\n\t\t\t\tif(n[a[i].second]<l[a[i].first])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p[a[i].second]==a[i].first)\n\t\t\t{\n\t\t\t\tif(n[a[i].first]<l[a[i].second])\n\t\t\t\t{\n\t\t\t\t\tcout << a[i].first << \" \" << a[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<int> > graph(100001);\nvector<int> pre(100001, -1);\nvector<int> low(100001, -1);\n\nint dfs(int now, int before, int cnt)\n{\n\tpre[now] = cnt;\n\tlow[now] = cnt;\n\tfor(int i = 0; i < graph[now].size(); i++){\n\t\tint next = graph[now][i];\n\t\tif(next == before) continue;\n\t\tif(pre[next] == -1){\n\t\t\tcnt = dfs(next, now, cnt + 1);\n\t\t}\n\t\tlow[now] = min(low[now], low[next]);\n\t}\n\t// cout << now << \" \" << pre[now] << \" \" << low[now] << endl;\n\treturn cnt;\n}\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tfor(int i = 0; i < e; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\tdfs(0, -1, 0);\n\tvector<pair<int, int> > ans;\n\tfor(int i = 0; i < v; i++){\n\t\tfor(int j = 0; j < graph[i].size(); j++){\n\t\t\tint next = graph[i][j];\n\t\t\tif(pre[i] < pre[next] && pre[next] == low[next]) ans.push_back(make_pair(min(i, next), max(i, next)));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nusing P = pair<int, int>;\nint ord[100000];\nint low[100000];\nint v, e;\n\nset<P> M;\nvector<int> Edge[100000];\nvector<bool> isNew(100000, true);\nset<P> U;\n\nbool isEdge(int s, int t) {\n\treturn M.end()!=M.find(P(s, t));\n}\nbool isUsed(int s, int t) {\n\treturn U.end()!=U.find(P(s, t));\n}\nvoid dfs(int u) {\n\tisNew[u] = false;\n\tstatic int k ;\n\tord[u] = k; k++;\n\t//cout << \"u=\" << u << \" k=\" << k << endl;\n\tlow[u] = ord[u];\n\tfor (int v : Edge[u]) {\n\t\tif (isNew[v]) {\n\t\t\tU.emplace(u, v); U.emplace(v, u);\n\t\t\tdfs(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t\telse if (!isUsed(u, v)) {\n\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> v >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tM.emplace(s, t);\n\t\tM.emplace(t, s);\n\t\tEdge[s].push_back(t);\n\t\tEdge[t].push_back(s);\n\t}\n\tdfs(0);\n\t//for (P p : M) {\n\t//\tcout << p.first << \" \" << p.second << endl;\n\t//}\n\t//for (int i = 0; i < v; i++) {\n\t//\tcout << \"low=\" << low[v] << \" ord=\" << ord[v] << endl;\n\t//}\n\t//cout << endl;\n\tfor (P p : M) {\n\t\tint f = p.first;\n\t\tint s = p.second;\n\t\tif (f < s) {\n\n\t\tif (ord[f] < low[s] || ord[s] < low[f]) {\n\t\t\tcout << f << \" \" << p.second << endl;\n\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int MAX_n = 1e5, MAX_m = 1e5;\n\nint n, m;\nvector<int> adj[MAX_n];\nint h[MAX_n], f[MAX_n];\nbool mark[MAX_n] = {};\nvector<pii> ceg;\n\nvoid add(int a, int b) {\n\tif (a > b) swap(a, b);\n\tceg.push_back(pii(a, b));\n}\n\nvoid DFS(int v, int p) {\n\tif (mark[v]) return;\n\tmark[v] = true;\n\tf[v] = h[v];\n\tfor (int u : adj[v]) {\n\t\tif (!mark[u]) {\n\t\t\th[u] = h[v] + 1;\n\t\t\tDFS(u, v);\n\t\t\tif (f[u] > h[v]) add(u, v);\n\t\t\telse f[v] = min(f[v], f[u]);\n\t\t}\n\t\telse if (u != p)\n\t\t\tf[v] = min(f[v], h[u]);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\th[0] = 0;\n\tDFS(0, -1);\n\tsort(ceg.begin(), ceg.end());\n\tfor (pii i : ceg)\n\t\tcout << i.first << ' ' << i.second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LowLink {\n  using A = vector<int>;\n  using B = vector<pair<int, int>>;\n  int n;\n  vector<vector<int>> es;\n  vector<bool> vis;\n  vector<int> ord, low;\n  A articulation;\n  B bridge;\n  LowLink(int n) : n(n), es(n) {}\n  void add_edge(int v, int u) {\n    es[v].push_back(u);\n    es[u].push_back(v);\n  }\n  void dfs(int v, int p, int &k) {\n    vis[v] = true;\n    ord[v] = k++;\n    low[v] = ord[v];\n    bool is = false;\n    int cnt = 0;\n    for (auto u : es[v]) {\n      if (vis[u])  {\n        if (u != p) low[v] = min(low[v], ord[u]);\n        continue;\n      }\n      cnt++;\n      dfs(u, v, k);\n      low[v] = min(low[v], low[u]);\n      if (p != -1 && ord[v] <= low[u]) is = true;\n      if (ord[v] < low[u]) bridge.emplace_back(min(v, u), max(v, u));\n    }\n    if (p == -1 && cnt > 1) is = true;\n    if (is) articulation.push_back(v);\n  }\n  pair<A, B> build() {\n    int k = 0;\n    vis.assign(n, false);\n    ord.assign(n, 0);\n    low.assign(n, 0);\n    articulation.clear();\n    bridge.clear();\n    dfs(0, -1, k);\n    return pair<A, B>(articulation, bridge);\n  }\n};\n\nint main() {\n  int N, M; cin >> N >> M;\n  auto low = LowLink(N);\n  for (int i = 0; i < M; i++) {\n    int v, u; cin >> v >> u;\n    low.add_edge(v, u);\n  }\n  auto ans = low.build().second;\n  sort(ans.begin(), ans.end());\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i].first << \" \" << ans[i].second << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nconst int max_n = 1000001, inf = 9999999;\npair<int, int>ans[1000000];\nvector<int>adj[max_n];\nint dp[max_n], depath[max_n], from[max_n], to[max_n];\nbool vis[max_n];\nint rt;\nvoid dfs(int v, int de, int p){\n\tdepath[v] = de;\n\tvis[v] = 1;\n\tfor (int e : adj[v]){\n\t\tint a = from[e] ^ to[e] ^ v;\n\t\tif (e == p)\n\t\t\tcontinue;\n\t\tif (vis[a])\n\t\t\tdp[v] = min(dp[v], depath[a]);\n\t\telse{\n\t\t\tdfs(a, de + 1, e);\n\t\t\tdp[v] = min(dp[a], dp[v]);\n\t\t}\n\t}\n\tif (dp[v] >= de  &&p != -1)\n\t\tans[rt] = { min(from[p], to[p]), max(from[p], to[p]) },rt++;\n}\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < max_n; i++)\n\t\tdp[i] = inf;\n\tfor (int i = 1; i <= m; i++){\n\t\tcin >> from[i]>> to[i];\n\t\tfrom[i];\n\t\tto[i];\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tdfs(0, 0, -1);\n\tsort(ans, ans + rt);\n\tfor (int i = 0; i < rt; i++)\n\t\tcout << ans[i].first << ' ' << ans[i].second << endl;\n\tint z;\n\tcin >> z;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  using weight_type = int;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\nusing Weight = Edge::weight_type;\nusing Edges = std::vector<Edge>;\nusing Weights = std::vector<Weight>;\nusing Path = std::vector<int>;\n}\nusing Graph = std::vector<graph::Edges>;\n}\n#endif\n//}}}\n//{{{ bridge.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\nnamespace bridge_internal {\nstruct BridgeImpl {\n  const Graph& G;\n  int k;\n  std::vector<int> ord, low;\n  Edges bridges;\n  BridgeImpl(const Graph& g) : G(g), k(0), ord(g.size(), -1), low(g.size()) {}\n  void dfs(int v, int p = -1) {\n    low[v] = ord[v] = k++;\n    for (const auto& e : G[v]) {\n      int u = e.to;\n      if (u == p) continue;\n      if (ord[u] >= 0) {\n        low[v] = std::min(low[v], ord[u]);\n      } else {\n        dfs(u, v);\n        low[v] = std::min(low[v], low[u]);\n      }\n      if (ord[v] < low[u]) bridges.emplace_back(e);\n    }\n  }\n  Edges get() {\n    dfs(0);\n    return std::move(bridges);\n  }\n};\n}\nEdges bridges(const Graph& g) {\n  return std::move(bridge_internal::BridgeImpl(g).get());\n}\n}\n}\n//}}}\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\nint main() {\n  int V = in(), E = in();\n  orliv::Graph g(V);\n  for (int i = 0; i < E; i++) {\n    int s = in(), t = in();\n    g[s].emplace_back(s, t, 1);\n    g[t].emplace_back(t, s, 1);\n  }\n  auto bridges = orliv::graph::bridges(g);\n  for (auto& e : bridges) {\n    if (e.from > e.to) swap(e.from, e.to);\n  }\n  sort(bridges.begin(), bridges.end());\n  for (auto& e : bridges) {\n    cout << e.from << \" \" << e.to << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nvector<Edge> g[100001];\nint prenum[100001],parent[100001],lowest[100001],visited[100001],cnt = 1,child[100001];\n\nvoid Articulation_Points(int k,int p){\n  visited[k] = true;\n  prenum[k] = cnt;\n  lowest[k] = cnt;\n  ++cnt;\n  for (auto&& n : g[k]) {\n    if(!visited[n.to]){\n      parent[n.to] = k;\n      Articulation_Points(n.to,k);\n      child[k]++;\n      lowest[k] = min(lowest[k],lowest[n.to]);\n    }\n    else if(n.to != p){\n      lowest[k] = min(lowest[k],prenum[n.to]);\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n ,a,b,e;\n  cin >> n >> e;\n  rep(i,e){\n    cin >> a >> b;\n    g[a].push_back({b,0LL});\n    g[b].push_back({a,0LL});\n  }\n  Articulation_Points(0,-1);\n  set<int> art;\n  set<pair<int,int>> ans;\n  int np = 0;\n  for (int i = 1; i < n; i++) {\n    int p = parent[i];\n    if(p == 0){\n      ++np;\n    }\n    else{\n      if(prenum[p] <= lowest[i]){\n        art.insert(p);\n      }\n    }\n  }\n  if(np > 1) art.insert(0);\n  rep(i,n){\n    if(g[i].size() == 1)\n      art.insert(i);\n  }\n  rep(i,n){\n    for (auto&& k : g[i]) {\n      if(art.find(i) != art.end() && art.find(k.to) != art.end() && g[k.to].size() <= 2){\n        if(i < k.to){\n          ans.insert({i,k.to});\n        }\n        else\n          ans.insert({k.to,i});\n      }\n    }\n  }\n  for (auto&& k : ans) {\n    std::cout << k.fi << ' ' << k.se << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T> struct Inf { static constexpr T inf() { return std::numeric_limits<T>::has_infinity() ? std::numeric_limits<T>::infinty() : std::numeric_limits<T>::max(); } };\ntemplate <> struct Inf<int> { static constexpr int inf() { return 0x3f3f3f3f; } };\ntemplate <> struct Inf<long long> { static constexpr long long inf() { return 0x3f3f3f3f3f3f3f3fLL; } };\nconstexpr int INF = Inf<int>::inf(); constexpr ll BINF = Inf<ll>::inf();\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\nint solve() {\n\tint n, m; cin >> n >> m;\n\tvvi g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v); g[v].push_back(u);\n\t}\n\tint timer = 0;\n\tvi stTime(n, INF), enTime(n, INF);\n\tvi low(n);\n\tvpii ans;\n\tfunction<void(int, int)> dfs = [&] (int u, int p) {\n\t\tstTime[u] = timer++;\n\t\tlow[u] = stTime[u];\n\t\tfor (int v : g[u]) {\n\t\t\tif (v == p) continue;\n\t\t\tif (stTime[v] >= INF) {\n\t\t\t\t// tree edge\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t\tif (low[v] > stTime[u]) ans.emplace_back(u, v);\n\t\t\t} else if (enTime[v] >= INF) {\n\t\t\t\t// back edge\n\t\t\t\tlow[u] = min(low[u], stTime[v]);\n\t\t\t}\n\t\t}\n\t\tenTime[u] = timer;\n\t};\n\tdfs(0, -1);\n\tfor (auto &p : ans) if (p.first > p.second) swap(p.first, p.second);\n\tsort(ans.begin(), ans.end());\n\tfor (auto p : ans) cout << p << endl;\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\n\nint n, m;\nvector<vector<int>> g(1000000 + 6);\n\nint ord[1000000 + 6], low[1000000 + 6];\nbool visited[1000000 + 6];\n\nvector<pair<int, int>> Bridges;\nvector<int> Points;\n\nvoid dfs(int now, int par, int &cnt) {\n    visited[now] = true;\n    ord[now] = cnt++;\n    low[now] = ord[now];\n    bool check = false;\n    int outdeg = 0;\n    for (auto nx : g[now]) {\n        if (nx == par) continue;\n        if (!visited[nx]) {\n            outdeg++;\n            dfs(nx, now, cnt);\n            low[now] = min(low[now], low[nx]);\n            //???????????????\n            if (ord[now] < low[nx]) {\n                Bridges.push_back({min(now, nx), max(now, nx)});\n            }\n            //??¢??????????????????\n            if (par != -1 && !check && ord[now] <= low[nx]) {\n                check = true;\n                Points.push_back(now);\n            }\n        }\n        else {\n            low[now] = min(low[now], ord[nx]);\n        }\n    }\n    //???????????????????????\\?????¢????????¨???????????????\n    if (par == -1 && outdeg >= 2) {\n        Points.push_back(now);\n    }\n    return;\n}\n\nvoid lowlink (int n, vector<vector<int>>& g) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1, cnt);\n        }\n    }\n    sort(all(Bridges));\n    sort(all(Points));\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    lowlink(n, g);\n    rep(i, Bridges.size()) {\n        cout << Bridges[i].fi << \" \" << Bridges[i].se << endl;\n    }\n    /*\n    rep(i, Points.size()) {\n        cout << Points[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nvector<int> G[V_MAX];\nvector<bool> check(V_MAX,false);\nvector<int> pre(V_MAX);\nvector<int> low(V_MAX);\nint order;\n\nvoid dfs(int s,int p){\n\t// cout << p << \" \" << s <<endl;\n\tif(check[s]==true){return;}\n\tcheck[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(G[s][i]!=p && low[G[s][i]]<low[s]){\n\t\t\tlow[s]=low[G[s][i]];\n\t\t}\n\t\tif(check[G[s][i]]==false){\n\t\t\tdfs(G[s][i],s);\n\t\t}\n\t}\n\t\n\tif(!(s==0&&p==0) && pre[s]==low[s]){\n\t\tcout << p << \" \" << s << endl;\n\t}\n\t\n\tif(low[p]>low[s]){\n\t\tlow[p]=low[s];\n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<V;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t/*\n\tfor(int i=0;i<V;i++){\n\t\tcout << low[i] << endl;\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  int n;\n  BiconectedGraph(){}\n  BiconectedGraph(int n):n(n){\n    G.clear();\n    C.clear();\n    T.clear();\n    G.resize(n);\n    C.resize(n);\n    T.resize(n);\n  }\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.clear();\n    low.clear();\n    belong.clear();\n    ord.resize(n,-1);\n    low.resize(n);\n    belong.resize(n,-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    add_component(0,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  bcc.input(e,0);\n  bcc.build();\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}\n\n/*\n  verified on 2017/10/15\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\ntemplate<class G>\nstruct LowLink {\n  const G& g;\n  vector<int> ord, low;\n  int next_ord;\n  bool ran = false;\n\n  LowLink(const G& g) : g(g) {}\n\n  void run() {\n    ran = true;\n    int n = g.size();\n    ord.assign(n, -1);\n    low.assign(n, -1);\n    next_ord = 0;\n    for (int u = 0; u < n; ++u) {\n      dfs(u, -1);\n    }\n  }\n\n  int dfs(int u, int p) {\n    if (low[u] >= 0) return low[u];\n    low[u] = ord[u] = next_ord++;\n    for (int v : g[u]) {\n      if (v == p) continue;\n      low[u] = min(low[u], dfs(v, u));\n    }\n    return low[u];\n  }\n\n  vector<pair<int, int>> bridges() {\n    if (!ran) run();\n    vector<pair<int, int>> res;\n    for (int u = 0; u < (int)g.size(); ++u) {\n      for (int v : g[u]) {\n        if (ord[u] < low[v]) res.emplace_back(u, v);\n      }\n    }\n    return res;\n  }\n};\n\nint n, m;\nvector<vector<int>> g;\nint main() {\n  cin >> n >> m;\n  init_n(g, n);\n  for (int i = 0; i < m; ++i) {\n    int a, b; cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  LowLink<vector<vector<int>>> ll(g);\n  auto bs = ll.bridges();\n  for (auto& e : bs) {\n    if (e.first > e.second) swap(e.first, e.second);\n  }\n  sort(begin(bs), end(bs));\n  for (auto e : bs) cout << e.first << ' ' << e.second << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\nclass Node{\n\tpublic:\n\t\tbool used;\n\t\tint prenum; //DFSの訪問の順番\n\t\tint parent; //DFS Treeにおける親\n\t\tint lowest; //min(自分のprenum, 逆辺がある場合の親のprenum, すべての子のlowest)\n\t\tNode() : used(0) { }\n};\n\nclass articulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int current, int prev){\n\t\t\tnode[current].prenum = node[current].lowest = cnt;\n\t\t\tcnt++;\n\n\t\t\tnode[current].used = true;\n\n\t\t\tint next;\n\t\t\trep(i,edge[current].size()){\n\t\t\t\tnext = edge[current][i];\n\t\t\t\tif(not node[next].used){\n\t\t\t\t\tnode[next].parent = current;\n\t\t\t\t\tdfs(next, current);\n\t\t\t\t\tnode[current].lowest = min(node[current].lowest, node[next].lowest);\n\t\t\t\t\tif(node[current].prenum < node[next].lowest){\n\t\t\t\t\t\tbridge.emplace_back(make_pair(min(current, next), max(current, next)));\n\t\t\t\t\t}\n\t\t\t\t}else if(next != prev){\n\t\t\t\t\tnode[current].lowest = min(node[current].lowest, node[next].prenum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> edge;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tarticulationPoints(int n) : v(n), cnt(1), node(n), edge(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tedge[a].emplace_back(b);\n\t\t\tedge[b].emplace_back(a);\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 == root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].parent;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].prenum <= node[i].lowest) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\n\t\t}\n};\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tarticulationPoints ap(n);\n\trep(i,m){\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tap.addEdge(s,t);\n\t}\n\tap.run();\n\tfor(auto i : ap.bridge){\n\t\tcout << i.first << ' ' << i.second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nint dfs(vector<vector<pair<int,int>>> &graph, vector<pair<int,int>> &res, int v, int &count, int from, vector<int> &low, vector<int> &pre){\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\t\n\tfor(pair<int,int> next : graph[v]){\n\t\tif(pre[next.first] == -1){\n\t\t\t\n\t\t\tlow[v] = min(low[v], dfs(graph, res, next.first, count, v, low, pre));\n\t\t\tif(low[next.first] == pre[next.first]){\n\t\t\t\tif(v < next.first) res.push_back(make_pair(v, next.first));\n\t\t\t\telse res.push_back(make_pair(next.first, v));\n\t\t\t}\n\t\t} else {\n\t\t\tif(from == next.first){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], pre[next.first]);\n\t\t}\n\t}\n\t\n\treturn low[v];\n}\n\nvector<pair<int,int>> bridges(vector<vector<pair<int,int>>> & graph, int V){\n\tvector<pair<int,int>> res;\n\t\n\tif(V > 0){\n\t\tvector<int> low(V, -1);\n\t\tvector<int> pre(V, -1);\n\t\tint count = 0;\n\t\tdfs(graph, res, 0, count, -1, low, pre);\n\t}\n\t\n\treturn res;\n}\n\n\nsigned main(){\n\t\n\tint V, E;\n\tvector<vector<pair<int,int>>> G;\n\tvector<pair<int,int>> b;\n\tset<int> s;\n\t\n\tcin>>V>>E;\n\t\n\tG.resize(V);\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint s, t;\n\t\t\n\t\tcin>>s>>t;\n\t\t\n\t\tG[s].push_back({t, 1});\n\t\tG[t].push_back({s, 1});\n\t}\n\t\n\tb = bridges(G, V);\n\t\n\tsort(b.begin(), b.end());\n\t\n\tfor(int i = 0; i < b.size(); i++){\n\t\tcout<<b[i].first<<\" \"<<b[i].second<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 100010\n\nvector<int> g[maxn];\nint dist[maxn], parent[maxn], n, m, src;\n//\n//\n//void dijkstra(int src) {\n//    memset(dist, 63, sizeof dist);\n//    int inf = dist[0];\n//    dist[src] = 0;\n//    set<pair<int, int>> q;\n//\n////    dist , node\n//    q.insert({0, src});\n//    while (!q.empty()) {\n//        int len = q.begin()->first;\n//        int node = q.begin()->second;\n//\n//        q.erase({len, node});\n//        for (auto x: g[node]) {\n//            if (dist[x.first] > dist[node] + x.second) {\n//                q.erase({dist[x.first], x.first});\n//                parent[x.first] = node;\n//                dist[x.first] = x.second + dist[node];\n//                q.insert({dist[x.first], x.first});\n//            }\n//        }\n//    }\n//    for (int i = 0; i < n; i++)\n//        if (dist[i] == inf)\n//            cout << \"INF\" << endl;\n//        else\n//            cout << dist[i] << endl;\n//}\n\nvector<pair<pair<int, int>, int>> ed;\n\nvoid bellman(int src) {\n    memset(dist, 63, sizeof dist);\n    int inf = dist[0];\n\n    dist[src] = 0;\n    int xx;\n    for (int i = 0; i < n; i++) {\n        xx = -1;\n        for (auto x: ed) {\n            if (dist[x.first.first] < inf and dist[x.first.first] + x.second < dist[x.first.second]) {\n                dist[x.first.second] = x.second + dist[x.first.first];\n                xx = 2;\n            }\n        }\n    }\n    if (xx == -1) {\n        for (int i = 0; i < n; i++)\n            if (dist[i] == inf)\n                cout << \"INF\" << endl;\n            else\n                cout << dist[i] << endl;\n    } else\n        cout << \"NEGATIVE CYCLE\" << endl;\n}\n\nbool comp(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n    return a.second < b.second;\n}\n\nint sz[maxn], p[maxn];\n\nvoid init(int n) {\n    for (int i = 0; i <= n; i++)\n        p[i] = i, sz[i] = 1;\n}\n\nint find(int n) {\n    return (n == p[n]) ? n : p[n] = find(p[n]);\n}\n\nbool unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n\n    if (a == b)\n        return false;\n    if (sz[b] > sz[a])\n        swap(a, b);\n    sz[a] += sz[b];\n    p[b] = a;\n    return true;\n}\n\nvoid mst() {\n    sort(ed.begin(), ed.end(), comp);\n    int ans = 0;\n    for (auto x:ed) {\n        if (unite(x.first.first, x.first.second))\n            ans += x.second;\n    }\n    cout << ans << endl;\n}\n\nint tin[maxn], low[maxn], visited[maxn];\nset<pair<int, int>> ans;\nint timer = 0;\n\nvoid dfs(int u, int p = -1) {\n    int child = 0;\n    tin[u] = low[u] = timer++;\n    visited[u] = true;\n    for (auto x: g[u]) {\n        if (x == p)continue;\n        if (visited[x]) {\n            low[u] = min(low[u], tin[x]);\n        } else {\n            child++;\n            dfs(x, u);\n\n            low[u] = min(low[u], low[x]);\n            if (low[x] > tin[u])\n                ans.insert({min(u, x), max(u, x)});\n        }\n    }\n}\n\nvoid solve() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        cin >> a >> b;\n\n//        ed.push_back({{a, b}, c});\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n//    dijkstra(src);\n//    bellman(src);\n//    init(n + 1);\n//    mst();\n\n    dfs(0);\n    for (auto x:ans)\n        cout << x.first << \" \" << x.second << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\n// ??¢??????????±??????? (artPoints)\n// ???????±??????? (bridges)\n\n// ??¢?????????????????????????????¨????????£?????§???????????£???????????????????????????????????¨\n// ????????????????????????????????£?????§???????????£????????????????????????????????¨\n\ntemplate <typename T>\nstruct graphLink {\n    vector<int> ord, low, parent;\n    vector< vector< Edge<T> > > G;\n\n    // ???????????± (first < second ??¨???????????????????´?)\n    vector< pair<int, int> > bridges;\n    int cnt, v;\n\n    // init\n    graphLink(vector< vector< Edge<T> > > S) {\n        int n = S.size();\n        ord.resize(n, -1), low.resize(n, 0),\n        parent.resize(n, -1);\n        cnt = 0, v = n;\n        G = S;\n    }\n\n    // ?????§??????????????????\n    bool is_bridge(int x, int y) {\n        if(ord[x] > ord[y]) swap(x, y);\n        return ord[x] < low[y];\n    }\n\n    // dfs ??¨???????????¨????????????\n    // usage: dfs(root);\n    void dfs(int cur, int prev=-1) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n\n        for(auto x : G[cur]) {\n            if(x.to == prev) continue;\n            if(ord[x.to] < 0) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n            if(is_bridge(cur, x.to)) {\n                int a = min(cur, x.to);\n                int b = max(cur, x.to);\n                bridges.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    // ??¢??????????±??????? (root ??? dfs ??¨??? root ??¨?????´?????????)\n    // root ????????? 2 ????????£???????????°??¢???????????????\n    // ????????\\?????????????????¢????????? ord[parent] <= low[i] ?????¨?????¢???????????????\n    // (lowlink ??§??????????????±????????????????????????????????????????????????)\n    set<int> artPoints(int root) {\n        set<int> se;\n        int num = 0;\n        rep(i,0,v) {\n            if(parent[i] < 0) continue;\n            if(parent[i] == root) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num >= 2) se.insert(0);\n        return se;\n    }\n};\n\nsigned main() {\n    int V, E; cin >> V >> E;\n    Graph<int> G(V);\n    rep(i,0,E) {\n        int s, t; cin >> s >> t;\n        G[s].push_back(Edge<int>(t, 1));\n        G[t].push_back(Edge<int>(s, 1));\n    }\n    graphLink<int> gr(G);\n    gr.dfs(0);\n    sort(gr.bridges.begin(), gr.bridges.end());\n    for(auto x : gr.bridges) printf(\"%lld %lld\\n\", x.first, x.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u, Edges& brdg, stack<int>& roots, stack<int>& S, vector<bool>& inS, vi& num, int& time)\n{\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  vrep(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 1));\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\n\nvoid Bridge(const Graph& g, Edges& brdg)\n{\n  const int n = g.size();\n  vi num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  rep(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint V, E;\nint s, t;\n\nint main()\n{\n  cin >> V >> E;\n  Graph g(V);\n  Edges brdg;\n  rep(i, E){\n    cin >> s >> t;\n    g[s].pb(Edge(s, t, 1));\n    g[t].pb(Edge(t, s, 1));\n  }\n\n  Bridge(g, brdg);\n\n  vrep(v, brdg) if(v->src > v->dst) swap(v->src, v->dst);\n  sort(ALL(brdg));\n\n  vrep(v, brdg) cout << v->src << \" \" << v->dst << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass biconnected{\npublic:\n\tvector<vector<int> > G ,graph;\n\tvector<int> ord,low,cmp;\n\tvector<P> bridge;\n\tvector<vector<P> > check;\n\tvector<bool> visit;\n\tint V;\n\tbiconnected(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V);\n\t\tcheck.resize(V),ord.resize(V),low.resize(V);\n\t\tcmp.resize(V),check.resize(V),visit.resize(V,false);\n\t}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v),G[v].push_back(u);\n\t\tcheck[u].push_back(P((int)check[v].size(),0));\n\t\tcheck[v].push_back(P((int)check[u].size()-1,0));\n\t}\n\tvoid build(){\n\t\tint id = 0;\n\t\trep(i,V){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(i,-1,id);\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,int p,int &k)\n\t{\n\t\tvisit[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\tfor(int i = 0;i < (int)G[v].size();i++){\n\t\t\tint w = G[v][i];\n\t\t\tif(!visit[w]){\n\t\t\t\tdfs(w,v,k);\n\t\t\t\tlow[v] = min(low[v],low[w]);\n\t\t\t\tif(ord[v] < low[w]){\n\t\t\t\t\tbridge.push_back(P(v,w));\n\t                check[v][i].second = 1;\n\t                check[w][check[v][i].first].second = 1;\n\t\t\t\t}\n\t\t\t//(v,w)????????????\n\t\t\t}else if(w != p){\n\t\t\t\tlow[v] = min(low[v],ord[w]);\n\t\t\t}\n\t\t}\n\t}\n\tbool isbridge(int u,int v)\n\t{\n\t\tif(ord[u] > ord[v]) swap(u,v);\n\t\treturn ord[u] < low[v];\n\t}\n\tvoid restrict_dfs(int u,int p,int kind,queue<int>& que)\n\t{\n\t    visit[u] = true;\n\t    cmp[u] = kind;\n\t    rep(i,(int)G[u].size()){\n\t\t\tint w = G[u][i];\n\t        if(check[u][i].second){\n\t            if(!visit[w]){\n\t                que.push(w);\n\t            }\n\t        }else if(!visit[w]){\n\t            restrict_dfs(w,u,kind,que);\n\t        }\n\t    }\n\t}\n\t//????????°?????????\n\tint make_bcgraph()\n\t{\n\t\tgraph.resize(V);\n\t    int num = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            dfs(i,-1,num);\n\t        }\n\t    }\n\t    fill(visit.begin(),visit.end(),false);\n\t    int kind = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            queue<int> que;\n\t            que.push(i);\n\t            while(!que.empty()){\n\t                int p = que.front();\n\t                que.pop();\n\t                restrict_dfs(p,-1,kind,que);\n\t                kind++;\n\t            }\n\t        }\n\t    }\n\t    rep(i,(int)bridge.size()){\n\t        int a = cmp[bridge[i].first];\n\t        int b = cmp[bridge[i].second];\n\t        graph[a].push_back(b), graph[b].push_back(a);\n\t    }\n\t    return kind;\n\t}\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n\tcin >> n >> m;\n\tvp hoge(m);\n\tbiconnected bc(n);\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\thoge[i] = P(min(u,v),max(u,v));\n\t\tbc.add_edge(u,v);\n\t}\n\tbc.build();\n\tvp ans;\n\trep(i,m){\n\t\tif(bc.isbridge(hoge[i].fi,hoge[i].se)){\n\t\t\tans.pb(hoge[i]);\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i,len(ans)){\n\t\tcout << ans[i].fi << \" \" << ans[i].se << \"\\n\";\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int maxn = 110000;\n\nint n, m, a, b;\nvector <int> adj[maxn];\nvector <pii> cut;\n\nbool mark[maxn];\nint dp[maxn], h[maxn], par[maxn];\nvoid dfs(int v)\n{\n    mark[v]=1;\n    dp[v] = -1;\n    int t = max(0, h[v]-1);\n    for(auto u : adj[v])\n    {\n        if(!mark[u])\n        {\n            par[u] = v, h[u] = h[v]+1, dfs(u);\n            dp[v] = (dp[v]==-1 ? dp[u] : min(dp[v], dp[u]));\n        }\n        else\n        {\n            t = min(t, h[u]);\n        }\n    }\n\n    if((dp[v] >= h[v] || dp[v] == -1) && t == h[v]-1)\n        cut.pb(mp(min(par[v],v), max(par[v],v)));\n    dp[v] = min((dp[v]==-1 ? t : dp[v]), t);\n}\n\nint main()\n{\n    cin >> n >> m;\n    for(int i = 0; i < m && cin>>a>>b; i ++)\n        adj[a].pb(b), adj[b].pb(a);\n\n    dfs(0);\n\n    //for(int i = 0; i < n; i++)  cout << i << \" : \" << dp[i] << \" , \" << h[i]  << \" , \"  << par[i] << endl;\n\n    sort(cut.begin(), cut.end(), [](pii a, pii b){return a.first == b.first ? a.second < b.second : a.first < b.first;});\n    for(auto e : cut)\n        cout << e.first << ' ' << e.second << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint const MAX=1000*100+10;\nint depth[MAX];\nint dp[MAX];\nint from[MAX];\nint to[MAX];\nvector<int>adj[MAX];\nbool vis[MAX];\npair<int,int>edg[MAX];\npair<int,int> ans[MAX];\nint cnt=0;\nint const inf=1000*1000*1000+10;\nvoid dfs(int v,int de,int p){\n\t//cout<<v<<\" \"<<p<<\" \";\n\tvis[v]=1;\n\tdepth[v]=de;\n\tdp[v]=de;\n\tfor(int i=0;i<adj[v].size();i++){\n\t\tint u=from[adj[v][i]]+to[adj[v][i]]-v;\n\t\tif(vis[u] && adj[v][i]!=p){\n\t\t\tdp[v]=min(dp[v],depth[u]);\n\t\t}\n\t\telse if(adj[v][i]!=p){\n\t\t\t//adjt[v].push_back(adj[v][i]);\n\t\t\tdfs(u,de+1,adj[v][i]);\n\t\t\tdp[v]=min(dp[u],dp[v]);\n\t\t}\n\t}\n\t//cout<<v<<\" \"<<dp[v]<<\"\\n\";\n\tif(dp[v]>=de && p!=-1){\n\t\tint t=edg[p].first;\n\t\tint t2=edg[p].second;\n\t\tpair<int,int>a;\n\t\ta.first=t;\n\t\ta.second=t2;\n\t\tans[cnt++]=a;\n\t}\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>from[i]>>to[i];\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t\tpair<int,int>a;\n\t\ta.first=from[i];\n\t\ta.second=to[i];\n\t\tedg[i]=a;\n\t}\n\tdfs(0,1,-1);\n\tsort(ans,ans+cnt);\n\tfor(int i=0;i<cnt;i++){\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n    vector<UL> E[100000];\n    UL P[100000];\n    bool F[100000] = {};\n    vector<pair<UL, UL>> ans;\n    UL D[100000];\n\n    UL DFS(UL p) {\n        F[p] = true;\n        UL tmp = D[p];\n        for (UL e : E[p]) {\n            if (P[p] == e) continue;\n            if (F[e]) {\n                tmp = min(tmp, D[e]);\n            }\n            else {\n                P[e] = p;\n                D[e] = D[p] + 1;\n                UL res = DFS(e);\n                if (res > D[p]) ans.push_back({ min(p, e), max(p, e) });\n                tmp = min(tmp, res);\n            }\n        }\n        return tmp;\n    }\n\n    void Solve() {\n        UL N, M; scanf(\"%d%d\", &N, &M);\n        rep(i, M) {\n            UL u, v; scanf(\"%d%d\", &u, &v);\n            if (u > v)swap(u, v);\n            E[u].push_back(v);\n            E[v].push_back(u);\n        }\n        D[0] = 0;\n        DFS(0);\n        sort(ans.begin(), ans.end());\n        for (auto& a : ans) printf(\"%d %d\\n\", a.first, a.second);\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    //cout << fixed << setprecision(10);\n    p->Solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Constraints\n * 1 ≤ |V| ≤ 100,000\n * 0 ≤ |E| ≤ 100,000\n * The graph is connected\n * There are no parallel edges\n * There are no self-loops\n */\n\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\n\n#define MAXM 100010\n#define MAXN 100010\n\nusing namespace std;\n\nstruct {\n  int to, next;\n} E[4 * MAXM];\n\nint LE[MAXN + MAXM];\n\npair<int, int> orig_edges[MAXM];\n\nint main() {\n  fill(LE, LE + MAXN + MAXM, -1);\n  int n, m;\n  cin >> n >> m;\n  for (int src, dst, i = 0; i < m; i++) {\n    cin >> src >> dst;\n    // split each edge with an intermediate node\n    E[4 * i] = {n + i, LE[src]};\n    LE[src] = 4 * i;\n    E[4 * i + 1] = {n + i, LE[dst]};\n    LE[dst] = 4 * i + 1;\n    E[4 * i + 2] = {src, LE[n + i]};\n    LE[n + i] = 4 * i + 2;\n    E[4 * i + 3] = {dst, LE[n + i]};\n    LE[n + i] = 4 * i + 3;\n\n    orig_edges[i] = {src, dst};\n  }\n\n  vector<int> cut_nodes;\n\n  constexpr int big_n = MAXN + MAXM;\n  int low[big_n]{0}, pre[big_n]{0}, parent[big_n]{0};\n  fill(parent, parent + big_n, -1);\n  int clk = 0;\n  struct dfsdata {\n    int id, parent;\n    bool after;\n  };\n  stack<dfsdata> dfs;\n\n  for (int i = 0; i < n + m; ++i) {\n    if (pre[i])\n      continue;\n    dfs.push({i, -1, false});\n    while (!dfs.empty()) {\n      dfsdata d = dfs.top();\n      dfs.pop();\n      if (pre[d.id] && !d.after && d.parent != -1)\n        low[d.parent] = min(low[d.parent], pre[d.id]);\n      if (pre[d.id] && d.after && d.parent != -1)\n        low[d.parent] = min(low[d.parent], low[d.id]);\n      if (!pre[d.id]) {\n        pre[d.id] = ++clk;\n        low[d.id] = pre[d.id];\n        parent[d.id] = d.parent;\n        dfs.push({d.id, d.parent, true});\n        for (int j = LE[d.id]; j != -1; j = E[j].next)\n          dfs.push({E[j].to, d.id, false});\n      }\n    }\n  }\n\n  int n_children[big_n]{0};\n  for (int i = 0; i < n + m; ++i)\n    if (parent[i] != -1)\n      ++n_children[parent[i]];\n\n  for (int i = 0; i < n + m; ++i) {\n    if (parent[i] == -1 && n_children[i] > 1)\n      cut_nodes.push_back(i);\n    if (parent[i] != -1 && parent[parent[i]] != -1 && low[i] >= pre[parent[i]])\n      cut_nodes.push_back(parent[i]);\n  }\n\n  set<pair<int, int>> cut_edges;\n  for (int u : cut_nodes) {\n    if (u >= n) {\n      cut_edges.insert(orig_edges[u - n]);\n    }\n  }\n  for (auto p : cut_edges) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nclass low_link_tree {\n\tint n;\n\tint tmr = 0;\n\tint rt = 0;\n\tvector<int> ord;\n\tvector<int> low;\n\tset<int> atc;\n\tset<pair<int, int>> bdg;\n\tvector<vector<int>> grh;\npublic:\n\tlow_link_tree (\n\t\tvector<vector<int>> const& grh\n\t)\n\t: n(grh.size())\n\t, ord(n, -1)\n\t, low(n, -1)\n\t, grh(grh)\n\t{\n\t\tdfs(0, 0);\n\t}\n\tvoid dfs (\n\t\tint crr\n\t,\tint prt\n\t) {\n\t\tint cnt = 0;\n\t\tord[crr] = low[crr] = tmr++;\n\t\tfor (int nxt : grh[crr]) {\n\t\t\tif (ord[nxt] == -1) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, crr);\n\t\t\t\tchmin(low[crr], low[nxt]);\n\t\t\t\tif (crr != rt && ord[crr] <= low[nxt]) atc.insert(crr);\n\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));\n\t\t\t}\n\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);\n\t\t}\n\t\tif (crr == rt && cnt > 1) atc.insert(crr);\n\t}\n\tauto const &order() {return ord;}\n\tauto const &low_link() {return low;}\n\tauto const &articulation_points() {return atc;}\n\tauto const &bridges() {return bdg;}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tauto bdg = low_link_tree(grh).bridges();\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T> >;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T> >;\nusing UnWeightedGraph = vector<vector<int> >;\ntemplate<typename T>\nusing Matrix = vector<vector<T> >;\n\ntemplate<typename G>\nstruct LowLink {\n    const G &g;\n    vector<int> used, ord, low;\n    vector<int> articulation;\n    vector<pair<int, int> > bridge;\n\n    LowLink(const G &g) : g(g) {}\n\n    int dfs(int idx, int k, int par) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_articulation = false;\n        int cnt = 0;\n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                ++cnt;\n                k = dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_articulation |= ~par && low[to] >= ord[idx];\n                if (ord[idx] < low[to]) bridge.emplace_back(minmax(idx, (int) to));\n            } else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if (is_articulation) articulation.push_back(idx);\n        return k;\n    }\n\n    virtual void build() {\n        used.assign(g.size(), 0);\n        ord.assign(g.size(), 0);\n        low.assign(g.size(), 0);\n        int k = 0;\n        for (int i = 0; i < g.size(); i++) {\n            if (!used[i]) k = dfs(i, k, -1);\n        }\n    }\n};\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n\n    UnWeightedGraph g(v);\n\n    rep(i, e) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n\n    LowLink<UnWeightedGraph> lowlink(g);\n    lowlink.build();\n    sort(lowlink.bridge.begin(), lowlink.bridge.end());\n    for (auto &a : lowlink.bridge) printf(\"%d %d\\n\", a.first, a.second);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\n\nint n, m;\nvector<vector<int>> g(100000 + 6);\n\nint ord[100000 + 6], low[100000 + 6];\nbool visited[100000 + 6];\n\nvector<pair<int, int>> Bridges;\nvector<int> Points;\n\nvoid dfs(int now, int par, int &cnt) {\n    visited[now] = true;\n    ord[now] = cnt++;\n    low[now] = ord[now];\n    bool check = false;\n    int outdeg = 0;\n    for (auto nx : g[now]) {\n        if (nx == par) continue;\n        if (!visited[nx]) {\n            outdeg++;\n            dfs(nx, now, cnt);\n            low[now] = min(low[now], low[nx]);\n            //???????????????\n            if (ord[now] < low[nx]) {\n                Bridges.push_back({min(now, nx), max(now, nx)});\n            }\n            //??¢??????????????????\n            if (par != -1 && !check && ord[now] <= low[nx]) {\n                check = true;\n                Points.push_back(now);\n            }\n        }\n        else {\n            low[now] = min(low[now], ord[nx]);\n        }\n    }\n    //???????????????????????\\?????¢????????¨???????????????\n    if (par == -1 && outdeg >= 2) {\n        Points.push_back(now);\n    }\n    return;\n}\n\nvoid lowlink (int n, vector<vector<int>>& g) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1, cnt);\n        }\n    }\n    sort(all(Bridges));\n    sort(all(Points));\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    lowlink(n, g);\n    rep(i, Bridges.size()) {\n        cout << Bridges[i].fi << \" \" << Bridges[i].se << endl;\n    }\n    /*\n    rep(i, Points.size()) {\n        cout << Points[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\nstruct LowLink {\n    int n;\n    vector<int> ord, low, data, ArticulationPoints;\n    vector<pair<int, int>> Bridge;\n    LowLink(vector<vector<int>>& g, int s = 0)\n        : n(sz(g)), ord(n, -1), low(n), data(n, -1) {\n        int k = 0;\n        dfs(s, -1, k, g);\n        sort(all(ArticulationPoints));\n        sort(all(Bridge));\n    }\n    int root(int x) {\n        return (data[x] < 0) ? x : data[x] = root(data[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    void dfs(int now, int pre, int& k, vector<vector<int>>& g) {\n        ord[now] = k;\n        k++;\n        low[now] = ord[now];\n        bool ok = 0;\n        int cnt = 0;\n        for (int nxt : g[now]) {\n            if (nxt == pre) continue;\n            if (ord[nxt] == -1) {\n                dfs(nxt, now, k, g);\n                chmin(low[now], low[nxt]);\n                cnt++;\n                if (low[nxt] >= ord[now]) {\n                    ok = 1;\n                }\n                if (ord[now] < low[nxt]) {\n                    Bridge.emplace_back(min(now, nxt), max(now, nxt));\n                } else {\n                    unite(now, nxt);\n                }\n            } else {\n                chmin(low[now], ord[nxt]);\n            }\n        }\n        if (pre == -1) {\n            if (cnt > 1) ArticulationPoints.push_back(now);\n        } else {\n            if (ok) ArticulationPoints.push_back(now);\n        }\n    }\n};\nstruct TwoEdgeConnectedComponents : LowLink {\n    int n;\n    vector<int> comp;\n    TwoEdgeConnectedComponents(vector<vector<int>>& g, vector<vector<int>>& t,\n                               int s = 0)\n        : n(sz(g)), comp(n, -1), LowLink(g, s) {\n        int k = 0;\n        rep(i, n) {\n            if (comp[root(i)] == -1) {\n                comp[root(i)] = k;\n                k++;\n            }\n        }\n        t.resize(k);\n        for (auto p : Bridge) {\n            int u, v;\n            tie(u, v) = p;\n            t[comp[root(u)]].push_back(comp[root(v)]);\n            t[comp[root(v)]].push_back(comp[root(u)]);\n        }\n    }\n    int operator[](int& x) {\n        return comp[root(x)];\n    }\n};\nstruct LowestCommonAncestor {\n    int n, sn;\n    vector<int> id, vs, dep;\n    vector<pair<int, int>> node;\n    LowestCommonAncestor(vector<vector<int>> g, int root = 0)\n        : n(sz(g)), id(n), vs(n * 2 - 1), dep(n * 2 - 1) {\n        int k = 0;\n        dfs(root, -1, 0, k, g);\n        sn = 1;\n        while (sn < sz(dep)) {\n            sn *= 2;\n        }\n        node.assign(2 * sn - 1, make_pair(INF, INF));\n        for (int i = 0; i < sz(dep); i++) {\n            node[sn + i - 1] = make_pair(dep[i], i);\n        }\n        for (int i = sn - 1; i >= 1; i--) {\n            node[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n    void dfs(int now, int pre, int d, int& k, const vector<vector<int>>& g) {\n        id[now] = k;\n        vs[k] = now;\n        dep[k++] = d;\n        for (int nxt : g[now]) {\n            if (nxt == pre) continue;\n            dfs(nxt, now, d + 1, k, g);\n            vs[k] = now;\n            dep[k++] = d;\n        }\n    }\n    pair<int, int> query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = sn;\n        if (r <= a || b <= l) return make_pair(INF, INF);\n        if (a <= l && r <= b) return node[k];\n        auto vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        auto vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n    int get(int u, int v) {\n        int l = min(id[u], id[v]);\n        int r = max(id[u], id[v]) + 1;\n        return vs[query(l, r).second];\n    }\n    int depth(int u) {\n        return dep[id[u]];\n    }\n    int dist(int u, int v) {\n        return depth(u) + depth(v) - 2 * depth(get(u, v));\n    }\n};\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    while (m--) {\n        int u, v;\n        cin >> u >> v;\n        // u--;\n        // v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    LowLink lk(g);\n    for (auto p : lk.Bridge) cout << p.first << \" \" << p.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1000005;\nconst int MAXE=1000005;\ntypedef pair<int,int> ii;\nvector <int> adj[MAXN];\nii ec[MAXE];\nint prof[MAXN],low[MAXN],padre[MAXN],cont,N,M,a,b,nec;\nbool usa[MAXN];\nvoid bridge(int v){\n    int child=0; //contara el n??mero de hijos en el DFST (DFS Tree)\n    usa[v]=true;\n    //low nos dice el ancestro m??s alto al que apunta alguno de los descendientes de v en DFST\n    //prof nos dice en que tiempo se visitaron los nodos en el DFS\n    low[v]=prof[v]=++cont;\n    for (int i=0; i<(int)adj[v].size(); i++){\n        int w=adj[v][i];\n        if (!usa[w]){\n            child++;\n            padre[w]=v;\n            bridge(w);\n            low[v]=min(low[v],low[w]);\n            //(v,w) ser?? una arista de corte si:\n            //no podemos alcanzar a ninguno de los ancestros\n            //de v o a v desde el ??rbol enraizado en w\n            if (low[w]>prof[v])ec[nec++]=make_pair(v,w);\n        } else if(w!=padre[v]) low[v]=min(low[v],prof[w]);\n    }\n}\nint main()\n{\n    //Asumimos que el grafo es conexo, no dirigido y simple\n    //En caso de no ser conexo lo hacemos para cada componente conexa\n    scanf(\"%d%d\",&N,&M);\n    for (int i=0; i<M; i++){\n        scanf(\"%d%d\",&a,&b);\n        adj[a].push_back(b); adj[b].push_back(a);\n    }\n    //Inicializamos los padres\n    fill(padre,padre+N,-1);\n    //En caso de ser multicaso inicializar prof,low,usa,ec,nec\n    bridge(0);\n    //ordenamos los puentes para mostrarlas en orden\n    sort(ec,ec+nec);\n    //en ec tenemos los puentes\n    for (int i=0; i<nec; i++)printf(\"%d %d\\n\",ec[i].first,ec[i].second);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nvector<int> E[200000];\nvector<pair<int,int> > res;\n\nvoid dfs(int n,int prev) {\n    bool flag=false;\n    while(!E[n].empty()) {\n        int t=E[n].back(); E[n].pop_back();\n        if(t==prev) { flag=true; continue; }\n        dfs(t,n);\n    }\n    if(flag) E[n].push_back(prev);\n}\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        E[s].push_back(t);\n        E[t].push_back(s);\n    }\n    dfs(0,-1);\n\n    for(int i=0;i<v;i++) {\n        for(int j=0;j<E[i].size();j++)\n            res.push_back(pair<int,int>(-min(E[i][j],i),-max(E[i][j],i)));\n    }\n    sort(res.begin(), res.end());\n\n    while(!res.empty()) {\n        printf(\"%d %d\\n\",-res.back().first,-res.back().second);\n        res.pop_back();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n\nstruct Lowlink{\n    ll n;\n    vector<vector<ll> > g;\n    vector< mp > bridge;\n    vector< ll > articulation;\n    vector< ll > ord , low;\n    vector< bool > used;\n    Lowlink(){}\n    Lowlink( ll n ):n(n){\n\tg = vector<vector<ll> >(n);\n\tord = vector<ll>(n);\n\tlow = vector<ll>(n);\n\tused = vector<bool>(n,false);\n    }\n    void add_edge( ll s , ll t ){\n\tg[s].push_back( t );\n\tg[t].push_back( s );\n    }\n    void solve(){\n\tll k = 0;\n\tfor(ll i=0;i<n;i++)if( !used[i] )dfs( i , -1 , k );\n\tsort( bridge.begin(),bridge.end() );\n\tsort( articulation.begin(),articulation.end() );\n    }\n    void dfs(ll v, ll p ,ll &k){\n\tused[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\tbool isarticulation = false;\n\tll cnt = 0;\n\tfor(ll i=0;i<g[v].size();i++){\n\t    if( !used[ g[v][i] ] ){\n\t\tcnt++;\n\t\tdfs(g[v][i],v,k);\n\t\tlow[v] = min( low[v] , low[ g[v][i] ] );\n\t\tif( ~p && ord[v] <= low[g[v][i]])isarticulation = true;\n\t\tif( ord[v] < low[ g[v][i] ] )bridge.push_back( mp( min( v, g[v][i] ) , max( v, g[v][i] ) ) );\n\t    }else if( g[v][i] != p ){\n\t\tlow[v] = min( low[v] , ord[ g[v][i] ] );\n\t    }\n\t}\n\tif( p==-1 && cnt > 1 )isarticulation = true;\n\tif( isarticulation ) articulation.push_back( v );\n    }\n};\n\nint main(){\n    ll v,e;\n    cin>>v>>e;\n    Lowlink L(v);\n    for(ll i=0;i<e;i++){\n\tll s,t;\n\tcin>>s>>t;\n\tL.add_edge( s,t );\n    }\n    L.solve();\n    for(auto i:L.bridge ){\n\tcout<<i.first<<' '<<i.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass BRI{\n\tpublic:\n\tint N;\n\tvi used;\n\tvvi G;\n\tvp bridge;\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\tBRI(int size){\n\t\tN=size;\n\t\tG=vvi(N);\n\t}\n\tint dfs(int i,int prev,int &n){\n\t\tif(used[i])return used[i];\n\t\tint m=n;\n\t\tused[i]=n++;\n\t\trep(j,G[i].size()){\n\t\t\tif(prev==G[i][j])continue;\n\t\t\tif(used[i]<used[G[i][j]])continue;\n\t\t\tint res=dfs(G[i][j],i,n);\n\t\t\tm=min(m,res);\n\t\t\tif(used[i]<res)bridge.pb(pii(min(i,G[i][j]),max(i,G[i][j])));\n\t\t}\n\t\treturn m;\n\t}\n\tvoid bri(){\n\t\tused=vi(N);\n\t\tbridge=vp(0);\n\t\tint n=1;\n\t\trep(i,N)if(!used[i])dfs(i,-1,n);\n\t\tsort(all(bridge));\n\t\trep(i,bridge.size())cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>;\nusing WeightedGraph = vector<vector <P>>; //to cost\nusing UnWeightedGraph = vector<vector<int>>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n#define DUMPOUT cerr\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T,U> &p_var) {\n    is >> p_var.first >> p_var.second;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<vector<T>> &df) {\n    for(int i=0;i<df.size();i++)for(int j=0;j<df[i].size();j++)\n    is >> df[i][j];\n    return is;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    //DUMPOUT<<'{';\n    os << pair_var.first;\n    //DUMPOUT<<',';\n    os << \" \"<< pair_var.second;\n    //DUMPOUT<<'}';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &vec) {\n    DUMPOUT<<'[';\n    for (int i = 0; i < vec.size(); i++) \n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    DUMPOUT<<']';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> &df) {\n  for (auto& vec : df) os<<vec;\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    DUMPOUT << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    DUMPOUT << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\nvoid print() {cout << endl;}\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(tail) != 0) cout << \" \";\n  print(forward<Tail>(tail)...);\n}\nvoid dump_func() {DUMPOUT << '#'<<endl;}\ntemplate <typename Head, typename... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\ntemplate <typename G>\nstruct Lowlink {\n    const G &g;\n    vector <int> used, ord, low;\n    vector <int> articulation;\n    vector <pair<int,int>> bridge;\n\n    Lowlink(const G &g) : g(g){\n        used.assign(g.size(), 0);\n        ord.assign(g.size(), 0);\n        low.assign(g.size(), 0);\n        int k = 0;\n        for(int i = 0; i < g.size(); i++) {\n            if(!used[i]) k = dfs(i, k, -1);\n        }\n    }\n\n    int dfs(int now, int k, int par){\n        used[now] = true, low[now] = ord[now] = k++; \n        bool is_articulation = false;\n        int cnt = 0;\n        for(auto &to : g[now]){\n            if(!used[to]){\n                ++cnt;\n                k = (dfs(to, k, now));\n                low[now] = min(low[now], low[to]);\n                is_articulation |= ~par && low[to] >= ord[now];\n                if(ord[now]<low[to]) bridge.emplace_back(minmax(now, (int)to));\n            }else if(to != par){\n                low[now] = min(low[now], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if(is_articulation) articulation.push_back(now);\n        return k;\n    }\n};\nsigned main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    int v,e; cin>>v>>e;\n    vector <vector<int>> g(v,vector <int>());\n    rep(i,e){\n        int a,b; cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    struct Lowlink <UnWeightedGraph> ll(g);\n    auto ans = ll.bridge;\n    sort(ans.begin(),ans.end());\n    rep(i, ans.size()) print(ans[i]);\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\torder[x] = 1e9;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, min(visited[e.b], order[e.b]));\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, g);\n\n\tfor( auto e : es ){\n\t\tif( !visited[e.a] || !visited[e.b] || order[e.a] < order[e.b] ){\n\t\t\tcout << e.a << \" \" << e.b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint N, M, A[200009], B[200009], pre[200009], low[200009], cnts;\nvector<pair<int, int>> X[200009];\nvector<int> G;\n\nvoid dfs(int pos, int par) {\n\tcnts++;\n\tpre[pos] = cnts; low[pos] = cnts;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tint to = X[pos][i].first;\n\t\tif (low[to] == (1 << 30)) {\n\t\t\tdfs(to, pos);\n\t\t\tlow[pos] = min(low[pos], low[to]);\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\tG.push_back(X[pos][i].second);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (to == par) continue;\n\t\t\tlow[pos] = min(low[pos], low[to]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> A[i] >> B[i]; if (A[i] > B[i]) swap(A[i], B[i]);\n\t\tX[A[i]].push_back(make_pair(B[i], i));\n\t\tX[B[i]].push_back(make_pair(A[i], i));\n\t}\n\tfor (int i = 0; i <= N; i++) { pre[i] = (1 << 30); low[i] = (1 << 30); }\n\tdfs(0, -1);\n\tvector<pair<int, int>>F;\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tF.push_back(make_pair(A[G[i]], B[G[i]]));\n\t}\n\tsort(F.begin(), F.end());\n\tfor (int i = 0; i < F.size(); i++) cout << F[i].first << \" \" << F[i].second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\n\nint n, m;\nvector<vector<int>> g(1000000 + 6);\n\nint ord[1000000 + 6], low[1000000 + 6];\nbool visited[1000000 + 6];\n\nvector<pair<int, int>> Bridges;\nvector<int> Points;\n\nvoid dfs(int now, int par, int &cnt) {\n    visited[now] = true;\n    ord[now] = cnt++;\n    low[now] = ord[now];\n    bool check = false;\n    int outdeg = 0;\n    for (auto nx : g[now]) {\n        if (nx == par) continue;\n        if (!visited[nx]) {\n            outdeg++;\n            dfs(nx, now, cnt);\n            low[now] = min(low[now], low[nx]);\n            //???????????????\n            if (ord[now] < low[nx]) {\n                Bridges.push_back({min(now, nx), max(now, nx)});\n            }\n            //??¢??????????????????\n            if (par != -1 && !check && ord[now] <= low[nx]) {\n                check = true;\n                Points.push_back(now);\n            }\n        }\n        else {\n            low[now] = min(low[now], ord[nx]);\n        }\n    }\n    //???????????????????????\\?????¢????????¨???????????????\n    if (par == -1 && outdeg >= 2) {\n        Points.push_back(now);\n    }\n    return;\n}\n\nvoid lowlink (int n, vector<vector<int>>& g) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1, cnt);\n        }\n    }\n    sort(all(Bridges));\n    sort(all(Points));\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    lowlink(n, g);\n    rep(i, Bridges.size()) {\n        cout << Bridges[i].fi << \" \" << Bridges[i].se << endl;\n    }\n    /*\n    rep(i, Points.size()) {\n        cout << Points[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n\nconst int MAX_V = 1e5;\nvector<int> G[MAX_V];\n\nset<int> used_v;\nset<PII> used_e;\nint ord[MAX_V], lowlink[MAX_V];\nint k = 0;\n\nvoid calc_lowlink(int v)\n{\n    used_v.insert(v);\n    ord[v] = lowlink[v] = k++;\n\n    for (auto u : G[v]) {\n        if (!used_v.count(u)) {\n            used_e.insert(PII(v, u));\n            calc_lowlink(u);\n            lowlink[v] = min(lowlink[v], lowlink[u]);\n        } else if (!used_e.count(PII(u, v))) {\n            // backward edge\n            lowlink[v] = min(lowlink[v], ord[u]);\n        }\n    }\n}\n\nvector<PII> calc_bridge(int N)\n{\n    vector<PII> res;\n    for (int v=0; v<N; v++) {\n        for (auto u : G[v]) {\n            if (ord[v] < lowlink[u]) {\n                res.emplace_back(v, u);\n            }\n        }\n    }\n    return res;\n}\n\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    rep(i, M) {\n        int U, V;\n        cin >> U >> V;\n        // U--, V--;\n        G[U].push_back(V);\n        G[V].push_back(U);\n    }\n\n    calc_lowlink(0);\n    vector<PII> bridges = calc_bridge(N);\n    sort(bridges.begin(), bridges.end());\n\n    for (auto p : bridges) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    /*\n    rep(i, N) {\n        cout << ord[i] << \" \" <<  lowlink[i] << endl;\n    }\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Graph{\n  vector< vector<int> > edge;\n  vector<bool> visited;\n  vector<int> lowest, parent, prenum;\n  int timer;\n\n  Graph(int n) : edge(n), visited(n, false), lowest(n), parent(n, -1), prenum(n){\n    timer = 1;\n  }\n\n  void dfs(int now, int prev){\n    lowest[now] = prenum[now] = timer;\n    timer++;\n    visited[now] = true;\n\n    for(auto next:edge[now]){\n      if(!visited[next]){ //next = 子供\n        parent[next] = now;\n        dfs(next, now);\n        lowest[now] = min(lowest[now], lowest[next]);\n      }\n      else if(next != prev){ //BackEdge next = 親戚\n        lowest[now] = min(lowest[now], prenum[next]);\n      }\n    }\n  }\n\n  void bridge(){\n    dfs(0,1);\n\n    set< pair<int, int> > bridge;\n    for(int i = 0; i < prenum.size(); i++){\n      if(i == 0) continue;\n      if(prenum[parent[i]] < lowest[i]) bridge.insert({min(i, parent[i]), max(i, parent[i])});\n    }\n    for(auto b:bridge){\n      cout << b.first << \" \" << b.second << endl;\n    }\n  }\n};\n\nint main(){\n  int v, e;\n  cin >> v >> e;\n  Graph G = (v);\n  for(int i = 0; i < e; i++){\n    int s,t;\n    cin >> s >> t;\n    G.edge[s].push_back(t);\n    G.edge[t].push_back(s);\n  }\n  G.bridge();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PI 3.14159265358979323846\n#define MAXINF (1e18L)\n#define INF (1e9L)\n#define EPS (1e-9)\n#define MOD ((ll)(1e9+7))\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define ALL(v) v.begin(),v.end()\n#define FIND(v,x) (binary_search(ALL(v),(x)))\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v));reverse(ALL(v))\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define Yes(n) cout<<((n)?\"Yes\":\"No\")<<endl\n#define YES(n) cout<<((n)?\"YES\":\"NO\")<<endl\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ntemplate<class A>void pr(A a){cout << (a) << endl;}\ntemplate<class A,class B>void pr(A a,B b){cout << a << \" \"  ;pr(b);}\ntemplate<class A,class B,class C>void pr(A a,B b,C c){cout << a << \" \" ;pr(b,c);}\ntemplate<class A,class B,class C,class D>void pr(A a,B b,C c,D d){cout << a << \" \" ;pr(b,c,d);}\ntemplate<class T> inline bool chmin(T& a, T b){return a>b ? a=b, true : false;}\ntemplate<class T> inline bool chmax(T& a, T b){return a<b ? a=b, true : false;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll,ll> pll;\n\n// Low Linkを計算して橋と関節点を見つける\n// ref : http://kagamiz.hatenablog.com/entry/2013/10/05/005213\nstruct low_link\n{\n    int n, m;\n    vector<vector<int>> G;\n    vector<pair<int, int>> bridge;\n    vector<int> articulation;\n    vector<int> ord, low;\n    vector<bool> vis;\n\n    low_link(vector<vector<int>> G, int n, int m) : G(G), n(n), m(m)\n    {\n        ord.resize(n);\n        low.resize(n);\n        vis.resize(n);\n\n        int k = 0;\n        REP(i, n){\n            if(!vis[i]) dfs(i, -1, k);\n        }\n\n        SORT(bridge);\n        SORT(articulation);\n    }\n\n    vector<pair<int, int>> get_bridge(){\n        return bridge;\n    }\n\n    vector<int> get_articulation(){\n        return articulation;\n    }\n\nprivate:\n    void dfs(int v, int p, int &k)\n    {\n        vis[v] = true;\n        \n        ord[v] = k++;\n        low[v] = ord[v];\n        \n        bool isArticulation = false;\n        int ct = 0;\n        \n        // for (int i = 0; i < G[v].size(); i++){\n        for (auto&& c : G[v]){\n            if (!vis[c]){\n                ct++;\n                dfs(c, v, k);\n                low[v] = min(low[v], low[c]);\n                if (~p && ord[v] <= low[c]) isArticulation = true;\n                if (ord[v] < low[c]) bridge.push_back(make_pair(min(v, c), max(v, c)));\n            }\n            else if (c != p){\n                low[v] = min(low[v], ord[c]);\n            }\n        }\n        \n        if (p == -1 && ct > 1) isArticulation = true;\n        if (isArticulation) articulation.push_back(v);\n    }\n};\n\nint main(void)\n{\n    int v,e;\n    cin >> v >> e;\n    vector<vector<int>> G(v);\n    REP(i, e){\n        int s,t;\n        cin >> s >> t;\n        G[s].pb(t);\n        G[t].pb(s);\n    }\n\n    low_link low(G, v, e);\n    auto b = low.get_bridge();\n    for(auto&& bi : b){\n        pr(bi.fi, bi.se);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n\nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\ntypedef std::pair<long, long> P;\n\nlong v, e;\nstd::vector<long> edge[100005];\nlong depth[100005], lowlink[100005];\nstd::vector<P> ans;\n\nvoid dfs(long par, long vis){\n  for(int i = 0; i < edge[vis].size(); i++){\n    long nx = edge[vis][i];\n    if(depth[nx] == LINF){\n      lowlink[nx] = depth[nx] = depth[vis]+1;\n      dfs(vis, nx);\n      lowlink[vis] = std::min(lowlink[vis], lowlink[nx]);\n    }else{\n      if(nx != par){\n        lowlink[vis] = std::min(lowlink[vis], depth[nx]);\n      }\n    }\n  }\n}\n\nint main(){\n  scanf(\"%ld%ld\", &v, &e);\n  for(int i = 0; i < e; i++){\n    long a, b;\n    scanf(\"%ld%ld\", &a, &b);\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  for(int i = 0; i < v; i++){\n    depth[i] = lowlink[i] = LINF;\n  }\n  depth[0] = lowlink[0] = 0;\n  dfs(0, 0);\n  /*\n  for(int i = 0; i < v; i++){\n    printf(\"%ld (%ld,%ld)\\n\", i, depth[i], lowlink[i]);\n  }\n  //*/\n  for(long i = 0; i < v; i++){\n    for(int j = 0; j < edge[i].size(); j++){\n      long k = edge[i][j];\n      if(depth[i] < lowlink[k]){\n        ans.push_back(P(std::min(i, k), std::max(i, k)));\n      }\n    }\n  }\n  std::sort(ans.begin(), ans.end());\n  for(int i = 0; i < ans.size(); i++){\n    printf(\"%ld %ld\\n\", ans[i].first, ans[i].second);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\n\n//無向\nclass Bridge{\nprivate:\n    typedef vector<vector<ll>> edge;\n    edge E;\n    ll v;\n    vector<pll> count;\n    \n    ll dfs(ll w,ll depth,ll parent){\n        if(count[w].F!=-1){return 1e18;}\n        count[w]={depth,depth};\n        bool p=true;\n        for(int i=0;i<E[w].size();i++){\n            if(E[w][i]==parent){\n                if(!p){count[w].S=min(count[E[w][i]].F,count[w].S);}\n                p=false;\n            }\n            else if(count[E[w][i]].F==-1){count[w].S=min(dfs(E[w][i],depth+1,w),count[w].S);}\n            else{count[w].S=min(count[E[w][i]].F,count[w].S);}\n        }\n        return count[w].S;\n    }\n    \npublic:\n    Bridge(ll v,edge e={}):v(v),E(e){\n        E.resize(v);\n        count.resize(v,{-1,-1});\n    }\n    \n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n        E[to].push_back(from);\n    }\n    \n    void search(){\n        dfs(0,1,-1);\n    }\n    \n    bool is_bridge(ll u,ll v){\n        if(count[u].F==count[v].F){return false;}\n        if(count[u].F>count[v].F){swap(u,v);}\n        if(count[u].F>=count[v].S){return false;}\n        return true;\n    }\n    \n    vector<pll> bridge(){\n        vector<pll> ret;\n        for(int i=0;i<v;i++){\n            for(int t=0;t<E[i].size();t++){\n                if(i<E[i][t] && is_bridge(i,E[i][t])){ret.push_back({i,E[i][t]});}\n            }\n        }\n        return ret;\n    }\n    \n    void test(){\n        for(int i=0;i<v;i++){\n            cout<<\"test \"<<i<<\" \"<<count[i].F<<\" \"<<count[i].S<<endl;\n        }\n    }\n};\n\n\n\n\nint main(){\n    ll v,e;\n    cin>>v>>e;\n    Bridge B(v);\n    for(int i=0;i<e;i++){\n        ll s,t;\n        cin>>s>>t;\n        B.add_edge(s,t);\n    }\n    B.search();\n    vector<pll> b=B.bridge();\n    sort(b.begin(),b.end());\n    //B.test();\n    for(int i=0;i<b.size();i++){\n        cout<<b[i].F<<\" \"<<b[i].S<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\nvector<int> pa[maxn];\nint vis[maxn],low[maxn],dfn[maxn];\nint ind ;\nvector<int> g[maxn];\nvoid tarjan(int u,int p)\n{\n    dfn[u]=low[u]=++ind;\n    vis[u]=1;\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(v==p) continue;\n        if(!vis[v])\n        {\n            tarjan(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u]<low[v])\n                pa[u].push_back(v);\n        }\n        else low[u]=min(low[u],dfn[v]);\n    }\n}\nint v,e;\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    tarjan(0,-1);\n    for(int i=0;i<v;i++)\n    {\n        if(pa[i].size()>0)\n        {\n            for(int j=0;j<pa[i].size();j++)\n                printf(\"%d %d\\n\",i,pa[i][j]);\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\nstruct LowLink {\n    \n    vector < vector < int > > G;\n    vector < int > ord, low;\n    vector < bool > used;\n    vector < pair < int, int > > bridge;\n    vector < int > articulation_point;\n    const int INF = 1145141919;\n    \n    LowLink (int n) : G(n), ord(n), low(n), used(n) {}\n    \n    void add_edge(int a, int b) {\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    void build(int root) {\n        fill(low.begin(), low.end(), INF);\n        fill(used.begin(), used.end(), false);\n        dfs(root, -1, 1);\n    }\n    \n    int dfs(int v, int prev, int cnt) {\n        used[v] = true;\n        low[v] = ord[v] = cnt;\n        int min_low = cnt;\n        int route = 0;\n        bool isArticulation = false;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (!used[G[v][i]]) {\n                route++;\n                int low_nxt = dfs(G[v][i], v, cnt + 1);\n                if (ord[v] < low_nxt) {\n                    bridge.push_back(make_pair(v, G[v][i]));\n                }\n                if (prev != -1 && G[v].size() >= 2 && low_nxt >= cnt) {\n                    isArticulation = true;\n                }\n                min_low = min(min_low, low_nxt);\n            } else if (G[v][i] != prev) {\n                min_low = min(min_low, low[G[v][i]]);\n            }\n        }\n        if (prev == -1 && route > 1) isArticulation = true;\n        if (isArticulation) articulation_point.push_back(v);\n        return low[v] = min_low;\n    }\n    \n};\n\n\nint main() {\n    \n    int V,E; cin >> V >> E;\n    LowLink inst(100010);\n    \n    REP(i,E) {\n        int a,b; cin >> a >> b;\n        inst.add_edge(a, b);\n    }\n    \n    inst.build(0);\n    \n    vector < pair < int, int > > ans;\n    \n    REP(i,inst.bridge.size()) {\n        int a = min(inst.bridge[i].first, inst.bridge[i].second);\n        int b = max(inst.bridge[i].first, inst.bridge[i].second);\n        ans.push_back(make_pair(a, b));\n    }\n    \n    sort(ans.begin(), ans.end());\n    REP(i,ans.size()) {\n        cout << ans[i].first << \" \" << ans[i].second << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define V 100000\n\nint v, e;\nvector<int> g[V];\nvector<P> ans;\nbool used[V], fin[V];\nint memo[V];\n\nint dfs(int v, int f) {\n  int cnt = 0;\n  used[v] = true;\n  rep(i, g[v].size()) {\n    int t = g[v][i];\n    if(used[t]) {\n      if(t != f && !fin[t]) {\n        cnt += 1;\n        memo[t] += 1;\n      }\n    } else {\n      int res = dfs(t, v);\n      if(res == 0) {\n        ans.push_back(v < t ? P(v, t) : P(t, v));\n      }\n      cnt += res;\n    }\n  }\n  cnt -= memo[v];\n  fin[v] = true;\n  return cnt;\n}\n\nint main() {\n  cin >> v >> e;\n  rep(i, e) {\n    int s, t;\n    cin >> s >> t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  dfs(0, -1);\n  sort(ALL(ans));\n  rep(i, ans.size()) {\n    P &e = ans[i];\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <map>\n#include <string>\n#define maxn 100005\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m;\nint dfn[maxn],low[maxn],ind;\nvector <int> adj[maxn];\nvector <P> ans;\nvoid tarjan(int u,int f){\n  dfn[u] = low[u] = ++ind;\n  for(int i=0;i<adj[u].size();i++){\n    int v = adj[u][i];\n      if(dfn[v] == 0){\n        tarjan(v,u);\n        low[u] = min(low[u],low[v]);\n      }else if(v != f){\n        low[u] = min(low[u],dfn[v]);\n      }\n  }\n  if(dfn[u] == low[u]){\n  \tif(u >= f) swap(u,f);\n  \tif(u != -1) ans.push_back(mp(u,f));\n  }\n}\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=m;i++){\n  \tint u,v;\n  \tscanf(\"%d%d\",&u,&v);\n  \tadj[u].push_back(v);\n  \tadj[v].push_back(u);\n  }\n  for(int i=0;i<n;i++){\n  \tif(dfn[i] == 0) tarjan(i,-1);\n  }\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++){\n  \tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); i ++)\nusing namespace std;\nusing ll = long long;\nusing PL = pair<ll,ll>;\nusing P = pair<int,int>;\nconstexpr int INF = 1000000000;\nconstexpr long long HINF = 1000000000000000;\nconstexpr long long MOD = 1000000007;\nconstexpr double EPS = 1e-4;\nconstexpr double PI = 3.14159265358979;\n\nstruct LowLink {\n    int N;\n    vector<vector<int>> G;\n    vector<int> low,ord,articulation;\n    vector<P> bridge;\n\n    LowLink(int N, vector<vector<int>> &G): N(N),G(G),low(N,-1),ord(N,-1) {}\n\n    void dfs(int v,int time,int p = -1) {\n        ord[v] = low[v] = time;\n        ++time;\n\n        bool isArticulation = false;\n        int cnt = 0;\n\n        for (int e:G[v]) {\n            if (low[e] < 0) {\n                ++cnt;\n                dfs(e,time,v);\n                low[v] = min(low[v],low[e]);\n                if (p != -1 && ord[v] <= low[e]) isArticulation = true;\n                if (ord[v] < low[e]) {\n                    if (v < e) bridge.push_back({v,e});\n                    else bridge.push_back({e,v});\n                }\n            }\n            else if (p != e) {\n                low[v] = min(low[v],ord[e]);\n            }\n        }\n\n        if (p == -1 && cnt >= 2) isArticulation = true;\n        if (isArticulation) articulation.push_back(v);\n    }\n\n    void build() {\n        dfs(0,0);\n    }\n};\n\nint main() {\n    int V,E; cin >> V >> E;\n    vector<vector<int>> G(V);\n    rep(_,E) {\n        int a,b; cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    LowLink lol(V,G);\n    lol.build();\n    vector<P> ans = lol.bridge;\n    sort(ans.begin(),ans.end());\n    rep(i,ans.size()) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 200002, E = 200002;\n\nvector <int> g[N], cvs;\nvector <pair<int, int>> ces;\nint up[N], h[N], from[E], to[E];\nbool mark[N];\n\nint cecvme(int v, int pare = -1) // With multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int e : g[v])\n\t\tif(e != pare)\n\t\t{\n\t\t\tint u = to[e] ^ from[e] ^ v;\n\t\t\tif(mark[u])\n\t\t\t\tup[v] = min(up[v], h[u]);\n\t\t\telse\n\t\t\t{\n\t\t\t\th[u] = h[v] + 1;\n\t\t\t\tup[v] = min(up[v], cecvme(u, e));\n\t\t\t\tif(up[u] >= h[v] && pare != -1)\n\t\t\t\t\tcvs.push_back(v);\n\t\t\t\tchildren++;\n\t\t\t}\n\t\t}\n\tif(pare != -1 && up[v] == h[v])\n\t\tces.push_back({from[pare] ^ to[pare] ^ v, v}); // pare\n\tif(pare == -1 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n \nint cecv(int v, int par) // Without multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int u : g[v])\n\t{\n\t\tif(mark[u] && u != par)\n\t\t\tup[v] = min(up[v], h[u]);\n\t\tif(!mark[u])\n\t\t{\n\t\t\th[u] = h[v] + 1;\n\t\t\tup[v] = min(up[v], cecv(u, v));\n\t\t\tif(up[u] >= h[v] && h[v] > 0)\n\t\t\t\tcvs.push_back(v);\n\t\t\tchildren++;\n\t\t}\n\t}\n\tif(h[v] > 0 && up[v] == h[v])\n\t\tces.push_back({par, v});\n\tif(h[v] == 0 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n\nint main()\n{\n\tint n = in(), m = in();\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u = in(), v = in();\n\t\tg[u].push_back(i);\n\t\tg[v].push_back(i);\n\t\tfrom[i] = u;\n\t\tto[i] = v;\n\t}\n\th[0] = 0;\n\tcecvme(0, -1);\n\tfor(auto &e : ces)\n\t\tif(e.first > e.second)\n\t\t\tswap(e.first, e.second);\n\tsort(ces.begin(), ces.end());\n\tfor(auto e : ces)\n\t\tcout << e.first << \" \" << e.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <set>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\n\nusing Gragh = vector<vector<int>>;\nstruct LowLink\n{\n    int V;\n    Gragh G;\n    vector<int> used, order, lowlink, articulation;\n    vector<pair<int, int>> bridges;\n    LowLink(int V) : V(V)\n    {\n        G.resize(V);\n        used.resize(V, 0);\n        order.resize(V, 0);\n        lowlink.resize(V, 0);\n    }\n    void add_edge(int s, int t) { G[s].emplace_back(t); }\n    void dfs(int v, int p)\n    {\n        static int k = 0;\n        used[v] = 1;\n        order[v] = lowlink[v] = k++;\n        int cnt = 0;\n        bool flag = false;\n        for(auto &u : G[v])\n        {\n            if(not used[u])\n            {\n                cnt++;\n                dfs(u, v);\n                lowlink[v] = min(lowlink[v], lowlink[u]);\n                if(order[v] <= lowlink[u] and p != -1) flag = true;\n                if(order[v] < lowlink[u]) bridges.emplace_back(min(v, u), max(v, u));\n            }\n            else if(u != p) lowlink[v] = min(lowlink[v], order[u]);\n        }\n        if(p == -1 and cnt > 1) flag = true;\n        if(flag) articulation.push_back(v);\n    }\n    void build() { dfs(0, -1); }\n};\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E; cin >> V >> E;\n    LowLink L(V);\n    for(int i = 0; i < E; i++)\n    {\n        int s, t; cin >> s >> t;\n        L.add_edge(s, t);\n        L.add_edge(t, s);\n    }\n    L.build();\n    sort(L.bridges.begin(), L.bridges.end());\n    for(auto ans : L.bridges) cout << ans.first << \" \" << ans.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  search_bridges\n//\n//  Created by ???????????? ???????´???°?????? on 26.06.15.\n//  Copyright (c) 2015 company. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid is_bridge(const std::vector<std::vector<int> > &graph, std::vector<std::pair<int, int> >& bridges, const int v, const int u) {\n    //    if (std::count(graph[v].begin(), graph[v].end(), u) == 1) {\n    if (v < u) bridges.push_back(std::make_pair(v, u));\n    else bridges.push_back(std::make_pair(u, v));\n    //    }\n}\n\nvoid DFS(const std::vector<std::vector<int> > &graph, std::vector<bool> &used, std::vector<int> &tin, std::vector<int> &fup,\n         std::vector<std::pair<int, int> > &bridges, int timer, int v, int parent = -1) {\n    \n//    std::copy(graph[v].begin(), graph[v].end(), std::ostream_iterator<size_t>(std::cout, \" \")); std::cout << '\\n';\n    \n    used[v] = true;\n    tin[v] = fup[v] = timer++;\n    for (int i = 0; i < graph[v].size(); ++i) {\n        int to = graph[v][i];\n        if (to == parent) continue;\n        if (used[to]) {\n            fup[v] = std::min(fup[v], tin[to]);\n        }\n        else {\n            DFS(graph, used, tin, fup, bridges, timer, to, v);\n            fup[v] = std::min(fup[v], fup[to]);\n            if (fup[to] > tin[v]) {\n                is_bridge(graph, bridges, v, to);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n    \n    std::vector<std::vector<int> > graph (N);\n    for (size_t i = 0; i < M; ++i) {\n        int from, to;\n        std::cin >> from >> to;\n        graph[from].push_back(to);\n        graph[to].push_back(from);\n    }\n    \n    std::vector<bool> used (N);\n    std::fill(used.begin(), used.end(), false);\n    \n    std::vector<int> tin (N), fup (N);\n    std::vector<std::pair<int, int> > bridges;\n    int timer = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        if (!used[i]) {\n            DFS(graph, used, tin, fup, bridges, timer, i);\n        }\n    }\n    std::sort(bridges.begin(), bridges.end());\n    \n    for (auto& edge: bridges) {\n        std::cout << edge.first << ' ' << edge.second << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n//関節点:  O(V + E)\nclass Articulation{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;           //ord[i] := ノードiに訪れた順番\n  vector<int> low;           //low[i] := ノードiから訪れることができる最小のord[j]の値。\n  vector<int> articulation;\n  int ok;\n\n  Articulation():V(-1),ok(false){};\n  Articulation(int V):V(V),G(V),ord(V),low(V),articulation(V),ok(false){};\n  \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a < V && b < V);\n    assert(a >=0 && b >= 0);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void build(int start = 0){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    articulation.clear(); articulation.resize(V,0);\n\n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) {\n        if(to == pre) continue; \n        if(ord[to] != -1) low[pos] = min(low[pos], ord[to]);\n        else {\n          low[pos] = min(low[pos], dfs(to, pos));\n          \n          if(pos == start) articulation[pos]++;\n          else articulation[pos] |= ord[pos] <= low[to];\n        }\n      }\n      if(pos == start) articulation[pos] = articulation[pos] >= 2;\n      return low[pos];\n    };\n    dfs(start , -1);\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n  \n  int isArticulation(int a){\n    assert(ok);\n    assert(a >= 0 && a < V);\n    return articulation[a];\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int V, E;\n  cin>>V>>E;\n  \n  Articulation A(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    A.add_edge(a,b);\n  }\n  \n  A.build();\n\n    vector<P> ans;\n    for(int i=0;i<V;i++)\n      for(int to:A.G[i]) if(i < to && A.isBridge(i, to)) ans.push_back(P(i, to));\n    \n    for(auto a:ans) cout<<a.first<<\" \"<<a.second<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,bool> P;\nvector<P> E[100010];\nvector<int> res;\nint o[100010];\n\n\nint dfs(int i,int &n) {\n//    printf(\": %d %d\\n\", i,n);\n    if(o[i]) {\n        o[i] = min(n, o[i]);\n        return o[i];\n    }\n    o[i] = n;\n    for(vector<P>::iterator it=E[i].begin(); it != E[i].end(); it++) {\n        if(it->second) continue;\n    for(vector<P>::iterator is=E[it->first].begin(); is != E[it->first].end(); is++)\n        if(is->first == i) {\n            is->second = true;\n        }\n        o[i] = min(o[i], dfs(it->first, ++n));\n    }\n    return o[i];\n}\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0; i<e; i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        E[s].push_back(P(t,false));\n        E[t].push_back(P(s,false));\n    }\n    for(int i=0; i<v; i++)\n        sort(E[i].begin(), E[i].end());\n\n    int n=1;\n    dfs(0,n);\n\n/*    for(int i=0; i<v; i++)\n        printf(\"%d \",o[i]);\n    printf(\"\\n\");\n*/\n    for(int i=0; i<v; i++)\n        for(vector<P>::iterator it = E[i].begin(); it != E[i].end(); it++) {\n            if(i > it->first) continue;\n            if(o[i] == o[it->first]) continue;\n            printf(\"%d %d\\n\",i,it->first);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  int V;\n  BiconectedGraph(){}\n  BiconectedGraph(int n){\n    G.clear();\n    C.clear();\n    T.clear();\n    G.resize(n);\n    C.resize(n);\n    T.resize(n);\n  }\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  void build(int n){\n    int k=0;\n    ord.clear();\n    ord.resize(n,-1);\n    low.clear();\n    low.resize(n);\n    belong.clear();\n    belong.resize(n,-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    add_component(0,k);\n    V=k;\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n  }\n};\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    bcc.add_edge(s,t);\n  }\n  bcc.build(v);\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,t,A[N],used[N],depth[N];\nvector<int> G[N];\nvector<P> ans;\n\nvoid dfs(int x,int d,int prev){\n  depth[x]=d;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(nx==prev)continue;\n    if(!used[nx]){\n      used[nx]=true;\n      dfs(nx,d+1,x);\n      if(!A[nx])\n\tans.push_back(P(min(x,nx),max(x,nx)));\n      A[x]+=A[nx];\n    }\n    else if(d>depth[nx])A[nx]--,A[x]++;\n  }\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  used[0]=1;\n  dfs(0,0,0);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i].first<<' '<<ans[i].second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\n//橋＋二重辺連結成分\n// verified by AOJ\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1091182#1\nnamespace __bridge{\n\ttypedef vector<vector<int>> Graph;\n    //O(V+E (logV))\n\tclass Bridge{\n\tprivate:\n\t\tint N;Graph g;\n\t\tvector<int> ord,low;vector<bool> vis;\n\t\tvoid dfs(int v,int p,int &k){\n\t\t\tvis[v]=true;ord[v]=k++;low[v]=ord[v];\n\t\t\tfor(int to:g[v]){\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tdfs(to,v,k);\n\t\t\t\t\tlow[v]=min(low[v],low[to]);\n\t\t\t\t\tif(ord[v]<low[to])bridges.push_back(make_pair(min(v,to),max(v,to)));\n\t\t\t\t}else if(to != p){\n\t\t\t\t\tlow[v]=min(low[v],ord[to]);\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<pair<int,int>> bridges;vector<int> articulations;\n\t\tBridge(int N):N(N){\n\t\t\tg=Graph(N);ord=low=vector<int>(N);vis=vector<bool>(N);\n\t\t}\n\t\tvoid add_edge(int f,int t){\n\t\t\tg[f].push_back(t);g[t].push_back(f);\n\t\t}\n\t\tvoid bridge(){\n\t\t\tint k=0;REP(v,N)if(!vis[v])dfs(v,-1,k);\n\t\t\t// articulations\n\t\t\tREP(i,bridges.size())articulations.push_back(bridges[i].first),articulations.push_back(bridges[i].second);\n\t\t\tsort(ALL(articulations));\n\t\t\tarticulations.erase(unique(ALL(articulations)),articulations.end());\n\t\t}\n\t\tbool same(int i,int j){return low[i]==low[j];}\n\t};\n}\nusing namespace __bridge;\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint V,E;cin >> V >> E;\n\t\tBridge bg(V);\n\t\tREP(i,E){\n\t\t\tint s,t;cin >> s >> t;\n\t\t\tbg.add_edge(s,t);\n\t\t}\n\t\tbg.bridge();\n\t\tsort(ALL(bg.bridges));\n\t\tREP(i,bg.bridges.size())\n\t\t\tcout <<bg.bridges[i]<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class VData, class EData, class GData>\nstruct Graph;\n\nstruct DefVData {};\n\nstruct DefEData {\n  int len;\n  DefEData() : len(1) {}\n};\n\ntemplate<class VData=DefVData, class EData=DefEData, class GData=int>\nstruct SCCVData {\n  Graph<VData, EData, GData> g;\n  vector<int> cont2orig; // v on g -> cont2orig[v] on the original graph(G)\n  SCCVData(int n) : g(n) {}\n};\n\n// the actual edge(before contracted) is s -> t\nstruct SCCEData {\n  int len;\n  int s;\n  int t;\n  SCCEData() : len(1) {}\n  SCCEData(int a, int b) : len(1), s(a), t(b) {}\n};\n\nstruct SCCGData {\n  vector<int> orig2cont; // v on G -> orig2cont[v] on G.SCC.vdat[belong[v]].g\n};\n\ntemplate<class VData=DefVData, class EData=DefEData, class GData=int>\nstruct Graph {\n  struct Edge {\n    int to;\n    int rev_idx;\n    EData dat;\n  };\n  using Len = decltype(EData::len);\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  using Brid = pair<int, int>;\n  Len INF;\n\n  int n;\n  int grp; // the number of SCC\n  GData gdat;\n  vector<VData> vdat;\n  vector<Es> es;\n  vector<Es> res;\n  vector<Ls> cost;\n  vector<int> ord;\n  vector<int> low;\n  vector<int> belong;\n  vector<int> artic;\n  vector<Brid> bridge;\n  \n  Graph() {}\n  Graph(int sz, Len inf) {\n    Init(sz, inf);\n  }\n\n  void Init(int sz, Len inf) {\n    INF = inf;\n    n = sz;\n    vdat.resize(sz);\n    es.resize(sz);\n    res.resize(sz);\n  }\n\n  void AddEdge(int u, int v, EData d, EData r) {\n    es[u].emplace_back(Edge{v, 0, d});\n    res[v].emplace_back(Edge{u, 0, r});\n    es[u].back().rev_idx = res[v].size()-1;\n    res[v].back().rev_idx = es[u].size()-1;\n  }\n\n  void AddEdge(int u, int v, EData d=EData()) {\n    AddEdge(u, v, d, d);\n  }\n\n  Edge *GetRevEdge(Edge *e, bool is_es) {\n    int v = e->to;\n    if (is_es) return &res[v][e->rev_idx];\n    return &es[v][e->rev_idx];\n  }\n\n  // should be tested\n  template<class Cmp>\n  void EraseMultipleEdge(Cmp cmp, bool really_erase) {\n    auto same = [](const Edge &a, const Edge &b) {\n      return a.to == b.to;\n    };\n\n    for (auto &ves : es) {\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n    }\n\n    for (auto &ves : res) {\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n    }\n  }\n\n  void CreateDFSForest(bool is_directed) {\n    int k = 0;\n    int idx = 0;\n    vector<int> st(n);\n\n    grp = 0;\n    ord.resize(n, -1);\n    low.resize(n);\n    belong.resize(n, -1);\n\n    function<void(int,int,Edge*)> dfs;\n    // to deal with multiple edges, it needs to be a pointer\n    auto update = [&](int v, Edge *e, bool &is_artic, int &cnt) {\n      int u = e->to;\n      if (ord[u] != -1) {\n        if (belong[u] == -1) low[v] = min(low[v], ord[u]);\n      } else {\n        cnt++;\n        dfs(u, v, e);\n        low[v] = min(low[v], low[u]);\n        if (ord[v] <= low[u]) is_artic = true;\n        // FIXME\n        if (ord[v] < low[u]) bridge.emplace_back(Brid(v, e - &es[v][0]));\n      }\n    };\n\n    dfs = [&](int v, int p, Edge *par) {\n      bool is_artic = false;\n      int cnt = 0;\n\n      st[idx++] = v;\n      low[v] = ord[v] = k++;\n\n      for (auto &e : es[v]) {\n        if (GetRevEdge(&e, true) == par) continue;\n        assert(e.to != p);\n        update(v, &e, is_artic, cnt);\n      }\n\n      if (!is_directed) {\n        for (auto &e : res[v]) {\n          if (GetRevEdge(&e, false) == par) continue;\n          assert(e.to != p);\n          update(v, &e, is_artic, cnt);\n        }\n      }\n\n      if (p == -1) is_artic = (cnt > 1);\n      if (is_artic) artic.emplace_back(v);\n\n      if (low[v] != ord[v]) return;\n      while (1) {\n        int u = st[--idx];\n        belong[u] = grp;\n        if (u == v) break;\n      }\n      grp++;\n    };\n\n    for (int i=0; i<n; i++) {\n      if (ord[i] == -1) dfs(i, -1, NULL);\n    }\n\n    sort(bridge.begin(), bridge.end(), [&](const Brid &a, const Brid &b) {\n      int av = a.first;\n      int bv = b.first;\n      if (av != bv) return av < bv;\n      int au = es[av][a.second].to;\n      int bu = es[bv][b.second].to;\n      return au < bu;\n    });\n  }\n\n  using DE = SCCEData;\n  using G = Graph<SCCVData<VData, EData, GData>, DE, SCCGData>;\n  G CreateSCC() {\n    if (belong.empty()) CreateDFSForest(true);\n\n    G ret(grp);\n    ret.gdat.orig2cont.resize(n);\n    for (int v=0; v<n; v++) {\n      auto &vd = ret.vdat[belong[v]];\n      ret.gdat.orig2cont[v] = ret.vd.cont2orig.size();\n      vd.cont2orig.emplace_back(v);\n    }\n\n    for (int i=0; i<grp; i++) {\n      auto &vd = ret.vdat[i];\n      vd.g.Init(vd.cont2orig.size(), 0x33433433);\n    }\n    \n    for (int v=0; v<n; v++) {\n      for (auto &e : es[v]) {\n        int u = e.to;\n\n        if (belong[v] == belong[v]) {\n          auto &vd = ret.vdat[belong[v]];\n          auto &dic = ret.gdat.orig2cont;\n          vd.g.AddEdge(dic[v], dic[u], e.dat, GetRevEdge(&e, true)->dat);\n        } else {\n          ret.AddEdge(belong[v], belong[u], DE(v, u), DE(u, v));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void CreateAdjMat() {\n    cost.clear();\n    cost.resize(n, Ls(n, INF));\n\n    auto cmp = [](const Edge &a, const Edge &b) {\n      if (a.to != b.to) return a.to < b.to;\n      return a.dat.len < b.dat.len;\n    };\n    EraseMultipleEdge(cmp, false);\n\n    for (int i=0; i<n; i++) {\n      int prev = -1;\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (prev > v) break;\n        cost[i][v] = min(cost[i][v], e.dat.len);\n        prev = v;\n      }\n    }\n  }\n\n  void DijkstraV(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    if (cost.empty()) CreateAdjMat();\n\n    vector<bool> used(n, false);\n    for (int i=0; i<n; i++) {\n      int v = -1;\n      for (int u=0; u<n; u++) {\n        if (used[u]) continue;\n        if (v == -1 || d[u] < d[v]) {\n          v = u;\n        }\n      }\n      if (v == -1) return;\n\n      used[v] = true;\n      for (int u=0; u<n; u++) {\n        d[u] = mind(d[u], d[v] + cost[v][u]);\n      }\n    }\n\n    // must not reach here\n    assert(0);\n  }\n\n  void DijkstraE(vector<int> &starts, Ls &d) {\n    using Pair = pair<Len, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.dat.len) {\n          d[u] = d[v] + e.dat.len;\n          q.push(Pair(d[u], u));\n        }\n      }\n    }\n  }\n\n  // return true if the graph has a negative cycle\n  bool SPFA(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n\n    queue<int> q;\n    vector<bool> inq(n);\n    vector<int> cnt(n);\n    for (int s : starts) {\n      inq[s] = true;\n      q.push(s);\n      d[s] = 0;\n    }\n\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      inq[v] = false;\n      cnt[v]++;\n      if (cnt[v] > n) continue;\n      for (auto &e : es[v]) {\n        int u = e.to;\n        if (d[u] > d[v] + e.to) {\n          d[u] = d[v] + e.to;\n          if (inq[u]) continue;\n          inq[u] = true;\n          q.push(u);\n        }\n      }\n    }\n\n    // do DFS if you need the concrete contents of such cycles\n    for (int i=0; i<n; i++) {\n      if (cnt[i] >= n) return true;\n    }\n\n    return false;\n  }\n\n  void DijkstraV(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraV(ss, d);\n  }\n\n  void DijkstraE(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraE(ss, d);\n  }\n\n  void SPFA(int s, Ls &d) {\n    vector<int> ss(1, s);\n    SPFA(ss, d);\n  }\n\n  // Create \"Shortest Path Graph\", which should be DAG\n  Graph<VData, EData, GData> RestoreShortestPaths(Ls &d) {\n    Graph<VData, EData, GData> ret(n);\n\n    for (int i=0; i<n; i++) {\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (d[v] == d[i] + e.dat.len) {\n          ret.AddEdge(i, e.to, e.dat, GetRevEdge(&e, true)->dat);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void WarshallFloyd(vector<Ls> &ds) {\n    if (cost.empty()) CreateAdjMat();\n\n    ds.clear();\n    ds.resize(cost);\n    for (int i=0; i<n; i++) {\n      ds[i][i] = min(ds[i][i], 0);\n    }\n\n    for (int k=0; k<n; k++) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n          if (ds[i][j] > ds[i][k] + ds[k][j]) {\n            ds[i][j] = ds[i][k] + ds[k][j];\n          }\n        }\n      }\n    }\n  }\n\n  // Karp's Algorithm O(NM)\n  // should be tested\n  // should be used for SCC\n  double MinimumMeanCycle() {\n    vector<Ls> dp(n+1, Ls(n, INF));\n\n    dp[0][0] = 0;\n    for (int i=1; i<=n; i++) {\n      for (int v=0; v<n; v++) {\n        for (auto &e : es[v]) {\n          int u = e.to;\n          dp[i][u] = min(dp[i][u], dp[i-1][v] + e.dat.len);\n        }\n      }\n    }\n\n    double ret = 1.0/0.0;\n    for (int v=0; v<n; v++) {\n      double alpha = (-1.0)/0.0;\n      for (int i=1; i<n; i++) {\n        if (dp[n][v] == INF) continue;\n        if (dp[i][v] == INF) continue;\n        alpha = max(alpha, (dp[n][v]-dp[i][v])/double(n-i));\n      }\n      ret = min(ret, alpha);\n    }\n    return ret;\n  }\n};\n\n// will be edited later\ntemplate<class Len>\nstruct Tree {\n  struct Edge {\n    int to;\n    Len len;\n  };\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  Len INF;\n\n  int n;\n  vector<Es> es;\n\n  Tree(int sz, Len inf) : INF(inf) {}\n\n  Len GetTreeDiameter() {\n    using Pair = pair<Len, int>;\n    auto dfs = [&](int v, int p) {\n      Pair ret{0, v};\n      for (auto &e : es[v]) {\n        if (e.to == p) continue;\n        Pair p = dfs(e.to, v);\n        p.first += e.len;\n        ret = max(ret, p);\n      }\n      return ret;\n    };\n\n    Pair p = dfs(0, 0);\n    return dfs(p.second, p.second).first;\n  }\n};\n\nint n;\nint m;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Graph<> g(n, 0x33433433);\n\n  while (m--) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    g.AddEdge(s, t);\n  }\n\n  g.CreateDFSForest(false);\n  for (auto &b : g.bridge) printf(\"%d %d\\n\", b.first, g.es[b.first][b.second].to);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N],ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back(l);\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        from[i]=a,to[i]=b;\n        vec[a].push_back(i);\n        vec[b].push_back(i);\n    }\n    dfs(0,0,-1);\n    for(int u:ans)\n        cout<<from[u]<<\" \"<<to[u]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (isBridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or isBridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) {\n            swap(s, t);\n        }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) {\n            swap(p.first, p.second);\n        }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n       \nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n       \n\n       \n\nclass IndexedEdge {\n public:\n  int from, to, index;\n  bool reversed;\n  IndexedEdge(int from, int to, int index, bool reversed = false)\n      : from(from), to(to), index(index), reversed(reversed) {}\n\n  IndexedEdge reverse() const {\n    return IndexedEdge(to, from, index, !reversed);\n  }\n};\n       \n       \n\ntemplate <typename T>\nstruct WeightedEdge {\n  int from, to;\n  T _weight;\n  WeightedEdge(){};\n  WeightedEdge(int from, int to, T weight)\n      : from(from), to(to), _weight(weight) {}\n\n  void scanFrom(std::istream& strm, int base = 1) {\n    strm >> from >> to >> _weight;\n    if (base == 1) --from, --to;\n  }\n\n  T weight() const { return _weight; }\n\n  WeightedEdge reverse() const { return WeightedEdge(to, from, _weight); }\n};\n\ntemplate <typename T>\ninline std::istream& operator>>(std::istream& strm, WeightedEdge<T>& t) {\n  t.scanFrom(strm);\n  return strm;\n}\n\ntemplate <typename Edge>\nclass Digraph {\n  int _E, _V;\n  vector<vector<Edge>> _adjacencyList;\n\n public:\n  int E() const { return _E; }\n\n  int V() const { return _V; }\n  int size() const { return _V; }\n\n  Digraph() : _V(0), _E(0){};\n  Digraph(int V, int E = 0) : _V(V), _E(E) { _adjacencyList.resize(V); }\n\n  void addEdge(const Edge& e) {\n    _adjacencyList[e.from].push_back(e);\n    ++_E;\n  }\n\n  void addUndirectedEdge(const Edge& e) {\n    _adjacencyList[e.from].push_back(e);\n    _adjacencyList[e.to].push_back(e.reverse());\n    ++_E;\n  }\n\n  void addNode() {\n    ++_V;\n    _adjacencyList.push_back(vector<Edge>());\n  }\n\n  void scanFrom(std::istream& strm, int base = 1) {\n    if (_V == 0) strm >> _V;\n    if (_E == 0) strm >> _E;\n    _adjacencyList.resize(_V);\n    for (int i = 0; i < _E; ++i) {\n      Edge e;\n      e.scanFrom(cin, base);\n      assert(0 <= e.from < _V);\n      assert(0 <= e.to < _V);\n      addEdge(e);\n    }\n  }\n\n  vector<Edge> operator[](int u) const { return _adjacencyList[u]; }\n  vector<vector<Edge>>& adjacencyList() { return _adjacencyList; }\n};\n\ntemplate <typename Edge>\ninline std::istream& operator>>(std::istream& strm, Digraph<Edge>& t) {\n  t.scanFrom(strm);\n  return strm;\n}\n\nclass Bridge {\n  vector<int> depth, passingBackEdgeCount;\n  vector<IndexedEdge> bridges;\n\n  int dfs(int u, int p, int d, const Digraph<IndexedEdge>& G) {\n    depth[u] = d;\n    int up = 0, down = 0, prefixSum = 0;\n    for (IndexedEdge& e : G[u]) {\n      if (depth[e.to] != -1) {\n        if (depth[e.to] < depth[u] - 1) ++up;\n        if (depth[e.to] > depth[u] + 1) ++down;\n        continue;\n      }\n      prefixSum += dfs(e.to, u, d + 1, G);\n    }\n    return passingBackEdgeCount[u] = up - down + prefixSum;\n  }\n\n public:\n  Bridge(const Digraph<IndexedEdge>& G) {\n    const int V = G.V();\n    depth.resize(V, -1);\n    passingBackEdgeCount.resize(V, 0);\n\n    for (int u = 0; u < (int)(V); ++u) if (depth[u] == -1) dfs(u, -1, 0, G);\n    for (int u = 0; u < (int)(V); ++u) {\n      if (passingBackEdgeCount[u] != 0) continue;\n\n      for (IndexedEdge& e : G[u]) {\n        if (depth[e.to] + 1 != depth[u]) continue;\n        bridges.push_back(e);\n      }\n    }\n  }\n\n  vector<IndexedEdge> edges() { return bridges; }\n};\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n\n  Digraph<IndexedEdge> G(V, E);\n\n  for (int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    IndexedEdge e(s, t, i);\n    G.addUndirectedEdge(e);\n  }\n\n  Bridge bridge(G);\n\n  vector<IndexedEdge> edges;\n  for (auto& e : bridge.edges()) {\n    edges.push_back(e.from < e.to ? e : e.reverse());\n  };\n  sort((edges).begin(), (edges).end(), [](const IndexedEdge& a, const IndexedEdge& b) {\n    return a.from == b.from ? a.to < b.to : a.from < b.from;\n  });\n  for (const IndexedEdge& e : edges) {\n    cout << e.from << \" \" << e.to << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > low[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n      // e is bridge!\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    if (u > v) swap(u, v);\n    es.emplace_back(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()) if (bd.edge_group[i].size() == 1) {\n    bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100010\ntypedef pair<int,int> P;\nvector<int> G[100010];\nint V,E;\nint ord[100010];\nint low[100010];\n\nint lowlink(int x,int p,int n){\n  if(ord[x]==INF)ord[x]=n;\n  else return ord[x];\n  int ans=INF;\n  for(int i=0;i<G[x].size();i++){\n    if(G[x][i]==p)continue;\n    ans=min(ans,lowlink(G[x][i],x,n+1));\n  }\n  return low[x]=ans;\n}\n\nint main(){\n  for(int i=0;i<100010;i++)\n    low[i]=ord[i]=INF;\n  cin>>V>>E;\n  P p[100010];\n  for(int i=0;i<E;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n    if(s>t)swap(s,t);\n    p[i]=P(s,t);\n  }\n  sort(p,p+E);\n  lowlink(0,-1,0);\n  for(int i=0;i<E;i++){\n    int f=0;\n    int u=p[i].first,v=p[i].second;\n    if(ord[u]>ord[v])swap(u,v);\n    if(ord[u]<low[v])cout<<p[i].first<<\" \"<<p[i].second<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n#include <functional>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(...) ;\n#else\n#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n\nvoid _tostr_rec(ostringstream &oss) {\n  oss << \"\\b\\b \\b\";\n}\n\ntemplate<typename Head, typename... Tail>\nvoid _tostr_rec(ostringstream &oss, Head &&head, Tail &&... tail) {\n  oss << head << \", \";\n  _tostr_rec(oss, forward<Tail>(tail)...);\n}\n\ntemplate<typename... T>\nstring _tostr(T &&... args) {\n  ostringstream oss;\n  int size = sizeof...(args);\n  if (size > 1) oss << \"{\";\n  _tostr_rec(oss, forward<T>(args)...);\n  if (size > 1) oss << \"}\";\n  return oss.str();\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Bridges & 2-edge-connected Components */\n\nstruct Bridges {\n  vector<pair<int, int>> edges;\n  vector<vector<pair<int, int>>> G;\n\n  vector<int> cmp, isBridge; //圧縮後に属するComponent番号, 橋であるか\n  vector<pair<int, int>> cmpEdges; //圧縮後のedge\n\n  int idx, cmpIdx;\n  vector<int> ord, inSt;\n  stack<int> roots, st;\n\n  Bridges(int N): G(N, vector<pair<int, int>>()), cmp(N), idx(0), cmpIdx(0), ord(N, -1), inSt(N, 0) {}\n\n  void add_edge(int u, int v) {\n    G[u].push_back({v, edges.size()});\n    G[v].push_back({u, edges.size()});\n    edges.push_back({u, v});\n    isBridge.push_back(false);\n  }\n\n  void dfs(int now, int eid = -1) {\n    ord[now] = idx++;\n    roots.push(now);\n    st.push(now);\n    inSt[now] = true;\n\n    for (auto e : G[now]) {\n      int to = e.first;\n      if (ord[to] == -1)\n        dfs(to, e.second);\n      else if (eid != e.second && inSt[to])\n        while (ord[roots.top()] > ord[to]) roots.pop();\n    }\n    if (now == roots.top()) {\n      while (1) {\n        int w = st.top();\n        st.pop();\n        inSt[w] = false;\n        cmp[w] = cmpIdx;\n        if (now == w) break;\n      }\n      if (eid != -1) isBridge[eid] = true;\n      roots.pop();\n      cmpIdx++;\n    }\n  }\n\n  void build() {\n    for (int i = 0; i < (int)ord.size(); i++)\n      if (ord[i] == -1)\n        dfs(i);\n\n    for (int i = 0; i < (int)edges.size(); i++) {\n      if (isBridge[i])\n        cmpEdges.push_back({cmp[edges[i].first], cmp[edges[i].second]});\n    }\n  }\n};\n\nint main() {\n  int V, E;\n\n  scanf(\"%d%d\", &V, &E);\n\n  Bridges bridges(V);\n\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    bridges.add_edge(min(s, t), max(s, t));\n  }\n\n  bridges.build();\n\n  vector<pair<int, int>> ans;\n\n  debug(bridges.isBridge, E);\n\n  for (int i = 0; i < E; i++) {\n    if (bridges.isBridge[i])\n      ans.push_back(bridges.edges[i]);\n  }\n\n  sort(ans.begin(), ans.end());\n\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 100001\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[v]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nvoid Bridge(void){\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  Bridge();\n\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, g);\n\n\tfor( auto e : es ){\n\t\tif(order[e.a] < order[e.b] ){\n\t\t\tcout << e.a << \" \" << e.b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n#define TSUKASA_DIARY_S_TEMPLATE\n// define\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) int((a).size())\n#define cauto const auto\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair< int, int > pii;\ntemplate< typename T > using Vec = vector< T >;\ntemplate< typename T > using Matrix = Vec< Vec< T > >;\ntemplate< typename T > using USet = unordered_set< T >;\ntemplate< typename T, class C > using MyUSet = unordered_set< T, C >;\ntemplate< typename T, typename F > using UMap = unordered_map< T, F >;\ntemplate< typename T, typename F, class C > using MyUMap = unordered_map< T, F, C >;\n// hash\nclass PiiHash { public: size_t operator () (const pii& p) const { return (p.first << 16) | p.second; } };\n// popcount\ninline int POPCNT(int x) { return __builtin_popcount(x); }\ninline int POPCNT(lint x) { return __builtin_popcount(x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n// inrange\ntemplate< typename T >\ninline bool in_range(T v, T mi, T mx) { return mi <= v && v < mx; }\ntemplate< typename T >\ninline bool in_range(T x, T y, T W, T H) { return in_range(x,0,W) && in_range(y,0,H); }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ntemplate< typename T > inline void modAdd(T& a, T b, T mod) { a = (a + b) % mod; }\ntemplate< typename T > inline void modMul(T& a, T b, T mod) { a = (a * b) % mod; }\ntemplate< typename T > inline void minUpdate(T& a, T b) { a = min(a, b); }\ntemplate< typename T > inline void maxUpdate(T& a, T b) { a = max(a, b); }\n// converter\ntemplate< typename F, typename T >\ninline void convert(F& from, T& to) {\n\tstringstream ss;\n\tss << from; ss >> to;\n}\n\nclass EnumBridge {\nprivate:\n\tint n;\n\tVec< Vec< int > > adj;\n\t\npublic:\n\tEnumBridge(int __n) : n(__n), adj(__n, Vec< int >()) {}\n\t\n\tvoid addEdge(int u, int v) {\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int p, int& cnt, Vec< int >& pos, Vec< int >& link, Vec< pii >& bridge) {\n\t\tif (pos[v] != -1) {\n\t\t\tlink[p] = min(link[p], pos[v]);\n\t\t\treturn;\n\t\t}\n\t\t\t\t\n\t\tpos[v] = link[v] = cnt; ++cnt;\n\t\t\n\t\tfor (int u : adj[v]) {\n\t\t\tif (u == p) continue;\n\t\t\tdfs(u, v, cnt, pos, link, bridge);\n\t\t\tlink[v] = min(link[v], link[u]);\n\t\t}\n\t\t\n\t\tif (p != -1 && pos[v] == link[v]) bridge.push_back(pii(min(p, v), max(p, v)));\n\t}\n\t\n\tVec< pii > run() {\n\t\tVec< pii > res;\n\t\tint cnt = 0;\n\t\tVec< int > pos(n, -1);\n\t\tVec< int > link(n, n);\n\t\tfor_(v,0,n) dfs(v, -1, cnt, pos, link, res);\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tEnumBridge eb(n);\n\tfor_(i,0,m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\teb.addEdge(u, v);\n\t}\n\tVec< pii > b = eb.run();\n\tsort(allof(b));\n\tfor (pii p : b) cout << p.first << \" \" << p.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)N;++i)\n#define rep1(i,N) for(int i=1;i<=(int)N;++i)\n\nusing int64 = long long;\nusing i64 = long long;\n\nconst int inf = 1 << 30;\nconst i64 inf64 = 1ll << 60;\n\nconst int mod = 1e9 + 7;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint dy[] = { 0, 1, 0, -1 };\nint dx[] = { -1, 0, 1, 0 };\n\ntemplate <typename G>\nstruct LowLink {\n\tG g;\n\tvector<int> used, low, ord;\n\tvector<pair<int, int>> bridge;\n\tvector<int> articulation;\n\n\tLowLink(const G& g) : g(g) {}\n\n\tint dfs(int u, int k, int par) {\n\t\tord[u] = low[u] = k++;\n\t\tused[u] = true;\n\t\tint cnt = 0;\n\t\tbool flag = false;\n\t\tfor (auto v : g[u]) {\n\t\t\tif (!used[v]) {\n\t\t\t\tk = dfs(v, k, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t\tcnt++;\n\t\t\t\tif (ord[u] < low[v]) bridge.emplace_back(make_pair(min(u, v), max(u, v)));\n\t\t\t\tflag |= (par != -1 && ord[u] <= low[v]);\n\t\t\t} else if (par != v) {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t\tflag |= (par == -1 && cnt > 1);\n\t\tif (flag) articulation.emplace_back(u);\n\t\treturn k;\n\t}\n\n\tvoid build() {\n\t\tused.assign(g.size(), 0);\n\t\tlow.assign(g.size(), 0);\n\t\tord.assign(g.size(), 0);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\tif (!used[i]) dfs(0, k, -1);\n\t\t}\n\t}\n};\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>> g(V);\n\trep(i, E) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tLowLink<vector<vector<int>>> lowlink(g);\n\tlowlink.build();\n\tsort(lowlink.bridge.begin(), lowlink.bridge.end());\n\tfor (auto e : lowlink.bridge) cout << e.first << \" \" << e.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n#define TSUKASA_DIARY_S_TEMPLATE\n// define\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) int((a).size())\n#define cauto const auto\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair< int, int > pii;\ntemplate< typename T > using Vec = vector< T >;\ntemplate< typename T > using Matrix = Vec< Vec< T > >;\ntemplate< typename T > using USet = unordered_set< T >;\ntemplate< typename T, class C > using MyUSet = unordered_set< T, C >;\ntemplate< typename T, typename F > using UMap = unordered_map< T, F >;\ntemplate< typename T, typename F, class C > using MyUMap = unordered_map< T, F, C >;\n// hash\nclass PiiHash { public: size_t operator () (const pii& p) const { return (p.first << 16) | p.second; } };\n// popcount\ninline int POPCNT(int x) { return __builtin_popcount(x); }\ninline int POPCNT(lint x) { return __builtin_popcount(x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nconst Double EPS = 1e-9;\nconst Double PI = acos(-1);\n// inrange\ntemplate< typename T >\ninline bool in_range(T v, T mi, T mx) { return mi <= v && v < mx; }\ntemplate< typename T >\ninline bool in_range(T x, T y, T W, T H) { return in_range(x,0,W) && in_range(y,0,H); }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ntemplate< typename T > inline void modAdd(T& a, T b, T mod) { a = (a + b) % mod; }\ntemplate< typename T > inline void modMul(T& a, T b, T mod) { a = (a * b) % mod; }\ntemplate< typename T > inline void minUpdate(T& a, T b) { a = min(a, b); }\ntemplate< typename T > inline void maxUpdate(T& a, T b) { a = max(a, b); }\n// converter\ntemplate< typename F, typename T >\ninline void convert(F& from, T& to) {\n\tstringstream ss;\n\tss << from; ss >> to;\n}\n\nclass EnumBridge {\nprivate:\n\tint n;\n\tVec< Vec< int > > adj;\n\t\npublic:\n\tEnumBridge(int __n) : n(__n), adj(__n, Vec< int >()) {}\n\t\n\tvoid addEdge(int u, int v) {\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tvoid dfs(int v, int p, int& cnt, Vec< int >& pos, Vec< int >& link, Vec< pii >& bridge) {\n\t\tif (pos[v] != -1) {\n\t\t\tlink[p] = min(link[p], pos[v]);\n\t\t\treturn;\n\t\t}\n\t\t\t\t\n\t\tpos[v] = link[v] = cnt; ++cnt;\n\t\t\n\t\tfor (int u : adj[v]) {\n\t\t\tif (u == p) continue;\n\t\t\tdfs(u, v, cnt, pos, link, bridge);\n\t\t\tlink[v] = min(link[v], link[u]);\n\t\t}\n\t\t\n\t\tif (p != -1 && pos[v] == link[v]) bridge.push_back(pii(p, v));\n\t}\n\t\n\tVec< pii > run() {\n\t\tVec< pii > res;\n\t\tint cnt = 0;\n\t\tVec< int > pos(n, -1);\n\t\tVec< int > link(n, n);\n\t\tfor_(v,0,n) dfs(v, -1, cnt, pos, link, res);\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tEnumBridge eb(n);\n\tfor_(i,0,m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\teb.addEdge(u, v);\n\t}\n\tVec< pii > b = eb.run();\n\tfor (pii p : b) cout << min(p.first, p.second) << \" \" << max(p.first, p.second) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nusing P = pair<int, int>;\n\n#define N 100004\n\nvector<int> g[N], g0[N];\n\nvector<int> vs;\nint lab[N], prv[N];\n\nvoid dfs(int v, int p) {\n  prv[v] = p;\n  vs.push_back(v);\n  lab[v] = vs.size();\n  for(int w : g[v]) {\n    if(w == p) {\n      continue;\n    }\n    if(lab[w]) {\n      if(lab[v] < lab[w]) {\n        g0[v].push_back(w);\n      }\n      continue;\n    }\n    dfs(w, v);\n  }\n}\n\nint used[N], ap[N];\nvector<P> bs;\nvector<int> aps;\nvoid construct(int n) {\n  dfs(0, -1);\n\n  used[0] = 1;\n  bool first = true;\n  for(int u : vs) {\n    if(!used[u]) {\n      // (u, p) is a bridge\n      int p = prv[u];\n      bs.push_back(u < p ? P(u, p) : P(p, u));\n      if(g[u].size() > 1) ap[u] = 1;\n      if(g[p].size() > 1) ap[p] = 1;\n    }\n    bool cycle = false;\n    for(int v : g0[u]) {\n      int w = v;\n      while(w != u && !used[w]) {\n        used[w] = 1;\n        w = prv[w];\n      }\n      if(w == u) {\n        cycle = true;\n      }\n    }\n    if(cycle) {\n      if(!first) ap[u] = 1;\n      first = false;\n    }\n  }\n  for(int i=0; i<n; ++i) {\n    if(ap[i]) aps.push_back(i);\n  }\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for(int i=0; i<m; ++i) {\n    int a, b; cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  construct(n);\n  sort(bs.begin(), bs.end());\n  for(P &e : bs) {\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n// typedef __int128_t Int;\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n// Bridges in a undirected graph\nstruct Bridge {\n  int V;\n  vector<vector<int>> G;\n  vector<int> visited, lowest, parent, prenum;\n  Bridge() {}\n  Bridge(int V) : V(V), G(V), visited(V), prenum(V), parent(V), lowest(V) {}\n  void add_edge(int s, int t) {\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  void dfs(int cur, int prev, vector<pair<int, int>> &b) {\n    static int time = 0;\n    visited[cur] = true;\n    prenum[cur] = lowest[cur] = ++time;\n    for (auto next : G[cur]) {\n      if (not visited[next]) {\n        parent[next] = cur;\n        dfs(next, cur, b);\n        lowest[cur] = min(lowest[cur], lowest[next]);\n        if (lowest[next] > prenum[cur]) {\n          b.push_back(make_pair(cur, next));\n        }\n      } else if (next != prev) {\n        lowest[cur] = min(lowest[cur], lowest[next]);\n      }\n    }\n  }\n  vector<pair<int, int>> bridges() {\n    fill(all(visited), false);\n    vector<pair<int, int>> b;\n    for (int i = 0; i < V; i++) {\n      if (not visited[i]) {\n        dfs(i, -1, b);\n      }\n    }\n    return b;\n  }\n};\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int V, E;\n  cin >> V >> E;\n  Bridge g(V);\n  loop(E) {\n    int s, t;\n    cin >> s >> t;\n    g.add_edge(s, t);\n  }\n  auto b = g.bridges();\n  for (auto e : b) {\n    if (e.first > e.second)\n      swap(e.first, e.second);\n  }\n  sort(all(b));\n  for (auto e : b) {\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> P;\n#define rep(i,n) for(ll i = 0; i < ll(n); i++)\n#define all(v) v.begin() , v.end()\n#define inputv(v,n) rep(i,n){\\\n    ll x;\\\n    cin>>x;\\\n    v.push_back(x);\\\n    }\nconst ll INF=99999999999999;\nconst ll MOD=1000000007;\nll c,d,e,f,p,t,x,y,ans=0;\n \nset<ll> s,loop;\nvl visited(300000,0);\nll n,m,r;\nll num=0;\nvl gragh[300000];\nvl low(300000,INF),pre(300000,INF);\nvector<P> ANS;\n \nvoid input(void){\n    cin>>n>>m;\n    rep(i,m){\n        cin>>c>>d;\n        gragh[d].push_back(c);\n        gragh[c].push_back(d);\n    }\n}\n\nvoid dfs(ll a,ll b){\n    visited[a]=1;\n    pre[a]=num;\n    low[a]=num;\n    num++;\n    for(ll i:gragh[a]){\n        if(i!=b){\n            if(visited[i]==0){\n                dfs(i,a);\n            }\n            if(pre[a]<pre[i])low[a]=min(low[a],low[i]);\n\t\telse low[a]=min(low[a],pre[i]);\n        }\n    }\n\n    if(pre[a]!=0&&pre[a]==low[a]){\n        ANS.emplace_back(min(a,b),max(a,b));\n    }\n}\n\nll solve(void){\n    dfs(0,-1);\n    sort(all(ANS));\n    rep(i,ANS.size()){\n        x=ANS[i].first;\n        y=ANS[i].second;\n        cout<<x<<\" \"<<y<<endl;\n    }\n    return ans;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    input();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1) dfs(to, current);\n      if(previous == to)continue;\n      node[current].min_order =\n        min(node[current].min_order,\n            node[to].min_order);\n    }\n    if(node[current].min_order == node[current].order and\n       previous != -1){\n      brige.insert(pii(previous, current));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tREP(i, g[u].size()) {\n\t\tint v = g[u][i];\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tdfs(0, -1, 0);\n\t\n\tfor (set<pii>::iterator it = bridge.begin(); it != bridge.end(); ++it) {\n\t\tprintf(\"%d %d\\n\", it->first, it->second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\n\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        const auto is_bridge = [&](const int i, const int j) { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; };\n        const auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (is_bridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        const auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or is_bridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass BRI{\n\tpublic:\n\tint N;\n\tvi used;\n\tvvi G;\n\tvp bridge;\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\tBRI(int size){\n\t\tN=size;\n\t\tG=vvi(N);\n\t}\n\tint dfs(int i,int prev,int &n){\n\t\tif(used[i])return used[i];\n\t\tint m=n;\n\t\tused[i]=n++;\n\t\trep(j,G[i].size()){\n\t\t\tif(prev==G[i][j])continue;\n\t\t\tif(used[i]<used[G[i][j]])continue;\n\t\t\tint res=dfs(G[i][j],i,n);\n\t\t\tm=min(m,res);\n\t\t\tif(used[i]<res)bridge.pb(pii(min(i,G[i][j]),max(i,G[i][j])));\n\t\t}\n\t\treturn m;\n\t}\n\tvoid bri(){\n\t\tused=vi(N);\n\t\tbridge=vp(0);\n\t\tint n=1;\n\t\trep(i,n)if(!used[i])dfs(i,-1,n);\n\t\tsort(all(bridge));\n\t\trep(i,bridge.size())cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v,int p){\t//make ord and lowlink\n\tused[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!used[to]){\n\t\t\tdfs(to,v);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(used[to]&&to!=p){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\nvector<pii> enumerateBridge(int e,vector<pii> edges){\t//????????????\n\tvector<pii> ret;\n\t\n\trep(i,e){\n\t\tint a = edges[i].first, b = edges[i].second;\n\t\tif(ord[a]>ord[b])swap(a,b);\n\t\tif(ord[a]<lowlink[b])ret.pb(pii(edges[i].first,edges[i].second));\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0,-1);\n\t\n\tvector<pii> ans = enumerateBridge(e,edges);\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cerr << x << \" \";} cerr << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cerr << x << \" \";}cerr << endl;}\n#define printP(p) cerr << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int>      Edge;   // (a < b: undirected)\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vi depth;\n    vi par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvi cmp;\n\tint num_cc;\n\tvi size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    void bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\t// rep(i, n) {\n\t\t// \tint size_cc = extractCC(i, num_cc);\n\t\t// \tif (size_cc > 0) {\n\t\t// \t\tsize_of_vertex.emplace_back(size_cc);\n\t\t// \t\tnum_cc++;\n\t\t// \t}\n\t\t// }\n        //\n        // r<set<int>> G_cc_st(num_cc);\n\t\t// for (auto&& p : EdgeType) {\n        //     Edge e;\n        //     int type;\n        //     tie(e, type) = p;\n        //     if (type == BRIDGE) {\n\t\t// \t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t// \t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n        //     }\n        // }\n        //\n\t\t// rep(i, num_cc) {\n\t\t// \tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t// }\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n    BICC bicc(V);\n    rep(i, E) {\n        int a, b;\n        cin >> a >> b;\n        bicc.addEdge(a, b);\n    }\n\n    bicc.bicc();\n    auto bridges = bicc.getBridges();\n    printVP(bridges);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d, vector<int> &depth, vector<int> &lowlink, vector<bool> &visited){\n    visited[u] = true;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1, depth, lowlink, visited);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    for(int i=0; i<V; i++)\n        sort(G[i].begin(), G[i].end());\n    \n    vector<int> depth(V, -1), lowlink(V, -1);\n    vector<bool> visited(V, false);\n    dfs(G, -1, 0, 0, depth, lowlink, visited);\n    \n    for(int s=0; s<V; s++){\n        for(auto t: G[s]) if(s<t && (depth[s]<lowlink[t]||depth[t]<lowlink[s])){\n            cout << s << \" \" << t << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define ps push\n#define fr front\ntypedef pair<int,int> pii;\n\n#define MAX_N 100000\n\nint ord[MAX_N],low[MAX_N];\nvector<int> g[MAX_N];\nbool f[MAX_N];\nvector<pii> ans;\n\nvoid dfs(int u,int v,int k){\n\tf[v]=true;\n\tord[v]=k;\n\tlow[v]=ord[v];\n\tfor(int j=0;j<g[v].size();++j){\n\t\tint w=g[v][j];\n\t\tif(w==u) continue;\n\t\telse if(f[w]) low[v]=min(low[v],ord[w]);\n\t\telse{\n\t\t\tdfs(v,w,k+1);\n\t\t\tlow[v]=min(low[v],low[w]);\n\t\t\tif(ord[v]<low[w]) ans.pb(mp(min(v,w),max(v,w)));\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,e;\n\tscanf(\"%d%d\",&n,&e);\n\tvector<pii> es;\n\tfor(int j=0;j<e;++j){\n\t\tint v,w;\n\t\tscanf(\"%d%d\",&v,&w);\n\t\tg[v].pb(w);\n\t\tg[w].pb(v);\n\t}\n\tfill(f,f+n,false);\n\tdfs(0,0,0);\n\tsort(ans.begin(),ans.end());\n\tfor(int j=0;j<ans.size();++j) printf(\"%d %d\\n\",ans[j].fi,ans[j].sc); \n}"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨??????root??????????????????u???lowlink???root??????root -> u??????\n//???DFS??¨?????????????????????u???????????????u?????????prenum <= u???lowest ??? u??¨u??????????????????????????????\n//??????????¨???????u --> ?????¨????????????u?????? (u --> u??????) ???????????????????????????\n// ( ???????¨????????????¶?¨????????????????u?????????????????????u --> ?????¨??????????????????u --> u????\\????x??¨??????????????§???lowest[u] <= prenum[x]????????????x???prenum < u?????????prenum?????????????????????)\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (parent[i] == 0) {\n\t\t\tif (lowest[i] == 0) { ans.push_back(Edge(0, i)); }\n\t\t}\n\t\telse if (prenum[parent[i]] <= lowest[i]) {\n\t\t\tans.push_back(Edge(parent[i], i));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\t\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nvector<pair<int, int> >X[1 << 17]; int used[1 << 17]; int N, M, A, B, C, sum, cnt2; queue<int>Q;\nint main() {\n    cin >> N >> M; for (int i = 0; i < M; i++) { cin >> A >> B; C=1;/* A--; B--;*/ X[A].push_back(make_pair(B, C)); X[B].push_back(make_pair(A,C)); }\n    for (int i = 0; i < N; i++) { sort(X[i].begin(), X[i].end()); }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < X[i].size(); j++) {\n            int a1 = i, a2 = X[i][j].first; for (int k = 0; k < N; k++) { used[k] = 0; }used[0] = 1; Q.push(0); int cnt = 1;\n            while (!Q.empty()) {\n                int to = Q.front(); Q.pop();\n                for (int k = 0; k < X[to].size(); k++) {\n                    int A1 = to, A2 = X[to][k].first; if (A1 == a1 && A2 == a2) { continue; }if (A1 == a2 && A2 == a1) { continue; }\n                    if (used[X[to][k].first] == 0) { used[X[to][k].first] = 1; Q.push(X[to][k].first); cnt++; }\n                }\n            }\n            if (cnt != N && a1 < a2) { /*cnt2 += 1; sum += X[i][j].second;*/cout<<a1<<' '<<a2<<endl; }\n        }\n    }\n    /*cout<<cnt2<<' '<<sum<<endl;*/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// lolinkの自作ライブラリ\n/* option1:グラフが非連結の場合,option2:bridgeの検出,option3:関節点の検出*/\n#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define loINF (long)10000000000\n#define shINF (short)10000\n#define SORT(c) sort((c).begin(),(c).end())\n//#define NOT_ALL_CONNECTED \t//option1\n#define BRIDGE   \t\t\t\t//option2\n//#define ARTICULATION_POINT    //option3\nusing namespace std;\nconst long V_START = 0;\ntypedef vector<long> VL;\ntypedef vector<VL> VVL;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\n\nbool pairCompare(const pr& firstElof, const pr& secondElof)\n{\n    return (firstElof.first < secondElof.first || ((firstElof.first == secondElof.first) && (firstElof.second < secondElof.second)));\n}\n\nVVL edge;\nVL ord;\nVL low;\nVL pre;\n\nvoid dfs(long now_ver,long parent,long order){\n\tlong child_num = 1;\n\tchar flag = 0;\n\tpre[now_ver] = parent;\n\tlow[now_ver] = ord[now_ver] = order;\n\n\tREP(i,edge[now_ver].size()){\n\t\tlong to = edge[now_ver][i];\n\t\tif (to == parent) continue;\n\t\tif (ord[to] == -1) { // 子ノードへの辺\n\t\t\tdfs(to,now_ver,order + child_num);\n\t\t\tchild_num++;\n\t\t\tlow[now_ver] = min(low[now_ver],low[to]);\n\t\t}\n\t\tlow[now_ver]=min(low[now_ver],ord[to]);\n\t}\n}\n\nint main(void){\n\tlong V,E;\n\tcin >> V >> E;\n\tedge = VVL(V+1,VL(0));\n\tord = VL(V+1,-1);\n\tlow = VL(V+1,loINF);\n\tpre = VL(V+1,-1);\n\n\tREP(i,E){\n\t\tlong u,v;\n\t\tcin >> u >> v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u); \n\t}\n\n\t#ifdef NOT_ALL_CONNECTED // グラフが非連結の場合\n\t\tFOR(i,V_START,V+V_START) \n\t\t\tif(ord[i] == -1)\n\t\t\t\tdfs(i,-1,1);\n\t#endif\n\n\t#ifndef NOT_ALL_CONNECTED // グラフが連結の場合\n\t\tdfs(1,-1,1);\n\t#endif\n\n\t#ifdef BRIDGE\n\t\tVP bridge;\n\t\tlong bridge_count = 0;\n\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (ord[i] == low[i]) {\n\t\t\t\tif (i == 1) continue;\n\t\t\t\tbridge.push_back(make_pair(min(i,pre[i]),max(i,pre[i])));\n\t\t\t\tbridge_count++;\n\t\t\t}\n\t\t}\n\n\t\tsort(bridge.begin(),bridge.end(),pairCompare);\n\n\t\tREP(i,bridge.size()) \n\t\t\tcout << bridge[i].first << \" \" << bridge[i].second << endl;\n\t#endif\n\n\t#ifdef ARTICULATION_POINT\n\t\tVL point;\n\t\tlong point_count = 0;\n\t\tchar root_count = 0;\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (pre[i] == -1) continue;\n\t\t\tif (pre[i] == 1) root_count++;\n\t\t\telse {\n\t\t\t\tif (ord[pre[i]] <= low[i]) {\n\t\t\t\t\tpoint.push_back(pre[i]);\n\t\t\t\t\tpoint_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(root_count >= 2) {\n\t\t\tpoint.push_back(1);\n\t\t\tpoint_count++;\n\t\t}\n\n\t\tSORT(point);\n\t\tpoint.erase(unique(point.begin(),point.end()),point.end());\n\n\t\t// point_count:関節点の個数 , point:関節点\n\t\tcout << \"関節点の個数:\" << point_count << endl;\n\t\tREP(i,point.size()) cout << point[i] << endl;\n\t\t\n\t#endif\n\n\t#ifdef DEBUG\n\t\tdump1d_arr(ord);\n\t\tdump1d_arr(low);\n\t\tdump1d_arr(pre);\n\t#endif\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nstruct node {\n\tbool done;\n\tvi to;\n\tint id, from;\n\tint pre, low;\n};\n\nclass lowlink {\n\tint ord;\npublic:\n\tvector<node> nodes;\n\tset<P> bridges;\n\tset<int> arts; //articulation point\n\tlowlink(vector<node> A) {\n\t\tord = 0;\n\t\tnodes = A;\n\t}\n\tvoid dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tdfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) bridges.insert({ a,b });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\tif (cnt > (a == root ? 1 : 0)) arts.insert(a);\n\t\treturn;\n\t}\n\tvoid find_bridges_and_arts() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) dfs(i, i);\n\t\t}\n\t}\n};\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tvector<node> nodes(v);\n\tLoop(i, v) nodes[i] = { 0,{}, i,-1,-1,-1 };\n\tLoop(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].to.push_back(t);\n\t\tnodes[t].to.push_back(s);\n\t}\n\tlowlink lk(nodes);\n\tlk.find_bridges_and_arts();\n\t/*\n\tauto itr = lk.arts.begin();\n\tLoop(i, lk.arts.size()) {\n\t\tcout << *itr << endl;\n\t\titr++;\n\t}*/\n\tauto itr = lk.bridges.begin();\n\tLoop(i, lk.bridges.size()) {\n\t\tcout << (*itr).first << \" \" << (*itr).second << endl;\n\t\titr++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nvoid Lowlink(BiDGraph& g,vector<int>& lowlink, vector<int>& orb) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int,int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) continue;\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first,cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0,-1);\n\treturn;\n}\n\nvoid Bridge(BiDGraph& g, vector<pii>& bridges) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({i, itr.first});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Joint(BiDGraph& g, vector<int>& joints) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr : bridges) {\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <algorithm>\n\n#include <cassert>\n\n#include <cstdint>\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\ntemplate <class T> using vec = std::vector<T>;\n\n/*\n * @title 2-辺連結成分分解 (Two-edges components)\n * @see [Wikipedia k-edge-connected graph](https://en.wikipedia.org/wiki/K-edge-connected_graph)\n * @docs graph/connectivity/tec_component.md\n */\n\nclass tec_component {\n    bool built;\n\n    // 1 回目の DFS\n    // 計算するもの: ord, low, bridges\n    // precondition: ckd = 0\n    // post-condition: ckd = 2\n    void low_link_dfs(usize x, usize p, usize& t) {\n        auto&& v = g.at(x);\n        ord.at(x) = low.at(x) = t++;\n        ckd.at(x) = 1;\n\n        // 親への多重辺\n        if (2u <= std::count(v.begin(), v.end(), p)) {\n            if (low.at(x) > ord.at(p)) low.at(x) = ord.at(p);\n        }\n\n        for (usize y : v) {\n            // 未訪問の場合です。\n            if (ckd.at(y)==0u) {\n                low_link_dfs(y, x, t);\n                // 橋を見つけました。\n                if (ord.at(x) < low.at(y)) {\n                    bridges.emplace_back(std::min(x, y), std::max(x, y));\n                } else {\n                    if (low.at(x) > low.at(y)) low.at(x) = low.at(y);\n                }\n            // 後退辺です。\n            } else if (y!=p && ckd.at(y)==1u) {\n                if (low.at(x) > ord.at(y)) low.at(x) = ord.at(y);\n            }\n        }\n        ckd.at(x) = 2;\n    }\n\n    // 2 回目の DFS\n    // 計算するも: cmp\n    // precondition: cmp = size()\n    // post-condition: cmp が計算済み\n    void cmp_dfs(usize x) {\n        for (usize y : g.at(x)) if (cmp.at(y)==size()) {\n            cmp.at(y) = ord.at(x)<low.at(y)? ++count : cmp.at(x);\n            cmp_dfs(y);\n        }\n    }\n\npublic:\n    vec<vec<usize>> g;\n    vec<usize> ord, low, ckd, cmp;\n\n    vec<std::pair<usize, usize>> bridges;\n\n    usize count;\n\n    tec_component()=default;\n    tec_component(tec_component const&)=default;\n    tec_component(tec_component&&)=default;\n    tec_component& operator=(tec_component const&)=default;\n    tec_component& operator=(tec_component&&)=default;\n    ~tec_component()=default;\n\n    tec_component(usize n)\n        : built(false), g(n), ord(n), low(n), ckd(n), cmp(n, n), count(0)\n    {}\n\n    usize size() const { return g.size(); }\n\n    void insert(usize i, usize j) {\n        assert(usize{ 0 } <= i && i < size());\n        assert(usize{ 0 } <= j && j < size());\n        g.at(i).push_back(j);\n        g.at(j).push_back(i);\n    }\n\n    void build() {\n        assert(built == false);\n        built = true;\n\n        for (usize i=0, t=0; i<size(); i++) if (ckd.at(i)==0) {\n            low_link_dfs(i, 0, t);\n        }\n\n        assert(std::all_of(std::begin(ckd), std::end(ckd), [](usize x){ return x==2; }));\n\n        for (usize i=0; i<size(); i++) if (cmp.at(i)==size()) {\n            cmp.at(i) = count;\n            cmp_dfs(i);\n        }\n        count++;\n    }\n\n    vec<vec<usize>> quotient_graph() {\n        if (!built) build();\n        vec<vec<usize>> h(count);\n\n        for (auto&& e: bridges) {\n            usize u, v;\n            std::tie(u, v) = e;\n            u = cmp.at(u);\n            v = cmp.at(v);\n\n            h.at(u).push_back(v);\n            h.at(v).push_back(u);\n        }\n        return h;\n    }\n};\n\nint main(){\n    std::size_t n, m;\n    std::cin >> n >> m;\n    tec_component tec(n);\n\n    while (m--) {\n        std::size_t u, v;\n        std::cin >> u >> v;\n        tec.insert(u, v);\n    }\n    tec.build();\n\n    std::vector<std::pair<std::size_t, std::size_t>> bridges = tec.bridges;\n    std::sort(bridges.begin(), bridges.end());\n\n    for (auto&& e : bridges) {\n        std::size_t i, j;\n        std::tie(i, j) = e;\n        std::cout << i << ' ' << j << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rnk;\n\nvoid init(int n){\n    parent.clear();\n    rnk.clear();\n    for(int i=0; i<n; i++){\n        parent.push_back(i);\n        rnk.push_back(0);\n    }\n}\n\nint find(int x){\n    if(x == parent[x]){\n        return x;\n    } else {\n        return parent[x] = find(parent[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    if(x == y) return;\n\n    if(rnk[x] < rnk[y]){\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct edge{\n    int from, to;\n};\n\nbool comp(edge& e1, edge e2){\n    if(e1.from == e2.from){\n        return e1.to < e2.to;\n    } else {\n        return e1.from < e2.from;\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector<edge> es(e);\n    for(int i=0; i<e; i++){\n        edge ed;\n        cin >> ed.from >> ed.to;\n        if(ed.from > ed.to) swap(ed.from, ed.to);\n        es[i] = ed;\n    }\n\n    sort(es.begin(), es.end(), comp);\n\n    int cnt = 0;\n    for(int i=0; i<e; i++){\n        init(v);\n        for(int j=0; j<e; j++){\n            if(i == j) continue;\n            edge e = es[j];\n            unite(e.from, e.to);\n        }\n\n        bool is_same = true;\n        for(int j=0; j<v-1 && is_same; j++){\n            if(!same(j, j+1)){\n                is_same = false;\n                edge e = es[i];\n                cout << e.from << \" \" << e.to << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Verified @ GRL_3_A\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate < typename T >\nvoid vprint(T &v, int size){\n\tREP(i, size){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nll N, M;\nvector<ll> G[101010];\nvector<ll> dfs_tree[101010];\nvector<ll> low(101010);\nvector<ll> ord(101010, -1);\nll cnt = 0;\n\nvoid dfs(ll now, ll par){\n\tord[now] = cnt;\n\tcnt++;\n\tlow[now] = ord[now];\n\tREP(i, G[now].size()){\n\t\tll next = G[now][i];\n\t\tif(ord[next] == -1){\n\t\t\tdfs_tree[now].push_back(next);\n\t\t\tdfs(next, now);\n\t\t\tlow[now] = min(low[now], low[next]);\n\t\t}else if(next != par){\n\t\t\tlow[now] = min(low[now], ord[next]);\n\t\t}\n\t}\n\treturn;\n}\n\nvector<pll> enum_bridge(){\n\t// construct lowlink\n\tll root = 0;\n\tdfs(root, -1);\n\n\t// enumerate bridge\n\tvector<pll> res;\n\tREP(i, N){\n\t\tREP(j, dfs_tree[i].size()){\n\t\t\tif(ord[i] < low[dfs_tree[i][j]]){\n\t\t\t\tres.push_back({i, dfs_tree[i][j]});\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    REP(i, M){\n    \tint s, t;\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    \tG[t].push_back(s);\n    }\n\n    auto res = enum_bridge();\n    REP(i, res.size()) if(res[i].first > res[i].second) swap(res[i].first, res[i].second);\n    sort(res.begin(), res.end());\n    REP(i, res.size()){\n    \tcout << res[i].first << \" \" << res[i].second << endl;\n    }\n\n    //vprint(low, N);\n    //vprint(ord, N);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\nconst int E_MAX=100000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nbool used_v[V_MAX]={};\n//bool used_e[E_MAX][E_MAX]={};\nvector<int> pre(V_MAX,INT_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(used_v[s]==true){return;}\n\tused_v[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\t//used_e[s][G[s][i]]=true;\n\t\tif(!used_v[G[s][i]]){\n\t\t\tdfs(G[s][i],s);\n\t\t\tlow[s]=min(low[s],low[G[s][i]]);\n\t\t}else if(G[s][i]!=p){\n\t\t\tlow[s]=min(low[s],pre[G[s][i]]);\n\t\t}\n\t}\n\tif(!(s==0 && p==0) && low[s]>pre[p]){\n\t\tedge e;\n\t\te.from=min(s,p);\n\t\te.to=max(s,p);\n\t\tresult.push_back(e); \n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t/*\n\tfor(int i=0;i<V;i++){\n\t\tcout << pre[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\tfor(int i=0;i<V;i++){\n\t\tcout << low[i] << \" \";\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\n\nconst int mx = 100005;\n\nint dtime = 0;\nint n, m, par[mx], low[mx], start[mx];\nvector<int> adj[mx];\nbool vis[mx];\nvector<pair<int, int>> bdg;\n\nvoid dfs(int n, int p = -1) {\n  vis[n] = true;\n  par[n] = p;\n  start[n] = dtime++;\n  low[n] = start[n];\n  \n  for (int h : adj[n]) {\n    if (!vis[h]) {\n      dfs(h, n);\n      // printf(\"Low[%d] = min(%d, %d) = %d\\n\", n, low[n], low[h], min(low[n], low[h]));\n      low[n] = min(low[h], low[n]);\n      if (low[h] > start[n]) {\n\tbdg.push_back({min(n, h), max(n, h)});\n      }\n    } else if (h != p) {\n      low[n] = min(low[n], start[h]);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    adj[u].pb(v); adj[v].pb(u);\n  }\n  dfs(0);\n  sort(bdg.begin(), bdg.end());\n  for (auto p : bdg) cout << p.first << \" \" << p.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX=100000;\n\nint n;\nvector<int> G[MAX];\nint order[MAX]={};\nbool inS[MAX]={};\nstack<int> roots,S;\nint k;\nvector<P> brg;\n\nvoid visit(int v,int p)\n{\n\torder[v]=++k;\n\tinS[v]=true;\n\tS.push(v);\n\troots.push(v);\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint to=G[v][i];\n\t\tif(order[to]==0)\n\t\t{\n\t\t\tvisit(to,v);\n\t\t}\n\t\telse if(to!=p&&inS[to])\n\t\t{\n\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top())\n\t{\n\t\tif(p!=-1)brg.push_back(P(min(p,v),max(p,v)));\n\t\twhile(1)\n\t\t{\n\t\t\tint node=S.top();S.pop();\n\t\t\tinS[node]=false;\n\t\t\tif(node==v)break;\n\t\t}\n\t\troots.pop();\n\t}\n\treturn;\n}\n\nvoid bridge()\n{\n\tk=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(order[i]==0)\n\t\t{\n\t\t\tvisit(i,-1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tcin>>n;\n\tint e;\n\tcin>>e;\n\tint u,v;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbridge();\n\tsort(brg.begin(),brg.end());\n\tfor(int i=0;i<brg.size();i++)\n\t{\n\t\tcout<<brg[i].first<<\" \"<<brg[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<functional>\n#include<set>\n#include<stack>\n#include<queue>\n#include<vector>\n\nusing Weight = int;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// ?????????????????????????????°?????? O(|E|)\nGraph reverse(const Graph& G) {\n  Graph H(G.size());\n  for(const auto& list: G) for(const auto& e: list) H[e.to].push_back({e.to, e.from, e.weight});\n  return H;\n}\n\n// ????????£??????????????????????????????????????? O(|V|)\nstd::vector<Vertex> connected_component(const Graph& G, Vertex v) {\n  static std::vector<bool> used(G.size());\n  used[v] = true;\n  std::vector<Vertex> S = {v};\n  for(const auto& e: G[v]) if(!used[e.to]) {\n    auto t = connected_component(G, e.to);\n    S.insert(end(S), begin(t), end(t));\n  }\n  return S;\n}\n\n// ??£????????????????§£ O(|V|)\nstd::vector<std::vector<Vertex>> connected_component(const Graph& G) {\n  std::vector<std::vector<int>> cc;\n  std::vector<bool> used(G.size());\n  for(int v = 0; v < G.size(); ++v) if(!used[v]) {\n    cc.push_back(connected_component(G, v));\n    for(auto w: cc.back()) used[w] = true;\n  }\n  return cc;\n}\n\n// ??????cur???????????£???????????????????????¢??????/???????????? O(|V| + |E|)\n// ???cur???????????¨??????pre==cur?????????\n// ???cut_vertex??????????????????????????°?????\\???????????§?????????\nvoid lowlink(const Graph& G, Vertex cur, Vertex pre, std::vector<int>& cut_vertex, std::vector<Edge>& bridge) {\n  static std::vector<bool> used(G.size());\n  static std::vector<int> ord(G.size()), low(G.size());\n  static int timer = 1;\n  ord[cur] = low[cur] = timer++;\n  used[cur] = true;\n  for(const auto& e: G[cur]) if(e.to != pre) {\n    if(used[e.to]) {\n      low[cur] = std::min(low[cur], ord[e.to]);\n    } else {\n      lowlink(G, e.to, cur, cut_vertex, bridge);\n      low[cur] = std::min(low[cur], low[e.to]);\n      if(cur == pre) if(ord[cur]+1 < ord[e.to]) cut_vertex.push_back(cur);\n      if(cur != pre) if(ord[cur] <= low[e.to])  cut_vertex.push_back(cur);\n      if(ord[cur] < low[e.to])                  bridge.push_back(e);\n    }\n  }\n}\n\n// ?????£?????????????§£ O(|V| + |E|)\nvoid Tarjan(const Graph& G, Vertex v, std::vector<std::vector<Vertex>>& scc) {\n  static std::stack<Vertex> S;\n  static std::vector<bool> inS(G.size());\n  static std::vector<int> ord(G.size()), low(G.size());\n  static int timer = 1;\n  ord[v] = low[v] = timer++;\n  S.push(v);\n  inS[v] = true;\n  for(const auto& e: G[v]) {\n    if(!ord[e.to]) {\n      Tarjan(G, e.to, scc);\n      low[v] = std::min(low[v], low[e.to]);\n    } else if(inS[e.to]) {\n      low[v] = std::min(ord[v], low[e.to]);\n    }\n  }\n  if(ord[v] == low[v]) {\n    scc.push_back(std::vector<int>());\n    while(true) {\n      Vertex w = S.top();\n      S.pop();\n      inS[w] = false;\n      scc.back().push_back(w);\n      if(v == w) break;\n    }\n  }\n}\nstd::vector<std::vector<Vertex>> Tarjan(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  for(int v = 0; v < G.size(); ++v) Tarjan(G, v, scc);\n  return scc;\n}\n\n// ???????§???????????????? O(|E| + |V| log |V|)\nstd::vector<Weight> Dijkstra(const Graph& G, Vertex s) {\n  std::vector<Weight> d(G.size(), -1);\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge,Edge)>> q([](Edge lhs, Edge rhs){return lhs.weight > rhs.weight;});\n  q.push({s, s, 0});\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(d[cur.to] != -1) continue;\n    d[cur.to] = cur.weight;\n    for(const auto& nex: G[cur.to]) if(d[nex.to] != -1) q.push({cur.to, nex.to, cur.weight + nex.weight});\n  }\n  return d;\n}\n\n// ???????????? O(|E| + |V|^3)\nstd::vector<std::vector<Weight>> WarshallFloyd(const Graph& G) {\n  std::vector<std::vector<Weight>> d(G.size(), std::vector<Weight>(G.size(), -1));\n  for(int v = 0; v < G.size(); ++v) {\n    d[v][v] = 0;\n    for(const auto& e: G[v]) {\n      if(d[e.from][e.to] == -1) d[e.from][e.to] = e.weight;\n      else                      d[e.from][e.to] = std::min(d[e.from][e.to], e.weight);\n    }\n  }\n  for(int i = 0; i < G.size(); ++i) for(int j = 0; j < G.size(); ++j) for(int k = 0; k < G.size(); ++k) {\n    if(d[i][k] != -1 && d[k][j] != -1) {\n      if(d[i][j] == -1) d[i][j] = d[i][k] + d[k][j];\n      else              d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n  return d;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back({s, t, 0});\n    G[t].push_back({t, s, 0});\n  }\n\n  vector<int> cut_vertex;\n  vector<Edge> bridge;\n  for(auto S: connected_component(G)) lowlink(G, S.front(), S.front(), cut_vertex, bridge);\n\n//   set<int> S(begin(cut_vertex), end(cut_vertex));\n//   for(auto v: S) cout << v << endl;\n\n  for(auto& e: bridge) if(e.from > e.to) swap(e.from, e.to);\n  set<Edge, function<bool(Edge,Edge)>> S(begin(bridge), end(bridge), [](Edge lhs, Edge rhs){\n    if(lhs.from != rhs.from) return lhs.from < rhs.from;\n    if(lhs.to != rhs.to) return lhs.to < rhs.to;\n    return lhs.weight < rhs.weight;\n  });\n  for(auto e: S) cout << e.from << \" \" << e.to << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* low_link.cpp\n    グラフの関節点・橋の列挙をする\n\n    verified: AOJ GRL_3_A\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A\n    verified: AOJ GRL_3_B\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int to;\n};\nusing Graph = vector<vector<Edge>>;\nusing P = pair<long, long>;\n\n/* Lowlink: グラフの関節点・橋を列挙する構造体\n    作成: O(E+V)\n    関節点の集合: vector<int> aps\n    橋の集合: vector<P> bridges\n*/\nstruct LowLink {\n    vector<int> aps;  // articulation points\n    vector<P> bridges;\n\n    const Graph &G;\n    vector<int> used, ord, low;\n    LowLink(const Graph &G_) : G(G_) {\n        used.assign(G.size(), 0);\n        ord.assign(G.size(), 0);\n        low.assign(G.size(), 0);\n        int k = 0;\n        for (int i = 0; i < (int)G.size(); i++) {\n            if (!used[i]) k = dfs(i, k, -1);\n        }\n        sort(aps.begin(), aps.end());\n        sort(bridges.begin(), bridges.end());\n    }\n\n    int dfs(int id, int k, int par) {\n        used[id] = true;\n        ord[id] = k++;\n        low[id] = ord[id];\n        bool is_aps = false;\n        int count = 0;\n        for (auto &e : G[id]) {\n            if (!used[e.to]) {\n                count++;\n                k = dfs(e.to, k, id);\n                low[id] = min(low[id], low[e.to]);\n                if (par != -1 && ord[id] <= low[e.to]) is_aps = true;\n                if (ord[id] < low[e.to]) bridges.emplace_back(min(id, e.to), max(id, e.to));\n            } else if (e.to != par) {\n                low[id] = min(low[id], ord[e.to]);\n            }\n        }\n        if (par == -1 && count >= 2) is_aps = true;\n        if (is_aps) aps.push_back(id);\n        return k;\n    }\n};\n\n/*\n//verified: AOJ GRL_3_A\n//    http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A\nint main() {\n    long long V, E;\n    cin >> V >> E;\n    Graph G(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back({t});\n        G[t].push_back({s});\n    }\n\n    LowLink lowlink(G);\n\n    for (auto i : lowlink.aps) {\n        cout << i << endl;\n    }\n    return 0;\n}\n*/\n\n/*\n// verified: AOJ GRL_3_B\n//    http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n*/\nint main() {\n    long long V, E;\n    cin >> V >> E;\n    Graph G(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back({t});\n        G[t].push_back({s});\n    }\n\n    LowLink lowlink(G);\n\n    for (auto e : lowlink.bridges) {\n        cout << e.first << \" \" << e.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> G;\nvector<int> preorder;\nvector<int> low;\nusing P = pair<int,int>;\n\nvoid lowlink(int v,int prev, int &pre, vector<P>& ans){\n  preorder[v]=pre;\n  low[v]=pre;\n  for(auto to:G[v]){\n    if(preorder[to]==-1){\n      lowlink(to,v,++pre,ans);\n      if(low[to]==preorder[to]){\n        ans.emplace_back(min(v,to),max(v,to));\n      }\n      low[v]=min(low[v],low[to]);\n    }else if(to!=prev){\n      low[v]=min(low[v],preorder[to]);\n    }\n  }\n}\n\nint main(){\n  int V,E;\n  cin>>V>>E;\n  G.resize(V);\n  preorder.resize(V,-1);\n  low.resize(V);\n\n  for(int i=0;i<E;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  int p=1;\n  vector<P> ans;\n  lowlink(0,-1,p,ans);\n  sort(ans.begin(), ans.end());\n  for(auto a:ans){\n    cout<<a.first<<' '<<a.second<<endl;\n  }\n  // for(int i=0;i<V;i++){\n  //   cout<<i<<' '<<preorder[i]<<' '<<low[i]<<endl;\n  // }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        auto brec = fix([&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (isBridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        });\n        auto crec = fix([&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or isBridge(s, to)) { continue; }\n                self(self, to);\n            }\n        });\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) x.begin(),x.end()\nconst long double PI = acos(-1.0L);\nconst long long MOD = 1000000007LL;\n// const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct LowLink {\n    const vector<vector<int>> &G;\n    vector<bool> used;\n    vector<int> ord,low,articulation;\n    vector<pair<int, int>> bridge;\n\n    LowLink (const vector<vector<int>> &G) : G(G) {}\n\n    int dfs(int v, int k, int pv) {\n        used[v] = true;\n        ord[v] = k++;\n        low[v] = ord[v];\n        bool is_articulation = false;\n        int cnt = 0;\n        for (auto &nv : G[v]) {\n            if (!used[nv]) {\n                ++cnt;\n                k = dfs(nv, k, v);\n                low[v] = min(low[v],low[nv]);\n                is_articulation |= ~pv && low[nv] >= ord[v];\n                if (ord[v] < low[nv]) bridge.emplace_back(minmax(v, nv));\n            } else if (nv != pv) {\n                low[v] = min(low[v],ord[nv]);\n            }\n        }\n        is_articulation |= pv == -1 && cnt > 1;\n        if (is_articulation) articulation.emplace_back(v);\n        return k;\n    }\n\n    virtual void build() {\n        used.assign(G.size(), false);\n        ord.assign(G.size(), 0);\n        low.assign(G.size(), 0);\n        int k = 0;\n        for (int i = 0; i < G.size(); i++) {\n            if (!used[i]) k = dfs(i, k, -1);\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    vector<vector<int>> G(N);\n    rep(i,M) {\n        int s,t; cin >> s >> t;\n        G[s].emplace_back(t);\n        G[t].emplace_back(s);\n    }\n\n    LowLink LL(G);\n    LL.build();\n    sort(all(LL.bridge));\n    for (auto i : LL.bridge) cout << i.first << \" \" << i.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct Bridge{\n  int n;\n  vector<vector<int> > G;\n  vector<int>low,used,depth;\n  set<pair<int,int> >ans;\n  Bridge(){}\n  Bridge(int sz):n(sz),low(sz),used(sz),depth(sz),G(sz){}\n  void add(int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  void dfs(int x,int d,int prev){\n    depth[x]=d;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i];\n      if(nx==prev)continue;\n      if(!used[nx]){\n        used[nx]=true;\n        dfs(nx,d+1,x);\n        if(!low[nx]) ans.insert(P(min(x,nx),max(x,nx)));\n        low[x]+=low[nx];\n      }\n      else if(d>depth[nx])low[nx]--,low[x]++;\n    }\n  }\n  void build(){\n    fill(used.begin(),used.end(),0);\n    fill(low.begin(),low.end(),0);\n    fill(depth.begin(),depth.end(),0);\n    used[0]=1;\n    dfs(0,0,0);\n  }\n  void prin(){\n    set<P>::iterator it=ans.begin();\n    while(it!=ans.end()){\n      cout<< (*it).first <<' '<< (*it).second <<endl;\n      it++;\n    }\n  }\n};\nint main(){\n  int n,m,s,t;\n  cin>>n>>m;\n  Bridge B(n);\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    B.add(s,t);\n  }\n  B.build();\n  B.prin();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v[100005],e[100000];\ntypedef pair<int,int> p;\npair<int,int> ep[100000];\nvector<int> ve[100000];\nint vv[100000],ev[100000],ef[100000];\n\nint dfs(int vi,int ei){\n  //cout<<vi<<\" \"<<ei<<11<<endl;\n  if(vv[vi]){\n    ef[ei]++;\n    if(ep[ei].first!=vi)swap(ep[ei].first,ep[ei].second);\n    v[ep[ei].first]--;\n    v[ep[ei].second]++;\n    return 1;\n  }\n  vv[vi]=1;\n  for(int i=0;i<(int)ve[vi].size();i++){\n    //cout<<vi<<\" \"<<ve[vi][i]<<endl;\n    int ne=ve[vi][i];\n    if(ev[ne])continue;\n    ev[ne]=1;\n    if(ep[ne].first!=vi)swap(ep[ne].first,ep[ne].second);\n    v[vi]+=dfs(ep[ne].second,ne);\n  }\n  ef[ei]+=v[vi];\n  return v[vi];\n}\n\nint main(){\n  int V,E;\n  cin>>V>>E;\n  for(int i=0;i<E;i++){\n    cin>>ep[i].first>>ep[i].second;\n    ve[ep[i].first].push_back(i);\n    ve[ep[i].second].push_back(i);\n  }\n  //cout<<endl;\n  dfs(0,E);\n  for(int i=0;i<E;i++){\n    //cout<<ef[i]<<endl;\n    if(ef[i]==0)cout<<ep[i].first<<\" \"<<ep[i].second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 77777\nvector<int>X[MAX_N];\nint used[MAX_N];\nint N, M, A, B; queue<int>Q;\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> A >> B; X[A].push_back(B);\n\t\tX[B].push_back(A);\n\t}\n\tif (N == 1) { return 0; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint a1 = i, a2 = X[i][j];\n\t\t\tfor (int k = 0; k < N; k++) { used[k] = 0; }\n\t\t\tused[0] = 1; Q.push(0); int cnt = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint to = Q.front(); Q.pop();\n\t\t\t\tfor (int k = 0; k < X[to].size(); k++) {\n\t\t\t\t\tif (used[X[to][k]] == 0 && (to != i || k != j) ) {\n\t\t\t\t\t\tused[X[to][k]] = 1; Q.push(X[to][k]); cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != N && a1 < a2) { cout << a1 << ' ' << a2 << endl; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iomanip>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MAX=100005;\nconst int inf=1e9;\nvi G[MAX];\nint N;\nbool visited[MAX];\ntypedef pair<int,int> P;\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\nvoid dfs(int current,int prev)\n{\n  prenum[current]=lowest[current]=timer;\n  timer++;\n\n  visited[current]=true;\n  int next;\n  for(int i=0;i<G[current].size();i++)\n  {\n    next=G[current][i];\n    if(!visited[next])\n    {\n      parent[next]=current;\n      dfs(next,current);\n      lowest[current]=min(lowest[current],lowest[next]);\n      if(prenum[current]<=lowest[next]) bridge.push_back(P(current,next));\n    }\n    else if(next!=prev)\n    {\n      lowest[current]=min(lowest[current],prenum[next]);\n      if(prenum[current]<=lowest[next]) bridge.push_back(P(current,next));\n    }\n  }\n}\n\nvoid bridge_points()\n{\n  timer=1;\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n  {\n    cout << bridge[i].first << ' ' << bridge[i].second << endl;\n  }\n}\n\nint main(void)\n{\n  int m;\n  cin >> N >> m;\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<m;i++)\n  {\n    int s,t;\n    cin >> s>> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  bridge_points();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nbool mark[MAX_N];\nifstream in(\"in1.txt\");\nofstream out(\"out1.txt\");\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            dp[v]=min(dp[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            dp[v]=min(dp[v],dp[u]);\n        }\n    }\n    if(dp[v]>=depth[v]&&l!=-1)\n        out<<from[l]<<\" \"<<to[l]<<'\\n';\n}\nint main(){\n    return 0;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    in>>n>>m;\n    //fill(dp,dp+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        if(i>=m){\n            dp[i]=INF;\n            continue;\n        }\n        dp[i]=INF;\n        in>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  auto begin() { return g.begin(); }\n  auto end() { return g.end(); }\n};\n\nclass TwoEdgeConnectedComponents {\npublic:\n  Graph g;\n  Edges bridges;\n  vector<int> cmp;\n\n  TwoEdgeConnectedComponents(const Graph &g) : g(g) {\n    int n = g.size();\n    cmp.resize(n);\n    stack<int> s, roots;\n    vector<int> ord(n, -1);\n    int id = 0, k = 0;\n    vector<int> onS(n), cmp(n);\n    function<void(int, int)> dfs = [&](int v, int u) {\n      ord[v] = id++;\n\n      s.emplace(v);\n      onS[v] = true;\n      roots.emplace(v);\n      for (auto &e : g[v]) {\n        int w = e.dst;\n        if (ord[w] == -1) {\n          dfs(w, v);\n        } else if (u != w && onS[w]) {\n          while (ord[roots.top()] > ord[w]) roots.pop();\n        }\n      }\n      if (v == roots.top()) {\n        bridges.emplace_back(u, v, 0);\n        while (true) {\n          int w = s.top();\n          s.pop();\n          onS[w] = false;\n          cmp[w] = k;\n          if (v == w) break;\n        }\n        roots.pop();\n        k++;\n      }\n    };\n\n    rep(i, n) {\n      if (ord[i] != -1) continue;\n      dfs(i, n);\n      bridges.pop_back();\n    }\n  }\n};\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  rep(i, m) {\n    int s, t;\n    cin >> s >> t;\n    g.addEdge(s, t);\n  }\n  TwoEdgeConnectedComponents tecc(g);\n  vector<pair<int, int>> es;\n  for (auto &e : tecc.bridges) es.emplace_back(e.src, e.dst);\n  sort(all(es));\n  for (auto &e : es) cout << e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nvector<Edge> g[100001];\nint prenum[100001],parent[100001],lowest[100001],visited[100001],cnt = 1,child[100001];\n\nvoid Articulation_Points(int k,int p){\n  visited[k] = true;\n  prenum[k] = cnt;\n  lowest[k] = cnt;\n  ++cnt;\n  for (auto&& n : g[k]) {\n    if(!visited[n.to]){\n      parent[n.to] = k;\n      Articulation_Points(n.to,k);\n      child[k]++;\n      lowest[k] = min(lowest[k],lowest[n.to]);\n    }\n    else if(n.to != p){\n      lowest[k] = min(lowest[k],prenum[n.to]);\n    }\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n ,a,b,e;\n  cin >> n >> e;\n  rep(i,e){\n    cin >> a >> b;\n    g[a].push_back({b,0LL});\n    g[b].push_back({a,0LL});\n  }\n  Articulation_Points(0,-1);\n  set<int> art;\n  set<pair<int,int>> ans;\n  int np = 0;\n  for (int i = 1; i < n; i++) {\n    int p = parent[i];\n    if(p == 0){\n      ++np;\n    }\n    else{\n      if(prenum[p] <= lowest[i]){\n        art.insert(p);\n      }\n    }\n  }\n  if(np > 1) art.insert(0);\n  rep(i,n){\n    if(g[i].size() == 1)\n      art.insert(i);\n  }\n  REP(i,1,n){\n    int p = parent[i];\n    if(prenum[i] <= lowest[i]){\n      if(i < p){\n        ans.insert({i,p});\n      }\n      else\n        ans.insert({p,i});\n    }\n  }\n  for (auto&& k : ans) {\n    std::cout << k.fi << ' ' << k.se << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INFLL=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int max_v=100000;\nvector<int> graph[max_v];\nbool used_v[max_v];\nmap<int,bool> used_e[max_v];\nint ord[max_v],lowlink[max_v];\nvector<pii> bridges;\n\nvoid dfs(int v,int &k){\n    used_v[v]=true;\n    ord[v]=lowlink[v]=k++;\n    for(int u:graph[v]){\n        if(!used_v[u]){\n            used_e[v][u]=true;\n            dfs(u,k);\n            lowlink[v]=min(lowlink[v],lowlink[u]);\n            if(ord[v]<lowlink[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n        }else if(!used_e[u][v]) lowlink[v]=min(lowlink[v],ord[u]);\n    }\n}\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    \n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n    }\n    \n    int k=0;\n    dfs(0,k);\n    \n    sort(bridges.begin(),bridges.end());\n    \n    for(auto &e:bridges) cout << e.first << \" \" << e.second << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nvoid dfs(int& u, int& k, vector<vector<int>>& g, set<tuple<int, int>>& g_set,\n         vector<int>& ord, vector<int>& low, vector<bool>& visited,\n         set<tuple<int, int>>& bridge) {\n    visited[u] = true;\n    ord[u] = k, low[u] = k;\n    k++;\n    for (int v : g[u]) {\n        if (g_set.count(make_tuple(u, v))) { g_set.erase(make_tuple(u, v)); }\n        if (visited[v] == false) {\n            dfs(v, k, g, g_set, ord, low, visited, bridge);\n            bridge.insert(make_tuple(u, v));\n            low[u] = min(low[u], low[v]);\n        } else if (g_set.count(make_tuple(v, u))) {\n            low[u] = min(low[u], ord[v]);\n        }\n    }\n}\nauto bridge_articulation(vector<vector<int>>& g) {\n    int n = (int)g.size(), inf = -pow(10, 9), k = 0, start = 0, u, v, cnt = 0;\n    set<tuple<int, int>> g_set, edge;\n    vector<int> articulation_temp(n, 0), articulation, ord(n, -1), low(n, -1);\n    vector<tuple<int, int>> bridge;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; i++) {\n        for (int j : g[i]) { g_set.insert(make_tuple(i, j)); }\n    }\n    articulation_temp[0] = -1;\n    dfs(start, k, g, g_set, ord, low, visited, edge);\n    for (tuple<int, int> temp : edge) {\n        tie(u, v) = temp;\n        if (u == 0) { cnt++; }\n        if (ord[u] <= low[v]) {\n            articulation_temp[u]++;\n            if (ord[u] < low[v]) {\n                bridge.push_back(make_tuple(min(u, v), max(u, v)));\n            }\n        } else {\n            articulation_temp[u] = inf;\n        }\n    }\n    if (cnt > 1) { articulation_temp[0] = 1; }\n    for (int i = 0; i < n; i++) {\n        if (articulation_temp[i] > 0) { articulation.push_back(i); }\n    }\n    return bridge;  // 橋\n    // return articulation; // 関節点\n}\nint main() {\n    PRE_COMMAND\n    int n, m;\n    INPUT(n, m);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    auto b = bridge_articulation(g);\n    SORT(b);\n    for (auto i : b) { PRINT(i); }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> g[100010];\n\nint zeit, dis[MAXN], fin[MAXN], low[MAXN], par[MAXN], dep[MAXN];\nint kodat[MAXN], koptr[MAXN + 1];\nvoid dfsInfo(int u,int oy,int d){\n\tdis[u] = low[u] = zeit++; par[u] = oy; dep[u] = d;\n\tint v;\n\trep(i,sz(g[u])) if((v = g[u][i]) != oy){\n\t\tif(!~dis[v]){\n\t\t\tdfsInfo(v, u, d + 1);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], dis[v]);\n\t\t}\n\t}\n\tfin[u] = zeit++;\n}\n\nvoid dfsInfos(){\n\tmemset(dis, ~0, n*4); zeit = 0;\n\trep(u,n) if(!~dis[u]) dfsInfo(u, -1, 0);\n\trep(u,n){\n\t\tint &j = koptr[u + 1] = koptr[u];\n\t\trep(i,sz(g[u])) if(u == par[g[u][i]]) kodat[j++] = g[u][i];\n\t}\n}\n\nbool produce(int u,int v){\n\treturn (dis[u] <= dis[v] && fin[u] >= fin[v]);\n}\n\nint related(int u,int v){\n\tint s = koptr[u], e = koptr[u+1], h;\n\twhile(s+1 < e){\n\t\th = (s + e) >> 1;\n\t\t(dis[kodat[h]] <= dis[v]) ? s = h : e = h;\n\t}\n\treturn kodat[s];\n}\n\nbool isBridge(int u,int v){\n\tif(dis[u] > dis[v]) swap(u, v);\n\treturn (u == par[v] && dis[v] <= low[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\n\tint m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\trep(i,n)sort(g[i].begin(),g[i].end());\n\tdfsInfos();\n\t/*rep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && isBridge(i,g[i][j]))cout<<i<<\" \"<<g[i][j]<<endl;\n\t}*/\n\t//rep(i,n)cout<<dis[i]<<\" \";cout<<endl;\n\t//rep(i,n)cout<<low[i]<<\" \";cout<<endl;\n\trep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && (dis[i] < low[g[i][j]] || dis[g[i][j]] < low[i])){\n\t\t\tcout<<i<<\" \"<<g[i][j]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[cmp[p]].pb(x+1);G2[x+1].pb(cmp[p]);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));x++;\n\t\t\t}else chmax(mx, build(G[p][i], cmp[p]));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nvector<vector<int> > G, G2;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tG.resize(n);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t\tG[v].pb(u);G[u].pb(v);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G2 = low.G2;\n\tvector<int> cmp = low.cmp;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tint from = cmp[i], to = cmp[G[i][j]];\n\t\t\tif(from < to)ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\tZIP(ans);\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iomanip>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MAX=100005;\nconst int inf=1e9;\nvi G[MAX];\nint N;\nbool visited[MAX];\ntypedef pair<int,int> P;\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\nvoid dfs(int current,int prev)\n{\n  prenum[current]=lowest[current]=timer;\n  timer++;\n\n  visited[current]=true;\n  int next;\n  for(int i=0;i<G[current].size();i++)\n  {\n    next=G[current][i];\n    if(!visited[next])\n    {\n      parent[next]=current;\n      dfs(next,current);\n      lowest[current]=min(lowest[current],lowest[next]);\n      if(prenum[current]<lowest[next]) bridge.push_back(P(min(current,next),max(current,next)));\n    }\n    else if(next!=prev)\n    {\n      lowest[current]=min(lowest[current],prenum[next]);\n    }\n  }\n}\n\nvoid bridge_points()\n{\n  timer=1;\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n  {\n    cout << bridge[i].first << ' ' << bridge[i].second << endl;\n  }\n}\n\nint main(void)\n{\n  int m;\n  cin >> N >> m;\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<m;i++)\n  {\n    int s,t;\n    cin >> s>> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  bridge_points();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kNil = -1;\n\nenum class Color {\n  kWhite,\n  kGrey,\n  kBlack,\n};\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\nvoid BridgesVisit(\n    const typename vector<Edge>::size_type node_now,\n    typename vector<Edge>::size_type & time,\n    const vector<vector<Edge>> & adjacency_list,\n    vector<int> & d,\n    vector<int> & low,\n    vector<Color> & color,\n    vector<int> & parent) {\n  color[node_now] = Color::kGrey;\n  d[node_now] = time;\n  low[node_now] = time++;\n  unsigned child_num = 0;\n  for (const auto & e: adjacency_list[node_now]) {\n    if (color[e.v] == Color::kWhite) {\n      ++child_num;\n      parent[e.v] = e.u;\n      BridgesVisit(e.v, time, adjacency_list, d, low, color, parent);\n      low[e.u] = min(low[e.u], low[e.v]);\n    } else if (parent[e.u] != e.v) {\n      low[e.u] = min(low[e.u], d[e.v]);\n    }\n  }\n  color[node_now] = Color::kBlack;\n}\n\ntemplate <class Edge>\ndecltype(auto) Bridges(vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n\n  sort(edges.begin(), edges.end());\n\n  vector<vector<Edge>> adjacency_list(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency_list[e.u].push_back(e);\n    adjacency_list[e.v].emplace_back(e.v, e.u, e.w);\n  }\n\n  size_type time = 0;\n  vector<int> d(node_num);\n  vector<int> low(node_num);\n  vector<Color> color(node_num, Color::kWhite);\n  vector<int> parent(node_num, kNil);\n\n  for (unsigned i = 0; i < node_num; ++i) {\n    if (color[i] == Color::kWhite) {\n      BridgesVisit(i, time, adjacency_list, d, low, color, parent);\n    }\n  }\n\n  vector<Edge> bridges;\n  for (const auto & e: edges) {\n    if (d[e.u] < low[e.v]) {\n      bridges.push_back(e);\n    }\n  }\n\n  return bridges;\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = unsigned;\n\n  vector<Edge<w_type>> edges;\n  unsigned V, E;\n  cin >> V >> E;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    w_type w;\n    cin >> u >> v;\n    edges.emplace_back(u, v, 1);\n  }\n\n  auto bridges = Bridges(edges, V);\n  for (const auto & e: bridges) {\n    cout << e.u << \" \" << e.v << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nstruct Edge {\n\tint src;\n\tint dst;\n\tint id;\n};\n\n// res: bridges\n// v: current node\n// from: parent node\nint dfs2(vector<vector<Edge>>&g, vector<int>& res, int v, int& count, int from_id, vector<int>& low, vector<int>& pre) {\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (auto it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = it->dst;\n\t\tif (pre[to] == -1) {\n\t\t\t// destination has not been visited\n\t\t\t// visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs2(g, res, to, count, it->id, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t// edge is not contained in a closed path -> bridge\n\t\t\t\t//res.push_back(it->id);\n\t\t\t\tres[it->id] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from_id == it->id) {\n\t\t\t\t// ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// Calculate bridges in a undirected graph.\n// Assume graph is connected and has no parallel edges or self-loops.\n// g: adjacency list\n// V: number of nodes\nvoid  bridges(vector<vector<Edge>>&g, int V, vector<int>&res) {\n\n\tif (V > 0) {\n\t\t// assume at least the first vertex exists\n\t\tvector<int> low(V, -1);  // lowest reacheable index\n\t\tvector<int> pre(V, -1);  // pre-order index\n\t\tint count = 0;  // pre-order index counter\n\t\tdfs2(g, res, 0, count, -1, low, pre);  // start dfs from vertex 0\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<Edge>>es(V);\n\tvector<Edge>eids;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tif (s > t)swap(s, t);\n\t\tes[s].push_back(Edge{ s,t,i });\n\t\tes[t].push_back(Edge{ t,s,i });\n\t\teids.push_back(Edge{ s,t,i });\n\t}\n\tvector<int>res(E);\n\tbridges(es, V, res);\n\tvector<Edge>bris;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (res[i])bris.push_back(eids[i]);\n\t}\n\tsort(bris.begin(), bris.end(), [=](const Edge&l, const Edge&r) {\n\t\treturn l.src == r.src ? l.dst < r.dst : l.src < r.src;\n\t});\n\tfor (int i = 0; i < bris.size(); ++i) {\n\t\tcout << bris[i].src << \" \" << bris[i].dst << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nvector<bool> check(V_MAX,false);\nvector<int> pre(V_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(check[s]==true){return;}\n\tcheck[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(G[s][i]!=p && low[G[s][i]]<low[s]){\n\t\t\tlow[s]=pre[G[s][i]];\n\t\t}\n\t\tif(check[G[s][i]]==false){\n\t\t\tdfs(G[s][i],s);\n\t\t}\n\t}\n\t\n\tif(!(s==0&&p==0) && pre[s]==low[s]){\n\t\tedge e;\n\t\te.from=min(s,p);\n\t\te.to=max(s,p);\n\t\tresult.push_back(e);\n\t\t//cout << p << \" \" << s << endl;\n\t}\n\t\n\t\n\t\n\tif(low[p]>low[s]){\n\t\tlow[p]=low[s];\n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) x.begin(),x.end()\n#define dmp(x) cerr<<#x<<\":\"<<x<<endl\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP; \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nconst int MOD = 1e9+7;\n\nvector<int> g[111111];\nvector<P> bs;\nvector<int> pre(111111,-1),low(111111,-1);\nint t;\n\nint dfs(int x=0,int p=-1){\n  if(pre[x]!=-1)return pre[x];\n  low[x]=pre[x]=t++;\n  for(int i=0;i<g[x].size();i++){\n    if(g[x][i]==p)continue;\n    low[x]=min(low[x],dfs(g[x][i],x));\n  }\n  if(p!=-1&&low[x]==pre[x]){\n    if(p<x)swap(p,x);\n    bs.pb(P(x,p));\n  }\n  return low[x];\n}\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    g[s].pb(t);\n    g[t].pb(s);\n  }\n  dfs();\n  sort(all(bs));\n  for(auto a:bs)cout<<a.fi<<\" \"<<a.se<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨???????????????????????????2?????\\?????????????????¨?????????DFS??¨???????????¨??????. ???????????????????????¨??????????????????????????????\n//???DFS??¨?????????????????????u???????????????u?????????prenum <= u???lowest ??? u??¨u??????????????????????????????\n//??????????¨???????u --> ?????¨????????????u?????? (u --> u??????) ???????????????????????????\n// ( ???????¨????????????¶?¨????????????????u?????????????????????u --> ?????¨??????????????????u --> u????\\????x??¨??????????????§???lowest[u] <= prenum[x]????????????x???prenum < u?????????prenum?????????????????????)\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\tint rootChildNum = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (parent[i] == 0) { rootChildNum++; }\n\t}\n\t\n\tif (rootChildNum >= 2) {\n\t\tfor (int i = 1; i < n; i++) { if (parent[i] == 0) { ans.push_back(Edge(0, i)); } }\n\t}\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (parent[i] == 0) continue;\n\t\tif (prenum[parent[i]] <= lowest[i]) {\n\t\t\tans.push_back(Edge(parent[i], i));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\t\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨?????????u(???root)???????????????lowlink[u] > prenum[u??????] ??? u?????? --> u?????? (??¨??????)\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse if (parent[u] != v) {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (prenum[parent[i]] < lowest[i]) {\n\t\t\tans.push_back(Edge(parent[i], i));\n\t\t}\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T1, class T2> inline void minup(T1& m, T2 x){ if(m>x) m=static_cast<T2>(x); }\ntemplate<class T1, class T2> inline void maxup(T1& m, T2 x){ if(m<x) m=static_cast<T2>(x); }\n\n#define INF 1000000000\n#define MOD 1000000009\n#define EPS 1E-9\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u, Edges& brdg, vector< vector<int> >& tecomp, stack<int>& roots, stack<int>& S, vector<bool>& inS, vector<int>& num, int& time)\n{\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  vrep(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 1));\n    tecomp.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      tecomp.back().push_back(w);\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\n\nvoid Bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp)\n{\n  const int n = g.size();\n  vector<int> num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  rep(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint V, E;\nint s, t;\n\nint main()\n{\n  cin >> V >> E;\n  Graph g(V);\n  Edges brdg;\n  vector<vi> tecomp;\n  rep(i, E){\n    cin >> s >> t;\n    g[s].pb(Edge(s, t, 1));\n    g[t].pb(Edge(t, s, 1));\n  }\n\n  Bridge(g, brdg, tecomp);\n\n  vrep(v, brdg) if(v->src > v->dst) swap(v->src, v->dst);\n  sort(ALL(brdg));\n\n  vrep(v, brdg) cout << v->src << \" \" << v->dst << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint v, e;\nstruct Edge {\n  Edge() : isBridge(true) {}\n  Edge(int src_, int dest_) : src(src_), dest(dest_), isBridge(true) {}\n  int src;\n  int dest;\n  bool isBridge;\n};\nstd::vector<Edge> graph[112345];\n\nvoid load() {\n  scanf(\"%d %d\", &v, &e);\n  for(int i = 0; i < e; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    graph[a].push_back(Edge(a, b));\n    graph[b].push_back(Edge(b, a));\n  }\n}\n\nint dfi[112345];\nint parent[112345];\nint dfiid = 1;\nstd::vector<int> backEdges[112345];\nstd::vector<int> ascNodes;\n\nvoid dfs(int i, int prev) {\n  dfi[i] = dfiid;\n  dfiid += 1;\n  ascNodes.push_back(i);\n  for(Edge edge : graph[i]) {\n    int src = edge.src;\n    int dest = edge.dest;\n    if( dest == prev ) continue;\n    if( dfi[dest] == 0 ) {\n      dfs(dest, src);\n      parent[dest] = src;\n    }\n    else {\n      // backEdge\n      backEdges[dest].push_back(src);\n      // printf(\"backEdge %d %d\\n\", src, dest);\n    }\n  }\n}\n\nbool visited[112345];\nbool traversed[112345];\nvoid traverse(int id) {\n  if( visited[id] ) return;\n  visited[id] = true;\n  traversed[id] = true;\n  traverse(parent[id]);\n}\nvoid calcChains() {\n  for(int id : ascNodes) {\n    visited[id] = true;\n    for(int parent : backEdges[id]) {\n      traverse(parent);\n    }\n  }\n}\n\nint main() {\n  load();\n  parent[0] = -1;\n  dfs(0, -1);\n  // for(int i = 0; i < v; ++i) {\n  //   printf(\"(v, parent, dfi) = (%d, %d, %d)\\n\", i, parent[i], dfi[i]);\n  // }\n  calcChains();\n  std::vector<std::pair<int, int>> res;\n  for(int i = 0 + 1; i < v; ++i) {\n    if( not traversed[i] ) {\n      res.push_back(std::make_pair(std::min(i, parent[i]), std::max(i, parent[i])));\n    }\n  }\n  for(std::pair<int, int> st : res) {\n    printf(\"%d %d\\n\", st.first, st.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint n;\nvector<vector<int>> graph;\nvector<int> ord, low;\nvector<pair<int, int>> bridge;\n\nvoid dfs(int v, int p, int& k) {\n    ord[v] = low[v] = k++;\n    for (int u : graph[v]) {\n        if (u == p) continue;\n        else if (ord[u] == -1) {\n            dfs(u, v, k);\n            low[v] = min(low[v], low[u]);\n            if (low[u] == ord[u]) {\n                bridge.emplace_back(v, u);\n            }\n        }\n        else {\n            low[v] = min(low[v], low[u]);\n        }\n    }\n}\n\nvoid build() {\n    ord.assign(n, -1);\n    low.resize(n);\n\n    int k = 0;\n    dfs(0, -1, k);\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    graph.resize(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n    }\n\n    n = V;\n    build();\n    for (auto&& e : bridge) {\n        if (e.first > e.second) swap(e.first, e.second);\n    }\n    sort(bridge.begin(), bridge.end());\n    for (auto&& e : bridge) {\n        cout << e.first << ' ' << e.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tinit(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[x].pb(x+1);G2[x+1].pb(x);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));\n\t\t\t}\n\t\t\tchmax(mx, build(G[p][i], x));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G = low.G2;\n\trep(i,size){\n\t\trep(j,G[i].size()){\n\t\t\tif(i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\t//printf(\"%lld\\n\", size);\n\tsort(all(ans));\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <stack>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph & g, int v, int u,\n    Edges& brdg, vector< vector<int> >& tecomp,\n    stack<int>& roots, stack<int>& S, vector<bool>& inS,\n    vector<int>& num, int& time) {\n  num[v] = ++time;\n  S.push(v); inS[v] = true;\n  roots.push(v);\n  FOR(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0)\n      visit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n    else if (u != w && inS[w])\n      while (num[roots.top()] > num[w]) roots.pop();\n  }\n  if (v == roots.top()) {\n    brdg.push_back(Edge(u, v, 0));\n    tecomp.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      tecomp.back().push_back(w);\n      if (v == w) break;\n    }\n    roots.pop();\n  }\n}\nvoid bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp) {\n  const int n = g.size();\n  vector<int> num(n);\n  vector<bool> inS(n);\n  stack<int> roots, S;\n  int time = 0;\n  REP(u, n) if (num[u] == 0) {\n    visit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n    brdg.pop_back();\n  }\n}\n\nint main(){\n\tint V,E,s,t;\n\tscanf(\"%d%d\",&V,&E);\n\tGraph g(V);\n\tEdges brdg;\n\tvector<vector<int> > tecomp;\n\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(Edge(s,t,0)),g[t].push_back(Edge(t,s,0));\n\tbridge(g,brdg,tecomp);\n\tFOR(e, brdg)if(e->src>e->dst)swap(e->src,e->dst);\n\tsort(ALL(brdg));\n\tFOR(e, brdg)printf(\"%d %d\\n\",e->src,e->dst);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nclass low_link_tree {\n\tint n;\n\tint tmr;\n\tint rt = 0;\n\tvector<int> ord;\n\tvector<int> low;\n\tset<int> atc;\n\tset<pair<int, int>> bdg;\n\tvector<vector<int>> grh;\npublic:\n\tlow_link_tree (\n\t\tvector<vector<int>> const& grh\n\t)\n\t: n(grh.size())\n\t, ord(n, -1)\n\t, low(n, -1)\n\t, grh(grh)\n\t{\n\t\tdfs(0, 0);\n\t}\n\tvoid dfs (\n\t\tint crr\n\t,\tint prt\n\t) {\n\t\tint cnt = 0;\n\t\tord[crr] = low[crr] = tmr++;\n\t\tfor (int nxt : grh[crr]) {\n\t\t\tif (ord[nxt] == -1) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, crr);\n\t\t\t\tchmin(low[crr], low[nxt]);\n\t\t\t\tif (crr != rt && ord[crr] <= low[nxt]) atc.insert(crr);\n\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));\n\t\t\t}\n\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);\n\t\t}\n\t\tif (crr == rt && cnt > 1) atc.insert(crr);\n\t}\n\tauto const &order() {return ord;}\n\tauto const &low_link() {return low;}\n\tauto const &articulation_points() {return atc;}\n\tauto const &bridges() {return bdg;}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tauto bdg = low_link_tree(grh).bridges();\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nclass LowLink\n{\n    using Graph = std::vector<std::vector<int>>;\n    using P = std::pair<int, int>;\n    std::vector<int> order;\n    int next = 0;\n    Graph G;\n    std::set<P> bridges;\n\n    void add(int a, int b)\n    {\n        bridges.insert(P(min(a, b), max(a, b)));\n    }\n    int dfs(int cur, int pre)\n    {\n        int res = order[cur] = next++;\n        for (const auto &to : G[cur])\n        {\n            if (to == pre)\n                continue;\n            if (order[to] >= 0)\n                res = std::min(res, order[to]);\n            else\n            {\n                int low = dfs(to, cur);\n                if (low > order[cur])\n                    add(cur, to);\n                res = std::min(res, low);\n            }\n        }\n        return res;\n    }\n\n  public:\n    LowLink(int _v) : G(_v, std::vector<int>()), order(_v, -1) {}\n    void addEdge(int s, int t)\n    {\n        G[s].push_back(t);\n    }\n    std::set<P> bridge()\n    {\n        dfs(0, -1);\n        return bridges;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n    LowLink link(V);\n    while (E--)\n    {\n        int s, t;\n        cin >> s >> t;\n        link.addEdge(s, t);\n        link.addEdge(t, s);\n    }\n    auto st = link.bridge();\n    for (auto p : st)\n    {\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 10000\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[MAX_V]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=0;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  //bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int SIZE = 100013;\n\ntypedef pair<int, int> pii;\n\nbool visited[SIZE];\nint disc[SIZE], low[SIZE], parent[SIZE];\n\nvector<int> G[SIZE];\n\n\nvoid bridges(int u, priority_queue<pii > *bridge){\n  static int time = 0;\n  int children = 0;\n  visited[u] = true;\n  disc[u] = low[u] = ++time;\n  for(int i = 0; i < G[u].size(); i++){\n    int v = G[u][i];\n    if(!visited[v]){\n      children++;\n      parent[v] = u;\n      bridges(v, bridge);\n      low[u] = min(low[u], low[v]);\n      if(low[v] > disc[u]) bridge->push({u,v});\n    }\n    else if(v != parent[u])\n      low[u] = min(low[u], disc[v]);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n,m;\n  cin>>n>>m;\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n  }\n  priority_queue<pii> bridge;\n  for(int i = 0; i < SIZE; i++)\n    parent[i] = -1;\n  bridges(0, &bridge);\n  while(!bridge.empty()){\n    cout<<bridge.top().first<<\" \"<<bridge.top().second<<\"\\n\";\n    bridge.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ GRL_3_B: Connected Components - Bridges\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }  \n  int find(int x) { return data[x] < 0 ? x : data[x] = find(data[x]); }\n  bool same(int x, int y) { return find(x) == find(y); }  \n  int unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] < data[y]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return -data[x];\n  }\n};\n\n// Biconnected Components (lowlink)\nstruct BICC\n{\n  UnionFind uf;\n  vector< vector<int> > graph, tree;\n  vector<Pi> edges;\n  vector<bool> vis;\n  vector<int> ord, low, cmp;\n  vector<int> articulation;\n  vector<Pi> bridge;\n  BICC(int sz):uf(sz), graph(sz), vis(sz, false), ord(sz), low(sz), cmp(sz){}\n  void add_edge(int u, int v)\n  {\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n    edges.emplace_back(minmax(u, v));\n  }\n  void dfs(int u, int p, int& k)\n  {\n    vis[u] = true;\n    \n    ord[u] = low[u] = k++;\n\n    bool is_articulation = false;\n    int cnt = 0;\n    \n    for(auto v : graph[u]) {\n      if(!vis[v]) {\n\tcnt++;\n\tdfs(v, u, k);\n\tlow[u] = min(low[u], low[v]);\n\tif(~p && ord[u] <= low[v]) is_articulation = true;\n\tif(ord[u] < low[v]) bridge.emplace_back(minmax(u, v));\n\telse uf.unite(u, v);\n      } else if(v != p) {\n\tlow[u] = min(low[u], ord[v]);\n      }\n    }\n    \n    if(p == -1 && cnt > 1) is_articulation = true;\n    if(is_articulation) articulation.push_back(u);\n  }\n  void compose()\n  {\n    int k = 0;\n    dfs(0, -1, k);\n\n    int num = 0;\n    vector<int> conn(graph.size());\n    for(int i = 0; i < graph.size(); i++) {\n      if(i == uf.find(i)) conn[i] = num++;\n    }\n\n    tree.resize(num);\n    for(int i = 0; i < graph.size(); i++) {\n      cmp[i] = conn[uf.find(i)];\n    }\n    for(auto e : edges) {\n      int x = cmp[e.first], y = cmp[e.second];\n      if(x == y) continue;\n      tree[x].emplace_back(y);\n      tree[y].emplace_back(x);\n    }\n  }\n};\n\n\nint main()\n{\n  int V, E; cin >> V >> E;\n  BICC bicc(V);\n  while(E--) {\n    int s, t;\n    cin >> s >> t;\n    bicc.add_edge(s, t);\n  }\n  bicc.compose();\n  sort(all(bicc.bridge));\n  rep(i, bicc.bridge.size()) cout << bicc.bridge[i].first << \" \" << bicc.bridge[i].second << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??£?????°????????¨????????????\n//????????????????????????????????? (????????????????????¨?????°?????????DFS??¨??????????????????)\n//???DFS??¨?????????u(???root)???????????????lowlink[u] > prenum[u??????] ??? u?????? --> u?????? (??¨??????)\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint u, v;\n\tEdge(int u, int v) { this->u = u; this->v = v; }\n\tEdge() { }\n\tbool operator<(const Edge &r) const { return (u != r.u) ? u < r.u : v < r.v; }\n};\n\nint n, m;\nvector<int> et[100000];\n\nint timer;\nbool visited[100000];\nint prenum[100000];\nint lowest[100000];\nint parent[100000];\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = timer;\n\tlowest[u] = timer;\n\tparent[u] = prev;\n\tvisited[u] = true;\n\ttimer++;\n\t\n\tfor (int i = 0; i < et[u].size(); i++) {\n\t\tint v = et[u][i];\n\t\t\n\t\tif (!visited[v]) {\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse if (parent[u] != v) {\n\t\t\t//u --> v????????????\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint src, dst;\n\t\tcin >> src >> dst;\n\t\tet[src].push_back(dst);\n\t\tet[dst].push_back(src);\n\t}\n\t\n\t//????????????\n\ttimer = 0;\n\tfor (int i = 0; i < n; i++) visited[i] = false;\n\tdfs(0, -1);\n\t\n\tstatic vector<Edge> ans;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tif (prenum[parent[i]] < lowest[i]) {\n\t\t\tans.push_back(Edge(min(parent[i], i), max(parent[i], i)));\n\t\t}\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i].u << \" \" << ans[i].v << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> parent;\nvector<int> rnk;\n\nvoid init(int n){\n    parent.clear();\n    rnk.clear();\n    for(int i=0; i<n; i++){\n        parent.push_back(i);\n        rnk.push_back(0);\n    }\n}\n\nint find(int x){\n    if(x == parent[x]){\n        return x;\n    } else {\n        return parent[x] = find(parent[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    if(x == y) return;\n\n    if(rnk[x] < rnk[y]){\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector<int> fs(e), ts(e);\n    for(int i=0; i<e; i++) cin >> fs[i] >> ts[i];\n\n    int cnt = 0;\n    for(int i=0; i<e; i++){\n        init(v);\n        for(int j=0; j<e; j++){\n            if(i == j) continue;\n            unite(fs[j], ts[j]);\n        }\n\n        bool is_same = true;\n        for(int j=0; j<v-1 && is_same; j++){\n            if(!same(j, j+1)){\n                is_same = false;\n                cout << fs[i] << \" \" << ts[i] << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int v = 0, int par = -1){\t//橋の検出\n\t\tif(pre[v] >= 0)return pre[v];\n\t\tpre[v] = low[v] = cnt1++;\n\t\trep(i,G[v].size())if(par != G[v][i]){\n\t\t\tint res = dfs(G[v][i], v);\n\t\t\tlow[v] = min(low[v], res);\n\t\t}\n\t\treturn low[v];\n\t}\n\tint build(int v = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[v] = x;\n\t\tused[v] = 1;\n\t\trep(i,G[v].size())if(!used[G[v][i]]){\n\t\t\tif(pre[G[v][i]] == low[G[v][i]]){\t\t\t//橋\n\t\t\t\tG2[cmp[v]].pb(x+1);G2[x+1].pb(cmp[v]);\n\t\t\t\tchmax(mx, build(G[v][i], x+1));x++;\n\t\t\t}else chmax(mx, build(G[v][i], cmp[v]));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<vector<int> > ans;\nvector<vector<int> > G, G2;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tG.resize(n);\n\tlow.init(n);\n\tans.resize(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t\tG[v].pb(u);G[u].pb(v);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G2 = low.G2;\n\tvector<int> cmp = low.cmp;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tint from = cmp[i], to = cmp[G[i][j]];\n\t\t\tif(from != to and i < G[i][j])ans[i].pb(G[i][j]);\n\t\t}\n\t}\n\trep(i,n){\n\t\tZIP(ans[i]);\n\t\trep(j,ans[i].size())printf(\"%lld %lld\\n\", i, ans[i][j]);\n\t}\n\t//ZIP(ans);\n\t//size = ans.size();\n\t//rep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n\tlow[v]=min(low[v],ord[u]);\n      }else{\n\tdfs(u,v,k);\n\tlow[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  bcc.input(e,0);\n  bcc.build();\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}\n\n/*\n  verified on 2017/12/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX 100000\n\nstd::vector<int>Graph[MAX];\nbool visited[MAX];\n\nint N;\n\nint prenum[MAX], parent[MAX], lowest[MAX], timer;\n\nstruct compare {\n    bool operator() (const std::pair<int,int> &lhs, const std::pair<int,int> &rhs) const{\n        if (lhs.first == rhs.first) return lhs.second < rhs.second;\n        return (lhs.first < rhs.first);\n    }\n};\n\nstd::set<std::pair< int, int>, compare > bridges;\n\nvoid dfs(int current, int prev) {\n\n    prenum[current] = lowest[current] = timer;\n    timer++;\n\n    visited[current] = true;\n\n    int next;\n\n    for (int i = 0; i < Graph[current].size(); i++) {\n        next = Graph[current][i];\n        if (!visited[next]) {\n            parent[next] = current;\n            dfs(next, current);\n\n            lowest[current] = std::min(lowest[current], lowest[next]);\n            \n            if (lowest[next] > prenum[current]) {\n                if (next > current) bridges.insert({current, next});\n                else bridges.insert({next, current});\n\n            }\n\n\n        }\n        else if (prev != next) {\n            lowest[current] = std::min(lowest[current], prenum[next]);\n        }\n    }\n}\n\nvoid bridge() {\n    for (int i = 0; i < N; i++) visited[i] = false;\n\n    timer = 1;\n\n    dfs(0, -1); //0 == root\n\n    for(std::set< std::pair<int, int> >::iterator it = bridges.begin(); it != bridges.end(); it++) {\n        std::cout << it->first << \" \" << it->second << std::endl;\n    }\n}\n\n\nint main()\n{\n    int Edges;\n    std::scanf(\"%d %d\", &N, &Edges);\n\n    int start, target;\n\n    for (int i = 0; i < Edges; i++) {\n        std::scanf(\"%d %d\", &start, &target);\n        Graph[start].push_back(target);\n        Graph[target].push_back(start);\n    }\n\n    bridge();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nstruct LowLink {\n    int n, pos;\n    vector<vector<int>> G;\n    vector<int> ord, low, par, ap;\n    vector<pair<int, int>> brg;\n    LowLink(int n) : n(n), pos(0), G(n), ord(n, -1), low(n), par(n, -1){}\n    void addEdge(int u, int v){\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    void dfs(int v){\n        ord[v] = low[v] = pos++;\n        int dup = 0;\n        for(int u : G[v]){\n            if(u == par[v]){\n                if(dup) low[v] = min(low[v], ord[u]);\n                dup = 1;\n                continue;\n            }\n            if(~ord[u]){\n                low[v] = min(low[v], ord[u]);\n                continue;\n            }\n            par[u] = v;\n            dfs(u);\n            low[v] = min(low[v], low[u]);\n            if(ord[v] < low[u]) brg.emplace_back(minmax(u, v));\n        }\n    }\n    void build(){\n        for(int i = 0;i < n;++i) if(ord[i] < 0) dfs(i);\n        vector<int > cnt(n, 0);\n        for(int i = 0;i < n;++i){\n            int p = par[i];\n            if(p < 0) continue;\n            if(par[p] < 0) cnt[p]++;\n            else if(ord[p] <= low[i]) ap.push_back(p);\n        }\n        for(int i = 0;i < n;++i) if(cnt[i] > 1) ap.push_back(i);\n        sort(begin(ap), end(ap));\n        sort(begin(brg), end(brg));\n        ap.erase(unique(begin(ap), end(ap)), end(ap));\n    }\n    bool isBridge(int u, int v){\n        if(ord[u] > ord[v]) swap(u, v);\n        return ord[u] < low[v];\n    }\n};\n\n\nint V, E;\n\n\nint main(){\n    cin >> V >> E;\n    LowLink G(V);\n    for(int i = 0;i < E;++i){\n        int s, t;\n        cin >> s >> t;\n        G.addEdge(s, t);\n    }\n    G.build();\n    for(auto p : G.brg) cout << p.first << ' ' << p.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/**\n * @title Template\n */\n\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n#include <cassert>\n\n\ntemplate <class T, class U>\nbool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { \n    lhs = rhs; \n    return true; \n  }\n  return false;\n}\n\ntemplate <class T, class U>\nbool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { \n    lhs = rhs; \n    return true; \n  }\n  return false;\n}\n\n/**\n * @title Chmin/Chmax\n */\n\n\nclass range {\npublic:\n  class iterator {\n  private:\n    int64_t M_position;\n\n  public:\n    iterator(int64_t position) noexcept: M_position(position) { }\n    void operator ++ () noexcept { ++M_position; }\n    bool operator != (iterator other) const noexcept { return M_position != other.M_position; }\n    int64_t operator * () const noexcept { return M_position; }\n\n  };\n\n  class reverse_iterator {\n  private:\n    int64_t M_position;\n  \n  public:\n    reverse_iterator(int64_t position) noexcept: M_position(position) { }\n    void operator ++ () noexcept { --M_position; }\n    bool operator != (reverse_iterator other) const noexcept { return M_position != other.M_position; }\n    int64_t operator * () const noexcept { return M_position; }\n\n  };\n  \nprivate:\n  const iterator M_first, M_last;\n\npublic:\n  range(int64_t first, int64_t last) noexcept: M_first(first), M_last(std::max(first, last)) { }\n  iterator begin() const noexcept { return M_first; }\n  iterator end() const noexcept { return M_last; }\n  reverse_iterator rbegin() const noexcept { return reverse_iterator(*M_last - 1); } \n  reverse_iterator rend() const noexcept { return reverse_iterator(*M_first - 1); } \n\n};\n\n/**\n * @title Range\n */\n\n#include <type_traits>\n#include <iterator>\n\ntemplate <class T>\nclass rev_impl {\npublic:\n  using iterator = decltype(std::declval<T>().rbegin());\n\nprivate:\n  const iterator M_begin;\n  const iterator M_end;\n\npublic:\n  rev_impl(T &&cont) noexcept: M_begin(cont.rbegin()), M_end(cont.rend()) { }\n  iterator begin() const noexcept { return M_begin; }\n  iterator end() const noexcept { return M_end; }\n\n};\n\ntemplate <class T>\nrev_impl<T> rev(T &&cont) {\n  return rev_impl<T>(std::forward<T>(cont));\n}\n\n/**\n * @title Reverser\n */\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nconstexpr size_t Vertices = 100000;\n\ni32 V, E;\nstd::array<std::vector<i32>, Vertices> graph;\nstd::array<i32, Vertices> ord, low;\nstd::vector<std::pair<i32, i32>> ans;\n\ni32 index;\nvoid dfs(const i32 u, const i32 p) {\n  ord[u] = low[u] = index;\n  ++index;\n  i32 cnt = 0;\n  bool art = false;\n  for (const auto v: graph[u]) {\n    if (v == p) {\n      continue;\n    }\n    if (ord[v] == -1) {\n      dfs(v, u);\n      chmin(low[u], low[v]);\n      if (ord[u] < low[v]) {\n        ans.push_back(std::minmax(u, v));\n      }\n      ++cnt;\n    }\n    else {\n      chmin(low[u], ord[v]);\n    }\n  }\n}\n\nint main() {\n  std::cin >> V >> E;\n  ord.fill(-1);\n  for (auto i: range(0, E)) {\n    i32 s, t;\n    std::cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n  }\n  dfs(0, -1);\n  std::sort(ans.begin(), ans.end());\n  for (auto p: ans) {\n    std::cout << p.first << ' ' << p.second << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing ll = long long;\nusing namespace std;\n\nvector<int> parent;\nvector<int> rnk;\n\nvoid init(int n){\n    parent.clear();\n    rnk.clear();\n    for(int i=0; i<n; i++){\n        parent.push_back(i);\n        rnk.push_back(0);\n    }\n}\n\nint find(int x){\n    if(x == parent[x]){\n        return x;\n    } else {\n        return parent[x] = find(parent[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n\n    if(x == y) return;\n\n    if(rnk[x] < rnk[y]){\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector<int> fs(e), ts(e);\n    for(int i=0; i<e; i++) cin >> fs[i] >> ts[i];\n\n    int cnt = 0;\n    for(int i=0; i<e; i++){\n        init(v);\n        for(int j=0; j<e; j++){\n            if(i == j) continue;\n            unite(fs[j], ts[j]);\n        }\n\n        bool is_same = true;\n        for(int j=0; j<v-1 && is_same; j++){\n            if(!same(j, j+1)){\n                is_same = false;\n                cout << fs[i] << \" \" << ts[i] << \"\\n\";\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tfor (int v : g[u]) {\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tdfs(0, -1, 0);\n\t\n\tfor (set<pii>::iterator it = bridge.begin(); it != bridge.end(); ++it) {\n\t\tprintf(\"%d %d\\n\", it->first, it->second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Have FUN\n\nusing namespace std;\n\n#include<bits/stdc++.h>\n\nconst int maxn=1e5+10;\n\nbool mark[maxn];\nint n,m,s,t,h[maxn],up[maxn],par[maxn];\nvector <int> a[maxn];\n\nvector < pair<int,int> > ans;\n\nvoid input()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t}\n}\n\nvoid dfs(int x)\n{\n\tmark[x]=true;\n\tint minn=h[x];\n\tfor(int i=0;i<a[x].size();i++)\n\t{\n\t\tint child=a[x][i];\n\t\tif(!mark[child])\n\t\t{\n\t\t    par[child]=x;\n\t\t\th[child]=h[x]+1;\n\t\t\tdfs(child);\n\t\t\tif(up[child]!=x)\n                minn=min(minn,up[child]);\n\n\t\t}\n\t}\n\tfor(int i=0;i<a[x].size();i++)\n\t{\n\t    if(a[x][i]!=par[x])\n            minn=min(minn,h[a[x][i]]);\n\t}\n\n\tup[x]=minn;\n\n\n}\n\nint main ()\n{\n\tinput();\n\tdfs(0);\n\tfor(int i=0;i<n;i++)\n    {\n\t\tfor(int j=0;j<a[i].size();j++)\n\t\t{\n\t    if( (h[i]>h[a[i][j]]) && (up[i] > h[a[i][j]]) )\n            {\n                if(a[i][j]>i)\n                    ans.push_back(make_pair(i,a[i][j]));\n                else\n                    ans.push_back(make_pair(a[i][j],i));\n            }\n\t\t}\n    }\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\n\nvi graph[vmax],ord,low,scc,par;\nstack<int>s;\n\nvoid add_edge(int f,int t){ graph[f].pb(t);}\nvoid add_both_edges(int f,int t){add_edge(f,t);add_edge(t,f);}\n\nvoid dfs(int v,int p,int &k){\n\tord[v]=k++;\n\tlow[v]=ord[v];\n\tpar[v]=p;\n//\ts.push(v);\n\tfor(auto &i:graph[v]){\n\t\tif(ord[i]==-1){\n\t\t\tdfs(i,v,k);\n\t\t\tlow[v]=min(low[v],low[i]);\n\t\t}else if(i!=p /*scc[i]==-1*/)\n\t\t\tlow[v]=min(low[v],ord[i]);\n\t}\n\t/*if(ord[v]==low[v]){\n\t\twhile(1){\n\t\t\tint u=s.top();s.pop();\n\t\t\tscc[u]=v;\n\t\t\tif(u==v) break;\n\t\t}\n\t}*/\n}\n\nvoid lowlink(int n){\n\tint k=0;\n\tord.assign(n,-1),low.resize(n);\n\tscc.assign(n,-1),par.resize(n);\n\trep(i,n) if(ord[i]==-1) dfs(i,-1,k);\n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\trep(loop,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_both_edges(a,b);\n\t}\n\tlowlink(v);\n\n/*\trep(i,v){\n\t\tcout << \"ord[\" << i << \"]=\" << ord[i]  << endl;\n\t\tcout << \"low[\" << i << \"]=\" << low[i]  << endl;\n\t}\n*/\n\n// Bridge\n\tvector<pii> bridge;\n\trep(i,v){\n\t\tint j=par[i];\n\t\tif(j==-1)\n\t\t\tcontinue;\n\t\tif(ord[i] < low[j] || ord[j] < low[i] ){\n\t\t\tpii in(i,j);\n\t\t\tif(in.second<=in.first) swap(in.first,in.second);\n\t\t\tbridge.pb(in);\n\t\t}\n\t}\n\tsort(bridge.begin(),bridge.end());\n\tfor(auto &i:bridge)\n\t\tcout << i.first << \" \" << i.second << endl;\n\n\n// SCC\n/*\tint q;\n\tcin >> q;\n\trep(loop,q){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << (scc[a]==scc[b]) << endl;\n\t}\n*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nvector<pii> bridges;\nint ord[100000], low[100000];\nbool checked[100000];\n\nint k;\n\nvoid dfs(int v, int p)\n{\n\tchecked[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\n\tfor (int i = 0; i != G[v].size(); i++)\n\t{\n\t\tif (!checked[G[v][i]])\n\t\t{\n\t\t\tdfs(G[v][i], v);\n\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\tif (ord[v] < low[G[v][i]])\n\t\t\t{\n\t\t\t\tbridges.push_back(pii(min(v, G[v][i]), max(v, G[v][i])));\n\t\t\t}\n\t\t}\n\t\telse if (G[v][i] != p)\n\t\t{\n\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t}\n\t}\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E;\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\n\tdfs(0, -1);\n\n\tsort(bridges.begin(), bridges.end());\n\n\tfor (auto& p : bridges)\n\t{\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n\nclass Lowlink{\npublic:\n  // {v_from, v_to}\n  vector<pair<int,int>> bridge;\n  // [v]\n  vector<int> articulation_point;\n  void construct(const vector<vector<int>>& g){\n    const int n = g.size();\n    bridge = vector<pair<int, int>>{};\n    articulation_point = vector<int>{};\n\n    vector<int> ord(n, -1);\n    vector<int> low(n);\n    for(int i=0; i<n; i++){\n      dfs(g, ord, low, i);\n    }\n  }\n\nprivate:\n  void dfs(\n    const vector<vector<int>>& g, vector<int>& ord, vector<int>& low,\n    int cur, int par = -1)\n  {\n    ord[cur] = par==-1 ? 0 : ord[par] + 1;\n    low[cur] = ord[cur];\n    int num_children = 0;\n    bool is_articulation = false;\n    for(auto& nex: g[cur]){\n      if(ord[nex] == -1){\n        ++num_children;\n        dfs(g, ord, low, nex, cur);\n        low[cur] = min(low[cur], low[nex]);\n        if(ord[cur] <= low[nex] && par!=-1)\n          is_articulation = true;\n        if(ord[cur] < low[nex])\n          bridge.emplace_back(min(cur, nex), max(cur, nex));\n      }else if(nex != par){ // back edge\n        low[cur] = min(low[cur], ord[nex]);\n      }\n    }\n    if(par == -1 && num_children >= 2)\n      is_articulation = true;\n    if(is_articulation)\n      articulation_point.push_back(cur);\n  }\n\n};\n\nint main(){\n  int n,e;\n  cin >> n >> e;\n  vector<vector<int>> g(n);\n  for(int i=0; i<e; i++){\n    int u,v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  Lowlink lowlink;\n  lowlink.construct(g);\n  auto b = lowlink.bridge;\n  sort(begin(b), end(b));\n  for(auto e : b){\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {\n\tint from, to;\n\tedge(int f, int t) : from(f), to(t) {}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& G, int f, int t) {\n\tG[f].emplace_back(f, t);\n\tG[t].emplace_back(t, f);\n}\n\npair<vector<int>, edges> bridge(const graph& G) {\n\tconst int n = G.size();\n\tint idx = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), stk, roots(n), cmp(n);\n\tvector<bool> onS(n);\n\tedges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk.push_back(v);\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : G[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk.back(); stk.pop_back();\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, -1);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint V, E;\n\tcin >> V >> E;\n\tgraph G(V);\n\tfor (int i = 0, s, t; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tadd_edge(G, s, t);\n\t}\n\tauto br = bridge(G);\n\tvector<pair<int, int>> res;\n\tfor (auto& e : br.second) {\n\t\tres.emplace_back(min(e.from, e.to), max(e.from, e.to));\n\t}\n\tsort(res.begin(), res.end());\n\tfor (auto p : res) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// TwoEdgeConnectedComponents + LowLink\nstruct TwoEdgeConnectedComponents {\n  int n;\n  vector<vector<int>> g;\n  vector<int> ord, low, articulation;\n  vector<bool> used;\n  using P = pair<int, int>;\n  vector<P> bridge;\n  TwoEdgeConnectedComponents(int _n = 1) : n(_n), g(n) {}\n  TwoEdgeConnectedComponents(vector<vector<int>> &_g) : n(_g.size()), g(_g) {\n    build();\n  }\n\n  bool add(int from, int to) {\n    g[from].push_back(to);\n    g[to].push_back(from);\n    return 1;\n  }\n\n  void build() {\n    ord.assign(n, -1);\n    low.assign(n, -1);\n    int k = 0;\n    for (int i = 0; i < n; ++i)\n      if (ord[i] < 0) lowlinkdfs(i, -1, k);\n  }\n  void lowlinkdfs(int now, int par, int &k) {\n    ord[now] = low[now] = k++;\n    bool ch = 0;  // articulation\n    int cnt = 0;\n    for (auto &to : g[now])\n      if (ord[to] < 0) {\n        ++cnt;\n        lowlinkdfs(to, now, k);\n        low[now] = min(low[now], low[to]);\n        ch |= ~par && low[to] >= ord[now];  // articulation\n        if (ord[now] < low[to])\n          bridge.emplace_back(min(now, to), max(now, to));  // bridge\n      } else if (to != par)\n        low[now] = min(low[now], ord[to]);\n    ch |= par == -1 && cnt > 1;           // articulation\n    if (ch) articulation.push_back(now);  // articulation\n  }\n};\n\nlong long n, m;\nTwoEdgeConnectedComponents lowlink;\nvector<vector<int>> g;\n\nint main() {\n  cin >> n >> m;\n  g.resize(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  lowlink = TwoEdgeConnectedComponents(g);\n  using P = pair<int, int>;\n\n  vector<P> res = lowlink.bridge;\n  sort(res.begin(), res.end());\n  for (auto p : res) cout << p.first << \" \" << p.second << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        cin>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans){\n        if(u.F<u.S)\n            cout<<u.F<<\" \"<<u.S<<'\\n';\n        else\n            cout<<u.S<<\" \"<<u.F<<'\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\nconst int N=1e5+10;\nint p[N],low[N],dep[N],t=0;\nstack<int> s;\nbitset<N>went,in,used;\nvector<pi> graph[N];\nvoid dfs(int now){\n    in[now]=went[now]=true;\n    low[now]=dep[now]=++t;\n    s.push(now);\n    for(int i=0;i<graph[now].size();i++)if(!used[graph[now][i].S]){\n        used[graph[now][i].S]=true;\n        if(!went[graph[now][i].F])dfs(graph[now][i].F);\n        if(in[graph[now][i].F])low[now]=min(low[now],low[graph[now][i].F]);\n    }\n    if(low[now]==dep[now]){\n        while(s.top()!=now){\n            p[s.top()]=now;\n            in[s.top()]=false;\n            s.pop();\n        }\n        p[now]=now;\n        s.pop();\n        in[now]=false;\n    }\n    return ;\n}\nint main(){\n    int n,m,l,r;\n    set<pi> ans;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d%d\",&l,&r);\n        graph[l].PB(MP(r,i));\n        graph[r].PB(MP(l,i));\n    }\n    went.reset();\n    in.reset();\n    used.reset();\n    for(int i=0;i<n;i++)if(!went[i])dfs(i);\n    for(int i=0;i<n;i++)for(int j=0;j<graph[i].size();j++)if(p[i]!=p[graph[i][j].F]){\n        if(i<graph[i][j].F)ans.insert(MP(i,graph[i][j].F));\n        else ans.insert(MP(graph[i][j].F,i));\n    }\n    for(auto u:ans)printf(\"%d %d\\n\",u.F,u.S);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint N, M, A[200009], B[200009], pre[200009], low[200009], cnts;\nvector<pair<int, int>> X[200009];\nvector<int> G;\n\nvoid dfs(int pos, int par) {\n\tcnts++;\n\tpre[pos] = cnts; low[pos] = cnts;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tint to = X[pos][i].first;\n\t\tif (low[to] == (1 << 30)) {\n\t\t\tdfs(to, pos);\n\t\t\tlow[pos] = min(low[pos], low[to]);\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\tG.push_back(X[pos][i].second);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (to == par) continue;\n\t\t\tlow[pos] = min(low[pos], low[to]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> A[i] >> B[i]; if (A[i] > B[i]) swap(A[i], B[i]);\n\t\tX[A[i]].push_back(make_pair(B[i], i));\n\t\tX[B[i]].push_back(make_pair(A[i], i));\n\t}\n\tfor (int i = 1; i <= N; i++) { pre[i] = (1 << 30); low[i] = (1 << 30); }\n\tdfs(1, -1);\n\tvector<pair<int, int>>F;\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tF.push_back(make_pair(A[G[i]], B[G[i]]));\n\t}\n\tsort(F.begin(), F.end());\n\tfor (int i = 0; i < F.size(); i++) cout << F[i].first << \" \" << F[i].second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[100000];\nvector<pii> bridges;\nint ord[100000], low[100000];\nbool checked[100000];\n\nint k;\n\nvoid dfs(int v, int p)\n{\n\tchecked[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\n\tfor (int i = 0; i != G[v].size(); i++)\n\t{\n\t\tif (!checked[G[v][i]])\n\t\t{\n\t\t\tdfs(G[v][i], v);\n\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\tif (ord[v] < low[G[v][i]])\n\t\t\t{\n\t\t\t\tbridges.push_back(pii(v, G[v][i]));\n\t\t\t}\n\t\t}\n\t\telse if (G[v][i] != p)\n\t\t{\n\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t}\n\t}\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E;\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\n\tdfs(0, -1);\n\n\tsort(bridges.begin(), bridges.end());\n\n\tfor (auto& p : bridges)\n\t{\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<int>E[100000];\nint s[100000],t[100000];\nint ord[100000],low[100000],k;\nbool used[100000];\nvector<P>V;\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tlow[v]=ord[v]=k++;\n\tfor(auto u:E[v]){\n\t\tif(!used[u]){\n\t\t\tdfs(u,v);\n\t\t\tlow[v]=min(low[v],low[u]);\n\t\t\tif(low[v]<low[u])V.push_back(P(min(u,v),max(u,v)));\n\t\t}\n\t\telse if(p!=u){\n\t\t\tlow[v]=min(low[v],ord[u]);\n\t\t}\n\t}\n}\nint main(){\n\tint v,e;scanf(\"%d%d\",&v,&e);\n\trep(i,e){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);\n\t\tE[s[i]].push_back(t[i]);\n\t\tE[t[i]].push_back(s[i]);\n\t}\n\tdfs(0,-1);\n\tsort(V.begin(),V.end());\n\tfor(auto p:V){\n\t\tcout<<p.first<<' '<<p.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <limits>\n#include <random>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n \n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\ntypedef long long ll;\n\nstruct LowLink {\n    \n    vector < vector < int > > G;\n    vector < int > ord, low;\n    vector < bool > used;\n    vector < pair < int, int > > bridge;\n    vector < int > articulation_point;\n    const int INF = 1145141919;\n    \n    LowLink (int n) : G(n), ord(n), low(n), used(n) {}\n    \n    void add_edge(int a, int b) {\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    void build(int root) {\n        fill(low.begin(), low.end(), INF);\n        fill(used.begin(), used.end(), false);\n        dfs(root, -1, 1);\n    }\n    \n    int dfs(int v, int prev, int cnt) {\n        used[v] = true;\n        low[v] = ord[v] = cnt;\n        int min_low = cnt;\n        int route = 0;\n        bool isArticulation = false;\n        for (int i = 0; i < G[v].size(); i++) {\n            if (!used[G[v][i]]) {\n                route++;\n                int low_nxt = dfs(G[v][i], v, cnt + 1);\n                min_low = min(min_low, low_nxt);\n                if (ord[v] < low_nxt) {\n                    bridge.push_back(make_pair(v, G[v][i]));\n                }\n                if (prev != -1 && G[v].size() >= 2 && low_nxt >= cnt) {\n                    isArticulation = true;\n                }\n            } else if (G[v][i] != prev) {\n                min_low = min(min_low, low[G[v][i]]);\n            }\n        }\n        if (prev == -1 && route > 1) isArticulation = true;\n        if (isArticulation) articulation_point.push_back(v);\n        return low[v] = min_low;\n    }\n    \n};\n\n\nint main() {\n\n    int V,E; cin >> V >> E;\n    LowLink inst(100010);\n\n    REP(i,E) {\n        int a,b; cin >> a >> b;\n        inst.add_edge(a, b);\n    }\n\n    inst.build(0);\n\n    vector < pair < int, int > > ans;\n\n    REP(i,inst.bridge.size()) {\n        int a = min(inst.bridge[i].first, inst.bridge[i].second);\n        int b = max(inst.bridge[i].first, inst.bridge[i].second);\n        ans.push_back(make_pair(a, b));\n    }\n\n    sort(ans.begin(), ans.end());\n    REP(i,ans.size()) {\n        cout << ans[i].first << \" \" << ans[i].second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=10000;\nconst int E_MAX=10000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nbool used_v[V_MAX]={};\nbool used_e[E_MAX][E_MAX]={};\nvector<int> pre(V_MAX,INT_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(used_v[s]==true){return;}\n\tused_v[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tused_e[s][G[s][i]]=true;\n\t\tif(!used_v[G[s][i]]){\n\t\t\tdfs(G[s][i],s);\n\t\t\tlow[s]=min(low[s],low[G[s][i]]);\n\t\t}else if(!used_e[G[s][i]][s]){\n\t\t\tlow[s]=min(low[s],pre[G[s][i]]);\n\t\t}\n\t}\n\tif(!(s==0 && p==0) && low[s]>pre[p]){\n\t\tedge e;\n\t\te.from=min(s,p);\n\t\te.to=max(s,p);\n\t\tresult.push_back(e); \n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t/*\n\tfor(int i=0;i<V;i++){\n\t\tcout << pre[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\tfor(int i=0;i<V;i++){\n\t\tcout << low[i] << \" \";\n\t}\n\tfor (int i=0;i<V;i++){\n\t\tfor (int j=0;j<V;j++){\n\t\t\tcout << used_e[i][j] <<\" \" ;\n\t\t}\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\ntypedef vector<vector<int>> graph;\nstruct LowLink{\n    graph v;\n    vector<int> art,low,ord;\n    vector <pint> bridge;\n\n    LowLink(int n):v(n),ord(n,-1),low(n){};\n\n    void addedge(int x,int y){\n        v[x].push_back(y);\n        v[y].push_back(x);\n    }\n    \n    void dfs(int& count,int from,int x){\n        ord[x]=count++;\n        low[x]=ord[x];\n        bool isart=false;\n        int cnt=0;\n        for(auto to:v[x]){\n            if(to==from)continue;\n            if(ord[to]==-1){\n                cnt++;\n                dfs(count,x,to);\n                if(ord[x]<low[to])bridge.push_back({min(x,to),max(to,x)});\n                if(from!=-1&&ord[x]<=low[to])isart=true;\n                low[x]=min(low[x],low[to]);\n            }\n            else low[x]=min(low[x],ord[to]);\n        }\n        if(from==-1&&cnt>1)isart=true;\n        if(isart)art.push_back(x);\n    }\n    void dfs(){\n        int count=0;\n        dfs(count,-1,0);\n    }\n};\n\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    LowLink ll(n);\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        ll.addedge(x,y);\n    }\n    ll.dfs();\n    sort(ll.bridge.begin(),ll.bridge.end());\n    for(auto x:ll.bridge)cout<<x.first<<\" \"<<x.second<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, N) for (int i = 0; i < (int)N; i++)\n\ntypedef pair<int, int> edge;\nconst int UNVISITED = -1;\npriority_queue<edge, vector<edge>, greater<edge>> bridges;\nvector<int> low;\nvector<int> dist;\nvector<vector<int>> adjacentList;\n\nint dfs(int i, int d, int parent) {\n  low[i] = d;\n  dist[i] = d;\n  for(auto n: adjacentList[i]) {\n    if(dist[n] == UNVISITED) {\n      low[i] = min(low[i], dfs(n, d+1, i));\n      if(d < low[n]) {\n        bridges.push(edge(min(i,n), max(i,n)));\n      }\n    } else if(parent != n) {\n      low[i] = min(low[i], dist[n]);\n    }\n  }\n  return low[i];\n}\n\nint main () {\n  int V, E;\n  cin >> V >> E;\n  low = vector<int>(V, 0);\n  dist = vector<int>(V, UNVISITED);\n  adjacentList = vector<vector<int>>(V);\n\n  for(int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    adjacentList[s].push_back(t);\n    adjacentList[t].push_back(s);\n  }\n\n  dfs(0, 0, -1);\n\n  while(!bridges.empty()) {\n    edge e = bridges.top(); bridges.pop();\n    printf(\"%d %d\\n\", e.first, e.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct Bridge{\n  int n;\n  vector<vector<int> > G;\n  vector<int>low,used,depth;\n  set<pair<int,int> >ans;\n  Bridge(){}\n  Bridge(int sz):n(sz),low(sz),used(sz),depth(sz),G(sz){}\n  void add(int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  void dfs(int x,int d,int prev){\n    depth[x]=d;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i];\n      if(nx==prev)continue;\n      if(!used[nx]){\n        used[nx]=true;\n        dfs(nx,d+1,x);\n        if(!low[nx]) ans.insert(P(min(x,nx),max(x,nx)));\n        low[x]+=low[nx];\n      }\n      else if(d>depth[nx])low[nx]--,low[x]++;\n    }\n  }\n  void build(){\n    fill(used.begin(),used.end(),0);\n    fill(low.begin(),low.end(),0);\n    fill(depth.begin(),depth.end(),0);\n    used[0]=1;\n    dfs(0,0,0);\n  }\n  void prin(){\n    set<P>::iterator it=ans.begin();\n    while(it!=ans.end()){\n      cout<< (*it).first << (*it).second <<endl;\n      it++;\n    }\n  }\n};\nint main(){\n  int n,m,s,t;\n  cin>>n>>m;\n  Bridge B(n);\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    B.add(s,t);\n  }\n  B.build();\n  B.prin();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nstruct LowLink{\n    int n, k;   // k  \n    vector<int> ord, low;\n    vector<pii> edge;\n    vector<vector<int>> v;\n    vector<bool> vis;\n\n    LowLink(int n) : n(n){\n        ord.resize(n);\n        v.resize(n);\n        low.resize(n);\n        vis.resize(n, 0);\n    }\n\n    void add_edge(int a, int b){\n        edge.push_back({a, b});\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    void dfs(int x, int p, int &k){\n        ord[x] = low[x] = k++;\n        vis[x] = true;\n        for(int j : v[x]){\n            if(vis[j]){\n                if(j != p)  low[x] = min(low[x], ord[j]);\n            }else{\n                dfs(j, x, k);\n                low[x] = min(low[x], low[j]);\n            }\n        }\n    }\n\n    void build(){\n        k = 0;\n        dfs(0, -1, k);\n    }\n\n    vector<pii> bridge(){\n        vector<pii> ret;\n        for(pii p : edge){\n            int x = p.first, y = p.second;\n            if(ord[x] > ord[y]) swap(x, y);\n            if(ord[x] < low[y]) ret.push_back(p);\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    LowLink l(n);\n    while(m--){\n        int u, v;\n        cin >> u >> v;\n        if(u > v)   swap(u, v);\n        l.add_edge(u, v);\n    }\n    l.build();\n    vector<pii> res = l.bridge();\n    sort(res.begin(), res.end());\n    for(pii p : res){\n        cout << p.first << \" \" << p.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass biconnected{\npublic:\n\tvector<vector<int> > G ,graph;\n\tvector<int> ord,low,cmp;\n    vector<vector<P> > check;\n\tset<P> bridge;\n\tvector<bool> visit;\n\tint V;\n\tbiconnected(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V);\n\t\tcheck.resize(V),ord.resize(V),low.resize(V);\n\t\tcmp.resize(V),visit.resize(V,false);\n\t}\n\tvoid build(){\n\t\tint id = 0;\n\t\trep(i,V){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(i,-1,id);\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,int p,int &k)\n\t{\n\t\tvisit[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\trep(i,(int)G[v].size()){\n\t\t\tint w = G[v][i];\n\t\t\tif(!visit[w]){\n\t\t\t\tdfs(w,v,k);\n\t\t\t\tlow[v] = min(low[v],low[w]);\n\t\t\t\tif(ord[v] < low[w]){\n\t\t\t\t    bridge.insert(P(min(v,w),max(v,w)));\n\t                check[v][i].second = 1;\n\t                check[w][check[v][i].first].second = 1;\n\t\t\t\t}\n\t\t\t//(v,w)????????????\n\t\t\t}else if(w != p){\n\t\t\t\tlow[v] = min(low[v],ord[w]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid add_edge(int u,int v)\n\t{\n\t    G[u].push_back(v),G[v].push_back(u);\n\t    check[u].push_back(P((int)check[v].size(),0));\n\t    check[v].push_back(P((int)check[u].size()-1,0));\n\t}\n\tvoid restrict_dfs(int u,int p,int kind,queue<int>& que)\n\t{\n\t    visit[u] = true;\n\t    cmp[u] = kind;\n\t    rep(i,(int)G[u].size()){\n\t\t\tint w = G[u][i];\n\t        if(check[u][i].second){\n\t            if(!visit[w]){\n\t                que.push(w);\n\t            }\n\t        }else if(!visit[w]){\n\t            restrict_dfs(w,u,kind,que);\n\t        }\n\t    }\n\t}\n\t// ????????°?????????\n\t// int make_bcgraph()\n\t// {\n\t// \tgraph.resize(V);\n\t//     int num = 0;\n\t//     rep(i,V){\n\t//         if(!visit[i]){\n\t//             dfs(i,-1,num);\n\t//         }\n\t//     }\n\t//     fill(visit.begin(),visit.end(),false);\n\t//     int kind = 0;\n\t//     rep(i,V){\n\t//         if(!visit[i]){\n\t//             queue<int> que;\n\t//             que.push(i);\n\t//             while(!que.empty()){\n\t//                 int p = que.front();\n\t//                 que.pop();\n\t//                 restrict_dfs(p,-1,kind,que);\n\t//                 kind++;\n\t//             }\n\t//         }\n\t//     }\n\t//     rep(i,(int)bridge.size()){\n\t//         int a = cmp[bridge[i].first];\n\t//         int b = cmp[bridge[i].second];\n\t//         graph[a].push_back(b), graph[b].push_back(a);\n\t//     }\n\t//     return kind;\n\t// }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    biconnected bc(n);\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        bc.add_edge(u,v);\n    }\n    bc.build();\n    each(it,bc.bridge){\n        cout << it.fi << \" \" << it.se << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nstruct LowLink{\n  int n;\n  vector<vector<int>> edge;\n  vector<int> ord, low;\n  vector<int> articulation;\n  vector<pair<int, int>> bridge;\n  int c;\n  LowLink(int n = 0): n(n){\n    edge.resize(n);\n    ord.resize(n);\n    low.resize(n);\n  }\n  void adde(int u, int v){\n    edge[u].push_back(v);\n  }\n  void dfs(int i, int p){\n    ord[i] = c++;\n    low[i] = ord[i];\n    int cnt = 0;\n    bool is_articulation = false;\n    for(auto e: edge[i]){\n      if(ord[e] < n){\n        if(e != p)low[i] = min(low[i], ord[e]);\n      }else{\n        cnt++;\n        dfs(e, i);\n        low[i] = min(low[i], low[e]);\n        if(ord[i] < low[e])bridge.emplace_back(min(i, e), max(i, e));\n        if(p != -1 && ord[i] <= low[e])is_articulation = true;\n      }\n    }\n    if(p == -1 && cnt > 1)is_articulation = true;\n    if(is_articulation)articulation.push_back(i);\n  }\n  void build(){\n    c = 0;\n    fill(ord.begin(), ord.end(), n + 1);\n    dfs(0, -1);\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n, m; cin >> n >> m;\n  LowLink lk(n);\n  rep(i, m){\n    int u, v; cin >> u >> v;\n    lk.adde(u, v);\n    lk.adde(v, u);\n  }\n  lk.build();\n  auto v = lk.bridge;\n  sort(whole(v));\n  for(auto e: v){\n    cout << e.first << \" \" << e.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\n\nvoid Lowlink(BiDGraph& g,vector<int>& lowlink, vector<int>& orb) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int,int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) continue;\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first,cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(0,-1);\n\treturn;\n}\n\nvoid Bridge(BiDGraph& g, vector<pii>& bridges) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({i, itr.first});\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Joint(BiDGraph& g, vector<int>& joints) {\n\tvector<int> lowlink, orb;\n\tLowlink(g, lowlink, orb);\n\n\tREP(i, g.vn) {\n\t\tfor (auto itr : g.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr = bridges.begin(); itr != bridges.end(); itr++) {\n\t\tif (itr->first > itr->second)\n\t\t\tswap(itr->first, itr->second);\n\t}\n\tsort(ALL(bridges));\n\tfor (auto itr : bridges) {\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\nstruct graphLink {\n    vector<bool> isthrough;\n    vector<int> ord, low, parent;\n    Graph G;\n    int cnt, v;\n\n    // init\n    graphLink(int _n) : isthrough(_n, false), ord(_n, 0), low(_n, 0), parent(_n, 0), G(_n), cnt(0), v(_n) {}\n\n    // example: dfs(0, -1);\n    void dfs(int cur, int prev) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n        isthrough[cur] = true;\n\n        for(auto x : G[cur]) {\n            if(!isthrough[x.to]) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else if(x.to != prev) {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n        }\n    }\n    set<int> artPoints() {\n        set<int> se;\n        int num = 0;\n        rep(i,0,v) {\n            // printf(\"%lld: %lld %lld\\n\", i, ord[parent[i]], low[i]);\n            if(parent[i] == 0) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num > 2) se.insert(0);\n        return se;\n    }\n\n    set<pii> bridges(vector<pii> vp) {\n        set<pii> se;\n        rep(i,0,vp.size()) {\n            if(ord[vp[i].fr] < low[vp[i].sc] || ord[vp[i].sc] < low[vp[i].fr]) {\n                // se.insert(vp[i]);\n                int mi = min(vp[i].fr, vp[i].sc);\n                int ma = max(vp[i].fr, vp[i].sc);\n                se.insert(pii(mi, ma));\n            }\n        }\n        return se;\n    }\n};\n\nsigned main() {\n    int v, e; cin >> v >> e;\n    graphLink gr(v);\n    vector<pii> vp;\n\n    int s, t;\n    rep(i,0,e) {\n        cin >> s >> t;\n        gr.G[s].pb(Edge(t,1));\n        gr.G[t].pb(Edge(s,1));\n        vp.pb(pii(s, t));\n    }\n    gr.dfs(0, -1);\n\n    // set<int> ret = gr.artPoints();\n    set<pii> ret2 = gr.bridges(vp);\n    // for(auto x : ret) cout << x << endl;\n    for(auto x : ret2) printf(\"%lld %lld\\n\", x.fr, x.sc);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int max_n=100001;\nvector<int> vi[max_n];\nvector<pint> bridge;\nvector<int> articulation;\nint ord[max_n],low[max_n];\nbool used[max_n];\nvoid lowlink_dfs(int v,int par,int &cur_ord){\n    used[v]=true;\n    ord[v]=cur_ord++;\n    low[v]=ord[v];\n\n    bool isArticulation=false;\n    int ctree=0;\n    rep(i,vi[v].size()){\n        if(!used[vi[v][i]]){\n            ++ctree;\n            lowlink_dfs(vi[v][i],v,cur_ord);\n            low[v]=min(low[v],low[vi[v][i]]);\n            if(par!=-1&&ord[v]<=low[vi[v][i]]) isArticulation=true;\n            if(ord[v]<low[vi[v][i]]) bridge.pb(mp(min(v,vi[v][i]),max(v,vi[v][i])));\n        }\n        else if(vi[v][i]!=par){\n            low[v]=min(low[v],ord[vi[v][i]]);\n        }\n    }\n    if(par==-1&&ctree>1) isArticulation=true;\n    if(isArticulation) articulation.pb(v);\n}\nint main(){\n    int n,m,sr,ds;\n    cin>>n>>m;\n    rep(i,m){\n        cin>>sr>>ds;\n        vi[sr].pb(ds);\n        vi[ds].pb(sr);\n    }\n    int ord=0;\n    rep(i,n){\n        if(!used[i]) lowlink_dfs(i,-1,ord);\n    }\n    sort(bridge.begin(),bridge.end());\n    /*rep(i,articulation.size()){\n        cout<<articulation[i]<<endl;\n    }*/\n    rep(i,bridge.size()){\n        cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<bits/stdc++.h>\nusing namespace std;\nusing cost_t=int;\n\nstruct Edge {\n    int from, to;\n    cost_t cost;\n    Edge(int from, int to, cost_t cost) : from(from), to(to), cost(cost) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nEdges bridgesDetection(Graph& g){\n    int n = g.size();\n    vector<int> pre(n,-1);\n    vector<int> low(n);\n    Edges res;\n    int k=0;\n    function<int(int,int)> dfs=[&](int v,int prev){\n        low[v] = pre[v];\n        for(auto& e:g[v]){\n            if(e.to==prev) continue;\n            if(pre[e.to]==-1){\n                pre[e.to] = k++;\n                low[v] = min(low[v], dfs(e.to,v));\n                if(pre[v]<low[e.to]) res.push_back(e);\n            }\n            else low[v] = min(low[v], pre[e.to]);\n        }\n        return low[v];\n    };\n    for(int i=0;i<n;i++){\n        if(pre[i]==-1){\n            pre[i]=k++;\n            dfs(i,-1);\n        }\n    }\n    return res;\n}\nint main(){\n    int V,E;\n    cin>>V>>E;\n    Graph g(V);\n    for(int i=0;i<E;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(Edge(s,t,0));\n        g[t].push_back(Edge(t,s,0));\n    }\n    auto res = bridgesDetection(g);\n    auto cmp=[&](Edge lhs,Edge rhs){\n        auto mP=[&](Edge e){\n            return make_pair(min(e.from,e.to),max(e.from,e.to));\n        };\n        auto lP=mP(lhs),rP=mP(rhs);\n        return lP<rP;\n    };\n    sort(res.begin(),res.end(),cmp);\n    for(auto &e:res){\n        cout<<min(e.from,e.to)<<\" \"<<max(e.from,e.to)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int v, e;\n   std::cin >> v >> e;\n   std::vector<Int> ss(e), ts(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i];\n   std::vector<std::vector<Int>> nexts(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i];\n      nexts[s].emplace_back(t);\n      nexts[t].emplace_back(s);\n   }\n   std::vector<Int> xs(v,-1);\n   std::vector<Int> ys(v);\n   std::vector<std::pair<Int,Int>> zs;\n   xs[0] = 0;\n   Int id = 1;\n   std::function<Int(Int,Int)> dfs = [&](Int i, Int prev) {\n      xs[i] = id;\n      id += 1;\n      Int res = 0;\n      for(Int k : nexts[i]) {\n         guard( k != prev );\n         if( xs[k] == -1 ) {\n            Int t = dfs(k, i);\n            if( t == 0 ) {\n               Int a = std::min(i, k);\n               Int b = std::max(i, k);\n               zs.emplace_back(a, b);\n            }\n            res += t;\n         }\n         else if( xs[k] < xs[i] ) {\n            ys[i] += 1;\n            ys[k] -= 1;\n         }\n      }\n      res += ys[i];\n      return res;\n   };\n   dfs(0, -1);\n   std::sort(zs.begin(), zs.end());\n   for(auto z : zs) {\n      printf(\"%ld %ld\\n\", z.first, z.second);\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tfor (int v : g[u]) {\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tdfs(0, -1, 0);\n\t\n\tfor (pii now : bridge) printf(\"%d %d\\n\", now.first, now.second);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iomanip>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MAX=100005;\nconst int inf=1e9;\nvi G[MAX];\nint N;\nbool visited[MAX];\ntypedef pair<int,int> P;\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\nvoid dfs(int current,int prev)\n{\n  prenum[current]=lowest[current]=timer;\n  timer++;\n\n  visited[current]=true;\n  int next;\n  for(int i=0;i<G[current].size();i++)\n  {\n    next=G[current][i];\n    if(!visited[next])\n    {\n      parent[next]=current;\n      dfs(next,current);\n      lowest[current]=min(lowest[current],lowest[next]);\n      if(prenum[current]<=lowest[next]) bridge.push_back(P(current,next));\n    }\n    else if(next!=prev)\n    {\n      lowest[current]=min(lowest[current],prenum[next]);\n    }\n  }\n}\n\nvoid bridge_points()\n{\n  timer=1;\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n  {\n    cout << bridge[i].first << ' ' << bridge[i].second << endl;\n  }\n}\n\nint main(void)\n{\n  int m;\n  cin >> N >> m;\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<m;i++)\n  {\n    int s,t;\n    cin >> s>> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  bridge_points();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int from,to;\n    Edge(int f,int t) : from(f), to(t){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass LowLink {\n    public:\n        LowLink(int n) : mGraph(n), mOrd(n), mLow(n), mUsed(n,false) {}\n        void add_edge(int u, int v){\n            mGraph[u].emplace_back(u,v);\n            mGraph[v].emplace_back(v,u);\n        }\n        // e(u,v)が橋　<=> ord[u] < low[v]\n        // 頂点vが関節点 <=> ord[u] <= low[v]となるvの子uが存在\n        int dfs(int v,int pv,int k){\n            mUsed[v] = true;\n            mOrd[v] = mLow[v] = k++; // 訪れた順\n            bool is_articulation = false;\n            int cnt = 0;\n            for(Edge nv : mGraph[v]){\n                if(!mUsed[nv.to]){ // まだ訪れてない\n                    ++cnt;\n                    k = dfs(nv.to,v,k);\n                    mLow[v] = min(mLow[v], mLow[nv.to]);\n\n                    is_articulation |= ~pv && mOrd[v] <= mLow[nv.to];\n                    if(mOrd[v] < mLow[nv.to]) mBridges.emplace_back(v,nv.to);\n                } else if(nv.to != pv){ // 後退辺だったら\n                    mLow[v] = min(mLow[v], mOrd[nv.to]);\n                }\n            }\n            is_articulation |= pv == -1 && cnt > 1;\n            if(is_articulation) mArticulationPoints.push_back(v);\n\n            return k;\n        }\n\n        void Init(){\n            int k = 0;\n            for(int i = 0; i < mGraph.size(); ++i){\n                if(!mUsed[i]) k = dfs(i,k,-1);\n            }\n        }\n\n        vector<pair<int,int> > GetBridges(){ return mBridges;}\n        vector<int> GetArticulationPoints(){ return mArticulationPoints;}\n\n    private:\n        Graph mGraph;\n        vector<int> mOrd;\n        vector<int> mLow;\n        vector<bool> mUsed;\n        vector<pair<int,int> > mBridges;\n        vector<int> mArticulationPoints;\n};\n\n\nint main(){\n    int V,E,s,t;\n    cin >> V >> E;\n    LowLink lowlink(V);\n    for(int i = 0; i < E; ++i){\n        cin >> s >> t;\n        lowlink.add_edge(s,t);\n    }\n    lowlink.Init();\n    auto ans = lowlink.GetBridges();\n    sort(ans.begin(),ans.end());\n    for(auto e : ans){ cout << e.first << \" \" << e.second << endl;}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n\nclass LowLink {\n    const int N;\n    vector<vector<int>> G;\n    set<int> used_v;\n    vector<int> ord, low, parent;\n\n    void dfs(int v, int &k)\n    {\n        used_v.insert(v);\n        ord[v] = low[v] = k++;\n\n        for (auto u : G[v]) {\n            if (!used_v.count(u)) {\n                parent[u] = v;\n                dfs(u, k);\n                low[v] = min(low[v], low[u]);\n            } else if (u != parent[v]) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n\n    void calc_lowlink()\n    {\n        int k = 0;\n        dfs(0, k);\n    }\n\npublic:\n    LowLink(int _N) : N(_N), G(_N), ord(_N), low(_N), parent(_N) {}\n\n    vector<int> articulation_point()\n    {\n        vector<int> res;\n\n        parent[0] = -1;\n        calc_lowlink();\n\n        int root_deg = 0;\n        for (int i=1; i<N; i++) {\n            int p = parent[i];\n            if (p == 0) root_deg++;\n            else if (ord[p] <= low[i]) {\n                res.push_back(p);\n            }\n        }\n\n        if (root_deg > 1) res.push_back(0);\n        sort(res.begin(), res.end());\n        res.erase(unique(res.begin(), res.end()), res.end());\n\n        return res;\n    }\n\n    vector<PII> bridge()\n    {\n        vector<PII> res;\n        calc_lowlink();\n        for (int v=0; v<N; v++) {\n            for (auto u : G[v]) {\n                if (ord[v] < low[u]) {\n                    res.emplace_back(min(v, u), max(v, u));\n                }\n            }\n        }\n        return res;\n    }\n\n    void add_edge(int u, int v)\n    {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n};\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    LowLink LL(N);\n\n    rep(i, M) {\n        int U, V;\n        cin >> U >> V;\n        LL.add_edge(U, V);\n    }\n\n    vector<PII> b = LL.bridge();\n    sort(ALL(b));\n    for (auto a : b) cout << a.first << \" \" << a.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nvoid DFS(Graph &g, int u, int &clock, vector<int> &low, vector<int> &disc, vector<bool> &seen, vector<int> &parent, vector<Edge> &bridges) {\n    stack<int> s;\n    for(int v: g[u]) {\n        if (! seen[v]) {\n            clock++;\n\n            disc[v] = clock;\n            low[v] = clock;\n            seen[v] = true;\n            parent[v] = u;\n\n            DFS(g, v, clock, low, disc, seen, parent, bridges);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u])\n                bridges.push_back(Edge{min(u, v), max(u, v)});\n        } else if (v != parent[u]) {\n            low[u]  = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> bridges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    int clock = 2;\n    vector<int> low(V, 0);\n    vector<int> disc(V, 0);\n    vector<int> parent(V, -1);\n    vector<bool> seen(V, false);\n    disc[0] = 1;\n    low[0] = 1;\n    seen[0] = true;\n\n    DFS(g, 0, clock, low, disc, seen, parent, bridges);\n\n    sort(bridges.begin(), bridges.end());\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint V,E;\nvector<int> g[100100];\nint dep[100100],low[100100],ord[100100];\nint cnt = 0;\nvoid dfs(int v,int p,int d){\n    dep[v] = d;\n    ord[v] = cnt++;\n    low[v] = ord[v];\n    for(int i=0;i<g[v].size();i++){\n        if(g[v][i]==p)continue;\n        int ch = g[v][i];\n        if(ord[ch]==-1){\n            dfs(ch,v,d+1);\n            low[v] = min(low[v],low[ch]);\n        }else{\n            low[v] = min(low[v],ord[ch]);\n        }\n    }\n}\nint main(){\n    scanf(\"%d %d\",&V,&E);\n    vector<P> es(E);\n    for(int i=0;i<E;i++){\n        int s,t;\n        scanf(\"%d %d\",&s,&t);\n        g[s].pb(t);\n        g[t].pb(s);\n        if(s>t)swap(s,t);\n        es[i]=P(s,t);\n    }\n    memset(ord,-1,sizeof(ord));\n    dfs(0,-1,0);\n    vector<P> ans;\n    for(int i=0;i<E;i++){\n        int s = es[i].fi,t = es[i].sec;\n        if(dep[s]>dep[t])swap(s,t);\n        if(ord[s]<low[t])ans.pb(es[i]);  \n    }\n    sort(all(ans));\n    for(int i=0;i<ans.size();i++)printf(\"%d %d\\n\",ans[i].fi,ans[i].sec);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int MAX_n = 1e5, MAX_m = 1e5;\n\nint n, m;\nvector<int> adj[MAX_n];\nint h[MAX_n], f[MAX_n];\nbool mark[MAX_n] = {};\nvector<pii> ceg;\n\nvoid add(int a, int b) {\n\tif (a > b) swap(a, b);\n\tceg.push_back(pii(a, b));\n}\n\nvoid DFS(int v, int p) {\n\tif (mark[v]) return;\n\tmark[v] = true;\n\tf[v] = h[v];\n\tfor (int u : adj[v]) {\n\t\tif (!mark[u]) {\n\t\t\th[u] = h[v] + 1;\n\t\t\tDFS(u, v);\n\t\t\tif (f[u] > h[v]) add(u, v);\n\t\t\telse f[v] = min(f[v], f[u]);\n\t\t}\n\t\telse if (u != p)\n\t\t\tf[v] = min(f[v], h[u]);\n\t}\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\th[0] = 0;\n\tDFS(0, -1);\n\tsort(ceg.begin(), ceg.end());\n\tfor (pii i : ceg)\n\t\tcout << i.first << ' ' << i.second << endl;\n        if (ceg.size() == 0)\n                cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LowLink{\n  int n,pos;\n  vector<int> ord,low,par,blg;\n  vector<vector<int> > G,C,T;\n  \n  vector<int> ap;\n  vector<pair<int, int> > bs;\n\n  LowLink(int n):n(n),pos(0),ord(n,-1),low(n),par(n,-1),blg(n,-1),G(n){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n\n  void dfs(int v){\n    ord[v]=low[v]=pos++;\n    for(int u:G[v]){\n      if(u==par[v]) continue;\n      if(~ord[u]){\n\tlow[v]=min(low[v],ord[u]);\n\tcontinue;\n      }\n      par[u]=v;\n      dfs(u);\n      low[v]=min(low[v],low[u]);\n      if(is_bridge(u,v)) bs.emplace_back(u,v);\n    }\n  }\n\n  void fill_component(int v){\n    C[blg[v]].emplace_back(v);\n    for(int u:G[v]){\n      if(~blg[u]) continue;\n      blg[u]=blg[v];\n      fill_component(u);\n    }\n  }\n\n  void add_component(int v,int &k){\n    if(~blg[v]) return;\n    blg[v]=k++;\n    C.emplace_back();\n    fill_component(v);\n  }\n  \n  void build(){\n    for(int i=0;i<n;i++)\n      if(ord[i]<0) dfs(i);\n    \n    vector<int> cnt(n,0);\n    for(int i=0;i<n;i++){\n      int p=par[i];\n      if(p<0) continue;\n      if(par[p]<0) cnt[p]++;\n      else if(ord[p]<=low[i]) ap.emplace_back(p);\n    }\n    \n    for(int i=0;i<n;i++)\n      if(cnt[i]>1) ap.emplace_back(i);\n\n    sort(ap.begin(),ap.end());\n    ap.erase(unique(ap.begin(),ap.end()),ap.end());\n\n    int k=0;    \n    for(int i=0;i<n;i++) add_component(i,k);\n\n    T.assign(C.size(),vector<int>());\n    for(auto e:bs){\n      int u=blg[e.first],v=blg[e.first];\n      T[u].emplace_back(v);\n      T[v].emplace_back(u);\n    }      \n  }\n};\n\n\n//problemId=GRL_3_B\nsigned main(){\n  int n,m;\n  scanf(\"%d %d\",&n,&m);\n  \n  LowLink G(n);\n  for(int i=0;i<m;i++){\n    int u,v;\n    scanf(\"%d %d\",&u,&v);\n    G.add_edge(u,v);\n  }\n  G.build();\n  \n  auto bs=G.bs;\n  for(auto &e:bs)\n    if(e.first>e.second) swap(e.first, e.second);\n  \n  sort(bs.begin(),bs.end());\n  for(auto e:bs) printf(\"%d %d\\n\",e.first, e.second);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nusing Lint=long long;\nusing Graph=vector<vector<int>>;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,M; cin>>N>>M;\n    Graph G(N);\n    for(int i=0;i<M;i++){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    vector<int> ord(N,-1),sum(N);\n    vector<pair<int,int>> bridges;\n    function<void(int,int)> dfs=[&](int v,int p)\n    {\n        static int order=0;\n        ord[v]=order++;\n        for(int u:G[v]) if(u!=p){\n            if(ord[u]<0){\n                dfs(u,v);\n                sum[v]+=sum[u];\n                if(sum[u]==0) bridges.push_back(minmax(v,u));\n            }else if(ord[v]>ord[u]){\n                // cout<<v+1<<' '<<u+1<<endl;\n                sum[v]++; sum[u]--;\n            }\n        }\n    };\n    dfs(0,-1);\n    sort(bridges.begin(),bridges.end());\n    for(auto p:bridges) cout<<p.first<<' '<<p.second<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tint tmr = 0;\n\tvector<int> ord(n, -1), low(n, -1);\n\tvector<pair<int, int>> bdg;\n\tfunction<void(int, int)> dfs = [&] (\n\t\tint crr\n\t,\tint prt\n\t) {\n\t\tord[crr] = low[crr] = tmr++;\n\t\tfor (int nxt : grh[crr]) {\n\t\t\tif (ord[nxt] == -1) dfs(nxt, crr);\n\t\t\tif (nxt != prt) chmin(low[crr], low[nxt]);\n\t\t\tif (ord[crr] < low[nxt]) bdg.emplace_back(crr, nxt);\n\t\t}\n\t};\n\tdfs(0, 0);\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tif (it->first > it->second) swap(it->first, it->second);\n\t}\n\tsort(bdg.begin(), bdg.end());\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> E[100010];\nvector<int> res;\nbool pass[100010][100010];\nint o[100010];\n\nint dfs(int i,int n) {\n    if(o[i]) {\n        o[i] = min(o[i], n);\n        return o[i];\n    }\n    o[i] = n;\n    for(vector<int>::iterator it=E[i].begin(); it != E[i].end(); it++) {\n        if(pass[i][*it]) continue;\n        pass[i][*it] = pass[*it][i] = true;\n        o[i] = min(o[i], dfs(*it, n+1));\n    }\n    return o[i];\n}\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0; i<e; i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        E[s].push_back(t);\n        E[t].push_back(s);\n    }\n    for(int i=0; i<v; i++)\n        sort(E[i].begin(), E[i].end());\n\n    dfs(0,1);\n\n    for(int i=0; i<v; i++)\n        for(vector<int>::iterator it = E[i].begin(); it != E[i].end(); it++) {\n            if(i > *it) continue;\n            if(o[i] == o[*it]) continue;\n            printf(\"%d %d\\n\",i,*it);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\nvector<pair<int, int> > vp;\nint vis[maxn],low[maxn],dfn[maxn];\nint ind ;\nvector<int> g[maxn];\nvoid tarjan(int u,int p)\n{\n    dfn[u]=low[u]=++ind;\n    vis[u]=1;\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(v==p) continue;\n        if(!vis[v])\n        {\n            tarjan(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u]<low[v]) {\n                int a = u, b = v;\n                if (a > b) swap(a, b);\n                vp.push_back(make_pair(a, b));\n            }\n        }\n        else low[u]=min(low[u],dfn[v]);\n    }\n}\nint v,e;\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    tarjan(0,-1);\n    sort(vp.begin(), vp.end());\n    for (int i = 0; i < vp.size(); i++)\n        printf(\"%d %d\\n\", vp[i].first, vp[i].second);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int f, int t) : from(f), to(t) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tGraph G(V);\n\tfor (int i = 0, s, t; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].emplace_back(s, t);\n\t\tG[t].emplace_back(t, s);\n\t}\n\tauto br = bridge(G);\n\tvector<pair<int, int>> res;\n\tfor (auto& e : br.second) {\n\t\tres.emplace_back(min(e.from, e.to), max(e.from, e.to));\n\t}\n\tsort(res.begin(), res.end());\n\tfor (auto p : res) {\n\t\tcout << p.first << ' ' << p.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n//O(|V|+|E|)\n\ntemplate<class graph_type> class bridge_and_articulation{\npublic:\n    const int size;\n    graph_type graph;\n    vector<bool> used,is_art;\n    vector<int> ord,low,articulations;\n    vector<pair<int,int>> bridges;\n\n    bridge_and_articulation(const graph_type &graph):graph(graph),size(graph.size()),used(size),is_art(size),ord(size),low(size){\n        int k=0;\n        for(int i=0; i<size; ++i) if(!used[i]) dfs(i,-1,k);\n    }\n\n    void dfs(int v,int p,int &k){ //v???????????¨???p=-1\n        used[v]=true;\n        ord[v]=low[v]=k++;\n\n        int count=0;\n        for(const auto &edge:graph[v]){\n            const int u=edge.to;\n            if(!used[u]){\n                ++count;\n                dfs(u,v,k);\n                low[v]=min(low[v],low[u]);\n\n                if(ord[v]<low[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n                if(p!=-1 and ord[v]<=low[u]) is_art[v]=true;\n            }else if(ord[u]<ord[v]) low[v]=min(low[v],ord[u]);\n        }\n\n        if(p==-1 and count>1) is_art[v]=true;\n        if(is_art[v]) articulations.push_back(v);\n    }\n\n    bool is_bridge(int u,int v)const{\n        if(ord[u]>ord[v]) swap(u,v);\n        return ord[u]<low[v];\n    }\n\n    bool is_articulation(int v)const{\n        return is_art[v];\n    }\n};\n\nstruct edge{\n    int to;\n};\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<edge>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(edge({t}));\n        graph[t].push_back(edge({s}));\n    }\n    bridge_and_articulation<vector<vector<edge>>> ba(graph);\n    vector<pair<int,int>> ans=ba.bridges;\n    sort(ans.begin(),ans.end());\n    for(auto &e:ans) cout << e.first << \" \" << e.second << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : dst < e.dst;}\n  bool operator==(const Edge &e){return src == e.src && dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void backward(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(int l=0;l<h[j].size();l++)\n        if(no[h[j][l].src]!=s) h[j][l].w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(auto i : next[v]) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        backward(h,i,s,r,no,cmp,prev,next,mcost,mark,cost,found);\n  }\n\n  void subaps(int current, int prev, int &timer,\n  vector<bool> &visited, vector<int> &prenum,\n  vector<int> &parent, vector<int> &lowest)\n  {\n    prenum[current]=lowest[current]=timer++;\n    visited[current]=true;\n    for(auto e : (*this)[current])\n    {\n      int next = e.dst;\n      if(!visited[next])\n      {\n        // cerr << e.src << \" \" << e.dst << endl;\n        parent[next]=current;\n        subaps(next,current,timer,visited,prenum,parent,lowest);\n        lowest[current]=min(lowest[current],lowest[next]);\n      }\n      else if(next != prev)\n        lowest[current]=min(lowest[current],prenum[next]);\n    }\n  }\n\n  void subbrs(int current, int prev, int &timer,\n  vector<int>&prenum, vector<int>&lowest, set<Edge<T>>&bridges)\n  {\n    prenum[current]=lowest[current]=timer++;\n    for(auto e : (*this)[current]) if(e.dst!=prev)\n    {\n      if(prenum[e.dst]==-1)\n      {\n        subbrs(e.dst,current,timer,prenum,lowest,bridges);\n        lowest[current]=min(lowest[current],lowest[e.dst]);\n        if(prenum[current] < lowest[e.dst])\n          bridges.insert(e);\n      }\n      lowest[current]=min(lowest[current],prenum[e.dst]);\n    }\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    const int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    const int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    const int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph<T> h(n);\n    for(int i=0;i<n;i++) for(auto e : (*this)[i]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int i=0;i<n;i++) cmp[i].push_back(no[i]=i);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : h[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int i=0;i<n;i++) if(prev[i]>=0)\n        next[prev[i]].push_back(i);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int i=0;i<n;i++) if(i!=r&&!mark[i]&&!cmp[i].empty())\n      {\n        bool found = false;\n        backward(h, i, i, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int i=0;i<n;i++) if(prev[i] >= 0) cost+=mcost[i];\n        return cost;\n      }\n    }\n  }\n\n  /*\n    articulation points\n    costs O(|E|log|V|)\n  */\n  set<int> APs(void)\n  {\n    const int n = (*this).size();\n    set<int> ap;\n    if(n==1) return ap;\n    int timer = 1;\n    vector<bool> visited(n,false);\n    vector<int> prenum(n), parent(n), lowest(n);\n    subaps(0,-1,timer,visited,prenum,parent,lowest);\n    int np = 0;\n    for(int i=1; i<n; i++)\n    {\n      int p = parent[i];\n      if(p==0) np++;\n      else if(prenum[p]<=lowest[i]) ap.insert(p);\n    }\n    if(np > 1) ap.insert(0);\n    return ap;\n  }\n\n  set<Edge<T>> bridges(void)\n  {\n    const int n = (*this).size();\n    set<Edge<T>> bridges;\n    vector<int> prenum(n,-1), lowest(n,inf);\n    int timer = 0;\n    for(int i=0;i<n;i++) if(prenum[i]==-1)\n      subbrs(i,-1,timer,prenum,lowest,bridges);\n    return bridges;\n  }\n};\n\nint main()\n{\n  int v,e,r; cin>>v>>e;\n  Graph<long long> g(v);\n  REP(i,e)\n  {\n    ll s,t; cin >> s >> t;\n    g.undirect(s,t);\n  }\n  auto ans = g.bridges();\n  for(auto x : ans) cout << x.src << \" \" << x.dst << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n\nclass Node {\npublic:\n\tNode():number(i++), order(0), min(0), depth(-1), edges(0), parent(nullptr), uft(nullptr) {}\n\tbool rearch() const { return depth >= 0; }\n\tvoid close() {\n\t\tuft = parent;\n\t}\n\tNode* get_union() {\n\t\tif (uft) {\n\t\t\treturn uft = uft->get_union();\n\t\t}\n\t\telse {\n\t\t\treturn this;\n\t\t}\n\t}\n\tstatic int i;\n\tint number, order, min, depth;\n\tstd::vector<Node*> edges;\n\tNode *parent;\n\tNode *uft;\n};\nstruct Edge {\n\tNode *from, *to;\n\tint start, end;\n\tEdge(Node * const f = nullptr, Node * const t = nullptr, const int &s = 0, const int &e = 0) :from(f), to(t), start(s > e ? e:s), end(s > e? s:e) {};\n\tEdge &operator=(const Edge &other) { from = other.from; to = other.to; start = other.start; end = other.end; return *this; }\n\tbool bridge() { return from->get_union()->number != to->get_union()->number; }\n\tbool operator<(const Edge &other) const { return (start < other.start) || (start == other.start && end < other.end); }\n\tvoid show() { std::cout << start << \" \" << end << \"\\n\"; }\n};\nint Node::i(0);\nint dfs(Node &node, Node* const parent, const int &depth = 0) {\n\tif (node.rearch()) {\n\t\treturn node.depth;\n\t}else{\n\t\tnode.parent = parent;\n\t\tnode.depth = depth;\n\t\tint min = depth;\n\t\tfor (auto &e : node.edges) {\n\t\t\tif (e != parent) {\n\t\t\t\tauto temp = dfs(*e, &node, depth + 1);\n\t\t\t\tif (min > temp) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnode.min = min;\n\t\tif (min < depth) {\n\t\t\tnode.close();\n\t\t}\n\t\treturn node.min;\n\t}\n}\nvoid sort(std::vector<Edge> &vector, const int &left, const int &right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (vector.at(l) < pivot)++l;\n\t\t\twhile(pivot < vector.at(r))--r;\n\t\t\tif (l < r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, r + 1, right);\n\t}\n}\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tstd::vector<Edge> edge(0);\n\tstd::vector<Node> node(v);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\t\tedge.push_back(Edge(&node.at(s), &node.at(t), s, t));\n\t\tnode.at(s).edges.push_back(&node.at(t));\n\t\tnode.at(t).edges.push_back(&node.at(s));\n\t}\n\tdfs(node.at(0), &node.at(0));\n\tsort(edge, 0, edge.size() - 1);\n\tfor (auto &e : edge) {\n\t\tif (e.bridge()) {\n\t\t\te.show();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> P;\nconst int MAX_V=100000;\nvector<int> G[MAX_V];\nint ord[MAX_V];\nbool inS[MAX_V];\nstack<int> roots,S;\nvector<vi> cc;\nvector<P> bs;\nint cnt;\nint N,M;\nvoid vis(int v,int p){\n\tord[v]=++cnt;\n\tS.push(v);\n\tinS[v]=1;\n\troots.push(v);\n\tfor(int u:G[v]){\n\t\tif(ord[u]==0){\n\t\t\tvis(u,v);\n\t\t}else if(u!=p&&inS[u]){\n\t\t\twhile(ord[roots.top()]>ord[u]) roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top()){\n\t\tbs.pb(P(p,v));\n\t\tvector<int> vc;\n\t\twhile(true){\n\t\t\tint w=S.top();S.pop();\n\t\t\tinS[w]=0;\n\t\t\tvc.pb(w);\n\t\t\tif(v==w) break;\n\t\t}\n\t\troots.pop();\n\t\tcc.pb(vc);\n\t}\n}\nvoid bridge(){\n\trep(i,N) if(ord[i]==0){\n\t\tvis(i,-1);\n\t\tbs.pop_back();\n\t}\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tbridge();\n\tfor(P& p:bs) if(p.fs>p.sc) swap(p.fs,p.sc);\n\tsort(all(bs));\n\tfor(P p:bs){\n\t\tcout<<p.fs<<\" \"<<p.sc<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  bcc.input(e,0);\n  bcc.build();\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  for(P &p:B) if(p.first>p.second) swap(p.first,p.second);\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}\n\n/*\n  verified on 2017/10/21\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n//??°?????????lowlink???????????????????????¢????????¨??????????????????\n//?¨??????? O(|V|+|E|)\nvoid lowlink(vector<int>graph[], int n, vector<int>&low, vector<pair<int, int>>&br, vector<int>&jnt) {\n\tlow.resize(n);\n\tvector<int>ord(n);//DFS?????????\n\tvector<bool>vis(n);//?¨???????????????????\n\t//?????°????????????\n\tfunction<void(int, int, int&)>dfs = [&](int v, int p, int &k) {\n\t\tvis[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\tbool joint = false;\n\t\tint cnt = 0;\n\t\tfor (auto nxt : graph[v]) {\n\t\t\tif (!vis[nxt]) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, v, k);\n\t\t\t\tlow[v] = min(low[v], low[nxt]);\n\t\t\t\tif (p >= 0 && ord[v] <= low[nxt]) joint = true;\n\t\t\t\tif (ord[v] < low[nxt])br.push_back({ min(v,nxt),max(v,nxt) });\n\t\t\t}\n\t\t\telse if (nxt != p) {\n\t\t\t\tlow[v] = min(low[v], ord[nxt]);\n\t\t\t}\n\t\t}\n\t\tif (p < 0 && cnt > 1) joint = true;\n\t\tif (joint) jnt.push_back(v);\n\t};\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])dfs(i, -1, k);\n}\n\nint N, M;\nvector<int>graph[123456];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgraph[s].push_back(t);\n\t\tgraph[t].push_back(s);\n\t}\n\tvector<int>low, jnt;\n\tvector<pair<int, int>>br;\n\tlowlink(graph, N, low, br, jnt);\n\tsort(br.begin(), br.end());\n\tfor (auto i : br) {\n\t\tcout << i.first << \"  \" << i.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass biconnected{\npublic:\n\tvector<vector<int> > G ,graph;\n\tvector<int> ord,low,cmp;\n\tvector<P> bridge;\n\tvector<vector<P> > check;\n\tvector<bool> visit;\n\tint V;\n\tbiconnected(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V);\n\t\tcheck.resize(V),ord.resize(V),low.resize(V);\n\t\tcmp.resize(V),check.resize(V),visit.resize(V,false);\n\t}\n\tvoid build(){\n\t\tint id = 0;\n\t\trep(i,V){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(i,-1,id);\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,int p,int &k)\n\t{\n\t\tvisit[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\trep(i,(int)G[v].size()){\n\t\t\tint w = G[v][i];\n\t\t\tif(!visit[w]){\n\t\t\t\tdfs(w,v,k);\n\t\t\t\tlow[v] = min(low[v],low[w]);\n\t\t\t\tif(ord[v] < low[w]){\n\t\t\t\t\tif(v > w) swap(v,w);\n\t\t\t\t\tbridge.push_back(P(v,w));\n\t                check[v][i].second = 1;\n\t                check[w][check[v][i].first].second = 1;\n\t\t\t\t}\n\t\t\t//(v,w)????????????\n\t\t\t}else if(w != p){\n\t\t\t\tlow[v] = min(low[v],ord[w]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid add_edge(int u,int v)\n\t{\n\t    G[u].push_back(v),G[v].push_back(u);\n\t    check[u].push_back(P((int)check[v].size(),0));\n\t    check[v].push_back(P((int)check[u].size()-1,0));\n\t}\n\n\tvoid restrict_dfs(int u,int p,int kind,queue<int>& que)\n\t{\n\t    visit[u] = true;\n\t    cmp[u] = kind;\n\t    rep(i,(int)G[u].size()){\n\t\t\tint w = G[u][i];\n\t        if(check[u][i].second){\n\t            if(!visit[w]){\n\t                que.push(w);\n\t            }\n\t        }else if(!visit[w]){\n\t            restrict_dfs(w,u,kind,que);\n\t        }\n\t    }\n\t}\n\t//????????°?????????\n\tint make_bcgraph()\n\t{\n\t\tgraph.resize(V);\n\t    int num = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            dfs(i,-1,num);\n\t        }\n\t    }\n\t    fill(visit.begin(),visit.end(),false);\n\t    int kind = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            queue<int> que;\n\t            que.push(i);\n\t            while(!que.empty()){\n\t                int p = que.front();\n\t                que.pop();\n\t                restrict_dfs(p,-1,kind,que);\n\t                kind++;\n\t            }\n\t        }\n\t    }\n\t    rep(i,(int)bridge.size()){\n\t        int a = cmp[bridge[i].first];\n\t        int b = cmp[bridge[i].second];\n\t        graph[a].push_back(b), graph[b].push_back(a);\n\t    }\n\t    return kind;\n\t}\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n\tbiconnected bc(n);\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tbc.add_edge(u,v);\n\t}\n\tbc.build();\n\tsort(all(bc.bridge));\n\trep(i,len(bc.bridge)){\n\t\tcout << bc.bridge[i].fi << \" \" << bc.bridge[i].se << \"\\n\";\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\nconst int N=1e5+10;\nint p[N],low[N],dep[N],t=0;\nstack<int> s;\nbitset<N>went,in,used;\nvector<pi> graph[N];\nvoid dfs(int now){\n    in[now]=went[now]=true;\n    low[now]=dep[now]=++t;\n    s.push(now);\n    for(int i=0;i<graph[now].size();i++)if(!used[graph[now][i].S]){\n        used[graph[now][i].S]=true;\n        if(!went[graph[now][i].F])dfs(graph[now][i].F);\n        if(in[graph[now][i].F])low[now]=min(low[now],low[graph[now][i].F]);\n    }\n    if(low[now]==dep[now]){\n        while(s.top()!=now){\n            p[s.top()]=now;\n            in[s.top()]=false;\n            s.pop();\n        }\n        p[now]=now;\n        s.pop();\n        in[now]=false;\n    }\n    return ;\n}\nint main(){\n    int n,m,l,r;\n    set<pi> ans;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<m;i++){\n        scanf(\"%d%d\",&l,&r);\n        graph[l].PB(MP(r,i));\n        graph[r].PB(MP(l,i));\n    }\n    went.reset();\n    in.reset();\n    used.reset();\n    for(int i=0;i<n;i++)if(!went[i])dfs(i);\n    for(int i=0;i<n;i++)for(int j=0;j<graph[i].size();j++)if(p[i]!=p[graph[i][j].F]){\n        if(i<graph[i][j].F)ans.insert(MP(i,graph[i][j].F));\n        else ans.insert(MP(graph[i][j].F,i));\n    }\n    for(auto u:ans)printf(\"%d %d\\n\",u.F,u.S);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX=100000;\n\nint n;\nvector<int> G[MAX];\nint order[MAX]={};\nbool inS[MAX]={};\nstack<int> roots;\nint k;\nvector<P> brg;\n\nvoid visit(int v,int p)\n{\n\torder[v]=++k;\n\tinS[v]=true;\n\troots.push(v);\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint to=G[v][i];\n\t\tif(order[to]==0)\n\t\t{\n\t\t\tvisit(to,v);\n\t\t}\n\t\telse if(to!=p&&inS[to])\n\t\t{\n\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top())\n\t{\n\t\tif(p!=-1)brg.push_back(P(p,v));\n\t\troots.pop();\n\t}\n\treturn;\n}\n\nvoid bridge()\n{\n\tk=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(order[i]==0)\n\t\t{\n\t\t\tvisit(i,-1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tcin>>n;\n\tint e;\n\tcin>>e;\n\tint u,v;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbridge();\n\tsort(brg.begin(),brg.end());\n\tfor(int i=0;i<brg.size();i++)\n\t{\n\t\tcout<<min(brg[i].first,brg[i].second)<<\" \"<<max(brg[i].first,brg[i].second)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In His Name\n#include<bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int> >e;\nvector<int>adj[100100];\nint n,m,minlvl[100100],lvl[100100];\nbool mark[100100];\nvoid dfs(int x,int par){\n\tmark[x]=true;\n\tminlvl[x]=lvl[x];\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tint v=adj[x][i];\n\t\tif(!mark[v]){\n\t\t\tlvl[v]=lvl[x]+1;\n\t\t\tdfs(v,x);\n\t\t\tminlvl[x]=min(minlvl[x],minlvl[v]);\n\t\t}\n\t\telse if(v!=par) minlvl[x]=min(minlvl[x],minlvl[v]);\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t\te.push_back(make_pair(x,y));\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(!mark[i]) dfs(i,i);\n\tsort(e.begin(),e.end());\n\tfor(int i=0;i<m;i++){\n\t\tint x=e[i].first,y=e[i].second;\n\t\tif(lvl[x]<lvl[y]) swap(x,y);\n\t\tif(minlvl[x]>lvl[y]) cout<<e[i].first<<\" \"<<e[i].second<<endl;\n\t}\n\treturn -0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n>>> In The Name Of GOD\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\n///ifstream fin(\"input.txt\");\n///ofstream fout(\"output.txt\");\n\nvector <int> mark;\n\nvector < vector <int> > adj;\nvector < pair <int,int> > edge;\nvector <int> h;\n\nint dfs(int v)\n{\n    mark[v-1]=1;\n    int m1,m2;\n    m1=m2=h[v-1];\n    //int check=1;\n    for (auto i:adj[v-1])\n        if (!mark[i-1])\n        {\n            h[i-1]=h[v-1]+1;\n            int x=dfs(i);\n           // if (v-1==3)\n             //   cout << '#'<< x << ' ' << h[v-1] << endl;\n            if ((x>h[v-1] || adj[i-1].size()==1))\n            {\n                edge.push_back(make_pair(min(i,v)-1,max(i,v)-1));\n                //check=0;\n            }\n            m1=min(m1,x);\n        }\n        else\n            if (h[i-1]!=h[v-1]-1)\n                m2=min(m2,h[i-1]);\n\n    return min(m1,m2);\n}\n\n\nint main()\n{\n    int n,i,m;\n    cin >> n >> m;\n    for (i=0;i<n;i++)\n        mark.push_back(0), h.push_back(0), adj.push_back({});\n    int x,y;\n    for (i=0;i<m;i++)\n        cin >> x >> y, adj[x].push_back(y+1), adj[y].push_back(x+1);\n    dfs(1);\n    sort(edge.begin(),edge.end());\n    for (auto j:edge)\n        cout << j.first << ' ' << j.second <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int>      Edge;   // (a < b: undirected)\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vi depth;\n    vi par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvi cmp;\n\tint num_cc;\n\tvi size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    void bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\t// rep(i, n) {\n\t\t// \tint size_cc = extractCC(i, num_cc);\n\t\t// \tif (size_cc > 0) {\n\t\t// \t\tsize_of_vertex.emplace_back(size_cc);\n\t\t// \t\tnum_cc++;\n\t\t// \t}\n\t\t// }\n        //\n        // r<set<int>> G_cc_st(num_cc);\n\t\t// for (auto&& p : EdgeType) {\n        //     Edge e;\n        //     int type;\n        //     tie(e, type) = p;\n        //     if (type == BRIDGE) {\n\t\t// \t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t// \t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n        //     }\n        // }\n        //\n\t\t// rep(i, num_cc) {\n\t\t// \tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t// }\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n    BICC bicc(V);\n    rep(i, E) {\n        int a, b;\n        cin >> a >> b;\n        bicc.addEdge(a, b);\n    }\n\n    bicc.bicc();\n    auto bridges = bicc.getBridges();\n    printVP(bridges);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint V,E;\nvector<int> G[MAX];\nint cnt[MAX];\nint visited[MAX];\n\nvector<P> ans;\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to]==0)ans.push_back( P( min(pos,to) , max(pos,to) ) );\n    }else{\n      cnt[pos]++;\n      cnt[to]--;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<(int)ans.size();i++)\n    printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <iomanip>\n\nusing namespace std;\n\n// Graph\nstruct UsedEdge{\n    int nextNode;\n    bool used;\n    int invIndex;\n};\n\nclass UsedEdgeGraph{\npublic:\n    vector<vector<UsedEdge>> E;\n\n    UsedEdgeGraph(int n){\n        E.resize(n);\n    }\n\n    void add(int node, int nextNode){\n        E[node].emplace_back((UsedEdge){nextNode, false, (int)E[nextNode].size()});\n        E[nextNode].emplace_back((UsedEdge){node, false, (int)E[node].size() - 1});\n    }\n};\n\n// lowlink\nclass Lowlink{\npublic:\n    vector<int> ord, low;\n    vector<vector<int>> dfsTree;\n    int root;\n    \n    Lowlink(vector<vector<UsedEdge>>& E, int root){\n        int n = (int)E.size();\n        this->root = root;\n        ord.assign(n, -1);\n        low.resize(n);\n        dfsTree.resize(n);\n\n        tempOrd = 0;\n        dfs(E, root);\n    }\n\n    bool isBridge(int u, int v){\n        if(ord[u] < low[v]){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\n    bool isPoint(int node){\n        if(node == root){\n            if((int)dfsTree[node].size() > 1){\n                return true;\n            }\n            else{\n                return false;\n            }\n        }\n        else{\n            for(int nextNode: dfsTree[node]){\n                if(ord[node] <= low[nextNode]){\n                    return true;\n                }\n            }\n            return false;\n        }   \n    }\n\nprivate:\n    int tempOrd;\n\n    void dfs(vector<vector<UsedEdge>>& E, int node){\n        ord[node] = tempOrd;\n        tempOrd++;\n        low[node] = ord[node];\n        for(auto& e: E[node]){\n            if(ord[e.nextNode] == -1){\n                e.used = true;\n                E[e.nextNode][e.invIndex].used = true;\n                dfsTree[node].push_back(e.nextNode);\n\n                dfs(E, e.nextNode);\n                low[node] = min(low[node], low[e.nextNode]);\n            }\n            else if(!e.used){\n                low[node] = min(low[node], ord[e.nextNode]);\n            }\n        }\n    }\n};\n\nint main(){\n\n    int V, E;\n    cin >> V >> E;\n    UsedEdgeGraph graph(V);\n    \n    int s, t;\n    for(int i = 0; i < E; i++){\n        cin >> s >> t;\n        graph.add(s, t);\n    }\n\n    Lowlink lowlink(graph.E, 0);\n\n    vector<pair<int, int>> ans;\n    for(int i = 0; i < V; i++){\n        for(int nextNode: lowlink.dfsTree[i]){\n            if(lowlink.isBridge(i, nextNode)){\n                int a = min(i, nextNode);\n                int b = max(i, nextNode);\n                ans.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    sort(ans.begin(), ans.end());\n\n    for(auto temp: ans){\n        cout << temp.first << \" \" << temp.second << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n    int from,to;\n    Edge(int f,int t) : from(f), to(t){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nclass LowLink {\n    public:\n        LowLink(int n) : mGraph(n), mOrd(n), mLow(n), mUsed(n,false) {}\n        void add_edge(int u, int v){\n            mGraph[u].emplace_back(u,v);\n            mGraph[v].emplace_back(v,u);\n        }\n        // e(u,v)が橋　<=> ord[u] < low[v]\n        // 頂点vが関節点 <=> ord[u] <= low[v]となるvの子uが存在\n        int dfs(int v,int pv,int k){\n            mUsed[v] = true;\n            mOrd[v] = mLow[v] = k++; // 訪れた順\n            bool is_articulation = false;\n            int cnt = 0;\n            for(Edge nv : mGraph[v]){\n                if(!mUsed[nv.to]){ // まだ訪れてない\n                    ++cnt;\n                    k = dfs(nv.to,v,k);\n                    mLow[v] = min(mLow[v], mLow[nv.to]);\n\n                    is_articulation |= ~pv && mOrd[v] <= mLow[nv.to];\n                    if(mOrd[v] < mLow[nv.to]) mBridges.emplace_back(minmax(v,nv.to));\n                } else if(nv.to != pv){ // 後退辺だったら\n                    mLow[v] = min(mLow[v], mOrd[nv.to]);\n                }\n            }\n            is_articulation |= pv == -1 && cnt > 1;\n            if(is_articulation) mArticulationPoints.push_back(v);\n\n            return k;\n        }\n\n        void Init(){\n            int k = 0;\n            for(int i = 0; i < mGraph.size(); ++i){\n                if(!mUsed[i]) k = dfs(i,k,-1);\n            }\n        }\n\n        vector<pair<int,int> > GetBridges(){ return mBridges;}\n        vector<int> GetArticulationPoints(){ return mArticulationPoints;}\n\n    private:\n        Graph mGraph;\n        vector<int> mOrd;\n        vector<int> mLow;\n        vector<bool> mUsed;\n        vector<pair<int,int> > mBridges;\n        vector<int> mArticulationPoints;\n};\n\n\nint main(){\n    int V,E,s,t;\n    cin >> V >> E;\n    LowLink lowlink(V);\n    for(int i = 0; i < E; ++i){\n        cin >> s >> t;\n        lowlink.add_edge(s,t);\n    }\n    lowlink.Init();\n    auto ans = lowlink.GetBridges();\n    sort(ans.begin(),ans.end());\n    for(auto e : ans){ cout << e.first << \" \" << e.second << endl;}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\nnamespace __bridge{\n\ttypedef vector<vector<int>> Graph;\n    //O(V+E)\n\tclass Bridge{\n\tprivate:\n\t\tint N;Graph g;\n\t\tvector<int> ord,low;vector<bool> vis;\n\t\tvoid dfs(int v,int p,int &oi,int &gi){\n\t\t\tvis[v]=true;ord[v]=low[v]=oi++;\n\t\t\tfor(int to:g[v]){\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tdfs(to,v,oi,gi);\n\t\t\t\t\tlow[v]=min(low[v],low[to]);\n\t\t\t\t\tif(ord[v]<low[to])bridges.push_back(make_pair(min(v,to),max(v,to)));\n\t\t\t\t}else if(to != p){\n\t\t\t\t\tlow[v]=min(low[v],ord[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<pair<int,int>> bridges;\n\t\tBridge(int N):N(N){\n\t\t\tg=Graph(N);ord=low=vector<int>(N);vis=vector<bool>(N);\n\t\t}\n\t\tvoid add_edge(int f,int t){\n\t\t\tg[f].push_back(t);g[t].push_back(f);\n\t\t}\n\t\tvector<pair<int,int>> bridge(){\n\t\t\tint oi=0,gi=0;REP(v,N)if(!vis[v])dfs(v,-1,oi,gi);\n\t\t\treturn bridges;\n\t\t}\n\t\tbool same(int i,int j){return low[i]==low[j];}\n\t};\n}\nusing namespace __bridge;\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint V,E;cin >> V >> E;\n\t\tBridge bg(V);\n\t\tREP(i,E){\n\t\t\tint s,t;cin >> s >> t;\n\t\t\tbg.add_edge(s,t);\n\t\t}\n\t\tbg.bridge();\n\t\tsort(ALL(bg.bridges));\n\t\tREP(i,bg.bridges.size())\n\t\t\tcout <<bg.bridges[i]<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n// BEGIN CUT HERE\npair< V<>, V< pair<int, int> > > lowlink(const VV<>& g, V<>& ord, V<>& low, int r = 0) {\n  int n = g.size();\n  ord.assign(n, -1); // pre-order\n  low.assign(n, -1); // 後退辺を高々1回通って到達できる頂点のordのmin\n  V<> articulation_points;\n  V< pair<int, int> > bridges;\n  int t = 0;\n  auto dfs = [&](const auto& dfs, int v, int p) -> void {\n    ord[v] = low[v] = t++;\n    int d = 0;\n    bool f = false;\n    for (int w : g[v]) if (w != p) {\n      if (ord[w] == -1) {\n        dfs(dfs, w, v);\n        low[v] = min(low[v], low[w]);\n        f |= ord[v] <= low[w];\n        if (ord[v] < low[w]) bridges.emplace_back(minmax(v, w));\n        ++d;\n      } else {\n        low[v] = min(low[v], ord[w]);\n      }\n    }\n    if (v == r and d >= 2 or v != r and f) {\n      articulation_points.push_back(v);\n    }\n  };\n  dfs(dfs, r, -1);\n  sort(begin(articulation_points), end(articulation_points));\n  sort(begin(bridges), end(bridges));\n  return {articulation_points, bridges};\n}\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  VV<> g(n);\n  while (m--) {\n    int s, t; cin >> s >> t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  V<> ord, low;\n  // for (int v : lowlink(g(, ord, low)).first) {\n  //   cout << v << '\\n';\n  // }\n  for (const auto& e : lowlink(g, ord, low).second) {\n    cout << e.first << ' ' << e.second << '\\n';\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3428946#1\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\nclass Finding_Bridge {\nprivate:\n\tstruct node {\n\t\tint id; bool done; vi to_eid; vi to; int from_eid; int from; int pre; int low;\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint ord;\n\tvector<P> bridges_idpair;\n\tvi bridges_eid;\n\tvoid lowlink_dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tlowlink_dfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) {\n\t\t\t\t\tbridges_idpair.push_back({ a,b });\n\t\t\t\t\tbridges_eid.push_back(nodes[a].to_eid[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\npublic:\n\tFinding_Bridge(graph_t G) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { i, false,{},{}, -1, -1, -1, -1 };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].first].to_eid.push_back(i);\n\t\t\tnodes[G.edges[i].first].to.push_back(G.edges[i].second);\n\t\t}\n\t\tord = 0;\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) lowlink_dfs(i, i);\n\t\t}\n\t\tsort(bridges_idpair.begin(), bridges_idpair.end());\n\t\tsort(bridges_eid.begin(), bridges_eid.end());\n\t}\n\tvector<P> get_bridges_idpair() {\n\t\treturn bridges_idpair;\n\t}\n\tvi get_bridges_eid() {\n\t\treturn bridges_eid;\n\t}\n};\n\n// prim sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tLoop(i, G.m) {\n\t\tint s, t; cin >> s >> t;\n\t\tG.edges.push_back({ s, t });\n\t\tG.edges.push_back({ t, s });\n\t}\n\tFinding_Bridge finding_bridge(G);\n\tvector<P> bridges = finding_bridge.get_bridges_idpair();\n\tLoop(i, bridges.size()) {\n\t\tcout << bridges[i].first << \" \" << bridges[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <utility>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T = int >\nstruct Edge {\n  int from, to;\n  T cost;\n  int idx;\n\n  Edge() = default;\n\n  Edge(int from, int to, T cost = 1, int idx = -1) : from(from), to(to), cost(cost), idx(idx) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T = int >\nstruct Graph {\n  vector< vector< Edge< T > > > g;\n  int es;\n\n  Graph() = default;\n\n  explicit Graph(int n) : g(n), es(0) {}\n\n  size_t size() const {\n    return g.size();\n  }\n\n  void add_directed_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es++);\n  }\n\n  void add_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es);\n    g[to].emplace_back(to, from, cost, es++);\n  }\n\n  void read(int M, int padding = -1, bool weighted = false, bool directed = false) {\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      cin >> a >> b;\n      a += padding;\n      b += padding;\n      T c = T(1);\n      if(weighted) cin >> c;\n      if(directed) add_directed_edge(a, b, c);\n      else add_edge(a, b, c);\n    }\n  }\n};\n\n/**\n * @brief Low-Link\n * @see http://kagamiz.hatenablog.com/entry/2013/10/05/005213\n */\ntemplate< typename T = int >\nstruct LowLink : Graph< T > {\npublic:\n  using Graph< T >::Graph;\n  vector< int > ord, low, articulation;\n  vector< Edge< T > > bridge;\n  using Graph< T >::g;\n\n  virtual void build() {\n    used.assign(g.size(), 0);\n    ord.assign(g.size(), 0);\n    low.assign(g.size(), 0);\n    int k = 0;\n    for(int i = 0; i < (int) g.size(); i++) {\n      if(!used[i]) k = dfs(i, k, -1);\n    }\n  }\n\n  explicit LowLink(const Graph< T > &g) : Graph< T >(g) {}\n\nprivate:\n  vector< int > used;\n\n  int dfs(int idx, int k, int par) {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n    bool is_articulation = false, beet = false;\n    int cnt = 0;\n    for(auto &to : g[idx]) {\n      if(to == par && !exchange(beet, true)) {\n        continue;\n      }\n      if(!used[to]) {\n        ++cnt;\n        k = dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        is_articulation |= par >= 0 && low[to] >= ord[idx];\n        if(ord[idx] < low[to]) bridge.emplace_back(to);\n      } else {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n    is_articulation |= par == -1 && cnt > 1;\n    if(is_articulation) articulation.push_back(idx);\n    return k;\n  }\n};\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  LowLink<> g(V);\n  g.read(E, 0);\n  g.build();\n  auto &bridge = g.bridge;\n  for(auto &v : bridge) tie(v.from, v.to) = minmax({v.from, v.to});\n  sort(bridge.begin(), bridge.end(), [](auto &p, auto &q) { return tie(p.from, p.to) < tie(q.from, q.to); });\n  for(auto &v : bridge) cout << v.from << \" \" << v.to << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\n\nconst int mx = 100005;\n\nint dtime = 0;\nint n, m, par[mx], low[mx], start[mx];\nvector<int> adj[mx];\nbool vis[mx];\nvector<pair<int, int>> bdg;\n\nvoid dfs(int n, int p = -1) {\n  vis[n] = true;\n  par[n] = p;\n  start[n] = dtime++;\n  low[n] = start[n];\n  \n  for (int h : adj[n]) {\n    if (!vis[h]) {\n      dfs(h, n);\n      // printf(\"Low[%d] = min(%d, %d) = %d\\n\", n, low[n], low[h], min(low[n], low[h]));\n      low[n] = min(low[h], low[n]);\n      if (low[h] > low[n]) {\n\tbdg.push_back({min(n, h), max(n, h)});\n      }\n    } else if (h != p) {\n      low[n] = min(low[n], start[h]);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    adj[u].pb(v); adj[v].pb(u);\n  }\n  dfs(0);\n  sort(bdg.begin(), bdg.end());\n  for (auto p : bdg) cout << p.first << \" \" << p.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,bool> P;\nvector<P> E[100010];\nvector<int> res;\nint o[100010];\n\n\nint dfs(int i,int n) {\n    if(o[i]) {\n        o[i] = min(o[i], n);\n        return o[i];\n    }\n    o[i] = n;\n    for(vector<P>::iterator it=E[i].begin(); it != E[i].end(); it++) {\n        if(it->second) continue;\n    for(vector<P>::iterator is=E[it->first].begin(); is != E[it->first].end(); is++)\n        if(is->first == i) {\n            is->second = true;\n            break;\n        }\n        o[i] = min(o[i], dfs(it->first, n+1));\n    }\n    return o[i];\n}\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0; i<e; i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        E[s].push_back(P(t,false));\n        E[t].push_back(P(s,false));\n    }\n    for(int i=0; i<v; i++)\n        sort(E[i].begin(), E[i].end());\n\n    dfs(0,1);\n\n    for(int i=0; i<v; i++)\n        for(vector<P>::iterator it = E[i].begin(); it != E[i].end(); it++) {\n            if(i > it->first) continue;\n            if(o[i] == o[it->first]) continue;\n            printf(\"%d %d\\n\",i,it->first);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\n\nint n, m;\nvector<vector<int>> g(1000000 + 6);\n\nint ord[1000000 + 6], low[1000000 + 6];\nbool visited[1000000 + 6];\n\nvector<pair<int, int>> Bridges;\nvector<int> Points;\n\nvoid dfs(int now, int par, int &cnt) {\n    visited[now] = true;\n    ord[now] = cnt++;\n    low[now] = ord[now];\n    for (auto nx : g[now]) {\n        if (!visited[nx]) {\n            dfs(nx, now, cnt);\n            low[now] = min(low[now], low[nx]);\n        }\n        else if (nx != par) {\n            low[now] = min(low[now], ord[nx]);\n        }\n        //???????????????\n        if (ord[now] < low[nx]) {\n            Bridges.push_back({min(now, nx), max(now, nx)});\n        }\n    }\n    //??¢??????????????????\n    if (par == -1) {\n        if (g[now].size() >= 2) Points.push_back(now);\n    }\n    else if (ord[par] <= low[now]) {\n        Points.push_back(par);\n    }\n    return;\n}\n\nvoid lowlink (int n, vector<vector<int>>& g) {\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, -1, cnt);\n        }\n    }\n    sort(all(Bridges));\n    sort(all(Points));\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    lowlink(n, g);\n    rep(i, Bridges.size()) {\n        cout << Bridges[i].fi << \" \" << Bridges[i].se << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph =  vector< vector<Edge> >;\n\nvoid add_edge(Graph& graph, int u, int v, int cost = 0){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\nint lowlink(int u, int p, int& num, Graph& G, VI& ord, VI& low){\n  int res = 0;\n  ord[u] = low[u] = num++;\n  \n  for(auto& e: G[u]){\n\tint to = e.to;\n\tif(to == p) continue;\n\tif(ord[to] < 0){\n\t  res += lowlink(to, u, num, G, ord, low);\n\t  low[u] = min(low[u], low[to]);\n\t  if(ord[u] < low[to])\n\t\t++res;\n\t}\n\telse{\n\t  low[u] = min(low[u], ord[to]);\n\t}\n  }\n\n  return res;\n}\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  REP(i,E){\n\tint s, t;\n\tcin >> s >> t;\n\tadd_edge(G, s, t);\n  }\n\n  int num = 0;\n  VI ord(V,-1), low(V);\n  lowlink(0, -1, num, G, ord, low);\n\n  vector<PII> ans;\n  REP(i,V)\n\tfor(auto& e: G[i])\n\t  if(ord[i] < ord[e.to] && ord[i] < low[e.to])\n\t\tans.EB(min(i,e.to), max(i,e.to));\n  SORT(ans);\n  for(auto&& e: ans)\n\tcout << e.FF << \" \" << e.SS << endl;  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<int>E[100000];\nint s[100000],t[100000];\nint ord[100000],low[100000],k;\nbool used[100000];\nvector<P>V;\n\nvoid dfs(int v,int p){\n\tused[v]=true;\n\tlow[v]=ord[v]=k++;\n\tfor(auto u:E[v]){\n\t\tif(!used[u]){\n\t\t\tdfs(u,v);\n\t\t\tlow[v]=min(low[v],low[u]);\n\t\t\tif(ord[v]<low[u])V.push_back(P(min(u,v),max(u,v)));\n\t\t}\n\t\telse if(p!=u){\n\t\t\tlow[v]=min(low[v],ord[u]);\n\t\t}\n\t}\n}\nint main(){\n\tint v,e;scanf(\"%d%d\",&v,&e);\n\trep(i,e){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);\n\t\tE[s[i]].push_back(t[i]);\n\t\tE[t[i]].push_back(s[i]);\n\t}\n\tdfs(0,-1);\n\tsort(V.begin(),V.end());\n\tfor(auto p:V){\n\t\tcout<<p.first<<' '<<p.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX_N=1e5+10;\nvector<int>adj[MAX_N];\npair<int,int>ans[MAX_N];\nlong long int from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N],rt;\nbool vis[MAX_N];\nvoid dfs(int v,int de,int p)\n{\n    depth[v]=de;\n    vis[v]=1;\n    for(int e:adj[v])\n    {\n        int u=from[e]^to[e]^v;\n        if(e==p)\n        {\n            continue;\n        }\n        if(vis[u])\n        {\n            dp[v]=min(dp[v],depth[u]);\n        }\n        else\n        {\n            dfs(u,de+1,e);\n            dp[v]=min(dp[u],dp[v]);\n        }\n    }\n    if(dp[v]>=de&&p!=-1)\n    {\n        ans[rt]={min(from[p],to[p]),max(from[p],to[p])};\n        rt++;\n    }\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    for(long long int i=0;i<=MAX_N;i++)\n    {\n        dp[i]=99999999;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        cin>>from[i]>>to[i];\n        adj[from[i]].push_back(i);\n        adj[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans,ans+rt);\n    for(int i=0;i<rt;i++)\n    {\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct edge{\n    int f, t;\n};\n\nconst int V_MAX = (int)1e5;\nconst int E_MAX = (int)1e5;\nvector<int> edges[V_MAX];\nint ord[V_MAX];\nint low[V_MAX];\nbool used_v[V_MAX], used_e[V_MAX][V_MAX];\nvector<edge> ans;\n\nbool comp(edge e1, edge e2){\n    if(e1.f == e2.f){\n        return e1.t < e2.t;\n    } else {\n        return e1.f < e2.f;\n    }\n}\n\nvoid dfs(int u, int k){\n    low[u] = ord[u] = k;\n    k += 1;\n    used_v[u] = true;\n\n    for(int i=0; i<edges[u].size(); i++){\n        int next = edges[u][i];\n\n        if(not used_v[next]){\n            used_e[u][next] = used_e[next][u] = true;\n            dfs(next, k);\n            low[u] = min(low[u], low[next]);\n\n            if(low[next] > ord[u]){\n                edge e;\n                e.f = min(u, next); e.t = max(u, next);\n                ans.push_back(e);\n            }\n        } else if(not used_e[u][next]){\n            low[u] = min(low[u], ord[next]);\n\n        }\n    }\n    return ;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int v, e; \n    cin >> v >> e;\n\n    for(int i=0; i<e; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    dfs(0, 1);\n\n    sort(ans.begin(), ans.end(), comp);\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i].f << \" \" << ans[i].t << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N],ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back(l);\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        from[i]=a,to[i]=b;\n        vec[a].push_back(i);\n        vec[b].push_back(i);\n    }\n    dfs(0,0,-1);\n    for(int i=ans.size()-1;i>=0;i--){\n        int u=ans[i];\n        cout<<from[u]<<\" \"<<to[u]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, char, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nconst ll mod = 1000000007;\n\nstatic const ll INF = 1e15;\n\ntypedef ll Weight;\nstruct Edge {\n\tint from, to;\n\tWeight weight;\n\tEdge(int src, int dst) :\n\t\tfrom(src), to(dst), weight(0) { }\n\n\tEdge(int src, int dst, Weight weight) :\n\t\tfrom(src), to(dst), weight(weight) { }\n};\nbool operator < (const Edge& e, const Edge& f) {\n\treturn e.weight != f.weight ? e.weight > f.weight :\n\te.from != f.from ? e.from < f.from : e.to < f.to;\n}\n\nstruct UndirectionalCompare {\n\tbool operator() (const Edge& e, const Edge& f) const {\n\t\tif (min(e.from, e.to) != min(f.from, f.to))\n\t\t\treturn min(e.from, e.to) < min(f.from, f.to);\n\t\treturn max(e.from, e.to) < max(f.from, f.to);\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\ntypedef set<Edge, UndirectionalCompare> Edgeset;\n\nstruct bridge_solver {\n\n\tvoid visit(const Graph& g, int v, int u,\n\t\tEdges& brdg, vector< vector<int> >& tecomp,\n\t\tstack<int>& roots, stack<int>& S, vector<bool>& inS,\n\t\tvector<int>& num, int& time) {\n\t\tnum[v] = ++time;\n\t\tS.push(v); inS[v] = true;\n\t\troots.push(v);\n\t\tfor(const auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (num[w] == 0)\n\t\t\t\tvisit(g, w, v, brdg, tecomp, roots, S, inS, num, time);\n\t\t\telse if (u != w && inS[w])\n\t\t\t\twhile (num[roots.top()] > num[w]) roots.pop();\n\t\t}\n\t\tif (v == roots.top()) {\n\t\t\tbrdg.push_back(Edge(u, v));\n\t\t\ttecomp.push_back(vector<int>());\n\t\t\twhile (1) {\n\t\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\t\ttecomp.back().push_back(w);\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\troots.pop();\n\t\t}\n\t}\n\tvoid bridge(const Graph& g, Edges& brdg, vector< vector<int> >& tecomp) {\n\t\tconst int n = g.size();\n\t\tvector<int> num(n);\n\t\tvector<bool> inS(n);\n\t\tstack<int> roots, S;\n\t\tint time = 0;\n\t\trep(u, n) if (num[u] == 0) {\n\t\t\tvisit(g, u, n, brdg, tecomp, roots, S, inS, num, time);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tint v, e;\n\tcin >> v >> e;\n\n\tGraph g(v);\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back({s,t,0});\n\t\tg[t].push_back({t,s,0});\n\t}\n\tbridge_solver solver;\n\tEdges edge;\n\tvector<vector<int>> temp;\n\tsolver.bridge(g, edge, temp);\n\tset<Edge> se;\n\tfor (auto element : edge) {\n\t\tif (element.from < element.to) {\n\t\t\tse.emplace(element);\n\t\t}\n\t\telse {\n\t\t\tse.emplace(element.to, element.from);\n\t\t}\n\t}\n\n\tfor (auto i : se) {\n\t\tcout << i.from << \" \" << i.to << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nstruct Graph\n{\n    Graph(const int v)\n        : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        rev_edge[to].push_back(from);\n    }\n    const int V;\n    vector<vector<int>> edge;\n    vector<vector<int>> rev_edge;\n};\n\n\n\nclass BiconnectedComponent\n{\npublic:\n    // g: 無向グラフ\n    BiconnectedComponent(const Graph& g_) : size{g_.V}, ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        auto brec = [&](auto&& self, const int s, const int par) -> void {\n            ord[s] = low[s] = num,\n            num++;\n            for (const int to : g_.edge[s]) {\n                if (to == par) { continue; }\n                if (ord[to] >= 0) {\n                    low[s] = min(low[s], ord[to]);\n                } else {\n                    self(self, to, s);\n                    low[s] = min(low[s], low[to]);\n                }\n                if (isBridge(s, to)) { bridge.push_back({s, to}); }\n            }\n        };\n        auto crec = [&](auto&& self, const int s) -> void {\n            comp[s] = comp_num;\n            for (const int to : g_.edge[s]) {\n                if (comp[to] >= 0 or isBridge(s, to)) { continue; }\n                self(self, to);\n            }\n        };\n        for (int i = 0; i < size; i++) {\n            if (ord[i] >= 0) { continue; }\n            brec(brec,i, -1);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) { continue; }\n            crec(crec,i);\n            comp_num++;\n        }\n    }\n\n    Graph toTree() const\n    {\n        Graph tree(comp_num);\n        for (const auto& p : bridge) {\n            tree.addEdge(comp[p.first], comp[p.second]);\n            tree.addEdge(comp[p.second], comp[p.first]);\n        }\n        return tree;\n    }\n    const vector<pair<int, int>>& getEdge() const { return bridge; }\n    bool isBridge(const int i, const int j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const vector<int>& getComp() const { return comp; }\n    const vector<pair<int, int>>& getBridge() const { return bridge; }\n\nprivate:\n    int num = 0;\n    int comp_num = 0;\n    vector<pair<int, int>> bridge;\n    const int size;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\n\n// Problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n// Status: Accepted\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    using P = pair<int, int>;\n    vector<P> edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        if (s > t) { swap(s, t); }\n        g.addEdge(s, t);\n        g.addEdge(t, s);\n        edge.push_back(make_pair(s, t));\n    }\n\n    BiconnectedComponent bic(g);\n    vector<P> b = bic.getBridge();\n    for (auto& p : b) {\n        if (p.first > p.second) { swap(p.first, p.second); }\n    }\n    sort(b.begin(), b.end());\n    for (const auto& p : b) { cout << p.first << \" \" << p.second << endl; }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct edge{int to, index;};\nstatic const int MAX_V = 100000;\nstatic const int MAX_E = 100000;\n\nint V, E;\nvector<edge> G[MAX_V];\nbool visited[MAX_V], passed[MAX_E];\nint ord[MAX_V], low[MAX_V];\n\nvoid dfs(int u, int k){\n\tvisited[u] = true;\n\tord[u] = k;\n\tk++;\n\tlow[u] = ord[u];\n\tfor(int i = 0; i < G[u].size(); i++){\n\t\tif(!visited[G[u][i].to]){\n\t\t\tpassed[G[u][i].index] = true;\n\t\t\tdfs(G[u][i].to, k);\n\t\t\tlow[u] = min(low[u], low[G[u][i].to]);\n\t\t}else if(!passed[G[u][i].index]){\n\t\t\tlow[u] = min(low[u], ord[G[u][i].to]);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\", &V, &E);\n\tfor(int i = 0; i < E; i++){\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back((edge){t, i});\n\t\tG[t].push_back((edge){s, i});\n\t}\n\tfill(visited, visited + V, false);\n\tfill(passed, passed + E, false);\n\tdfs(0, 0);\n\tvector<pair<int, int> > res;\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(!passed[G[i][j].index]) continue;\n\t\t\tif(ord[G[i][j].to] < ord[i]) continue;\n\t\t\tif(ord[i] < low[G[i][j].to]){\n\t\t\t\tres.push_back(make_pair(min(i, G[i][j].to), max(i, G[i][j].to)));\n\t\t\t}\n\t\t}\n\t}\n\tsort(res.begin(), res.end());\n\tfor(int i = 0; i < res.size(); i++) printf(\"%d %d\\n\", res[i].first, res[i].second);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n//関節点:  O(V + E)\nclass Articulation{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;           //ord[i] := ノードiに訪れた順番\n  vector<int> low;           //low[i] := ノードiから訪れることができる最小のord[j]の値。\n  vector<int> articulation;\n  int ok;\n\n  Articulation():V(-1),ok(false){};\n  Articulation(int V):V(V),G(V),ord(V),low(V),articulation(V),ok(false){};\n  \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a < V && b < V);\n    assert(a >=0 && b >= 0);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void build(int start = 0){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    articulation.clear(); articulation.resize(V,0);\n\n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) {\n        if(to == pre) continue; \n        if(ord[to] != -1) low[pos] = min(low[pos], ord[to]);\n        else {\n          low[pos] = min(low[pos], dfs(to, pos));\n          \n          if(pos == start) articulation[pos]++;\n          else articulation[pos] |= ord[pos] <= low[to];\n        }\n      }\n      if(pos == start) articulation[pos] = articulation[pos] >= 2;\n      return low[pos];\n    };\n    dfs(start , -1);\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n  \n  int isArticulation(int a){\n    assert(ok);\n    assert(a >= 0 && a < V);\n    return articulation[a];\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int V, E;\n  cin>>V>>E;\n  \n  Articulation A(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    A.add_edge(a,b);\n  }\n  \n  A.build();\n\n    vector<P> ans;\n    for(int i=0;i<V;i++)\n      for(int to:A.G[i]) if(i < to && A.isBridge(i, to)) ans.push_back(P(i, to));\n    \n    sort(ans.begin(),ans.end());\n    for(auto a:ans) cout<<a.first<<\" \"<<a.second<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//In His Name\n#include<bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int> >e;\nvector<int>adj[100100];\nint n,m,minlvl[100100],lvl[100100];\nbool mark[100100];\nvoid dfs(int x,int par){\n\tmark[x]=true;\n\tminlvl[x]=lvl[x];\n\tfor(int i=0;i<adj[x].size();i++){\n\t\tint v=adj[x][i];\n\t\tif(!mark[v]){\n\t\t\tlvl[v]=lvl[x]+1;\n\t\t\tdfs(v,x);\n\t\t\tminlvl[x]=min(minlvl[x],minlvl[v]);\n\t\t}\n\t\telse if(v!=par) minlvl[x]=min(minlvl[x],minlvl[v]);\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(x>y) swap(x,y);\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t\te.push_back(make_pair(x,y));\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(!mark[i]) dfs(i,i);\n\tsort(e.begin(),e.end());\n\tfor(int i=0;i<m;i++){\n\t\tint x=e[i].first,y=e[i].second;\n\t\tif(lvl[x]<lvl[y]) swap(x,y);\n\t\tif(minlvl[x]>lvl[y]) cout<<e[i].first<<\" \"<<e[i].second<<endl;\n\t}\n\treturn -0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,s,t,A[N],used[N],depth[N];\nvector<int> G[N];\nvector<P> ans;\n\nvoid dfs(int x,int d,int prev){\n  depth[x]=d;\n  for(int i=0;i<G[x].size();i++){\n    int nx=G[x][i];\n    if(nx==prev)continue;\n    if(!used[nx]){\n      used[nx]=true;\n      dfs(nx,d+1,x);\n      if(!A[nx])\n\tans.push_back(P(min(x,nx),max(x,nx)));\n      A[x]+=A[nx];\n    }\n    else if(d>depth[nx]){\n      A[nx]--;\n      A[x]++;\n    }    \n  }\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  used[0]=1;\n  dfs(0,0,0);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i].first<<' '<<ans[i].second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nclass Edge{\npublic:\n  int from, to, rev;\n  Int cost, lim;\n  Edge(int from, int to, Int cost, int lim = -1, Int rev = -1):\n    from(from),to(to),cost(cost),lim(lim),rev(rev){}\n};\n\n\nclass Graph{\npublic:\n  int n;\n  int m;\n  vector<vector<Edge>> edge;\n  Graph(int n = 0):n(n),m(0){\n    edge = vector<vector<Edge>>(n);\n  }\n  void add_edge(int from, int to, int cost = 1, int lim = -1)\n  {\n    if(lim == -1){\n      edge[from].push_back(Edge(from, to, cost));\n      return;\n    }\n    edge[from].push_back(Edge(from, to, cost, lim, edge[to].size()));\n    edge[to].push_back(Edge(to, from, -cost, 0, edge[from].size() - 1));\n  }\n};\n\nint n, m, s, t;\nGraph g;\nvector<int> come(108000);\nvector<int> ongo(108000);\nvector<int> cnt(108000);\nvector<P> ans;\nvoid dfs(int x, int last = - 1){\n  come[x] = true;\n  ongo[x] = true;\n  for(auto e:g.edge[x]){\n    if(e.to == last)continue;\n    if(ongo[e.to]){\n      cnt[x]++;\n      cnt[e.to]--;\n    }\n    if(!come[e.to]){\n      dfs(e.to, x);\n      cnt[x] += cnt[e.to];\n    }\n  }\n  ongo[x] = false;\n  if(last != -1 && cnt[x] == 0){\n    ans.push_back(P(min(x, last), max(x, last)));\n  }\n}\n\nint main(){\n  cin >> n >> m;\n  g = Graph(n);\n  for(int i = 0;i < m;i++){\n    cin >> s >> t;\n    g.add_edge(s, t);\n    g.add_edge(t, s);\n  }\n  dfs(0);\n  sort(ans.begin(), ans.end());\n  for(auto p:ans)cout << p.first << \" \" << p.second << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n#define endl \"\\n\"\n\ntemplate<typename T>\nstruct LowLink {\nprivate:\n    const vector<vector<T>> &g;\n    vector<int> used, ord, low;\n    \n    int dfs(int idx, int k, int par) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_articulation = false;\n        int cnt = 0;\n        for(auto &to : g[idx]) {\n            if (!used[to]) {\n                ++cnt;\n                k = dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_articulation |= ~par && low[to] >= ord[idx];\n                if (ord[idx] < low[to]) bridge.emplace_back(minmax(idx, (int)to));\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if (is_articulation) articulation.push_back(idx);\n        return k;\n    }\n    \npublic:\n    vector<int> articulation;\n    vector<pair<int, int>> bridge;\n    \n    LowLink(const vector<vector<T>> &g) : g(g) {}\n    \n    void build() {\n        used.assign(g.size(), 0);\n        ord.assign(g.size(), 0);\n        low.assign(g.size(), 0);\n        int k = 0;\n        for(int i = 0; i < g.size(); i++) {\n            if (!used[i]) k = dfs(i, k, -1);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    ll v, e;\n    cin >> v >> e;\n    vector<vector<ll>> g(v);\n    rep(i, e) {\n        ll a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    LowLink<ll> link(g);\n    link.build();\n    vector<pair<int, int>> ans = link.bridge;\n    sort(all(ans));\n    for(auto x : ans) printf(\"%d %d\\n\", x.first, x.second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d, vector<int> &depth, vector<int> &lowlink, vector<bool> &visited){\n    visited[u] = true;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1, depth, lowlink, visited);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    for(int i=0; i<V; i++)\n        sort(G[i].begin(), G[i].end());\n    \n    vector<int> depth(V, -1), lowlink(V, -1);\n    vector<bool> visited(V, false);\n    dfs(G, -1, 0, 0, depth, lowlink, visited);\n    \n    for(int s=0; s<V; s++){\n        for(auto t: G[s]) if(s<t && (depth[s]<lowlink[t]||depth[t]<lowlink[s])){\n            cout << s << \" \" << t << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nvector<int> v[101010],art;\nvector <pint> bridge;\nint low[101010],ord[101010];\n\nvoid dfs(int& count,int from,int x){\n    ord[x]=count++;\n    low[x]=ord[x];\n    bool isart=false;\n    int cnt=0;\n    for(auto to:v[x]){\n        if(to==from)continue;\n        if(ord[to]==-1){\n            cnt++;\n            dfs(count,x,to);\n            if(ord[x]<low[to])bridge.push_back({min(x,to),max(to,x)});\n            if(from!=-1&&ord[x]<=low[to])isart=true;\n            low[x]=min(low[x],low[to]);\n        }\n        else low[x]=min(low[x],ord[to]);\n    }\n    if(from==-1&&cnt>1)isart=true;\n    if(isart)art.push_back(x);\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    rep(i,m){\n        int s,t;\n        cin>>s>>t;\n        v[s].push_back(t);\n        v[t].push_back(s);\n    }\n    rep(i,n)ord[i]=low[i]=-1;\n    int count=0;\n    dfs(count,-1,0);\n    sort(bridge.begin(),bridge.end());\n    rep(i,bridge.size()){\n        cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  search_bridges\n//\n//  Created by ???????????? ???????´???°?????? on 26.06.15.\n//  Copyright (c) 2015 company. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid is_bridge(const std::vector<std::vector<int> > &graph, std::vector<std::pair<int, int> >& bridges, const int v, const int u) {\n    //    if (std::count(graph[v].begin(), graph[v].end(), u) == 1) {\n    if (v < u) bridges.push_back(std::make_pair(v, u));\n    else bridges.push_back(std::make_pair(u, v));\n    //    }\n}\n\nvoid DFS(const std::vector<std::vector<int> > &graph, std::vector<bool> &used, std::vector<int> &tin, std::vector<int> &fup,\n         std::vector<std::pair<int, int> > &bridges, int timer, int v, int parent = -1) {\n    \n//    std::copy(graph[v].begin(), graph[v].end(), std::ostream_iterator<size_t>(std::cout, \" \")); std::cout << '\\n';\n    \n    used[v] = true;\n    tin[v] = fup[v] = timer++;\n    for (int i = 0; i < graph[v].size(); ++i) {\n        int to = graph[v][i];\n        if (to == parent) continue;\n        if (used[to]) {\n            fup[v] = std::min(fup[v], tin[to]);\n        }\n        else {\n            DFS(graph, used, tin, fup, bridges, timer, to, v);\n            fup[v] = std::min(fup[v], fup[to]);\n            if (fup[to] > tin[v]) {\n                is_bridge(graph, bridges, v, to);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    std::cin >> N >> M;\n    \n    std::vector<std::vector<int> > graph (N);\n    for (size_t i = 0; i < M; ++i) {\n        int from, to;\n        std::cin >> from >> to;\n        graph[from].push_back(to);\n        graph[to].push_back(from);\n    }\n    \n    std::vector<bool> used (N);\n    std::fill(used.begin(), used.end(), false);\n    \n    std::vector<int> tin (N), fup (N);\n    std::vector<std::pair<int, int> > bridges;\n    int timer = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        if (!used[i]) {\n            DFS(graph, used, tin, fup, bridges, timer, i);\n        }\n    }\n    std::sort(bridges.begin(), bridges.end());\n    \n    for (auto& edge: bridges) {\n        std::cout << edge.first << ' ' << edge.second << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n    int s;\n    int t;\n    bool operator < (const Edge& tgt) const {\n\tif( s == tgt.s )\n\t    return t < tgt.t;\n\treturn s < tgt.s;\n    }\n};\n\n\n\nint Bridges_dfs(const vector<vector<Edge>>& g, vector<int>& order,\n\t\tvector<Edge>& ans, int u, int& cnt_v, Edge pre) {\n\n    if( order[u] != -1 ) { //?¨????????????¨?????????\n\treturn order[u];\n    }\n    // ??????????¨???????\n    order[u] = cnt_v; cnt_v++;\n    // ??£??\\???????????????\n    int min_v = order[u];\n    for(auto& e : g[u]) {\n\tif( e.t == pre.s and e.s == pre.t ) continue;\n\tmin_v = min(Bridges_dfs(g, order, ans, e.t, cnt_v, e), min_v);\n    }\n    if( min_v == order[u] and u != 0 ) {\n\tans.push_back(pre);\n    }\n}\n\nvector<Edge> Bridges(const vector<vector<Edge>>& g) {\n    vector<Edge> ans;\n    const int V = g.size();\n    vector<int> order(V,-1);\n    \n    // 0??????DFS\n    int cnt_v = 0;\n    Edge tmp{-1,-1};\n    Bridges_dfs(g, order, ans, 0, cnt_v, tmp);\n    assert(cnt_v == V); // ??£???????????°?????????????????????\n    return ans;\n}\n\nint main () {\n    int V,E;\n    cin >> V >> E;\n    vector<vector<Edge>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t; \n\tg[s].push_back(Edge{s,t});\n\tg[t].push_back(Edge{t,s});\n    }\n    vector<Edge> ans = Bridges(g);\n    sort(ans.begin(), ans.end());\n    for(auto& e : ans) {\n\tcout << e.s << \" \"<< e.t << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define MAX_N 77777\nvector<int>X[MAX_N];\nint used[MAX_N];\nint N, M, A, B; queue<int>Q;\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> A >> B; X[A].push_back(B);\n\t\tX[B].push_back(A);\n\t}\n\tif (N == 1) { return 0; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < X[i].size(); j++) {\n\t\t\tint a1 = i, a2 = X[i][j];\n\t\t\tfor (int k = 0; k < N; k++) { used[i] = 0; }\n\t\t\tused[0] = 1; Q.push(0); int cnt = 1;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint to = Q.front(); Q.pop();\n\t\t\t\tfor (int k = 0; k < X[to].size(); k++) {\n\t\t\t\t\tif (used[X[to][k]] == 0) {\n\t\t\t\t\t\tused[X[to][k]] = 1; Q.push(X[to][k]); cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt != N && a1 < a2) { cout << a1 << ' ' << a2 << endl; }\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing UnweightedGraph = vector<vector<int>>;\nstruct LowLink {\n    const UnweightedGraph &g;\n    vector<int> aps;                // articulation points\n    vector<pair<int, int>> brs;     // brides\n    vector<int> seen, ord, low;\n    LowLink(const UnweightedGraph &g) : g(g) { }\n    int dfs(int u, int p = -1, int time = 0) {\n        seen[u] = true;\n        ord[u] = low[u] = time++;\n        bool exists = false;\n        int cnt_ch = 0;\n        for (auto v : g[u]) {\n            if (!seen[v]) {\n                ++cnt_ch;\n                time = dfs(v, u, time);\n                low[u] = min(low[u], low[v]);   // forward edge\n                if (ord[u] < low[v]) brs.emplace_back(u, v);\n                if (ord[u] <= low[v]) exists = true;\n            } else if (v != p) {\n                low[u] = min(low[u], ord[v]);   // back edge\n            }\n        }\n        if ((p == -1 && cnt_ch > 1) || (p != -1 && exists)) {\n            aps.emplace_back(u);\n        }\n        return time;\n    }\n    void build() {\n        int N = g.size();\n        seen.assign(N, 0); ord.resize(N); low.resize(N);\n        aps.clear(); brs.clear();\n        for (int v = 0; v < N; ++v) if (!seen[v]) dfs(v);\n        for (auto &br: brs) if (br.first > br.second) swap(br.first, br.second);\n        sort(brs.begin(), brs.end());\n        sort(aps.begin(), aps.end());\n    }\n};\n\nint main() {\n    int V, E; cin >> V >> E;\n    UnweightedGraph g(V);\n    while (E--) {\n        int s, t; cin >> s >> t;\n        g[s].emplace_back(t);\n        g[t].emplace_back(s);\n    }\n    LowLink ll(g);\n    ll.build();\n    //for (auto v: ll.aps) cout << v << endl;\n    for (auto b: ll.brs) cout << b.first << \" \" << b.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_3_A\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return std::cout << \"\\n\", 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v);\n        if (bi) { es[v].emplace_back(v, u); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c);\n        if (bi) { es[v].emplace_back(v, u, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\ntemplate<typename Edge = edge<>>\nclass lowlink_manager\n{\nprivate:\n    using P = std::pair<usize, usize>;\n    const usize sz;\n    std::vector<P> bs;\n    std::vector<usize> ord, low, as;\n    std::vector<bool> is_a;\n    std::vector<std::vector<usize>> dfs_tree;\n\npublic:\n    lowlink_manager(const base_tree<Edge>& g) : sz(g.size()), ord(sz, sz), low(sz, sz), is_a(sz, false), dfs_tree(sz)\n    {\n        usize num = 0;\n        auto dfs  = [&](auto&& self, const usize s, const usize p) -> void {\n            ord[s] = low[s] = num++;\n            usize back      = 0;\n            for (const auto& e : g[s]) {\n                const usize to = e.to();\n                if (ord[to] == sz) {\n                    dfs_tree[s].push_back(to), self(self, to, s), low[s] = std::min(low[s], low[to]);\n                } else {\n                    if (p == to) { back++; }\n                    if (p != to or back > 1) { low[s] = std::min(low[s], ord[to]); }\n                }\n            }\n        };\n        auto dfs2 = [&](auto&& self, const usize s) -> void {\n            usize max = 0;\n            for (const usize to : dfs_tree[s]) {\n                max = std::max(max, low[to]);\n                if (this->is_bridge(s, to)) { bs.push_back(std::minmax(s, to)); }\n                self(self, to);\n            }\n            is_a[s] = ord[s] <= max and (s != 0 or dfs_tree[s].size() > 1);\n            if (is_a[s]) { as.push_back(s); }\n        };\n        for (usize i = 0; i < sz; i++) {\n            if (ord[i] != sz) { continue; }\n            dfs(dfs, i, sz), dfs2(dfs2, i);\n        }\n    }\n    bool is_art(const usize i) const { return is_a[i]; }\n    bool is_bridge(const usize i, const usize j) const { return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i]; }\n    const std::vector<P>& bridges() const { return bs; }\n    const std::vector<usize>& arts() const { return as; }\n};\nint main()\n{\n    const auto V = in<usize>();\n    const auto E = in<usize>();\n    graph g(V);\n    for (usize i = 0; i < E; i++) {\n        const usize s = in<usize>();\n        const usize t = in<usize>();\n        g.add_edge(s, t, true);\n    }\n    auto bs = lowlink_manager<edge<>>{g}.bridges();\n    std::sort(bs.begin(), bs.end());\n    for (const auto& e : bs) { outln(e); }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int> > G(V);\n\tfor(int i = 0; i < E; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvector<int> dp(V, 1 << 30), par(V), depth(V);\n\tvector<bool> vis(V, false);\n\tfunction<void(int, int)> dfs = [&](int pos, int pre) {\n\t\tpar[pos] = pre;\n\t\tvis[pos] = true;\n\t\tdp[pos] = depth[pos];\n\t\tfor(int i : G[pos]) {\n\t\t\tif(i == pre) continue;\n\t\t\tif(!vis[i]) {\n\t\t\t\tdepth[i] = depth[pos] + 1;\n\t\t\t\tdfs(i, pos);\n\t\t\t\tdp[pos] = min(dp[pos], dp[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[pos] = min(dp[pos], depth[i]);\n\t\t\t}\n\t\t}\n\t};\n\tfor(int i = 0; i < V; ++i) {\n\t\tif(!vis[i]) {\n\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\tvector<pair<int, int> > bridges;\n\tfor(int i = 0; i < V; ++i) {\n\t\tif(par[i] != -1) {\n\t\t\tif(dp[i] == depth[i]) {\n\t\t\t\tint a = i, b = par[i];\n\t\t\t\tif(a > b) swap(a, b);\n\t\t\t\tbridges.push_back(make_pair(a, b));\n\t\t\t}\n\t\t}\n\t}\n\tsort(bridges.begin(), bridges.end());\n\tfor(pair<int, int> i : bridges) {\n\t\tcout << i.first << ' ' << i.second << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nint n, m;\nvector<vector<int>> g;\nvector<bool> visited;\nvector<int> ord;\nvector<int> low;\nvector<int> parent;\nint timer = 0;\nvector<pair<int,int>> bridge;\n\nvoid dfs(int cur, int prev) {\n    ord[cur] = low[cur] = timer++;\n    visited[cur] = true;\n    for (int next : g[cur]) {\n        if (visited[next] == false) {\n            parent[next] = cur;\n            dfs(next, cur);\n            low[cur] = min(low[cur], low[next]);\n            if (ord[cur] < low[next]) {\n                if (cur < next) bridge.push_back({cur,next});\n                else bridge.push_back({next,cur});\n            }\n        } else if (next != prev) {\n            low[cur] = min(low[cur], ord[next]);\n        }\n    }\n}\n\nvoid art_points() {\n    set<int> ap;\n    timer = 1;\n    dfs(0, 1);\n    int child = 0;\n    rep(i, n) {\n        if (i == 0) continue;\n        if (parent[i] == 0) child++;\n        else if (ord[parent[i]] <= low[i]) ap.insert(parent[i]);\n    }\n    if (child > 1) ap.insert(0);\n}\n\nint main() {\n    cin >> n;\n    cin >> m;\n    g.resize(n);\n    visited.resize(n, false);\n    ord.resize(n);\n    low.resize(n);\n    parent.resize(n);\n    rep(i, m) {\n        int s, t ;\n        cin >> s;\n        cin >> t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    dfs(0,1);\n    sort(bridge.begin(), bridge.end());\n    rep(i, bridge.size()) {\n        printf(\"%d %d\\n\", bridge[i].first, bridge[i].second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * 関節点 : https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_A\n * 橋 : https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_B\n * */\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1<<29\n#define all(v) (v).begin(), (v).end()\n\nint V, E; //頂点数 辺の数\nvector<vector<int>> G(V); //頂点の隣接リスト\nvector<int> ord_pre(V, INF); //行きがけ順の記録\nvector<int> lowlink(V, INF); //lowlinkの記録\nvector<pair<int, int>> Bridges; //橋のリスト\nvector<int> ArticulationPoints; //関節点のリスト\n\nint pre = 0; //行きがけ順序\n\nvoid recdfs(int p, int u){ //p : uの親\n  ord_pre[u] = pre++; //uの番号を確定する\n  lowlink[u] = ord_pre[u];\n\n  int cnt = 0; //DFS木次数カウント\n  bool isArt = false; //関節点か否か\n\n  for(int v: G[u]){ //uから行ける頂点vについて\n    if(ord_pre[v]==INF){ //未訪問ならばuの子なので\n      cnt++;\n\n      recdfs(u, v); //uの子であるvの番号を確定させる //vのlowlinkも確定\n      lowlink[u] = min(lowlink[u], lowlink[v]);\n\n      if(ord_pre[u] < lowlink[v])Bridges.push_back({u,v}); //橋の判定してリストに入れる\n      if(p!=-1 && ord_pre[u]<=lowlink[v])isArt = true; //根以外の関節点判定\n\n    }else if( v != p ){\n      //このとき uv が後退辺\n      lowlink[u] = min(lowlink[u], ord_pre[v]);\n    }\n  }\n  if(p==-1 && cnt>1)isArt = true; //根の関節点判定\n  if(isArt)ArticulationPoints.push_back(u); //関節点だったらリストに入れる\n}\n\n\nint main(){\n  cin>>V>>E;\n  G.resize(V);\n  for(int i=0; i<E; i++){\n    int s,t;\n    cin>>s>>t; //s--;t--;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n\n  ord_pre.assign(V, INF);\n  lowlink.assign(V,INF);\n  pre = 0;\n  recdfs(-1, 0);\n\n  /* 3a\n  sort(all(ArticulationPoints));\n  for(int x: ArticulationPoints)cout<<x<<endl;\n  //*/\n\n  //* 3b\n  for(auto &x: Bridges){\n    if(x.first>x.second)swap(x.first, x.second);\n  }\n  sort(all(Bridges));\n  for(auto x: Bridges)cout<<x.first<<\" \"<<x.second<<endl;\n  //*/\n}\n"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 200002, E = 200002;\n\nvector <int> g[N], cvs;\nvector <pair<int, int>> ces;\nint up[N], h[N], from[E], to[E];\nbool mark[N];\n\nint cecvme(int v, int pare = -1) // With multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int e : g[v])\n\t\tif(e != pare)\n\t\t{\n\t\t\tint u = to[e] ^ from[e] ^ v;\n\t\t\tif(mark[u])\n\t\t\t\tup[v] = min(up[v], h[u]);\n\t\t\telse\n\t\t\t{\n\t\t\t\th[u] = h[v] + 1;\n\t\t\t\tup[v] = min(up[v], cecvme(u, e));\n\t\t\t\tif(up[u] >= h[v] && pare != -1)\n\t\t\t\t\tcvs.push_back(v);\n\t\t\t\tchildren++;\n\t\t\t}\n\t\t}\n\tif(pare != -1 && up[v] == h[v])\n\t\tces.push_back({from[pare], v}); // pare\n\tif(pare == -1 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n \nint cecv(int v, int par) // Without multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int u : g[v])\n\t{\n\t\tif(mark[u] && u != par)\n\t\t\tup[v] = min(up[v], h[u]);\n\t\tif(!mark[u])\n\t\t{\n\t\t\th[u] = h[v] + 1;\n\t\t\tup[v] = min(up[v], cecv(u, v));\n\t\t\tif(up[u] >= h[v] && h[v] > 0)\n\t\t\t\tcvs.push_back(v);\n\t\t\tchildren++;\n\t\t}\n\t}\n\tif(h[v] > 0 && up[v] == h[v])\n\t\tces.push_back({par, v});\n\tif(h[v] == 0 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n\nint main()\n{\n\th[0] = 0;\n\tint n = in(), m = in();\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u = in(), v = in();\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t\tfrom[i] = u;\n\t\tto[i] = v;\n\t}\n\tcecv(0, -1);\n\tfor(auto &e : ces)\n\t\tif(e.first > e.second)\n\t\t\tswap(e.first, e.second);\n\tsort(ces.begin(), ces.end());\n\tfor(auto e : ces)\n\t\tcout << e.first << \" \" << e.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 100000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  if (ord[s] > ord[t]) swap(s, t);\n  return ord[s] < lowlink[t];\n}\n\nvoid init_bridge() {\n  memset(vis, false, sizeof(vis));\n  timer = 1;\n  dfs(0, -1);\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    edges.push_back(make_pair(s, t));\n  }\n  sort(edges.begin(), edges.end());\n  init_bridge();\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nvector<int> E[100010];\nvector<int> res;\nint o[100010];\nvector<pair<int,int> > bridge;\n\n\nint dfs(int i,int prev,int &n) {\n    if(o[i]) return o[i];\n\n    int M=n;\n    o[i] = n++;\n    for(vector<int>::iterator it = E[i].begin(); it != E[i].end(); it++) {\n        if(prev == *it) continue;\n        if(o[i] < o[*it]) continue;\n\n        int res = dfs(*it, i, n);\n        M = min(M, res);\n\n        if(o[i] < res) bridge.push_back(pair<int,int>(min(i,*it),max(i,*it)));\n    }\n    return M;\n}\n\nint main(void) {\n\tint v,e;\n\tscanf(\"%d%d\",&v,&e);\n\tfor(int i=0; i<e; i++) {\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tE[s].push_back(t);\n\t\tE[t].push_back(s);\n\t}\n\n    int n=1;\n\tdfs(0,-1,n);\n\n    sort(bridge.begin(), bridge.end());\n\n    for(vector<pair<int,int> >::iterator it = bridge.begin(); it != bridge.end(); it++) {\n        printf(\"%d %d\\n\",it->first,it->second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define PA pair<ll,ll>\n#define FOR(I,A,B) for(ll I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(ll I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e16+7;\nconst ll MOD=1e9+7;\n\n\n//無向グラフ\n// http://kagamiz.hatenablog.com/entry/2013/10/05/005213\nstruct Articulation_point_and_Bridge{\nint V,E=0;\nvector< vector<int> > G;\nvector<int> ord,low;\nvector<bool> vis;\nvector< pair<int, int> > bridge;\nvector<int> articulation;\nArticulation_point_and_Bridge(int V_){\n\tV=V_;\n\tG.resize(V);\n\tord.resize(V,0);\n\tlow.resize(V,0);\n\tvis.resize(V,false);\n}\nvoid dfs(int v, int p, int &k){\n\tvis[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\tbool isArticulation = false;\n\tint ct = 0;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]){\n\t\t\tct++;\n\t\t\tdfs(G[v][i], v, k);\n\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\tif (~p && ord[v] <= low[G[v][i]]) isArticulation = true;\n\t\t\tif (ord[v] < low[G[v][i]]) bridge.push_back(make_pair(min(v, G[v][i]), max(v, G[v][i])));\n\t\t}\n\t\telse if (G[v][i] != p){\n\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t}\n\t}\n\t\n\tif (p == -1 && ct > 1) isArticulation = true;\n\tif (isArticulation) articulation.push_back(v);\n}\nvoid add_edge(int v1,int v2){\n\tG[v1].push_back(v2);\n\tG[v2].push_back(v1);\n\tE++;\n}\nvoid calc(){\n\tint k=0;\n\tfor(int i=0;i<V;i++){\n\t\tif(!vis[i])dfs(i,-1,k);\n\t}\n\tsort(bridge.begin(), bridge.end());\n\tsort(articulation.begin(), articulation.end());\n}\n\n};\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tArticulation_point_and_Bridge apb(n);\n\tFOR(i,0,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tapb.add_edge(a,b);\n\t}\n\tapb.calc();\n\tfor(auto x:apb.bridge){\n\t\tcout << x.first << \" \" << x.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//In His Name\n#include<bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int> >e;\nvector<int>adj[100100];\nint n,m,minlvl[100100],lvl[100100];\nbool mark[100100];\nvoid dfs(int x,int par){\n    mark[x]=true;\n    minlvl[x]=lvl[x];\n    for(int i=0;i<adj[x].size();i++){\n        int v=adj[x][i];\n        if(!mark[v]){\n            lvl[v]=lvl[x]+1;\n            dfs(v,x);\n            minlvl[x]=min(minlvl[x],minlvl[v]);\n        }\n        else if(v!=par) minlvl[x]=min(minlvl[x],minlvl[v]);\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        if(x>y) swap(x,y);\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n        e.push_back(make_pair(x,y));\n    }\n    for(int i=0;i<n;i++)\n        if(!mark[i]) dfs(i,i);\n    sort(e.begin(),e.end());\n    for(int i=0;i<m;i++){\n        int x=e[i].first,y=e[i].second;\n        if(lvl[x]<lvl[y]) swap(x,y);\n        if(minlvl[x]>lvl[y]) cout<<e[i].first<<\" \"<<e[i].second<<endl;\n    }\n    return -0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[x].pb(x+1);G2[x+1].pb(x);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));\n\t\t\t}\n\t\t\tchmax(mx, build(G[p][i], x));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G = low.G2;\n\trep(i,size){\n\t\trep(j,G[i].size()){\n\t\t\tif(i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\tZIP(ans);\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst int kMaxV = 10010;\n\nstruct Edge {\n  int u;\n  int v;\n\n  Edge(int u, int v): u(u), v(v) {}\n\n  bool operator < (const Edge& rhs) const {\n    if (u != rhs.u) {\n      return u < rhs.u;\n    } else {\n      return v < rhs.v;\n    }\n  }\n};\n\nint v, e, source = 0, dfs_clock = 0;\nvector<int> g[kMaxV];\nint pre[kMaxV] = {0};\nint low[kMaxV] = {0};\nint parent[kMaxV];\nvector<Edge> bridges;\n\nvoid DFS(int u, int father) {\n  int child_num = 0;\n  ++dfs_clock;\n  pre[u] = dfs_clock;\n  low[u] = dfs_clock;\n  for (int v: g[u]) {\n    if (!pre[v]) {\n      ++child_num;\n      parent[v] = u;\n      DFS(v, u);\n      low[u] = min(low[u], low[v]);\n      if (low[v] > pre[u]) {\n        bridges.emplace_back(min(u, v), max(u, v));\n      }\n    } else if (v != father) {\n      low[u] = min(low[u], pre[v]);\n    }\n  }\n}\n\nvoid Bridge() {\n  memset(parent, source, sizeof(parent));\n  DFS(source, -1);\n  sort(bridges.begin(), bridges.end());\n}\n\nint main() {\n  scanf(\"%d %d\", &v, &e);\n  for (int i = 0; i < e; ++i) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n\n  Bridge();\n  for (auto b: bridges) {\n    printf(\"%d %d\\n\", min(b.u, b.v), max(b.u, b.v));\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\n\nvoid visit(int cur, int prev, vector<pii> &brg, vector<vector<int>> &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n\torder[cur] = ++k;\n\tS.push(cur); inS[cur] = true;\n\troots.push(cur);\n\t\n\trep(i,G[cur].size()){\n\t\tint to = G[cur][i];\n\t\tif(order[to]==0){\n\t\t\tvisit(to,cur,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t\telse if(to!=prev && inS[to]){\t//?????????????????????\n\t\t\twhile(order[roots.top()] > order[to]) roots.pop();\t//cur???to?????§(to???????????????)????????????roots????????¨??????\n\t\t}\n\t}\n\n\tif(cur==roots.top()&&prev!=-1){\n\t\tbrg.pb(pii(prev,cur));\n\t\tvector<int> bcc;\n\t\twhile(1){\n\t\t\tint node = S.top(); S.pop(); inS[node] = false;\n\t\t\tbcc.pb(node);\n\t\t\tif(node==cur)break;\n\t\t}\n\t\teach_bcc.pb(bcc);\n\t\troots.pop();\n\t}\n}\n\n\nvoid bridge(int V, vector<pii> &brg, vector<vector<int>> &each_bcc){\n\tvector<int> order(V);\n\tvector<bool> inS(V);\n\tstack<int> roots, S;\n\tint k=0;\n\trep(i,V){\n\t\tif(order[i]==0){\n\t\t\tvisit(i,-1,brg,each_bcc,roots,S,inS,order,k);\n\t\t}\n\t}\n}\n\n\n\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tvector<pii> brg;\n\tvector<vector<int>> each_bcc;\n\t\n\tbridge(v,brg,each_bcc);\n\t\n\tvector<pii> ans;\n\n\tmap<pii,bool> mp;\n\trep(i,edges.size()){\n\t\tpii e = edges[i];\n\t\tmp[e] = true;\n\t}\n\n\trep(i,brg.size()){\n\t\tif(mp.count(brg[i])!=0)ans.pb(pii(brg[i].first,brg[i].second));\n\t\telse ans.pb(pii(brg[i].second,brg[i].first));\n\t}\n\t\n\t\n\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > low[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n      // e is bridge!\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    es.emplace_back(u, v);\n    if (u > v) swap(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()) if (bd.edge_group[i].size() == 1) {\n    bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass biconnected{\npublic:\n\tvector<vector<int> > G ,graph;\n\tvector<int> ord,low,cmp;\n\tvector<P> bridge;\n\tvector<vector<P> > check;\n\tvector<bool> visit;\n\tint V;\n\tbiconnected(int node_size){\n\t\tV = node_size;\n\t\tG.resize(V);\n\t\tcheck.resize(V),ord.resize(V),low.resize(V);\n\t\tcmp.resize(V),check.resize(V),visit.resize(V,false);\n\t}\n\tvoid build(){\n\t\tint id = 0;\n\t\trep(i,V){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(i,-1,id);\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int v,int p,int &k)\n\t{\n\t\tvisit[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\tfor(int i = 0;i < (int)G[v].size();i++){\n\t\t\tint w = G[v][i];\n\t\t\tif(!visit[w]){\n\t\t\t\tdfs(w,v,k);\n\t\t\t\tlow[v] = min(low[v],low[w]);\n\t\t\t\tif(ord[v] < low[w]){\n\t\t\t\t\tbridge.push_back(P(min(v,w),max(v,w)));\n\t                check[v][i].second = 1;\n\t                check[w][check[v][i].first].second = 1;\n\t\t\t\t}\n\t\t\t//(v,w)????????????\n\t\t\t}else if(w != p){\n\t\t\t\tlow[v] = min(low[v],ord[w]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid add_edge(int u,int v)\n\t{\n\t    G[u].push_back(v),G[v].push_back(u);\n\t    check[u].push_back(P((int)check[v].size(),0));\n\t    check[v].push_back(P((int)check[u].size()-1,0));\n\t}\n\n\tvoid restrict_dfs(int u,int p,int kind,queue<int>& que)\n\t{\n\t    visit[u] = true;\n\t    cmp[u] = kind;\n\t    rep(i,(int)G[u].size()){\n\t\t\tint w = G[u][i];\n\t        if(check[u][i].second){\n\t            if(!visit[w]){\n\t                que.push(w);\n\t            }\n\t        }else if(!visit[w]){\n\t            restrict_dfs(w,u,kind,que);\n\t        }\n\t    }\n\t}\n\t//????????°?????????\n\tint make_bcgraph()\n\t{\n\t\tgraph.resize(V);\n\t    int num = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            dfs(i,-1,num);\n\t        }\n\t    }\n\t    fill(visit.begin(),visit.end(),false);\n\t    int kind = 0;\n\t    rep(i,V){\n\t        if(!visit[i]){\n\t            queue<int> que;\n\t            que.push(i);\n\t            while(!que.empty()){\n\t                int p = que.front();\n\t                que.pop();\n\t                restrict_dfs(p,-1,kind,que);\n\t                kind++;\n\t            }\n\t        }\n\t    }\n\t    rep(i,(int)bridge.size()){\n\t        int a = cmp[bridge[i].first];\n\t        int b = cmp[bridge[i].second];\n\t        graph[a].push_back(b), graph[b].push_back(a);\n\t    }\n\t    return kind;\n\t}\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n\tbiconnected bc(n);\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tbc.add_edge(u,v);\n\t}\n\tbc.build();\n\tsort(all(bc.bridge));\n\trep(i,len(bc.bridge)){\n\t\tcout << bc.bridge[i].fi << \" \" << bc.bridge[i].se << \"\\n\";\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAX_N=1000*1000+20,INF=999999;\nint n,m;\nint dp[MAX_N],depth[MAX_N],from[MAX_N],to[MAX_N];\nbool vis[MAX_N];\nvector<int> adj[MAX_N];\nvoid dfs(int v,int de,int par){\n\tdepth[v]=de;\n\tvis[v]=1;\n\tfor(int y:adj[v]){\n\t\tint b=from[y]^to[y]^v;\n\t\tif(y==par){\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[b]){\n\t\t\tdp[v]=min(dp[v],depth[b]);\n\t\t}\n\t\telse{\n\t\t\tdfs(b,de+1,y);\n\t\t\tdp[v]=min(dp[b],dp[v]);\n\t\t}\n\t}\n\tif(dp[v]>=de &&par!=-1){\n\t\t//cout<<par+1<<endl;\n\t\tcout<<from[par]<<\" \"<<to[par]<<endl;\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<=n+10;i++){\n\t\tdp[i]=INF;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tcin>>from[i]>>to[i];\n\t\t//from[i]--;\n\t\t//to[i]--;\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tdfs(0,0,-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nvector<int> G[100010];\nbool f[100010];\nint ord[100010], low[100010];\nvector<P> bridge;\n\nvoid dfs(int v, int p, int &k){\n    ord[v] = k++;\n    low[v] = ord[v];\n    f[v] = true;\n    rep(i, 0, G[v].size()){\n        int u = G[v][i];\n        if(f[u]){\n            if(u != p) low[v] = min(low[v], ord[u]);\n        }else{\n            dfs(u, v, k);\n            if(ord[v] < low[u]) bridge. push_back(P(min(v, u), max(v, u)));\n            low[v] = min(low[v], low[u]);\n        }\n    }\n}\n\nsigned main(){\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b;\n        cin >> a >> b;\n        G[a]. push_back(b);\n        G[b]. push_back(a);\n    }\n    int k = 0;\n    dfs(0, -1, k);\n    sort(all(bridge));\n    rep(i, 0, bridge.size()){\n        cout << bridge[i].fi << \" \" << bridge[i].se << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint V,E;\nvector<int> g[100100];\nint dep[100100],low[100100],ord[100100];\nint cnt = 0;\nvoid dfs(int v,int p,int d){\n\tdep[v] = d;\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tfor(int i=0;i<g[v].size();i++){\n\t\tif(g[v][i]==p)continue;\n\t\tint ch = g[v][i];\n\t\tif(ord[ch]==-1){\n\t\t\tdfs(ch,v,d+1);\n\t\t\tlow[v] = min(low[v],low[ch]);\n\t\t}else{\n\t\t\tlow[v] = min(low[v],ord[ch]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&V,&E);\n\tvector<P> es(E);\n\tfor(int i=0;i<E;i++){\n\t\tint s,t;\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tg[s].pb(t);\n\t\tg[t].pb(s);\n\t\tes[i]=P(s,t);\n\t}\n\tmemset(ord,-1,sizeof(ord));\n\tdfs(0,-1,0);\n\tvector<P> ans;\n\tfor(int i=0;i<E;i++){\n\t\tint s = es[i].fi,t = es[i].sec;\n\t\tif(dep[s]>dep[t])swap(s,t);\n\t\tif(ord[s]<low[t])ans.pb(es[i]);\t\n\t}\n\tsort(all(ans));\n\tfor(int i=0;i<ans.size();i++)printf(\"%d %d\\n\",ans[i].fi,ans[i].sec);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define ps push\n#define fr front\ntypedef pair<int,int> pii;\n\n#define MAX_N 100000\n\nint d[MAX_N],md[MAX_N];\nvector<int> g[MAX_N];\nbool f[MAX_N];\n\nvoid dfs(int u,int v){\n\tf[v]=true;\n\tmd[v]=d[v];\n\tfor(int j=0;j<g[v].size();++j){\n\t\tint w=g[v][j];\n\t\tif(w==u) continue;\n\t\tif(f[w]) md[v]=min(md[v],d[w]);\n\t\telse{\n\t\t\tdfs(v,w);\n\t\t\tmd[v]=min(md[v],md[w]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,e;\n\tcin>>n>>e;\n\tvector<pii> es;\n\tfor(int j=0;j<e;++j){\n\t\tint v,w;\n\t\tcin>>v>>w;\n\t\tg[v].pb(w);\n\t\tg[w].pb(v);\n\t\tes.pb(mp(min(v,w),max(v,w)));\n\t}\n\tfill(d,d+n,-1);\n\td[0]=0;\n\tqueue<int> q;\n\tq.ps(0);\n\twhile(!q.empty()){\n\t\tint v=q.fr();\n\t\tq.pop();\n\t\tfor(int j=0;j<g[v].size();++j){\n\t\t\tint w=g[v][j];\n\t\t\tif(d[w]>=0) continue;\n\t\t\td[w]=d[v]+1;\n\t\t\tq.ps(w);\n\t\t}\n\t}\n\tfill(f,f+n,false);\n\tmd[0]=0;\n\tdfs(-1,0);\n\tvector<pii> ans;\n\tfor(int j=0;j<e;++j){\n\t\tint v=es[j].fi,w=es[j].sc;\n\t\tif((d[v]<d[w]&&md[v]<md[w])||(d[v]>d[w]&&md[v]>md[w])) ans.pb(es[j]);\n\t}\n\tsort(ans.begin(),ans.end());\n\tfor(int j=0;j<ans.size();++j) printf(\"%d %d\\n\",ans[j].fi,ans[j].sc);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nconst int MAX_V =100000;\nvector<int> G[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V];\nint low[MAX_V];\nvector<pii> Brides;//橋\n/*頂点u がDFS tree の根であるとき, その次数が1 より大きければ関節点である(明らかに木を(次数) 個の木に分断する.)\nそうでないとき, 頂点u のある子vについてordu≦lowvが成り立てば頂点u は関節点となる.(u を介して親の方へ進まなければならないから,u が消えるとv 以下の部分木は孤立してしまう.)*/\n/*橋 ⇔ordu<lowv となることがわかる. (これは, 後退辺で遡ってもu の訪問時刻より早い頂点に訪れることが不可能である, ということを示している.) これはlowlink を求めるDFS を行いながらO(1) 時間で判定ができるので, O(n+m) 時間で橋を列挙することができる.*/\n/*? low[u] は, uから以下の方法で辿り着ける頂点\nでの ord の最小値 \n1. DFS 木の辺を根から葉の向きへ進む (何度でも) \n2. 後退辺を葉から根の向きへ進む (1 回まで)*/\nvoid dfs(int v,int p,int &k){\n\tord[v] = k++;\n\tlow[v] =ord[v];\n\tvis[v] =true;\n\tint ct = 0;//次数\n\tfor(int i =0;i <G[v].size();i++){\n\t\tif(!vis[G[v][i]]){\n\t\t\tct++;\n\t\t\tdfs(G[v][i],v,k);\n\t\t\tlow[v] =min(low[v],low[G[v][i]]);\n\t\t\tif(ord[v] <low[G[v][i]]){\n\t\t\t\tBrides.push_back(mp(min(v,G[v][i]),max(v,G[v][i])));\n\t\t\t}\n\t\t}else if(G[v][i]!=p){//後退辺をたどる\n\t\t\tlow[v] =min(low[v],ord[G[v][i]]);\n\t\t}\n\t}\n}\nint V,E;\nint main(){\n\tcin>>V>>E;\n\tfor(int i =0;i < E;i++){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\tint k = 0;\n\tfor(int i =0;i < V;i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i,-1,k);\n\t\t}\n\t}\n\tsort(Brides.begin(),Brides.end());\n\tfor(int i =0;i < Brides.size();i++){\n\t\tcout <<Brides[i].first<<\" \"<<Brides[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nstruct Edge {\n\tint src;\n\tint dst;\n\tint id;\n};\n\n// res: bridges\n// v: current node\n// from: parent node\nint dfs2(vector<vector<Edge>>&g, vector<int>& res, int v, int& count, int from_id, vector<int>& low, vector<int>& pre) {\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (auto it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = it->dst;\n\t\tif (pre[to] == -1) {\n\t\t\t// destination has not been visited\n\t\t\t// visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs2(g, res, to, count, it->id, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t// edge is not contained in a closed path -> bridge\n\t\t\t\t//res.push_back(it->id);\n\t\t\t\tres[it->id] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from_id == it->id) {\n\t\t\t\t// ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// Calculate bridges in a undirected graph.\n// Assume graph is connected and has no parallel edges or self-loops.\n// g: adjacency list\n// V: number of nodes\nvoid  bridges(vector<vector<Edge>>&g, int V, vector<int>&res) {\n\n\tif (V > 0) {\n\t\t// assume at least the first vertex exists\n\t\tvector<int> low(V, -1);  // lowest reacheable index\n\t\tvector<int> pre(V, -1);  // pre-order index\n\t\tint count = 0;  // pre-order index counter\n\t\tdfs2(g, res, 0, count, -1, low, pre);  // start dfs from vertex 0\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<Edge>>es(V);\n\tvector<Edge>eids;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tes[s].push_back(Edge{ s,t,i });\n\t\tes[t].push_back(Edge{ t,s,i });\n\t\teids.push_back(Edge{ s,t,i });\n\t}\n\tvector<int>res(V);\n\tbridges(es, V, res);\n\tvector<Edge>bris;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (res[i])bris.push_back(eids[i]);\n\t}\n\tsort(bris.begin(), bris.end(), [=](const Edge&l, const Edge&r) {\n\t\treturn l.src == r.src ? l.dst < r.dst : l.src < r.src;\n\t});\n\tfor (int i = 0; i < bris.size(); ++i) {\n\t\tcout << bris[i].src << \" \" << bris[i].dst << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> P;\nconst int MAX_V=100000;\nvector<int> G[MAX_V];\nint ord[MAX_V];\nbool inS[MAX_V];\nstack<int> roots,S;\nvector<vi> cc;\nvector<P> bs;\nint cnt;\nint N,M;\nvoid vis(int v,int p){\n\tord[v]=++cnt;\n\tS.push(v);\n\tinS[v]=1;\n\troots.push(v);\n\tfor(int u:G[v]){\n\t\tif(ord[u]==0){\n\t\t\tvis(u,v);\n\t\t}else if(u!=p&&inS[u]){\n\t\t\twhile(ord[roots.top()]>ord[u]) roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top()){\n\t\tbs.pb(P(p,v));\n\t\tvector<int> vc;\n\t\twhile(true){\n\t\t\tint w=S.top();S.pop();\n\t\t\tinS[w]=0;\n\t\t\tvc.pb(w);\n\t\t\tif(v==w) break;\n\t\t}\n\t\troots.pop();\n\t\tcc.pb(vc);\n\t}\n}\nvoid bridge(){\n\trep(i,N) if(ord[i]==0){\n\t\tvis(i,-1);\n\t\tbs.pop_back();\n\t}\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tbridge();\n\tsort(all(bs));\n\tfor(P p:bs){\n\t\tcout<<p.fs<<\" \"<<p.sc<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 100010\n \nusing namespace std;\n \ntypedef pair<int,int> ii;\ntypedef vector<ii>   vii;\ntypedef vector<int>   vi;\nconst int DFS_WHITE = -1; // unvisited\nconst int DFS_BLACK =  1; // visited\n \nint V,E;\nint dfsNumberCounter,rootChildren,dfsRoot;\nvi dfs_num,dfs_low,dfs_parent,articulation_vertex;\nvii AdjList[MAX_V];// ii(neighbor,weight)\n \nvii ans;\n \nvoid articulationPointAndBridge(int u)\n{\n  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;\n  for(int j=0;j<(int)AdjList[u].size();j++)\n    {\n      ii v = AdjList[u][j];\n      if(dfs_num[v.first] == DFS_WHITE)\n    {\n      dfs_parent[v.first] = u;\n      if(u == dfsRoot)rootChildren++;\n \n      articulationPointAndBridge(v.first);\n \n      if(dfs_low[v.first] >= dfs_num[u])\n        articulation_vertex[u] = true;\n      if(dfs_low[v.first] >  dfs_num[u])\n        ans.push_back(ii(min(u,v.first),max(u,v.first)));\n        //printf(\"Edge (%d,%d) is a bridge\\n\",u,v.first);\n      dfs_low[u] = min(dfs_low[u],dfs_low[v.first]);\n \n    }\n      else if(v.first != dfs_parent[u])\n    dfs_low[u] = min(dfs_low[u],dfs_num[v.first]);\n    }\n}\n \nvoid compute()\n{\n  dfsNumberCounter = 0; dfs_num.assign(V,DFS_WHITE); dfs_low.assign(V,0);\n  dfs_parent.assign(V,0); articulation_vertex.assign(V,0);\n  //puts(\"Bridges:\");\n  for(int i = 0; i < V; i++)\n    if(dfs_num[i] == DFS_WHITE)\n      {\n    dfsRoot = i; rootChildren = 0;\n    articulationPointAndBridge(i);\n    articulation_vertex[dfsRoot] = (rootChildren > 1);// special case\n      }\n  //puts(\"Articulation Points\");\n  //for(int i = 0; i < V; i++)\n  //if(articulation_vertex[i])\n      //printf(\"Vertex %d\\n\",i);\n}\n \nint main()\n{\n  scanf(\"%d%d\",&V,&E);\n  rep(i,V)AdjList[i].clear();\n  rep(i,E)\n    {\n      int s,t;\n      scanf(\"%d%d\",&s,&t);\n      AdjList[s].push_back(ii(t,1));\n      AdjList[t].push_back(ii(s,1));\n    }\n \n  ans.clear();\n  compute();\n  sort(ans.begin(),ans.end());\n  ans.erase(unique(ans.begin(),ans.end()),ans.end());\n  rep(i,ans.size())cout << ans[i].first << \" \" << ans[i].second << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool usedV[MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v,int p){\t//make ord and lowlink\n\tusedV[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!usedV[to]){\n\t\t\tdfs(to,v);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(usedV[to]&&to!=p){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0,-1);\n\t\n\tvector<pii> ans;\n\t\n\trep(i,e){\n\t\tint a = edges[i].first, b = edges[i].second;\n\t\tif(ord[a]>ord[b])swap(a,b);\n\t\tif(ord[a]<lowlink[b])ans.pb(pii(edges[i].first,edges[i].second));\n\t}\n\t\n//\tsort(all(ans));\n\trep(i,ans.size())cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int MAX_N = 2e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        cout<<from[l]<<\" \"<<to[l]<<endl;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        from[i]=a,to[i]=b;\n        vec[a].push_back(i);\n        vec[b].push_back(i);\n    }\n    dfs(0,0,-1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cerr << x << \" \";} cerr << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cerr << x << \" \";}cerr << endl;}\n#define printP(p) cerr << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\n\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int>      Edge;   // (a < b: undirected)\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vi depth;\n    vi par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvi cmp;\n\tint num_cc;\n\tvi size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    void bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\trep(i, n) {\n\t\t\tint size_cc = extractCC(i, num_cc);\n\t\t\tif (size_cc > 0) {\n\t\t\t\tsize_of_vertex.emplace_back(size_cc);\n\t\t\t\tnum_cc++;\n\t\t\t}\n\t\t}\n\n\t \tvector<set<int>> G_cc_st(num_cc);\n\t\tfor (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == BRIDGE) {\n\t\t\t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t\t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n            }\n        }\n\n\t\trep(i, num_cc) {\n\t\t\tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t}\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n    BICC bicc(V);\n    rep(i, E) {\n        int a, b;\n        cin >> a >> b;\n        bicc.addEdge(a, b);\n    }\n\n    bicc.bicc();\n    auto bridges = bicc.getBridges();\n    printVP(bridges);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair <int, int> P;\n\nclass LowLink {\n    const vector<vector<int>> edge;\n    vector <bool> used;\n    vector <int> ord; // DFS木で訪れた順\n    vector <int> low; // 後退辺を1度だけ通って辿れるordの最小値\n\npublic:\n    vector <int> articulation; // 関節点\n    vector <P> bridge; // 橋\n\n    LowLink(const vector<vector<int>> &edge) : edge(edge) {}\n\n    int dfs(int cur, int k, int par) {\n        used[cur] = true;\n        ord[cur] = k++;\n        low[cur] = ord[cur];\n        bool is_articulation = false;\n        int children = 0;\n        for (int to : edge[cur]) {\n            if (!used[to]) {\n                children++;\n                k = dfs(to, k, cur);\n                low[cur] = min(low[cur], low[to]);\n                if (par >= 0) is_articulation |= low[to] >= ord[cur];\n                if (low[to] > ord[cur]) bridge.push_back({cur, to});\n            } else if (to != par) {\n                low[cur] = min(low[cur], ord[to]);\n            }\n        }\n        if (par == -1) is_articulation |= children > 1;\n        if (is_articulation) articulation.push_back(cur);\n        return k;\n    }\n\n    void build() {\n        used.assign(edge.size(), false);\n        ord.assign(edge.size(), 0);\n        low.assign(edge.size(), 0);\n        for (int i = 0; i < edge.size(); i++) {\n            if (!used[i]) dfs(i, 0, -1);\n        }\n    }\n};\n\n\n// verified\n//   http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=jp\nvoid AOJ_GRL_3_A() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> edge(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n\n    LowLink lowlink(edge);\n    lowlink.build();\n\n    sort(lowlink.articulation.begin(), lowlink.articulation.end());\n    for (int i : lowlink.articulation) cout << i << '\\n';\n}\n\n\n// verified\n//   http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\nvoid AOJ_GRL_3_B() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> edge(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        edge[t].push_back(s);\n    }\n\n    LowLink lowlink(edge);\n    lowlink.build();\n\n    vector <P> bridge = lowlink.bridge;\n    for (P &p : bridge) {\n        if (p.first > p.second) swap(p.first, p.second);\n    }\n\n    sort(bridge.begin(), bridge.end());\n    for (P p : bridge) cout << p.first << \" \" << p.second << '\\n';\n}\n\nint main() {\n    // AOJ_GRL_3_A();\n    AOJ_GRL_3_B();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ライブラリにするほどか？\n//橋\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100001\nvector<int> G[MAX_N];\nvector<pair<int,int> > ans;\nint cnt[MAX_N],dep[MAX_N];\n\nvoid dfs(int pos,int pre){\n    for(int i = 0; i < G[pos].size(); i++){\n        int nx = G[pos][i];\n        if (nx == pre || dep[nx] > dep[pos]) continue;\n        \n        if (dep[nx] != -1 && dep[nx] < dep[pos]){\n            cnt[nx]--;\n            cnt[pos]++;\n        } else {\n            dep[nx] = dep[pos] + 1;\n            dfs(nx,pos);\n            if (cnt[nx] == 0){\n                ans.push_back({min(pos,nx),max(pos,nx)});\n            }\n            cnt[pos] += cnt[nx];\n        }\n    }\n}\n\n\nint main(){\n    int n,m; cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int a,b; cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    memset(dep,-1,sizeof(dep));\n    dep[0] = 0;\n    dfs(0,-1);\n    sort(ans.begin(),ans.end());\n    for(int i = 0; i < ans.size(); i++){\n        cout << ans[i].first << \" \" << ans[i].second << endl;\n    }\n    //return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int MAX_N=1000*1000+20,INF=999999;\nint n,m;\nint dp[MAX_N],depth[MAX_N],from[MAX_N],to[MAX_N];\nbool vis[MAX_N];\nvector<int> adj[MAX_N],ans;\nvoid dfs(int v,int de,int par){\n\tdepth[v]=de;\n\tvis[v]=1;\n\tfor(int y:adj[v]){\n\t\tint b=from[y]^to[y]^v;\n\t\tif(y==par){\n\t\t\tcontinue;\n\t\t}\n\t\tif(vis[b]){\n\t\t\tdp[v]=min(dp[v],depth[b]);\n\t\t}\n\t\telse{\n\t\t\tdfs(b,de+1,y);\n\t\t\tdp[v]=min(dp[b],dp[v]);\n\t\t}\n\t}\n\tif(dp[v]>=de &&par!=-1){\n\t\t//cout<<par+1<<endl;\n\t\t//cout<<from[par]<<\" \"<<to[par]<<endl;\n\t\tans.push_back(par);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<=n+10;i++){\n\t\tdp[i]=INF;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tcin>>from[i]>>to[i];\n\t\t//from[i]--;\n\t\t//to[i]--;\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tdfs(0,0,-1);\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& p) {\n    return os << p.first << \" \" << p.second;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nvector<vector<ll>> G;\nvector<bool> used;\nvector<ll> order;\nll next_order = 0;\nvector<P> ans;\n\nvoid add_ans(ll a, ll b) {\n    if (a > b) swap(a, b);\n    ans.pb({a, b});\n}\nll dfs(ll v, ll prev) {\n    ll res = order[v] = next_order++;\n    EACH(to, G[v]) {\n        if (to == prev) continue;\n        if (order[to] >= 0) {\n            res = min(res, order[to]);\n        }\n        else {\n            ll low = dfs(to, v);\n            if (low > order[v]) add_ans(v, to);\n            res = min(res, low);\n        }\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m; cin >> n >> m;\n    vector<ll> g(n);\n    G.resize(n);\n    REP(i, m) {\n        ll a, b; cin >> a >> b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    order.assign(n, -1);\n    dfs(0, -1);\n    sort(ALL(ans));\n    EACH(p, ans) {\n        cout << p << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\n\nint ord[100001],low[100001];\nvector<int> G[100001];\nstruct edge{int u,v;};\nvoid dfs(int u, int pre, int c, vector<int> G[], vector<edge> &B){\n  ord[u] = low[u] = c++;\n  for(int i=0;i<G[u].size();i++){\n    int v = G[u][i];\n    if(v != pre){\n      if(ord[v] == -1){\n        dfs(v,u,c,G,B);\n        low[u] = min(low[u],low[v]);\n      } else low[u] = min(low[u],ord[v]);\n      if(ord[u] < low[v]) B.push_back((edge){u,v});\n    }\n  }\n}\n\nvoid bridge(int n, vector<int> G[], vector<edge> &B){\n  B.clear();\n  int c = 0;\n  fill(ord,ord+n,-1);\n  for(int i=0;i<n;i++) if(ord[i]==-1) dfs(i,-1,c,G,B);\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  rep(i,m) {\n    int x,y;\n    cin >> x >> y;\n    G[x].pb(y);\n    G[y].pb(x);\n  }\n\n  vector<edge> E;\n  bridge(n,G,E);\n  vector<P> ans;\n  rep(i,E.size()) {\n    if(E[i].u>E[i].v) swap(E[i].u,E[i].v);\n    ans.pb(P(E[i].u,E[i].v));\n  }\n  sort(all(ans));\n  rep(i,ans.size()) PR(ans[i].F,ans[i].S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <utility>\n#include <vector>\n\nclass union_find {\nprivate:\n  using size_t = std::size_t;\n\n  class node_type {\n    friend union_find;\n\n    size_t parent;\n    size_t size;\n\n    node_type(const size_t parent, const size_t size)\n      : parent(parent), size(size) {}\n  };\n\n  std::vector<node_type> tree;\n\n  size_t size() const { return tree.size(); }\n\npublic:\n  union_find() = default;\n  explicit union_find(const size_t n) : tree(n, node_type(n, 1)) {}\n\n  size_t find(const size_t x) {\n    assert(x < size());\n    if (tree[x].parent == size())\n      return x;\n    else\n      return tree[x].parent = find(tree[x].parent);\n  }\n  bool same(const size_t x, const size_t y) {\n    assert(x < size());\n    assert(y < size());\n    return find(x) == find(y);\n  }\n  size_t size(const size_t x) {\n    assert(x < size());\n    return tree[find(x)].size;\n  }\n\n  void unite(size_t x, size_t y) {\n    assert(x < size());\n    assert(y < size());\n    x = find(x);\n    y = find(y);\n    if (x != y) {\n      if (tree[x].size < tree[y].size)\n        std::swap(x, y);\n      tree[x].size += tree[y].size;\n      tree[y].parent = x;\n    }\n  }\n};\n\n#include <unordered_set>\n\nclass incremental_bridge_connected_components {\nprivate:\n  using size_t = std::size_t;\n\n  union_find cc;\n  union_find bcc;\n  std::vector<size_t> bbf;\n\n  size_t size() const { return bbf.size(); }\n  size_t nil() const { return size(); }\n\n  size_t parent(const size_t v) {\n    if (bbf[v] == nil())\n      return nil();\n    else\n      return bcc.find(bbf[v]);\n  }\n  size_t lca(size_t u, size_t v) {\n    std::unordered_set<size_t> reached;\n    while (true) {\n      if (u != nil()) {\n        if (!reached.insert(u).second)\n          return u;\n        u = parent(u);\n      }\n      std::swap(u, v);\n    }\n  }\n  void condense_path(size_t u, const size_t v) {\n    while (!bcc.same(u, v)) {\n      const size_t next = parent(u);\n      bbf[u] = bbf[v];\n      bcc.unite(u, v);\n      u = next;\n    }\n  }\n  void link(const size_t x, const size_t y) {\n    size_t v = x, prev = y;\n    while (v != nil()) {\n      const size_t next = bbf[v];\n      bbf[v] = prev;\n      prev = v;\n      v = next;\n    }\n  }\n\npublic:\n  incremental_bridge_connected_components() = default;\n  explicit incremental_bridge_connected_components(const size_t n)\n    : cc(n), bcc(n), bbf(n, n) {}\n\n  void insert_edge(size_t u, size_t v) {\n    assert(u < size());\n    assert(v < size());\n    u = bcc.find(u);\n    v = bcc.find(v);\n    if (cc.same(u, v)) {\n      const size_t w = lca(u, v);\n      condense_path(u, w);\n      condense_path(v, w);\n    }\n    else {\n      if (cc.size(u) > cc.size(v))\n        std::swap(u, v);\n      link(u, v);\n      cc.unite(u, v);\n    }\n  }\n  size_t find_block(const size_t u) {\n    assert(u < size());\n    return bcc.find(u);\n  }\n};\n\n#include <iostream>\n#include <utility>\n#include <vector>\n#include<algorithm>\n\nint main() {\n  int n, m;\n  std::cin >> n >> m;\n  std::vector<std::pair<int, int>> v(m);\n  for (auto& e : v) {\n    std::cin >> e.first >> e.second;\n    e = std::minmax({ e.first, e.second });\n  }\n  std::sort(v.begin(), v.end());\n  incremental_bridge_connected_components ibcc(n);\n  for (const auto& e : v) {\n    ibcc.insert_edge(e.first, e.second);\n  }\n  //std::cout << std::endl;\n  for (const auto& e : v) {\n    if (ibcc.find_block(e.first) != ibcc.find_block(e.second)) {\n      std::cout << e.first << \" \" << e.second << std::endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nint V, E;\nvector<int> g[112345];\nvector<int> depth, low;\nset<pii> bridge;\n\nint dfs(int u, int p, int d) {\n\tdepth[u] = d;\n\tlow[u] = d;\n\t\n\tfor (int v : g[u]) {\n\t\tif (v == p) continue;\n\t\t\n\t\tif (depth[v] == -1) {\n\t\t\tchmin(low[u], dfs(v, u, d + 1));\n\t\t\tif (depth[v] == low[v]) bridge.insert(pii(min(u, v), max(u, v)));\n\t\t}\n\t\telse chmin(low[u], low[v]);\n\t}\n\t\n\treturn low[u];\n}\n\n\nint main() {\n\tcin >> V >> E;\n\tREP(i, E) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\t\n\tdepth.resize(V, -1);\n\tlow.resize(V, -1);\n\t\n\tdfs(0, -1, 0);\n\t\n\tfor (pii now : bridge) printf(\"%d %d\\n\", now.first, now.second);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\nvoid dfs(int v, int p, vector<vi> &G, vi &ord, vi &low, int &idx)\n{\n    ord[v] = low[v] = idx++;\n    for(auto u:G[v]){\n        if (u==p) continue;\n        if (ord[u]!=-1){\n            chmin(low[v],ord[u]);\n            continue;\n        }\n        dfs(u,v,G,ord,low,idx);\n        chmin(low[v],low[u]);\n    }\n}\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M; cin>>N>>M;\n    vector<vi> G(N);\n    rep(i,M){\n        int a,b; cin>>a>>b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n    vi ord(N,-1),low(N);\n    int idx=0;\n    dfs(0,-1,G,ord,low,idx);\n    vector<pi> ans;\n    rep(v,N){\n        for(auto u:G[v]){\n            if (ord[v]<low[u]){\n                int a = min(v,u);\n                int b = max(v,u);\n                ans.pb({a,b});\n            }\n        }\n    }\n    sort(all(ans));\n    for(auto e:ans){\n        cout<<e.fi<<\" \"<<e.se<<\"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\nint v = 100005,e;\nint c = 0;\nvector<vector<int>> graph(v,vector<int>());\nvector<bool> seen(v,false);\nvector<int> ord(v);\nvector<int> low(v);\nvector<P> bridges;\n\nvoid dfs(int i,int par=-1){\n    seen[i] = true;\n    ord[i] = low[i] = c++;\n\n    for(int j:graph[i]){\n        if(!seen[j]){\n            dfs(j,i);\n            low[i] = min(low[i],low[j]);\n            if(ord[i] < low[j]) bridges.push_back(P(min(i,j),max(i,j)));\n        }else if(j!=par){\n            low[i] = min(low[i],ord[j]);\n        }\n    }\n\n    return;\n}\n\nint main(){\n    cin >> v >> e;\n    rep(i,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        graph[t].push_back(s);\n    }\n    dfs(0);\n    sort(bridges.begin(),bridges.end());\n    for(P p:bridges){\n        cout << p.first << \" \" << p.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint V,E;\nvector<int> g[100100];\nint dep[100100],low[100100],ord[100100];\nint cnt = 0;\nvoid dfs(int v,int p,int d){\n\tdep[v] = d;\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tfor(int i=0;i<g[v].size();i++){\n\t\tif(g[v][i]==p)continue;\n\t\tint ch = g[v][i];\n\t\tif(ord[ch]==-1){\n\t\t\tdfs(ch,v,d+1);\n\t\t\tlow[v] = min(low[v],low[ch]);\n\t\t}else{\n\t\t\tlow[v] = min(low[v],ord[ch]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&V,&E);\n\tvector<P> es(E);\n\tfor(int i=0;i<E;i++){\n\t\tint s,t;\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tg[s].pb(t);\n\t\tg[t].pb(s);\n\t\tes[i]=P(s,t);\n\t}\n\tmemset(ord,-1,sizeof(ord));\n\tdfs(0,-1,0);\n\tfor(int i=0;i<E;i++){\n\t\tint s = es[i].fi,t = es[i].sec;\n\t\tif(dep[s]>dep[t])swap(s,t);\n\t\tif(ord[s]<low[t])printf(\"%d %d\\n\",es[i].fi,es[i].sec);\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\n\n//////////////////////////////\n// ????????? (?????¨????????????????????????????????¨??°?????????2???????????????????????????????????????\nint dfs(int u, int prev, int *cnt, int *prenum, int *lowest, vector< vector<int> > &v, vector<pi> &res){\n  prenum[u] = lowest[u] = ++(*cnt);\n  REP(i, v[u].size()){\n    int next = v[u][i];\n    if(prenum[next] == -1){\n      lowest[u] = min(lowest[u], dfs(next, u, cnt, prenum, lowest, v, res));\n      if(lowest[next] == prenum[next]) res.push_back(pi(min(u, next), max(u, next)));\n    }\n    else if(prev != next)\n      lowest[u] = min(lowest[u], lowest[next]);\n  }\n  return lowest[u];\n}\nvector<pi> bridges(int V, int E, vector< vector<int> > &v){\n  int prenum[V], lowest[V];\n  memset(prenum, -1, sizeof(prenum));\n  int tmp = 1;\n  vector<pi> res;\n  dfs(0, -1, &tmp, prenum, lowest, v, res);\n  return res;\n}\nint main() {\n\tint v, e; cin >> v >> e;\n\tvector<vi> vvi(v);\n\tREP(i, e) {\n\t\tint a,b; cin >> a >> b;\n\t\tvvi[a].pb(b);\n\t\tvvi[b].pb(a);\n\t}\n\tvector<pi> ans = bridges(v, e, vvi);\n\tsort(ans.begin(), ans.end());\n\tREP(i, ans.size())\n\t\tcout << ans[i].first << ' '<< ans[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint V,E;\nvector<int> g[100100];\nint dep[100100],low[100100],ord[100100];\nint cnt = 0;\nvoid dfs(int v,int p,int d){\n\tdep[v] = d;\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tfor(int i=0;i<g[v].size();i++){\n\t\tif(g[v][i]==p)continue;\n\t\tint ch = g[v][i];\n\t\tif(ord[ch]==-1){\n\t\t\tdfs(ch,v,d+1);\n\t\t\tlow[v] = min(low[v],low[ch]);\n\t\t}else{\n\t\t\tlow[v] = min(low[v],ord[ch]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&V,&E);\n\tvector<P> es(E);\n\tfor(int i=0;i<E;i++){\n\t\tint s,t;\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tg[s].pb(t);\n\t\tg[t].pb(s);\n\t\tif(s>t)swap(s,t);\n\t\tes[i]=P(s,t);\n\t}\n\tmemset(ord,-1,sizeof(ord));\n\tdfs(0,-1,0);\n\tvector<P> ans;\n\tfor(int i=0;i<E;i++){\n\t\tint s = es[i].fi,t = es[i].sec;\n\t\tif(dep[s]>dep[t])swap(s,t);\n\t\tif(ord[s]<low[t])ans.pb(es[i]);\t\n\t}\n\tsort(all(ans));\n\tfor(int i=0;i<ans.size();i++)printf(\"%d %d\\n\",ans[i].fi,ans[i].sec);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#include <numeric>\n#define M_PI       3.14159265358979323846\n#ifdef LOCAL\n#include <sys/types.h>\n#include <sys/timeb.h>\n#include <intrin.h> \n#include <thread>\n#else\n#include <sys/time.h>\n#endif\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define FILL(a, x) memset(a, x, sizeof(a))\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int N = 100000;\nint idx[N];\nint lowlink[N];\nbool onstack[N];\n\nstruct edge {\n\tint to;\n\tedge(int _to) : to(_to) {};\n};\nusing node = vector<edge>;\nusing graph = vector<node>;\n\nvoid visit(graph &g,int node, int parent, int &ord, VI & order, vector<PII> &bridges, VVI &bcc, stack<int> &S, vector<bool> &inS, stack<int> &roots) {\n\torder[node] = ord++;\n\tS.push(node); inS[node] = true;\n\troots.push(node);\n\tfor (auto e : g[node]) {\n\t\tif (order[e.to] == -1) {\n\t\t\tvisit(g, e.to, node, ord, order, bridges, bcc, S, inS, roots);\n\t\t}\n\t\telse if( parent != e.to && inS[e.to]){\n\t\t\twhile (order[roots.top()] > order[e.to])roots.pop();\t\t\n\t\t}\n\t}\n\tif (node == roots.top()) {\n\t\tbridges.PB(PII(min(node, parent), max(node, parent)));\n\t\tbcc.PB(VI());\n\t\twhile (1) {\n\t\t\tint cur = S.top(); S.pop(); inS[cur] = false;\n\t\t\tbcc.back().PB(cur);\n\t\t\tif (cur == node)break;\n\t\t}\n\t\troots.pop();\n\t}\n}\n\nvoid bridge(graph &g, vector<PII> &bridges, VVI &bcc) {\n\tint n = g.size();\n\tVI order(n, -1);\n\tvector<bool> inS(n);\n\tstack<int> roots, S;\n\tint ord = 0;\n\tREP(i, n) {\n\t\tif (order[i] == -1) {\n\t\t\tvisit(g, i, -1, ord, order, bridges, bcc, S, inS, roots);\n\t\t\tbridges.pop_back();\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tgraph g(n);\n\tREP(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\n\tvector<PII> bridges;\n\tVVI bcc;\n\tbridge(g, bridges, bcc);\n\tSORT(bridges);\n\tfor (auto e : bridges) printf(\"%d %d\\n\", e.first, e.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> g[100010];\n\nint zeit, dis[MAXN], fin[MAXN], low[MAXN], par[MAXN], dep[MAXN];\nint kodat[MAXN], koptr[MAXN + 1];\nvoid dfsInfo(int u,int oy,int d){\n\tdis[u] = low[u] = zeit++; par[u] = oy; dep[u] = d;\n\tint v;\n\trep(i,sz(g[u])) if((v = g[u][i]) != oy){\n\t\tif(!~dis[v]){\n\t\t\tdfsInfo(v, u, d + 1);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], dis[v]);\n\t\t}\n\t}\n\tfin[u] = zeit++;\n}\n\nvoid dfsInfos(){\n\tmemset(dis, ~0, n*4); zeit = 0;\n\trep(u,n) if(!~dis[u]) dfsInfo(u, -1, 0);\n\trep(u,n){\n\t\tint &j = koptr[u + 1] = koptr[u];\n\t\trep(i,sz(g[u])) if(u == par[g[u][i]]) kodat[j++] = g[u][i];\n\t}\n}\n\nbool produce(int u,int v){\n\treturn (dis[u] <= dis[v] && fin[u] >= fin[v]);\n}\n\nint related(int u,int v){\n\tint s = koptr[u], e = koptr[u+1], h;\n\twhile(s+1 < e){\n\t\th = (s + e) >> 1;\n\t\t(dis[kodat[h]] <= dis[v]) ? s = h : e = h;\n\t}\n\treturn kodat[s];\n}\n\nbool isBridge(int u,int v){\n\tif(dis[u] > dis[v]) swap(u, v);\n\treturn (u == par[v] && dis[v] <= low[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\n\tint m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfsInfos();\n\trep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && isBridge(i,g[i][j]))cout<<i<<\" \"<<g[i][j]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nclass low_link_tree {\n\tint n;\n\tint tmr;\n\tint rt = 0;\n\tvector<int> ord;\n\tvector<int> low;\n\tset<int> atc;\n\tset<pair<int, int>> bdg;\n\tvector<vector<int>> grh;\npublic:\n\tlow_link_tree (\n\t\tvector<vector<int>> const& grh\n\t)\n\t: n(grh.size())\n\t, ord(n, -1)\n\t, low(n, -1)\n\t, grh(grh)\n\t{\n\t\tdfs(0, 0);\n\t}\n\tvoid dfs (\n\t\tint crr\n\t,\tint prt\n\t) {\n\t\tint cnt = 0;\n\t\tord[crr] = low[crr] = tmr++;\n\t\tfor (int nxt : grh[crr]) {\n\t\t\tif (ord[nxt] == -1) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, crr);\n\t\t\t\tchmin(low[crr], low[nxt]);\n\t\t\t\tif (crr != rt && ord[crr] <= low[nxt]) atc.insert(crr);\n\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(crr, nxt);\n\t\t\t}\n\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);\n\t\t}\n\t\tif (crr == rt && cnt > 1) atc.insert(crr);\n\t}\n\tauto const &order() {return ord;}\n\tauto const &low_link() {return low;}\n\tauto const &articulation_points() {return atc;}\n\tauto const &bridges() {return bdg;}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tauto bdg = low_link_tree(grh).bridges();\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvi g;\n\tvi imos,big,dep;\n\tvp edge;\n\tvoid Bdfs(int v,int d){\n\t\tdep[v]=d;\n\t\tfor(auto u:g[v]) if(dep[u]==-1) Bdfs(u,d+1);\n\t}\n\tint BDFS(int v){\n\t\tint d=dep[v],S=0;\n\t\tfor(auto u:g[v]){\n\t\t\tint D=dep[u];\n\t\t\tif(D==d-1) continue;\n\t\t\tif(D==d+1) S+=BDFS(u);\n\t\t\telse if(D<d) S++;\n\t\t\telse S--;\n\t\t}\n\t\treturn imos[v]=S;\n\t}\n\tvoid BDfs(int v,int t,int& id){\n\t\tbig[v]=t;\n\t\tfor(auto u:g[v]) if(dep[u]==dep[v]+1){\n\t\t\tif(imos[u]) BDfs(u,t,id);\n\t\t\telse{\n\t\t\t\tid++;\n\t\t\t\tBDfs(u,id,id);\n\t\t\t}\n\t\t}\n\t}\n\tint Biconnect(){\n\t\timos=big=vi(n);\n\t\tdep=vi(n,-1);\n\t\tint t=0;\n\t\tBdfs(0,0);BDFS(0);BDfs(0,0,t);\n\t\treturn t+1;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\tvoid solve(){\n\t\tint N=Biconnect();\n\t\tvp a;\n\t\tfor(int u=0;u<n;u++) for(auto v:g[u]) if(big[u]<big[v])a.push_back({min(u,v),max(u,v)});\n\t\tsort(a.begin(),a.end());\n\t\tfor(auto p:a) cout<<p.first<<' '<<p.second<<endl;\n\t}\n};\n\nint n,m;\n\nint main(){\n\tcin>>n>>m;\n\tGraph g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tg.add_edge(u,v);\n\t}\n\tg.solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\n\tint ans = currentTime;\n\tfor( auto &&e : g[x] ){\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t}\n\tdfs(0, g);\n\n\tfor( auto e : es ){\n\t\tif( !visited[e.a] || !visited[e.b] || order[e.a] < order[e.b] ){\n\t\t\tcout << e.a << \" \" << e.b << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nvoid DFS(Graph g, int u, int &clock, vector<int> &low, vector<int> &disc, vector<bool> &seen, vector<int> &parent, vector<Edge> &bridges) {\n    for(int v: g[u]) {\n        if (! seen[v]) {\n            clock++;\n\n            disc[v] = clock;\n            low[v] = clock;\n            seen[v] = true;\n            parent[v] = u;\n\n            DFS(g, v, clock, low, disc, seen, parent, bridges);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u])\n                bridges.push_back(Edge{min(u, v), max(u, v)});\n        } else if (v != parent[u]) {\n            low[u]  = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> bridges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    int clock = 2;\n    vector<int> low(V, 0);\n    vector<int> disc(V, 0);\n    vector<int> parent(V, -1);\n    vector<bool> seen(V, false);\n    disc[0] = 1;\n    low[0] = 1;\n    seen[0] = true;\n\n    DFS(g, 0, clock, low, disc, seen, parent, bridges);\n\n    sort(bridges.begin(), bridges.end());\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = 2002, E = 2002;\n\nvector <int> g[N], cvs;\nvector <pair<int, int>> ces;\nint up[N], h[N], from[E], to[E];\nbool mark[N];\n\nint cecvme(int v, int pare = -1) // With multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int e : g[v])\n\t\tif(e != pare)\n\t\t{\n\t\t\tint u = to[e] ^ from[e] ^ v;\n\t\t\tif(mark[u])\n\t\t\t\tup[v] = min(up[v], h[u]);\n\t\t\telse\n\t\t\t{\n\t\t\t\th[u] = h[v] + 1;\n\t\t\t\tup[v] = min(up[v], cecvme(u, e));\n\t\t\t\tif(up[u] >= h[v] && pare != -1)\n\t\t\t\t\tcvs.push_back(v);\n\t\t\t\tchildren++;\n\t\t\t}\n\t\t}\n\tif(pare != -1 && up[v] == h[v])\n\t\tces.push_back({from[pare], v}); // pare\n\tif(pare == -1 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n \nint cecv(int v, int par) // Without multiple edge\n{\n\tup[v] = h[v];\n\tmark[v] = true;\n\tint children = 0;\n\tfor(int u : g[v])\n\t{\n\t\tif(mark[u] && u != par)\n\t\t\tup[v] = min(up[v], h[u]);\n\t\tif(!mark[u])\n\t\t{\n\t\t\th[u] = h[v] + 1;\n\t\t\tup[v] = min(up[v], cecv(u, v));\n\t\t\tif(up[u] >= h[v] && h[v] > 0)\n\t\t\t\tcvs.push_back(v);\n\t\t\tchildren++;\n\t\t}\n\t}\n\tif(h[v] > 0 && up[v] == h[v])\n\t\tces.push_back({par, v});\n\tif(h[v] == 0 && children > 1)\n\t\tcvs.push_back(v);\n\treturn up[v];\n}\n\nint main()\n{\n\th[0] = 0;\n\tint n = in(), m = in();\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u = in(), v = in();\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tcecv(0, -1);\n\tfor(auto &e : ces)\n\t\tif(e.first > e.second)\n\t\t\tswap(e.first, e.second);\n\tsort(ces.begin(), ces.end());\n\tfor(auto e : ces)\n\t\tcout << e.first << \" \" << e.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n#define MAX_V 100000\nvector<int> G[MAX_V];\nbool usedV[MAX_V],usedE[MAX_V][MAX_V];\nint ord[MAX_V],lowlink[MAX_V];\nint k=0;\n\n\nvoid dfs(int v){\t//make ord and lowlink\n\tusedV[v] = true;\n\tord[v]=lowlink[v]=k;\n\tk++;\n\t\n\trep(i,G[v].size()){\n\t\tint to = G[v][i];\n\t\tif(!usedV[to]){\n\t\t\tusedE[v][to] = true;\n\t\t\tdfs(to);\n\t\t\tlowlink[v] = min(lowlink[v],lowlink[to]);\n\t\t}\n\t\telse if(!usedE[to][v]){\t//use back edge\n\t\t\tlowlink[v] = min(lowlink[v],ord[to]);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<pii> edges;\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tif(s>t)swap(s,t);\n\t\tedges.pb(pii(s,t));\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\t\n\tdfs(0);\n\t\n\trep(i,e){\n\t\tif(ord[edges[i].first]<lowlink[edges[i].second])cout<<edges[i].first<<\" \"<<edges[i].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\nclass edge {\n   public:\n    int t;\n    int id;\n    edge(int to, int i) : t(to), id(i) {}\n    edge() {}\n};\nint n = 0, m = 0;\nvector<vector<edge>> g;\nvector<int> pre;\nvector<int> ll;\nvector<pair<int, int>> res;\nint tt = 0;\nvoid input() {\n    cin >> n >> m;\n    int id = 1, M = m;\n    g = vector<vector<edge>>(n, vector<edge>());\n    pre = vector<int>(n, -1);\n    ll = vector<int>(n, -1);\n    while (M--) {\n        int a = 0, b = 0;\n        cin >> a >> b;\n        g[a].push_back({b, ++id});\n        g[b].push_back({a, id});\n    }\n}\nint dfs(int i, int p, int id) {\n    if (pre[i] != -1) {\n        ll[p] = min(ll[p], pre[i]);\n        return ll[p];\n    }\n    pre[i] = ++tt;\n    ll[i] = pre[i];\n    for (auto v : g[i]) {\n        if (v.id == id) {\n            continue;\n        }\n        if (dfs(v.t, i, v.id) < 0) {\n            ll[i] = min(ll[i], ll[v.t]);\n            if (ll[v.t] == pre[v.t]) res.push_back({i, v.t});\n        }\n    }\n    return -1;\n}\nvoid compute() {\n    for (int i = 0; i < n; i++) {\n        if (pre[i] == -1) {\n            dfs(i, i, m + 2);\n        }\n    }\n    for (auto &r : res) {\n        if (r.first > r.second) {\n            swap(r.first, r.second);\n        }\n    }\n    sort(res.begin(), res.end());\n\n    for (auto b : res) {\n        cout << b.first << \" \" << b.second << endl;\n    }\n}\n\nint main() {\n    input();\n    compute();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > ord[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n\n  vector<int> visit(V, -1);\n  \n  int num_cc = edge_group.size();\n  REP(s, V) if (visit[s] == -1){\n    \n    visit[s] = true;\n    queue<int> que;\n    while (!que.empty()){\n      int v = que.front(); que.pop();\n      for (int w : G[v]){\n        if (visit[w] == -1){\n          visit[w] = num_cc;\n          que.push(w);\n        }\n      }\n    }\n    num_cc++;\n  }\n  edge_group.resize(num_cc);\n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (visit[e.fst] == visit[e.snd]) edge_group[visit[e.fst]].push_back(i);\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    if (u > v) swap(u, v);\n    es.emplace_back(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()) if (bd.edge_group[i].size() == 1) {\n    bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<utility>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<set>\n\nusing namespace std;\n\nstruct Edge {\n\tint from, to; //if you want cost, etc., you should care about the \"emplace_back\"(line36,line118).\n\tEdge(int f, int t) {\n\t\tfrom = f;\n\t\tto = t;\n\t}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nvector<int>ArticulationPoint(const Graph& g) {\n\tint n = g.size(), idx = 0;\n\tvector<int>low(n), ord(n), art;\n\tfunction<void(int)>dfs = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[w] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v]))\n\t\t\t\t\tart.push_back(v);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\treturn art;\n}\n\nvector<int> tarjan(const Graph& g) {\n\tint n = g.size(), idx = 0, k = 0, s = 0;\n\tvector<int>ord(n, -1), low(n), onS(n), cmp(n), stk(n);\n\tfunction<void(int)>dfs;\n\tdfs = [&](int v) {\n\t\tord[v] = low[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) {\n\t\t\t\tdfs(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t}\n\t\t\telse if (onS[w]) {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t\tif (low[v] == ord[v]) {\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (w == v)break;\n\t\t\t}\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int v = 0; v<n; ++v)\n\t\tif (ord[v] == -1)dfs(v);\n\treturn cmp;\n}\n\nvector<int> kosaraju(const Graph& g) {\n\tint n = g.size(), sz = 0;\n\tGraph rg(n);\n\tvector<int>stk, cmp(n, -1), added(n), visited(n), ord(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es)rg[e.to].emplace_back(e.to, e.from);\n\t\tsz += es.size();\n\t}\n\tstk.resize(n + sz);\n\tsz = 0;\n\tfor (int i = 0; i<n; ++i) {\n\t\tif (visited[i])continue;\n\t\tint s = 0;\n\t\tstk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : g[v]) {\n\t\t\t\tint to = e.to;\n\t\t\t\tif (!visited[to]) {\n\t\t\t\t\tstk[s++] = to;\n\t\t\t\t\tpushed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pushed)continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) {\n\t\t\t\tadded[t] = true;\n\t\t\t\tord[n - ++sz] = t;\n\t\t\t}\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1)continue;\n\t\tint s = 0;\n\t\tstk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s];\n\t\t\tcmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint t = e.to;\n\t\t\t\tif (cmp[t] == -1)stk[s++] = t;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tGraph g(V);\n\tfor (int i = 0; i<E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].emplace_back(s, t);\n\t\tg[t].emplace_back(t, s);\n\t}\n\tEdges es = bridge(g).second;\n\tvector<pair<int, int>>v;\n\tfor (auto x : es) {\n\t\tif(x.from>x.to)v.push_back(pair<int, int>(x.to, x.from));\n\t\telse v.push_back(pair<int, int>(x.from, x.to));\n\t}\n\tsort(v.begin(), v.end());\n\tfor (auto x : v) {\n\t\tcout << x.first << \" \"  << x.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int>      Edge;   // (a < b: undirected)\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vi depth;\n    vi par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvi cmp;\n\tint num_cc;\n\tvi size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    void bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\t// rep(i, n) {\n\t\t// \tint size_cc = extractCC(i, num_cc);\n\t\t// \tif (size_cc > 0) {\n\t\t// \t\tsize_of_vertex.emplace_back(size_cc);\n\t\t// \t\tnum_cc++;\n\t\t// \t}\n\t\t// }\n        //\n        // r<set<int>> G_cc_st(num_cc);\n\t\t// for (auto&& p : EdgeType) {\n        //     Edge e;\n        //     int type;\n        //     tie(e, type) = p;\n        //     if (type == BRIDGE) {\n\t\t// \t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t// \t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n        //     }\n        // }\n        //\n\t\t// rep(i, num_cc) {\n\t\t// \tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t// }\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n    BICC bicc(V);\n    rep(i, E) {\n        int a, b;\n        cin >> a >> b;\n        bicc.addEdge(a, b);\n    }\n\n    bicc.bicc();\n    auto bridges = bicc.getBridges();\n    sort(all(bridges));\n    printVP(bridges);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define V_MAX 100000\nusing namespace std;\nstruct edgeB{int u,v;}; //u,v???????????????\nint V;                  //???????????°\nvector <int> G[V_MAX];  //??°???????????£??\\??????????????¨???\nvector <edgeB> bridges; // ???\nint ord[V_MAX];         //?????????????????????????????????\nint low[V_MAX];         //\n \nvoid dfs(int u, int p, int &c){\n  ord[u] = low[u] = c++;\n  for(int i=0;i<G[u].size();i++){\n    int v = G[u][i];\n    if(v==p)continue;\n    \n    if(ord[v] == -1){\n      dfs(v,u,c);\n      low[u] = min(low[u],low[v]);\n    }\n    else low[u] = min(low[u], ord[v]);\n    if(ord[u] < low[v]) bridges.push_back((edgeB){u,v});\n  }\n}\n\nvoid bridge(){\n  bridges.clear();\n  int c = 0;\n  memset(ord,-1,sizeof(ord));\n  for(int i=0;i<V;i++) if(ord[i]==-1) dfs(i,-1,c);\n}\n\nbool compare(edgeB a, edgeB b){\n  return a.u==b.u? a.v<b.v:a.u<b.u;\n}\n\nint main(){\n  int E;\n  cin>>V>>E;\n  for(int i=0;i<E;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  \n  bridge();\n  for(int i=0;i<bridges.size();i++)\n    if(bridges[i].u > bridges[i].v)swap(bridges[i].u, bridges[i].v);\n  sort(bridges.begin(),bridges.end(),compare);\n  for(int i=0;i<bridges.size();i++) cout << bridges[i].u<<\" \"<<bridges[i].v<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\ntemplate< typename T >\nstruct edge\n{\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\ntemplate< typename G >\nstruct LowLink\n{\n  const G &g;\n  UnionFind uf;\n  vector< int > used, ord, low, parent;\n\n  LowLink(const G &g) : g(g), uf(g.size()), used(g.size()), ord(g.size()), low(g.size()), parent(g.size(), -1) {}\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        parent[to] = idx;\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  void dfs()\n  {\n    int k = 0;\n    dfs(0, k);\n  }\n};\n\ntemplate< typename G >\nstruct BiConnectedComponents : LowLink< G >\n{\n  using LL = LowLink< G >;\n\n  vector< int > comp;\n\n  BiConnectedComponents(const G &g) : LL(g), comp(g.size()) {}\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  vector< pair< int, int > > build(UnWeightedGraph &t)\n  {\n    LL::dfs();\n    int ptr = 0;\n    vector< int > cc(LL::g.size());\n    for(int i = 0; i < LL::g.size(); i++) {\n      if(i == LL::uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < LL::g.size(); i++) {\n      comp[i] = cc[LL::uf.find(i)];\n    }\n\n    vector< pair< int, int > > edges;\n    for(int i = 0; i < LL::g.size(); i++) {\n      for(auto &to : LL::g[i]) edges.emplace_back(minmax(i, to));\n    }\n    sort(begin(edges), end(edges));\n    edges.erase(unique(begin(edges), end(edges)), end(edges));\n    vector< pair< int, int > > vs;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      vs.emplace_back(e.first, e.second);\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n    sort(begin(vs), end(vs));\n    return (vs);\n  }\n};\n\nvoid solve()\n{\n  int V, E;\n  cin >> V >> E;\n  UnWeightedGraph g(V);\n  for(int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  BiConnectedComponents< UnWeightedGraph > bp(g);\n  UnWeightedGraph gg;\n\n  for(auto &p : bp.build(gg)) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n\nclass Node {\npublic:\n\tNode():number(i++), order(-1), min(0), edges(0), parent(0), art(false) {};\n\tvoid add_edge(Node *);\n\tstd::vector<Node*> &get_edge() { return edges; }\n\tbool operator==(const Node &other) { return number == other.number; }\n\tint order, min, number, parent;\n\tbool art;\n\tbool arti() { return art || edges.size() == 1; }\nprivate:\n\tstatic int i;\n\tstd::vector<Node*> edges;\n};\nint Node::i = 0 ;\nvoid Node::add_edge(Node *other) { edges.push_back(other); }\nint dfs(Node &current, int &order) {\n\tint min = order;\n\tint count = 0;\n\tfor (auto &node : current.get_edge()) {\n\t\tint temp;\n\t\tif (node->order == -1) {\n\t\t\tnode->order = ++order;\n\t\t\tnode->parent = current.order;\n\t\t\ttemp = dfs(*node, order);\n\t\t\tif (temp == current.order) {\n\t\t\t\tcurrent.art = true;\n\t\t\t}\n\t\t\t++count;\n\t\t}\n\t\telse {\n\t\t\ttemp = node->order;\n\t\t}\n\t\tif (min > temp) {\n\t\t\tmin = temp;\n\t\t}\n\t}\n\tif (current.number == 0) {\n\t\tif (count > 1) {\n\t\t\tcurrent.art = true;\n\t\t}\n\t\telse {\n\t\t\tcurrent.art = false;\n\t\t}\n\t}\n\tcurrent.min = min;\n\treturn min;\n}\nclass Edge {\npublic:\n\tEdge(const int &sn = 0, const int &tn = 0, Node *s = nullptr, Node *e = nullptr) : s_num(sn), t_num(tn), start{ s }, end{ e }, number(i++) {};\n\tbool suspect() { return (start->arti() && end->arti()) && (start->parent == end->number || start->number == end->parent); }\n\tbool operator<(const Edge &other) { return (s_num < other.s_num) || (s_num == other.s_num && t_num < other.t_num); }\n\tvoid show() { std::cout << s_num << \" \" << t_num << \"\\n\"; }\nprivate:\n\tNode *start, *end;\n\tint s_num, t_num, number;\n\tstatic int i;\n};\nint Edge::i(0);\nvoid sort(std::vector<Edge> &vector, const int left, const int right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (vector.at(l) < pivot)++l;\n\t\t\twhile (pivot < vector.at(r))--r;\n\t\t\tif (l <= r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, l, right);\n\t}\n}\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tstd::vector<Node> node(v);\n\tstd::vector<Edge> edge(e);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\t\tedge.at(i) = Edge(s, t, &node.at(s), &node.at(t));\n\t\tnode.at(s).add_edge(&node.at(t));\n\t\tnode.at(t).add_edge(&node.at(s));\n\t}\n\tnode.at(0).order = 0;\n\tint order = 0;\n\tdfs(node.at(0), order);\n\tsort(edge, 0, edge.size() - 1);\n\tfor (auto v : node) {\n\t\t//std::cout << v.number << \"--art= \" << v.arti() << \"--min= \" << v.min << \"--order= \" << v.order << \"--parent= \" << v.parent << std::endl;\n\t}\n\tfor (auto e : edge) {\n\t\tif (e.suspect()) {\n\t\t\te.show();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            dp[v]=min(dp[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            dp[v]=min(dp[v],dp[u]);\n        }\n    }\n    if(dp[v]>=depth[v]&&l!=-1)\n        cout<<from[l]<<\" \"<<to[l]<<'\\n';\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    //fill(dp,dp+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        if(i>=m){\n            dp[i]=INF;\n            continue;\n        }\n        dp[i]=INF;\n        cin>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nset<pa> hasi;\nint pre[100100],lowlink[100100];\nint counter_hasi=1;\nvoid dfs_hasi(int r,int mae,vector<int> *graph){\n\tif(pre[r]>=0) return;\n\tpre[r]=counter_hasi;\n\tcounter_hasi++;\n\tint f=pre[r];\n\tint oyacnt=0;\n\tfor(int i=0;i<graph[r].size();i++){\n\t//\tcout<<r<<\" \"<<graph[r][i]<<endl;\n\t\tif(graph[r][i]==mae){\n\t\t\toyacnt++;\n\t\t\tif(oyacnt==1) continue; \n\t\t}\n\t\tif(pre[graph[r][i]]<0){\n\t\t\tdfs_hasi(graph[r][i],r,graph);\n\t\t\tf=min(f,lowlink[graph[r][i]]);\n\t\t\t//cout<<r<<\" \"<<graph[r][i]<<\" \"<<pre[graph[r][i]]<<\" \"<<lowlink[graph[r][i]]<<endl;\n\t\t\tif(pre[graph[r][i]]==lowlink[graph[r][i]]){\n\t\t\t//\tcout<<\" \"<<graph[r][i]<<endl;\n\t\t\t\t\n\t\t\t\t//ryouhoukou\n\t\t\t//\thasi.insert(mp(r,graph[r][i]));\n\t\t\t//\thasi.insert(mp(graph[r][i],r));\n\t\t\t\t\n\t\t\t\t//katahou\n\t\t\t\tif(r<graph[r][i])\thasi.insert(mp(r,graph[r][i]));\n\t\t\t\telse hasi.insert(mp(graph[r][i],r));\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tf=min(f,pre[graph[r][i]]);\n\t\t}\n\t\t\n\t}\n\tlowlink[r]=f;\n\t\n\treturn ;\n}\n\nvoid hashi_kenshutu(int V,vector<int> *graph){// V=tyoutensuu\n\tfor(int i=0;i<=V;i++)pre[i]=-1,lowlink[i]=-1;\n\tcounter_hasi=1;\n\t\n\tfor(int i=0;i<V;i++){//0-index\n\t\tif(pre[i]==-1)dfs_hasi(i,i,graph);\n\t}\n\t\n\treturn;\n}\nvector<int> G[100010];\nint a[100010],b[100010];\n   signed main(){\n int n,m;\n   \tcin>>n>>m;\n   \t\n   \tfor(int i=0;i<m;i++){\n   \t\tint y,yy;\n   \t\tcin>>y>>yy;\n   \t\tG[y].pb(yy);\n   \t\tG[yy].pb(y);\n   \t\ta[i]=y;\n   \t\tb[i]=yy;\n   \t}\n   \thashi_kenshutu(n,G);\n   \t\n   \tfor(auto v:hasi) cout<<v.first<<\" \"<<v.second<<endl;\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "//Have FUN\n\nusing namespace std;\n\n#include<bits/stdc++.h>\n\nconst int maxn=1e5+10;\n\nbool mark[maxn];\nint n,m,s,t,h[maxn],up[maxn],par[maxn];\nvector <int> a[maxn];\n\nvector < pair<int,int> > ans;\nvector <pair<int, int> > ed;\nvoid input()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\ta[s].push_back(t);\n\t\ta[t].push_back(s);\n\t\tif(s>t)\n            swap(s,t);\n\t\ted.push_back(make_pair(s,t));\n\t}\n}\n\nvoid dfs(int x)\n{\n\tmark[x]=true;\n\tup[x]=h[x];\n\tfor(int i=0;i<a[x].size();i++)\n\t{\n\t\tint child=a[x][i];\n\t\tif(!mark[child])\n\t\t{\n\t\t    par[child]=x;\n\t\t\th[child]=h[x]+1;\n\t\t\tdfs(child);\n            up[x]=min(up[x],up[child]);\n\n\t\t}\n\t\telse\n            if(child!=par[x])\n                up[x]=min(up[x],h[child]);\n\t}\n}\n\nint main ()\n{\n\tinput();\n\tdfs(0);\n\tfor(int i=0; i<m; i++)\n        {\n            int fi=ed[i].first, se=ed[i].second;\n            if(h[fi]>h[se])\n                swap(fi,se);\n            if(up[se]>=h[se])\n                ans.push_back(make_pair(min(fi,se), max(fi,se)));\n        }\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vi;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LowLink{\npublic:\n\tint n, cnt1;\n\tvector<vector<int> > G, G2;\t//G2は作ったグラフ(木)\n\tvector<int> pre, low, cmp, used;\t//cmpは作成後のindex\n\tvoid init(int m){\n\t\tn = m;cnt1 = 0;\n\t\tpre.resize(n);low.resize(n);used.resize(n);\n\t\tG.resize(n);G2.resize(n);cmp.resize(n);\n\t\tfill(all(pre), -1);\n\t}\n\tvoid add_edge(int x, int y){\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tint dfs(int p = 0, int par = -1){\t//橋の検出\n\t\tif(pre[p] >= 0)return pre[p];\n\t\tpre[p] = low[p] = cnt1++;\n\t\trep(i,G[p].size())if(par != G[p][i]){\n\t\t\tint res = dfs(G[p][i], p);\n\t\t\tlow[p] = min(low[p], res);\n\t\t}\n\t\treturn low[p];\n\t}\n\tint build(int p = 0, int x = 0){\t//橋のみを残した木の構築\n\t\tint mx = x;cmp[p] = x;\n\t\tused[p] = 1;\n\t\trep(i,G[p].size())if(!used[G[p][i]]){\n\t\t\tif(pre[G[p][i]] == low[G[p][i]]){\t\t\t//橋\n\t\t\t\tG2[cmp[p]].pb(x+1);G2[x+1].pb(cmp[p]);\n\t\t\t\tchmax(mx, build(G[p][i], x+1));x++;\n\t\t\t}\n\t\t\tchmax(mx, build(G[p][i], cmp[p]));\n\t\t}\n\t\treturn mx;\n\t}\n\tint lowlink(){\n\t\trep(i,n)if(!used[i])dfs(i);\n\t\tfill(all(used), 0);\n\t\tint k = 0;\n\t\trep(i,n)if(!used[i])k += (build(i, k)-k)+1;\n\t\treturn k;\n\t}\n};\n\nvector<P> ans;\nsigned main(){\n\tLowLink low;\n\tint n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tlow.init(n);\n\trep(i,m){\n\t\tint v, u;\n\t\tscanf(\"%lld%lld\", &v, &u);\n\t\tlow.add_edge(v, u);\n\t}\n\tint size = low.lowlink();\n\tvector<vector<int> > G = low.G2;\n\trep(i,size){\n\t\trep(j,G[i].size()){\n\t\t\tif(i < G[i][j])ans.push_back(P(i, G[i][j]));\n\t\t}\n\t}\n\tZIP(ans);\n\tsize = ans.size();\n\trep(i,size)printf(\"%lld %lld\\n\", ans[i].fi, ans[i].se);\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        cin>>from[i]>>to[i];\n        if(from[i]>to[i])\n            swap(from[i],to[i]);\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nvector<bool> check(V_MAX,false);\nvector<int> pre(V_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(check[s]==true){return;}\n\tcheck[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(G[s][i]!=p && low[G[s][i]]<low[s]){\n\t\t\tlow[s]=low[G[s][i]];\n\t\t}\n\t\tif(check[G[s][i]]==false){\n\t\t\tdfs(G[s][i],s);\n\t\t}\n\t}\n\t\n\tif(!(s==0&&p==0) && pre[s]==low[s]){\n\t\tedge e;\n\t\te.from=min(s,p);\n\t\te.to=max(s,p);\n\t\tresult.push_back(e);\n\t\t//cout << p << \" \" << s << endl;\n\t}\n\t\n\t\n\t\n\tif(low[p]>low[s]){\n\t\tlow[p]=low[s];\n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nclass Bridges {\npublic:\n  int n;\n  vector<vector<int>> G;\n  vector<bool> visited;\n  vector<int> prenum, parent, lowest;\n  int timer;\n  set<pair<int, int>> bd;\n\n  Bridges() {}\n  Bridges(int n_, vector<vector<int>> G_) {init(n_, G_);}\n\n  void init(int n_, vector<vector<int>> G_) {\n    n = n_;\n    G = G_;\n    visited.resize(n, false);\n    prenum.resize(n, 0);\n    parent.resize(n, 0);\n    lowest.resize(n, 0);\n    timer = 1;\n    find();\n  }\n\n  void dfs(int current, int prev) {\n    prenum[current] = lowest[current] = timer;\n    timer++;\n    visited[current] = true;\n    for (int next: G[current]) {\n      if (!visited[next]) {\n        parent[next] = current;\n        dfs(next, current);\n        chmin(lowest[current], lowest[next]);\n        if (prenum[current] < lowest[next]) {\n          bd.insert({min(current, next), max(current, next)});\n        }\n      }\n      else if (next != prev) {\n        chmin(lowest[current], prenum[next]);\n      }\n    }\n  }\n\n  void find() {\n    dfs(0, -1);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> G(n);\n  rep(i, m) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n\n  Bridges bd(n ,G);\n  auto ans = bd.bd;\n  for (auto x: ans) cout << x.first << ' ' << x.second << '\\n';\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\nint pa[maxn];\nint vis[maxn],low[maxn],dfn[maxn];\nint ind ;\nvector<int> g[maxn];\nvoid tarjan(int u,int p)\n{\n    dfn[u]=low[u]=++ind;\n    vis[u]=1;\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(v==p) continue;\n        if(!vis[v])\n        {\n            tarjan(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u]<low[v])\n                pa[u]=v;\n        }\n        else low[u]=min(low[u],dfn[v]);\n    }\n}\nint v,e;\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    tarjan(0,-1);\n    for(int i=0;i<v;i++)\n    {\n        if(pa[i]!=0)\n            printf(\"%d %d\\n\",i,pa[i]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct node {int to,cost; };\n\ntypedef vector< vector<node> > G;\n\ninline void add_edge(G& g,int from,int to,int cost=1){\n\tnode in; in.to=to; in.cost=cost;\n\tg[from].pb(in);\n}\n\ninline void add_both_edge(G& g,int from,int to,int cost=1){\t\n\tadd_edge(g,from,to,cost);\n\tadd_edge(g,to,from,cost);\n}\n\nvoid dfs(const G& g,int cur,int prev,int &k,vi& order, vi& low,vi& parent) {\n\torder[cur]=k++;\n\tlow[cur]=order[cur];\n\n\trep(i,g[cur].size()){\n\t\tint to=g[cur][i].to;\n\t\tif(order[to]==-1){\n\t\t\tparent[to]=cur;\n\t\t\tdfs(g,to,cur,k,order,low,parent);\n\t\t\tlow[cur]=min(low[cur],low[to]);\n\t\t}else if(to!=prev)\n\t\t\tlow[cur]=min(low[cur],order[to]);\n\t}\n\treturn;\n}\n\nvoid Lowlink(const G& g, vi& order,vi& low,vi& parent) {\n\tint v=g.size();\n\torder.assign(v,-1);\n\tlow.resize(v);\n\tparent.resize(v);\n\tint k=0;\n\tparent[0]=-1;\n\tdfs(g,0,-1,k,order,low,parent);\n\treturn ;\n}\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\tG graph(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_both_edge(graph,a,b);\n\t}\n\tvi order,low,parent;\n\tLowlink(graph,order,low,parent);\n\n\t/*rep(i,n){\n\t\tif(i){\n\t\t\tbool ok=false;\n\t\t\trep(j,graph[i].size()){\n\t\t\t\tint to=graph[i][j].to;\n\t\t\t\tif(i==parent[to]&&order[i]<=low[to])\n\t\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(ok) cout << i << endl;\n\t\t}else{\n\t\t\tint d=0;\n\t\t\trep(j,n) if(parent[j]==0) d++;\n\t\t\tif(d>=2) cout << i << endl;\n\t\t}\n\t}*/\n\t\n\tvector<pii> res;\n\n\trep(i,n){\n\t\tint t=i,f=parent[i];\n\t\tif(f==-1) \n\t\t\tcontinue;\n\t\tif(t<=f)\n\t\t\tswap(f,t);\n\t\tif(order[f] < low[t] || order[t] < low[f] ){\n\t\t\tpii ok; ok.first=f; ok.second=t;\n\t\t\tres.pb(ok);\n\t\t}\n\t}\n\tsort(res.begin(),res.end());\n\teach(it,res) cout << (*it).first << \" \" << (*it).second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],DP[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nvector <pii> ans;\nbool mark[MAX_N];\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            DP[v]=min(DP[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            DP[v]=min(DP[v],DP[u]);\n        }\n    }\n    if(DP[v]>=depth[v]&&l!=-1)\n        ans.push_back({from[l],to[l]});\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    if(n==1)\n        return 0;\n    fill(DP,DP+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        from[i]=a,to[i]=b;\n        vec[a].push_back(i);\n        vec[b].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans.begin(),ans.end());\n    for(pii u:ans)\n        cout<<u.F<<\" \"<<u.S<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// ------ graph ------ //\nusing Weight = long long;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\nusing UnweightedGraph = vector<vector<int>>;\n\n// ------ Low-Link ------ //\nstruct LowLink {\n    vector<int> aps;                // articulation points\n    vector<pair<int, int>> brs;     // brides\n    vector<int> seen, ord, low;\n    int dfs(const UnweightedGraph &G, int u, int p = -1, int time = 0) {\n        seen[u] = true;\n        ord[u] = low[u] = time++;\n        bool exists = false;\n        int cnt_ch = 0;\n        for (auto v : G[u]) {\n            if (!seen[v]) {\n                ++cnt_ch;\n                time = dfs(G, v, u, time);\n                low[u] = min(low[u], low[v]);   // forward edge\n                if (ord[u] < low[v]) brs.emplace_back(u, v);\n                if (ord[u] <= low[v]) exists = true;\n            } else if (v != p) {\n                low[u] = min(low[u], ord[v]);   // back edge\n            }\n        }\n        if ((p == -1 && cnt_ch > 1) || (p != -1 && exists)) {\n            aps.emplace_back(u);\n        }\n        return time;\n    }\n    void solve(const UnweightedGraph &G) {\n        int N = G.size();\n        seen.assign(N, 0); ord.resize(N); low.resize(N);\n        aps.clear(); brs.clear();\n        for (int v = 0; v < N; ++v) if (!seen[v]) dfs(G, v);\n        for (auto &br: brs) if (br.first > br.second) swap(br.first, br.second);\n        sort(brs.begin(), brs.end());\n        sort(aps.begin(), aps.end());\n    }\n};\n\nint main() {\n    int V, E; cin >> V >> E;\n    UnweightedGraph G(V);\n    while (E--) {\n        int s, t; cin >> s >> t;\n        G[s].emplace_back(t);\n        G[t].emplace_back(s);\n    }\n    LowLink ll;\n    ll.solve(G);\n\n    for (auto b: ll.brs) cout << b.first << \" \" << b.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 100010\n\nvector<int> G[MAX_N];\nint n,m;\nint num[MAX_N],par[MAX_N],low[MAX_N];\nint cnt;\nvector<pair<int,int> > res;\n\nvoid dfs(int v,int prev){\n\tnum[v]=low[v]=++cnt;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i];\n\t\tif(num[nv]==-1){\n\t\t\tpar[nv]=v;\n\t\t\tdfs(nv,v);\n\t\t\tlow[v]=min(low[v],low[nv]);\n\t\t\tif(num[v]<low[nv]){\n\t\t\t\tres.push_back(make_pair(min(v,nv),max(v,nv)));\n\t\t\t}\n\t\t}else if(nv!=prev){\n\t\t\tlow[v]=min(low[v],num[nv]);\n\t\t}\n\t}\n}\n\nvoid bridge(){\n\tmemset(num,-1,sizeof(num));\n\tcnt=0;\n\tdfs(0,-1);\n\tsort(res.begin(),res.end());\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tG[a].pb(b); G[b].pb(a);\n\t}\n\tbridge();\n\trep(i,res.size()){\n\t\tcout<<res[i].fi<<\" \"<<res[i].se<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nvector<pair<int,int>> bridges;\nvector<int> graph[100000];\nint ord[100000],low[100000];\nbool visited[100000];\n\nint visit_time = 0;\n\nvoid dfs(int v,int p){\n  visited[v] = true;\n  ord[v] = visit_time;\n  low[v] = ord[v];\n  visit_time++;\n  for(int i=0;i<graph[v].size();++i){\n    if(!visited[graph[v][i]]){\n      dfs(graph[v][i],v);\n      low[v] = min(low[v],low[graph[v][i]]);\n      if(ord[v] < low[graph[v][i]]){\n        int s = v, t = graph[v][i];\n        if(s > t) swap(s,t);\n        bridges.emplace_back(s,t);\n      }\n    }else if(graph[v][i]!=p){\n      low[v] = min(low[v],ord[graph[v][i]]);\n    }\n  }\n\n}\n\nint main(){\n  int N , M ;\n  cin >> N >> M;\n  for(int i=0;i<M;++i){\n    int s,t;\n    cin >> s >> t;\n    graph[s].push_back(t);   \n    graph[t].push_back(s);\n  }\n  \n  for(int i=0;i<N;++i){\n    if(!visited[i]) dfs(i,-1);\n  }\n  \n  sort(bridges.begin(),bridges.end());\n  for(const auto &b:bridges){\n    cout << b.first << \" \" << b.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\n\nclass LowLink {\n    const int N;\n    vector<vector<int>> G;\n    set<int> used_v;\n    vector<int> ord, low, parent;\n\n    void dfs(int v, int &k)\n    {\n        used_v.insert(v);\n        ord[v] = low[v] = k++;\n\n        for (auto u : G[v]) {\n            if (!used_v.count(u)) {\n                parent[u] = v;\n                dfs(u, k);\n                low[v] = min(low[v], low[u]);\n            } else if (u != parent[v]) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n\n    void calc_lowlink()\n    {\n        int k = 0;\n        dfs(0, k);\n    }\n\npublic:\n    LowLink(int _N) : N(_N), G(_N), ord(_N), low(_N), parent(_N) {}\n\n    vector<int> articulation_point()\n    {\n        vector<int> res;\n\n        parent[0] = -1;\n        calc_lowlink();\n\n        int root_deg = 0;\n        for (int i=1; i<N; i++) {\n            int p = parent[i];\n            if (p == 0) root_deg++;\n            else if (ord[p] <= low[i]) {\n                res.push_back(p);\n            }\n        }\n\n        if (root_deg > 1) res.push_back(0);\n        sort(res.begin(), res.end());\n        res.erase(unique(res.begin(), res.end()), res.end());\n\n        return res;\n    }\n\n    vector<PII> bridge()\n    {\n        vector<PII> res;\n        calc_lowlink();\n        for (int v=0; v<N; v++) {\n            for (auto u : G[v]) {\n                if (ord[v] < low[u]) {\n                    res.emplace_back(min(v, u), max(v, u));\n                }\n            }\n        }\n        return res;\n    }\n\n    void add_edge(int u, int v)\n    {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n};\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n\n    LowLink LL(N);\n\n    rep(i, M) {\n        int U, V;\n        cin >> U >> V;\n        LL.add_edge(U, V);\n    }\n\n    vector<PII> b = LL.bridge();\n    for (auto a : b) cout << a.first << \" \" << a.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d, vector<int> &depth, vector<int> &lowlink, vector<bool> &visited){\n    visited[u] = true;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1, depth, lowlink, visited);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    for(int i=0; i<V; i++)\n        sort(G[i].begin(), G[i].end());\n    \n    vector<int> depth(V, -1), lowlink(V, -1);\n    vector<bool> visited(V, false);\n    dfs(G, -1, 0, 0, depth, lowlink, visited);\n    \n    for(int s=0; s<V; s++){\n        for(auto t: G[s]) if(s<t && (depth[s]<lowlink[t])){\n            cout << s << \" \" << t << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int ord, low;\n};\n\nclass BridgeFind{\npublic:\n  BridgeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  vector<pii> find(){\n    if(v_ord == 0)dfs();\n    return bridge;\n  }\nprivate:\n  void dfs(int v  = 0,\n           int previous = -1){\n    node[v].ord = node[v].low = v_ord++;\n    int to;\n    for (int i = 0; i < g[v].size(); i++) {\n      to = g[v][i];\n      if(previous == to)continue;\n      if(node[to].ord == -1) dfs(to, v);\n      node[v].low = min(node[v].low, node[to].low);\n    }\n    if(node[v].low == node[v].ord and previous != -1)\n      bridge.emplace_back(pii(previous, v));\n  }\n  int v_ord = 0;\n  vector<pii> bridge;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BridgeFind bf(g);\n  vector<pii> bridge = bf.find();\n  sort(bridge.begin(), bridge.end());\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tint tmr = 0;\n\tvector<int> ord(n, -1), low(n, -1);\n\tvector<pair<int, int>> bdg;\n\tfunction<void(int, int)> dfs = [&] (\n\t\tint crr\n\t,\tint prt\n\t) {\n\t\tord[crr] = low[crr] = tmr++;\n\t\tfor (int nxt : grh[crr]) {\n\t\t\tif (ord[nxt] == -1) dfs(nxt, crr);\n\t\t\tif (nxt != prt) chmin(low[crr], low[nxt]);\n\t\t\tif (ord[crr] < low[nxt]) bdg.emplace_back(crr, nxt);\n\t\t}\n\t};\n\tdfs(0, 0);\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tif (it->first > it->second) swap(it->first, it->second);\n\t}\n\tsort(bdg.begin(), bdg.end());\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << flush;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ??£??\\???????????§??¨????????????????????°??????\n\n// static?????°??????????????? ??? ??¢??°?????????????????????????????????\n\n#include<algorithm>\n#include<functional>\n#include<set>\n#include<stack>\n#include<queue>\n#include<vector>\n\nusing Weight = int;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// ?????????????????????????????°?????? O(|E|)\nGraph reverse(const Graph& G) {\n  Graph H(G.size());\n  for(const auto& list: G) for(const auto& e: list) H[e.to].push_back({e.to, e.from, e.weight});\n  return H;\n}\n\n// ????????£??????????????????????????????????????? O(|V|)\nstd::vector<Vertex> connected_component(const Graph& G, Vertex v) {\n  static std::vector<bool> used(G.size());\n  used[v] = true;\n  std::vector<Vertex> S = {v};\n  for(const auto& e: G[v]) if(!used[e.to]) {\n    auto t = connected_component(G, e.to);\n    S.insert(end(S), begin(t), end(t));\n  }\n  return S;\n}\n\n// ??£????????????????§£ O(|V|)\nstd::vector<std::vector<Vertex>> connected_component(const Graph& G) {\n  std::vector<std::vector<int>> cc;\n  std::vector<bool> used(G.size());\n  for(int v = 0; v < G.size(); ++v) if(!used[v]) {\n    cc.push_back(connected_component(G, v));\n    for(auto w: cc.back()) used[w] = true;\n  }\n  return cc;\n}\n\n// ??????cur???????????£???????????????????????¢??????/???????????? O(|V| + |E|)\n// ???cur???????????¨??????pre==cur?????????\n// ???cut_vertex??????????????????????????°?????\\???????????§?????????\nvoid lowlink(const Graph& G, Vertex cur, Vertex pre, std::vector<int>& cut_vertex, std::vector<Edge>& bridge) {\n  static std::vector<bool> used(G.size());\n  static std::vector<int> ord(G.size()), low(G.size());\n  static int timer = 1;\n  ord[cur] = low[cur] = timer++;\n  used[cur] = true;\n  for(const auto& e: G[cur]) if(e.to != pre) {\n    if(used[e.to]) {\n      low[cur] = std::min(low[cur], ord[e.to]);\n    } else {\n      lowlink(G, e.to, cur, cut_vertex, bridge);\n      low[cur] = std::min(low[cur], low[e.to]);\n      if(cur == pre) if(ord[cur]+1 < ord[e.to]) cut_vertex.push_back(cur);\n      if(cur != pre) if(ord[cur] <= low[e.to])  cut_vertex.push_back(cur);\n      if(ord[cur] < low[e.to])                  bridge.push_back(e);\n    }\n  }\n}\n\n// ?????£?????????????§£ O(|V| + |E|)\nvoid Tarjan(const Graph& G, Vertex v, std::vector<std::vector<Vertex>>& scc) {\n  static std::stack<Vertex> S;\n  static std::vector<bool> inS(G.size());\n  static std::vector<int> ord(G.size()), low(G.size());\n  static int timer = 1;\n  ord[v] = low[v] = timer++;\n  S.push(v);\n  inS[v] = true;\n  for(const auto& e: G[v]) {\n    if(!ord[e.to]) {\n      Tarjan(G, e.to, scc);\n      low[v] = std::min(low[v], low[e.to]);\n    } else if(inS[e.to]) {\n      low[v] = std::min(ord[v], low[e.to]);\n    }\n  }\n  if(ord[v] == low[v]) {\n    scc.push_back(std::vector<int>());\n    while(true) {\n      Vertex w = S.top();\n      S.pop();\n      inS[w] = false;\n      scc.back().push_back(w);\n      if(v == w) break;\n    }\n  }\n}\nstd::vector<std::vector<Vertex>> Tarjan(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  for(int v = 0; v < G.size(); ++v) Tarjan(G, v, scc);\n  return scc;\n}\n\n// ???????§???????????????? O(|E| + |V| log |V|)\nstd::vector<Weight> Dijkstra(const Graph& G, Vertex s) {\n  std::vector<Weight> d(G.size(), -1);\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge,Edge)>> q([](Edge lhs, Edge rhs){return lhs.weight > rhs.weight;});\n  q.push({s, s, 0});\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(d[cur.to] != -1) continue;\n    d[cur.to] = cur.weight;\n    for(const auto& nex: G[cur.to]) if(d[nex.to] != -1) q.push({cur.to, nex.to, cur.weight + nex.weight});\n  }\n  return d;\n}\n\n// ???????????? O(|E| + |V|^3)\nstd::vector<std::vector<Weight>> WarshallFloyd(const Graph& G) {\n  std::vector<std::vector<Weight>> d(G.size(), std::vector<Weight>(G.size(), -1));\n  for(int v = 0; v < G.size(); ++v) {\n    d[v][v] = 0;\n    for(const auto& e: G[v]) {\n      if(d[e.from][e.to] == -1) d[e.from][e.to] = e.weight;\n      else                      d[e.from][e.to] = std::min(d[e.from][e.to], e.weight);\n    }\n  }\n  for(int i = 0; i < G.size(); ++i) for(int j = 0; j < G.size(); ++j) for(int k = 0; k < G.size(); ++k) {\n    if(d[i][k] != -1 && d[k][j] != -1) {\n      if(d[i][j] == -1) d[i][j] = d[i][k] + d[k][j];\n      else              d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n  return d;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back({s, t, 0});\n    G[t].push_back({t, s, 0});\n  }\n\n  vector<int> cut_vertex;\n  vector<Edge> bridge;\n  for(auto S: connected_component(G)) lowlink(G, S.front(), S.front(), cut_vertex, bridge);\n\n//   set<int> S(begin(cut_vertex), end(cut_vertex));\n//   for(auto v: S) cout << v << endl;\n\n  set<Edge, function<bool(Edge,Edge)>> S(begin(bridge), end(bridge), [](Edge lhs, Edge rhs){\n    if(lhs.from != rhs.from) return lhs.from < rhs.from;\n    if(lhs.to != rhs.to) return lhs.to < rhs.to;\n    return lhs.weight < rhs.weight;\n  });\n  for(auto e: S) cout << e.from << \" \" << e.to << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\nint low[maxn];\nint vis[maxn],lv[maxn];\nvector<int> E[maxn];\nset<pair<int,int> > bridge;\nmap<pair<int,int>,int> V;\n/* \n1.if there are parellel lines, can't use fa.\n\n */\nvoid dfs(int now,int curlv,int fa){\n    low[now]=curlv;\n    lv[now]=curlv;\n    vis[now]=1;\n    int son_cnt=0;\n    for(auto v:E[now]){\n        //1.tree edge to fa, or back edge visited by now's descendant\n        if(v==fa)continue;\n        //2.back edge to now's ancestor\n        if(vis[v]) low[now]=min(low[now],lv[v]);\n        //3.tree edge to son.\n        else{\n            son_cnt++;\n            dfs(v,curlv+1,now);\n            low[now]=min(low[now],low[v]);\n            if(low[v]>lv[now]){\n                bridge.insert({min(now,v),max(now,v)});\n            }\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,m;\n    cin>>n>>m;\n    rep(i,1,m){\n        int x,y;\n        cin>>x>>y;\n        E[x].push_back(y);\n        E[y].push_back(x);\n    }\n    rep(i,0,n-1)if(!vis[i])dfs(i,0,-1);\n   // rep(i,0,n-1)debug(i),debug(low[i]);\n    for(auto e:bridge)cout<<e.first<<' '<<e.second<<endl;\n}\n/* \n4 4\n0 1\n0 2\n1 2\n2 3\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair <int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\nint n, e, t1, t2, timer, st[100005], nd[100005], low[100005];\nvector <int> v[100005];\nvector <pii> b;\n\nvoid dfs(int node, int p) {\n\tst[node] = timer++;\n\tlow[node] = st[node];\n\tfor (int i : v[node]) {\n\t\tif (i == p) continue;\n\t\tif (st[i] == INF) {\n\t\t\tdfs(i, node);\n\t\t\tlow[node] = min(low[node], low[i]);\n\t\t\tif (low[i] > st[node]) {\n\t\t\t\tb.push_back(make_pair(i, node));\n\t\t\t}\n\t\t}\n\t\telse if (nd[i] == INF) {\n\t\t\tlow[node] = min(low[node], low[i]);\n\t\t}\n\t}\n\tnd[node] = timer;\n}\n\nint main() {\n\tcin >> n >> e;\n\tfor (int i = 0; i < n; i++) st[i] = INF, nd[i] = INF;\n\tfor (int i = 0; i < e; i++) {\n\t\tcin >> t1 >> t2;\n\t\tv[t1].push_back(t2);\n\t\tv[t2].push_back(t1);\n\t}\n\tdfs(0, -1);\n//\tfor (int i = 0; i < n; i++) {\n//\t\tcout << st[i] << ' ' << nd[i] << ' ' << low[i] << endl;\n//\t}\n\tfor (int i = 0; i < b.size(); i++) if (b[i].fi > b[i].se) swap(b[i].fi, b[i].se);\n\tsort(b.begin(), b.end());\n\tfor (int i = 0; i < b.size(); i++) cout << b[i].fi << ' ' << b[i].se << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//TO CHANGE THE WORLD\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define L first\n#define R second\n\nconst int maxn=1e5+10;\n\nvector <int> adj[maxn];\nvector <pair<int, int> > ed;\nbool mark[maxn];\nint h[maxn], up[maxn], par[maxn];\n\nvoid dfs(int x)\n{\n    up[x]=h[x];\n    mark[x]=true;\n    for(int i=0; i<adj[x].size(); i++)\n    {\n        int child=adj[x][i];\n        if(!mark[child])\n        {\n            par[child]=x;\n            h[child]=h[x]+1;\n            dfs(child);\n            up[x]=min(up[x],up[child]);\n        }\n        else if(child!=par[x])\n            up[x]=min(up[x],h[child]);\n    }\n}\n\nint main()\n{\n    int n,m;\n    vector <pair <int, int> > ans;\n    cin>>n>>m;\n    for(int i=0; i<m; i++)\n    {\n        int fi,se;\n        cin>>fi>>se;\n        adj[fi].pb(se);\n        adj[se].pb(fi);\n        if(fi>se)\n            swap(fi,se);\n        ed.pb(mp(fi,se));\n    }\n    dfs(0);\n    for(int i=0; i<m; i++)\n    {\n        int fi=ed[i].L, se=ed[i].R;\n        if(h[fi]>h[se])\n            swap(fi,se);\n        if(up[se]>=h[se])\n            ans.pb(mp(min(fi,se), max(fi,se)));\n    }\n    sort(ans.begin(), ans.end());\n    for(int i=0; i<ans.size(); i++)\n        cout<<ans[i].L<<\" \"<<ans[i].R<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph {\n  size_t n;\n  int cnt;\n  vector<vector<int>> g;\n  vector<bool> isArt;\n  vector<int> ord, low;\n  vector<pair<int, int>> bridges;\n\n  Graph(size_t n) : n(n), cnt(0), g(n), ord(n, -1), low(n, -1), isArt(n, false) {}\n\n  void addEdge(int u, int v) {\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  void dfs(int u, int p) {\n    ord[u] = low[u] = cnt++;\n    for (auto&& v : g[u]) {\n      if (ord[v] == -1) {\n        dfs(v, u);\n        low[u] = min(low[u], low[v]);\n        if (ord[u] <= low[v]) isArt[u] = (ord[u] > 0) || (ord[v] > 1);\n        if (ord[u] < low[v]) bridges.push_back({min(u, v), max(u, v)});\n      } else if (v != p) {\n        low[u] = min(low[u], ord[v]);\n      }\n    }\n  }\n  void biconnectedComponents() {\n    for (int i = 0; i < static_cast<int>(n); ++i) {\n      if (ord[i] == -1) dfs(i, -1);\n    }\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m; cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int s, t; cin >> s >> t;\n    g.addEdge(s, t);\n  }\n  g.biconnectedComponents();\n\n  sort(begin(g.bridges), end(g.bridges));\n  for (auto&& p : g.bridges) {\n    cout << p.first << ' ' << p.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nvector<vector<int>> to;\nvector<int> ord, low;\nvector<bool> is_articulation;\nvector<pair<int, int>> bridge;\nint num = 0;\n\nvoid dfs(int v, int p=-1) {\n    ord[v] = num++;\n    low[v] = ord[v];\n    int child = 0;\n    for (auto u : to[v]) {\n        if (ord[u] == -1) {\n            child++;\n            dfs(u, v);\n            low[v] = min(low[v], low[u]);\n            if (p != -1 && ord[v] <= low[u]) is_articulation[v] = true;\n            if (ord[v] < low[u]) bridge.emplace_back(min(v, u), max(v, u));\n        } else if (u != p) {\n            low[v] = min(low[v], ord[u]);\n        }\n    }\n    if (p == -1 && child >= 2) is_articulation[v] = true;\n}\n\nvoid lowlink(int v) {\n    ord.resize(v, -1);\n    low.resize(v);\n    is_articulation.resize(v);\n    dfs(0);\n    sort(bridge.begin(), bridge.end());\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int v, e;\n    cin >> v >> e;\n    to.resize(v);\n    rep(i, e) {\n        int s, t;\n        cin >> s >> t;\n        to[s].pb(t);\n        to[t].pb(s);\n    }\n    lowlink(v);\n    rep(i, sz(bridge)) cout << bridge[i].fi << \" \" << bridge[i].se << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-12L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        c /= hoge;\n        d /= hoge;\n        if (d < 0) {\n            d *= -1;\n            c *= -1;\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        return a * rhs.b < rhs.a * b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL){\n    \n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\nfor (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<int> table;\n    vector<int> Pattern;\n    KMP(vector<int> a){\n        build(a);\n    }\n    void build(vector<int> a) {\n        Pattern = a;\n        table = vector<int>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0&&Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<int> search(vector<int> a) {\n        vector<int> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(200);\n}\n\n#define int ll\nvector<pair<int,int>> vertexs[300000];\nint bads[300000];\nint dist[300000];\nint backs[300000];\nint itr = 0;\nint dfs(int now,int back) {\n    dist[now] = itr;\n    backs[now] = dist[now];\n    itr++;\n    for (auto& x : vertexs[now]) {\n        if (x.first == back) continue;\n        if (dist[x.first] == 1e9) {\n            int hoge = dfs(x.first, now);\n            if (hoge == 1) {\n                bads[x.second] = 1;\n            }\n        }\n        backs[now] = min(backs[now], backs[x.first]);\n    }\n    return dist[now] == backs[now];\n}\n\n\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> edges;\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        //a--; b--;\n        if (a > b) swap(a, b);\n        edges.push_back(mp(a, b));\n        vertexs[a].push_back(mp(b, i));\n        vertexs[b].push_back(mp(a, i));\n    }\n    REP(i, n) {\n        dist[i] = 1e9;\n    }\n    REP(i, n) {\n        if (dist[i] != 1e9) continue;\n        dfs(i, -1);\n    }\n    REP(i, n) {\n        vertexs[i].clear();\n    }\n    vector<pair<int, int>> tmps;\n    REP(i, m) {\n        if (bads[i] == 1) {\n            tmps.push_back(edges[i]);\n            continue;\n        }\n        vertexs[edges[i].first].push_back(mp(edges[i].second, i));\n        vertexs[edges[i].second].push_back(mp(edges[i].first, i));\n    }\n    sort(ALL(tmps));\n    REP(i, tmps.size()) {\n        cout << tmps[i].first << \" \" << tmps[i].second << endl;\n    }\n    return;\n    REP(i, n) {\n        dist[i] = 0;\n    }\n    vector<int> ans;\n    REP(i, n) {\n        if (dist[i] != 0) continue;\n        set<int> gogos;\n        dist[i] = 1;\n        queue<int> next;\n        next.push(i);\n        int cnter = 0;\n        while (!next.empty()) {\n            int now = next.front();\n            next.pop();\n            cnter++;\n            for (auto& x : vertexs[now]) {\n                gogos.insert(x.second);\n                if (dist[x.first] == 0) {\n                    dist[x.first] = 1;\n                    next.push(x.first);\n                }\n            }\n        }\n        if (gogos.size() == cnter) {\n            for (auto& x : gogos) {\n                ans.push_back(x);\n            }\n        }\n    }\n    sort(ALL(ans));\n    cout << ans.size() << endl;\n    REP(i, ans.size()) {\n        cout << ans[i]+1 << \" \";\n    }\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\nusing namespace std;\n\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e15\n#define _INFLL (long long)-1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\nstruct graph_t {\n\tint n;           // |V|, index begins with 0\n\tint m;           // |E|\n\tvector<P> edges; // E\n\tvector<ll> cost; // cost or distance\n\tvector<ll> cap;  // capacity\n};\n\nclass Finding_Bridge {\nprivate:\n\tstruct node {\n\t\tint id; bool done; vi to_eid; vi to; int from_eid; int from; int pre; int low;\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint ord;\n\tvector<P> bridges_idpair;\n\tvi bridges_eid;\n\tvoid lowlink_dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tlowlink_dfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) {\n\t\t\t\t\tif (a < b) bridges_idpair.push_back({ a,b });\n\t\t\t\t\telse bridges_idpair.push_back({ b,a });\n\t\t\t\t\tbridges_eid.push_back(nodes[a].to_eid[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\npublic:\n\tFinding_Bridge(graph_t G) {\n\t\tn = G.n;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) nodes[i] = { i, false,{},{}, -1, -1, -1, -1 };\n\t\tLoop(i, G.edges.size()) {\n\t\t\tnodes[G.edges[i].first].to_eid.push_back(i);\n\t\t\tnodes[G.edges[i].first].to.push_back(G.edges[i].second);\n\t\t}\n\t\tord = 0;\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) lowlink_dfs(i, i);\n\t\t}\n\t\tsort(bridges_idpair.begin(), bridges_idpair.end());\n\t\tsort(bridges_eid.begin(), bridges_eid.end());\n\t}\n\tvector<P> get_bridges_idpair() {\n\t\treturn bridges_idpair;\n\t}\n\tvi get_bridges_eid() {\n\t\treturn bridges_eid;\n\t}\n};\n\n// prim sample\nint main() {\n\tgraph_t G;\n\tcin >> G.n >> G.m;\n\tLoop(i, G.m) {\n\t\tint s, t; cin >> s >> t;\n\t\tG.edges.push_back({ s, t });\n\t\tG.edges.push_back({ t, s });\n\t}\n\tFinding_Bridge finding_bridge(G);\n\tvector<P> bridges = finding_bridge.get_bridges_idpair();\n\tLoop(i, bridges.size()) {\n\t\tcout << bridges[i].first << \" \" << bridges[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass FindBridge {\npublic:\n    explicit FindBridge(const vector<vector<int>>& g) : ord(g.size(), -1), pre(g.size(), -1) {\n        int curOrder = 0;\n        search_(g, 0, -1, curOrder);\n        auto reorder = [](vector<pair<int, int>>& v){\n            for(auto& p : v){\n                if(p.first > p.second) swap(p.first, p.second);\n            }\n            sort(v.begin(), v.end());\n        };\n        reorder(bridge);\n        reorder(edge);\n    }\nprivate:\n    void search_(const vector<vector<int>>& g, int pos, int prev, int& curOrder){\n        ord[pos] = pre[pos] = curOrder;\n        ++curOrder;\n        for(auto& e : g[pos]){\n            if(e == prev) continue;\n            if(ord[e] == -1) search_(g, e, pos, curOrder);\n            if(ord[pos] < pre[e]){\n                bridge.emplace_back(pos, e);\n            } else {\n                edge.emplace_back(pos, e);\n            }\n            pre[pos] = min(pre[pos], pre[e]);\n        }\n    }\npublic:\n    const vector<pair<int, int>> getBridge() const { return bridge; }\n    const vector<pair<int, int>> getEdge() const { return edge; }\nprivate:\n    vector<int> ord;\n    vector<int> pre;\n    vector<pair<int, int>> bridge;\n    vector<pair<int, int>> edge;\n};\n\nint main(){\n    int n, m;\n    while(cin >> n >> m){\n        vector<vector<int>> g(n);\n        for(int i=0;i<m;i++){\n            int a, b; cin >> a >> b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        FindBridge b(g);\n        for(auto& e : b.getBridge()){\n            cout << e.first << \" \" << e.second << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n\nclass Node {\npublic:\n\tNode():number(i++), order(-1), min(0), edges(0), parent(0), art(false) {};\n\tvoid add_edge(Node *);\n\tstd::vector<Node*> &get_edge() { return edges; }\n\tbool operator==(const Node &other) { return number == other.number; }\n\tint order, min, number, parent;\n\tbool art;\n\tbool arti() { return art || edges.size() == 1; }\nprivate:\n\tstatic int i;\n\tstd::vector<Node*> edges;\n};\nint Node::i = 0 ;\nvoid Node::add_edge(Node *other) { edges.push_back(other); }\nint dfs(Node &current, int &order) {\n\tint min = order;\n\tint count = 0;\n\tfor (auto &node : current.get_edge()) {\n\t\tint temp;\n\t\tif (node->order == -1) {\n\t\t\tnode->order = ++order;\n\t\t\tnode->parent = current.number;\n\t\t\ttemp = dfs(*node, order);\n\t\t\tif (temp == current.order) {\n\t\t\t\tcurrent.art = true;\n\t\t\t}\n\n\t\t\t++count;\n\t\t}\n\t\telse {\n\t\t\ttemp = node->order;\n\t\t}\n\t\tif (min > temp) {\n\t\t\tmin = temp;\n\t\t}\n\t}\n\tif (current.number == 0) {\n\t\tif (count > 1) {\n\t\t\tcurrent.art = true;\n\t\t}\n\t\telse {\n\t\t\tcurrent.art = false;\n\t\t}\n\t}\n\tcurrent.min = min;\n\treturn min;\n}\nclass Edge {\npublic:\n\tEdge(const int &sn = 0, const int &tn = 0, Node *s = nullptr, Node *e = nullptr) : s_num(sn), t_num(tn), start{ s }, end{ e }, number(i++) {};\n\tbool suspect() { return (start->arti() && end->arti()) && (start->parent == end->number || start->number == end->parent); }\n\tbool operator<(const Edge &other) { return (s_num < other.s_num) || (s_num == other.s_num && t_num < other.t_num); }\n\tvoid show() { std::cout << s_num << \" \" << t_num << \"\\n\"; }\nprivate:\n\tNode *start, *end;\n\tint s_num, t_num, number;\n\tstatic int i;\n};\nint Edge::i(0);\nvoid sort(std::vector<Edge> &vector, const int left, const int right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (vector.at(l) < pivot)++l;\n\t\t\twhile (pivot < vector.at(r))--r;\n\t\t\tif (l <= r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, l, right);\n\t}\n}\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tstd::vector<Node> node(v);\n\tstd::vector<Edge> edge(e);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\t\tedge.at(i) = Edge(s, t, &node.at(s), &node.at(t));\n\t\tnode.at(s).add_edge(&node.at(t));\n\t\tnode.at(t).add_edge(&node.at(s));\n\t}\n\tnode.at(0).order = 0;\n\tint order = 0;\n\tdfs(node.at(0), order);\n\tsort(edge, 0, edge.size() - 1);\n\tfor (auto v : node) {\n\t\t//std::cout << v.number << \"--art= \" << v.arti() << \"--min= \" << v.min << \"--order= \" << v.order << \"--parent= \" << v.parent << std::endl;\n\t}\n\tfor (auto e : edge) {\n\t\tif (e.suspect()) {\n\t\t\te.show();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\n//橋＋二重辺連結成分\n// verified by ACAC003D\n// http://judge.u-aizu.ac.jp/onlinejudge/creview.jsp?rid=899186&cid=ACAC003\nnamespace bridge{\n\ttypedef vector<vector<int>> Graph;\n    //O(V+E)\n\tclass Bridge{\n\tprivate:\n\t\tint N;Graph g;\n\t\tvector<int> ord,low;vector<bool> vis;\n\t\tvoid dfs(int v,int p,int &k){\n\t\t\tvis[v]=true;ord[v]=k++;low[v]=ord[v];\n\t\t\tbool isA=false;\n\t\t\tint ct=0;\n\t\t\tfor(int to :g[v]){\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tct++;\n\t\t\t\t\tdfs(to,v,k);\n\t\t\t\t\tlow[v]=min(low[v],low[to]);\n\t\t\t\t\tif(~p && ord[v] <= low[to]) isA = true;\n\t\t\t\t\tif(ord[v]<low[to])bridges.push_back(make_pair(min(v,to),max(v,to)));\n\t\t\t\t}else if(to != p){\n\t\t\t\t\tlow[v]=min(low[v],ord[to]);\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p==-1 && ct>1)isA=true;\n\t\t\tif(isA)articulations.push_back(v);\n\t\t}\n\tpublic:\n\t\tvector<pair<int,int>> bridges;vector<int> articulations;\n\t\tBridge(int N):N(N){\n\t\t\tg=Graph(N);ord=low=vector<int>(N);vis=vector<bool>(N);\n\t\t}\n\t\tvoid add_edge(int f,int t){\n\t\t\tg[f].push_back(t);g[t].push_back(f);\n\t\t}\n\t\tvoid bridge(){\n\t\t\tint k=0;\n\t\t\tREP(v,N)if(!vis[v])dfs(v,-1,k);\n\t\t}\n\t};\n}\nusing namespace bridge;\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint V,E;cin >> V >> E;\n\t\tBridge bg(V);\n\t\tREP(i,E){\n\t\t\tint s,t;cin >> s >> t;\n\t\t\tbg.add_edge(s,t);\n\t\t}\n\t\tbg.bridge();\n\t\tsort(ALL(bg.bridges));\n\t\tREP(i,bg.bridges.size())\n\t\t\tcout <<bg.bridges[i]<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include \"common.hpp\"\n// #include \"bridge_decomposition.hpp\"\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define fst first\n#define snd second\n\n#include <iostream>\nusing namespace std;\n\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nclass BridgeDecomposition{\n  std::vector<std::vector<int> >  G;\n  std::vector<int> ord;\n  std::vector<int> low;\n  std::vector<int> par;\n  void Dfs(int v, int &times);\n  \npublic:\n  std::vector<std::vector<int> > edge_group;\n  BridgeDecomposition(const std::vector<std::pair<int, int> > &es);\n};\n\nvoid BridgeDecomposition::Dfs(int v, int &times){\n  ord[v] = low[v] = times++;\n  for (int w : G[v]){\n    if (ord[w] == -1){\n      par[w] = v;\n      Dfs(w, times);\n      low[v] = min(low[v], low[w]);\n    } else if (w != par[v]){\n      low[v] = min(low[v], low[w]);\n    }\n  }\n}\n\nBridgeDecomposition::BridgeDecomposition(const vector<pair<int, int> > &es){\n  int V = 0;\n  for (const auto &e : es) V = max(V, max(e.fst, e.snd) + 1);\n  \n  ord = vector<int>(V, -1);\n  low = vector<int>(V, -1);\n  par = vector<int>(V, -1);\n  G   = vector<vector<int> >(V);\n  for (const auto &e : es){\n    G[e.fst].push_back(e.snd);\n    G[e.snd].push_back(e.fst);\n  }\n\n  int times = 0;\n  REP(v, V) if (ord[v] == -1){\n    Dfs(v, times);\n  }\n  \n  G.clear();\n  G = vector<vector<int> > (V);\n  \n  for (size_t i = 0; i < es.size(); i++){\n    pair<int, int> e = es[i];\n    if (par[e.snd] != e.fst) swap(e.fst, e.snd);\n    if (par[e.snd] != e.fst) continue;\n    if (low[e.snd] > ord[e.fst]){\n      edge_group.push_back(vector<int>(1, i));\n      // e is bridge!\n    } else {\n      G[e.fst].push_back(e.snd);\n      G[e.snd].push_back(e.fst);\n    }\n  }\n}\n\n\nint main(int argc, char *argv[])\n{\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<pair<int, int> > es;\n  REP(i, m){\n    cin >> u >> v;\n    if (u > v) swap(u, v);\n    es.emplace_back(u, v);\n  }\n  BridgeDecomposition bd(es);\n  vector<pair<int, int> > bs;\n  REP(i, bd.edge_group.size()) if (bd.edge_group[i].size() == 1) {\n    bs.push_back(es[bd.edge_group[i][0]]);\n  }\n  sort(bs.begin(), bs.end());\n  for (const auto &e : bs){\n    cout << e.fst << \" \" << e.snd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\nstruct bridge{\n\tvector<int>ord,low;\n\tvector<bool>art;\n\tvector<pair<int,int> >bridges;\n\tvector<vector<int> >G;\n\tbridge(int n_=0):ord(n_,-1),low(n_),art(n_,false),G(n_){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool operator[](int a){return art[a];}\n\tvoid dfs(int u,int p,int&cnt)\n\t{\n\t\tlow[u]=ord[u]=cnt++;\n\t\tfor(int&v:G[u])\n\t\t{\n\t\t\tif(ord[v]==-1)\n\t\t\t{\n\t\t\t\tdfs(v,u,cnt);\n\t\t\t\tlow[u]=min(low[u],low[v]);\n\t\t\t\tart[u]=art[u]|ord[u]<=low[v];\n\t\t\t\tif(ord[u]<low[v])bridges.push_back(u<v?make_pair(u,v):make_pair(v,u));\n\t\t\t}\n\t\t\telse if(v!=p)\n\t\t\t{\n\t\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tint k=1,cnt=0;\n\t\tlow[0]=ord[0]=0;\n\t\tfor(int&v:G[0])if(ord[v]==-1)\n\t\t{\n\t\t\tdfs(v,0,k);\n\t\t\tif(ord[0]<low[v])bridges.push_back(make_pair(0,v));\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>=2)art[0]=true;\n\t}\n};\n\nmain()\n{\n\tint n,m;cin>>n>>m;\n\tbridge P(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\tP.add_edge(a,b);\n\t}\n\tP.build();\n\tsort(P.bridges.begin(),P.bridges.end());\n\tfor(int i=0;i<P.bridges.size();i++)cout<<P.bridges[i].first<<\" \"<<P.bridges[i].second<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {\n    int from, to;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\n\nclass lowlink {\npublic:\n    lowlink(graph const& g, int root)\n        : ord(g.size()),\n          low(g.size())\n    {\n        const int N = g.size();\n        std::vector<bool> visited(N);\n        int cnt = 0;\n        for(int i=0; i<N; ++i) {\n            if(!visited[i]) {\n                dfs(i, -1, cnt, g, visited);\n            }\n        }\n    }\n\n    std::vector<int> get_articulation_points() const {\n        return articulation_points;\n    }\n\n    std::vector<edge> get_bridges() const {\n        return bridges;\n    }\n\nprivate:\n    void dfs(int v, int prev, int& cnt, graph const& g, std::vector<bool>& visited) {\n        visited[v] = true;\n        ord[v] = cnt++;\n        low[v] = ord[v];\n        bool is_articulation = false;\n        int cnt2 = 0;\n\n        for(auto& e : g[v]) {\n            if(e.to != prev && visited[e.to]) {\n                low[v] = min(low[v], ord[e.to]);\n            } else if(!visited[e.to]) {\n                cnt2++;\n                dfs(e.to, v, cnt, g, visited);\n                low[v] = min(low[v], low[e.to]);\n                if(prev != -1 && ord[v] <= low[e.to]) {\n                    is_articulation = true;\n                }\n                if(ord[v] < low[e.to]) {\n                    bridges.push_back(edge{min(v, e.to), max(v, e.to)});\n                }\n            }\n        }\n\n        if(prev == -1 && cnt2 > 1) {\n            is_articulation = true;\n        }\n        if(is_articulation) {\n            articulation_points.push_back(v);\n        }\n    }\n\nprivate:\n    std::vector<int> articulation_points;\n    std::vector<edge> bridges;\n    std::vector<int> ord;\n    std::vector<int> low;\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    graph g(V);\n    for(int i=0; i<E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(edge{s, t});\n        g[t].push_back(edge{t, s});\n    }\n    lowlink ans(g, 0);\n    auto es = ans.get_bridges();\n    sort(es.begin(), es.end(), [](auto const& e1, auto const& e2) {\n        if(e1.from == e2.from) {\n            return e1.to < e2.to;\n        }\n        return e1.from < e2.from;\n    });\n    for(auto e : es) {\n        cout << e.from << ' ' << e.to << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\nconst int E_MAX=100000;\n\nstruct edge{\n\tint from;\n\tint to;\n\tbool operator<( const edge& right ) const {\n        return from == right.from ? to < right.to : from < right.from;\n    }\n};\n\nvector<int> G[V_MAX];\nbool used_v[V_MAX]={};\nbool used_e[E_MAX][E_MAX]={};\nvector<int> pre(V_MAX,INT_MAX);\nvector<int> low(V_MAX,INT_MAX);\nvector<edge> result;\nint order;\n\nvoid dfs(int s,int p){\n\tif(used_v[s]==true){return;}\n\tused_v[s]=true;\n\tpre[s]=order;\n\tlow[s]=order;\n\torder++;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tused_e[s][G[s][i]]=true;\n\t\tif(!used_v[G[s][i]]){\n\t\t\tdfs(G[s][i],s);\n\t\t\tlow[s]=min(low[s],low[G[s][i]]);\n\t\t}else if(!used_e[G[s][i]][s]){\n\t\t\tlow[s]=min(low[s],pre[G[s][i]]);\n\t\t}\n\t}\n\tif(!(s==0 && p==0) && low[s]>pre[p]){\n\t\tedge e;\n\t\te.from=min(s,p);\n\t\te.to=max(s,p);\n\t\tresult.push_back(e); \n\t}\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tG[t].push_back(s);\n\t}\n\t\n\torder=0;\n\tdfs(0,0);\n\t\n\tsort(result.begin(),result.end());\n\tfor(int i=0;i<result.size();i++){\n\t\tcout << result[i].from << \" \" << result[i].to << endl;\n\t}\n\t/*\n\tfor(int i=0;i<V;i++){\n\t\tcout << pre[i] << \" \";\n\t}\n\tcout << endl;\n\t\n\tfor(int i=0;i<V;i++){\n\t\tcout << low[i] << \" \";\n\t}\n\tfor (int i=0;i<V;i++){\n\t\tfor (int j=0;j<V;j++){\n\t\t\tcout << used_e[i][j] <<\" \" ;\n\t\t}\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iomanip>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MAX=100005;\nconst int inf=1e9;\nvi G[MAX];\nint N;\nbool visited[MAX];\ntypedef pair<int,int> P;\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\nvoid dfs(int current,int prev)\n{\n  prenum[current]=lowest[current]=timer;\n  timer++;\n\n  visited[current]=true;\n  int next;\n  for(int i=0;i<G[current].size();i++)\n  {\n    next=G[current][i];\n    if(!visited[next])\n    {\n      parent[next]=current;\n      dfs(next,current);\n      lowest[current]=min(lowest[current],lowest[next]);\n      if(prenum[current]<lowest[next]) bridge.push_back(P(current,next));\n    }\n    else if(next!=prev)\n    {\n      lowest[current]=min(lowest[current],prenum[next]);\n    }\n  }\n}\n\nvoid bridge_points()\n{\n  timer=1;\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n  {\n    cout << bridge[i].first << ' ' << bridge[i].second << endl;\n  }\n}\n\nint main(void)\n{\n  int m;\n  cin >> N >> m;\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<m;i++)\n  {\n    int s,t;\n    cin >> s>> t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n  }\n  bridge_points();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <tuple>\n#include <bitset>\n#include <iostream>\n\n\nstruct union_find {\n  std::vector<int> par;\n  union_find(int N): par(N, -1) {}\n  int root(int x) {\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  std::tuple<int, int> unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return std::make_tuple(x, y);\n    if(par[x] > par[y]) std::swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return std::make_tuple(x, y);\n  }\n  int size(int x) {\n    return -par[root(x)];\n  }\n};\n\n#include <unistd.h>\n\nnamespace niu {\n\n  struct fastin {\n    static const int bufsize = 1 << 24;\n    char buf[bufsize];\n    char* iter;\n    fastin() {\n      iter = buf;\n      for(int t = 0, k; (k = read(STDIN_FILENO, buf + t, sizeof(buf)) - t) > 0; t += k);\n    }\n    fastin& operator>>(int& num) {\n      num = 0;\n      bool neg = false;\n      while(*iter < '+') iter++;\n      if(*iter == '-') { neg = true; iter++; }\n      else if(*iter == '+') iter++;\n      while(*iter >= '0') num = 10 * num + *(iter++) - '0';\n      if(neg) num = -num;\n      return *this;\n    } \n  } fin;\n  struct fastout {\n    static const int bufsize = 1 << 24;\n    char buf[bufsize];\n    char* iter;\n    fastout() {\n      iter = buf;\n    }\n    ~fastout() {\n      for(int t = 0, k; (k = write(STDOUT_FILENO, buf + t, iter - buf - t)) > 0; t += k);\n    }\n    fastout& operator<<(int num) {\n      static char tmp[20];\n      if(num == 0) {\n        *(iter++) = '0';\n        return *this;\n      }\n      if(num < 0) {\n        *(iter++) = '-';\n        num = -num;\n      }\n      int i = 0;\n      while(num) {\n        tmp[i++] = num % 10;\n        num /= 10;\n      }\n      while(i--) {\n        *(iter++) = tmp[i] + '0';\n      }\n      return *this;\n    }\n    fastout& operator<<(char c) {\n      *(iter++) = c;\n      return *this;\n    }\n  } fout;\n}\n\nstruct incremental_bridge_connectivity {\n  static const int MAX_N = 202020;\n  static const int MAX_E = 202020;\n  std::vector<int> par;\n  std::vector<std::pair<int, int>> edge;\n  std::bitset<MAX_N> bit;\n  std::bitset<MAX_E> bridge;\n  union_find cg;\n  union_find bcg;\n\n  incremental_bridge_connectivity(int N)\n    : par(N, -1), cg(N), bcg(N) {\n    }\n\n  int lca(int u, int v) {\n    bit = 0;\n    while(1) {\n      if(u >= 0) {\n        if(bit.test(u)) {\n          return u;\n        }\n        bit.set(u);\n        if(par[u] < 0) u = -1;\n        else u = edge[par[u]].second;\n      }\n      std::swap(u, v);\n    }\n  }\n\n  void compress_path(int v, int w) {\n    while(v != w) {\n      bcg.unite(v, w);\n      bridge.reset(par[v]);\n      v = edge[par[v]].second;\n    }\n  }\n\n  void reverse_path(int v, int p) {\n    while(true) {\n      std::swap(edge[p].first, edge[p].second);\n      std::swap(p, par[v]);\n      if(p < 0) break;\n      v = edge[p].second;\n    }\n  }\n\n  int add_edge(int u, int v) {\n    int ei = edge.size();\n    edge.emplace_back(u, v);\n    if(bcg.root(u) == bcg.root(v)) {\n    }\n    else if(cg.root(u) == cg.root(v)) {\n      int w = lca(u, v);\n      compress_path(u, w);\n      compress_path(v, w);\n    }\n    else {\n      bridge.set(ei);\n      if(cg.size(u) < cg.size(v)) {\n        std::swap(u, v);\n        std::swap(edge.back().first, edge.back().second);\n      }\n      reverse_path(v, ei);\n      cg.unite(u, v);\n    }\n    return ei;\n  }\n\n  int size(int v) {\n    return bcg.size(v);\n  }\n\n  bool is_bridge(int ei) {\n    return bridge.test(ei);\n  }\n};\n\n#include <algorithm>\n\nint main() {\n  int N, M;\n  niu::fin >> N >> M;\n  incremental_bridge_connectivity ibc(N);\n  for(int i =0;i < M;i++) {\n    int a, b;\n    niu::fin >> a >> b;\n    ibc.add_edge(a, b);\n  }\n  std::vector<std::pair<int , int>> ans;\n  for(int i = 0;i < M; i++) {\n    if(ibc.is_bridge(i)) {\n      ans.emplace_back(std::move(ibc.edge[i]));\n      if(ans.back().first > ans.back().second) {\n        std::swap(ans.back().first, ans.back().second);\n      }\n    }\n  }\n  std::sort(std::begin(ans), std::end(ans));\n  for(auto&& e: ans) {\n    niu::fout << e.first << ' ' << e.second << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n//#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nusing Edges = std::vector<std::vector<int>>;\n\nstruct Memo {\n    int cnt;\n    int parent;\n    int low;\n};\n\nint dfs(int i, const Edges& edges, std::vector<Memo>& memo, int& cnt) {\n    memo[i].cnt = cnt++;\n    int ans = memo[i].cnt;\n    for(auto v: edges[i]) {\n        if(memo[v].cnt < 0) {\n            memo[v].parent = i;\n            ans = std::min(ans, dfs(v, edges, memo, cnt));\n        } else {\n            if(v != memo[i].parent) ans = std::min(ans, memo[v].cnt);\n        }\n    }\n    memo[i].low = ans;\n    return ans;\n}\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    Edges edges(V, std::vector<int>());\n    while(E--) {\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n        edges[t].push_back(s);\n    }\n\n    std::vector<Memo> memo(V, Memo{-1, -1, -1});\n    int cnt = 0;\n    dfs(0, edges, memo, cnt);\n\n    std::vector<std::pair<int, int>> ans;\n    ans.reserve(V);\n    for(int i = 0; i < V; ++i) {\n        if(0 <= memo[i].parent && memo[memo[i].parent].cnt < memo[i].low) {\n            if(i < memo[i].parent) ans.push_back(std::make_pair(i, memo[i].parent));\n            else ans.push_back(std::make_pair(memo[i].parent, i));\n        }\n    }\n\n    std::sort(begin(ans), end(ans), [](auto x, auto y){return x.first == y.first ? x.second < y.second : x.first < y.first;});\n\n    for(auto val: ans) {\n        std::cout << val.first << \" \" << val.second << \"\\n\";\n    }\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n//??°?????????lowlink???????????????????????¢????????¨??????????????????\n//?¨??????? O(|V|+|E|)\nvoid lowlink(vector<int>graph[], int n, vector<int>&low, vector<pair<int, int>>&br, vector<int>&jnt) {\n\tlow.resize(n);\n\tvector<int>ord(n);//DFS?????????\n\tvector<bool>vis(n);//?¨???????????????????\n\t//?????°????????????\n\tfunction<void(int, int, int&)>dfs = [&](int v, int p, int &k) {\n\t\tvis[v] = true;\n\t\tord[v] = k++;\n\t\tlow[v] = ord[v];\n\t\tbool joint = false;\n\t\tint cnt = 0;\n\t\tfor (auto nxt : graph[v]) {\n\t\t\tif (!vis[nxt]) {\n\t\t\t\tcnt++;\n\t\t\t\tdfs(nxt, v, k);\n\t\t\t\tlow[v] = min(low[v], low[nxt]);\n\t\t\t\tif (p >= 0 && ord[v] <= low[nxt]) joint = true;\n\t\t\t\tif (ord[v] < low[nxt])br.push_back({ min(v,nxt),max(v,nxt) });\n\t\t\t}\n\t\t\telse if (nxt != p) {\n\t\t\t\tlow[v] = min(low[v], ord[nxt]);\n\t\t\t}\n\t\t}\n\t\tif (p < 0 && cnt > 1) joint = true;\n\t\tif (joint) jnt.push_back(v);\n\t};\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!vis[i])dfs(i, -1, k);\n}\n\nint N, M;\nvector<int>graph[123456];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgraph[s].push_back(t);\n\t\tgraph[t].push_back(s);\n\t}\n\tvector<int>low, jnt;\n\tvector<pair<int, int>>br;\n\tlowlink(graph, N, low, br, jnt);\n\tsort(br.begin(), br.end());\n\tfor (auto i : br) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = int64_t;\nconst int64_t MOD = 1e9+7;\nstruct LowLink {\n    struct edge {\n        int to, rev, used;\n        edge(int to, int rev) :\n            to(to), rev(rev), used(0) {}\n    };\n    // e.used: used for down in dfs.\n    vector<vector<edge>> g;\n    const int sz;\n    vector<int> ord, low, par;\n    vector<int> used, _is_articulation;\n    vector<int> articulations;\n    vector<pair<int,int>> bridges;\n    LowLink(int sz) :\n        sz(sz), g(sz), ord(sz), low(sz), used(sz),\n        par(sz), _is_articulation(sz) {}\n    void add_edge(int u, int v) {\n        g[u].emplace_back(v, (int)g[v].size());\n        g[v].emplace_back(u, (int)g[u].size() - 1);\n    }\n    void build() {\n        int k = 0;\n        for (int i = 0; i < sz; ++i) {\n            if (!used[i]) dfs(i, -1, k);\n        }\n    }\n    void dfs(int v, int p, int& k) {\n        used[v] = 1;\n        par[v] = p;\n        low[v] = ord[v] = k++;\n        int cnt = 0;\n        for (auto& e : g[v]) {\n            int to = e.to;\n            if (!used[to]) {\n                e.used = 1;\n                ++cnt;\n                dfs(to, v, k);\n                low[v] = min(low[v], low[to]);\n                _is_articulation[v] |= ord[v] <= low[to];\n                if (ord[v] < low[to]) {\n                    bridges.emplace_back(minmax(to, v));\n                }\n            } else if (!g[to][e.rev].used) {\n                low[v] = min(low[v], ord[to]);\n            }\n        }\n        if (p == -1) _is_articulation[v] = cnt > 1;\n        if (_is_articulation[v]) articulations.push_back(v);\n    }\n    bool is_articulation(int v) const { return _is_articulation[v]; }\n    bool is_bridge(int u, int v) const {\n        if (u != par[v] and v != par[u]) return false;\n        if (u == par[v]) swap(u, v);\n        return ord[v] < low[u];\n    }\n};\nint main()\n{\n    int V, E; cin >> V >> E;\n    LowLink lowlink(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t; cin >> s >> t;\n        lowlink.add_edge(s, t);\n    }\n    lowlink.build();\n    sort(lowlink.bridges.begin(), lowlink.bridges.end());\n    for (const auto& p : lowlink.bridges) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<int> G[100010];\nbool used[100010];\nint par[100010];\nint dep[100010];\nint low[100010];\n\nvoid dfs(int v,int p,int d){\n    used[v] = true;\n    par[v] = p;\n    dep[v] = d;\n    low[v] = d;\n    for(int i = 0 ; i < G[v].size() ; i ++){\n        if(G[v][i] == p)continue;\n        if(used[G[v][i]]){\n            low[v] = min ( low[v] , dep[G[v][i]] );\n        }\n        else {\n            dfs(G[v][i],v,d+1);\n            low[v] = min ( low[v] , low[G[v][i]] );\n        }\n    }\n}\n\nint main(){\n    int V,E;\n    int s[100010],t[100010];\n    scanf(\"%d%d\",&V,&E);\n    for(int i = 0 ; i < E ; i ++){\n        scanf(\"%d%d\",&s[i],&t[i]);\n        G[s[i]].push_back(t[i]);\n        G[t[i]].push_back(s[i]);\n    }\n    for(int i = 0 ; i < 100010 ; i ++){\n        used[i] = false;\n    }\n    dfs(0,-1,0);\n    \n    vector<pair<int,int>> ans;\n    for(int i = 0 ; i < E ; i ++){\n        if(par[s[i]] == t[i]){\n            if(low[s[i]] > dep[t[i]])ans.push_back(pair<int,int>(s[i],t[i]));\n        }\n        else if(par[t[i]] == s[i]){\n            if(low[t[i]] > dep[s[i]])ans.push_back(pair<int,int>(s[i],t[i]));\n        }\n    }\n    sort(ans.begin(),ans.end());\n    for(int i = 0 ; i < ans.size() ; i ++){\n        printf(\"%d %d%c\",ans[i].first,ans[i].second,10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nusing P = pair<int, int>;\nint ord[100000];\nint low[100000];\nint v, e;\n\nset<P> M;\nvector<int> Edge[100000];\nvector<bool> isNew(100000, true);\nset<P> U;\n\nbool isEdge(int s, int t) {\n\treturn M.end()!=M.find(P(s, t));\n}\nbool isUsed(int s, int t) {\n\treturn U.end()!=U.find(P(s, t));\n}\nvoid dfs(int u) {\n\tisNew[u] = false;\n\tstatic int k ;\n\tord[u] = k; k++;\n\t//cout << \"u=\" << u << \" k=\" << k << endl;\n\tlow[u] = ord[u];\n\tfor (int v : Edge[u]) {\n\t\tif (isNew[v]) {\n\t\t\tU.emplace(u, v); U.emplace(v, u);\n\t\t\tdfs(v);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t}\n\t\telse if (!isUsed(u, v)) {\n\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> v >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tM.emplace(s, t);\n\t\tM.emplace(t, s);\n\t\tEdge[s].push_back(t);\n\t\tEdge[t].push_back(s);\n\t}\n\tdfs(0);\n\t//for (P p : M) {\n\t//\tcout << p.first << \" \" << p.second << endl;\n\t//}\n\t//for (int i = 0; i < v; i++) {\n\t//\tcout << \"low=\" << low[v] << \" ord=\" << ord[v] << endl;\n\t//}\n\t//cout << endl;\n\tfor (P p : M) {\n\t\tif (ord[p.first] < low[p.second] || ord[p.first] < low[p.second]) {\n\t\t\tcout << p.first << \" \" << p.second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\n#define MAX_V 100005\nint V, E;\nvector<int> G[MAX_V];\nint depth[MAX_V];\nint cnt[MAX_V];\nint visited[MAX_V];\nvector<P> ans;\n\nvoid dfs(int pos, int prev){\n    visited[pos] = true;\n    for(int i = 0; i < (int)G[pos].size(); i++){\n        int to = G[pos][i];\n        if(to==prev)continue;\n        if(!visited[to]){\n            depth[to] = depth[pos] + 1;\n            dfs(to, pos);\n            cnt[pos]+=cnt[to];\n            if(cnt[to] == 0) ans.push_back(P(min(pos,to) , max(pos,to)));\n        }else if(depth[to] < depth[pos]){\n            cnt[pos]++;\n            cnt[to]--;\n        }\n    }\n}\n \nint main(){\n    scanf(\"%d %d\", &V, &E);\n    for(int i = 0; i < E; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(0,-1);\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < (int)ans.size(); i++) printf(\"%d %d\\n\",ans[i].first, ans[i].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        os << \"\\n\";\n    }\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << P.first;\n    os << \" \";\n    os << P.second;\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n    os<<endl;\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, map<T,S> const&M){\n    for(auto e:M){\n        os<<e;\n    }\n    os<<endl;\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\nstruct LowLink{\n    vector<bool> visited;\n    vector<vector<int>> edge;\n    vector<int> pre_order,low; //low[v]:=min{pre_order[u]|u==v or uがvの子孫(vを含む)に補木辺を持つ}\n    int N;\n    vector<int> articulation_points; //関節点:=2つ以上の2連結成分に含まれる点(=グラフから削除すると連結成分が一つ増えるような点)\n    vector<pair<int,int>> bridge; //橋:=グラフから削除すると連結成分が一つ増えるような辺\n    //O(N+M)\n    LowLink(vector<vector<int>>& edge):edge(edge){\n        N = edge.size();\n        visited.assign(N,false);\n        int order = 0; \n        pre_order.assign(N,0); low.assign(N,0);\n        for(int v=0;v<N;v++) dfs(v,-1,v,order);\n    }\n\n    void dfs(int v,int pre,int root,int& order){\n        if(visited[v]) return;\n        visited[v] = true;\n        \n        pre_order[v] = order++; \n        low[v] = pre_order[v];\n        int child_cnt = 0; \n        bool Art_flag = false;\n        for(auto to:edge[v]){\n            if(to==pre) continue;\n            if(visited[to])  low[v] = min(low[v], pre_order[to]);\n            else {\n                dfs(to,v,root,order);\n                low[v] = min(low[v], low[to]);\n                child_cnt++;\n                if(pre_order[v]<=low[to]) Art_flag=true;\n                if(pre_order[v] < low[to]) bridge.emplace_back(min(v,to), max(v,to));\n            }\n        }\n        if(v==root and child_cnt>=2) articulation_points.emplace_back(v);\n        if(v!=root and Art_flag) articulation_points.emplace_back(v);\n    }\n\n    //関節点を返す\n    vector<int> get_art_points(){\n        /*点vが関節点 <=>DFS木において\n            ・vが根なら子の数が複数\n            ・そうでなければ、vの子孫と先祖を結ぶ補木辺が存在しない*/\n        return articulation_points;\n    }\n\n    //橋を返す\n    vector<pair<int,int>> get_bridge(){\n        return bridge;\n    }\n\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int N,M;\n    cin >> N >> M;\n    vector<vector<int>> edge(N);\n    REP(i,M){\n        int a,b; cin >> a >> b;\n        edge[a].emplace_back(b);\n        edge[b].emplace_back(a);\n    }\n\n    LowLink LL(edge);\n    auto ans = LL.get_bridge();\n    sort(ALL(ans));\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define FOR(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\nstruct Edge {\n    int u;\n    int v;\n};\nbool operator< (const Edge& e1, const Edge& e2) {\n    return e1.u < e2.u || (e1.u == e2.u && e1.v < e2.v);\n};\ntypedef vector<vector<int> > Graph;\n\nvoid DFS(Graph &g, int u, int &clock, vector<int> &low, vector<int> &disc, vector<bool> &seen, vector<int> &parent, vector<Edge> &bridges) {\n    stack<int> s;\n    for(int v: g[u]) {\n        if (! seen[v]) {\n            clock++;\n\n            disc[v] = clock;\n            low[v] = clock;\n            seen[v] = true;\n            parent[v] = u;\n\n            DFS(g, v, clock, low, disc, seen, parent, bridges);\n\n            low[u] = min(low[u], low[v]);\n\n            if (low[v] > disc[u])\n                bridges.push_back(Edge{min(u, v), max(u, v)});\n        } else if (v != parent[u]) {\n            low[u]  = min(low[u], disc[v]);\n        }\n    }\n}\n\nint main () {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n    vector<Edge> bridges;\n\n    FOR(i,E) {\n        int s, t;\n        cin >> s >> t;\n\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    int clock = 2;\n    vector<int> low(V, 0);\n    vector<int> disc(V, 0);\n    vector<int> parent(V, -1);\n    vector<bool> seen(V, false);\n    disc[0] = 1;\n    low[0] = 1;\n    seen[0] = true;\n\n    DFS(g, 0, clock, low, disc, seen, parent, bridges);\n\n    sort(bridges.begin(), bridges.end());\n\n    for(Edge e: bridges)\n        cout << e.u << \" \" << e.v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define dhoom ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);  \ntypedef long long ll;\n#define SIZE 100005\nvector< int > graph[SIZE];\nvector< pair< int , int > > ans;\nvector< int > vis(SIZE,0);\nvector< int > low(SIZE,0);\nvector< int > tin(SIZE , 0);\n\nint timer;\nvoid dfs(int u , int p = -1){\n\tvis[u] = true;\n\ttin[u] = low[u] = timer++;\n\tint children = 0;\n\tfor(auto it : graph[u]){\n\t\t\tif(it == p) continue;\n\t\t\tif(vis[it] == 1)\n\t\t\t\tlow[u] = min(low[u] , tin[it]);\n\t\t\telse{\n\t\t\t\tdfs(it , u);\n\t\t\t\tlow[u] = min(low[u] , low[it]);\n\t\t\t\tif(low[it] > tin[u])\n\t\t\t\t\tit > u ? ans.push_back({u, it}) : ans.push_back({it,u});\n\t\t\t\tchildren++;\n\t\t\t}\n\t}\n}\nint main(){\n\tdhoom;\n\tint n , m;\n\tcin >> n >> m;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint x , y ;\n\t\tcin >> x >> y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(!vis[i])\n\t\t\t\tdfs(i);\n\t}\n\tsort(ans.begin() , ans.end());\n\tans.erase(unique(ans.begin() , ans.end()), ans.end());\n\tfor(int i = 0 ; i < (int) ans.size() ; i++)\t\n\t\tcout << ans[i].first<< \" \" << ans[i].second << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define int long long\n#define vec(a,n) vector<int> (a)((n));\n#define Vec(a,n) vector<string> (a)((n));\n#define twovec(a,n,m) vector<vector<int>> a(n,vector<int>(m,0));\n#define Twovec(a,n,m) vector<vector<double>> a(n,vector<double>(m,0));\n#define P pair<int,int>\n#define All(a) (a).begin(),(a).end()\n#define Sort(a) sort(All(a));\n#define Reverse(a) reverse(All(a));\n#define PQ(n) priority_queue<P,vector<P>,greater<P>> (n)\n#define pq(n) priority_queue<int> (n)\n#define print(a) cout << (a) << endl\n#define printD(a) cout << setprecision(15) << (a) << endl;\nusing namespace std;\nint max_int = 2147483647;\nint prime = 10e9+7;\nvoid Debug(auto a);\nint nibul(auto a,auto b);\nint nibuu(auto a,auto b);\nvoid input(vector<auto>& a,int n);\ndouble PI = 3.14159265358979;\nint n;\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n    vector<int> siz;\n\n    UnionFind(int N) : par(N), siz(N, 1LL) { //最初は全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        par[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n        if (siz[rx] < siz[ry]) swap(rx, ry);\n        siz[rx] += siz[ry];\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n    int size(int x) { // 素集合のサイズ\n        return siz[root(x)];\n    }\n};\n\nstruct Edge{\n    int from,to,cost;\n    bool operator<(const Edge& another) const{\n        return cost < another.cost;\n    }\n    bool operator>(const Edge& another) const{\n        return cost > another.cost;\n    }\n};\n\nclass uGrapf{\n    vector<vector<P>> grapf;\n    vector<int> d,ord,low;\n    vector<P> _bridge;\n    bool loop = false;\n    public:\n    uGrapf(int n){\n        this->grapf.resize(n);\n        this->d.resize(grapf.size(),max_int);\n    }\n    uGrapf(){\n        this->grapf.resize(10e6);\n        this->d.resize(grapf.size(),max_int);\n    }\n    /* 辺の二つ、コストの順\n     */\n    void edge(int edge1,int edge2,int weight=1){\n        P p = P(edge2,weight);\n        grapf[edge1].push_back(p);\n        p = P(edge1,weight);\n        grapf[edge2].push_back(p);\n    }\n    void dijkstra(int n){\n        d[n] = 0;\n        PQ(que);\n        que.emplace(0,n);\n        while(!que.empty()){\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(P e: grapf[v]){\n                if(d[e.first] > d[v]+e.second){\n                    d[e.first] = d[v]+e.second;\n                    que.emplace(d[e.first],e.first);\n                }\n            }\n        }\n    }\n    void bellmanford(int n){\n        fill(d.begin(), d.end(), max_int);\n        d[n] = 0;\n        bool update = true;\n        int cnt = 0;\n        while(update){\n            update = false;\n            REP(i,grapf.size()){\n                REP(j,grapf[i].size()){\n                    if(d[i] != max_int && d[grapf[i][j].first] > d[i] + grapf[i][j].second){\n                        d[grapf[i][j].first] = d[i] + grapf[i][j].second;\n                        update = true;\n                    }\n                }\n            }\n            cnt++;\n            if(cnt > grapf.size()){\n                loop = true;\n                return;\n            }\n        }\n    }\n    int prim(int n){\n        UnionFind uf(grapf.size());\n        priority_queue<Edge,vector<Edge>,greater<Edge>> que;\n        Edge e;\n        REP(i,grapf[n].size()){\n            e.from = n;e.to = grapf[n][i].first;e.cost = grapf[n][i].second;\n            que.push(e);\n        }\n        int cnt = 0;\n        while(!que.empty()){\n            e = que.top();\n            que.pop();\n            if(!uf.same(e.from,e.to)){\n                uf.unite(e.from,e.to);\n                cnt += e.cost;\n                REP(i,grapf[e.to].size()){\n                    if(!uf.same(e.to,grapf[e.to][i].first)){\n                        Edge tmp;\n                        tmp.from = e.to;tmp.to = grapf[e.to][i].first;tmp.cost = grapf[e.to][i].second;\n                        que.push(tmp);\n                    }\n                }\n            }\n        }\n        return cnt;\n    }\n    void dfs(int v,int p,int &k,vector<int> &ret){\n        ord[v] = k++;\n        low[v] = ord[v];\n        low[n] = ord[n];\n        int cnt=0;\n        bool is_articulation = false;\n        for(auto to: grapf[v]){\n            if(ord[to.first]==-1){\n                dfs(to.first,v,k,ret);\n                if(low[v]>low[to.first]){\n                    low[v] = low[to.first];\n                }\n                cnt++;\n                is_articulation |= p!=-1 && low[to.first] >= ord[v];\n                if (ord[v] < low[to.first]) _bridge.push_back(make_pair(min(v, to.first), max(v, to.first)));\n            }\n            else if(to.first != p && low[v]>ord[to.first]){\n                low[v] = ord[to.first];\n            }\n        }\n        is_articulation |= p==-1 && cnt>1;\n        if(is_articulation) ret.push_back(v);\n    }\n    void Lowlink_init(int n=0){\n        this->ord.resize(grapf.size(),-1);\n        this->low.resize(grapf.size());\n    }\n    vector<int> articulation(){\n        int k = 0;\n        vector<int> ret;\n        Lowlink_init();\n        REP(i, grapf.size()) if(ord[i]==-1) dfs(i, -1, k, ret);\n        Sort(ret);\n        return ret;\n    }\n\n    vector<P> bridge(){\n        int k = 0;\n        vector<int> ret;\n        Lowlink_init();\n        REP(i, grapf.size()) if(ord[i]==-1) dfs(i, -1, k, ret);\n        Sort(_bridge);\n        return _bridge;\n    }\n\n\n    void print_AOJ(){\n        if(loop){\n            print(\"NEGATIVE CYCLE\");\n            return;\n        }\n        REP(i,d.size()){\n            if(d[i] == max_int){\n                print(\"INF\");\n            }\n            else{\n                print(d[i]);\n            }\n        }\n    }\n    void De(){\n        REP(i,grapf.size()){\n            cout << \"{\";\n            for(P p:grapf[i]){\n                cout << \"{\" << p.first << \",\" << p.second << \"}\";\n            }\n            cout << \"}\\n\";\n        }\n        Debug(d);\n    }\n};\n\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int v,e,r=0;\n    cin >> v >> e;\n    uGrapf g(v);\n    REP(i,e){\n        int s,t;\n        cin >> s >> t;\n        g.edge(s,t);\n    }\n    vector<P> x = g.bridge();\n    for(auto a:x){\n        cout << a.first << \" \" << a.second << \"\\n\";\n    }\n    \n\n    return 0;\n}\n\nvoid Debug(auto a){\n    cout << \"{ \";\n    for(auto b: a){\n        cout << b << \" \";\n    }\n    cout << \"}\" << endl;\n}\n\n//key以上の初めてのitr\nint nibul(auto a,auto b){return lower_bound(All(a),b) - a.begin();}\n//key以下の最後のitr\nint nibuu(auto a,auto b){return upper_bound(All(a),b) - a.begin()-1;}\n\nvoid input(vector<auto>& a,int n){\n    REP(i,n){\n        cin >> a[i];\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nset< pair<int,int> > bad;\n\nint dfs(int x, int p, Edge e, const vector< vector<Edge> > &g){\n\tvisited[x] = ++currentTime;\n\tint ans = currentTime;\n\t\n\tfor( auto &&e : g[x] ){\n\t\tif( p == e.b ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, e, g));\n\t\t}\n\t}\n\tif( p != -1 && ans > visited[p] ){\n\t\tbad.insert({x,p});\n\t\tbad.insert({p,x});\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b;\n\t\tc = 1;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\tg[b].push_back({b,a,c});\n\t}\n\tdfs(0,-1, {}, g);\n\n\tvector< pair<int,int> > a;\n\tfor( auto e : es ){\n\t\tif( bad.count({e.a, e.b}) ){\n\t\t\ta.push_back({min(e.a,e.b),max(e.a,e.b)});\n\t\t}\n\t}\n\tsort(a.begin(),a.end());\n\tfor( auto p : a ){\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX_N=1e5+10;\nvector<int>adj[MAX_N];\npair<int,int>ans[MAX_N];\nlong long int from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N],rt;\nbool vis[MAX_N];\nvoid dfs(int v,int de,int p)\n{\n    depth[v]=de;\n    vis[v]=1;\n    for(int e:adj[v])\n    {\n        int u=from[e] xor to[e] xor v;\n        if(e==p)\n        {\n            continue;\n        }\n        if(vis[u])\n        {\n            dp[v]=min(dp[v],depth[u]);\n        }\n        else\n        {\n            dfs(u,de+1,e);\n            dp[v]=min(dp[u],dp[v]);\n        }\n    }\n    if(dp[v]>=de&&p!=-1)\n    {\n        ans[rt]={min(from[p],to[p]),max(from[p],to[p])};\n        rt++;\n    }\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    for(long long int i=0;i<=100000;i++)\n    {\n        dp[i]=999999;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        cin>>from[i]>>to[i];\n        from[i];\n        to[i];\n        adj[from[i]].push_back(i);\n        adj[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n    sort(ans,ans+rt);\n    for(int i=0;i<rt;i++)\n    {\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// lolinkの自作ライブラリ\n/* option1:グラフが非連結の場合,option2:bridgeの検出,option3:関節点の検出*/\n#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define loINF (long)10000000000\n#define shINF (short)10000\n#define SORT(c) sort((c).begin(),(c).end())\n//#define NOT_ALL_CONNECTED \t//option1\n#define BRIDGE   \t\t\t\t//option2\n//#define ARTICULATION_POINT    //option3\nusing namespace std;\nconst long V_START = 0;\ntypedef vector<long> VL;\ntypedef vector<VL> VVL;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\n\nVVL edge;\nVL ord;\nVL low;\nVL pre;\n\nvoid dfs(long now_ver,long parent,long order){\n\tlong child_num = 1;\n\tchar flag = 0;\n\tpre[now_ver] = parent;\n\tlow[now_ver] = ord[now_ver] = order;\n\n\tREP(i,edge[now_ver].size()){\n\t\tlong to = edge[now_ver][i];\n\t\tif (to == parent) continue;\n\t\tif (ord[to] == -1) { // 子ノードへの辺\n\t\t\tdfs(to,now_ver,order + child_num);\n\t\t\tchild_num++;\n\t\t\tlow[now_ver] = min(low[now_ver],low[to]);\n\t\t}\n\t\tlow[now_ver]=min(low[now_ver],ord[to]);\n\t}\n}\n\nint main(void){\n\tlong V,E;\n\tcin >> V >> E;\n\tedge = VVL(V+1,VL(0));\n\tord = VL(V+1,-1);\n\tlow = VL(V+1,loINF);\n\tpre = VL(V+1,-1);\n\n\tREP(i,E){\n\t\tlong u,v;\n\t\tcin >> u >> v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u); \n\t}\n\n\t#ifdef NOT_ALL_CONNECTED // グラフが非連結の場合\n\t\tFOR(i,V_START,V+V_START) \n\t\t\tif(ord[i] == -1)\n\t\t\t\tdfs(i,-1,1);\n\t#endif\n\n\t#ifndef NOT_ALL_CONNECTED // グラフが連結の場合\n\t\tdfs(1,-1,1);\n\t#endif\n\n\t#ifdef BRIDGE\n\t\tVP bridge;\n\t\tlong bridge_count = 0;\n\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (ord[i] == low[i]) {\n\t\t\t\tif (i == 1) continue;\n\t\t\t\tbridge.push_back(make_pair(i,pre[i]));\n\t\t\t\tbridge_count++;\n\t\t\t}\n\t\t}\n\n\t\tREP(i,bridge.size()) \n\t\t\tcout << min(bridge[i].first,bridge[i].second) << \" \" << max(bridge[i].first,bridge[i].second) << endl;\n\t#endif\n\n\t#ifdef ARTICULATION_POINT\n\t\tVL point;\n\t\tlong point_count = 0;\n\t\tchar root_count = 0;\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (pre[i] == -1) continue;\n\t\t\tif (pre[i] == 1) root_count++;\n\t\t\telse {\n\t\t\t\tif (ord[pre[i]] <= low[i]) {\n\t\t\t\t\tpoint.push_back(pre[i]);\n\t\t\t\t\tpoint_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(root_count >= 2) {\n\t\t\tpoint.push_back(1);\n\t\t\tpoint_count++;\n\t\t}\n\n\t\tSORT(point);\n\t\tpoint.erase(unique(point.begin(),point.end()),point.end());\n\n\t\t// point_count:関節点の個数 , point:関節点\n\t\tcout << \"関節点の個数:\" << point_count << endl;\n\t\tREP(i,point.size()) cout << point[i] << endl;\n\t\t\n\t#endif\n\n\t#ifdef DEBUG\n\t\tdump1d_arr(ord);\n\t\tdump1d_arr(low);\n\t\tdump1d_arr(pre);\n\t#endif\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass BRI{\n\tpublic:\n\tint N;\n\tvi used;\n\tvvi G;\n\tvp bridge;\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\tBRI(int size){\n\t\tN=size;\n\t\tG=vvi(N);\n\t}\n\tint dfs(int i,int prev,int &n){\n\t\tif(used[i])return used[i];\n\t\tint m=n;\n\t\tused[i]=n++;\n\t\trep(j,G[i].size()){\n\t\t\tif(prev==G[i][j])continue;\n\t\t\tif(used[i]<used[G[i][j]])continue;\n\t\t\tint res=dfs(G[i][j],i,n);\n\t\t\tm=min(m,res);\n\t\t\tif(used[i]<res)bridge.pb(pii(min(i,G[i][j]),max(i,G[i][j])));\n\t\t}\n\t\treturn m;\n\t}\n\tvoid bri(){\n\t\tused=vi(N);\n\t\tbridge=vp(0);\n\t\tint n=1;\n\t\tdfs(0,-1,n);\n\t\tsort(all(bridge));\n\t\trep(i,bridge.size())cout<<bridge[i].first<<\" \"<<bridge[i].second<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing P = pair<int,int>;\n\nstruct Lowlink {\n  const vector<vector<int>> &g;\n  vector<int> ord, low;\n  vector<int> articulation;\n  vector<P> bridge;\n  int k;\n\n  Lowlink(const vector<vector<int>>& g) : g(g) {}\n\n  virtual void dfs(int idx, int par) {\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n    bool is_articulation = false;\n    int cnt = 0;\n    for(auto to : g[idx]) {\n      if(ord[to] < 0) {\n        ++cnt;\n        dfs(to,idx);\n        low[idx] = min(low[idx],low[to]);\n        if(par != -1 && low[to] >= ord[idx]) is_articulation = true;\n        if(ord[idx] < low[to]) bridge.push_back(P(min(idx,to),max(idx,to)));\n      } else if(to != par) {\n        low[idx] = min(low[idx],ord[to]);\n      }\n    }\n    if(par == -1 && cnt > 1) is_articulation = true;\n    if(is_articulation) articulation.push_back(idx);\n  }\n\n  virtual void build() {\n    ord.assign(g.size(),-1);\n    low.assign(g.size(),0);\n    k = 0;\n    rep(i,g.size()) {\n      if(ord[i] < 0) dfs(i,-1);\n    }\n  }\n};\n\nint main() {\n  int n, m, u, v;\n  cin >> n >> m;\n  vector<vector<int>> g(n);\n  rep(i,m) {\n    cin >> u >> v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  Lowlink llink(g);\n  llink.build();\n  sort(llink.bridge.begin(),llink.bridge.end());\n  for(auto x : llink.bridge) cout << x.first << \" \" << x.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nstruct edge{\n    int f, t;\n};\n\nconst int V_MAX = (int)1e5 + 10;\nvector<int> edges[V_MAX];\nint ord[V_MAX];\nint low[V_MAX];\nbool used_v[V_MAX];\nvector<edge> ans;\n\nbool comp(edge e1, edge e2){\n    if(e1.f == e2.f){\n        return e1.t < e2.t;\n    } else {\n        return e1.f < e2.f;\n    }\n}\n\nvoid dfs(int u, int prev, int k){\n    low[u] = ord[u] = k;\n    k += 1;\n    used_v[u] = true;\n\n    for(int i=0; i<edges[u].size(); i++){\n        int next = edges[u][i];\n\n        if(not used_v[next]){\n            dfs(next, u, k);\n            low[u] = min(low[u], low[next]);\n\n            if(low[next] > ord[u]){\n                edge e;\n                e.f = min(u, next); e.t = max(u, next);\n                ans.push_back(e);\n            }\n        } else if(prev != next){\n            low[u] = min(low[u], ord[next]);\n        }\n    }\n    return ;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int v, e; \n    cin >> v >> e;\n\n    for(int i=0; i<e; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    dfs(0, -1, 1);\n\n    sort(ans.begin(), ans.end(), comp);\n    for(int i=0; i<ans.size(); i++){\n        cout << ans[i].f << \" \" << ans[i].t << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int ord, low;\n};\n\nclass BridgeFind{\npublic:\n  BridgeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  vector<pii> find(){\n    if(v_ord == 0)dfs();\n    return bridge;\n  }\nprivate:\n  void dfs(int v  = 0,\n           int previous = -1){\n    node[v].ord = node[v].low = v_ord++;\n    int to;\n    for (int i = 0; i < g[v].size(); i++) {\n      to = g[v][i];\n      if(previous == to)continue;\n      if(node[to].ord == -1) dfs(to, v);\n      node[v].low = min(node[v].low, node[to].low);\n    }\n    if(node[v].low == node[v].ord and previous != -1)\n      bridge.emplace_back(pii(previous, v));\n  }\n  int v_ord = 0;\n  vector<pii> bridge;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BridgeFind bf(g);\n  vector<pii> bridge = bf.find();\n  sort(bridge.begin(), bridge.end());\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define MAX_V 10000\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int>G[MAX_V];\nvector<P> bridge;\nint pnum[MAX_V],lowest[MAX_V],num;\nbool used[MAX_V];\n\nint dfs(int v,int prev){\n  pnum[v]=num,lowest[MAX_V]=num;\n  num++;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    int nx=G[v][i];\n    if(!used[nx]){\n      dfs(nx,v);\n      lowest[v]=min(lowest[v],lowest[nx]);\n      if(pnum[v]<lowest[nx])\n        bridge.push_back(make_pair(min(v,nx),max(v,nx)));\n    }\n    else if(nx!=prev){\n      lowest[v]=min(lowest[v],pnum[nx]);\n    }\n  }\n}\n\nint main(void){\n  int n,m;\n  cin >> n >> m;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  fill(used,used+MAX_V,false);\n  fill(lowest,lowest+MAX_V,INF);\n  fill(pnum,pnum+MAX_V,INF);\n  num=-1;\n  bridge.clear();\n  dfs(0,-1);\n  sort(bridge.begin(),bridge.end());\n  //bridge.erase(unique(bridge.begin(),bridge.end()),bridge.end());\n  for(int i=0;i<bridge.size();i++)\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 100010\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef vector<ii>   vii;\ntypedef vector<int>   vi;\nconst int DFS_WHITE = -1; // unvisited\nconst int DFS_BLACK =  1; // visited\n\nint V,E;\nint dfsNumberCounter,rootChildren,dfsRoot;\nvi dfs_num,dfs_low,dfs_parent,articulation_vertex;\nvii AdjList[MAX_V];// ii(neighbor,weight)\n\nvii ans;\n\nvoid articulationPointAndBridge(int u)\n{\n  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;\n  for(int j=0;j<(int)AdjList[u].size();j++)\n    {\n      ii v = AdjList[u][j];\n      if(dfs_num[v.first] == DFS_WHITE)\n\t{\n\t  dfs_parent[v.first] = u;\n\t  if(u == dfsRoot)rootChildren++;\n\n\t  articulationPointAndBridge(v.first);\n\n\t  if(dfs_low[v.first] >= dfs_num[u])\n\t    articulation_vertex[u] = true;\n\t  if(dfs_low[v.first] >  dfs_num[u])\n\t    ans.push_back(ii(u,v.first));\n\t    //printf(\"Edge (%d,%d) is a bridge\\n\",u,v.first);\n\t  dfs_low[u] = min(dfs_low[u],dfs_low[v.first]);\n\n\t}\n      else if(v.first != dfs_parent[u])\n\tdfs_low[u] = min(dfs_low[u],dfs_num[v.first]);\n    }\n}\n\nvoid compute()\n{\n  dfsNumberCounter = 0; dfs_num.assign(V,DFS_WHITE); dfs_low.assign(V,0);\n  dfs_parent.assign(V,0); articulation_vertex.assign(V,0);\n  //puts(\"Bridges:\");\n  for(int i = 0; i < V; i++)\n    if(dfs_num[i] == DFS_WHITE)\n      {\n\tdfsRoot = i; rootChildren = 0;\n\tarticulationPointAndBridge(i);\n\tarticulation_vertex[dfsRoot] = (rootChildren > 1);// special case\n      }\n  //puts(\"Articulation Points\");\n  //for(int i = 0; i < V; i++)\n  //if(articulation_vertex[i])\n      //printf(\"Vertex %d\\n\",i);\n}\n\nint main()\n{\n  scanf(\"%d%d\",&V,&E);\n  rep(i,V)AdjList[i].clear();\n  rep(i,E)\n    {\n      int s,t;\n      scanf(\"%d%d\",&s,&t);\n      AdjList[s].push_back(ii(t,1));\n      AdjList[t].push_back(ii(s,1));\n    }\n\n  ans.clear();\n  compute();\n  sort(ans.begin(),ans.end());\n  rep(i,ans.size())cout << ans[i].first << \" \" << ans[i].second << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline bool chmin (int& a, int b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid dfs (\n\tint crr\n,\tint prt\n, int& tmr\n, vector<int>& ord\n, vector<int>& low\n, vector<pair<int, int>>& bdg\n, vector<vector<int>>& grh\n) {\n\tord[crr] = low[crr] = tmr++;\n\tfor (int nxt : grh[crr]) {\n\t\tif (ord[nxt] == -1) dfs(nxt, crr, tmr, ord, low, bdg, grh);\n\t\tif (nxt != prt) chmin(low[crr], low[nxt]);\n\t\tif (ord[crr] < low[nxt]) bdg.emplace_back(crr, nxt);\n\t}\n}\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> grh(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgrh[s].push_back(t);\n\t\tgrh[t].push_back(s);\n\t}\n\tint tmr = 0;\n\tvector<int> ord(n, -1), low(n, -1);\n\tvector<pair<int, int>> bdg;\n\tdfs(0, 0, tmr, ord, low, bdg, grh);\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tif (it->first > it->second) swap(it->first, it->second);\n\t}\n\tsort(bdg.begin(), bdg.end());\n\tfor (auto it = bdg.begin(); it != bdg.end(); it++) {\n\t\tcout << it->first << ' ' << it->second << '\\n';\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int order, min_order;\n};\nclass BrigeFind{\npublic:\n  BrigeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  set<pii> find(){\n    if(current_order == 0)dfs();\n    return brige;\n  }\nprivate:\n  void dfs(int current  = 0,\n           int previous = -1){\n    node[current].order   = current_order;\n    node[current].min_order = current_order++;\n    int to;\n    for (int i = 0; i < g[current].size(); i++) {\n      to = g[current][i];\n      if(node[to].order == -1) dfs(to, current);\n      if(previous == to)continue;\n      node[current].min_order =\n        min(node[current].min_order,\n            node[to].min_order);\n    }\n    if(node[current].min_order == node[current].order and\n       previous != -1){\n      if(previous < current)\n        brige.insert(pii(previous, current));\n      else\n        brige.insert(pii(current, previous));\n    }\n  }\n  int current_order = 0;\n  set<pii> brige;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BrigeFind bf(g);\n  set<pii> bridge = bf.find();\n  for (auto i: bridge){\n    std::cout << i.first << \" \" << i.second << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nset<pa> hasi;\nint pre[100100],lowlink[100100];\nint counter_hasi=1;\nvoid dfs_hasi(int r,int mae,vector<int> *graph){\n\tif(pre[r]>=0) return;\n\tpre[r]=counter_hasi;\n\tcounter_hasi++;\n\tint f=pre[r];\n\tint oyacnt=0;\n\tfor(int i=0;i<graph[r].size();i++){\n\t//\tcout<<r<<\" \"<<graph[r][i]<<endl;\n\t\tif(graph[r][i]==mae){\n\t\t\toyacnt++;\n\t\t\tif(oyacnt==1) continue; \n\t\t}\n\t\tif(pre[graph[r][i]]<0){\n\t\t\tdfs_hasi(graph[r][i],r,graph);\n\t\t\tf=min(f,lowlink[graph[r][i]]);\n\t\t\t//cout<<r<<\" \"<<graph[r][i]<<\" \"<<pre[graph[r][i]]<<\" \"<<lowlink[graph[r][i]]<<endl;\n\t\t\tif(pre[graph[r][i]]==lowlink[graph[r][i]]){\n\t\t\t//\tcout<<\" \"<<graph[r][i]<<endl;\n\t\t\t\thasi.insert(mp(r,graph[r][i]));\n\t\t\t\thasi.insert(mp(graph[r][i],r));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tf=min(f,pre[graph[r][i]]);\n\t\t}\n\t\t\n\t}\n\tlowlink[r]=f;\n\t\n\treturn ;\n}\n\nvoid hashi_kenshutu(int V,vector<int> *graph){// V=tyoutensuu\n\tfor(int i=0;i<=V;i++)pre[i]=-1,lowlink[i]=-1;\n\tcounter_hasi=1;\n\t\n\tfor(int i=0;i<V;i++){//0-index\n\t\tif(pre[i]==-1)dfs_hasi(i,i,graph);\n\t}\n\t\n\treturn;\n}\nvector<int> G[100010];\nint a[100010],b[100010];\n   signed main(){\n int n,m;\n   \tcin>>n>>m;\n   \t\n   \tfor(int i=0;i<m;i++){\n   \t\tint y,yy;\n   \t\tcin>>y>>yy;\n   \t\tG[y].pb(yy);\n   \t\tG[yy].pb(y);\n   \t\ta[i]=y;\n   \t\tb[i]=yy;\n   \t}\n   \thashi_kenshutu(n,G);\n   \t\n   \tfor(int i=0;i<m;i++){\n   \t\tif(hasi.find(mp(a[i],b[i]))!=hasi.end()){\n   \t\t\n   \t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n   \t\t}\n   \t}\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\nstruct LowLink{\n    const vector<vector<int>> &g;\n    vector<int> used,ord,low;\n    vector<int> articulation;// 関節点\n    vector<pair<int,int>> bridge;// 橋\n    LowLink(const vector<vector<int>> &g):g(g){}\n    int dfs(int pre,int now,int k){\n        used[now]=1;\n        ord[now]=k++;\n        low[now]=ord[now];\n        bool is_articulation=false;\n        int cnt=0;\n        for(auto &to:g[now])if(to!=pre){\n            if(!used[to]){\n                cnt++;\n                k=dfs(now,to,k);\n                low[now]=min(low[now],low[to]);\n                is_articulation|=(pre>=0 and low[to]>=ord[now]);\n                if(ord[now]<low[to]) bridge.push_back(minmax(now,to));\n            }else{\n                // 後退辺\n                low[now]=min(low[now],ord[to]);\n            }\n        }\n        // 根の場合子が2個以上いれば関節点\n        is_articulation|=(pre==-1 and cnt>1);\n        if(is_articulation) articulation.push_back(now);\n        return k;\n    }\n    void build(){\n        used.assign(g.size(),0);\n        ord.assign(g.size(),0);\n        low.assign(g.size(),0);\n        int k=0;\n        for(int i=0;i<(int)g.size();i++)if(!used[i]) k=dfs(-1,i,k);\n    }\n    bool isBridge(int u,int v){\n        if(ord[u]>ord[v]) swap(u,v);\n        return ord[u]<low[v];\n    }\n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    int n,m;cin>>n>>m;\n    vector<vector<int>> g(n);\n    rep(i,m){\n        int u,v;cin>>u>>v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    LowLink L(g);\n    L.build();\n\n    sort(ALL(L.bridge));\n    for(auto &p:L.bridge)cout<<p.first<<\" \"<<p.second<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> grh;\nvector<int> ord, low;\nvector<pair<int, int>> brg;\nint cnt;\nvoid dfs (int crr, int prt) {\n  low[crr] = ord[crr] = cnt++;\n  for (int nxt : grh[crr]) {\n    if (ord[nxt] == -1) {\n      dfs(nxt, crr);\n      if (ord[nxt] == low[nxt]) brg.push_back({crr, nxt});\n      low[crr] = min(low[crr], low[nxt]);\n    } else if (nxt != prt) {\n      low[crr] = min(low[crr], ord[nxt]);\n    }\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  grh.resize(n);\n  ord.resize(n, -1);\n  low.resize(n);\n  for (int i = 0; i < m; i++) {\n    int s, t;\n    cin >> s >> t;\n    grh[s].push_back(t);\n    grh[t].push_back(s);\n  }\n  cnt = 0;\n  dfs(0, 0);\n  for (auto& p : brg) {\n    int& crr = p.first;\n    int& nxt = p.second;\n    if (crr > nxt) swap(crr, nxt);\n  }\n  sort(brg.begin(), brg.end());\n  for (auto p : brg) {\n    int crr = p.first;\n    int nxt = p.second;\n    cout << crr << ' ' << nxt << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 6;\nconst ll LLINF = 1e18 + 1;\n\n// 橋・関節点列挙 O(V)\nstruct LowLink {\nprivate:\n    vector< vector< int > > G;\n    int V; // 頂点数\n    vector< int > used, ord, low;\n\n    int dfs(int idx, int k, int par) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_articulation = false;\n        int cnt = 0;\n        for (auto &to : G[idx]) {\n            if (!used[to]) {\n                ++cnt;\n                k = dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_articulation |= ~par && low[to] >= ord[idx];\n                if (ord[idx] < low[to]) bridge.push_back(minmax(idx, (int)to));\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if (is_articulation) articulation.push_back(idx);\n        return k;\n    }\n\npublic:\n    vector< int > articulation; // 関節点\n    vector< pair< int, int > > bridge; // 橋\n\n    LowLink(int V) : V(V) {\n        G.resize(V);\n    }\n\n    // 無向辺を張る\n    void add_edge(int v, int u) {\n        G[v].push_back(u);\n        G[u].push_back(v);\n    }\n\n    void build() {\n        used.assign(V, 0);\n        ord.assign(V, 0);\n        low.assign(V, 0);\n        int k = 0;\n        for (int i = 0; i < V; i++) {\n            if (!used[i]) k = dfs(i, k, -1);\n        }\n    }\n};\n\nint main() {\n    int v, e; cin >> v >> e;\n    LowLink G(v);\n    REP(i, e) {\n        int a, b; cin >> a >> b;\n        G.add_edge(a, b);\n    }\n    G.build();\n    sort(G.bridge.begin(), G.bridge.end());\n    for (auto &e : G.bridge) {\n        cout << e.first << \" \" << e.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n\nusing namespace std;\ntypedef pair<long,long> pr;\nbool pairCompare(const pr& firstElof, const pr& secondElof)\n{\n    return (firstElof.first < secondElof.first || ((firstElof.first == secondElof.first) && (firstElof.second < secondElof.second)));\n}\n\nclass Lowlink {\nprivate:\n\tvector<vector<long>> E;\n\tvector<long> ord;\n\tvector<long> low;\n\tvector<long> prev;\n\tsize_t V;\npublic:\n\tLowlink() : V(0){ }\n\tLowlink(size_t v) : \n\t\tV(v),E(v,vector<long>(0)),ord(v,-1),low(v,2147483647),prev(v,-1) {}\n\n\tsize_t size() {return V;}\n\n\tvoid add_edge_directed(long from,long to){\n\t\tE[from].push_back(to);\n\t}\n\n\tvoid add_edge_undirected(long from,long to){ \n\t\tE[from].push_back(to);\n\t\tE[to].push_back(from);\n\t}\n\n\tvoid dfs(long node,long parent,long order){\n\t\tlong child = 1;\n\t\tprev[node] = parent;\n\t\tlow[node] =  ord[node] = order;\n\n\t\tREP(i,(long)E[node].size()){\n\t\t\tlong to = E[node][i];\n\t\t\tif (to == parent) continue;\n\t\t\tif (ord[to] == -1) { // 子ノードへの辺\n\t\t\t\tdfs(to,node,order + child);\n\t\t\t\tchild++;\n\t\t\t\tlow[node] = min(low[node],low[to]);\n\t\t\t}\n\t\t\tlow[node]=min(low[node],ord[to]);\n\t\t}\n\t}\n\n\tvector<pr> find_bridge(void){\n\t\tvector<pr> bridge;\n\t\tREP(i,V){\n\t\t\tif (ord[i] == (-1)) dfs(i,-1,1);\n\t\t}\n\n\t\tREP(i,V){\n\t\t\tif (ord[i] == low[i]) {\n\t\t\t\tif (prev[i] == (-1)) continue;\n\t\t\t\tbridge.push_back(pr(min(i,prev[i]),max(i,prev[i])));\n\t\t\t}\n\t\t}\n\n\t\tsort(bridge.begin(),bridge.end(),pairCompare);\n\t\treturn bridge;\n\t}\n\n\tvector<long> find_articulation_point(void){\n\t\tvector<long> point;\n\t\tvector<char> root(V,0);\n\n\t\tREP(i,V){\n\t\t\tif (ord[i] == (-1)) {\n\t\t\t\tdfs(i,-1,1);\n\t\t\t\troot[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tREP(i,V){\n\t\t\tif (prev[i] == (-1)) continue;\n\t\t\tif (root[prev[i]]) root[prev[i]]++;\n\t\t\telse {\n\t\t\t\tif (ord[prev[i]] <= low[i]) point.push_back(prev[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i,V) if (root[i] >= 3) point.push_back(i);\n\n\t\tsort((point).begin(),(point).end());\n\t\tpoint.erase(unique(point.begin(),point.end()),point.end());\n\n\t\treturn point;\n\t}\n};\n\nint main(void){\n\tlong V,E;\n\tlong u,v;\n\tcin >> V >> E;\n\tLowlink ll(V);\n\tREP(i,E){\n\t\tcin >> u >> v;\n\t\tll.add_edge_undirected(u,v);\n\t}\n\n\tvector<pr> ans = ll.find_bridge();\n\tREP(i,ans.size()) cout << ans[i].first << \" \" << ans[i].second << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nconst int MAXN = 100010;\n\nint n;\nvector<int> g[100010];\n\nint zeit, dis[MAXN], fin[MAXN], low[MAXN], par[MAXN], dep[MAXN];\nint kodat[MAXN], koptr[MAXN + 1];\nvoid dfsInfo(int u,int oy,int d){\n\tdis[u] = low[u] = zeit++; par[u] = oy; dep[u] = d;\n\tint v;\n\trep(i,sz(g[u])) if((v = g[u][i]) != oy){\n\t\tif(!~dis[v]){\n\t\t\tdfsInfo(v, u, d + 1);\n\t\t\tlow[u] = min(low[u], low[v]);\n\t\t} else {\n\t\t\tlow[u] = min(low[u], dis[v]);\n\t\t}\n\t}\n\tfin[u] = zeit++;\n}\n\nvoid dfsInfos(){\n\tmemset(dis, ~0, n*4); zeit = 0;\n\trep(u,n) if(!~dis[u]) dfsInfo(u, -1, 0);\n\trep(u,n){\n\t\tint &j = koptr[u + 1] = koptr[u];\n\t\trep(i,sz(g[u])) if(u == par[g[u][i]]) kodat[j++] = g[u][i];\n\t}\n}\n\nbool produce(int u,int v){\n\treturn (dis[u] <= dis[v] && fin[u] >= fin[v]);\n}\n\nint related(int u,int v){\n\tint s = koptr[u], e = koptr[u+1], h;\n\twhile(s+1 < e){\n\t\th = (s + e) >> 1;\n\t\t(dis[kodat[h]] <= dis[v]) ? s = h : e = h;\n\t}\n\treturn kodat[s];\n}\n\nbool isBridge(int u,int v){\n\tif(dis[u] > dis[v]) swap(u, v);\n\treturn (u == par[v] && dis[v] <= low[v]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\n\tint m;\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\trep(i,n)sort(g[i].begin(),g[i].end());\n\tdfsInfos();\n\t/*rep(i,n)rep(j,sz(g[i])){\n\t\tif(i<g[i][j] && isBridge(i,g[i][j]))cout<<i<<\" \"<<g[i][j]<<endl;\n\t}*/\n\trep(i,n)rep(j,sz(g[i])){\n\t\tif(dis[i] < low[g[i][j]])cout<<i<<\" \"<<g[i][j]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\n//O(|V|+|E|)\n\ntemplate<class graph_type> class bridge_and_articulation{\npublic:\n    const int size;\n    graph_type graph;\n    vector<bool> used,is_art;\n    vector<int> ord,low,articulations;\n    vector<pair<int,int>> bridges;\n\n    bridge_and_articulation(const graph_type &graph):graph(graph),size(graph.size()),used(size),is_art(size),ord(size),low(size){\n        int k=0;\n        for(int i=0; i<size; ++i) if(!used[i]) dfs(i,-1,k);\n    }\n\n    void dfs(int v,int p,int &k){ //v???????????¨???p=-1\n        used[v]=true;\n        ord[v]=low[v]=k++;\n\n        int count=0;\n        for(const auto &edge:graph[v]){\n            const int u=edge.to;\n            if(!used[u]){\n                ++count;\n                dfs(u,v,k);\n                low[v]=min(low[v],low[u]);\n\n                if(ord[v]<low[u]) bridges.push_back(make_pair(min(v,u),max(v,u)));\n                if(p!=-1 and ord[v]<=low[u]) is_art[v]=true;\n            }else if(u!=p) low[v]=min(low[v],ord[u]);\n        }\n\n        if(p==-1 and count>1) is_art[v]=true;\n        if(is_art[v]) articulations.push_back(v);\n    }\n\n    bool is_bridge(int u,int v)const{\n        if(ord[u]>ord[v]) swap(u,v);\n        return ord[u]<low[v];\n    }\n\n    bool is_articulation(int v)const{\n        return is_art[v];\n    }\n};\n\nstruct edge{\n    int to;\n};\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<edge>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(edge({t}));\n        graph[t].push_back(edge({s}));\n    }\n    bridge_and_articulation<vector<vector<edge>>> ba(graph);\n    vector<pair<int,int>> ans=ba.bridges;\n    sort(ans.begin(),ans.end());\n    for(auto &e:ans) cout << e.first << \" \" << e.second << endl;\n    cerr << ba.ord << endl;\n    cerr << ba.low << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5+5;\nconst int inf = 1001*1000*1000;\n#define pb push_back\n#define mp make_pair\nvector<int> obj[maxN];\nvector<pair<int,int>> bre;\nint n,e,mark[maxN],fa[maxN],dp[maxN],hig[maxN];\npair<int,int> jof;\nvoid dfs(int u)\n{\n\tmark[u] =1;\n\tdp[u]=inf;\n\tfor(int v:obj[u])\n\t{\n\t\tif(!mark[v])\n\t\t{\n\t\t\thig[v]=hig[u]+1;\n\t\t\tmark[v]=1;\n\t\t\tfa[v]=u;\n\t\t\tdfs(v);\n\t\t\tdp[u]=min(dp[u],dp[v]);\n\t\t}\n\t\telse if(v!=fa[u]&&hig[v]<hig[u])\n\t\t{\n\t\t\tdp[u]=min(dp[u],hig[v]);\n\t\t}\n\t}\n\tif(dp[u]>=hig[u]&&u!=fa[u])\n\t{\n\t\tjof = mp(min(u,fa[u]),max(u,fa[u]));\n\t\tbre.pb(jof);\n\t}\n}\nint main()\n{\n\tcin>>n>>e;\n\tint u,v;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tobj[u].pb(v);\n\t\tobj[v].pb(u);\n\t}\n\tdfs(0);\n\tsort(bre.begin(),bre.end());\n\tfor(int i=0;i<bre.size();i++)\n\t{\n\t\tcout<<bre[i].first<<\" \"<<bre[i].second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint ord[110000], low[110000], n, m, a, b, cnt;\nvector<int>x[110000]; bool used[110000];\nvector<pair<int, int>>bridge;\nvoid dfs(int v, int k) {\n\tord[v] = cnt; used[v] = true;\n\tlow[v] = cnt; cnt++;\n\tfor (int i = 0; i < x[v].size(); i++) {\n\t\tif (used[x[v][i]] == false) {\n\t\t\tdfs(x[v][i], v);\n\t\t\tlow[v] = min(low[v], low[x[v][i]]);\n\t\t\tif (ord[v] < low[x[v][i]]) { bridge.push_back(make_pair(v, x[v][i])); }\n\t\t}\n\t\telse if (x[v][i] != k) {\n\t\t\tlow[v] = min(low[v], ord[x[v][i]]);\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> a >> b;\n\t\tx[a].push_back(b);\n\t\tx[b].push_back(a);\n\t}\n\tused[1] = true; dfs(1, -1);\n\tfor (int i = 0; i < bridge.size(); i++) {\n\t\tif (bridge[i].first > bridge[i].second) { swap(bridge[i].first, bridge[i].second); }\n\t}\n\tsort(bridge.begin(), bridge.end());\n\tfor (int i = 0; i < bridge.size(); i++) {\n\t\tcout << bridge[i].first << ' ' << bridge[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nvector<vector<int>> connenct_list;\nvector<int> visit_list;\nvector<int> lowlink_list;\nvector<int> parent_list;\nvector<vector<int>> children_list;\n\nint counter = 1;\nvoid dfs(int k, int p)\n{\n    // cout << k << x << p<< endl;\n    visit_list[k] = counter;\n    lowlink_list[k] = counter;\n    counter++;\n    parent_list[k] = p;\n    for (int j : connenct_list[k])\n    {\n        if (visit_list[j] == 0)\n        {\n            dfs(j, k);\n            children_list[k].push_back(j);\n            lowlink_list[k] = min(lowlink_list[k], lowlink_list[j]);\n        }\n        else if (parent_list[k] != j)\n            lowlink_list[k] = min(lowlink_list[k], visit_list[j]);\n    }\n}\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int v, e, a, b;\n    cin >> v >> e;\n    vector<pair<int, int>> node;\n    vector<pair<int, int>> bridge;\n    connenct_list.resize(v);\n    visit_list.resize(v);\n    lowlink_list.resize(v);\n    parent_list.resize(v);\n    children_list.resize(v);\n    for (int i = 0; i < e; i++)\n    {\n        cin >> a >> b;\n        connenct_list[a].push_back(b);\n        connenct_list[b].push_back(a);\n        node.push_back(make_pair(a, b));\n    }\n\n    for (int i = 0; i < v; i++)\n    {\n        visit_list[i] = 0;\n        sort(connenct_list[i].begin(), connenct_list[i].end());\n        // for ( auto v : connenct_list[i])\n        //     cout << v << \" \";\n        // cout << endl;\n    }\n\n    dfs(0, -1);\n\n    // for (int x = 0; x < v; x++)\n    // {\n    //     printf( \"%d, %d, %d\\n\" , x, visit_list[x], lowlink_list[x] );\n    // }\n    // for (int x : parent_list)\n    //     cout << x << endl;\n    // for (int x = 0; x < v; x++)\n    //     for (auto y : children_list[x])\n    //         cout << x << \" \" << y << endl;\n\n    /* 関節点(Articuration Point)\n    if (children_list[0].size() > 1)\n        cout << 0 << endl;\n    for (int i = 1; i < v; i++)\n    {\n        for (int j : children_list[i])\n        {\n            // cout << i << \" \" << visit_list[i] << \" \" << j << \" \" << lowlink_list[j] << endl;\n            if (visit_list[i] <= lowlink_list[j])\n            {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n*/\n\n    for (auto x : node)\n    {\n        a = x.first, b = x.second;\n        {\n            if (visit_list[a] > visit_list[b])\n                swap(a, b);\n            if (visit_list[a] < lowlink_list[b])\n            {\n                if (a > b)\n                    swap(a, b);\n                bridge.push_back(make_pair(a, b));\n            }\n        }\n    }\n\n    sort(bridge.begin(), bridge.end());\n    for (auto x : bridge)\n    {\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\nusing namespace std;\nvector<vector<int>> G(100000);\nvector<bool> visit(100000, false);\nvector<int> prenum(100000), parent(100000, -1), lowest(100000);\nint timer = 1;\n\nvoid dfs(int u, int prev) {\n\tprenum[u] = lowest[u] = timer++;\n\tvisit[u] = true;\n\tfor (int v : G[u]) {\n\t\tif (!visit[v]) {\n\t\t\tparent[v] = u;\n\t\t\tdfs(v, u);\n\t\t\tlowest[u] = min(lowest[u], lowest[v]);\n\t\t}\n\t\telse if (v != prev) {\n\t\t\tlowest[u] = min(lowest[u], prenum[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint V, E; cin >> V >> E;\n\tset<pair<int, int>> Ans;\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tG[s].emplace_back(t);\n\t\tG[t].emplace_back(s);\n\t}\n\tdfs(0, -1);\n\n\t//u:??? v:???\n\t//prenum[u] < lowest[v]\n\n\tfor (int i = 0; i < V;i++) {\n\t\tfor (int v : G[i]) {\n\t\t\tif (prenum[i] < lowest[v]) {\n\t\t\t\tif (i <= v) { Ans.insert(make_pair(i, v)); }\n\t\t\t\telse { Ans.insert(make_pair(v, i)); }\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto p : Ans) {\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX=100000;\n\nint n;\nvector<int> G[MAX];\nint order[MAX]={};\nbool inS[MAX]={};\nstack<int> roots;\nint k;\nvector<P> brg;\n\nvoid visit(int v,int p)\n{\n\torder[v]=++k;\n\tinS[v]=true;\n\troots.push(v);\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint to=G[v][i];\n\t\tif(order[to]==0)\n\t\t{\n\t\t\tvisit(to,v);\n\t\t}\n\t\telse if(to!=p&&inS[to])\n\t\t{\n\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t}\n\tif(v==roots.top())\n\t{\n\t\tif(p!=-1)brg.push_back(P(min(p,v),max(p,v)));\n\t\troots.pop();\n\t}\n\treturn;\n}\n\nvoid bridge()\n{\n\tk=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(order[i]==0)\n\t\t{\n\t\t\tvisit(i,-1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tcin>>n;\n\tint e;\n\tcin>>e;\n\tint u,v;\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbridge();\n\tsort(brg.begin(),brg.end());\n\tfor(int i=0;i<brg.size();i++)\n\t{\n\t\tcout<<brg[i].first<<\" \"<<brg[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\nint n, m; // number of nodes, edges\n\nvvi edge;\nvvi g;\nvi prenum;\nvi lowest;\nvi parent;\nint timer;\n\nvoid lowlink_dfs(int u, int prev) {\n  prenum[u] = timer;\n  lowest[u] = timer;\n  timer += 1;\n\n  for (auto v : g[u]) {\n    if (prenum[v] < 0) {\n      parent[v] = u;\n      lowlink_dfs(v, u);\n      lowest[u] = min(lowest[u], lowest[v]);\n    } else if (v != prev) {\n      lowest[u] = min(lowest[u], prenum[v]);\n    }\n  }\n}\n\nvoid lowlink() {\n  prenum.assign(n, -1);\n  lowest.assign(n, 0);\n  parent.assign(n, 0);\n  timer = 0;\n  lowlink_dfs(0, -1);\n}\n\nbool is_bridge(int x, int y) {\n  return (return (prenum[x] < lowest[y] || prenum[y] < lowest[x]);\n}\n\n// call after lowlink()\nset<pii> bridge() {\n  set<pii> ret;\n  rep (i, m) {\n    int x = edge[i][0];\n    int y = edge[i][1];\n    if (is_bridge(x, y)) {\n      if (x > y) {\n        swap(x, y);\n      }\n      ret.insert(make_pair(x, y));\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  edge.assign(m, vi(2, 0));\n  g.resize(n);\n  rep (i, m) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    if (s > t) {\n      swap(s, t);\n    }\n    edge[i][0] = s;\n    edge[i][1] = t;\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  sort(all(edge));\n  lowlink();\n  auto ans = bridge();\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nstruct UndirComp {\n    bool operator()(const Edge &e, const Edge &f) const {\n        if (min(e.src, e.dst) != min(f.src, f.dst)) {\n            return min(e.src, e.dst) < min(f.src, f.dst);\n        } else {\n            return max(e.src, e.dst) < max(f.src, f.dst);\n        }\n    }\n} undircomp;\n\nvoid visit(\n    const Graph &g, size_t v ,size_t u, Edges &bridge,\n    stack<size_t> &roots, stack<size_t> &s, vector<bool> &stacked,\n    vector<size_t> &num, int &time\n) {\n    num[v] = ++time;\n    s.push(v), stacked[v] = true;\n    roots.push(v);\n    for (const Edge &e: g[v]) {\n        size_t w=e.dst;\n        if (!num[w]) {\n            visit(g, w, v, bridge, roots, s, stacked, num, time);\n        } else if (u != w && stacked[w]) {\n            while (num[roots.top()] > num[w]) roots.pop();\n        }\n    }\n\n    if (v == roots.top()) {\n        bridge.push_back(Edge(u, v));\n        while (true) {\n            size_t w=s.top(); s.pop(), stacked[w]=false;\n            if (v == w) break;\n        }\n        roots.pop();\n    }\n}\n\nEdges get_bridge(const Graph &g) {\n    size_t V=g.size();\n    vector<size_t> num(V);\n    vector<bool> stacked(V);\n    stack<size_t> roots, s;\n    int time=0;\n\n    Edges bridge;\n    for (size_t u=0; u<V; ++u) if (!num[u]) {\n        visit(g, u, V, bridge, roots, s, stacked, num, time);\n        bridge.pop_back();\n    }\n\n    return bridge;\n}\n\nint main() {\n    size_t V, E;\n    scanf(\"%zu %zu\", &V, &E);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        scanf(\"%zu %zu\", &s, &t);\n\n        join(g, s, t);\n    }\n\n    Edges bridge=get_bridge(g);\n    sort(bridge.begin(), bridge.end(), undircomp);\n\n    for (Edge &e: bridge)\n        printf(\"%zu %zu\\n\", e.src, e.dst);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e6+9;\nint par[MAX], low[MAX], vis[MAX], dis[MAX];\nvector<int>adj[MAX];\nint cnt=0,n ,m;\nvector<pair<int, int> >ans;\nvoid dfs(int vertex ,int p ){\n\tlow[vertex]=dis[vertex]=cnt++;\n\tvis[vertex]=1;\n\tpar[vertex]=p;\n\tfor(int i=0;i<adj[vertex].size();i++){\n\t\tif(!vis[adj[vertex][i]]){\n\t\t\tpar[adj[vertex][i]]=vertex;\n\t\t\tdfs(adj[vertex][i], vertex);\n\t\t\tlow[vertex]=min(low[vertex], low[adj[vertex][i]]);\n\t\t}\n\t\telse if(p!=adj[vertex][i])\n\t\t\tlow[vertex]=min(low[vertex] , dis[adj[vertex][i]]);\n\t}\n\n}\nvoid bridges(){\n\tpar[0]=-1;\n\tdfs(0, -1);\n\tfor(int i=0;i<n;i++){\n\t\tif(dis[par[i]]<low[i]){\n\t\t\tans.push_back(make_pair(min(i ,par[i]), max(i, par[i])));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tbridges();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\ntemplate<typename T> struct Edge\n{\n  int src, dst; T w;\n  Edge() {};\n  Edge(int src, int dst): src(src), dst(dst) {w=1;}\n  Edge(int src, int dst, T w): src(src), dst(dst), w(w){}\n  bool operator<(const Edge &e)const{return w != e.w ? w > e.w : (src != e.src ? src < e.src : dst < e.dst);}\n  bool operator==(const Edge &e){return src == e.src && dst == e.dst;}\n};\n\ntemplate<typename T> class Graph : public vector<vector<Edge<T>>>\n{\nprivate:\n  pair<T,int> farthest(int p, int v)\n  {\n    pair<T,int> r(0,v);\n    for(auto e : (*this)[v]) if(e.dst != p)\n    {\n      auto t = farthest(v,e.dst);\n      t.first += e.w;\n      if(t.first > r.first) r=t;\n    }\n    return r;\n  }\n\n  void backward(Graph &h, int v, int s, int r,\n  vector<int> &no, vector<vector<int>> &cmp,\n  vector<int> &prev, vector<vector<int>> &next, vector<T> &mcost,\n  vector<int> &mark, T &cost, bool &found)\n  {\n    const int n = h.size();\n    if(mark[v])\n    {\n      vector<int> tmp = no;\n      found = true;\n      do {\n        cost += mcost[v];\n        v = prev[v];\n        if (v != s)\n        {\n          while (cmp[v].size() > 0)\n          {\n            no[cmp[v].back()] = s;\n            cmp[s].push_back(cmp[v].back());\n            cmp[v].pop_back();\n          }\n        }\n      } while (v != s);\n      for(auto j : cmp[s]) if(j!=r) for(int l=0;l<h[j].size();l++)\n        if(no[h[j][l].src]!=s) h[j][l].w -= mcost[tmp[j]];\n    }\n    mark[v] = true;\n    for(auto i : next[v]) if(no[i]!=no[v]&&prev[no[i]]==v)\n      if (!mark[no[i]]||i==s)\n        backward(h,i,s,r,no,cmp,prev,next,mcost,mark,cost,found);\n  }\n\n  void subaps(int current, int prev, int &timer,\n  vector<bool> &visited, vector<int> &prenum,\n  vector<int> &parent, vector<int> &lowest)\n  {\n    prenum[current]=lowest[current]=timer++;\n    visited[current]=true;\n    for(auto e : (*this)[current])\n    {\n      int next = e.dst;\n      if(!visited[next])\n      {\n        // cerr << e.src << \" \" << e.dst << endl;\n        parent[next]=current;\n        subaps(next,current,timer,visited,prenum,parent,lowest);\n        lowest[current]=min(lowest[current],lowest[next]);\n      }\n      else if(next != prev)\n        lowest[current]=min(lowest[current],prenum[next]);\n    }\n  }\n\n  void subbrs(int current, int prev, int &timer,\n  vector<int>&prenum, vector<int>&lowest, set<Edge<T>>&bridges)\n  {\n    prenum[current]=lowest[current]=timer++;\n    for(auto e : (*this)[current]) if(e.dst!=prev)\n    {\n      if(prenum[e.dst]==-1)\n      {\n        subbrs(e.dst,current,timer,prenum,lowest,bridges);\n        lowest[current]=min(lowest[current],lowest[e.dst]);\n        if(prenum[current] < lowest[e.dst])\n          bridges.insert(Edge<T>(min(e.dst,e.src),max(e.dst,e.src)));\n      }\n      lowest[current]=min(lowest[current],prenum[e.dst]);\n    }\n  }\n\npublic:\n  T inf;\n  Graph(int n){(*this).resize(n);inf=numeric_limits<T>::max();}\n  void direct(int s, int t){(*this)[s].push_back(Edge<T>(s,t));}\n  void direct(int s, int t, T w){(*this)[s].push_back(Edge<T>(s,t,w));}\n  void undirect(int s, int t){direct(s,t);direct(t,s);}\n  void undirect(int s, int t, T w){direct(s,t,w);direct(t,s,w);}\n\n  /*\n    cost : O(|V|)\n  */\n  T diameter(void)\n  {\n    auto r = farthest(-1,0);\n    auto t = farthest(-1,r.second);\n    return t.first;\n  }\n\n  /*\n    s : start point\n    cost : O(|E|+|V|log(|V|))\n    dist : distances\n  */\n  vector<T> dijkstra(int s = 0)\n  {\n    const int n = (*this).size();\n    priority_queue<Edge<T>> PQ;\n    vector<T> dist(n,inf);\n    dist[s] = 0; Edge<T> e(-1,s,0);\n    PQ.push(e);\n    while(!PQ.empty())\n    {\n      auto f = PQ.top(); PQ.pop();\n      int u = f.dst;\n      if(dist[u] < f.w * (-1)) continue;\n      for(int j=0;j<(*this)[u].size();j++)\n      {\n        int v = (*this)[u][j].dst;\n        if(dist[v] > dist[u] + (*this)[u][j].w)\n        {\n          dist[v] = dist[u] + (*this)[u][j].w;\n          Edge<T> e(-1,v,dist[v]*(-1));\n          PQ.push(e);\n        }\n      }\n    }\n    return dist;\n  }\n\n  /*\n    s : start point\n    cost : O(|V||E|)\n    first : is negative cycle ?\n    second : distances\n  */\n  pair<bool,vector<T>> bellmanFord(int s = 0)\n  {\n    const int n = (*this).size();\n    vector<T> dist(n,inf);\n    dist[s] = 0;\n    for(int i=0;i<n;i++)\n    {\n      bool update = false;\n      for(int v=0;v<n;v++) for(auto e : (*this)[v])\n      {\n        if (dist[v] != inf && dist[e.dst] > dist[v] + e.w)\n        {\n          dist[e.dst] = dist[v] + e.w;\n          update = true;\n          if(i==n-1) return make_pair(true,dist);\n        }\n      }\n      if(!update) break;\n    }\n    return make_pair(false,dist);\n  }\n\n  /*\n    Minimum Spanning Tree (Prim's algorithm)\n    r : root\n    cost : O(|E|+|V|log|V|) (because priority_queue use paring sort)\n    first : total cost\n    second : edges\n  */\n  pair<T, vector<Edge<T>>> MST(int r = 0)\n  {\n    const int n = (*this).size();\n    vector<Edge<T>> U;\n    T total = 0;\n    vector<bool> visited(n,false);\n    priority_queue<Edge<T>> Q;\n    Q.push(Edge<T>(-1,r,0));\n    while (!Q.empty())\n    {\n      auto e = Q.top(); Q.pop();\n      if (visited[e.dst]) continue;\n      U.push_back(e);\n      total += e.w;\n      visited[e.dst] = true;\n      for(auto f : (*this)[e.dst]) if (!visited[f.dst]) Q.push(f);\n    }\n    return make_pair(total, U);\n  }\n\n  /*\n    Minimum Spanning Arborescence(Chu-Liu/Edmond)\n    r : root\n    cost : O(|V||E|)\n  */\n  T MSA(int r = 0) {\n    const int n = (*this).size();\n    Graph<T> h(n);\n    for(int i=0;i<n;i++) for(auto e : (*this)[i]) h[e.dst].push_back(e);\n    vector<int> no(n);\n    vector< vector<int> > cmp(n);\n    for(int i=0;i<n;i++) cmp[i].push_back(no[i]=i);\n    for (T cost=0;;)\n    {\n      vector<int> prev(n,-1);\n      vector<T> mcost(n,inf);\n      for(int j=0;j<n;j++) if(j!=r) for(auto e : h[j])\n        if (no[e.src] != no[j])\n          if (e.w < mcost[no[j]])\n            mcost[no[j]] = e.w, prev[no[j]] = no[e.src];\n      vector<vector<int>> next(n);\n      for(int i=0;i<n;i++) if(prev[i]>=0)\n        next[prev[i]].push_back(i);\n      bool stop = true;\n      vector<int> mark(n);\n      for(int i=0;i<n;i++) if(i!=r&&!mark[i]&&!cmp[i].empty())\n      {\n        bool found = false;\n        backward(h, i, i, r, no, cmp, prev, next, mcost, mark, cost, found);\n        if (found) stop = false;\n      }\n      if (stop)\n      {\n        for(int i=0;i<n;i++) if(prev[i] >= 0) cost+=mcost[i];\n        return cost;\n      }\n    }\n  }\n\n  /*\n    articulation points\n    costs O(|E|log|V|)\n  */\n  set<int> APs(void)\n  {\n    const int n = (*this).size();\n    set<int> ap;\n    if(n==1) return ap;\n    int timer = 1;\n    vector<bool> visited(n,false);\n    vector<int> prenum(n), parent(n), lowest(n);\n    subaps(0,-1,timer,visited,prenum,parent,lowest);\n    int np = 0;\n    for(int i=1; i<n; i++)\n    {\n      int p = parent[i];\n      if(p==0) np++;\n      else if(prenum[p]<=lowest[i]) ap.insert(p);\n    }\n    if(np > 1) ap.insert(0);\n    return ap;\n  }\n\n  /*\n    bridges\n    only undirect graph\n  */\n  set<Edge<T>> bridges(void)\n  {\n    const int n = (*this).size();\n    set<Edge<T>> bridges;\n    vector<int> prenum(n,-1), lowest(n,inf);\n    int timer = 0;\n    for(int i=0;i<n;i++) if(prenum[i]==-1)\n      subbrs(i,-1,timer,prenum,lowest,bridges);\n    return bridges;\n  }\n};\n\nint main()\n{\n  int v,e,r; cin>>v>>e;\n  Graph<long long> g(v);\n  REP(i,e)\n  {\n    ll s,t; cin >> s >> t;\n    g.undirect(s,t);\n  }\n  auto ans = g.bridges();\n  for(auto x : ans) cout << x.src << \" \" << x.dst << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  int V;\n  BiconectedGraph(){}\n  BiconectedGraph(int n){\n    G.clear();\n    C.clear();\n    T.clear();\n    G.resize(n);\n    C.resize(n);\n    T.resize(n);\n  }\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  void dfs(int u,int p,int &k){\n    ord[u]=low[u]=k;\n    ++k;\n    for(int v:G[u]){\n      if(v==p) continue;\n      if(ord[v]>=0){\n\tlow[u]=min(low[u],ord[v]);\n      }else{\n\tdfs(v,u,k);\n\tlow[u]=min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u]=c;\n    for(int v:G[u]){\n      if(belong[v]>=0||is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  void add_component(int u,int &k){\n    if(belong[u]>=0) return;\n    fill_component(k++,u);\n  }\n  \n  void build(int n){\n    int k=0;\n    ord.clear();\n    ord.resize(n,-1);\n    low.clear();\n    low.resize(n);\n    belong.clear();\n    belong.resize(n,-1);\n    for(int u=0;u<n;u++){\n      if(ord[u]>=0) continue;\n      dfs(u,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    add_component(0,k);\n    V=k;\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n  }\n};\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  BiconectedGraph bcc(v);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    bcc.add_edge(s,t);\n  }\n  bcc.build(v);\n  typedef pair<int,int> P;\n  vector<P> B=bcc.B;\n  sort(B.begin(),B.end());\n  for(P p:B) cout<<p.first<<\" \"<<p.second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\nconstexpr int INF = 1 << 28;\nusing EdgeList = vector<vector<int>>;\nusing pii = pair<int, int>;\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nvector<pii> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    vector<pii> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(int nxt : E[now]) {\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.emplace_back(min(now, nxt), max(now, nxt));\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            } \n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n// ?????£?????????????????°?????? E ?????¢??????????????????????????????\n// O(N + M) N: ????????°, M: ?????°\nvector<int> enumerate_articulations(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    vector<int> articulations;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        \n        bool is_articulation = false;\n        int dfs_children = 0;\n        \n        for(int nxt : E[now]) {\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs_children++;\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(pre >= 0 and ord[now] <= low[nxt]) {\n                    is_articulation = true;\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            } \n        }\n        if(pre < 0 and dfs_children > 1) is_articulation = true;\n        if(is_articulation) articulations.push_back(now);\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return articulations;\n}\nint main() {\n    int N, M; cin >> N >> M;\n    EdgeList E(N);\n    rep(i, M) {\n        int a, b; cin >> a >> b;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    auto ans = enumerate_bridges(E);\n    sort(begin(ans), end(ans));\n    for(pii p : ans) cout << p.first << \" \" << p.second << endl;        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<int> > graph(100001);\nvector<int> pre(100001, -1);\nvector<int> low(100001, -1);\n\nvoid dfs(int now, int before)\n{\n\tpre[now] = now;\n\tlow[now] = now;\n\tfor(int i = 0; i < graph[now].size(); i++){\n\t\tint next = graph[now][i];\n\t\tif(next == before) continue;\n\t\tif(pre[next] == -1) dfs(next, now);\n\t\tlow[now] = min(low[now], low[next]);\n\t}\n\t// cout << now << \" \" << pre[now] << \" \" << low[now] << endl;\n}\n\nint main()\n{\n\tint v, e;\n\tcin >> v >> e;\n\tfor(int i = 0; i < e; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\tdfs(0, -1);\n\tvector<pair<int, int> > ans;\n\tfor(int i = 0; i < v; i++){\n\t\tfor(int j = 0; j < graph[i].size(); j++){\n\t\t\tint next = graph[i][j];\n\t\t\tif(pre[next] == low[next] && i < next) ans.push_back(make_pair(i, next));\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end());\n\tfor(int i = 0; i < ans.size(); i++){\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define MAX_V 100000\n\nint V, E;\nvector<int> G[MAX_V];\nvector<pair<int, int> > bridge;\nbool visited[MAX_V];\nint prenum[MAX_V];\nint parent[MAX_V];\nint lowest[MAX_V];\nint timer, root;\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nvoid dfs(int u, int prev) {\n    prenum[u] = timer;\n    lowest[u] = timer;\n    timer++;\n\n    visited[u] = true;\n\n    for(int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      if(!visited[v]) {\n        dfs(v, u);\n        lowest[u] = min(lowest[u], lowest[v]);\n        if(lowest[v] == prenum[v]) {\n          if(u < v) bridge.push_back(make_pair(u, v));\n          else bridge.push_back(make_pair(v, u));\n        }\n      } else if(v != prev) {\n        lowest[u] = min(lowest[u], prenum[v]);\n      }\n    }\n\n}\n\nint main () {\n  cin >> V >> E;\n  for(int i = 0; i < E; i++) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    add_edge(v1, v2);\n  }\n\n  for(int i = 0; i < V; i++) {\n    visited[i] = false;\n  }\n  root = 0;\n  timer = 1;\n  dfs(root, -1);\n\n  sort(bridge.begin(), bridge.end());\n  for(int i = 0; i < bridge.size(); i++) {\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Bridge{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;\n  vector<int> low;\n  int ok;\n\n  Bridge():V(-1),ok(false){};\n  Bridge(int V):V(V),G(V),ord(V),low(V),ok(false){};\n  \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a >=0 && b >= 0 && a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void build(){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    \n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      if(ord[pos] != -1) return low[pos];\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) if(to != pre) low[pos] = min(low[pos], dfs(to, pos));\n      return low[pos];\n    };\n\n    for(int i=0;i<V;i++) low[i] = dfs(i, -1);\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    return ord[a] < low[b];\n  }\n\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int V,E;\n  cin>>V>>E;\n  \n  Bridge A(V);\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    A.add_edge(a,b);\n  }\n\n  A.build();\n  typedef pair<int,int> P;\n  vector<P> ans;\n  for(int i=0;i<V;i++)\n    for(int j:A.G[i]) if(A.isBridge(i, j)) ans.push_back(P(i, j));\n  \n  sort(ans.begin(),ans.end());\n  for(auto p:ans) cout<<p.first<<\" \"<<p.second<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\nnamespace __bridge{\n\ttypedef vector<vector<int>> Graph;\n    //O(V+E)\n\tclass Bridge{\n\tprivate:\n\t\tint N;Graph g;\n\t\tvector<int> ord,low,cmp;vector<bool> vis;\n\t\tstack<int> st;vector<bool> S;\n\t\tvoid dfs(int v,int p,int &oi,int &gi){\n\t\t\tvis[v]=true;ord[v]=low[v]=oi++;st.push(v);S[v]=true;\n\t\t\tfor(int to:g[v]){\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tdfs(to,v,oi,gi);\n\t\t\t\t\tlow[v]=min(low[v],low[to]);\n\t\t\t\t\tif(ord[v]<low[to])bridges.push_back(make_pair(min(v,to),max(v,to)));\n\t\t\t\t}else if(to != p){\n\t\t\t\t\tlow[v]=min(low[v],ord[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<pair<int,int>> bridges;\n\t\tBridge(int N):N(N){\n\t\t\tg=Graph(N);ord=low=cmp=vector<int>(N);vis=vector<bool>(N);\n\t\t}\n\t\tvoid add_edge(int f,int t){\n\t\t\tg[f].push_back(t);g[t].push_back(f);\n\t\t}\n\t\tvector<pair<int,int>> bridge(){\n\t\t\tint oi=0,gi=0;REP(v,N)if(!vis[v])dfs(v,-1,oi,gi);\n\t\t\treturn bridges;\n\t\t}\n\t\tbool same(int i,int j){return low[i]==low[j];}\n\t};\n}\nusing namespace __bridge;\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint V,E;cin >> V >> E;\n\t\tBridge bg(V);\n\t\tREP(i,E){\n\t\t\tint s,t;cin >> s >> t;\n\t\t\tbg.add_edge(s,t);\n\t\t}\n\t\tbg.bridge();\n\t\tsort(ALL(bg.bridges));\n\t\tREP(i,bg.bridges.size())\n\t\t\tcout <<bg.bridges[i]<<endl;\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 以下のライブラリを使ってみる.\n// dohatsu氏.\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1927353#1\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n#define MAX 100005\nint V, E;\nvector<int> G[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\nvector<P> ans;\n\nvoid dfs(int pos, int prev){\n    visited[pos] = true;\n    for(int i = 0; i < (int)G[pos].size(); i++){\n        int to = G[pos][i];\n        if(to==prev)continue;\n        if(!visited[to]){\n            depth[to] = depth[pos] + 1;\n            dfs(to, pos);\n            cnt[pos]+=cnt[to];\n            if(cnt[to] == 0) ans.push_back(P(min(pos,to) , max(pos,to)));\n        }else if(depth[to] < depth[pos]){\n            cnt[pos]++;\n            cnt[to]--;\n        }\n    }\n}\n \nint main(){\n    scanf(\"%d %d\", &V, &E);\n    for(int i = 0; i < E; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(0,-1);\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < (int)ans.size(); i++) printf(\"%d %d\\n\",ans[i].first, ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// lolinkの自作ライブラリ\n/* option1:グラフが非連結の場合,option2:bridgeの検出,option3:関節点の検出*/\n#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define loINF (long)10000000000\n#define shINF (short)10000\n#define SORT(c) sort((c).begin(),(c).end())\n//#define NOT_ALL_CONNECTED \t//option1\n#define BRIDGE   \t\t\t\t//option2\n//#define ARTICULATION_POINT    //option3\nusing namespace std;\nconst long V_START = 0;\ntypedef vector<long> VL;\ntypedef vector<VL> VVL;\ntypedef pair<long,long> pr;\ntypedef vector<pr> VP;\n\nbool pairCompare(const pr& firstElof, const pr& secondElof)\n{\n    return firstElof.first < secondElof.first;\n}\n\nVVL edge;\nVL ord;\nVL low;\nVL pre;\n\nvoid dfs(long now_ver,long parent,long order){\n\tlong child_num = 1;\n\tchar flag = 0;\n\tpre[now_ver] = parent;\n\tlow[now_ver] = ord[now_ver] = order;\n\n\tREP(i,edge[now_ver].size()){\n\t\tlong to = edge[now_ver][i];\n\t\tif (to == parent) continue;\n\t\tif (ord[to] == -1) { // 子ノードへの辺\n\t\t\tdfs(to,now_ver,order + child_num);\n\t\t\tchild_num++;\n\t\t\tlow[now_ver] = min(low[now_ver],low[to]);\n\t\t}\n\t\tlow[now_ver]=min(low[now_ver],ord[to]);\n\t}\n}\n\nint main(void){\n\tlong V,E;\n\tcin >> V >> E;\n\tedge = VVL(V+1,VL(0));\n\tord = VL(V+1,-1);\n\tlow = VL(V+1,loINF);\n\tpre = VL(V+1,-1);\n\n\tREP(i,E){\n\t\tlong u,v;\n\t\tcin >> u >> v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u); \n\t}\n\n\t#ifdef NOT_ALL_CONNECTED // グラフが非連結の場合\n\t\tFOR(i,V_START,V+V_START) \n\t\t\tif(ord[i] == -1)\n\t\t\t\tdfs(i,-1,1);\n\t#endif\n\n\t#ifndef NOT_ALL_CONNECTED // グラフが連結の場合\n\t\tdfs(1,-1,1);\n\t#endif\n\n\t#ifdef BRIDGE\n\t\tVP bridge;\n\t\tlong bridge_count = 0;\n\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (ord[i] == low[i]) {\n\t\t\t\tif (i == 1) continue;\n\t\t\t\tbridge.push_back(make_pair(min(i,pre[i]),max(i,pre[i])));\n\t\t\t\tbridge_count++;\n\t\t\t}\n\t\t}\n\n\t\tsort(bridge.begin(),bridge.end(),pairCompare);\n\n\t\tREP(i,bridge.size()) \n\t\t\tcout << bridge[i].first << \" \" << bridge[i].second << endl;\n\t#endif\n\n\t#ifdef ARTICULATION_POINT\n\t\tVL point;\n\t\tlong point_count = 0;\n\t\tchar root_count = 0;\n\t\tFOR(i,V_START,V+V_START){\n\t\t\tif (pre[i] == -1) continue;\n\t\t\tif (pre[i] == 1) root_count++;\n\t\t\telse {\n\t\t\t\tif (ord[pre[i]] <= low[i]) {\n\t\t\t\t\tpoint.push_back(pre[i]);\n\t\t\t\t\tpoint_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(root_count >= 2) {\n\t\t\tpoint.push_back(1);\n\t\t\tpoint_count++;\n\t\t}\n\n\t\tSORT(point);\n\t\tpoint.erase(unique(point.begin(),point.end()),point.end());\n\n\t\t// point_count:関節点の個数 , point:関節点\n\t\tcout << \"関節点の個数:\" << point_count << endl;\n\t\tREP(i,point.size()) cout << point[i] << endl;\n\t\t\n\t#endif\n\n\t#ifdef DEBUG\n\t\tdump1d_arr(ord);\n\t\tdump1d_arr(low);\n\t\tdump1d_arr(pre);\n\t#endif\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\nvector<int> grf[MAXN];\nint visited[MAXN],tin[MAXN],low[MAXN];\nint timer = 0, n,m;\nset<int> arp;\nset<pair<int,int>> brgs;\n\nvoid dfs1(int u,int p=-1){\n    visited[u]=true;\n    tin[u]=low[u]= timer++;\n    int childs=0;\n    for(auto x: grf[u]){\n        if(x==p){continue;}\n        if( visited[x]){\n            // ancestor\n            low[u]=min(low[u],tin[x]);\n        }\n        else{\n            childs++;\n            dfs1(x,u);\n            low[u] = min(low[u],low[x]);\n            if(p!= -1 and low[x] >= tin[u]){\n                arp.insert(u);\n            }\n        }\n    }\n\n    if( p==-1 and childs>1){\n        arp.insert(u);\n    }\n}\n\nvoid dfs(int u,int p=-1){\n    visited[u]=true;\n    tin[u]=low[u]=timer++;\n    for(auto x:grf[u]){\n        if(x==p){continue;}\n        if(visited[x]){\n            // ancestor\n            low[u] = min(low[u], tin[x]);\n        }\n        else{\n            dfs(x,u);\n            low[u] = min(low[u],low[x]);\n            if(low[x] > tin[u]){\n                brgs.insert({min(u,x),max(u,x)});\n            }\n        }\n    }\n}\n\n\nint main() {\n    // freopen(\"./input.txt\",\"r\",stdin);\n    // freopen(\"./output.txt\",\"w\",stdout);\n    cin>>n>>m;\n    for(int i=0; i<m; i++){\n        int x,y; cin>>x>>y;\n        grf[x].push_back(y);\n        grf[y].push_back(x);\n    }\n    for(int i=0; i<n; i++){\n        if(!visited[i]){\n            dfs(i);\n        }\n    }\n    for(auto p: brgs){\n        cout<<p.first<<\" \"<<p.second<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((long long)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst double PI = atan(1.0) * 4.0;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\nstruct LowLink {\n    VVL G;\n    vector<int> used, ord, low;\n    vector<int> articulation;\n    vector<pair<int, int>> bridge;\n\n    LowLink(int n) : G(n) {}\n\n    void add_edge(int u, int v) {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    int dfs(int idx, int k, int par) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_articulation = false;\n        int cnt = 0;\n        for(auto &to : G[idx]) {\n            if(!used[to]) {\n                ++cnt;\n                k = dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_articulation |= ~par && low[to] >= ord[idx];\n                if(ord[idx] < low[to])\n                    bridge.emplace_back(minmax(idx, (int)to));\n            } else if(to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if(is_articulation) articulation.push_back(idx);\n        return k;\n    }\n\n    virtual void build() {\n        used.assign(G.size(), 0);\n        ord.assign(G.size(), 0);\n        low.assign(G.size(), 0);\n        int k = 0;\n        for(int i = 0; i < G.size(); i++) {\n            if(!used[i]) k = dfs(i, k, -1);\n        }\n        // NlogN, MlogM\n        sort(All(articulation));\n        sort(All(bridge));\n    }\n};\n\nsigned main() {\n    LCIN(N, M);\n    LowLink ll(N);\n    REP(i, M) {\n        LCIN(s, t);\n        ll.add_edge(s, t);\n    }\n    ll.build();\n    FOREACH(v, ll.bridge) { cout << v.fi << \" \" << v.se << \"\\n\"; }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//橋と関節点:  O(V + E)\nclass Lowlink{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;           //ord[i] := ノードiに訪れた順番\n  vector<int> low;           //low[i] := ノードiから訪れることができる最小のord[j]の値。\n  vector<int> articulation;\n  int ok;\n  \n  Lowlink():V(-1),ok(false){};\n  Lowlink(int V):V(V),G(V),ok(false){};\n  \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a < V && b < V);\n    assert(a >=0 && b >= 0);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void build(int root = 0){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    articulation.clear(); articulation.resize(V,0); /*関節点用*/\n    \n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) {\n        if(to == pre) continue; \n        if(ord[to] != -1) low[pos] = min(low[pos], ord[to]);\n        else {\n          low[pos] = min(low[pos], dfs(to, pos));\n\t  \n\t  /*関節点用*/\n\t  if(pos == root) articulation[pos]++;\n\t  else articulation[pos] |= ord[pos] <= low[to];\n\t  \n\t}\n      }\n      return low[pos];\n    };\n    \n    dfs(root , -1);\n    articulation[root] = articulation[root] >= 2; /*関節点用*/\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n  \n  int isArticulation(int a){\n    assert(ok);\n    assert(a >= 0 && a < V);\n    return articulation[a];\n  }\n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  auto verifyBridge=[&]{\n    int V, E;\n    cin>>V>>E;\n  \n    Lowlink A(V);\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      A.add_edge(a,b);\n    }\n    \n    A.build();\n    \n    typedef pair<int,int> P;\n    vector<P> ans;\n    for(int i=0;i<V;i++)\n      for(int to:A.G[i]) if(i < to && A.isBridge(i, to)) ans.push_back(P(i, to));\n    \n    sort(ans.begin(),ans.end());\n    for(auto a:ans) cout<<a.first<<\" \"<<a.second<<endl;\n  };\n\n  verifyBridge();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define MAX_V 100000\n\nint V, E;\nvector<int> G[MAX_V];\nvector<pair<int, int> > bridge;\nbool visited[MAX_V];\nint prenum[MAX_V];\nint parent[MAX_V];\nint lowest[MAX_V];\nint timer, root;\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nvoid dfs(int u, int prev) {\n    prenum[u] = timer;\n    lowest[u] = timer;\n    timer++;\n\n    visited[u] = true;\n\n    for(int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      if(!visited[v]) {\n        dfs(v, u);\n        lowest[u] = min(lowest[u], lowest[v]);\n        if(lowest[v] == prenum[v]) {\n          bridge.push_back(make_pair(u, v));\n        }\n      } else if(v != prev) {\n        lowest[u] = min(lowest[u], prenum[v]);\n      }\n    }\n\n}\n\nint main () {\n  cin >> V >> E;\n  for(int i = 0; i < E; i++) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    add_edge(v1, v2);\n  }\n\n  for(int i = 0; i < V; i++) {\n    visited[i] = false;\n  }\n  root = 0;\n  timer = 1;\n  dfs(root, -1);\n\n  sort(bridge.begin(), bridge.end());\n  for(int i = 0; i < bridge.size(); i++) {\n    cout << bridge[i].first << \" \" << bridge[i].second << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n#define fi first\n#define se second\nconst ll INFLL=LLONG_MAX;\nconst int INF=INT_MAX;\n#define eb emplace_back\n#define emp emplace\n#define mp(a,b) make_pair(a,b)\ntemplate<class T> using min_heap=priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T>\nvoid sort(vector<T>& v){\n\tsort(v.begin(),v.end());\n}\ntemplate <class T, class U>\nvoid sort(vector<T>& v,U func){\n\tsort(v.begin(),v.end(),func);\n}\ntemplate <class T>\nint lb_index(vector<T>& v,T k){\n\treturn lower_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate <class T>\nint ub_index(vector<T>& v,T k){\n\treturn upper_bound(v.begin(),v.end(),k)-v.begin();\n}\nint n,m;\nvector<int>v[100000];\nvector<int>st(100000,-1),et(100000,-1);\nvector<int>low(100000);\nvector<pair<int,int> >bridge;\nint tim;\nvoid dfs(int u,int p){\n\tst[u]=tim++;\n\tlow[u]=st[u];\n\tfor(auto i:v[u]){\n\t\tif(p==i)continue;\n\t\tif(st[i]==-1){\n\t\t\tdfs(i,u);\n\t\t\tlow[u]=min(low[u],low[i]);\n\t\t\tif(st[u]<low[i]){\n\t\t\t\tbridge.emplace_back(u,i);\n\t\t\t}\n\t\t}\n\t\telse if(et[i]==-1){\n\t\t\tlow[u]=min(low[u],st[i]);\n\t\t}\n\t}\n\tet[u]=tim;\n}\nint main(){\n\tcin>>n>>m;\n\twhile(m--){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tv[l].emplace_back(r);\n\t\tv[r].emplace_back(l);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(st[i]==-1)dfs(i,-1);\n\t}\n\tmap<pii,bool>p;\n\tfor(int i=0;i<bridge.size();i++){\n\t\tbridge[i]={min(bridge[i].fi,bridge[i].se),max(bridge[i].fi,bridge[i].se)};\n\t}\n\tsort(bridge);\n\tfor(auto i:bridge){\n\t\tif(!p[i])cout<<min(i.fi,i.se)<<\" \"<<max(i.fi,i.se)<<\"\\n\";\n\t\tp[i]=1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 10000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  return ord[s] < lowlink[t];\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    edges.push_back(make_pair(s, t));\n  }\n  dfs(0, -1);\n  sort(edges.begin(), edges.end());\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\ntypedef pair<int, int> pii;\nstruct Node{\n  int ord, low;\n};\n\nclass BridgeFind{\npublic:\n  BridgeFind(Graph _g){\n    g = _g;\n    node.resize(g.size(), Node{-1, (int)1e9});\n  }\n  vector<pii> find(){\n    if(v_ord == 0)dfs();\n    return bridge;\n  }\nprivate:\n  void dfs(int v  = 0,\n           int previous = -1){\n    node[v].ord = node[v].low = v_ord++;\n    int to;\n    for (int i = 0; i < g[v].size(); i++) {\n      to = g[v][i];\n      if(previous == to)continue;\n      if(node[to].ord == -1) dfs(to, v);\n      node[v].low = min(node[v].low, node[to].low);\n    }\n    if(node[v].low == node[v].ord and previous != -1)\n      bridge.emplace_back(pii(previous, v));\n  }\n  int v_ord = 0;\n  vector<pii> bridge;\n  Graph g;\n  vector<Node> node;\n};\n\nint main(int argc, char *argv[]){\n  int n, m;\n  std::cin >> n >> m;\n  Graph g(n, vector<int>());\n  for (int i = 0; i < m; i++) {\n    int to, from;\n    std::cin >> to >> from;\n    g[to].push_back(from);\n    g[from].push_back(to);\n  }\n  BridgeFind bf(g);\n  vector<pii> bridge = bf.find();\n  sort(bridge.begin(), bridge.end());\n  for (int i = 0; i < bridge.size(); i++) {\n    std::cout << bridge[i].first << \" \" << bridge[i].second << std::endl;\n  }\n  // for (auto i: bridge){\n  //   std::cout << i.first << \" \" << i.second << std::endl;\n  // }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 100000\n\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nint ord[MAX_V], parent[MAX_V], lowlink[MAX_V], timer;\n\nvector <pair<int, int> > edges;\nvector <pair<int, int> > bridge;\n\nvoid dfs(int current, int prev) {\n  ord[current] = lowlink[current] = timer;\n  timer++;\n\n  vis[current] = true;\n\n  int next;\n  for (int i = 0; i < graph[current].size(); i++) {\n    next = graph[current][i];\n    if (!vis[next]) {\n      parent[next] = current;\n\n      dfs(next, current);\n      lowlink[current] = min(lowlink[current], lowlink[next]);\n    }else if (next != prev) {\n      lowlink[current] = min(lowlink[current], ord[next]);\n    }\n  }\n}\n\nbool is_bridge(int s, int t) {\n  if (ord[s] > ord[t]) swap(s, t);\n  return ord[s] < lowlink[t];\n}\n\nvoid init_bridge() {\n  memset(vis, false, sizeof(vis));\n  timer = 1;\n  dfs(0, -1);\n}\n\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    graph[t].push_back(s);\n    if (s > t) swap(s, t);\n    edges.push_back(make_pair(s, t));\n  }\n  sort(edges.begin(), edges.end());\n  init_bridge();\n  for (int i = 0; i < e; i++) {\n    int s = edges[i].first, t = edges[i].second;\n    if (is_bridge(s, t)) {\n      cout << s << \" \" << t << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100010\ntypedef pair<int,int> P;\nvector<int> G[100010];\nint V,E;\nint ord[100010];\nint low[100010];\n\nint lowlink(int x,int p,int n){\n  if(ord[x]==INF)ord[x]=n;\n  else return ord[x];\n  int ans=INF;\n  for(int i=0;i<G[x].size();i++){\n    if(G[x][i]==p)continue;\n    ans=min(ans,lowlink(G[x][i],x,n+1));\n  }\n  return low[x]=ans;\n}\n\nint main(){\n  for(int i=0;i<100010;i++)\n    low[i]=ord[i]=INF;\n  cin>>V>>E;\n  P p[100010];\n  for(int i=0;i<E;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(t);\n    G[t].push_back(s);\n    p[i]=P(s,t);\n  }\n  sort(p,p+E);\n  lowlink(0,-1,0);\n  for(int i=0;i<E;i++){\n    int f=0;\n    int u=p[i].first,v=p[i].second;\n    if(ord[u]>ord[v])swap(u,v);\n    if(ord[u]<low[v])cout<<p[i].first<<\" \"<<p[i].second<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n#define PAD(a,b) MP(((a).first + (b).first),((a).second, (b).second))\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0, 1 }, { -1, 0 }, { 1, 0 }, { 0, -1 },\n\t{ 1, 1 }, { 1, -1 }, { -1, 1 }, { -1, -1 }\n}; \nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n};\n\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b, w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//??????\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b, w });\n\t\tsumcost++;\n\t}\n};\n\n//Lowlink  BID\nvoid Lowlink(BiDGraph& g, vector<int>& lowlink, DGraph& dfsg, vector<int>& orb, int st = 0) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int, int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (f == itr.first) {f = -1; continue;}\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first, cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t\tdfsg.con(cur, itr.first);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(st, -1);\n\treturn;\n}\n//Lowlink D\nvoid Lowlink(DGraph& g, vector<int>& lowlink, DGraph& dfsg, vector<int>& orb, int st = 0) {\n\torb.resize(g.vn, INT_MAX);\n\tlowlink.resize(g.vn, INT_MAX);\n\tint k = 0;\n\tfunction<void(int, int)> dfs = [&](int cur, int f) {\n\t\tint nex = 0;\n\t\torb[cur] = k++;\n\t\tlowlink[cur] = orb[cur];\n\t\tfor (auto itr : g.g[cur]) {\n\t\t\tif (orb[itr.first] == INT_MAX) {\n\t\t\t\tdfs(itr.first, cur);\n\t\t\t\tlowlink[cur] = min(lowlink[cur], lowlink[itr.first]);\n\t\t\t\tdfsg.con(cur, itr.first);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlowlink[cur] = min(lowlink[cur], orb[itr.first]);\n\t\t\t}\n\t\t}\n\t};\n\tdfs(st, -1);\n\treturn;\n}\n//??¢???????????¨??????\ntemplate<typename Gtype>\nvoid Joint(Gtype& g, vector<int>& joints, int st = 0) {\n\tvector<int> lowlink, orb;\n\tDGraph dfsg(g.vn);\n\tLowlink(g, lowlink, dfsg, orb, st);\n\n\tREP(i, dfsg.vn) {\n\t\tif (st == i) continue;\n\t\tif (orb[i] == INT_MAX) continue;\n\t\tfor (auto itr : dfsg.g[i]) {\n\t\t\tif (orb[itr.first] == INT_MAX) continue;\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] <= lowlink[itr.first]) {\n\t\t\t\tjoints.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (dfsg.g[st].size() > 1)\n\t\tjoints.push_back(st);\n}\ntemplate<typename Gtype>\nvoid Bridge(Gtype& g, vector<pii>& bridges, int st = 0) {\n\tvector<int> lowlink, orb;\n\tDGraph dfsg(g.vn);\n\tLowlink(g, lowlink, dfsg, orb, st);\n\n\tREP(i, dfsg.vn) {\n\t\tfor (auto itr : dfsg.g[i]) {\n\t\t\tif (orb[i] > orb[itr.first]) continue;\n\n\t\t\tif (orb[i] < lowlink[itr.first]) {\n\t\t\t\tbridges.push_back({ i, itr.first });\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tint v, e;\n\tscnaf(\"%d %d\", &v, &e);\n\tBiDGraph g(v);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a, b);\n\t}\n\tvector<pii> bridges;\n\tBridge(g, bridges);\n\n\tfor (auto itr = bridges.begin(); itr != bridges.end(); itr++) {\n\t\tif (itr->first > itr->second)\n\t\t\tswap(itr->first, itr->second);\n\t}\n\tsort(ALL(bridges));\n\tfor (auto itr : bridges) {\n\t\tprintf(\"%d %d\\n\", itr.first, itr.second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\nstruct node {\n\tbool done;\n\tvi to;\n\tint id, from;\n\tint pre, low;\n};\n\nclass lowlink {\n\tint ord;\npublic:\n\tvector<node> nodes;\n\tvector<P> bridges;\n\tset<int> arts; //articulation point\n\tlowlink(vector<node> A) {\n\t\tord = 0;\n\t\tnodes = A;\n\t}\n\tvoid dfs(int a, int root) {\n\t\tnodes[a].done = 1;\n\t\tnodes[a].pre = nodes[a].low = ord;\n\t\tord++;\n\t\tint cnt = 0;\n\t\tLoop(i, nodes[a].to.size()) {\n\t\t\tint b = nodes[a].to[i];\n\t\t\tif (b == nodes[a].from) continue;\n\t\t\tif (!nodes[b].done) {\n\t\t\t\tnodes[b].from = a;\n\t\t\t\tdfs(b, root);\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].low);\n\t\t\t\tif (nodes[a].pre <= nodes[b].low) cnt++;\n\t\t\t\tif (nodes[a].pre < nodes[b].low) bridges.push_back({ a,b });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].low = min(nodes[a].low, nodes[b].pre);\n\t\t\t}\n\t\t}\n\t\tif (cnt > (a == root ? 1 : 0)) arts.insert(a);\n\t\treturn;\n\t}\n\tvoid find_bridges_and_arts() {\n\t\tLoop(i, nodes.size()) {\n\t\t\tif (!nodes[i].done) dfs(i, i);\n\t\t}\n\t\tLoop(i, bridges.size()) {\n\t\t\tif (bridges[i].first > bridges[i].second) swap(bridges[i].first, bridges[i].second);\n\t\t}\n\t\tsort(bridges.begin(), bridges.end());\n\t}\n};\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tvector<node> nodes(v);\n\tLoop(i, v) nodes[i] = { 0,{}, i,-1,-1,-1 };\n\tLoop(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].to.push_back(t);\n\t\tnodes[t].to.push_back(s);\n\t}\n\tlowlink lk(nodes);\n\tlk.find_bridges_and_arts();\n\t/*\n\tauto itr = lk.arts.begin();\n\tLoop(i, lk.arts.size()) {\n\t\tcout << *itr << endl;\n\t\titr++;\n\t}*/\n\tLoop(i, lk.bridges.size()) {\n\t\tcout << lk.bridges[i].first << \" \" << lk.bridges[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nstruct edge {\n\tint from,to;\n\tbool used;\n};\nstd::vector<int> G[100000];\nbool used_v[100000];\nedge es[100000];\nbool used_e[100000];\nbool bridge[100000];\nint ord[100000],lowlink[100000];\nint V,E;\nint k=0;\nvoid dfs(int v);\nbool check_edge(int from,int to);\nvoid set_edge(int from,int to);\nint main(void){\n\tstd::cin>>V>>E;\n\tfor(int i=0;i<E;i++){\n\t\tint from,to;\n\t\tstd::cin>>from>>to;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tes[i].from=from;\n\t\tes[i].to=to;\n\t}\n\tfor(int i=0;i<V;i++){\n\t\tused_v[i]=false;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tused_e[i]=false;\n\t\tbridge[i]=false;\n\t}\n\tdfs(0);\n\tfor(int i=0;i<V;i++){\n\t\tused_v[i]=false;\n\t}\n\n\tfor(int i=0;i<E;i++){\n\t\tfor(int j=i;j<E;j++){\n\t\t\tif(es[j].from<es[i].from){\n\t\t\t\tstd::swap(es[i].from,es[j].from);\n\t\t\t\tstd::swap(es[i].to,es[j].to);\t\t\t\t\n\t\t\t}else if(es[j].from==es[i].from){\n\t\t\t\tif(es[j].to<es[i].to){\n\t\t\t\t\tstd::swap(es[i].from,es[j].from);\n\t\t\t\t\tstd::swap(es[i].to,es[j].to);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tstd::cout<<ord[i]<<\" \"<<lowlink[i]<<std::endl;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint parent,child;\n\t\tif(ord[es[i].from]>ord[es[i].to]){\n\t\t\tparent=es[i].to;\n\t\t\tchild=es[i].from;\n\t\t}else {\n\t\t\tparent=es[i].from;\n\t\t\tchild=es[i].to;\n\t\t}\n\t\tif(ord[parent]<lowlink[child]){\n\t\t\tstd::cout<<es[i].from<<\" \"<<es[i].to<<std::endl;\n\t\t}\n//\t\tstd::cout<<es[i].from<<\" \"<<es[i].to<<std::endl;\n\t}\n\treturn 0;\n}\n/*void bridge_dfs(int v){\n\tused_v[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(used_v[G[v][i]]==false){\n\t\t\tset_edge(v,G[v][i]);\n\t\t\tdfs(G[v][i]);\n\t\t\tlowlink[v]=std::min(lowlink[v],lowlink[G[v][i]]);\n\t\t}else if(!check_edge(G[v][i],v)){\n\t\t\tlowlink[v]=std::min(lowlink[v],ord[G[v][i]]);\n\t\t}\n\t}\n}*/\nvoid dfs(int v){\n\tused_v[v]=true;\n\tord[v]=k;\n\tlowlink[v]=k;\n\tk++;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(used_v[G[v][i]]==false){\n\t\t\tset_edge(v,G[v][i]);\n\t\t\tdfs(G[v][i]);\n\t\t\tlowlink[v]=std::min(lowlink[v],lowlink[G[v][i]]);\n\t\t}else if(!check_edge(G[v][i],v)){\n\t\t\tlowlink[v]=std::min(lowlink[v],ord[G[v][i]]);\n\t\t}\n\t}\n}\nvoid set_edge(int from,int to){\n\tfor(int i=0;i<E;i++){\n\t\tif(es[i].from==from){\n\t\t\tif(es[i].to==to){\n\t\t\t\tused_e[i]=true;\n\t\t\t}\n\t\t}else if(es[i].to==from){\n\t\t\tif(es[i].from==to){\n\t\t\t\tused_e[i]=true;\n\t\t\t}\n\t\t}\n\t}\n}\nbool check_edge(int from,int to){\n\tfor(int i=0;i<E;i++){\n\t\tif(es[i].from==from){\n\t\t\tif(es[i].to==to){\n\t\t\t\treturn used_e[i];\n\t\t\t}\n\t\t}else if(es[i].to==from){\n\t\t\tif(es[i].from==to){\n\t\t\t\treturn used_e[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn false;//????????????\n}"
  },
  {
    "language": "C++",
    "code": "/*\n無向グラフに対して使う\n\nG=vector<int>を引数にすることを前提にしている\nedgeなどを使う場合には、eの所をe.toにする必要がある\n\nO(V+E)\n\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_A&lang=ja\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n参考:\nhttps://ei1333.github.io/luzhiled/snippets/graph/lowlink.html\nhttp://hos.ac/slides/20110504_graph.pdf\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long int;\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\ntypedef pair<int,int> pii;\n\nusing Graph=vector<vector<int>>;\n\n\ntemplate<typename G>\nstruct LowLink{\n    const G &g;\n    int sz;\n    vector<int> ord,low;\n    vector<bool> used;\n    vector<int> articulation;\n    vector<pii> bridge;\n    int k;\n\n    void dfs(int idx,int par){\n        used[idx]=true;\n        ord[idx]=k++;\n        low[idx]=ord[idx];\n        bool is_articulation=false;\n        int cnt=0;\n        for(auto &e:g[idx]){\n            if(!used[e]){\n                cnt++;\n                dfs(e,idx);\n                chmin(low[idx],low[e]);\n                if(ord[idx]<low[e]) bridge.emplace_back(minmax(idx,e));\n                is_articulation |=(par!=-1 && ord[idx]<=low[e]);\n            }else if(e!=par){\n                chmin(low[idx],ord[e]);\n            }\n        }\n        is_articulation |= (par==-1 && cnt>=2);\n        if(is_articulation) articulation.push_back(idx);\n\n    }\n\n    LowLink(const G &g):g(g){\n        sz=g.size();\n        used.assign(sz,false);\n        ord.assign(sz,0);\n        low.assign(sz,0);\n        k=0;\n        for(int i=0;i<sz;i++){\n            if(!used[i]) dfs(i,-1);\n        }\n    }\n\n\n};\n\nsigned main(){\n    /*int v,e;\n    cin>>v>>e;\n    vector<vector<int>> g(v);\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    LowLink<int> l(g);\n    vector<int> buri=l.articulation;\n    sort(buri.begin(),buri.end());\n    for(int i:buri){\n        cout<<i<<endl;\n    }*/\n\n    int v,e;\n    cin>>v>>e;\n    Graph g(v);\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(t);\n        g[t].push_back(s);\n    }\n    LowLink<Graph> l(g);\n    vector<pii> buri=l.bridge;\n    sort(buri.begin(),buri.end());\n    for(auto i:buri){\n        cout<<i.first<<\" \"<<i.second<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n\nclass Node {\npublic:\n\tNode():number(i++), order(0), min(0), edges(0), parent(0), art(false) {};\n\tvoid add_edge(Node *);\n\tstd::vector<Node*> &get_edge() { return edges; }\n\tbool operator==(const Node &other) { return number == other.number; }\n\tint order, min, number, parent;\n\tbool art;\n\tbool arti() { return art || edges.size() == 1; }\nprivate:\n\tstatic int i;\n\tstd::vector<Node*> edges;\n};\nint Node::i = 0 ;\nvoid Node::add_edge(Node *other) { edges.push_back(other); }\nint dfs(Node &current, int &order) {\n\tint min = order;\n\tint count = 0;\n\tfor (auto &node : current.get_edge()) {\n\t\tint temp;\n\t\tif (node->order == 0) {\n\t\t\tnode->order = ++order;\n\t\t\tnode->parent = current.order;\n\t\t\ttemp = dfs(*node, order);\n\t\t\tif (temp == current.order) {\n\t\t\t\tcurrent.art = true;\n\t\t\t}\n\t\t\t++count;\n\t\t}\n\t\telse {\n\t\t\ttemp = node->order;\n\t\t}\n\t\tif (min > temp) {\n\t\t\tmin = temp;\n\t\t}\n\t}\n\tif (current.number == 0) {\n\t\tif (count > 1) {\n\t\t\tcurrent.art = true;\n\t\t}\n\t\telse {\n\t\t\tcurrent.art = false;\n\t\t}\n\t}\n\tcurrent.min = min;\n\treturn min;\n}\nclass Edge {\npublic:\n\tEdge(const int &sn = 0, const int &tn = 0, Node *s = nullptr, Node *e = nullptr) : s_num(sn), t_num(tn), start{ s }, end{ e }, number(i++) {};\n\tbool suspect() { return (start->arti() && end->arti()) && (start->order == end->number || start->number == end->order); }\n\tbool operator<(const Edge &other) { return (s_num < other.s_num) || (s_num == other.s_num && t_num < other.t_num); }\n\tvoid show() { std::cout << s_num << \" \" << t_num << \"\\n\"; }\nprivate:\n\tNode *start, *end;\n\tint s_num, t_num, number;\n\tstatic int i;\n};\nint Edge::i(0);\nvoid sort(std::vector<Edge> &vector, const int left, const int right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (vector.at(l) < pivot)++l;\n\t\t\twhile (pivot < vector.at(r))--r;\n\t\t\tif (l <= r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, l, right);\n\t}\n}\nint main() {\n\tint v, e;\n\tstd::cin >> v >> e;\n\tstd::vector<Node> node(v);\n\tstd::vector<Edge> edge(e);\n\tfor (auto i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tstd::cin >> s >> t;\n\t\tedge.at(i) = Edge(s, t, &node.at(s), &node.at(t));\n\t\tnode.at(s).add_edge(&node.at(t));\n\t\tnode.at(t).add_edge(&node.at(s));\n\t}\n\tnode.at(0).order = 1;\n\tint order = 1;\n\tdfs(node.at(0), order);\n\tsort(edge, 0, edge.size() - 1);\n\tfor (auto v : node) {\n\t\t//std::cout << v.number << \"--art= \" << v.arti() << \"--min= \" << v.min << \"--order= \" << v.order << std::endl;\n\t}\n\tfor (auto e : edge) {\n\t\tif (e.suspect()) {\n\t\t\te.show();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include<utility>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\nconst int nCk_MAX = 510000;//nCkの前計算で使うかもしれない 普段は入ってないよ\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//フローで使う容量を意味するcapaも追加\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\tll capa;\n\n\tedge(int s, int d) : from(s), to(d) {\n\t\tcost = 0; capa = 0;\n\t}\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n\tedge(int s, int d, ll x, ll y) :from(s), to(d), cost(x), capa(y) {  }\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\nusing graph = vector<vector<edge>>;\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n#define ALL(vec_etc) vec_etc.begin(),vec_etc.end()\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll PowMod(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll Gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? Gcd(b, a % b) : a;\n}\nll Lcm(ll a, ll b) {//最小公倍数\n\treturn a / Gcd(a, b) * b;\n}\nvector<string> split(string s, string t) {\n\t//文字列を文字列で分割する\n\tvector<string> v;\n\tint p = s.find(t);\n\tif (p != s.npos) {\n\t\tv.push_back(s.substr(0, p));\n\t\ts = s.substr(p + t.size());\n\t}\n\tv.push_back(s);\n\treturn v;\n}\nvector<int> Lis(const vector<int>& a) {\n\t//#define index_of(as, x) distance(as.begin(), lower_bound(as.begin(), as.end(), x))\n#define index_of(as, x) distance(as.begin(), upper_bound(as.begin(), as.end(), x))\n//upper_boundを使用すると、重複を許した最長増加部分列になる\n//-1倍した値を入れれば、最長減少部分列になる\n\tconst int n = a.size();\n\tvector<int> A(n, INF);\n\tvector<int> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = index_of(A, a[i]);\n\t\tA[id[i]] = a[i];\n\t}\n\tint m = *max_element(id.begin(), id.end());\n\tvector<int> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;//最長部分列のどれか1つ\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nll MergeCount(vector<int> &a) {\n\t//反転数を数える\n\tll count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += MergeCount(b);\n\t\tcount += MergeCount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool  WarshallFloyd(vector<vector<ll>> &c) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tint V = c.size();\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> Dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool BellmanFord(int start, int V, int E, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:V 頂点数\n\t//第三引数:E 辺の数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tresize(d, V);\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\t/*\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (t[V - 1]) {\n\t\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nbool TopologicalSort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> ArticulationNode(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//与えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nvector<vector<edge>> to_roottree(const vector<vector<edge>> &g, int r) {\n\t//根付き木へ変換する。\n\t//動作未確認。\n\tint n = g.size();\n\tvector<vector<edge>> G(n);\n\tvector<int> ord(n, -1);\n\n\tqueue<int> q;\n\n\tq.push(r);\n\tint k = 0;\n\n\twhile (q.size()) {\n\t\tint u = q.front(); q.pop();\n\n\t\tfor (auto &e : g[u]) {\n\t\t\tint v = e.to;\n\t\t\tif (ord[v] == -1) {\n\t\t\t\tord[v] = k; k++;\n\t\t\t\tq.push(v);\n\t\t\t\tG[u].emplace_back(e);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn G;\n}\nedge TreeDiameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<int> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<int> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tll d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\nvoid add_edge(vector<vector<edge>> &g, int a, int b, ll cost, ll cap) {\n\tg[a].emplace_back(a, b, cost, cap);\n\tg[b].emplace_back(b, a, cost, cap);\n}\npair<vector<int>, vector<edge>> bridge(const vector<vector<edge>>& g) {\n\t//グラフの橋となる辺を列挙する\n\t//戻り値のfirst:二重辺連結成分分解の番号となる\n\t//戻り値のsecond:橋となる辺を列挙したもの\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int> ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tvector<edge> brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1) {dfs(w, v);}\n\t\t\telse if (u != w && onS[w]) {\n\t\t\t\twhile (ord[roots[t - 1]] > ord[w]) { --t; }\n\t\t\t}\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v, 0);\n\t\t\twhile (1) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest_num\n\t//forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\nclass Dinic {\n\t//最大流を求める\nprivate:\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<ll>> cap, flow;\n\tvector<vector<int>> g;\n\tll inf;\npublic:\n\tDinic(const vector<vector<edge>> &graph) :\n\t\tn(graph.size()),\n\t\tcap(n, vector<ll>(n)),//\n\t\tflow(n, vector<ll>(n)),\n\t\tg(n, vector<int>()),\n\t\tinf(LONGINF) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.from, v = e.to;\n\t\t\t\tll c = e.capa;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline ll residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tll solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tll res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tll augment(int v, ll lim) {\n\t\tll res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst ll aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MinimumCostFlow {\nprivate:\n\n\tusing Flow = ll;\n\tusing Cost = ll;\n\tstruct Edge {\n\t\tint d;\n\t\tFlow c, f;\n\t\tCost w;\n\t\tint r, is_r;\n\t\tEdge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n\t\t\t: d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\npublic:\n\n\tMinimumCostFlow(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n\n\tvoid add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n\t\tint rsrc = g[dst].size();\n\t\tint rdst = g[src].size();\n\t\tg[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n\t\tg[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n\t}\n\n\tCost solve(int s, int t, Flow f) {\n\t\tCost res = 0;\n\n\t\tvector<Cost> h(n + 10), dist(n);\n\t\tvector<int> prevv(n + 10), preve(n + 10);\n\n\t\tusing pcv = pair<Cost, int>;\n\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LONGINF);\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(0, s);\n\t\t\twhile (q.size()) {\n\t\t\t\tCost cd;\n\t\t\t\tint v;\n\t\t\t\ttie(cd, v) = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif (dist[v] < cd) continue;\n\t\t\t\tfor (int i = 0; i < (int)(g[v].size()); ++i) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif (residue(e) == 0) continue;\n\t\t\t\t\tif (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n\t\t\t\t\t\tdist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n\t\t\t\t\t\tprevv[e.d] = v;\n\t\t\t\t\t\tpreve[e.d] = i;\n\t\t\t\t\t\tq.emplace(dist[e.d], e.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[t] == LONGINF) return -1;  // 経路が見つからなかった\n\n\t\t\t// s-t 間を最短路に沿って目一杯流す\n\t\t\tfor (int i = 0; i < n; ++i) h[i] += dist[i];\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(d, residue(g[prevv[v]][preve[v]]));\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.f += d;\n\t\t\t\tg[v][e.r].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tFlow residue(const Edge &e) { return e.c - e.f; }\n\n\t// 流量を表示\n\tvoid show() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < (int)(g[i].size()); ++j) {\n\t\t\t\tEdge &e = g[i][j];\n\t\t\t\tif (e.is_r) continue;\n\t\t\t\tcout << i << \"->\" << e.d << \"(flow:\" << e.f << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\nclass BipartiteMatching {\nprivate:\n\tint V;\n\tvector<int> match;\n\tvector<bool> used;\n\tvector<vector<int>> g;\n\tvector<pair<int, int>> match_pair;\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch_pair.emplace_back(make_pair(u, v));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\npublic:\n\tBipartiteMatching(int n) {\n\t\tV = n;\n\t\tresize(match, n);\n\t\tresize(used, n);\n\t\tresize(g, n);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tint MatchingSolve() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<pair<int, int>> get_pair() {\n\t\tfor (auto x : match_pair) {\n\t\t\tcout << x.first << \"  \" << x.second << endl;\n\t\t}\n\t\treturn match_pair;\n\t}\n\n};\nclass Lca {\nprivate:\n\tint n;\n\tint log2_n;\n\tvector<vector<int>> parent;\n\tvector<int> depth;\n\n\tvoid dfs(const vector<vector<edge>> &g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (e.to != p) { dfs(g, e.to, v, d + 1); }\n\t\t}\n\t}\n\npublic:\n\n\tLca(const vector<vector<edge>> &g, int root) {\n\t\tn = g.size();\n\t\tlog2_n = (int)log2(n) + 1;\n\t\tresize(parent, log2_n, n);\n\t\tresize(depth, n);\n\n\t\tdfs(g, root, -1, 0);\n\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint get_lca(int u, int v) {\n\t\tif (depth[u] > depth[v]) { swap(u, v); }//u≦v\n\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) { return u; }\n\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\n\tint get_depth(int v) {\n\t\treturn depth[v];\n\t}\n};\n\n\n\nint main() {\n\tint n, m; cin >> n >> m;\n\n\tvector<vector<edge>> g(n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tadd_edge(g, a, b, 0, 0);\n\t}\n\n\tauto x = bridge(g).second;\n\n\tvector<pair<int, int>> p;\n\n\tfor (auto y : x) {\n\t\tif (y.to > y.from) { swap(y.to, y.from); }\n\t\tp.emplace_back(y.to, y.from);\n\t}\n\n\tSORT(p);\n\n\tfor (auto c : p) {\n\t\tcout << c.first << \" \" << c.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int,int>;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n\nusing EdgeList = vector<vector<int>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nvector<pii> calc_bridge(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    vector<pii> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(int nxt : E[now]) {\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.emplace_back(min(now, nxt), max(now, nxt));\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            } \n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n#define all(v) v.begin(),v.end()\n\nclass Solver {\n  public:\n    bool solve() {\n        int N, M; cin >> N >> M;\n        EdgeList E(N);\n        rep(i, M) {\n            int a, b; cin >> a >> b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n        auto ans = calc_bridge(E);\n        sort(all(ans));\n        for(pii p : ans) cout << p.first << \" \" << p.second << endl;\n        \n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\nstruct bridge{\n\tvector<int>ord,low;\n\tvector<bool>art;\n\tvector<pair<int,int> >bridges;\n\tvector<vector<int> >G;\n\tbridge(int n_=0):ord(n_,-1),low(n_),art(n_,false),G(n_){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool operator[](int a){return art[a];}\n\tvoid dfs(int u,int p,int&cnt)\n\t{\n\t\tlow[u]=ord[u]=cnt++;\n\t\tfor(int&v:G[u])\n\t\t{\n\t\t\tif(ord[v]==-1)\n\t\t\t{\n\t\t\t\tdfs(v,u,cnt);\n\t\t\t\tlow[u]=min(low[u],low[v]);\n\t\t\t\tart[u]=art[u]|ord[u]<=low[v];\n\t\t\t\tif(ord[u]<low[v])bridges.push_back(make_pair(u,v));\n\t\t\t}\n\t\t\telse if(v!=p)\n\t\t\t{\n\t\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tint k=1,cnt=0;\n\t\tlow[0]=ord[0]=0;\n\t\tfor(int&v:G[0])if(ord[v]==-1)\n\t\t{\n\t\t\tdfs(v,0,k);\n\t\t\tif(ord[0]<low[v])bridges.push_back(make_pair(0,v));\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>=2)art[0]=true;\n\t}\n};\n\nmain()\n{\n\tint n,m;cin>>n>>m;\n\tbridge P(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\tP.add_edge(a,b);\n\t}\n\tP.build();\n\tsort(P.bridges.begin(),P.bridges.end());\n\tfor(int i=0;i<P.bridges.size();i++)cout<<P.bridges[i].first<<\" \"<<P.bridges[i].second<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\nstruct graphLink {\n    vector<bool> isthrough;\n    vector<int> ord, low, parent;\n    Graph G;\n    int cnt, v;\n\n    // init\n    graphLink(int _n) : isthrough(_n, false), ord(_n, 0), low(_n, 0), parent(_n, 0), G(_n), cnt(0), v(_n) {}\n\n    // example: dfs(0, -1);\n    void dfs(int cur, int prev) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n        isthrough[cur] = true;\n\n        for(auto x : G[cur]) {\n            if(!isthrough[x.to]) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else if(x.to != prev) {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n        }\n    }\n    set<int> artPoints() {\n        set<int> se;\n        int num = 0;\n        rep(i,0,v) {\n            // printf(\"%lld: %lld %lld\\n\", i, ord[parent[i]], low[i]);\n            if(parent[i] == 0) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num > 2) se.insert(0);\n        return se;\n    }\n\n    set<pii> bridges(vector<pii> vp) {\n        set<pii> se;\n        rep(i,0,vp.size()) {\n            if(ord[vp[i].fr] < low[vp[i].sc]) se.insert(vp[i]);\n        }\n        return se;\n    }\n};\n\nsigned main() {\n    int v, e; cin >> v >> e;\n    graphLink gr(v);\n    vector<pii> vp;\n\n    int s, t;\n    rep(i,0,e) {\n        cin >> s >> t;\n        gr.G[s].pb(Edge(t,1));\n        gr.G[t].pb(Edge(s,1));\n        vp.pb(pii(s, t));\n    }\n    gr.dfs(0, -1);\n\n    // set<int> ret = gr.artPoints();\n    set<pii> ret2 = gr.bridges(vp);\n    // for(auto x : ret) cout << x << endl;\n    for(auto x : ret2) printf(\"%lld %lld\\n\", x.fr, x.sc);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint V, E;\nvector<int> G[100005];\nvector<P> bridge;\nint pre[100005], low[100005];\n\nint id = 1;\nint bridge_dfs(int v, int prev)\n{\n\tpre[v] = id++;\n\tint ret = pre[v];\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tif(pre[G[v][i]]) ret = min(ret, pre[G[v][i]]);\n\t\telse ret = min(ret, bridge_dfs(G[v][i], v));\n\t}\n\treturn low[v] = ret;\n}\nvoid findBridge()\n{\n\tbridge_dfs(1, -1);\n\tfor(int i = 1; i <= V; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(pre[i] < pre[G[i][j]] && low[G[i][j]] > pre[i]) bridge.push_back(make_pair(i, G[i][j]));\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> V >> E;\n\tint u, v;\n\tfor(int i = 1; i <= E; i++){\n\t\tcin >> u >> v;\n\t\tu++, v++;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tfindBridge();\n\t\n\tfor(int i = 0; i < bridge.size(); i++){\n\t\tif(bridge[i].first > bridge[i].second) swap(bridge[i].first, bridge[i].second);\n\t}\n\tsort(bridge.begin(), bridge.end());\n\t\n\tfor(int i = 0; i < bridge.size(); i++){\n\t\tcout << bridge[i].first-1 << \" \" << bridge[i].second-1 << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n \nusing namespace std;\n \ntypedef pair<int, int> P;\n \nvector<int> G[1000000];\nvector<P> bridge;\nvector<int> articulation;\nint ord[1000000], low[1000000];\nbool vis[1000000];\n \nvoid dfs(int v, int p, int &k)\n{\n\tvis[v] = true;\n\t\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\t\n\tbool isArticulation = false;\n\tint ct = 0;\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]){\n\t\t\tct++;\n\t\t\tdfs(G[v][i], v, k);\n\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\tif (~p && ord[v] <= low[G[v][i]]) isArticulation = true;\n\t\t\tif (ord[v] < low[G[v][i]]) bridge.push_back(make_pair(min(v, G[v][i]), max(v, G[v][i])));\n\t\t}\n\t\telse if (G[v][i] != p){\n\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t}\n\t}\n\t\n\tif (p == -1 && ct > 1) isArticulation = true;\n\tif (isArticulation) articulation.push_back(v);\n}\n \nint main(){\n\t\n\tint V, E;\n\tcin >> V >> E;\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint v1, v2;\n\t\tcin >> v1 >> v2;\n\t\tG[v1].push_back(v2);\n\t\tG[v2].push_back(v1);\n\t}\n\t\n\tint k = 0;\n\tfor (int i = 0; i < V; i++){\n\t\tif (!vis[i]) dfs(i, -1, k);\n\t}\n\t\n\tsort(bridge.begin(), bridge.end());\n\tsort(articulation.begin(), articulation.end());\n\t/*\n\tfor (int i = 0; i < articulation.size(); i++){\n\t\tcout << articulation[i] << endl;\n\t}\n\t\n\t//cout << endl;\n\t*/\n\tfor (int i = 0; i < bridge.size(); i++){\n\t\tcout << bridge[i].first << \" \" << bridge[i].second << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n    int s;\n    int t;\n    bool operator < (const Edge& tgt) const {\n\tif( s == tgt.s )\n\t    return t < tgt.t;\n\treturn s < tgt.s;\n    }\n};\n\n\n\nint Bridges_dfs(const vector<vector<Edge>>& g, vector<int>& order,\n\t\tvector<Edge>& ans, int u, int& cnt_v, Edge pre) {\n\n    if( order[u] != -1 ) { //?¨????????????¨?????????\n\treturn order[u];\n    }\n    // ??????????¨???????\n    order[u] = cnt_v; cnt_v++;\n    // ??£??\\???????????????\n    int min_v = order[u];\n    for(auto& e : g[u]) {\n\tif( e.t == pre.s and e.s == pre.t ) continue;\n\tmin_v = min(Bridges_dfs(g, order, ans, e.t, cnt_v, e), min_v);\n    }\n    if( min_v == order[u] and pre.s != -1 ) {\n\tans.push_back(pre);\n    }\n}\n\nvector<Edge> Bridges(const vector<vector<Edge>>& g) {\n    vector<Edge> ans;\n    const int V = g.size();\n    vector<int> order(V,-1);\n    \n    // 0??????DFS\n    int cnt_v = 0;\n    Edge tmp{-1,-1};\n    Bridges_dfs(g, order, ans, 0, cnt_v, tmp);\n    assert(cnt_v == V); // ??£???????????°?????????????????????\n    return ans;\n}\n\nint main () {\n    int V,E;\n    cin >> V >> E;\n    vector<vector<Edge>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t; \n\tg[s].push_back(Edge{s,t});\n\tg[t].push_back(Edge{t,s});\n    }\n    vector<Edge> ans = Bridges(g);\n    sort(ans.begin(), ans.end());\n    for(auto& e : ans) {\n\tcout << e.s << \" \"<< e.t << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// 関節点、橋、lowlink\n// lowlink\ntypedef pair<int,int> mypair;\nvoid dfs(int v,int p,int &k,vector<int> &ord,vector<int> &low,vector<bool> &used,vector<vector<int> > &g,vector<mypair> &bridge,vector<int> &articulation){\n\tused[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\tbool isarticulation = false;\n\tint cnt = 0;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tif(!used[g[v][i]]){\n\t\t\tcnt++;\n\t\t\tdfs(g[v][i],v,k,ord,low,used,g,bridge,articulation);\n\t\t\tlow[v] = min(low[v],low[g[v][i]]);\n\t\t\tif(~p&&ord[v]<=low[g[v][i]])isarticulation = true;\n\t\t\tif(ord[v]<low[g[v][i]])bridge.push_back( mypair( min(v,g[v][i]), max(v,g[v][i]) ) ) ;\n\t\t}\n\t\telse if(g[v][i] != p){\n\t\t\tlow[v] = min(low[v],ord[g[v][i]]);\n\t\t}\n\t}\n\tif(p==-1 &&cnt>1)isarticulation=true;\n\tif(isarticulation)articulation.push_back(v);\n}\n\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> >g(v);\n\tvector<int> ord(v),low(v);\n\tvector<int> art;\n\tvector<mypair> bridge;\n\tvector<bool> used(v,false);\n\tint k=0;\n\n\tfor(int i=0;i<e;i++){\n\tint s,t;\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\tg[t].push_back(s);\n\t}\n\n\tfor(int i=0;i<v;i++)if(!used[i])dfs(i,-1,k,ord,low,used,g,bridge,art);\n\tsort(art.begin(),art.end());\n\tsort(bridge.begin(),bridge.end());\n\t//関節点\n\t//cout<<art.size()<<endl;\n\t//for(int i=0;i<art.size();i++)cout<<art[i]<<endl;\t\n\t//橋\n\t//cout<<bridge.size()<<endl;\n\tfor(int i=0;i<bridge.size();i++)cout<<bridge[i].first<<' '<<bridge[i].second<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> v[100000];\nvector<pair<int,int> > ans;\nint S[100000],D[100000];\n\nvoid dfs(int p,int d,int pr){\n  D[p]=d;\n  for(int i=0;i<v[p].size();i++){\n    int np=v[p][i];\n    if(pr==np)continue;\n    if(!D[np]){\n      dfs(np,d+1,p);\n      if(!S[np])ans.push_back(make_pair(min(p,np),max(p,np)));\n      S[p]+=S[np];\n    }\n    else if(D[p]>D[np])S[np]--,S[p]++;\n  }\n}\n\nint main(){\n  int V,E;\n  cin>>V>>E;\n  for(int s,t,i=0;i<E;i++)\n    cin>>s>>t,v[s].push_back(t),v[t].push_back(s);\n  dfs(0,1,-1);\n  sort(ans.begin(),ans.end());\n  for(int i=0;i<ans.size();i++)cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\n\nconst int mx = 100005;\n\nint dtime = 0;\nint n, m, par[mx], low[mx], start[mx];\nvector<int> adj[mx];\nbool vis[mx];\nvector<pair<int, int>> bdg;\n\nvoid dfs(int n, int p = -1) {\n  vis[n] = true;\n  par[n] = p;\n  start[n] = dtime++;\n  low[n] = start[n];\n  \n  for (int h : adj[n]) {\n    if (!vis[h]) {\n      dfs(h, n);\n      low[n] = min(low[h], low[n]);\n      if (low[h] > low[n]) {\n\tbdg.push_back({n, h});\n      }\n    } else {\n      low[n] = min(low[n], start[h]);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int u, v; cin >> u >> v;\n    adj[u].pb(v); adj[v].pb(u);\n  }\n  dfs(0);\n  sort(bdg.begin(), bdg.end());\n  for (auto p : bdg) cout << p.first << \" \" << p.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nvector<bool> visited;\nvector<int> depth, lowlink, pars;\n\nvoid dfs(vector<vector<int>> &G, int p, int u, int d){\n    visited[u] = true;\n    pars[u] = p;\n    depth[u] = lowlink[u] = d;\n    \n    for(auto v: G[u]) if(v != p){\n        if(!visited[v]){\n            dfs(G, u, v, d+1);\n            lowlink[u] = min(lowlink[u], lowlink[v]);\n        }else{\n            lowlink[u] = min(lowlink[u], depth[v]);\n        }\n    }\n}\n\nint main(){\n    cin >> V >> E;\n    \n    vector<vector<int>> G(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    \n    depth.assign(V, -1), lowlink.assign(V, -1);\n    visited.assign(V, false);\n    pars.assign(V, -1);\n    dfs(G, -1, 0, 0);\n    \n    vector<pair<int, int>> ans;\n    vector<vector<int>> tree(V);\n    for(int i=0; i<V; i++){\n        int p = pars[i];\n        if(p != -1 && depth[p]<lowlink[i]){\n            if(p < i)\n                ans.emplace_back(p, i);\n            else\n                ans.emplace_back(i, p);\n        }\n    }\n    sort(ans.begin(), ans.end());\n    \n    for(auto p: ans)\n        cout << p.first << \" \" << p.second << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=1000005;\nconst int MAXE=1000005;\ntypedef pair<int,int> ii;\nvector <int> adj[MAXN];\nii ec[MAXE];\nint prof[MAXN],low[MAXN],padre[MAXN],cont,N,M,a,b,nec;\nbool usa[MAXN];\nvoid bridge(int v){\n    int child=0; //contara el n??mero de hijos en el DFST (DFS Tree)\n    usa[v]=true;\n    //low nos dice el ancestro m??s alto al que apunta alguno de los descendientes de v en DFST\n    //prof nos dice en que tiempo se visitaron los nodos en el DFS\n    low[v]=prof[v]=++cont;\n    for (int i=0; i<(int)adj[v].size(); i++){\n        int w=adj[v][i];\n        if (!usa[w]){\n            child++;\n            padre[w]=v;\n            bridge(w);\n            low[v]=min(low[v],low[w]);\n            //(v,w) ser?? una arista de corte si:\n            //no podemos alcanzar a ninguno de los ancestros\n            //de v o a v desde el ??rbol enraizado en w\n            if (low[w]>prof[v])ec[nec++]=make_pair(min(v,w),max(v,w));\n        } else if(w!=padre[v]) low[v]=min(low[v],prof[w]);\n    }\n}\nint main()\n{\n    //Asumimos que el grafo es conexo, no dirigido y simple\n    //En caso de no ser conexo lo hacemos para cada componente conexa\n    scanf(\"%d%d\",&N,&M);\n    for (int i=0; i<M; i++){\n        scanf(\"%d%d\",&a,&b);\n        adj[a].push_back(b); adj[b].push_back(a);\n    }\n    //Inicializamos los padres\n    fill(padre,padre+N,-1);\n    //En caso de ser multicaso inicializar prof,low,usa,ec,nec\n    bridge(0);\n    //ordenamos los puentes para mostrarlas en orden\n    sort(ec,ec+nec);\n    //en ec tenemos los puentes\n    for (int i=0; i<nec; i++)printf(\"%d %d\\n\",ec[i].first,ec[i].second);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \nstruct Edge {\n\tint src;\n\tint dst;\n\tint id;\n};\n\n// res: bridges\n// v: current node\n// from: parent node\nint dfs2(vector<vector<Edge>>&g, vector<int>& res, int v, int& count, int from_id, vector<int>& low, vector<int>& pre) {\n\tpre[v] = count++;\n\tlow[v] = pre[v];\n\tfor (auto it = g[v].begin(); it != g[v].end(); it++) {\n\t\tint to = it->dst;\n\t\tif (pre[to] == -1) {\n\t\t\t// destination has not been visited\n\t\t\t// visit destination and update low[v]\n\t\t\tlow[v] = min(low[v], dfs2(g, res, to, count, it->id, low, pre));\n\t\t\tif (low[to] == pre[to]) {\n\t\t\t\t// edge is not contained in a closed path -> bridge\n\t\t\t\t//res.push_back(it->id);\n\t\t\t\tres[it->id] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (from_id == it->id) {\n\t\t\t\t// ignore a path to parent\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlow[v] = min(low[v], low[to]);\n\t\t}\n\t}\n\treturn low[v];\n}\n\n// Calculate bridges in a undirected graph.\n// Assume graph is connected and has no parallel edges or self-loops.\n// g: adjacency list\n// V: number of nodes\nvoid  bridges(vector<vector<Edge>>&g, int V, vector<int>&res) {\n\n\tif (V > 0) {\n\t\t// assume at least the first vertex exists\n\t\tvector<int> low(V, -1);  // lowest reacheable index\n\t\tvector<int> pre(V, -1);  // pre-order index\n\t\tint count = 0;  // pre-order index counter\n\t\tdfs2(g, res, 0, count, -1, low, pre);  // start dfs from vertex 0\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<Edge>>es(V);\n\tvector<Edge>eids;\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tes[s].push_back(Edge{ s,t,i });\n\t\tes[t].push_back(Edge{ t,s,i });\n\t\teids.push_back(Edge{ s,t,i });\n\t}\n\tvector<int>res(V);\n\tbridges(es, V, res);\n\tvector<Edge>bris;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (res[i])bris.push_back(eids[i]);\n\t}\n\tsort(bris.begin(), bris.end(), [=](const Edge&l, const Edge&r) {\n\t\treturn l.src == r.src ? l.dst < r.dst : l.src < r.src;\n\t});\n\tfor (int i = 0; i < bris.size(); ++i) {\n\t\tcout << bris[i].src << \" \" << bris[i].dst << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct LowLink\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< int > used, ord, low, parent;\n\n  LowLink(size_t v) : g(v), used(v, 0), ord(v), low(v), uf(v), parent(v, -1) {}\n\n  virtual void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        parent[to] = idx;\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  void dfs()\n  {\n    int k = 0;\n    dfs(0, k);\n  }\n};\n\nstruct ArticulationPoints : LowLink\n{\n  ArticulationPoints(size_t v) : LowLink(v) {}\n\n  vector< int > build()\n  {\n    LowLink::dfs();\n    vector< int > vs;\n    int sum = 0;\n    for(int i = g.size() - 1; i >= 1; i--) {\n      if(parent[i] == 0) ++sum;\n      else if(ord[parent[i]] <= low[i]) vs.push_back(parent[i]);\n    }\n    if(sum > 1)vs.push_back(0);\n    sort(begin(vs), end(vs));\n    vs.erase(unique(begin(vs), end(vs)), end(vs));\n    return (vs);\n  }\n};\n\nstruct BiConnectedComponents : LowLink\n{\n  vector< pair< int, int > > edges;\n  vector< int > comp;\n\n  BiConnectedComponents(size_t v) : LowLink(v), comp(v) {}\n\n  void add_edge(int x, int y)\n  {\n    LowLink::add_edge(x, y);\n    edges.push_back(minmax(x, y));\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  vector< pair< int, int > > build(vector< vector< int > > &t)\n  {\n    LowLink::dfs();\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    vector< pair< int, int > > vs;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      vs.emplace_back(e.first, e.second);\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n    return (vs);\n  }\n};\n\n\nvoid solve()\n{\n  int V, E;\n  cin >> V >> E;\n  BiConnectedComponents graph(V);\n  vector< vector< int > > malta;\n  for(int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph.add_edge(s, t);\n  }\n  for(auto &p : graph.build(malta)) {\n    cout << p.first << \" \" << p.second << endl;\n  }\n\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct node {int to,cost; };\n\ntypedef vector< vector<node> > G;\n\ninline void add_edge(G& g,int from,int to,int cost=1){\n\tnode in; in.to=to; in.cost=cost;\n\tg[from].pb(in);\n}\n\ninline void add_both_edge(G& g,int from,int to,int cost=1){\t\n\tadd_edge(g,from,to,cost);\n\tadd_edge(g,to,from,cost);\n}\n\nvoid dfs(const G& g,int cur,int prev,int &k,vi& order, vi& low,vi& parent) {\n\torder[cur]=k++;\n\tlow[cur]=order[cur];\n\n\trep(i,g[cur].size()){\n\t\tint to=g[cur][i].to;\n\t\tif(order[to]==-1){\n\t\t\tparent[to]=cur;\n\t\t\tdfs(g,to,cur,k,order,low,parent);\n\t\t\tlow[cur]=min(low[cur],low[to]);\n\t\t}else if(to!=prev)\n\t\t\tlow[cur]=min(low[cur],order[to]);\n\t}\n\treturn;\n}\n\nvoid Lowlink(const G& g, vi& order,vi& low,vi& parent) {\n\tint v=g.size();\n\torder.assign(v,-1);\n\tlow.resize(v);\n\tparent.resize(v);\n\tint k=0;\n\tparent[0]=-1;\n\tdfs(g,0,-1,k,order,low,parent);\n\treturn ;\n}\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\tG graph(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_both_edge(graph,a,b);\n\t}\n\tvi order,low,parent;\n\tLowlink(graph,order,low,parent);\n\n\t/*rep(i,n){\n\t\tif(i){\n\t\t\tbool ok=false;\n\t\t\trep(j,graph[i].size()){\n\t\t\t\tint to=graph[i][j].to;\n\t\t\t\tif(i==parent[to]&&order[i]<=low[to])\n\t\t\t\t\tok=true;\n\t\t\t}\n\t\t\tif(ok) cout << i << endl;\n\t\t}else{\n\t\t\tint d=0;\n\t\t\trep(j,n) if(parent[j]==0) d++;\n\t\t\tif(d>=2) cout << i << endl;\n\t\t}\n\t}*/\n\t\n\trep(i,n){\n\t\tint f=i;\n\t\trep(j,graph[i].size()){\n\t\t\tint t=graph[i][j].to;\n\t\t\tif(t<=f) \n\t\t\t\tcontinue;\n\t\t\tif(order[f] < low[t])\n\t\t\t\tcout << f << \" \"<< t << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B&lang=jp\n// hos?????????????????????????????????\n// lowlink????¨??????????????????§??????\n// lowlink????¨??????????????????§????????????????????¢?????¨?????????????????????????????§\n// http://kagamiz.hatenablog.com/entry/2013/10/05/005213??????????????????\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nvector<int> G[100000];\nvector<P> bridge;\nvector<int> articulation;\nint ord[100000], low[100000];\nbool vis[100000];\nint v, e, s, t, k;\nvoid dfs(int v, int p, int &k) {\n    vis[v] = true;\n    ord[v] = k++; low[v] = ord[v];\n    bool isArticulation = false;\n    int ct = 0;\n    for (int i=0; i<G[v].size(); i++) {\n        if (!vis[G[v][i]]) {\n            ct++;\n            dfs(G[v][i], v, k);\n            low[v] = min(low[v], low[G[v][i]]);\n            if (~p && ord[v] <= low[G[v][i]]) isArticulation = true;\n            if (ord[v] < low[G[v][i]]) bridge.push_back(P(min(v, G[v][i]), max(v, G[v][i])));\n        } else if (G[v][i] != p) {\n            low[v] = min(low[v], ord[G[v][i]]);\n        }\n    }\n    if (p == -1 && ct > 1) isArticulation = true;\n    if (isArticulation) articulation.push_back(v);\n}\nint main() {\n    scanf(\"%d%d\",&v,&e);\n    for (int i=0; i<e; i++) {\n        scanf(\"%d%d\",&s,&t);\n        G[s].push_back(t); G[t].push_back(s);\n    }\n    if (v == 1) {\n    } else {\n        k = 0;\n        for (int i=0; i<v; i++) {\n            if (!vis[i]) dfs(i, -1, k);\n        }\n        sort(bridge.begin(), bridge.end());\n        for (int i=0; i<bridge.size(); i++) printf(\"%d %d\\n\",bridge[i].first, bridge[i].second);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Edge{\n    int from,to;\n};\nusing Graph=vector<vector<Edge>>;\nnamespace ProconLib{\n    \n    //no multiple Edges\n    //undirected edges graph\n    template<typename edge_t,typename graph_t>\n    vector<edge_t> bridgeDetection(graph_t &g){\n        int n=g.size();\n        vector<int> pre(n,-1),low(n,-1);\n        int k=0;\n        vector<edge_t> res;\n        function<int(int,int)> dfs=[&](int v,int pv){\n            pre[v]=k++;\n            low[v]=pre[v];\n            for(auto &e:g[v]){\n                int to=e.to;\n                if(to==pv) continue;\n                if(pre[to]==-1){\n                    low[v]=min(low[v],dfs(to,v));\n                    if(low[to]==pre[to]){\n                        res.push_back(e);\n                    }\n                }\n                else{\n                    low[v]=min(low[v],low[to]);\n                }\n            }\n            return low[v];\n        };\n        for(int i=0;i<n;i++){\n            if(pre[i]!=-1){\n                dfs(i,-1);\n            }\n        }\n        return res;\n    }\n}\n\n//verify\nusing namespace ProconLib;\nusing Graph=vector<vector<Edge>>;\nint main(){\n    int v,e;\n    cin>>v>>e;\n    Graph g(v);\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(Edge{s,t});\n        g[t].push_back(Edge{t,s});\n    }\n    vector<Edge> res=bridgeDetection<Edge>(g);\n    for(auto &e:res){\n        cout<<min(e.from,e.to)<<\" \"<<max(e.from,e.to)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 参考:http://kagamiz.hatenablog.com/entry/2013/10/05/005213\n\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[1000000];\nvector<pair<int, int> > bridge;\nint ord[1000000], low[1000000];\nbool vis[1000000];\n\nvoid dfs(int v, int p, int &k){\n\tvis[v] = true;\n\tord[v] = k++;\n\tlow[v] = ord[v];\n\tint ct = 0;\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]){\n\t\t\tct++;\n\t\t\tdfs(G[v][i], v, k);\n\t\t\tlow[v] = min(low[v], low[G[v][i]]);\n\t\t\tif (ord[v] < low[G[v][i]]) bridge.push_back(make_pair(min(v, G[v][i]), max(v, G[v][i])));\n\t\t}\n\t\telse if (G[v][i] != p){\n\t\t\tlow[v] = min(low[v], ord[G[v][i]]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 0;i < m;++i){\n\t\tint v, e;\n\t\tscanf(\"%d %d\",&v,&e);\n\t\tG[v].push_back(e);\n\t\tG[e].push_back(v);\n\t}\n\tint k = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]) dfs(i, -1, k);\n\t}\n\t\n\tsort(bridge.begin(), bridge.end());\n\tfor (int i = 0; i < bridge.size(); i++)\n\t\tprintf(\"%d %d\\n\", bridge[i].first, bridge[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define FORs(i,st) for(auto i : st)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\n\n// 橋 (= 取り除くと連結成分が増える辺) 列挙\n// グラフを適当な頂点を根とする dfs 木として以下の値を更新する\n// order[v] := 行きがけ順, low[v] := 部分グラフでの min{order[i]}\n// 各辺 e について, 子から order[親]以下に遷移できない <=> e は橋\n// 各辺 e について, low[子] > order[親] <=> e は橋\n// が, low[v] は陽に持たないで良い\n// verified: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3382012\nclass LowLink\n{\n    using Graph = std::vector<std::vector<ll>>;\n    std::vector<ll> order;\n    ll next = 0;\n    Graph G;\n    std::set<P> bridges;\n\n    void add(ll a, ll b)\n    {\n        bridges.insert(P(std::min(a, b), std::max(a, b)));\n    }\n    ll dfs(ll cur, ll pre)\n    {\n        ll res = order[cur] = next++;\n        for (const auto &to : G[cur])\n        {\n            if (to == pre)\n                continue;\n            if (order[to] >= 0)\n                res = std::min(res, order[to]);\n            else\n            {\n                ll low = dfs(to, cur);\n                if (low > order[cur])\n                    add(cur, to);\n                res = std::min(res, low);\n            }\n        }\n        return res;\n    }\n\n  public:\n    LowLink(ll _v) : order(_v, -1), G(_v, std::vector<ll>())  {}\n    void addEdge(ll s, ll t)\n    {\n        G[s].push_back(t);\n    }\n    std::set<P> bridge()\n    {\n        dfs(0, -1);\n        return bridges;\n    }\n};\n\n/*\n二重辺連結成分分解\n- 二重辺連結 := どの辺を取り除いても連結である, すなわち橋を含まないようなグラフ\n- 二重辺連結成分 := グラフの内二重辺連結な部分グラフであり, 極大 (= どの頂点集合を追加しても二重辺連結にならない)なもの\n橋が列挙できたら適当に dfs すれば ok\n*/\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int v,e;\n    cin>>v>>e;\n    LowLink link(v);\n    FOR(i,0,e){\n      ll in1,in2;\n      cin>>in1>>in2;\n      link.addEdge(in1,in2);\n      link.addEdge(in2,in1);\n    }\n    set<P> res = link.bridge();\n    FORs(i,res){\n      cout<<i.first<<\" \"<<i.second<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#define pii pair<int,int>\n#define S second\n#define F first\n\nusing namespace std;\nconst int MAX_N = 1e5+10;\nconst int INF = 1e9+10;\nint from[MAX_N],to[MAX_N],dp[MAX_N],depth[MAX_N];\nvector <int> vec[MAX_N];\nbool mark[MAX_N];\nifstream in(\"in1.txt\");\nofstream out(\"out1.txt\");\nvoid dfs(int v,int cnt,int l){\n    mark[v]=true;\n    depth[v]=cnt;\n    for(int en:vec[v]){\n        if(en==l)\n            continue;\n        int u=to[en]^from[en]^v;\n        if(mark[u])\n            dp[v]=min(dp[v],depth[u]);\n        else{\n            dfs(u,cnt+1,en);\n            dp[v]=min(dp[v],dp[u]);\n        }\n    }\n    if(dp[v]>=depth[v]&&l!=-1)\n        out<<from[l]<<\" \"<<to[l]<<'\\n';\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    in>>n>>m;\n    if(n==1)\n        return 0;\n    //fill(dp,dp+max(n,m),INF);\n    for(int i=0;i<m;i++){\n        if(i>=m){\n            dp[i]=INF;\n            continue;\n        }\n        dp[i]=INF;\n        in>>from[i]>>to[i];\n        vec[from[i]].push_back(i);\n        vec[to[i]].push_back(i);\n    }\n    dfs(0,0,-1);\n}"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.Primitive\nimport           Control.Monad.ST\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport           Data.List\nimport           Data.Primitive.MutVar\nimport           Data.Tuple\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\n\nmain :: IO ()\nmain = do\n    [v, e] <- map read.words <$> getLine\n    edges <- U.unfoldrN e (readInt2.B.dropWhile isSpace) <$> B.getContents\n    putStr.unlines.map showEdge . solve . fromEdges v $ toUndirectedEdges edges\n\nsolve :: Graph -> [Edge]\nsolve gr = sort $ bridges gr\n\ntype Vertex = Int\ntype Edge = (Vertex, Vertex)\ntype Graph = V.Vector (U.Vector Vertex)\n\nshowEdge :: Edge -> String\nshowEdge (src, dst) = shows src \" \" ++ show dst\n\ntoUndirectedEdges :: U.Vector Edge -> U.Vector Edge\ntoUndirectedEdges edges = edges U.++ U.map swap edges\n\nfromEdges :: Int -> U.Vector Edge -> Graph\nfromEdges numV edges = V.map U.fromList\n    . V.unsafeAccumulate (flip (:)) (V.replicate numV [])\n    $ U.convert edges\n\nnothing :: Int\nnothing = -1\n\nbridges :: Graph -> [Edge]\nbridges gr = runST $ do\n    let numV = V.length gr\n    low <- UM.replicate numV nothing\n    num <- UM.replicate numV nothing\n    parent <- UM.replicate numV nothing\n    bridge <- newMutVar [] :: ST s (MutVar s [Edge])\n    numOfVisited <- newMutVar 0 :: ST s (MutVar s Int)\n\n    let root = 0\n\n    fix `flip` root `flip` nothing $ \\dfs !v !p -> do\n        !nv <- readMutVar numOfVisited\n        modifyMutVar' numOfVisited (+1)\n        UM.unsafeWrite num v nv\n        UM.unsafeWrite parent v p\n        UM.unsafeWrite low v nv\n\n        U.forM_ (V.unsafeIndex gr v) $ \\child -> do\n            isVisited <- (/= nothing) <$> UM.unsafeRead num child\n            if not isVisited\n            then do\n                dfs child v\n                lc <- UM.unsafeRead low child\n                unsafeModify low v (min lc)\n                when (nv < lc) $\n                    modifyMutVar' bridge ((min v child, max v child):)\n            else\n                when (child /= p) $ do\n                    nc <- UM.unsafeRead num child\n                    unsafeModify low v (min nc)\n\n    readMutVar bridge\n\n-------------------------------------------------------------------------------\n\nreadInt2 :: B.ByteString -> Maybe ((Int,Int), B.ByteString)\nreadInt2 bs = Just ((x,y),bsy)\n  where\n    Just (x, bsx) = B.readInt bs\n    Just (y, bsy) = B.readInt $ B.unsafeTail bsx\n\nunsafeModify :: (PrimMonad m, GM.MVector mv a)\n             => mv (PrimState m) a -> Int -> (a -> a) -> m ()\nunsafeModify v i f = GM.unsafeRead v i >>= GM.unsafeWrite v i . f\n{-# INLINE unsafeModify #-}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct node **list;\nint *seq, **art, counter;\n\nvoid Insert(int, int);\nint Biconnected(int, int);\nint main(void)\n{\n  int i, j, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (int**)malloc(sizeof(int*) * v);\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    art[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0, -1);\n  for (i = 0; i < v; i++) {\n    for (j = 0; j < v; j++) {\n      if (art[i][j]) printf(\"%d %d\\n\", i, j);\n    }\n    free(art[i]);\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point, int pre)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id, point);\n      if (m < min) min = m;\n      if (m > seq[point]) {\n        if (point < n->id) art[point][n->id] = 1;\n        else art[n->id][point] = 1;\n      }\n    } else if (n->id != pre) {\n      if (seq[n->id] < min) {\n        min = seq[n->id];\n      }\n    }\n  }\n  return min;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_3_B Bridges\n// 2018.5.7 bal4u\n// https://everysick.hatenablog.com/entry/2016/06/13/120033 を参考にした\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define MAX_V 100002\n#define MAX_E 100002\n\ntypedef struct { int s, t; } EDGE;\t\t// ブリッジ（橋）になる辺\nEDGE bridge[MAX_E]; int sz;\t\t\t\t// s < t となっている\n\nint  hi[MAX_V], *to[MAX_V];\nint  low[MAX_V], pre[MAX_V];\nint  cnt;\n\nint dfs(int cur, int from)\n{\n\tint i, e, t;\n\t\n\tlow[cur] = pre[cur] = ++cnt;\n\tfor (i = 0; i < hi[cur]; i++) {\n\t\te = to[cur][i];\n\n\t\tif (!pre[e]) {\n\t\t\tt = dfs(e, cur);\n\t\t\tif (t < low[cur]) low[cur] = t;\n\t\t\tif (pre[e] == low[e]) {\n\t\t\t\tif (cur < e) bridge[sz].s = cur, bridge[sz].t = e; // 出力に合わせる\n\t\t\t\telse         bridge[sz].s = e,   bridge[sz].t = cur;\n\t\t\t\tsz++;\n\t\t\t}\n\t\t} else if (from != e) {\n\t\t\tt = low[e];\n\t\t\tif (t < low[cur]) low[cur] = t;\n\t\t}\n\t}\n\treturn low[cur];\n} \n\nvoid check_bridge(int V)\n{\n\tint i;\n\tfor (i = 0; i < V; i++) {\n\t\tif (!pre[i]) dfs(i, i);\n\t}\n}\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n}\n\nint cmp(EDGE *a, EDGE *b) { if (a->s - b->s) return a->s - b->s; return a->t - b->t; }\n\nint main()\n{\n    int E, V, s, t, i, j;\n    int *memo;\n \n    V = in(), E = in();\n    memo = malloc(E<<3);\n    j = 0; for (i = 0; i < E; i++) {\n        memo[j++] = s = in(), memo[j++] = t = in();\n        hi[s]++, hi[t]++;\n     }\n    for (i = 0; i < V; i++) {\n        if (hi[i]) to[i] = malloc(hi[i]<<2);\n    }\n    memset(hi, 0, V<<2);\n \n    j = 0; while (E--) {\n        s = memo[j++], t = memo[j++];\n\t\tto[s][hi[s]++] = t, to[t][hi[t]++] = s;\n    }\n \n    check_bridge(V);\n \n\tqsort(bridge, sz, sizeof(EDGE), cmp);\n\n\tfor (i = 0; i < sz; i++) {\n\t\tout(bridge[i].s), pc(' '), out(bridge[i].t), pc('\\n');\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint **matrix, *seq, *art, counter;\n\nint Biconnected(int, int);\nint main(void)\n{\n  int i, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  matrix = (int**)malloc(sizeof(int*) * v);\n  seq = (int*)calloc(v, sizeof(int));\n  art = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) matrix[i] = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    matrix[s][t] = 1;\n    matrix[t][s] = 1;\n  }\n  Biconnected(0, v);\n  for (i = 0; i < v; i++) {\n    if (art[i]) printf(\"%d\\n\", i);\n    free(matrix[i]);\n  }\n  free(matrix);\n  free(seq);\n  free(art);\n}\nint Biconnected(int point, int v)\n{\n  int i, min;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(i = 0; i < v; i++) {\n    if (!matrix[point][i]) continue;\n    if (!seq[i]) {\n      int m;\n      m = Biconnected(i, v);\n      if (m < min) min = m;\n      if (seq[point] == 1) {\n        if (seq[i] != 2) {\n          art[point] = 1;\n        }\n      }else {\n        if (m >= seq[point]) {\n          art[point] = 1;\n        }\n      }\n    } else if (seq[i] < min) {\n      min = seq[i];\n    }\n  }\n  return min;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct pair {\n  int x;\n  int y;\n};\nstruct node **list;\nstruct pair *art;\nint *seq, counter,sp;\n\nvoid Insert(int, int);\nint Biconnected(int, int);\nvoid qsort1(int, int);\nint main(void)\n{\n  int i, j, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (struct pair*)malloc(sizeof(struct pair) * e);\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0, -1);\n  qsort1(0, sp - 1);\n  for (i = sp-1; i >= 0; i--) printf(\"%d %d\\n\", art[i].x, art[i].y);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point, int pre)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id, point);\n      if (m < min) min = m;\n      if (m > seq[point]) {\n        if (point < n->id) {\n          art[sp].x = point;\n          art[sp].y = n->id;\n        } else {\n          art[sp].x = n->id;\n          art[sp].y = point;\n        }\n        sp++;\n      }\n    } else if (n->id != pre) {\n      if (seq[n->id] < min) {\n        min = seq[n->id];\n      }\n    }\n  }\n  return min;\n}\nvoid qsort1(int left, int right) {\n  struct pair pivot = art[(left + right) / 2];\n  int i = left, j = right;\n  if (left >= right) return;\n  do{\n    while (1) {\n      if (art[i].x < pivot.x || (art[i].x == pivot.x && art[i].y < pivot.y)) break;\n      i++;\n    }\n    while (1) {\n      if (art[j].x > pivot.x || (art[j].x == pivot.x && art[j].y > pivot.y)) break;\n      j--;\n    }\n    if (i <= j) {\n      struct pair temp = art[i];\n      art[i] = art[j];\n      art[j] = temp;\n      i++;\n      j--;\n    }\n  }while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct node **list;\nint *seq, **art, counter;\n\nvoid Insert(int, int);\nint Biconnected(int, int);\nint main(void)\n{\n  int i, j, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (int**)malloc(sizeof(int*) * v);\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    art[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0, -1);\n  for (i = 0; i < v; i++) {\n    for (j = 0; j < v; j++) {\n      if (art[i][j]) printf(\"%d %d\\n\", i, j);\n    }\n    free(art[i]);\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point, int pre)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id, point);\n      if (m < min) min = m;\n      if (m > seq[point]) {\n        art[point][n->id] = 1;\n      }\n    } else if (n->id != pre) {\n      if (seq[n->id] < min) {\n        min = seq[n->id];\n      }\n    }\n  }\n  return min;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define INF 1010001000\n#define MAX_V 100000\n#define min(a, b) a<b?a:b\n\ntypedef struct vertex {\n    int edge_count;\n    struct edge *head;\n}vertex;\n\ntypedef struct edge {\n    int to;\n    struct edge *next;\n}edge;\n\nvoid add(int f, int t);\nvoid dfs(int st, int prev);\nvoid bridge(void);\n\nvertex graph[MAX_V]; \nint used[MAX_V], prenum[MAX_V], lowest[MAX_V], parent[MAX_V], ans[MAX_V];\nint from[MAX_V], dir[MAX_V];\nint e, v, j;\nint pre, ac;\n\nint main(void)\n{\n    int i;\n    scanf(\"%d%d\", &v, &e);\n    for (i = 0; i < e; i++) {\n        scanf(\"%d %d\", &from[i], &dir[i]);\n        add(from[i], dir[i]);\n        graph[from[i]].edge_count++;\n        add(dir[i], from[i]);\n        graph[dir[i]].edge_count++;\n    }\n    bridge();\n    return 0;\n}\n\nvoid bridge(void)\n{\n    int i;\n    for (i = 0; i < v; i++) {\n        lowest[i] = INF;\n        prenum[i] = INF;\n        used[i] = 0;\n    }\n\n    pre = 1;\n    dfs(0, -1);\n    for (i = 0; i < v; i++) {\n        if (prenum[from[i]] < lowest[dir[i]]) {\n            printf(\"%d %d\\n\", from[i], dir[i]);\n        }\n    }\n}\n\nvoid dfs(int st, int prev)\n{\n    int cnt = 0;\n    edge *tmp = graph[st].head;\n\n    prenum[st] = pre;\n    lowest[st] = pre++;\n    used[st] = 1;\n\n    while (tmp) {\n        if (!used[tmp->to]) {\n            cnt++;\n            parent[tmp->to] = st;\n            dfs(tmp->to, st);\n            lowest[st] = min(lowest[st], lowest[tmp->to]);\n        } else if (tmp->to != prev) {\n            lowest[st] = min(lowest[st], prenum[tmp->to]);\n        }\n        tmp = tmp->next;\n    }\n    if (st == 0 && cnt > 1) {\n        ans[st] = 1;\n    }\n}\n\nvoid add(int f, int t)\n{\n    edge *tmp, *new_ = (edge *)malloc(sizeof(edge));\n    new_->to = t;\n    new_->next = NULL;\n    if (graph[f].head) {\n        tmp = graph[f].head;\n        while (tmp->next) {\n            tmp = tmp->next;\n        }\n        tmp->next = new_;\n    } else {\n        graph[f].head = new_;\n    }\n}"
  },
  {
    "language": "C",
    "code": "//lowlink and bridge\n//AOJ-GRL-3-B\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nlong long val;\nlong long node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\n//Queue Template\nsd q[1048576];\nlong long qp=0,qqp=0;\n\nvoid qpush(sd x){\n    qp++;q[qp]=x;\n}\n\nsd qpop(){\n    qqp++;\n    return q[qqp];\n}\n\ntypedef struct{\n    long long st;\n    long long fi;\n    long long kr;\n}rs;\n\ntypedef struct{\n    long long st;\n    long long kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st > ((rs*)b)->st){return 1;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nif(((rs*)a)->fi > ((rs*)b)->fi){return 1;}\nif(((rs*)a)->fi < ((rs*)b)->fi){return -1;}\nreturn 0;\n}\n\nvoid makemkj(rs g[],mkj x[],long long n){\n    long long i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\n//lowlink\nlong long vid[524288],low[524288],par[524288],dim[524288],vcnt,efl[1048576];\n\nvoid reslow(){\n  long long i;\n  vcnt=0;\n  for(i=0;i<524288;i++){\n    vid[i]=-1;\n    par[i]=-1;\n    dim[i]=0;\n    low[i]=llinf;\n  }\n  for(i=0;i<1048576;i++){\n    efl[i]=0;\n  }\n}\n\nvoid lowbfs(long long v,long long p,rs g[],mkj x[]){\n  long long i;\n  vid[v]=vcnt;\n  low[v]=vcnt;\n  par[v]=p;\n  vcnt++;\n  for(i=x[v].st;i<x[v].st+x[v].kz;i++){\n    if(g[i].fi==par[v]){continue;}\n    if(vid[g[i].fi]==-1){\n      lowbfs(g[i].fi,v,g,x);\n      dim[v]++;\n      efl[i]=1;\n      low[v]=llmin(low[g[i].fi],low[v]);\n    }\n    else{\n      low[v]=llmin(vid[g[i].fi],low[v]);\n    }\n  }\n}\n\nlong long isbridge(long long eid,rs g[]){\n  long long a=g[eid].st,b=g[eid].fi;\n  if(vid[a]>vid[b]){llswap(&a,&b);}\n  if(vid[a]<low[b]){return 1;}\n  return 0;\n}\n\nint main(void){\n  reslow();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  long long isjoint[524288]={0},res[524288];\n  rs g[1048576];\n  mkj x[524288];\n  sd pd,od;\n  scanf(\"%lld%lld\",&n,&m);\n  if(n==1){printf(\"\");return 0;}\n  for(i=0;i<m;i++){\n    scanf(\"%lld%lld\",&g[i].st,&g[i].fi);\n    g[i].st++;\n    g[i].fi++;\n    g[m+i].st=g[i].fi;\n    g[m+i].fi=g[i].st;\n  }\n  qsort(g,2*m,sizeof(g[0]),sortfnc);\n  makemkj(g,x,2*m);\n  lowbfs(1,-1,g,x);\n  for(i=0;i<2*m;i++){\n    if(g[i].st>g[i].fi){continue;}\n    if(isbridge(i,g)==1){\n      printf(\"%lld %lld\\n\",g[i].st-1,g[i].fi-1);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct node **list;\nint *seq, *art, counter;\n\nvoid Insert(int, int);\nint Biconnected(int);\nint main(void)\n{\n  int i, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (int*)calloc(v, sizeof(int));\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0);\n  for (i = 0; i < v; i++) {\n    if (art[i]) printf(\"%d\\n\", i);\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id);\n      if (m < min) min = m;\n      if (seq[point] == 1) {\n        if (seq[n->id] != 2) {\n          art[point] = 1;\n        }\n      }else {\n        if (m >= seq[point]) {\n          art[point] = 1;\n        }\n      }\n    } else if (seq[n->id] < min) {\n      min = seq[n->id];\n    }\n  }\n  return min;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct pair {\n  int x;\n  int y;\n};\nstruct node **list;\nstruct pair *art;\nint *seq, counter,sp;\n\nvoid Insert(int, int);\nint Biconnected(int, int);\nvoid qsort1(int, int);\nint main(void)\n{\n  int i, j, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (struct pair*)malloc(sizeof(struct pair) * e);\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0, -1);\n  qsort1(0, sp - 1);\n  for (i = 0; i < sp; i++) printf(\"%d %d\\n\", art[i].x, art[i].y);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point, int pre)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id, point);\n      if (m < min) min = m;\n      if (m > seq[point]) {\n        if (point < n->id) {\n          art[sp].x = point;\n          art[sp].y = n->id;\n        } else {\n          art[sp].x = n->id;\n          art[sp].y = point;\n        }\n        sp++;\n      }\n    } else if (n->id != pre) {\n      if (seq[n->id] < min) {\n        min = seq[n->id];\n      }\n    }\n  }\n  return min;\n}\nvoid qsort1(int left, int right) {\n  struct pair pivot = art[(left + right) / 2];\n  int i = left, j = right;\n  if (left >= right) return;\n  do{\n    while (1) {\n      if (art[i].x >= pivot.x || (art[i].x == pivot.x && art[i].y >= pivot.y)) break;\n      i++;\n    }\n    while (1) {\n      if (art[j].x <= pivot.x || (art[j].x == pivot.x && art[j].y <= pivot.y)) break;\n      j--;\n    }\n    if (i <= j) {\n      struct pair temp = art[i];\n      art[i] = art[j];\n      art[j] = temp;\n      i++;\n      j--;\n    }\n  }while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\nstruct pair {\n  int x;\n  int y;\n};\nstruct node **list;\nstruct pair *art;\nint *seq, counter,sp;\n\nvoid Insert(int, int);\nint Biconnected(int, int);\nvoid qsort1(int, int);\nint main(void)\n{\n  int i, j, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  art = (struct pair*)malloc(sizeof(struct pair) * e);\n  seq = (int*)calloc(v, sizeof(int));\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s,t);\n  }\n  Biconnected(0, -1);\n  qsort1(0, sp - 1);\n  for (i = 0; i < sp; i++) printf(\"%d %d\\n\", art[i].x, art[i].y);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n  }\n  free(list);\n  free(seq);\n  free(art);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->next = list[b];\n  list[b] = p;\n}\nint Biconnected(int point, int pre)\n{\n  int min;\n  struct node *n;\n  counter++;\n  seq[point] = counter;\n  min = counter;\n  for(n = list[point]; n != NULL; n = n->next) {\n    if (!seq[n->id]) {\n      int m;\n      m = Biconnected(n->id, point);\n      if (m < min) min = m;\n      if (m > seq[point]) {\n        if (point < n->id) {\n          art[sp].x = point;\n          art[sp].y = n->id;\n        } else {\n          art[sp].x = n->id;\n          art[sp].y = point;\n        }\n        sp++;\n      }\n    } else if (n->id != pre) {\n      if (seq[n->id] < min) {\n        min = seq[n->id];\n      }\n    }\n  }\n  return min;\n}\nvoid qsort1(int left, int right) {\n  struct pair pivot = art[(left + right) / 2];\n  int i = left, j = right;\n  if (left >= right) return;\n  do{\n    while (1) {\n      if (art[i].x > pivot.x || (art[i].x == pivot.x && art[i].y >= pivot.y)) break;\n      i++;\n    }\n    while (1) {\n      if (art[j].x < pivot.x || (art[j].x == pivot.x && art[j].y <= pivot.y)) break;\n      j--;\n    }\n    if (i <= j) {\n      struct pair temp = art[i];\n      art[i] = art[j];\n      art[j] = temp;\n      i++;\n      j--;\n    }\n  }while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic class C implements Comparator<Bridge>\n\t{\n\n\t\t@Override\n\t\tpublic int compare(Bridge arg0, Bridge arg1) \n\t\t{\n\t\t\tint ans = arg0.v1 - arg1.v1;\n\t\t\tif(ans == 0)ans = arg0.v2 - arg1.v2;\n\t\t\treturn ans;\n\t\t}\n\t}\n\t\n\tstatic class Bridge\n\t{\n\t\tint v1;\n\t\tint v2;\n\t\t\n\t\tpublic Bridge(int v1, int v2)\n\t\t{\n\t\t\tthis.v1 = Math.min(v1, v2);\n\t\t\tthis.v2 = Math.max(v1, v2);\n\t\t}\n\t\t\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn v1 + \" \" + v2;\n\t\t}\n\t}\n\t\n\tstatic class Vertex\n\t{\n\t\tTreeSet<Integer> adjlist = new TreeSet<Integer>();\n\t\t\n\t\tint dim()\n\t\t{\n\t\t\treturn adjlist.size();\n\t\t}\n\t\t\n\t\tpublic Vertex()\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic Vertex(int adjacentTo)\n\t\t{\n\t\t\tadjlist.add(adjacentTo);\n\t\t}\n\t}\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int vn, en;\n\tstatic Vertex[] v;\n\tstatic int[] low;\n\tstatic int[] disc;\n\tstatic int[] parent;\n\tstatic boolean[] visited;\n\tstatic TreeSet<Bridge> b;\n\t\n\tstatic void DFS()\n\t{\n\t\tint time = 0;\n\t\tint pos = 0;\n\t\tStack<Integer> queue = new Stack<Integer>();\n\t\t\n\t\tqueue.push(0);\n\t\t\n\t\tint children = 0;\n\t\t\n\t\twhile(!queue.isEmpty())\n\t\t{\n\t\t\tpos = queue.peek();\n\t\t\t\n\t\t\tif(!visited[pos])\n\t\t\t{\n\t//\t\t\tSystem.out.println(\"Visit \" + pos + \" \" + queue);\n\t\t\t\tif(pos == 0)time = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttime = disc[parent[pos]] + 1;\n\t\t\t\t}\n\t\t\t\tVertex v0 = v[pos];\n\t\t\t\tboolean alreadyvisited = visited[pos];\n\t\t\t\tvisited[pos] = true;\n\t\t\t\tdisc[pos] = time;\n\t\t\t\tlow[pos] = time;\n\t\t\t\tchildren = 0;\n\t\t\t\t\n\t\t\t\tfor(int adj : v0.adjlist)\n\t\t\t\t{\n\t\t\t\t\tif(parent[pos] != adj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!visited[adj])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchildren++;\n//\t\t\t\t\t\t\tif(pos == 0)rootchildren++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tparent[adj] = pos;\n\t\t\t\t\t\t\tqueue.push(adj);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlow[pos] = Math.min(low[pos], disc[adj]);\n\t//\t\t\t\t\t\tSystem.out.println(\"Re \" + pos + \" \" + adj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = queue.pop();\n\t\t\t\t\n\t\t\t\tint par = parent[pos];\n\t\t\t\tif(par >= 0)\n\t\t\t\t{\n\t\t\t\t\tlow[par] = Math.min(low[par], low[pos]);\n\t\t\t\t\tif(disc[par] < low[pos])\n\t\t\t\t\t{\n\t\t\t\t\t\tb.add(new Bridge(par, pos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tvn = sc.nextInt();\n\t\ten = sc.nextInt();\n\t\tv = new Vertex[vn];\n\t\tdisc = new int[vn];\n\t\tlow = new int[vn];\n\t\tparent = new int[vn];\n\t\tvisited = new boolean[vn];\n\t\tC c = new C();\n\t\tb = new TreeSet<Bridge>(c);\n\n\t\tfor(int i = 0; i < vn; i++)\n\t\t{\n\t\t\tv[i] = new Vertex();\n\t\t\tparent[i] = -1;\n\t\t\tlow[i] = 999999999;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < en; i++)\n\t\t{\n//\t\t\tSystem.out.println(\"Reading edge \" + (i+1));\n\t\t\tint v1 = sc.nextInt();\n\t\t\tint v2 = sc.nextInt();\n\t\t\t\n\t\t\tv[v1].adjlist.add(v2);\n\t\t\tv[v2].adjlist.add(v1);\n\t\t}\n\t\t\n\t\tDFS();\n\t\t\n\t\tfor(Bridge s : b)\n\t\t{\n\t\t\tSystem.out.println(s);\n\t\t}\n//\t\tSystem.out.println(ap);\n//\t\tSystem.out.println(\"Disc \"+ Arrays.toString(disc));\n//\t\tSystem.out.println(\"Low \"+ Arrays.toString(low));\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private ArrayList<ArrayList<Integer>> graph;\n    private int clock;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n\n        for(int i = 0; i < V; ++i){\n            graph.add(new ArrayList<Integer>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        clock = 0;\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        Set<int[]> result = new TreeSet<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0] != o2[0]){\n                    return o1[0] - o2[0];\n                }\n                else{\n                    return o1[1] - o2[1];\n                }\n            }\n        });\n\n        if(V > 0){\n            parent[0] = -1;\n            dfs(0, visited, parent, disc, low, result);\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        Iterator<int[]> iter = result.iterator();\n        while(iter.hasNext()){\n            int[] pair = iter.next();\n            printWriter.println(pair[0] + \" \" + pair[1]);\n        }\n        printWriter.flush();\n    }\n\n    private void dfs(int u, boolean[] visited, int[] parent, int[] disc, int[] low, Set<int[]> result){\n        visited[u] = true;\n        disc[u] = low[u] = ++clock;\n\n        for(int v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                dfs(v, visited, parent, disc, low, result);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    int[] temp = new int[2];\n                    temp[0] = Math.min(u, v);\n                    temp[1] = Math.max(u, v);\n                    result.add(temp);\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main implements Runnable {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic ArrayList<int[]> bridge(int[][][] g) {\n\t\tint n = g.length;\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\n\t\tArrayList<int[]> res = new ArrayList<>();\n\n\t\tfor (int cur=0; cur<n; cur++) {\n\t\t\tif (ord[cur] == -1) {\n\t\t\t\tdfsBridge(g, cur, -1, 0, res, ord, new boolean[n], new ArrayDeque<Integer>(), new ArrayDeque<Integer>());\n\t\t\t\tres.remove(res.size()-1);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic void dfsBridge(int[][][] g, int cur, int prev, int d, ArrayList<int[]> res, int[] ord, boolean[] visited, ArrayDeque<Integer> roots, ArrayDeque<Integer> stack) {\n\t\tord[cur] = d++;\n\t\tvisited[cur] = true;\n\t\troots.addFirst(cur);\n\t\tstack.addFirst(cur);\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tint next = to[0];\n\t\t\tif (next == prev) continue;\n\t\t\tif (ord[next] == -1) dfsBridge(g, next, cur, d+1, res, ord, visited, roots, stack);\n\t\t\telse if (visited[next]) while (ord[roots.peek()] > ord[next]) roots.pollFirst();\n\t\t}\n\n\t\tif (cur == roots.peek()) {\n\t\t\tres.add(new int[]{cur, prev});\n\t\t\twhile (true) {\n\t\t\t\tint v = stack.pollFirst();\n\t\t\t\tvisited[v] = false;\n\t\t\t\tif (cur == v) break;\n\t\t\t}\n\t\t\troots.pollFirst();\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = 0;\n\t\t}\n\t\tint[][][] g = undirectedGraph(v, s, t, c);\n\t\tArrayList<int[]> ans = bridge(g);\n\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tif (ans.get(i)[0] > ans.get(i)[1]) {\n\t\t\t\tint tmp = ans.get(i)[0];\n\t\t\t\tans.get(i)[0] = ans.get(i)[1];\n\t\t\t\tans.get(i)[1] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif (a[0] != b[0]) return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tout.println(ans.get(i)[0]+\" \"+ans.get(i)[1]);\n\t\t}\n\n\t\tout.flush();\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    private static HashMap<Integer, List<Integer>> graph;\n    private static int time;\n    public static void main(String[] args) throws Exception {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        List<int[]> bridges = new LinkedList<>();\n\n        Arrays.fill(parent, -1);\n        time = 0;\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                BridgeUtil(i, parent, disc, low, visited, bridges);\n            }\n        }\n\n        Collections.sort(bridges, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0] - o2[0];\n            }\n        });\n\n        for(int[] bridge : bridges){\n            System.out.println(Math.min(bridge[0], bridge[1]) + \" \" + Math.max(bridge[0], bridge[1]));\n        }\n    }\n\n    private static void BridgeUtil(int u, int[] parent, int[] disc, int[] low, boolean[] visited, List<int[]> bridges){\n        if(visited[u]){\n            return;\n        }\n\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                BridgeUtil(v, parent, disc, low, visited, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    bridges.add(new int[] {u, v});\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    private static HashMap<Integer, List<Integer>> graph;\n    private static int time;\n    public static void main(String[] args) throws Exception {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        List<int[]> bridges = new LinkedList<>();\n\n        Arrays.fill(parent, -1);\n        time = 0;\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                BridgeUtil(i, parent, disc, low, visited, bridges);\n            }\n        }\n        Collections.sort(bridges, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0] != o2[0]){\n                    return o1[0] - o2[0];\n                }\n                else {\n                    return o1[1] - o2[1];\n                }\n            }\n        });\n        for(int[] bridge : bridges){\n            System.out.println(Math.min(bridge[0], bridge[1]) + \" \" + Math.max(bridge[0], bridge[1]));\n        }\n    }\n\n    private static void BridgeUtil(int u, int[] parent, int[] disc, int[] low, boolean[] visited, List<int[]> bridges){\n        if(visited[u]){\n            return;\n        }\n\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                BridgeUtil(v, parent, disc, low, visited, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    bridges.add(new int[] {u, v});\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    private static HashMap<Integer, List<Integer>> graph;\n    private static int time;\n    public static void main(String[] args) throws Exception {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        List<int[]> bridges = new LinkedList<>();\n\n        Arrays.fill(parent, -1);\n        time = 0;\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                BridgeUtil(i, parent, disc, low, visited, bridges);\n            }\n        }\n\n        for(int[] bridge : bridges){\n            System.out.println(Math.min(bridge[0], bridge[1]) + \" \" + Math.max(bridge[0], bridge[1]));\n        }\n    }\n\n    private static void BridgeUtil(int u, int[] parent, int[] disc, int[] low, boolean[] visited, List<int[]> bridges){\n        if(visited[u]){\n            return;\n        }\n\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                BridgeUtil(v, parent, disc, low, visited, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    bridges.add(new int[] {u, v});\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int[] parent, prenum, lowest;\n\tstatic int timer=0;\n\tstatic boolean[] visited;\n\tstatic int V;\n\tstatic boolean[][] G;\n\tstatic PriorityQueue<State> pq=new PriorityQueue<>();\n\t\n\tstatic class State implements Comparable<State>{\n\t\tint s, t;\n\t\tState(int s, int t){\n\t\t\tthis.s=s;\n\t\t\tthis.t=t;\n\t\t}\n\t\tpublic int compareTo(State p) {\n\t\t\tif(p.s==this.s) {\n\t\t\t\treturn this.t-p.t;\n\t\t\t}\n\t\t\treturn this.s-p.s;\n\t\t}\n\t}\n\t\n\t\n\tstatic void dfs(int current, int prev) {\n\t\tprenum[current]=lowest[current]=timer;\n\t\ttimer++;\n\t\tvisited[current]=true;\n\t\tint next=0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tif(G[current][i]) {\n\t\t\t\tnext=i;\n\t\t\t\tif(!visited[next]) {\n\t\t\t\t\tparent[next]=current;\n\t\t\t\t\tdfs(next, current);\n\t\t\t\t\tlowest[current]=Math.min(lowest[current], lowest[next]);\n\t\t\t\t}\n\t\t\t\telse if(next != prev) {//currentからnextがbackedgeの時\n\t\t\t\t\tlowest[current]=Math.min(lowest[current], prenum[next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic void art_point() {\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tvisited[i]=false;\n\t\t}\n\t\ttimer=1;\n\t\tdfs(0, -1);\n//\t\tfor(int i=0; i<V; i++) {\n//\t\t\tSystem.out.println(\"prenum[\"+i+\"]=\"+prenum[i]+\" lowest[\"+i+\"]=\"+lowest[i]);\n//\t\t}\n\t\t\n\t\tfor(int i=1; i<V; i++) {\n\t\t\tint p=parent[i];\n\t\t\tif(prenum[p]<lowest[i]) {\n\t\t\t\tpq.add(new State(Math.min(p, i), Math.max(p, i)));\n\t\t\t\t//System.out.println(Math.min(i, p)+\" \"+Math.max(i, p));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(! pq.isEmpty()) {\n\t\t\tState p=pq.remove();\n\t\t\tSystem.out.println(p.s+\" \"+p.t);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tV=sc.nextInt();\n\t\t\tint E=sc.nextInt();\n\t\t\tparent=new int[V];\n\t\t\tprenum=new int[V];\n\t\t\tlowest=new int[V];\n\t\t\tvisited=new boolean[V];\n\t\t\tG=new boolean[V][V];\n\t\t\tfor(int i=0; i<E; i++) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tG[s][t]=G[t][s]=true;\n\t\t\t}\n\t\t\tart_point();\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic int pos = 0;\n\n\tstatic ArrayList<int[]> bridge(int[][][] g) {\n\t\tint n = g.length;\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] roots = new int[n];\n\n\t\tArrayList<int[]> res = new ArrayList<>();\n\n\t\tfor (int cur=0; cur<n; cur++) {\n\t\t\tif (ord[cur] == -1) {\n\t\t\t\tdfsBridge(g, cur, -1, 0, res, ord, new boolean[n], new ArrayDeque<Integer>(), new ArrayDeque<Integer>());\n\t\t\t\tres.remove(res.size()-1);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic void dfsBridge(int[][][] g, int cur, int prev, int d, ArrayList<int[]> res, int[] ord, boolean[] visited, ArrayDeque<Integer> roots, ArrayDeque<Integer> stack) {\n\t\tord[cur] = pos++;\n\t\tvisited[cur] = true;\n\t\troots.addFirst(cur);\n\t\tstack.addFirst(cur);\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tint next = to[0];\n\t\t\tif (next == prev) continue;\n\t\t\tif (ord[next] == -1) dfsBridge(g, next, cur, d+1, res, ord, visited, roots, stack);\n\t\t\telse if (visited[next]) while (ord[roots.peek()] > ord[next]) roots.pollFirst();\n\t\t}\n\n\t\tif (cur == roots.peek()) {\n\t\t\tres.add(new int[]{cur, prev});\n\t\t\twhile (true) {\n\t\t\t\tint v = stack.pollFirst();\n\t\t\t\tvisited[v] = false;\n\t\t\t\tif (cur == v) break;\n\t\t\t}\n\t\t\troots.pollFirst();\n\t\t}\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = 0;\n\t\t}\n\t\tint[][][] g = undirectedGraph(v, s, t, c);\n\t\tArrayList<int[]> ans = bridge(g);\n\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tif (ans.get(i)[0] > ans.get(i)[1]) {\n\t\t\t\tint tmp = ans.get(i)[0];\n\t\t\t\tans.get(i)[0] = ans.get(i)[1];\n\t\t\t\tans.get(i)[1] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif (a[0] != b[0]) return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tout.println(ans.get(i)[0]+\" \"+ans.get(i)[1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main implements Runnable{\n    private HashMap<Integer, List<Integer>> graph;\n    private int time;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        List<int[]> bridges = new LinkedList<>();\n\n        Arrays.fill(parent, -1);\n        time = 0;\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                BridgeUtil(i, parent, disc, low, visited, bridges);\n            }\n        }\n\n        Collections.sort(bridges, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] a, int[] b) {\n                if(a[0] != b[0]){\n                    return a[0] - b[0];\n                }\n                else {\n                    return a[1] - b[1];\n                }\n            }\n        });\n\n        for(int[] bridge : bridges){\n            System.out.println(bridge[0] + \" \" + bridge[1]);\n        }\n    }\n    \n    private void BridgeUtil(int u, int[] parent, int[] disc, int[] low, boolean[] visited, List<int[]> bridges){\n        if(visited[u]){\n            return;\n        }\n\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                BridgeUtil(v, parent, disc, low, visited, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    int min = Math.min(u, v);\n                    int max = Math.max(u, v);\n                    bridges.add(new int[] {min, max});\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic ArrayList<int[]> bridge(int[][][] g) {\n\t\tint n = g.length;\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\n\t\tArrayList<int[]> res = new ArrayList<>();\n\n\t\tfor (int cur=0; cur<n; cur++) {\n\t\t\tif (ord[cur] == -1) {\n\t\t\t\tdfsBridge(g, cur, -1, 0, res, ord, new boolean[n], new ArrayDeque<Integer>(), new ArrayDeque<Integer>());\n\t\t\t\tres.remove(res.size()-1);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic void dfsBridge(int[][][] g, int cur, int prev, int d, ArrayList<int[]> res, int[] ord, boolean[] visited, ArrayDeque<Integer> roots, ArrayDeque<Integer> stack) {\n\t\tord[cur] = d++;\n\t\tvisited[cur] = true;\n\t\troots.addFirst(cur);\n\t\tstack.addFirst(cur);\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tint next = to[0];\n\t\t\tif (next == prev) continue;\n\t\t\tif (ord[next] == -1) dfsBridge(g, next, cur, d+1, res, ord, visited, roots, stack);\n\t\t\telse if (visited[next]) while (ord[roots.peek()] > ord[next]) roots.pollFirst();\n\t\t}\n\n\t\tif (cur == roots.peek()) {\n\t\t\tres.add(new int[]{cur, prev});\n\t\t\twhile (true) {\n\t\t\t\tint v = stack.pollFirst();\n\t\t\t\tvisited[v] = false;\n\t\t\t\tif (cur == v) break;\n\t\t\t}\n\t\t\troots.pollFirst();\n\t\t}\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = 0;\n\t\t}\n\t\tint[][][] g = undirectedGraph(v, s, t, c);\n\t\tArrayList<int[]> ans = bridge(g);\n\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tif (ans.get(i)[0] > ans.get(i)[1]) {\n\t\t\t\tint tmp = ans.get(i)[0];\n\t\t\t\tans.get(i)[0] = ans.get(i)[1];\n\t\t\t\tans.get(i)[1] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif (a[0] != b[0]) return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tout.println(ans.get(i)[0]+\" \"+ans.get(i)[1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main implements Runnable {\n\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        // Run with 16MB stack\n        Thread thread = new Thread(null, new Main(), \"\", 16 * 1024 * 1024);\n        thread.start();\n    }\n\n    @Override\n    public void run() {\n        final Scanner scanner = new Scanner(System.in);\n        solve(scanner);\n    }\n\n    static void solve(Scanner scanner) {\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        scanner.nextLine();\n\n        BridgeAndActuationPointsDetection detection = new BridgeAndActuationPointsDetection(V);\n        for (int i = 0; i < E; i++) {\n            int[] e = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            detection.addEdge(e[0], e[1]);\n            detection.addEdge(e[1], e[0]);\n        }\n\n        detection.run();\n        for (Edge e: detection.bridges.stream()\n                .map(b -> b.from > b.to ? new Edge(b.to, b.from, 1) : b)\n                .sorted((b1, b2) -> b1.from == b2.from ? b1.to - b2.to : b1.from - b2.from)\n                .collect(Collectors.toList())) {\n            System.out.printf(\"%d %d\\n\", e.from, e.to);\n        }\n    }\n\n}\n\nclass BridgeAndActuationPointsDetection {\n    private int size;\n    public Map<Integer, List<Edge>> edges;\n    private TreeSet<Integer> unvisited;\n    private int[] nodeId;\n    private int[] lowLink;\n    public List<Edge> bridges;\n    public Set<Integer> actuationPoints;\n\n    public BridgeAndActuationPointsDetection(int size) {\n        this.size = size;\n        edges = new HashMap<>();\n        nodeId = new int[size];\n        lowLink = new int[size];\n        for (int i = 0; i < size; i++) {\n            nodeId[i] = -1;\n            lowLink[i] = -1;\n        }\n        unvisited = new TreeSet<>();\n        for (int i = 0; i < size; i++) {\n            unvisited.add(i);\n        }\n\n        bridges = new ArrayList<>();\n        actuationPoints = new HashSet<>();\n    }\n\n    public void addEdge(int from, int to) {\n        if (!edges.containsKey(from)) {\n            edges.put(from, new ArrayList<>());\n        }\n        edges.get(from).add(new Edge(from, to, 1));\n    }\n\n    public void run() {\n        while (!unvisited.isEmpty()) {\n            dfs(unvisited.pollFirst(), -1, 0, new HashSet<>());\n        }\n    }\n\n    private int dfs(int s, int from, int id, Set<Integer> visited) {\n        nodeId[s] = id;\n        lowLink[s] = id;\n        if (visited.add(s)) {\n            unvisited.remove(s);\n            int cnt = 0;\n            for (Edge e : edges.getOrDefault(s, Collections.emptyList())) {\n                if (e.to == from) {\n                    continue;\n                }\n                if (!visited.contains(e.to)) {\n                    id = dfs(e.to, s, id + 1, visited);\n                    if (nodeId[e.to] == lowLink[e.to]) {\n                        bridges.add(e);\n                    }\n                    // Consider root node later\n                    if (from != -1 && nodeId[s] <= lowLink[e.to]) {\n                        actuationPoints.add(s);\n                    }\n                    cnt++;\n                    lowLink[s] = Math.min(lowLink[s], lowLink[e.to]);\n                } else {\n                    lowLink[s] = Math.min(lowLink[s], nodeId[e.to]);\n                }\n            }\n\n            // For root note\n            if (from == -1 && cnt >= 2) {\n                actuationPoints.add(s);\n            }\n        }\n        return id;\n    }\n\n}\n\nclass Edge {\n    public final int from;\n    public final int to;\n    public final int cost;\n\n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Edge edge = (Edge) o;\n        return from == edge.from &&\n                to == edge.to &&\n                cost == edge.cost;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(from, to, cost);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] undirectedGraph(int n, int[] v1, int[] v2, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : v1) cnt[i]++;\n\t\tfor (int i : v2) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<v1.length; i++) {\n\t\t\tint s = v1[i];\n\t\t\tint t = v2[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\n\t\t\tg[t][--cnt[t]][0] = s;\n\t\t\tg[t][cnt[t]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic ArrayList<int[]> bridge(int[][][] g) {\n\t\tint n = g.length;\n\t\tint[] ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\n\t\tArrayList<int[]> res = new ArrayList<>();\n\n\t\tfor (int cur=0; cur<n; cur++) {\n\t\t\tif (ord[cur] == -1) {\n\t\t\t\tdfsBridge(g, cur, -1, 0, res, ord, new boolean[n], new ArrayDeque<Integer>(), new ArrayDeque<Integer>());\n\t\t\t\tres.remove(res.size()-1);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic void dfsBridge(int[][][] g, int cur, int prev, int d, ArrayList<int[]> res, int[] ord, boolean[] visited, ArrayDeque<Integer> roots, ArrayDeque<Integer> stack) {\n\t\tord[cur] = d++;\n\t\tvisited[cur] = true;\n\t\troots.addFirst(cur);\n\t\tstack.addFirst(cur);\n\n\t\tfor (int[] to : g[cur]) {\n\t\t\tint next = to[0];\n\t\t\tif (next == prev) continue;\n\t\t\tif (ord[next] == -1) dfsBridge(g, next, cur, d+1, res, ord, visited, roots, stack);\n\t\t\telse if (visited[next]) while (ord[roots.peek()] > ord[next]) roots.pollFirst();\n\t\t}\n\n\t\tif (cur == roots.peek()) {\n\t\t\tres.add(new int[]{cur, prev});\n\t\t\twhile (true) {\n\t\t\t\tint v = stack.pollFirst();\n\t\t\t\tvisited[v] = false;\n\t\t\t\tif (cur == v) break;\n\t\t\t}\n\t\t\troots.pollFirst();\n\t\t}\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = 0;\n\t\t}\n\t\tint[][][] g = undirectedGraph(v, s, t, c);\n\t\tArrayList<int[]> ans = bridge(g);\n\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tif (ans.get(i)[0] > ans.get(i)[1]) {\n\t\t\t\tint tmp = ans.get(i)[0];\n\t\t\t\tans.get(i)[0] = ans.get(i)[1];\n\t\t\t\tans.get(i)[1] = tmp;\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(ans, new Comparator<int[]>(){\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif (a[0] != b[0]) return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\tfor (int i=0; i<ans.size(); i++) {\n\t\t\tout.println(ans.get(i)[0]+\" \"+ans.get(i)[1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic class Vertex\n\t{\n\t\tTreeSet<Integer> adjlist = new TreeSet<Integer>();\n\t\t\n\t\tint dim()\n\t\t{\n\t\t\treturn adjlist.size();\n\t\t}\n\t\t\n\t\tpublic Vertex()\n\t\t{\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic Vertex(int adjacentTo)\n\t\t{\n\t\t\tadjlist.add(adjacentTo);\n\t\t}\n\t}\n\t\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int vn, en;\n\tstatic Vertex[] v;\n\tstatic int[] low;\n\tstatic int[] disc;\n\tstatic int[] parent;\n\tstatic boolean[] visited;\n\tstatic TreeSet<String> b;\n\t\n\tstatic void DFS()\n\t{\n\t\tint time = 0;\n\t\tint pos = 0;\n\t\tStack<Integer> queue = new Stack<Integer>();\n\t\t\n\t\tqueue.push(0);\n\t\t\n\t\tint children = 0;\n\t\t\n\t\twhile(!queue.isEmpty())\n\t\t{\n\t\t\tpos = queue.peek();\n\t\t\t\n\t\t\tif(!visited[pos])\n\t\t\t{\n\t//\t\t\tSystem.out.println(\"Visit \" + pos + \" \" + queue);\n\t\t\t\tif(pos == 0)time = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttime = disc[parent[pos]] + 1;\n\t\t\t\t}\n\t\t\t\tVertex v0 = v[pos];\n\t\t\t\tboolean alreadyvisited = visited[pos];\n\t\t\t\tvisited[pos] = true;\n\t\t\t\tdisc[pos] = time;\n\t\t\t\tlow[pos] = time;\n\t\t\t\tchildren = 0;\n\t\t\t\t\n\t\t\t\tfor(int adj : v0.adjlist)\n\t\t\t\t{\n\t\t\t\t\tif(parent[pos] != adj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!visited[adj])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchildren++;\n//\t\t\t\t\t\t\tif(pos == 0)rootchildren++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tparent[adj] = pos;\n\t\t\t\t\t\t\tqueue.push(adj);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlow[pos] = Math.min(low[pos], disc[adj]);\n\t//\t\t\t\t\t\tSystem.out.println(\"Re \" + pos + \" \" + adj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = queue.pop();\n\t\t\t\t\n\t\t\t\tint par = parent[pos];\n\t\t\t\tif(par >= 0)\n\t\t\t\t{\n\t\t\t\t\tlow[par] = Math.min(low[par], low[pos]);\n\t\t\t\t\tif(disc[par] < low[pos])\n\t\t\t\t\t{\n\t\t\t\t\t\tb.add(par + \" \" + pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tvn = sc.nextInt();\n\t\ten = sc.nextInt();\n\t\tv = new Vertex[vn];\n\t\tdisc = new int[vn];\n\t\tlow = new int[vn];\n\t\tparent = new int[vn];\n\t\tvisited = new boolean[vn];\n\t\tb = new TreeSet<String>();\n\n\t\tfor(int i = 0; i < vn; i++)\n\t\t{\n\t\t\tv[i] = new Vertex();\n\t\t\tparent[i] = -1;\n\t\t\tlow[i] = 999999999;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < en; i++)\n\t\t{\n//\t\t\tSystem.out.println(\"Reading edge \" + (i+1));\n\t\t\tint v1 = sc.nextInt();\n\t\t\tint v2 = sc.nextInt();\n\t\t\t\n\t\t\tv[v1].adjlist.add(v2);\n\t\t\tv[v2].adjlist.add(v1);\n\t\t}\n\t\t\n\t\tDFS();\n\t\t\n\t\tfor(String s : b)\n\t\t{\n\t\t\tSystem.out.println(s);\n\t\t}\n//\t\tSystem.out.println(ap);\n//\t\tSystem.out.println(\"Disc \"+ Arrays.toString(disc));\n//\t\tSystem.out.println(\"Low \"+ Arrays.toString(low));\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int[] parent, prenum, lowest;\n\tstatic int timer=0;\n\tstatic boolean[] visited;\n\tstatic int V;\n\tstatic boolean[][] G;\n\tstatic PriorityQueue<State> pq=new PriorityQueue<>();\n\t\n\tstatic class State implements Comparable<State>{\n\t\tint s, t;\n\t\tState(int s, int t){\n\t\t\tthis.s=s;\n\t\t\tthis.t=t;\n\t\t}\n\t\tpublic int compareTo(State p) {\n\t\t\tif(p.s==this.s) {\n\t\t\t\treturn this.t-p.t;\n\t\t\t}\n\t\t\treturn this.s-p.s;\n\t\t}\n\t}\n\t\n\t\n\tstatic void dfs(int current, int prev) {\n\t\tprenum[current]=lowest[current]=timer;\n\t\ttimer++;\n\t\tvisited[current]=true;\n\t\tint next=0;\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tif(G[current][i]) {\n\t\t\t\tnext=i;\n\t\t\t\tif(!visited[next]) {\n\t\t\t\t\tparent[next]=current;\n\t\t\t\t\tdfs(next, current);\n\t\t\t\t\tlowest[current]=Math.min(lowest[current], lowest[next]);\n\t\t\t\t}\n\t\t\t\telse if(next != prev) {//currentからnextがbackedgeの時\n\t\t\t\t\tlowest[current]=Math.min(lowest[current], prenum[next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic void art_point() {\n\t\tfor(int i=0; i<V; i++) {\n\t\t\tvisited[i]=false;\n\t\t}\n\t\ttimer=1;\n\t\tdfs(0, -1);\n//\t\tfor(int i=0; i<V; i++) {\n//\t\t\tSystem.out.println(\"prenum[\"+i+\"]=\"+prenum[i]+\" lowest[\"+i+\"]=\"+lowest[i]);\n//\t\t}\n\t\t\n\t\tfor(int i=1; i<V; i++) {\n\t\t\tint p=parent[i];\n\t\t\tif(prenum[p]<lowest[i]) {\n\t\t\t\t//pq.add(new State(p, i));\n\t\t\t\tSystem.out.println(p+\" \"+i);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(int i=0; i<pq.size(); i++) {\n//\t\t\tState p=pq.remove();\n//\t\t\tSystem.out.println(p.s+\" \"+p.t);\n//\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tV=sc.nextInt();\n\t\t\tint E=sc.nextInt();\n\t\t\tparent=new int[V];\n\t\t\tprenum=new int[V];\n\t\t\tlowest=new int[V];\n\t\t\tvisited=new boolean[V];\n\t\t\tG=new boolean[V][V];\n\t\t\tfor(int i=0; i<E; i++) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tG[s][t]=G[t][s]=true;\n\t\t\t}\n\t\t\tart_point();\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n         \n        int v = sc.nextInt();\n        int e = sc.nextInt();\n        \n        SGraph g = new SGraph(v);\n        \n        for(int i=0;i<e;i++){\n        \tg.addEdge(sc.nextInt(), sc.nextInt());\n        }\n        \n        ArrayList<SGraph.EdgePair> l = g.bridge();\n        Collections.sort(l);\n        for(SGraph.EdgePair p:l){\n        \tSystem.out.println(p.a + \" \" + p.b);\n        }\n        \n    }\n\t\n}\n\nclass SGraph {\n\n\tNodeList[] nlist; //隣接リスト\n\t\n\tpublic SGraph(int vnum){\n\t\tthis.nlist = new NodeList[vnum];\n\t\tfor(int i=0;i<vnum;i++){\n\t\t\tnlist[i] = new NodeList();\n\t\t}\n\t}\n\t\n\t//辺の追加（同じ辺を複数回追加すると多重辺になる）\n\tvoid addEdge(int n, int m){\n\t\tnlist[n].add(m);\n\t\tnlist[m].add(n);\n\t}\n\t\n\t//頂点数を返す\n\tint vnum(){\n\t\treturn nlist.length;\n\t}\n\t\n\t//辺数を返す\n\tint edgeNum(){\n\t\tint sum = 0;\n\t\tfor(NodeList l:nlist){\n\t\t\tsum += l.size();\n\t\t}\n\t\treturn sum/2;\n\t}\n\t\n\t//隣接判定\n\tboolean isNext(int n, int m){\n\t\treturn nlist[n].contains(m);\n\t}\n\t\n\t//隣接する全ての頂点を返す\n\tNodeList nextList(int n){\n\t\treturn nlist[n];\n\t}\n\t\n\t//含まれる木の数を返す\n\tint treeNum(){\n    \tboolean[] isVisited = new boolean[vnum()];\n    \tint[] par = new int[vnum()];\n    \tint TreeNum = 0;\n    \t\n    \tboolean con = true;\n    \t\n    \twhile(con){\n    \t\tint core = -1;\n    \t\t\n    \t\tfor(int i=0;i<vnum();i++){\n    \t\t\tif(!isVisited[i]){\n    \t\t\t\tcore = i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(core==-1){\n    \t\t\tcon = false;\n    \t\t}\n    \t\telse{\n    \t\t\tboolean isTree = true;\n    \t\t\tArrayDeque<Integer> s = new ArrayDeque<>();\n    \t\t\ts.offerFirst(core);\n    \t\t\tisVisited[core] = true;\n    \t\t\t\n    \t\t\twhile(!s.isEmpty()){\n    \t\t\t\tint now = s.pollFirst();\n    \t\t\t\t\n    \t\t\t\tfor(int i:this.nextList(now)){\n    \t\t\t\t\t\n    \t\t\t\t\tif(isVisited[i]){\n    \t\t\t\t\t\tif(par[now] != i){\n        \t\t\t\t\t\tisTree = false;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\telse{\n        \t\t\t\t\ts.offerFirst(i);\n        \t\t\t\t\tisVisited[i] = true;\n        \t\t\t\t\tpar[i] = now;\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(isTree){\n    \t\t\t\tTreeNum += 1;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \treturn TreeNum;\n\t}\n\t\n\t//森かどうか返す\n\tboolean isForest(){\n    \tboolean[] isVisited = new boolean[vnum()];\n    \tint[] par = new int[vnum()];\n    \t\n    \tboolean con = true;\n    \t\n    \twhile(con){\n    \t\tint core = -1;\n    \t\t\n    \t\tfor(int i=0;i<vnum();i++){\n    \t\t\tif(!isVisited[i]){\n    \t\t\t\tcore = i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(core==-1){\n    \t\t\tcon = false;\n    \t\t}\n    \t\telse{\n    \t\t\tboolean isTree = true;\n    \t\t\tArrayDeque<Integer> s = new ArrayDeque<>();\n    \t\t\ts.offerFirst(core);\n    \t\t\tisVisited[core] = true;\n    \t\t\t\n    \t\t\twhile(!s.isEmpty()){\n    \t\t\t\tint now = s.pollFirst();\n    \t\t\t\t\n    \t\t\t\tfor(int i:this.nextList(now)){\n    \t\t\t\t\t\n    \t\t\t\t\tif(isVisited[i]){\n    \t\t\t\t\t\tif(par[now] != i){\n        \t\t\t\t\t\tisTree = false;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\telse{\n        \t\t\t\t\ts.offerFirst(i);\n        \t\t\t\t\tisVisited[i] = true;\n        \t\t\t\t\tpar[i] = now;\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t}\n    \t\t\t\n    \t\t\tif(!isTree){\n    \t\t\t\treturn false;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \treturn true;\n\t}\n\t\n\t//連結成分数を返す\n\tint CCNum(){\n    \tboolean[] isVisited = new boolean[vnum()];\n    \tint CNum = 0;\n    \t\n    \tboolean con = true;\n    \t\n    \twhile(con){\n    \t\tint core = -1;\n    \t\t\n    \t\tfor(int i=0;i<vnum();i++){\n    \t\t\tif(!isVisited[i]){\n    \t\t\t\tcore = i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(core==-1){\n    \t\t\tcon = false;\n    \t\t}\n    \t\telse{\n\n    \t\t\tArrayDeque<Integer> s = new ArrayDeque<>();\n    \t\t\ts.offerFirst(core);\n    \t\t\tisVisited[core] = true;\n    \t\t\tCNum += 1;\n    \t\t\t\n    \t\t\twhile(!s.isEmpty()){\n    \t\t\t\tint now = s.pollFirst();\n    \t\t\t\t\n    \t\t\t\tfor(int i:this.nextList(now)){\n    \t\t\t\t\t\n    \t\t\t\t\tif(!isVisited[i]){\n        \t\t\t\t\ts.offerFirst(i);\n        \t\t\t\t\tisVisited[i] = true;\n    \t\t\t\t\t}\n\n    \t\t\t\t}\n\n    \t\t\t}\n\n    \t\t}\n    \t}\n    \t\n    \treturn CNum;\n\t}\n\n\t//連結成分に分割\n\tLinkedList<SGraph> CCSet(){\n\t\tLinkedList<SGraph> set = new LinkedList<>();\n\t\t\n    \tboolean[] isVisited = new boolean[vnum()];\n\n    \tboolean con = true;\n    \t\n    \twhile(con){\n    \t\tint core = -1;\n    \t\t\n    \t\tfor(int i=0;i<vnum();i++){\n    \t\t\tif(!isVisited[i]){\n    \t\t\t\tcore = i;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tif(core==-1){\n    \t\t\tcon = false;\n    \t\t}\n    \t\telse{\n    \t\t\tjava.util.ArrayList<Integer> list = new java.util.ArrayList<>();\n    \t\t\tArrayDeque<Integer> s = new ArrayDeque<>();\n    \t\t\ts.offerFirst(core);\n    \t\t\tlist.add(core);\n    \t\t\tisVisited[core] = true;\n    \t\t\t\n    \t\t\twhile(!s.isEmpty()){\n    \t\t\t\tint now = s.pollFirst();\n    \t\t\t\t\n    \t\t\t\tfor(int i:this.nextList(now)){\n    \t\t\t\t\t\n    \t\t\t\t\tif(!isVisited[i]){\n        \t\t\t\t\ts.offerFirst(i);\n        \t\t\t\t\tisVisited[i] = true;\n        \t\t\t\t\tlist.add(i);\n    \t\t\t\t\t}\n    \t\t\t\t}\n\n    \t\t\t}\n    \t\t\t\n    \t\t\tCollections.sort(list);;\n    \t\t\tint size = list.size();\n    \t\t\tSGraph g = new SGraph(size);\n    \t\t\t\n    \t\t\tint[] newindex = new int[this.vnum()];\n    \t\t\t\n    \t\t\tfor(int i=0;i<list.size();i++){\n    \t\t\t\tnewindex[list.get(i)] = i;\n    \t\t\t}\n    \t\t\t\n    \t\t\tfor(int i:list){\n    \t\t\t\tfor(int j:this.nlist[i]){\n    \t\t\t\t\tif(i<j){\n        \t\t\t\t\tg.addEdge(newindex[i],newindex[j]);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tset.add(g);\n    \t\t\t\n    \t\t}\n    \t}\n    \t\n    \treturn set;\n\t}\n\n\t//2点間距離をBFSで求める。到達不可は-1。\n\tint distance(int n, int m){\n\t\t\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\tint[] d = new int[vnum()];\t//nとの距離。未チェックなら-1。\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\td[i] = -1;\n\t\t}\n\t\t\n\t\tq.add(n);\n\t\td[n] = 0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.pollFirst();\n\t\t\t\n\t\t\tfor(int i:nextList(now)){\n\t\t\t\tif(d[i] == -1){\n\t\t\t\t\tif(i==m){\n\t\t\t\t\t\treturn d[now]+1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\td[i] = d[now]+1;\n\t\t\t\t\tq.offerLast(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\t//nとの距離のリストを返す（BFS）。到達不可は-1。\n\tint[] distanceList(int n){\n\t\t\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\tint[] d = new int[vnum()];\t//nとの距離。未チェックなら-1。\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\td[i] = -1;\n\t\t}\n\t\t\n\t\tq.add(n);\n\t\td[n] = 0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.pollFirst();\n\t\t\t\n\t\t\tfor(int i:nextList(now)){\n\t\t\t\tif(d[i] == -1){\n\t\t\t\t\td[i] = d[now]+1;\n\t\t\t\t\tq.offerLast(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\t\n\t//2部グラフかどうか判定\n\tboolean isBipartite(){\n\t\t//白黒で2彩色可能か判定\n\t\tboolean[] isBlack = new boolean[vnum()];\n\t\tboolean[] isChecked = new boolean[vnum()];\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\n\t\tboolean con = true;\n\t\t\n\t\twhile(con){\n\t\t\t\n\t\t\tint core = -1;\n\t\t\tfor(int i=0;i<vnum();i++){\n\t\t\t\tif(!isChecked[i]){\n\t\t\t\t\tcore = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(core!=-1){\n\t\t\t\tq.offerFirst(core);\n\t\t\t\tisBlack[core] = true;\n\t\t\t\tisChecked[core] = true;\n\t\t\t\t\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint now = q.pollFirst();\n\t\t\t\t\t\n\t\t\t\t\tfor(int i:nextList(now)){\n\t\t\t\t\t\tif(!isChecked[i]){\n\t\t\t\t\t\t\tisChecked[i] = true;\n\t\t\t\t\t\t\tisBlack[i] = !isBlack[now];\n\t\t\t\t\t\t\tq.offerFirst(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(isBlack[i] == isBlack[now]){\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcon = false;\n\t\t\t}\t\n\t\t\t\n\t\t}\n\t\n\t\treturn true;\n\t}\n\t\n\t//2部グラフにしたときの、左右の頂点数のうち小さい方を返す（連結前提、不可能なら-1を返す）\n\tint bipartiteNum(){\n\t\t//白黒で2彩色可能か判定\n\t\tboolean[] isBlack = new boolean[vnum()];\n\t\tboolean[] isChecked = new boolean[vnum()];\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\n\t\tq.offerFirst(0);\n\t\tisBlack[0] = true;\n\t\tisChecked[0] = true;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.pollFirst();\n\t\t\t\n\t\t\tfor(int i:nextList(now)){\n\t\t\t\tif(!isChecked[i]){\n\t\t\t\t\tisChecked[i] = true;\n\t\t\t\t\tisBlack[i] = !isBlack[now];\n\t\t\t\t\tq.offerFirst(i);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(isBlack[i] == isBlack[now]){\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\n\t\t//ここに到達すれば二部グラフ\n\t\tint blacknum = 0;\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\tif(isBlack[i]){\n\t\t\t\tblacknum += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn Math.min(blacknum, vnum()-blacknum);\n\t}\n\n\t//橋を列挙（連結グラフ）（indexは小→大）\n\tpublic ArrayList<EdgePair> bridge(){\n\t\tint[] ord = new int[vnum()];\n\t\tint[] ordidx = new int[vnum()]; //そのオーダーを持つ頂点のインデックス\n\t\tint[] lowlink = new int[vnum()];\n\t\tArrays.fill(lowlink, -1);\n\t\t\n\t\t//DFS木を作り、ordを求める\n\t\tArrayDeque<Integer> a = new ArrayDeque<>();\n\t\ta.offerFirst(0);\n\t\tint noword = 0;\n\t\tboolean isVisited[] = new boolean[vnum()];\n\t\tint parent[] = new int[vnum()];\n\t\tHashSet<EdgePair> tree = new HashSet<>(); //DFS木に含まれる辺（ここになければ後退辺\n\t\t\n\t\twhile(!a.isEmpty()){\n\t\t\tint now = a.pollFirst();\n\t\t\t\n\t\t\tif(isVisited[now]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited[now] = true;\n\t\t\ttree.add(new EdgePair(parent[now],now));\n\t\t\t\n\t\t\tord[now] = noword;\n\t\t\tordidx[noword] = now;\n\t\t\tnoword++;\n\t\t\t\n\t\t\tfor(int i:nextList(now)){\n\t\t\t\ta.offerFirst(i);\n\t\t\t\tparent[i] = now;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//後ろからlowlinkを求める\n\t\tfor(int i=vnum()-1;i>=0;i--){\n\t\t\tint now = ordidx[i];\n\t\t\tint min = i;\n\t\t\tfor(int j:nextList(now)){\n\t\t\t\tif(ord[j]<i){\t//jが親\n\t\t\t\t\tif(tree.contains(new EdgePair(j,now))){ //後退辺でないなら数えない\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(lowlink[j]!=-1){\n\t\t\t\t\tif(min>lowlink[j]){\n\t\t\t\t\t\tmin = lowlink[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(min>ord[j]){\n\t\t\t\t\t\tmin = ord[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlowlink[now] = min;\n\t\t}\n\t\t\n\t\tArrayList<EdgePair> ans = new ArrayList<>();\n\t\t\n\t\t//全ての辺が橋かチェック\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\tfor(int j:nextList(i)){\n\t\t\t\tif(ord[i]<ord[j]){ //iが親のときのみ調べる（2重に調べるのを防ぐ）\n\t\t\t\t\tif(ord[i] < lowlink[j]){\n\t\t\t\t\t\tans.add(new EdgePair(Math.min(i,j),Math.max(i,j)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tclass EdgePair implements Comparable<EdgePair>{\n\t\tint a,b;\n\t\t\n\t\tpublic EdgePair(int a, int b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\tif(o instanceof EdgePair){\n\t\t\t\tEdgePair p = (EdgePair) o;\n\t\t\t\treturn (a == p.a && b == p.b)||(a == p.b && b == p.a);\n\t\t\t}\n\t\t\treturn super.equals(o);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(EdgePair o){\n\t\t\tif(a!=o.a){\n\t\t\t\treturn Integer.compare(a,o.a);\n\t\t\t}\n\t\t\treturn Integer.compare(b, o.b);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\treturn (a<<16)+b;\n\t\t}\n\t\t\n\t}\n\tclass NodeList extends ArrayList<Integer>{\n\t\tprivate static final long serialVersionUID = -4461479015945373120L;\n\t}\n}\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    private static HashMap<Integer, List<Integer>> graph;\n    private static int time;\n    public static void main(String[] args) throws Exception {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[V];\n        int[] parent = new int[V];\n        int[] disc = new int[V];\n        int[] low = new int[V];\n        List<int[]> bridges = new LinkedList<>();\n\n        Arrays.fill(parent, -1);\n        time = 0;\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                BridgeUtil(i, parent, disc, low, visited, bridges);\n            }\n        }\n\n        Collections.sort(bridges, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] a, int[] b) {\n                if(a[0] != b[0]){\n                    return a[0] - b[0];\n                }\n                else {\n                    return a[1] - b[1];\n                }\n            }\n        });\n\n        for(int[] bridge : bridges){\n            System.out.println(bridge[0] + \" \" + bridge[1]);\n        }\n    }\n\n    private static void BridgeUtil(int u, int[] parent, int[] disc, int[] low, boolean[] visited, List<int[]> bridges){\n        if(visited[u]){\n            return;\n        }\n\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                parent[v] = u;\n                BridgeUtil(v, parent, disc, low, visited, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if(low[v] > disc[u]){\n                    int min = Math.min(u, v);\n                    int max = Math.max(u, v);\n                    bridges.add(new int[] {min, max});\n                }\n            }\n            else if(v != parent[u]){\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<int>[] li;\n\tstatic bool[] b;\n\tstatic int[] h;\n\tstatic int[] low,pre;\n\tstatic List<Tuple<int,int>> ans;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tint n=s[0],m=s[1];\n\t\tif(m==0){return;}\n\t\tli=new List<int>[n+1];\n\t\tb=new bool[n+1];\n\t\th=new int[n+1];\n\t\tlow=new int[n+1];\n\t\tpre=new int[n+1];\n\t\tans=new List<Tuple<int,int>>();\n\t\tfor(int i=0;i<n;i++){li[i]=new List<int>();}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint[] e=sc.Ia;\n\t\t\tli[e[0]].Add(e[1]);\n\t\t\tli[e[1]].Add(e[0]);\n\t\t}\n\t\tFu(1,0,-1);\n\t\tvar ans2=ans.OrderBy(x=>x.Item1).ThenBy(x=>x.Item2).ToArray();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tforeach(var e in ans2){sb.Append(e.Item1+\" \"+e.Item2+\"\\n\");}\n\t\tConsole.Write(sb);\n\t}\n\tstatic void Fu(int a,int g,int p){\n\t\tb[a]=true;\n\t\tpre[a]=g;\n\t\tlow[a]=g;\n\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i]]){\n\t\t\t\tFu(li[a][i],g+1,a);\n\t\t\t\tif(low[li[a][i]]==pre[li[a][i]]){ans.Add(Tuple.Create(Min(a,li[a][i]),Max(a,li[a][i])));}\n\t\t\t}\n\t\t\tif(li[a][i]!=p){low[a]=Min(low[li[a][i]],low[a]);}\n\t\t}\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace GraphBridges\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] info = Console.ReadLine().Split().Select(x => Convert.ToInt32(x)).ToArray();\n            int v = info[0];\n            int e = info[1];\n\n            IDictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\n            for(int i = 0; i < e; ++i)\n            {\n                int[] edge = Console.ReadLine().Split().Select(x => Convert.ToInt32(x)).ToArray();\n                if(!graph.ContainsKey(edge[0]))\n                    graph.Add(edge[0], new HashSet<int>());\n                if(!graph.ContainsKey(edge[1]))\n                    graph.Add(edge[1], new HashSet<int>());\n                graph[edge[0]].Add(edge[1]);\n                graph[edge[1]].Add(edge[0]);\n            }\n\n            GraphAlgorithms rAlgorithms = new GraphAlgorithms();\n            IList<int[]> bridges = rAlgorithms.FindBridges(graph);\n            (bridges as List<int[]>).Sort((x, y) =>\n            {\n                Array.Sort(x);\n                Array.Sort(y);\n                if(x[0] == y[0])\n                    return x[1] - y[1];\n                return x[0] - y[0];\n            });\n            foreach (var br in bridges)\n               System.Console.WriteLine(br[0] + \" \" + br[1]); \n        }\n    }\n\n    public class GraphAlgorithms\n    {\n        public virtual IList<int[]> FindBridges(IDictionary<int, HashSet<int>> graph)\n        {\n            HashSet<int> visited = new HashSet<int>();\n            IDictionary<int, int> lowLink = new Dictionary<int, int>();\n            IDictionary<int, int> ids = new Dictionary<int, int>();\n            IList<int[]> bridges = new List<int[]>();\n            int id = 0;\n            foreach(var kv in graph)\n            {\n                if(visited.Contains(kv.Key))\n                    continue;\n                _FindBridges(kv.Key, -1, ref id, visited, lowLink, ids, graph, bridges);\n            }\n            return bridges;\n        }\n\n        protected virtual void _FindBridges(int v, int parent, ref int id, \n            HashSet<int> visited, \n            IDictionary<int, int> lowLink, \n            IDictionary<int, int> ids, \n            IDictionary<int, HashSet<int>> graph,\n            IList<int[]> bridges)\n        {\n            int tp_id = id;\n            ids.Assign(v, int.MaxValue, x => Math.Min(x, tp_id));\n            lowLink.Insert(v, ids[v]);\n            visited.Add(v);\n            foreach (var adj_vert in graph[v])\n            {\n                if(adj_vert == parent)\n                    continue;\n                if(!visited.Contains(adj_vert))\n                {\n                    ++id;\n                    _FindBridges(adj_vert, v, ref id, visited, lowLink, ids, graph, bridges);\n                } \n                if(ids[v] < lowLink[adj_vert])\n                    bridges.Add(new [] { v, adj_vert });\n                lowLink[v] = Math.Min(lowLink[v], lowLink[adj_vert]);\n            }\n        }\n    }\n\n    public static class DictionaryHelpers\n    {\n        public static void Insert<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue value)\n        {\n            if(!dictionary.ContainsKey(key))    \n                dictionary.Add(key, default(TValue));\n            dictionary[key] = value;\n        }\n\n        public static void Assign<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue default_value, Func<TValue, TValue> value_resolver)\n        {\n            if(!dictionary.ContainsKey(key))\n                dictionary.Add(key, default_value);\n            dictionary[key] = value_resolver(dictionary[key]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static int[] preNum, parent, lowest;\n        static bool[] visited;\n        static int timer;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n\n            Dictionary<int, List<int>> G = new Dictionary<int, List<int>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<int>());\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int s = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n\n                G[s].Add(t);\n                G[t].Add(s);\n            }\n\n            PrintBridges(G, V);\n        }\n\n        static void PrintBridges(Dictionary<int, List<int>> G, int V)\n        {\n            preNum = new int[V];\n            parent = new int[V];\n            lowest = new int[V];\n            visited = new bool[V];\n            timer = 1;\n\n            DFS(G, 0, -1);\n\n            List<KeyValuePair<int, int>> ans = new List<KeyValuePair<int, int>>();\n            for (int i = 1; i < V; i++)\n            {\n                int p = parent[i];\n\n                if (preNum[p] < lowest[i])\n                {\n                    int s = Math.Min(p, i);\n                    int t = Math.Max(p, i);\n                    ans.Add(new KeyValuePair<int, int>(s, t));\n                }\n            }\n            var query = ans.OrderBy(a => a.Key).ThenBy(a => a.Value);\n\n            StringBuilder sb = new StringBuilder();\n            foreach (var q in query)\n            {\n                sb.AppendLine(q.Key + \" \" + q.Value);\n            }\n            Console.Write(sb);\n        }\n\n        static void DFS(Dictionary<int, List<int>> G, int cur, int prev)\n        {\n            preNum[cur] = lowest[cur] = timer;\n            timer++;\n\n            visited[cur] = true;\n\n            for (int i = 0; i < G[cur].Count; i++)\n            {\n                int next = G[cur][i];\n\n                if (!visited[next])\n                {\n                    parent[next] = cur;\n\n                    DFS(G, next, cur);\n\n                    lowest[cur] = Math.Min(lowest[cur], lowest[next]);\n                }\n                else if (next != prev)\n                {\n                    lowest[cur] = Math.Min(lowest[cur], preNum[next]);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using Debug;\n//using static System.Globalization.CultureInfo;\n//using Edge = Pair<long, int>;\nusing System.Text;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        Solve();\n        Console.Out.Flush();\n        //WriteLine(Solve());\n    }\n    static void Solve()\n    {\n        var ve = Input.ar;\n        var adj = Enumerable.Repeat(0, ve[0]).Select(_ => new List<int>()).ToArray();\n        while (ve[1]-- > 0)\n        {\n            var st = Input.ar;\n            adj[st[0]].Add(st[1]);\n            adj[st[1]].Add(st[0]);\n        }\n        var l = LowLink.Bridge(adj);\n        if(l.Count!=0)\n        WriteLine(string.Join(\"\\n\", l.OrderBy(v=>v)));\n    }\n}\n\npublic class LowLink\n{\n    private static List<int> arti;\n    private static int[] ord, low;\n    private static List<Pair<int, int>> bridge;\n    private static bool[] th;\n    private static IList<IEnumerable<int>> adj;\n    public static List<int> Articulation(IList<IEnumerable<int>> edge)\n    {\n        adj = edge;\n        arti = new List<int>();\n        ord = new int[edge.Count];\n        low = new int[edge.Count];\n        bridge = new List<Pair<int, int>>();\n        th = new bool[edge.Count];\n        var ct = 0;\n        for (var i = 0; i < edge.Count; i++)\n            if (!th[i]) ct = dfs(i, ct, -1);\n        return arti;\n    }\n    public static List<Pair<int,int>> Bridge(IList<IEnumerable<int>> edge)\n    {\n        Articulation(edge);\n        return bridge;\n    }\n    private static int dfs(int index,int ct,int par)\n    {\n        th[index] = true;\n        ord[index] = ct;\n        low[index] = ct++;\n        var isArti = false;\n        var c = 0;\n        foreach (var ad in adj[index])\n            if(!th[ad])\n            {\n                c++;\n                ct = dfs(ad, ct, index);\n                low[index] = Min(low[index], low[ad]);\n                isArti |= par != -1 && low[ad] >= ord[index];\n                if (ord[index] < low[ad])\n                    bridge.Add(new Pair<int, int>(Min(index,ad), Max(index,ad)));   \n            }\n            else if (ad != par)\n                low[index] = Min(low[index], ord[ad]);\n        isArti |= par == -1 && c > 1;\n        if (isArti) arti.Add(index);\n        return ct;\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => ToInt64(read);\n    public static char[][] gred(int h)\n        => Enumerable.Repeat(0, h).Select(_ => read.ToCharArray()).ToArray();\n    public static int[] ar1D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => num).ToArray();\n    public static long[] arL1D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => numL).ToArray();\n    public static string[] strs(int n)\n        => Enumerable.Repeat(0, n).Select(_ => read).ToArray();\n    public static int[][] ar2D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => ar).ToArray();\n    public static long[][] arL2D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => arL).ToArray();\n    public static T getValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public static string[] Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        var r = read.Split(' ');\n        v1 = getValue<T1>(r[0]);\n        v2 = getValue<T2>(r[1]);\n        return r;\n    }\n    public static string[] Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        var r = Make(out v1, out v2);\n        v3 = getValue<T3>(r[2]);\n        return r;\n    }\n    public static string[] Make<T1,T2,T3,T4>(out T1 v1,out T2 v2,out T3 v3,out T4 v4)\n    {\n        var r = Make(out v1, out v2, out v3);\n        v4 = getValue<T4>(r[3]);\n        return r;\n    }\n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() : this(default(T1), default(T2)) { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1;this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int M = cin.nextint;\n        var L = new LowLink();\n        var G = L.Input(N, M, false, 0);\n        L.Run(G);\n        L.bridge.Sort();\n        foreach (var item in L.bridge)\n        {\n            WriteLine(item);\n        }\n    }\n\n}\n\nclass LowLink\n{\n    bool[] used;\n    int[] ord, low;\n    public List<int> articulation;\n    public List<pair> bridge;\n    List<int>[] G;\n\n    public List<int>[] Input(int n, int m, bool dir = false, int indexed = 1, bool cost = false)\n    {\n        var cin = new Scanner();\n        var G = new List<int>[n];\n        for (int i = 0; i < G.Length; i++)\n        {\n            G[i] = new List<int>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int a = cin.nextint - indexed;\n            int b = cin.nextint - indexed;\n            G[a].Add(b);\n            if (!dir) G[b].Add(a);\n            if (cost) { var tmp = cin.next; }\n        }\n        return G;\n    }\n    public void Run(List<int>[] G)\n    {\n        this.G = G;\n        int n = G.Length;\n        used = new bool[n];\n        ord = new int[n];\n        low = new int[n];\n        articulation = new List<int>();\n        bridge = new List<pair>();\n        int k = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (used[i]) continue;\n            k = dfs(i, k, -1);\n        }\n    }\n    int dfs(int idx, int k, int par)\n    {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_articulation = false;\n        int cnt = 0;\n        foreach (var to in G[idx])\n        {\n            if (!used[to])\n            {\n                cnt++;\n                k = dfs(to, k, idx);\n                low[idx] = Min(low[idx], low[to]);\n                is_articulation |= par != -1 && low[to] >= ord[idx];\n                if (ord[idx] < low[to]) bridge.Add(new pair(Min(idx, to), Max(idx, to)));\n            }\n            else if (to != par)\n            {\n                low[idx] = Min(low[idx], ord[to]);\n            }\n        }\n        is_articulation |= par == -1 && cnt > 1;\n        if (is_articulation) articulation.Add(idx);\n        return k;\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static int[] preNum, parent, lowest;\n        static bool[] visited;\n        static int timer;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n\n            Dictionary<int, List<int>> G = new Dictionary<int, List<int>>();\n            for (int i = 0; i < V; i++) G.Add(i, new List<int>());\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int s = int.Parse(input[0]);\n                int t = int.Parse(input[1]);\n\n                G[s].Add(t);\n                G[t].Add(s);\n            }\n\n            PrintBridges(G, V);\n        }\n\n        static void PrintBridges(Dictionary<int, List<int>> G, int V)\n        {\n            preNum = new int[V];\n            parent = new int[V];\n            lowest = new int[V];\n            visited = new bool[V];\n            timer = 1;\n\n            DFS(G, 0, -1);\n\n            List<KeyValuePair<int, int>> ans = new List<KeyValuePair<int, int>>();\n            for (int i = 1; i < V; i++)\n            {\n                int p = parent[i];\n\n                if (preNum[p] < lowest[i])\n                {\n                    if (p < i) ans.Add(new KeyValuePair<int, int>(p, i));\n                    else ans.Add(new KeyValuePair<int, int>(i, p));\n                }\n            }\n            var query = ans.OrderBy(a => a.Key).ThenBy(a => a.Value);\n\n            StringBuilder sb = new StringBuilder();\n            foreach (var q in query) sb.AppendLine(q.Key + \" \" + q.Value);\n            Console.Write(sb);\n        }\n\n        static void DFS(Dictionary<int, List<int>> G, int cur, int prev)\n        {\n            preNum[cur] = lowest[cur] = timer;\n            timer++;\n\n            visited[cur] = true;\n\n            for (int i = 0; i < G[cur].Count; i++)\n            {\n                int next = G[cur][i];\n\n                if (!visited[next])\n                {\n                    parent[next] = cur;\n\n                    DFS(G, next, cur);\n\n                    lowest[cur] = Math.Min(lowest[cur], lowest[next]);\n                }\n                else if (next != prev)\n                {\n                    lowest[cur] = Math.Min(lowest[cur], preNum[next]);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Reader.IntTable(M);\n        var bridges = new TwoEdgeConnectedComponent(N, E).Bridges;\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        bridges.ForEach(b => Console.WriteLine(b[0] + \" \" + b[1]));\n        Console.Out.Flush();\n        Console.ReadLine();\n    }\n}\n\npublic class TwoEdgeConnectedComponent\n{\n    int N, id;\n    List<int>[] E;\n    int[] component, order;\n    bool[] inS;\n    Stack<int> S = new Stack<int>(), roots = new Stack<int>();\n    List<int[]> vertexes = new List<int[]>();\n    HashSet<long> BridgesSet = new HashSet<long>();\n    public List<int[]> Bridges = new List<int[]>();\n\n    public TwoEdgeConnectedComponent(int N) { Init(N); }\n    public TwoEdgeConnectedComponent(int N, int[][] E, int origin = 0)\n    {\n        Init(N);\n        Array.ForEach(E, e => AddEdge(e[0] - origin, e[1] - origin));\n        Decompose();\n    }\n\n    void Init(int N)\n    {\n        this.N = N;\n        component = new int[N];\n        order = new int[N];\n        inS = new bool[N];\n        E = new List<int>[N];\n        for (int i = 0; i < N; i++) E[i] = new List<int>();\n    }\n\n    public void AddEdge(int a, int b)\n    {\n        E[a].Add(b);\n        E[b].Add(a);\n    }\n\n    public void Decompose()\n    {\n        for (int i = 0; i < N; i++)\n            if (order[i] == 0)\n                DFS(i, -1);\n        Bridges.Sort((a, b) => a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n    }\n\n    void DFS(int v, int prev)\n    {\n        order[v] = ++id;\n        roots.Push(v);\n        S.Push(v);\n        inS[v] = true;\n        foreach (int next in E[v])\n            if (order[next] == 0)\n                DFS(next, v);\n            else if (next != prev && inS[next])\n                while (order[roots.Peek()] > order[next]) roots.Pop();\n        if (roots.Peek() != v) return;\n        if (prev != -1) AddBridge(prev, v);\n        AddComponent(v);\n    }\n\n    void AddBridge(int a, int b)\n    {\n        BridgesSet.Add(ToKey(a, b));\n        Bridges.Add(new[] { Math.Min(a, b), Math.Max(a, b) });\n    }\n\n    void AddComponent(int root)\n    {\n        int compId = vertexes.Count;\n        var vs = new List<int>();\n        for (; ; )\n        {\n            int v = S.Pop();\n            inS[v] = false;\n            component[v] = compId;\n            vs.Add(v);\n            if (v == root) break;\n        }\n        vertexes.Add(vs.ToArray());\n        roots.Pop();\n    }\n\n\n    long ToKey(long a, long b) { return a < b ? a * N + b : b * N + a; }\n\n}\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { Dispose(); A = new string[0]; }\n    public static void Set(TextReader r) { Init(); reader = r; }\n    public static void Set(string file) { Init(); reader = new StreamReader(file); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    public static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    public static void Dispose() { reader.Dispose(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n\nfunction main(lines){\n\tif(lines.pop() != \"\"){\n\t\tlines.push();\n\t}\n\tlines = lines.map(function(line){\n\t\treturn line.split(\" \").map(function(e){\n\t\t\treturn Number(e);\n\t\t});\n\t});\n\tvar top_line = lines.shift();\n\tvar V = top_line[0];\n\tvar E = top_line[1];\n\tvar real_edge = [];\n\tvar virt_edge = [];\n\tvar mark = [];\n\tvar status = [];\n\tvar ord = [];\n\tvar lowlink = [];\n\tvar bridges = [];\n\tvar used_e = [];\n\tfor(var i = 0; i < V ; i++){\n\t\treal_edge[i] = [];\n\t\tmark[i] = false;\n\t\t//ord?????????\n\t\t//lowlink??????(dfs????????????????§????){0,}??¨(?????????){0,1}??§?????????ord???????°????\n\t\t//?????????????????????????????§???????°???????ord\n\t\tord[i] = 0;\n\t\tlowlink[i] = V;\n\t\tbridges[i] = [];\n\t\t//\n\t\tused_e[i] = [];\n\t\tfor(var j = 0; j < V ; j++){\n\t\t\tused_e[i][j]= false;\n\t\t}\n\t}\n\tlines.forEach(function(edge){\n\t\tvar a = edge[0];\n\t\tvar b = edge[1];\n\t\treal_edge[a].push(b);\n\t\treal_edge[b].push(a);\n\t});\n\tvar no = 0;\n\tvar prev = 0;\n\tfunction dfs(now_point){\n\t\t//now_point????????¨???????????????\n\t\t//now_ord????????¨???????????????\n\t\t//mark????¨???????????????????\n\t\tvar np = now_point;\n\t\tvar mk = mark;\n\t\tvar targets = real_edge[np];\n\t\tmk[np] = true;\n\t\tord[np] = no;\n\t\tlowlink[np] = no;\n\t\tno++;\n\t\ttargets.forEach(function(target){\n\t\t\tif(!mk[target]){\n\t\t\t\t//???????????£????????¨?????????\n\t\t\t\t//??¢?´¢?????????\n\t\t\t\t//log(np+\" -> \"+target);\n\t\t\t\t//???????°????\n\t\t\t\tused_e[np][target]=true;\n\t\t\t\tused_e[target][np]=true;\n\t\t\t\tdfs(target);\n\t\t\t\t//?????\\????????????lowlink?????????\n\t\t\t\t//???????????????????±????lowlink???????°???????lowlink????????¨??????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],lowlink[target]);\n\t\t\t}else if(!used_e[target][np]){\n\t\t\t\t//?????????\n\t\t\t\t//lowlink?????´??°\n\t\t\t\t//????°????????????????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],ord[target]);\n\t\t\t\t//log(np+\" => \"+target);\n\t\t\t}\n\t\t});\n\t}\n\tdfs(0);\n\t//log(ord);\n\t//log(lowlink);\n\tlines.forEach(function(edge){\n\t\tvar u = edge[0];\n\t\tvar v = edge[1];\n\t\tif(ord[u] > ord[v]){\n\t\t\tvar k = u;\n\t\t\tu = v;\n\t\t\tv = k;\n\t\t}\n\t\tif(ord[u] < lowlink[v]){\n\t\t\t//????????????\n\t\t\tvar min = Math.min(u,v);\n\t\t\tvar max = Math.max(u,v);\n\t\t\tbridges[min].push(max);\n\t\t}\n\t});\n\tbridges = bridges.map(function(e){\n\t\treturn e.sort();\n\t});\n\tfor(var s = 0 ; s < V ; s++){\n\t\tvar len = bridges[s].length;\n\t\tfor(var td = 0 ; td < len ;td++){\n\t\t\tvar t = bridges[s][td];\n\t\t\tlog(s+\" \"+t);\n\t\t}\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n\nfunction main(lines){\n\tif(lines.pop() != \"\"){\n\t\tlines.push();\n\t}\n\tlines = lines.map(function(line){\n\t\treturn line.split(\" \").map(function(e){\n\t\t\treturn Number(e);\n\t\t});\n\t});\n\tvar top_line = lines.shift();\n\tvar V = top_line[0];\n\tvar E = top_line[1];\n\tvar real_edge = [];\n\tvar virt_edge = [];\n\tvar mark = [];\n\tvar status = [];\n\tvar ord = [];\n\tvar lowlink = [];\n\tvar bridges = [];\n\tvar used_e = [];\n\tfor(var i = 0; i < V ; i++){\n\t\treal_edge[i] = [];\n\t\tmark[i] = false;\n\t\t//ord?????????\n\t\t//lowlink??????(dfs????????????????§????){0,}??¨(?????????){0,1}??§?????????ord???????°????\n\t\t//?????????????????????????????§???????°???????ord\n\t\tord[i] = 0;\n\t\tlowlink[i] = V;\n\t\tbridges[i] = [];\n\t\t//\n\t\tused_e[i] = [];\n\t\tfor(var j = 0; j < V ; j++){\n\t\t\tused_e[i][j]= false;\n\t\t}\n\t}\n\tlines.forEach(function(edge){\n\t\tvar a = edge[0];\n\t\tvar b = edge[1];\n\t\treal_edge[a].push(b);\n\t\treal_edge[b].push(a);\n\t});\n\tvar no = 0;\n\tvar prev = 0;\n\tfunction dfs(now_point){\n\t\t//now_point????????¨???????????????\n\t\t//now_ord????????¨???????????????\n\t\t//mark????¨???????????????????\n\t\tvar np = now_point;\n\t\tvar mk = mark;\n\t\tvar targets = real_edge[np];\n\t\tmk[np] = true;\n\t\tord[np] = no;\n\t\tlowlink[np] = no;\n\t\tno++;\n\t\ttargets.forEach(function(target){\n\t\t\tif(!mk[target]){\n\t\t\t\t//???????????£????????¨?????????\n\t\t\t\t//??¢?´¢?????????\n\t\t\t\t//log(np+\" -> \"+target);\n\t\t\t\t//???????°????\n\t\t\t\tused_e[np][target]=true;\n\t\t\t\tused_e[target][np]=true;\n\t\t\t\tdfs(target);\n\t\t\t\t//?????\\????????????lowlink?????????\n\t\t\t\t//???????????????????±????lowlink???????°???????lowlink????????¨??????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],lowlink[target]);\n\t\t\t}else if(!used_e[target][np]){\n\t\t\t\t//?????????\n\t\t\t\t//lowlink?????´??°\n\t\t\t\t//????°????????????????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],ord[target]);\n\t\t\t\t//log(np+\" => \"+target);\n\t\t\t}\n\t\t});\n\t}\n\tdfs(0);\n\t//log(ord);\n\t//log(lowlink);\n\tlines.forEach(function(edge){\n\t\tvar u = edge[0];\n\t\tvar v = edge[1];\n\t\tif(ord[u] > ord[v]){\n\t\t\tvar k = u;\n\t\t\tu = v;\n\t\t\tv = k;\n\t\t}\n\t\tif(ord[u] < lowlink[v]){\n\t\t\t//????????????\n\t\t\tvar min = Math.min(u,v);\n\t\t\tvar max = Math.max(u,v);\n\t\t\tbridges[min].push(max);\n\t\t}\n\t});\n\tbridges = bridges.map(function(e){\n\t\treturn e.sort(function(a,b){\n\t\t\treturn b<a;\n\t\t});\n\t});\n\tfor(var s = 0 ; s < V ; s++){\n\t\tvar len = bridges[s].length;\n\t\tfor(var td = 0 ; td < len ;td++){\n\t\t\tvar t = bridges[s][td];\n\t\t\tlog(s+\" \"+t);\n\t\t}\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n\nfunction main(lines){\n\tif(lines.pop() != \"\"){\n\t\tlines.push();\n\t}\n\tlines = lines.map(function(line){\n\t\treturn line.split(\" \").map(function(e){\n\t\t\treturn Number(e);\n\t\t});\n\t});\n\tvar top_line = lines.shift();\n\tvar V = top_line[0];\n\tvar E = top_line[1];\n\tvar real_edge = [];\n\tvar virt_edge = [];\n\tvar mark = [];\n\tvar status = [];\n\tvar ord = [];\n\tvar lowlink = [];\n\tvar bridges = [];\n\tfor(var i = 0; i < V ; i++){\n\t\treal_edge[i] = [];\n\t\tmark[i] = false;\n\t\t//ord?????????\n\t\t//lowlink??????(dfs????????????????§????){0,}??¨(?????????){0,1}??§?????????ord???????°????\n\t\t//?????????????????????????????§???????°???????ord\n\t\tord[i] = 0;\n\t\tlowlink[i] = V;\n\t\tbridges[i] = [];\n\t}\n\tlines.forEach(function(edge){\n\t\tvar a = edge[0];\n\t\tvar b = edge[1];\n\t\treal_edge[a].push(b);\n\t\treal_edge[b].push(a);\n\t});\n\tvar no = 0;\n\tvar prev = 0;\n\tfunction dfs(now_point,prev){\n\t\t//now_point????????¨???????????????\n\t\t//now_ord????????¨???????????????\n\t\t//mark????¨???????????????????\n\t\tvar np = now_point;\n\t\tvar mk = mark;\n\t\tvar targets = real_edge[np];\n\t\tmk[np] = true;\n\t\tord[np] = no;\n\t\tlowlink[np] = no;\n\t\tno++;\n\t\ttargets.forEach(function(target){\n\t\t\tif(target == prev){\n\t\t\t\t//??´???????????????????????????????????§\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(mk[target]){\n\t\t\t\t//?????????\n\t\t\t\t//lowlink?????´??°\n\t\t\t\t//????°????????????????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],target);\n\t\t\t}else{\n\t\t\t\t//???????????£????????¨?????????\n\t\t\t\t//??¢?´¢?????????\n\t\t\t\tdfs(target,np);\n\t\t\t\t//?????\\????????????lowlink?????????\n\t\t\t\t//???????????????????±????lowlink???????°???????lowlink????????¨??????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],lowlink[target]);\n\t\t\t}\n\t\t});\n\t}\n\tdfs(0,V);\n\tlines.forEach(function(edge){\n\t\tvar u = edge[0];\n\t\tvar v = edge[1];\n\t\tif(ord[u] > ord[v]){\n\t\t\tvar k = u;\n\t\t\tu = v;\n\t\t\tv = k;\n\t\t}\n\t\tif(ord[u] < lowlink[v]){\n\t\t\t//????????????\n\t\t\tvar min = Math.min(u,v);\n\t\t\tvar max = Math.max(u,v);\n\t\t\tbridges[min].push(max);\n\t\t}\n\t});\n\tbridges = bridges.map(function(e){\n\t\treturn e.sort();\n\t});\n\tfor(var s = 0 ; s < V ; s++){\n\t\tvar len = bridges[s].length;\n\t\tfor(var td = 0 ; td < len ;td++){\n\t\t\tvar t = bridges[s][td];\n\t\t\tlog(s+\" \"+t);\n\t\t}\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "module.exports=function(r){var t={};function n(e){if(t[e])return t[e].exports;var o=t[e]={i:e,l:!1,exports:{}};return r[e].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=r,n.c=t,n.d=function(r,t,e){n.o(r,t)||Object.defineProperty(r,t,{enumerable:!0,get:e})},n.r=function(r){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(r,\"__esModule\",{value:!0})},n.t=function(r,t){if(1&t&&(r=n(r)),8&t)return r;if(4&t&&\"object\"==typeof r&&r&&r.__esModule)return r;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,\"default\",{enumerable:!0,value:r}),2&t&&\"string\"!=typeof r)for(var o in r)n.d(e,o,function(t){return r[t]}.bind(null,o));return e},n.n=function(r){var t=r&&r.__esModule?function(){return r.default}:function(){return r};return n.d(t,\"a\",t),t},n.o=function(r,t){return Object.prototype.hasOwnProperty.call(r,t)},n.p=\"\",n(n.s=0)}([function(r,t,n){\"use strict\";var e=n(1);n(2)(e.readFileSync(\"/dev/stdin\",\"utf8\"))},function(r,t){r.exports=require(\"fs\")},function(r,t,n){\"use strict\";var e=n(3),o=n(5);r.exports=function(r){var t=new e(r);o(t)}},function(r,t,n){\"use strict\";var e=n(4);r.exports=class{constructor(r){var t=r.trim().split(/\\s+/g);this.inp=new e(t)}inr(){return this.inp.deq()}in(){return parseInt(this.inp.deq(),10)}fin(){this.inp.clear()}}},function(r,t,n){\"use strict\";r.exports=class{constructor(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.size=r.length,this.items=r,this.ind=0}enq(r){this.size+=1,this.items.push(r)}deq(){var r=this.items[this.ind];return this.size-=1,this.ind+=1,r}clear(){this.items=[],this.size=0,this.ind=0}}},function(r,t,n){\"use strict\";var e=n(6).FindBridge;r.exports=function(r){for(var t=r.in(),n=r.in(),o=new Array(t),i=0;i<t;i++)o[i]=[];for(var f=0;f<n;f++){var u=r.in(),a=r.in();o[u].push(a),o[a].push(u)}for(var s=e(o),l=0;l<s.length;l++)if(s[l].from>s[l].to){var v=s[l].from;s[l].from=s[l].to,s[l].to=v}s.sort(function(r,t){return r.from>t.from?1:r.from<t.from?-1:r.to>t.to?1:r.to<t.to?-1:0});for(var c=0;c<s.length;c++)console.log(`${s[c].from} ${s[c].to}`)}},function(r,t,n){\"use strict\";r.exports={FindAP:function(r){for(var t=r.length,n=new Array(t).fill(-1),e=new Array(t).fill(-1),o=new Array(t).fill(0),i=[{v:0,p:-1}],f=[],u=0;i.length>0;){var a=i.pop();-1==n[a.v]?(-1!=a.p&&f.push({from:a.p,to:a.v,isF:!0}),n[a.v]=u++,e[a.v]=n[a.v]):f.push({from:a.v,to:a.p,isF:!1});for(var s=r[a.v].length,l=0;l<s;l++){var v=r[a.v][l];-1==n[v]&&i.push({v:v,p:a.v})}}for(var c=0;f.length>0;){var p=f.pop();p.isF?(0==p.from&&c++,e[p.from]=Math.min(e[p.from],e[p.to]),0!=p.from&&n[p.from]<=e[p.to]&&(o[p.from]=1)):e[p.from]=Math.min(e[p.from],n[p.to])}return c>1&&(o[0]=1),o},FindAP_R:function(r){var t=r.length,n=new Array(t).fill(-1),e=new Array(t).fill(-1),o=new Array(t).fill(0);return function t(i,f,u){n[i]=u++,e[i]=n[i];var a=0,s=!0,l=!1,v=void 0;try{for(var c,p=r[i][Symbol.iterator]();!(s=(c=p.next()).done);s=!0){var h=c.value;-1==n[h]?(a++,e[i]=Math.min(e[i],t(h,i,u)),0!=i&&n[i]<=e[h]&&(o[i]=1)):f!=h&&(e[i]=Math.min(e[i],n[h]))}}catch(r){l=!0,v=r}finally{try{s||null==p.return||p.return()}finally{if(l)throw v}}return 0==i&&a>1&&(o[0]=1),e[i]}(0,-1,0),o},FindBridge:function(r){for(var t=r.length,n=new Array(t).fill(-1),e=new Array(t).fill(-1),o=[],i=[{v:0,p:-1}],f=[],u=0;i.length>0;){var a=i.pop();-1==n[a.v]?(-1!=a.p&&f.push({from:a.p,to:a.v,isF:!0}),n[a.v]=u++,e[a.v]=n[a.v]):f.push({from:a.v,to:a.p,isF:!1});for(var s=r[a.v].length,l=0;l<s;l++){var v=r[a.v][l];-1==n[v]&&i.push({v:v,p:a.v})}}for(;f.length>0;){var c=f.pop();c.isF?(e[c.from]=Math.min(e[c.from],e[c.to]),n[c.from]<e[c.to]&&o.push({from:c.from,to:c.to})):e[c.from]=Math.min(e[c.from],n[c.to])}return o},FindBridge_R:function(r){var t=r.length,n=new Array(t).fill(-1),e=new Array(t).fill(-1),o=[];return function t(i,f,u){n[i]=u++,e[i]=n[i];var a=!0,s=!1,l=void 0;try{for(var v,c=r[i][Symbol.iterator]();!(a=(v=c.next()).done);a=!0){var p=v.value;if(-1==n[p])e[i]=Math.min(e[i],t(p,i,u)),e[p]==n[p]&&o.push({from:i,to:p});else{if(f==p)continue;e[i]=Math.min(e[i],e[p])}}}catch(r){s=!0,l=r}finally{try{a||null==c.return||c.return()}finally{if(s)throw l}}return e[i]}(0,0,0),o}}}]);\n"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n\nfunction main(lines){\n\tif(lines.pop() != \"\"){\n\t\tlines.push();\n\t}\n\tlines = lines.map(function(line){\n\t\treturn line.split(\" \").map(function(e){\n\t\t\treturn Number(e);\n\t\t});\n\t});\n\tvar top_line = lines.shift();\n\tvar V = top_line[0];\n\tvar E = top_line[1];\n\tvar real_edge = [];\n\tvar virt_edge = [];\n\tvar mark = [];\n\tvar status = [];\n\tvar ord = [];\n\tvar lowlink = [];\n\tvar bridges = [];\n\tvar used_e = [];\n\tfor(var i = 0; i < V ; i++){\n\t\treal_edge[i] = [];\n\t\tmark[i] = false;\n\t\t//ord?????????\n\t\t//lowlink??????(dfs????????????????§????){0,}??¨(?????????){0,1}??§?????????ord???????°????\n\t\t//?????????????????????????????§???????°???????ord\n\t\tord[i] = 0;\n\t\tlowlink[i] = V;\n\t\tbridges[i] = [];\n\t\t//\n\t\tused_e[i] = [];\n\t\tfor(var j = 0; j < V ; j++){\n\t\t\tused_e[i][j]= false;\n\t\t}\n\t}\n\tlines.forEach(function(edge){\n\t\tvar a = edge[0];\n\t\tvar b = edge[1];\n\t\treal_edge[a].push(b);\n\t\treal_edge[b].push(a);\n\t});\n\tvar no = 0;\n\tvar prev = 0;\n\tfunction dfs(now_point){\n\t\t//now_point????????¨???????????????\n\t\t//now_ord????????¨???????????????\n\t\t//mark????¨???????????????????\n\t\tvar np = now_point;\n\t\tvar mk = mark;\n\t\tvar targets = real_edge[np];\n\t\tmk[np] = true;\n\t\tord[np] = no;\n\t\tlowlink[np] = no;\n\t\tno++;\n\t\ttargets.forEach(function(target){\n\t\t\tif(!mk[target]){\n\t\t\t\t//???????????£????????¨?????????\n\t\t\t\t//??¢?´¢?????????\n\t\t\t\t//log(np+\" -> \"+target);\n\t\t\t\t//???????°????\n\t\t\t\tused_e[np][target]=true;\n\t\t\t\tused_e[target][np]=true;\n\t\t\t\ttry{\n\t\t\t\t\tdfs(target);\n\t\t\t\t}catch(e){\n\t\t\t\t\tdfs(target);\n\t\t\t\t}\n\t\t\t\t//?????\\????????????lowlink?????????\n\t\t\t\t//???????????????????±????lowlink???????°???????lowlink????????¨??????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],lowlink[target]);\n\t\t\t}else if(!used_e[target][np]){\n\t\t\t\t//?????????\n\t\t\t\t//lowlink?????´??°\n\t\t\t\t//????°????????????????\n\t\t\t\tlowlink[np] = Math.min(lowlink[np],ord[target]);\n\t\t\t\t//log(np+\" => \"+target);\n\t\t\t}\n\t\t});\n\t}\n\tdfs(0);\n\t//log(ord);\n\t//log(lowlink);\n\tlines.forEach(function(edge){\n\t\tvar u = edge[0];\n\t\tvar v = edge[1];\n\t\tif(ord[u] > ord[v]){\n\t\t\tvar k = u;\n\t\t\tu = v;\n\t\t\tv = k;\n\t\t}\n\t\tif(ord[u] < lowlink[v]){\n\t\t\t//????????????\n\t\t\tvar min = Math.min(u,v);\n\t\t\tvar max = Math.max(u,v);\n\t\t\tbridges[min].push(max);\n\t\t}\n\t});\n\tbridges = bridges.map(function(e){\n\t\treturn e.sort(function(a,b){\n\t\t\treturn b<a;\n\t\t});\n\t});\n\tfor(var s = 0 ; s < V ; s++){\n\t\tvar len = bridges[s].length;\n\t\tfor(var td = 0 ; td < len ;td++){\n\t\t\tvar t = bridges[s][td];\n\t\t\tlog(s+\" \"+t);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "\nclass Node\n  attr_accessor :order, :parent, :child, :edges, :lowest, :visited, :isArticulation\n  def initialize\n    @order = nil\n    @parent = -1\n    @child = []\n    @edges = []\n    @lowest = nil\n    @visited = false\n    @isArticulation = false\n  end\nend\n\ndef dfs(root, g)\n  t = 1\n  stack = []\n  g[root].order = g[root].lowest = t\n  g[root].visited = true\n\n  stack << root\n  while stack.size > 0\n    u = stack[-1]\n    flag = true\n    g[u].edges.each{|x|\n      if g[x].visited == false\n        t += 1\n        g[x].order = g[x].lowest = t\n        g[x].visited = true\n        g[x].parent = u\n        g[u].child << x\n        flag = false\n        g[u].lowest = [g[u].lowest, g[x].lowest].min\n        stack << x\n        break\n      elsif x != g[u].parent\n        g[u].lowest = [g[u].lowest, g[x].order].min\n      end\n    }\n    if flag\n      stack.pop\n      g[u].child.each{|v|\n        g[u].lowest = [g[u].lowest, g[v].lowest].min\n        g[u].isArticulation = true if (u != root && g[u].order <= g[v].lowest)\n        if g[u].order < g[v].lowest\n          if u < v\n            $bridge << [u, v]\n          else\n            $bridge << [v, u]\n          end\n        end\n      }\n    end\n  end\n  g[root].isArticulation = true if g[root].child.size > 1\nend\n\n$bridge = []\n\n$t = 1\nv, e = gets.split.map(&:to_i)\ngraph = Array.new(v){Node.new}\ne.times{\n  s, t = gets.split.map(&:to_i)\n  graph[s].edges << t\n  graph[t].edges << s\n}\n\ndfs(0, graph)\n\n# v.times{|i|\n#   puts \"#{graph[i].order} #{graph[i].parent} #{graph[i].lowest} #{graph[i].child}\"\n# }\n\n# v.times{|i|\n#   if graph[i].isArticulation\n#     puts i\n#   end\n# }\n\n$bridge.sort.each{|a, b|\n  puts \"#{a} #{b}\"\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\n// https://ei1333.github.io/luzhiled/snippets/graph/lowlink.html\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc newGraph(nNodes int) *Graph {\n\tg := Graph{}\n\tg.nodes = make([]*GraphNode, nNodes)\n\tfor iNode := 0; iNode < len(g.nodes); iNode++ {\n\t\tg.nodes[iNode] = &GraphNode{}\n\t\tg.nodes[iNode].key = GraphNodeKey(iNode)\n\t}\n\treturn &g\n}\n\nvar infty = 1000000000\n\ntype GraphNodeKey int\n\n// GraphNode is a node for undirected graph\ntype GraphNode struct {\n\tkey       GraphNodeKey\n\tadjacents []*GraphNode\n\tvisited   bool\n\td, f      int\n\tparent    *GraphNode\n\tcc        int\n\n\tlow             int // 22-2 c.\n\tis_articulation bool\n}\n\nfunc (g *Graph) setAdjacent(l, r GraphNodeKey) {\n\tg.nodes[l].adjacents = append(g.nodes[l].adjacents, g.nodes[r])\n}\n\n// Graph is a undirected graph\ntype Graph struct {\n\tnodes []*GraphNode\n}\n\nfunc (g *Graph) initialize() {\n\tfor iNode := 0; iNode < len(g.nodes); iNode++ {\n\t\tg.nodes[iNode].visited = false\n\t\tg.nodes[iNode].d = infty\n\t\tg.nodes[iNode].f = infty\n\t\tg.nodes[iNode].parent = nil\n\t\tg.nodes[iNode].cc = -1 // 22.3-12\n\t}\n}\n\nvar time = 0\nvar visitedNodes = []*GraphNode{}\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc dfsVisit(g *Graph, u *GraphNode, cc int) {\n\ttime++\n\tu.d = time\n\tu.cc = cc\n\n\tu.visited = true\n\tfor _, v := range u.adjacents {\n\t\tif !v.visited {\n\t\t\tv.parent = u\n\t\t\tdfsVisit(g, v, cc)\n\t\t}\n\t}\n\ttime++\n\tu.f = time\n\tvisitedNodes = append(visitedNodes, u)\n}\n\nfunc runDFS(g *Graph) {\n\tg.initialize()\n\ttime = 0\n\tcc := 0\n\n\tfor _, u := range g.nodes {\n\t\tif !u.visited {\n\t\t\tdfsVisit(g, u, cc)\n\t\t\tcc++\n\t\t}\n\t}\n}\n\nvar bridges = [][]GraphNodeKey{}\n\nfunc fillLowLink(graph *Graph) {\n\tfor _, node := range visitedNodes {\n\t\tnode.low = node.d\n\t\tnode.is_articulation = false\n\n\t\tfor _, adjacent := range node.adjacents {\n\t\t\tif adjacent.parent == node { // G_\\pi上で node -> adjacent\n\t\t\t\tnode.low = min(node.low, adjacent.low)\n\t\t\t\tnode.is_articulation = node.is_articulation || (node.parent != nil && adjacent.low >= node.d)\n\t\t\t\tif adjacent.low > node.d {\n\t\t\t\t\tk1, k2 := node.key, adjacent.key\n\t\t\t\t\tif k1 > k2 {\n\t\t\t\t\t\tk1, k2 = k2, k1\n\t\t\t\t\t}\n\t\t\t\t\tbridges = append(bridges, []GraphNodeKey{k1, k2})\n\t\t\t\t}\n\t\t\t} else if adjacent != node.parent { // G上では繋がっているが、G_\\pi上では繋がっていない\n\t\t\t\tnode.low = min(node.low, adjacent.d)\n\t\t\t}\n\t\t}\n\n\t\tnChildren := 0\n\t\tfor _, adjacent := range node.adjacents {\n\t\t\tif adjacent.parent == node {\n\t\t\t\tnChildren++\n\t\t\t}\n\t\t}\n\t\tnode.is_articulation = node.is_articulation || (node.parent == nil && nChildren >= 2)\n\t}\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnNodes := nextInt()\n\tnEdges := nextInt()\n\tgraph := newGraph(nNodes)\n\tfor iEdge := 0; iEdge < nEdges; iEdge++ {\n\t\tl := GraphNodeKey(nextInt())\n\t\tr := GraphNodeKey(nextInt())\n\t\tgraph.setAdjacent(l, r)\n\t\tgraph.setAdjacent(r, l)\n\t}\n\n\trunDFS(graph)\n\n\tfillLowLink(graph)\n\n\tsort.Slice(bridges, func(i, j int) bool {\n\t\tif bridges[i][0] == bridges[j][0] {\n\t\t\treturn bridges[i][1] < bridges[j][1]\n\t\t}\n\t\treturn bridges[i][0] < bridges[j][0]\n\t})\n\tfor _, bridge := range bridges {\n\t\tfmt.Println(bridge[0], bridge[1])\n\t}\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass LowLinks {\n    private $edges, $root, $ord, $low, $cnt, $bridges, $articulations, $par;\n\n    function __construct($edges, $v, $root=0) {\n        $this->edges = $edges;\n        $this->root = $root;\n        $this->ord = array_fill(0, $v, null);\n        $this->low = array_fill(0, $v, null);\n        $this->cnt = 0;\n        $this->bridges = [];\n        $this->articulations = [];\n        $this->par = array_fill(0, $v, null);\n    }\n\n    function getArticulations() {\n        return $this->articulations;\n    }\n\n    function getBridges() {\n        return $this->bridges;\n    }\n\n    function build() {\n        $this->search($this->root);\n    }\n\n    function search($node) {\n        $this->ord[$node] = $this->cnt;\n        $this->low[$node] = $this->cnt;\n        $this->cnt++;\n        $dim = 0;\n        foreach($this->edges[$node] as $to) {\n            if ($to === $this->par[$node]) continue;\n            if ($this->ord[$to] === null) {\n                $this->par[$to] = $node;\n                $this->search($to);\n                $dim++;\n                $this->low[$node] = min($this->low[$node], $this->low[$to]);\n                if ($node != $this->root and $this->ord[$node] <= $this->low[$to]) {\n                    $this->articulations[] = $node;\n                }\n            } else {\n                $this->low[$node] = min($this->low[$node], $this->ord[$to]);\n            }\n\n            if ($node == $this->root and $dim > 1) {\n                $this->articulations[] = $node;\n            }\n\n            if ($this->ord[$node] < $this->low[$to]) {\n                $this->bridges[] = [$node, $to];\n            }\n        }\n    }\n}\n\nfunction compBridge($bridge1, $bridge2) {\n    $u1 = min($bridge1);\n    $v1 = max($bridge1);\n    $u2 = min($bridge2);\n    $v2 = max($bridge2);\n    if ($u1 < $u2) {\n        return -1;\n    } elseif ($u1 > $u2) {\n        return 1;\n    } else {\n        if ($v1 < $v2) {\n            return -1;\n        } elseif ($v1 > $v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n\nlist($v, $e) = explode(\" \", trim(fgets(STDIN)));\n$edges = array_fill(0, $v, []);\nfor ($i = 0; $i < $e; $i++) {\n    list($s, $t) = explode(\" \", trim(fgets(STDIN)));\n    $edges[(int)$s][] = (int)$t;\n    $edges[(int)$t][] = (int)$s;\n}\n\n$lowlinks = new LowLinks($edges, $v, 0);\n$lowlinks->build();\n\n/*** print articulations\n$articulations = array_unique($lowlinks->getArticulations());\nsort($articulations);\nforeach($articulations as $art) {\n    echo $art . \"\\n\";\n}\n*/\n\n$bridges = $lowlinks->getBridges();\nusort($bridges, \"compBridge\");\nforeach($bridges as $bridge) {\n    echo min($bridge) . \" \" . max($bridge) . \"\\n\";\n}\n\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    Tuple!(int, int)[] findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        Tuple!(int, int)[] bridges;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges ~= Tuple!(int, int)(l, g);\n                }\n            }\n        }\n        dfs(0, -1);\n        return bridges;\n    }\n}\n\nvoid main() {\n    int V, E; scanf(\"%d %d\\n\", &V, &E);\n    auto graph = new Graph(V);\n    foreach (i; 0 .. E) {\n        int s, t; scanf(\"%d %d\\n\", &s, &t);\n        graph.addEdge(s, t);\n    }\n    auto ans = graph.findBridges();\n    ans.sort;\n    foreach (a; ans) {\n        writefln(\"%d %d\", a[0], a[1]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime, std.typecons;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\t//mc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tmc++;\n\t\t\t\tdfs2(v, mc-1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\t//int c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tmc++;\n\t\t\t\tdfs2(i, mc-1);\n\t\t\t\t//c = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tif (a > b) swap(a, b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tP[] res;\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\tres ~= p;\n\t\t}\n\t}\n\tres.sort!((a, b) => a[0] != b[0] ? a[0] < b[0] : a[1] < b[1]);\n\tforeach (p; res) {\n\t\twriteln(p[0], \" \", p[1]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime, std.typecons;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\t//mc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tmc++;\n\t\t\t\tdfs2(v, mc-1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\t//int c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tmc++;\n\t\t\t\tdfs2(i, mc-1);\n\t\t\t\t//c = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tif (a > b) swap(a, b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tP[] res;\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\tres ~= p;\n\t\t}\n\t}\n\tforeach (p; res.sort) {\n\t\twriteln(p[0], \" \", p[1]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto G = new UndirectedGraph(N);\n    foreach (_; 0..M) {\n        s = readln.split.map!(to!int);\n        G.add_edge(s[0], s[1]);\n    }\n\n    auto B = new BridgeBlockTree(G);\n    auto bridges = B.bridges.dup;\n\n    foreach (i; 0..bridges.length) {\n        bridges[i] = tuple(min(bridges[i][0], bridges[i][1]),\n                           max(bridges[i][0], bridges[i][1]));\n    }\n    bridges.sort();\n\n    foreach (b; bridges) {\n        writeln(b[0], \" \", b[1]);\n    }\n}\n\nclass UndirectedGraph {\n    int N;\n    int[][] adj;\n\n    this (int N) {\n        this.N = N;\n        adj = new int[][](N);\n    }\n\n    void add_edge(int u, int v) {\n        adj[u] ~= v;\n        adj[v] ~= u;\n    }\n}\n\nclass BridgeBlockTree : UndirectedGraph { // 二重辺連結成分分解 (橋で分解したあとの木)\n    int[] index;\n    int[][] block;\n    Tuple!(int, int)[] bridges;\n\n    this (UndirectedGraph g) {\n        int n = 0;\n        int cnt = 0;\n\n        bridges = detect_bridges(g);\n        auto is_bridge = new bool[int][](g.N);\n        foreach (b; bridges) {\n            is_bridge[b[0]][b[1]] = true;\n            is_bridge[b[1]][b[0]] = true;\n        }\n\n        index = new int[](g.N);\n        auto used = new bool[](g.N);\n\n        void dfs(int n) {\n            index[n] = block.length.to!int - 1;\n            block.back ~= n;\n            used[n] = true;\n            foreach (m; g.adj[n]) {\n                if (used[m] || m in is_bridge[n]) continue;\n                dfs(m);\n            }\n        }\n\n        foreach (u; 0..g.N) {\n            if (used[u]) continue;\n            block.length += 1;\n            dfs(u);\n        }\n\n        super(block.length.to!int);\n\n        foreach (u; 0..g.N) {\n            foreach (v; g.adj[u]) {\n                if (u < v && index[u] != index[v]) {\n                    adj[index[u]] ~= index[v];\n                    adj[index[v]] ~= index[u];\n                }\n            }\n        }\n    }\n\n    Tuple!(int, int)[] detect_bridges(UndirectedGraph g) {\n        Tuple!(int, int)[] bridges;\n        int cnt = 0;\n        auto ord = new int[](g.N);\n        auto low = new int[](g.N);\n        fill(ord, -1);\n        fill(low, -1);\n\n        void dfs(int n, int p) {\n            ord[n] = low[n] = cnt++;\n            foreach (m; g.adj[n]) {\n                if (m == p) continue;\n                if (ord[m] == -1) dfs(m, n);\n                low[n] = min(low[n], low[m]);\n                if (ord[n] < low[m]) bridges ~= tuple(n, m);\n            }\n        }\n\n        dfs(0, -1);\n        return bridges;\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\twriteln(p[0], \" \", p[1]);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime, std.typecons;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\twriteln(p[0], \" \", p[1]);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime, std.typecons;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tif (a > b) swap(a, b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tP[] res;\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\tres ~= p;\n\t\t}\n\t}\n\tforeach (p; res.sort) {\n\t\twriteln(p[0], \" \", p[1]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias P = Tuple!(int, int);\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\twriteln(p[0], \" \", p[1]);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\tmc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tdfs2(v, d+1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\tint c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tdfs2(i, c);\n\t\t\t\tc = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nalias P = Tuple!(int, int);\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\twriteln(p[0], \" \", p[1]);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.getopt, std.random, std.range, std.string, std.conv;\nimport std.algorithm, std.container, std.datetime, std.typecons;\n\nclass LowLink {\n\tint n;\n\tint[][] g;\n\tint[] ord, low, root, cmp, used;\n\tthis(int nn) {\n\t\tn = nn;\n\t\tg.length = ord.length = low.length = used.length = n;\n\t\tcmp.length = root.length = n;\n\t}\n\n\tvoid addEdge(int x, int y) {\n\t\tg[x] ~= y;\n\t\tg[y] ~= x;\n\t}\n\n\tint k;\n\tvoid dfs(int u, int b) {\n\t\tused[u] = 1;\n\t\tlow[u] = ord[u] = k;\n\t\tk++;\n\t\tforeach (v; g[u]) {\n\t\t\tif (v == b) continue;\n\t\t\tif (!used[v]) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tlow[u] = min(low[u], low[v]);\n\t\t\t} else {\n\t\t\t\tlow[u] = min(low[u], ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint mc;\n\tvoid dfs2(int u, int d) {\n\t\tused[u] = 2;\n\t\tcmp[u] = d;\n\t\t//mc = max(mc, d);\n\t\tforeach (v; g[u]) {\n\t\t\tif (used[v] == 2) continue;\n\t\t\tif (ord[u] < low[v]) {\n\t\t\t\tmc++;\n\t\t\t\tdfs2(v, mc-1);\n\t\t\t} else {\n\t\t\t\tdfs2(v, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec() {\n\t\tk = mc = 0;\n\t\t//int c = 0;\n\t\tforeach (i; 0..n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tmc++;\n\t\t\t\tdfs2(i, mc-1);\n\t\t\t\t//c = mc+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint v, e;\n\treadf(\"%d %d\\n\", &v, &e);\n\tauto ll = new LowLink(v);\n\talias Tuple!(int, int) P;\n\tP[] g;\n\tforeach (i; 0..e) {\n\t\tint a, b;\n\t\treadf(\"%d %d\\n\", &a, &b);\n\t\tif (a > b) swap(a, b);\n\t\tll.addEdge(a, b);\n\t\tg ~= P(a, b);\n\t}\n\tll.exec();\n\tP[] res;\n\tforeach (p; g) {\n\t\tif (ll.cmp[p[0]] != ll.cmp[p[1]]) {\n\t\t\tres ~= p;\n\t\t}\n\t}\n\tforeach (p; res.sort) {\n\t\twriteln(p[0], \" \", p[1]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    Tuple!(int, int)[] findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        Tuple!(int, int)[] bridges;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) bridges ~= Tuple!(int, int)(v, next);\n            }\n        }\n        dfs(0, -1);\n        return bridges;\n    }\n}\n\nvoid main() {\n    int V, E; scanf(\"%d %d\\n\", &V, &E);\n    auto graph = new Graph(V);\n    foreach (i; 0 .. E) {\n        int s, t; scanf(\"%d %d\\n\", &s, &t);\n        graph.addEdge(s, t);\n    }\n    auto ans = graph.findBridges();\n    ans.sort;\n    foreach (a; ans) {\n        writefln(\"%d %d\", a[0], a[1]);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# N,M = map(int,sys.stdin.readline().split())\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n# s = sys.stdin.readline().rstrip()\n# N = int(sys.stdin.readline())\n# INF = float(\"inf\")\n\nimport sys,collections\nsys.setrecursionlimit(100000)\n\nINF = float(\"inf\")\n\nV,E = map(int,sys.stdin.readline().split())\nst = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(E)) # multi line with multi param\n\nG = [[] for _ in range(V)]\n\nfor s,t in st:\n    G[s].append(t)\n    G[t].append(s) #not directed\n\nvisited = set()\nprenum = [0]*V\nparent = [0]*V\nlowest = [0]*V\ntimer = 0\n\ndef dfs(current,prev):\n    global timer\n    parent[current]=prev\n    prenum[current]=lowest[current]=timer\n    timer += 1\n    visited.add(current)\n    for nex in G[current]:\n        if not nex in visited:\n            dfs(nex,current)\n            lowest[current]=min(lowest[current],lowest[nex])\n        elif nex != prev:\n            lowest[current]=min(lowest[current],prenum[nex])\ndfs(0,-1)\nret = []\n\nfor i in range(1,V):\n    p = parent[i]\n    if prenum[p] < lowest[i]:\n        if p < i:\n            ret.append([p,i])\n        else:\n            ret.append([i,p])\nret = sorted(list(ret))\n\nfor s,t in ret:\n    print(s,t)\n\n"
  },
  {
    "language": "Python",
    "code": "import operator\ndef connection(G):\n    how_many_point=len(G[0])\n    tip=[0]\n\n    G_flag=[0 for i in range(how_many_point)]\n    G_flag[0]=1\n\n    while len(tip)>0:\n        tip_cash=[]\n        for i in tip:\n            for j in range(how_many_point):\n                if G[i][j]==1 and G_flag[j]==0:\n                    tip_cash.append(j)\n                    G_flag[j]=1\n        tip=list(set(tip_cash))\n\n    if G_flag==[1 for i in range(how_many_point)]:\n        return True\n    else:\n        return False\n\n\n\n\nV,E=[int(i) for i in input().split(\" \")]\nG_original=[[0 for i in range(V)] for j in range(V)]\ns=[]\nt=[]\nfor i in range(E):\n    si,ti=[int(j) for j in input().split(\" \")]\n    s.append(si)\n    t.append(ti)\n    G_original[si][ti]=1\n    G_original[ti][si]=1\n\n\nanswer=[]\nclass Point:\n    def __init__(self,s,t):\n        self.s=s\n        self.t=t\n\n\nfor i in range(E):\n    G=G_original.copy()\n    G[s[i]][t[i]]=0\n    G[t[i]][s[i]]=0\n    if not(connection(G)):\n        if s[i]<=t[i]:\n            answer.append(Point(s[i],t[i]))\n        else:\n            answer.append(Point(t[i],s[i]))\n    G[s[i]][t[i]]=1\n    G[t[i]][s[i]]=1\n\n\n\nanswer.sort(key=operator.attrgetter(\"s\"))\nfor i in answer:\n    print(\"%d %d\"%(i.s,i.t))\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\n\nsys.setrecursionlimit(10**7)\nclass LowLinks:\n    def __init__(self, edges, edges_num:int):\n        \"\"\"edges[u]: all vertexes connected with vertex 'u'\n        edges_num: number of edges of graph\n        the root of DFS-tree is vertex 0\n        \"\"\"\n        self.edges = edges\n        self.V = len(edges)\n        self.order = [-1]*V\n        self.low = [float('inf')]*V\n        self.bridges = []\n        # if degreee(root) > 1 and graph is tree: root is articulation\n        self.articulations = []\n        if len(edges[0]) > 1 and edges_num == self.V-1:\n            self.articulations.append(0)\n        self.k = 0\n\n    def build(self):\n        self.dfs(0, 0)\n\n    def get_bridges(self)->tuple:\n        return self.bridges\n\n    def get_articulations(self)->tuple:\n        return self.articulations\n\n    def dfs(self, v:int, prev:int):\n        self.order[v] = self.k\n        self.low[v] = self.k\n        self.k += 1\n        is_articulation = False\n        for to in self.edges[v]:\n            if self.order[to] < 0: # not visited\n                self.dfs(to, v)\n                self.low[v] = min(self.low[v], self.low[to])\n                if self.order[v] < self.low[to]:\n                    self.bridges.append((v, to) if v < to else (to, v))\n                is_articulation |= self.order[v] <= self.low[to]\n            elif to != prev: # back edge\n                self.low[v] = min(self.low[v], self.order[to])\n        if v>0 and is_articulation:\n            self.articulations.append(v)\n\nif __name__ == \"__main__\":\n    V,E = map(int, readline().split())\n    edges = [[] for _ in range(V)]\n    for _ in range(E):\n        s,t = map(int, readline().split())\n        edges[s].append(t)\n        edges[t].append(s)\n    lowlinks = LowLinks(edges, E)\n    lowlinks.build()\n    bridges = lowlinks.get_bridges()\n    bridges.sort()\n    if bridges:\n        for s,t in bridges:\n            print(s, t)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nsys.setrecursionlimit(1000000)\n\n\ndef dfs(current, prev):\n    global time\n    # node currentを訪問した直後の処理\n    ord[current] = time\n    low[current] = time\n    time += 1\n    color[current] = BLACK\n\n    for next in G[current]:\n        if color[next] == WHITE:\n            # node currentからnode nextへ訪問する直前の処理\n            parent[next] = current\n            dfs(next, current)\n\n            # node nextの探索が終了した直後の処理\n            low[current] = min(low[current], low[next])\n        elif next != prev:\n            # edge current --> next がback-edgeの場合の処理\n            low[current] = min(low[current], ord[next])\n\n\ndef bridge():\n    global time\n    time = 1\n    dfs(0, -1)  # 0をrootとしてlowの計算\n    for u, v in edges:\n        if ord[u] < low[v] or ord[v] < low[u]:\n            br.add((u, v))\n\n\nG = {}\nedges = set([])\nbr = set([])\nv, n = map(int, input().split())\nfor i in range(0, v):\n    G[i] = []\nfor i in range(n):\n    s, t = map(int, input().split())\n    G[s].append(t)\n    G[t].append(s)\n    edges.add((s, t))\nWHITE = 0\nBLACK = 2\n\ncolor = [WHITE] * (v)\nparent = [0] * (v)\nord = [0] * (v)\nlow = [0] * (v)\nparent = [0] * (v)\nbridge()\nif br:\n    for ans in sorted(br):\n        print(*ans, sep=' ')\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs_Tarjan(current, visited, parent, low, disc):\n    global timer\n    children = 0\n    visited[current] = True\n    disc[current] = timer\n    low[current] = timer\n    timer += 1\n\n    for adj in adj_table[current]:\n        if not visited[adj]:\n            parent[adj] = current\n            children += 1\n            dfs_Tarjan(adj, visited, parent, low, disc)\n            low[current] = min(low[current], low[adj])\n            if low[adj] > disc[current]:\n                ans.append(sorted([current, adj]))\n        elif adj != parent[current]:\n            low[current] = min(low[current], disc[adj])\n\n    return None\n\n\ndef dfs_init():\n    visited = [False] * v_num\n    disc = [float(\"Inf\")] * v_num\n    low = [float(\"Inf\")] * v_num\n    parent = [-1] * v_num\n\n    for v in range(v_num):\n        if not visited[v]:\n            dfs_Tarjan(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n    adj_table = tuple([] for _ in range(v_num))\n    for v_info in edges:\n        source, target = map(int, v_info)\n        adj_table[source].append(target)\n        adj_table[target].append(source)\n\n    timer = 0\n    ans = list()\n\n    dfs_init()\n    # ans.sort()\n    for ele in sorted(ans):\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nN,M=MAP()\nnodes=[[] for i in range(N)]\nfor i in range(M):\n    u,v=MAP()\n    nodes[u].append(v)\n    nodes[v].append(u)\n\nvisited=[False]*N\ntimer=1\nprenum=[0]*(N+1)\nlowest=[0]*(N+1)\nans=[]\ndef rec(cur, prev):\n    global timer\n    # curを訪問した直後の処理\n    prenum[cur]=lowest[cur]=timer\n    timer+=1\n\n    visited[cur]=True\n    for nxt in nodes[cur]:\n        # 未訪問なら再帰探索する\n        if not visited[nxt]:\n            rec(nxt, cur)\n            # nxtの探索が終了した直後の処理\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n            # より近い経路を含まないなら橋とする\n            if lowest[nxt]==prenum[nxt]:\n                # 番号の小さい方から入れる\n                ans.append((min(cur, nxt), max(cur, nxt)))\n        # 訪問済の場合、親への経路は無視して、他は近い経路となるか確認を取る\n        elif nxt!=prev:\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n\nrec(0, -1)\n\nans.sort()\nfor edge in ans:\n    print(*edge)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nfrom operator import itemgetter\n\nsys.setrecursionlimit(int(3e6))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort()\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tbridges\n# CreatedDate:  2020-07-26 23:07:19 +0900\n# LastModified: 2020-07-26 23:42:02 +0900\n#\n\n\nimport os\nimport sys\nsys.setrecursionlimit(100000)\n\n# import numpy as np\n# import pandas as pd\n\n\nclass Graph():\n    def __init__(self, V):\n        self.V = V\n        self.path = [[] for _ in range(self.V)]\n        self.parents = [-1] * self.V\n        self.lowlink = [float('inf')] * self.V\n        self.order = [float('inf')] * self.V\n        self.ap = []\n\n    def add(self, s, t):\n        self.path[s].append(t)\n        self.path[t].append(s)\n\n    def dfs(self, k, u):\n        child = 0\n        self.lowlink[u] = k\n        self.order[u] = k\n        k += 1\n        for v in self.path[u]:\n            if self.lowlink[v] == float('inf'):\n                child += 1\n                self.parents[v] = u\n                self.dfs(k, v)\n                self.lowlink[u] = min(self.lowlink[u], self.lowlink[v])\n\n                if self.lowlink[v] > self.order[u]:\n                    self.ap.append(sorted([u, v]))\n\n            elif self.parents[u] != v:\n                self.lowlink[u] = min(self.lowlink[u], self.order[v])\n\n    def lowlink_order_print(self):\n#        print(\"lowlink:\", self.lowlink)\n#        print(\"order:\", self.order)\n        self.ap = sorted(self.ap)\n        for s in self.ap:\n            print(\"{} {}\".format(s[0], s[1]))\n\n\ndef main():\n    V, E = map(int, input().split())\n    graph = Graph(V)\n    for _ in range(E):\n        s, t = map(int, input().split())\n        graph.add(s, t)\n    graph.dfs(0, 0)\n    graph.lowlink_order_print()\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\nclass LowLink:\n    def __init__(self, v):\n        self.size = len(v)\n        self.v = v\n        self.pre = [None]*self.size\n        self.low = [None]*self.size\n        self.articulation = []\n        self.bridge = []\n        for x in range(self.size):\n            if self.pre[x] is None:\n                self.cnt = 0\n                self.dfs(x,None)\n\n    def dfs(self, x, par):\n        self.pre[x] = self.low[x] = self.cnt\n        self.cnt += 1\n        is_articulation = False\n        n = 0\n        for y in self.v[x]:\n            if self.pre[y] is None:\n                n += 1\n                lowy = self.dfs(y, x)\n                if lowy < self.low[x]:\n                    self.low[x] = lowy\n                if self.pre[x] <= lowy:\n                    if self.pre[x]:\n                        is_articulation = True\n                    if self.pre[x] < lowy:\n                        self.bridge.append((x,y))\n            else:\n                if par != y and self.pre[y] < self.low[x]:\n                    self.low[x] = self.pre[y]\n\n        if par is None and n > 1:\n            is_articulation = True\n\n        if is_articulation:\n            self.articulation.append(x)\n\n        return self.low[x]\n\n\ndef solve():\n    n,m = LI()\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b = LI()\n        v[a].append(b)\n        v[b].append(a)\n    lowlink = LowLink(v)\n    bridge = lowlink.bridge\n    for i in range(len(bridge)):\n        l,r = bridge[i]\n        if r < l:\n            bridge[i] = (r,l)\n    for i in sorted(bridge):\n        print(*i)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef seq():\n    a = 1\n    while True:\n        yield a\n        a += 1\n\ndef dfs(here, went, connect, discovery, low, answer, seq):\n    went |= {here}\n    discovery[here] = low[here] = next(seq)\n    child = 0\n    for con in connect[here]:\n        if con not in went:\n            parent[con] = here\n            child += 1\n            dfs(con, went, connect, discovery, low, answer, seq)\n            low[here] = min(low[here], low[con])\n            if discovery[here] < low[con]:\n                answer[min(here,con)].append(max(here,con))\n        elif parent[here] != con:\n            low[here] = min(low[here], discovery[con])\n\nvertices, edges = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nfor _ in range(edges):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = defaultdict(list)\nnew_seq = seq()\nwent = set()\ndiscovery = [0 for n in range(vertices)]\nlow = [float(\"inf\") for n in range(vertices)]\nparent = [None for n in range(vertices)]\ndfs(0, went, connect, discovery, low, answer, new_seq)\n\nfor k in answer.keys():\n    for n in answer[k]:\n        print(k,n)"
  },
  {
    "language": "Python",
    "code": "def connection(G):\n    how_many_point=len(G[0])\n    tip=[0]\n\n    G_flag=[0 for i in range(how_many_point)]\n    G_flag[0]=1\n\n    while len(tip)>0:\n        tip_cash=[]\n        for i in tip:\n            for j in range(how_many_point):\n                if G[i][j]==1 and G_flag[j]==0:\n                    tip_cash.append(j)\n                    G_flag[j]=1\n        tip=list(set(tip_cash))\n\n    if G_flag==[1 for i in range(how_many_point)]:\n        return True\n    else:\n        return False\n\n\n\n\nV,E=[int(i) for i in input().split(\" \")]\nG_original=[[0 for i in range(V)] for j in range(V)]\ns=[]\nt=[]\nfor i in range(E):\n    si,ti=[int(j) for j in input().split(\" \")]\n    s.append(si)\n    t.append(ti)\n    G_original[si][ti]=1\n    G_original[ti][si]=1\n\nfor i in range(E):\n    G=G_original.copy()\n    G[s[i]][t[i]]=0\n    G[t[i]][s[i]]=0\n    if not(connection(G)):\n        print(s[i],t[i])\n    G[s[i]][t[i]]=1\n    G[t[i]][s[i]]=1\n\n\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\n\ndef input(f):\n    global v, e\n    global s, t\n    \n    v, e = map(int, f.readline().split())\n    s = [-1 for _ in range(e)]\n    t = [-1 for _ in range(e)]\n    for i in range(e):\n        s[i], t[i] = map(int, f.readline().split())\n\ndef solve():\n    g = [[] for _ in range(v)]\n    for i in range(e):\n        g[s[i]].append(t[i])\n        g[t[i]].append(s[i])\n    \n    used = [False for _ in range(v)]\n    ord = [-1 for _ in range(v)]\n    low = [10**6 for _ in range(v)]\n    res = []\n    \n    def rec(cur, prev, d):\n        if used[cur]:\n            return\n        used[cur] = True\n        ord[cur] = d\n        low[cur] = ord[cur]\n        \n        cnt = 0\n        for nxt in g[cur]:\n            if not used[nxt]:\n                cnt += 1\n                rec(nxt, cur, d+1)\n                low[cur] = min(low[cur], low[nxt])\n                if prev >= 0 and ord[cur] < low[nxt]:\n                    res.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                low[cur] = min(low[cur], ord[nxt])\n        \n        if prev == -1 and (cnt >= 2 or len(g[cur]) == 1):\n            for nxt in g[cur]:\n                res.append((min(cur, nxt), max(cur, nxt)))\n    \n    rec(0, -1, 0)\n    \n    for src, dst in sorted(res):\n        print('{} {}'.format(src, dst))\n\nwith open('/dev/stdin') as f:\n    input(f)\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(int(1e6))\n\nn, m = map(int, input().split())\n\nedges = {}\n\nfor i in range(m):\n    s, t = map(int, input().split())\n    if s not in edges:\n        edges[s] = set()\n    if t not in edges:\n        edges[t] = set()\n    edges[s].add(t)\n    edges[t].add(s)\n\norder = [0] * n\nlowlink = [0] * n\nvisited = set()\nbridges = set()\n\n\ndef dfs(v, p, i):\n    visited.add(v)\n\n    i += 1\n    lowlink[v] = order[v] = i\n\n    if v not in edges:\n        return\n\n    for t in edges[v]:\n        if t not in visited:\n            dfs(t, v, i)\n            lowlink[v] = min(lowlink[v], lowlink[t])\n            if lowlink[t] == order[t]:\n                bridges.add((min(v, t), max(v, t)))\n        elif t != p:\n            lowlink[v] = min(lowlink[v], lowlink[t])\n\n\nk = 0\nfor i in range(n):\n    if i not in visited:\n        dfs(i, -1, k)\n\nfor s, t in sorted(bridges):\n    print(s, t)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 8)\n\n\ndef lowLink(N: int, Adj: list):\n\tarticulation = []\n\tbridge = []\n\torder = [None] * N\n\tlowest = [1 << 100] * N\n\n\tdef _dfs(cur, pre, k):\n\t\torder[cur] = lowest[cur] = k\n\t\tis_articulation = False\n\t\tcnt = 0\n\t\tfor nxt in Adj[cur]:\n\t\t\tif order[nxt] is None:\n\t\t\t\tcnt += 1\n\t\t\t\t_dfs(nxt, cur, k + 1)\n\t\t\t\tif lowest[cur] > lowest[nxt]:\n\t\t\t\t\tlowest[cur] = lowest[nxt]\n\t\t\t\tis_articulation |= pre >= 0 and lowest[nxt] >= order[cur]\n\t\t\t\tif order[cur] < lowest[nxt]:\n\t\t\t\t\tif cur < nxt:\n\t\t\t\t\t\tbridge.append((cur, nxt))\n\t\t\t\t\telse:\n\t\t\t\t\t\tbridge.append((nxt, cur))\n\t\t\telif nxt != pre and lowest[cur] > order[nxt]:\n\t\t\t\tlowest[cur] = order[nxt]\n\t\tis_articulation |= pre < 0 and cnt > 1\n\t\tif is_articulation:\n\t\t\tarticulation.append(cur)\n\n\t_dfs(0, -1, 0)\n\treturn articulation, bridge\n\n\ndef main():\n\tn, m, *L = map(int, open(0).read().split())\n\tadj = [[] for _ in range(n)]\n\tfor s, t in zip(*[iter(L)] * 2):\n\t\tadj[s] += t,\n\t\tadj[t] += s,\n\t_, bridge = lowLink(n, adj)\n\tfor x, y in sorted(bridge):\n\t\tprint(x, y)\n\n\nif __name__ == '__main__':\n\tmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(v, tm):\n    dts[v] = est[v] = tm + 1\n    child = 0\n\n    for i in adj[v]:\n        if est[i] == float('inf'):\n            child += 1\n            parents[i] = v\n            dfs(i, tm + 1)\n            est[v] = min(est[v], est[i])\n\n            if est[i] > dts[v]: bridges.append((v, i))\n\n        elif parents[v] != i:\n            est[v] = min(est[v], dts[i])\n\nnv, ne = map(int, input().split(' '))\nadj = [[] for _ in range(nv)]\nest = [float('inf')] * nv\nparents = [None] * nv\ndts = [0] * nv\nbridges = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n    adj[s].append(t)\n    adj[t].append(s)\n\ndfs(0, 0)\nbridges.sort(key=lambda tup: (tup[0], tup[1]))\n[print(str(bridge[0]) + ' ' + str(bridge[1])) for bridge in bridges]"
  },
  {
    "language": "Python",
    "code": "# Undirected Graph\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\ndef bridges(graph):\n    def visit(v, e):\n        nonlocal n\n        w = e.other(v)\n        if not visited[w]:\n            parent[w] = v\n            n += 1\n            visited[w] = n\n            low[w] = n\n            return True\n        elif w != parent[v]:\n            low[v] = min(low[v], visited[w])\n            return False\n\n    def leave(p, e):\n        c = e.other(p)\n        if p == parent[c] and low[c] > visited[p]:\n            es.append(e)\n        low[p] = min(low[p], low[c])\n        return False\n\n    visited = [0] * graph.v\n    low = [0] * graph.v\n    parent = [-1] * graph.v\n    es = []\n\n    s = 0\n    n = 1\n    visited[s] = n\n    low[s] = n\n    stack = [(s, e, visit) for e in graph.adj(s)]\n\n    while stack:\n        v, e, func = stack.pop()\n        # print(v, e.v, e.w, func.__name__, visited, low)\n        if func(v, e):\n            stack.append((v, e, leave))\n            w = e.other(v)\n            for ne in graph.adj(w):\n                stack.append((w, ne, visit))\n\n    return es\n\n\ndef run():\n    v, e = [int(i) for i in input().split()]\n    g = Graph(v)\n\n    for _ in range(e):\n        s, t = [int(i) for i in input().split()]\n        g.add(Edge(s, t))\n\n    edges = [(e.v, e.w) if e.v < e.w else (e.w, e.v)\n             for e in bridges(g)]\n\n    for v, w in sorted(edges):\n        print(v, w)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            lowest[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        for v in adj_v:\n            l = min(lowest[u], lowest[v])\n            lowest[u] = l\n            lowest[v] = l\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\n\nv, e = map(int, input().split())\n\nedges = [set() for _ in range(v)]\n\nfor _ in range(e):\n    s, t = map(int, input().split())\n    edges[s].add(t)\n    edges[t].add(s)\n\nprenum = [None] * v\nparent = [None] * v\nlowest = [None] * v\ncounter = 0\nbridges = set()\n\ndef dfs(cur, prev):\n    global counter\n    prenum[cur] = lowest[cur] = counter\n    counter += 1\n    for edge in edges[cur]:\n        if prenum[edge] is not None:\n            if edge != prev:\n                lowest[cur] = min(lowest[cur], prenum[edge])\n            continue\n        parent[edge] = cur\n        dfs(edge, cur)\n        lowest[cur] = min(lowest[cur], lowest[edge])\n    if prenum[cur] == lowest[cur]:\n        bridges.add((cur, prev) if cur < prev else (prev, cur))\n \n \ndfs(0, -1)\n \nfor bridge in sorted(bridges)[1:]:\n    print(*bridge)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(int(1e10))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort()\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "import operator\ndef connection(G):\n    how_many_point=len(G[0])\n    tip=[0]\n\n    G_flag=[0 for i in range(how_many_point)]\n    G_flag[0]=1\n\n    while len(tip)>0:\n        tip_cash=[]\n        for i in tip:\n            for j in range(how_many_point):\n                if G[i][j]==1 and G_flag[j]==0:\n                    tip_cash.append(j)\n                    G_flag[j]=1\n        tip=list(set(tip_cash))\n\n    if G_flag==[1 for i in range(how_many_point)]:\n        return True\n    else:\n        return False\n\n\n\n\nV,E=[int(i) for i in input().split(\" \")]\nG_original=[[0 for i in range(V)] for j in range(V)]\ns=[]\nt=[]\nfor i in range(E):\n    si,ti=[int(j) for j in input().split(\" \")]\n    s.append(si)\n    t.append(ti)\n    G_original[si][ti]=1\n    G_original[ti][si]=1\n\n\nanswer=[]\nclass Point:\n    def __init__(self,s,t):\n        self.s=s\n        self.t=t\n\n\nfor i in range(E):\n    G=G_original.copy()\n    G[s[i]][t[i]]=0\n    G[t[i]][s[i]]=0\n    if not(connection(G)):\n        answer.append(Point(s[i],t[i]))\n    G[s[i]][t[i]]=1\n    G[t[i]][s[i]]=1\n\n\n\nanswer.sort(key=operator.attrgetter(\"s\"))\nfor i in answer:\n    print(\"%d %d\"%(i.s,i.t))\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nclass LowLink():\n    def __init__(self,G):\n        self.N = len(G)\n        self.G = G\n        self.low = [-1] * self.N\n        self.ord = [-1] * self.N\n    \n    def _dfs(self,v,time,p = -1):\n        self.ord[v] = self.low[v] = time\n        time += 1\n\n        isArticulation = False\n        cnt = 0\n        for e in self.G[v]:\n            if self.low[e] < 0:\n                cnt += 1\n                self._dfs(e,time,v)\n                self.low[v] = min(self.low[v],self.low[e])\n                if p != -1 and self.ord[v] <= self.low[e]:\n                    isArticulation = True\n                if self.ord[v] < self.low[e]:\n                    if v < e:\n                        self.bridge.append((v,e))\n                    else:\n                        self.bridge.append((e,v))\n            elif e != p:\n                self.low[v] = min(self.low[v],self.ord[e])\n        \n        if p == -1 and cnt >= 2:\n            isArticulation = True\n        if isArticulation:\n            self.articulation.append(v) \n\n    def build(self):\n        self.articulation = []\n        self.bridge = []\n        self._dfs(0,0)\n    \n\ndef main():\n    V,E = map(int,input().split())\n    G = [[] for _ in range(V)]\n    for _ in range(E):\n        a,b = map(int,input().split())\n        G[a].append(b)\n        G[b].append(a)\n    \n    lowlink = LowLink(G)\n    lowlink.build()\n    ans = lowlink.bridge\n    ans.sort()\n    if ans:\n        for t in ans:\n            print(*t)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class Graph(): #non-directed\n    def __init__(self,n,edge):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n        for e in edge:\n            self.graph[e[0]].append(e[1])\n            self.graph[e[1]].append(e[0])\n            self.deg[e[0]] += 1\n            self.deg[e[1]] += 1\n\n    def lowlink(self): #DFS木, ord, lowを計算\n        self.ord = [None for _ in range(self.n)]\n        self.low = [None for _ in range(self.n)]\n        self.group = [None for _ in range(self.n)]\n        self.prev = [None for _ in range(self.n)]\n        self.tree = [[] for _ in range(self.n)]\n        self.sorted = []\n        order = 0\n        count = 0\n        low = [None for _ in range(self.n)]\n        for s in range(self.n):\n            if self.group[s] is None:\n                stack = [(s, None)]\n                while stack:\n                    node, par = stack.pop()\n                    if self.group[node] is None:\n                        self.group[node] = count\n                        self.ord[node] = order\n                        self.sorted.append(node)\n                        order += 1\n                        if par is not None:\n                            self.prev[node] = par\n                            self.tree[par].append(node)\n                        for adj in self.graph[node]:\n                            if self.group[adj] is None:\n                                stack.append((adj, node))\n                count += 1\n        for node in self.sorted[::-1]:\n            self.low[node] = self.ord[node]\n            for adj in self.graph[node]:\n                if self.prev[adj]  == node:\n                    self.low[node] = min(self.low[node], self.low[adj])\n                elif self.prev[node] == adj:\n                    continue\n                else:\n                    self.low[node] = min(self.low[node], self.ord[adj])\n\n    def articulation(self):\n        res = []\n        for node in range(self.n):\n            if self.prev[node] is None and len(self.tree[node]) > 1:\n                res.append(node)\n            if self.prev[node] is not None:\n                for adj in self.tree[node]:\n                    if self.ord[node] <= self.low[adj]:\n                        res.append(node)\n                        break\n        return res\n\n    def bridge(self):\n        res = []\n        for node in range(self.n):\n            for adj in self.tree[node]:\n                if self.ord[node] < self.low[adj]:\n                    res.append((node, adj))\n        return res\n\n\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nE = [tuple(map(int, input().split())) for _ in range(M)]\n\ng = Graph(N, E)\ng.lowlink()\nres = g.bridge()\nres = list(map(lambda x: (min(x), max(x)), res))\nres.sort()\nif res:\n    print('\\n'.join(map(lambda x: ' '.join(map(str, x)), res)))\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            lowest[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        for v in adj_v:\n            lowest[u] = min(lowest[u], lowest[v])\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nfrom operator import itemgetter\n\nsys.setrecursionlimit(int(3e6))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort(key=itemgetter(0))\n    res.sort(key=itemgetter(1))\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    # return: articulation points, bridges\n    # The graph must be connected.\n    def lowlink(adj, root=1):\n        N = len(adj) - 1\n        order = [N + 1] * (N + 1)\n        low = [N + 1] * (N + 1)\n        AP = []\n        bridge = []\n\n        st = [root]\n        cnt = 1\n        par = [0] * (N + 1)\n        seq = []\n        while st:\n            v = st.pop()\n            if order[v] != N+1:\n                continue\n            order[v] = cnt\n            seq.append(v)\n            low[v] = cnt\n            cnt += 1\n            for u in adj[v]:\n                if order[u] < cnt:\n                    if par[v] != u:\n                        low[v] = min(low[v], order[u])\n                        continue\n                else:\n                    par[u] = v\n                    st.append(u)\n\n        child = [[] for _ in range(N + 1)]\n        for v in range(1, N + 1):\n            child[par[v]].append(v)\n\n        seq.reverse()\n        for v in seq:\n            for u in child[v]:\n                low[v] = min(low[v], low[u])\n\n        # bridge\n        for p in range(1, N+1):\n            for c in child[p]:\n                if order[p] < low[c]:\n                    bridge.append((p, c))\n\n        # articulation point\n        for v in range(1, N + 1):\n            if v == root:\n                if len(child[v]) > 1:\n                    AP.append(v)\n            else:\n                for c in child[v]:\n                    if order[v] <= low[c]:\n                        AP.append(v)\n                        break\n\n        return AP, bridge\n\n    N, M = map(int, input().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        a += 1\n        b += 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    AP, bridge = lowlink(adj)\n    ans = []\n    for u, v in bridge:\n        u -= 1\n        v -= 1\n        if u > v:\n            u, v = v, u\n        ans.append((u, v))\n    ans.sort(key=lambda x: x[1])\n    ans.sort(key=lambda x: x[0])\n    for u, v in ans:\n        print(u, v)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef dfs(root,u,parent,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices):\n    vis[u]=1\n    id+=1\n    dfs_num[u] = id\n    dfs_low[u] = id\n    for v in G[u]:\n        if v==parent:continue\n        if vis[v]==-1:\n            dfs(root,v,u,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices)\n            dfs_low[u]=min(dfs_low[u],dfs_low[v])\n            if(dfs_low[v]>dfs_num[u]):\n     \n                puntos.append((u,v))\n            if(dfs_low[v]>=dfs_num[u]):\n                puentes[u]=True\n            if(dfs_low[u]>=dfs_num[root] and u!=root):\n                puentes[root]=True\n        else:\n            dfs_low[u]=min(dfs_low[u],dfs_num[v])\n    \n\ndef main():\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    V = T[0]\n    E = T[1]\n    G = [[] for i in range(V)]\n    for j in range(E):\n        line =[int(x) for x in sys.stdin.readline().strip().split()]\n        G[line[0]].append(line[1])\n        G[line[1]].append(line[0])\n    n = len(G)\n    id=0\n    dfs_num = [0 for i in range(n)]\n    dfs_low = [0 for i in range(n)]\n    vis = [-1 for i in range(n)]\n    puentes=[False for i in range(n)]\n    puntos=[]\n    raices = [0 for i in range(n)]\n    for i in range(V):\n        if vis[i]==-1:\n            acumulador=0\n            dfs(i,i,-1,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices)\n\n    for i in range(len(puentes)):\n        puentes[i] = puentes[i] or raices[i]>1\n    #print(puentes.count(True))\n    T = []\n    #for k in range(len(puentes)):\n       # if(puentes[k]):\n            #T.append(str(k))\n    #print(\" \".join(T))\n    #print(len(puntos))\n    for i in sorted(puntos):\n        print(i[0],i[1])\n\nmain()\n            \n\n"
  },
  {
    "language": "Python",
    "code": "import operator\ndef connection(G):\n    how_many_point=len(G[0])\n    tip=[0]\n\n    G_flag=[0 for i in range(how_many_point)]\n    G_flag[0]=1\n\n    while len(tip)>0:\n        tip_cash=[]\n        for i in tip:\n            for j in range(how_many_point):\n                if G[i][j]==1 and G_flag[j]==0:\n                    tip_cash.append(j)\n                    G_flag[j]=1\n        tip=list(set(tip_cash))\n\n    if G_flag==[1 for i in range(how_many_point)]:\n        return True\n    else:\n        return False\n\n\n\n\nV,E=[int(i) for i in input().split(\" \")]\nG_original=[[0 for i in range(V)] for j in range(V)]\ns=[]\nt=[]\nfor i in range(E):\n    si,ti=[int(j) for j in input().split(\" \")]\n    s.append(si)\n    t.append(ti)\n    G_original[si][ti]=1\n    G_original[ti][si]=1\n\n\nanswer=[]\nclass Point:\n    def __init__(self,s,t):\n        self.s=s\n        self.t=t\n\n\nfor i in range(E):\n    G=G_original.copy()\n    G[s[i]][t[i]]=0\n    G[t[i]][s[i]]=0\n    if not(connection(G)):\n        if s[i]<=t[i]:\n            answer.append(Point(s[i],t[i]))\n        else:\n            answer.append(Point(t[i],s[i]))\n    G[s[i]][t[i]]=1\n    G[t[i]][s[i]]=1\n\n\n\nanswer.sort(key=operator.attrgetter(\"t\"))\nanswer.sort(key=operator.attrgetter(\"s\"))\nfor i in answer:\n    print(\"%d %d\"%(i.s,i.t))\n    "
  },
  {
    "language": "Python",
    "code": "import sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            lowest[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        lowest[u] = min(lowest[u], prenum[u])\n        for v in adj_v:\n            l = min(lowest[u], lowest[v])\n            lowest[u] = l\n            lowest[v] = l\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "def bridges(E, s):\n    N = len(E)\n    preorder = [-1] * N # a dfs preordering of each vertex\n    lowpt = [N] * N # for finding a cut-vertex\n    bridge = []\n    stack = [(s, -1, 0)] # (vertex, parent, status)\n    pre_num = 0 # current preordering\n    while stack:\n        v, p, st = stack.pop()\n        if st == 0 and preorder[v] < 0: # visited v for the first time\n            preorder[v] = pre_num\n            lowpt[v] = pre_num\n            pre_num += 1\n            n_children = 0\n            for u in E[v]:\n                if preorder[u] >= 0:\n                    if u != p: # the edge (v, u) is a back edge, which is not in dfs search tree\n                        lowpt[v] = min(lowpt[v], preorder[u])\n                    continue\n                if n_children == 0:\n                    stack += [(v, p, 2), (u, v, 0)]\n                    n_children += 1\n                else:\n                    stack += [(v, p, 1), (u, v, 0)]\n                    n_children += 1\n            if n_children == 0: # v is a leaf of the dfs search tree\n                lowpt[p] = min(lowpt[p], lowpt[v])\n                if lowpt[v] > preorder[p]: bridge.append((v, p) if v < p else (p, v))\n        elif st == 0 and preorder[v] >= 0: # the edge (v, p) is a back edge\n            continue\n        elif st == 1: # now searching\n            continue\n        else: # search finished\n            if p != -1:\n                lowpt[p] = min(lowpt[p], lowpt[v])\n                if lowpt[v] > preorder[p]: bridge.append((v, p) if v < p else (p, v))\n    return bridge\n\nN, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    s, t = map(int, input().split())\n    E[s].append(t); E[t].append(s)\nbr = sorted(bridges(E, 0))\nfor s, t in br:\n    print(s, t)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[0] * N for i in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    G[a][b] = 1\n    G[b][a] = 1\n\nvisited = None\ndef dfs(v):\n    visited[v] = True\n    for u,e in enumerate(G[v]):\n        if e == 0 or visited[u] == True: continue\n        dfs(u)\n \nans = []\nfor i in range(N):\n    for j in range(i+1, N):\n        if G[i][j] is 0:continue\n        G[i][j] = G[j][i] = 0\n        visited = [False] * N\n        dfs(0)\n        G[i][j] = G[j][i] = 1\n        if not all(visited):ans.append((i,j))\n \nfor a in ans:\n    print(' '.join(map(str,a)))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\n\ndef dfs(current, prev):\n    global time\n    # node currentを訪問した直後の処理\n    ord[current] = time\n    low[current] = time\n    time += 1\n    color[current] = BLACK\n\n    for next in G[current]:\n        if color[next] == WHITE:\n            # node currentからnode nextへ訪問する直前の処理\n            parent[next] = current\n            dfs(next, current)\n\n            # node nextの探索が終了した直後の処理\n            low[current] = min(low[current], low[next])\n        elif next != prev:\n            # edge current --> next がback-edgeの場合の処理\n            low[current] = min(low[current], ord[next])\n\n\ndef bridge():\n    global time\n    time = 1\n    dfs(0, -1)  # 0をrootとしてlowの計算\n    for u, v in edges:\n        if ord[u] < low[v] or ord[v] < low[u]:\n            br.add((u, v))\n\n\nG = {}\nedges = set([])\nbr = set([])\nv, n = map(int, input().split())\nfor i in range(0, v):\n    G[i] = []\nfor i in range(n):\n    s, t = map(int, input().split())\n    G[s].append(t)\n    G[t].append(s)\n    edges.add((s, t))\nWHITE = 0\nBLACK = 2\n\ncolor = [WHITE] * (v)\nparent = [0] * (v)\nord = [0] * (v)\nlow = [0] * (v)\nparent = [0] * (v)\nbridge()\nif br:\n    for ans in sorted(br):\n        print(*ans, sep=' ')\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\n\ndef dfs(current, prev):\n    global time\n    # node currentを訪問した直後の処理\n    ord[current] = time\n    low[current] = time\n    time += 1\n    color[current] = BLACK\n\n    for next in G[current]:\n        if color[next] == WHITE:\n            # node currentからnode nextへ訪問する直前の処理\n            parent[next] = current\n            dfs(next, current)\n\n            # node nextの探索が終了した直後の処理\n            low[current] = min(low[current], low[next])\n        elif next != prev:\n            # edge current --> next がback-edgeの場合の処理\n            low[current] = min(low[current], ord[next])\n\n\ndef bridge():\n    global time\n    time = 1\n    dfs(0, -1)  # 0をrootとしてlowの計算\n    for u, v in edges:\n        if ord[u] < low[v] or ord[v] < low[u]:\n            br.add((u, v))\n\n\nG = {}\nedges = set([])\nbr = set([])\nv, n = map(int, input().split())\nfor i in range(0, v):\n    G[i] = []\nfor i in range(n):\n    s, t = map(int, input().split())\n    G[s].append(t)\n    G[t].append(s)\n    edges.add((s, t))\nWHITE = 0\nBLACK = 2\n\ncolor = [WHITE] * (v)\nparent = [0] * (v)\nord = [0] * (v)\nlow = [0] * (v)\nparent = [0] * (v)\nbridge()\nif br:\n    br = list(map(sorted, br))\n    br.sort(key=lambda x: x[1])\n    br.sort(key=lambda x: x[0])\n    # 安定ソートだからこれができる\n    for ans in br:\n        print(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\n\nV, E = list(map(int, input().split()))\nG = [[] for i in range(V)]\n\nfor i in range(E):\n    s, t = list(map(int, input().split()))\n    G[s].append(t)\n    G[t].append(s)\n\nclass LowLink:\n    def main(G, V):\n        LowLink.G = G\n        LowLink.used = [False] * V\n        LowLink.ord = [0] * V\n        LowLink.low = [0] * V\n        LowLink.aps = []\n        LowLink.bridges = []\n        n = 0\n        \n        for i in range(V):\n            if not LowLink.used[i]: n = LowLink.dfs(i, n, -1)\n            \n        LowLink.aps.sort()\n        LowLink.bridges.sort()\n        \n    def dfs(v, n, par):\n        LowLink.used[v] = True\n        LowLink.ord[v] = n+1\n        n += 1\n        LowLink.low[v] = LowLink.ord[v]\n        \n        is_aps = False\n        chi = 0\n        \n        for u in LowLink.G[v]:\n            if not LowLink.used[u]:\n                chi += 1\n                n = LowLink.dfs(u, n, v)\n                LowLink.low[v] = min(LowLink.low[v], LowLink.low[u])\n                if par != -1 and LowLink.ord[v] <= LowLink.low[u]: is_aps = True\n                if LowLink.ord[v] < LowLink.low[u]: LowLink.bridges.append((min(v, u), max(v, u)))\n                \n            elif u != par:\n                LowLink.low[v] = min(LowLink.low[v], LowLink.ord[u])\n                \n        if par == -1 and chi >= 2: is_aps = True\n        if is_aps: LowLink.aps.append(v)\n\n        return n\n\nLowLink.main(G, V)      \n\nfor v in LowLink.bridges:\n    print(*v)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\n\nn, m = map(int, input().split())\n\nedges = [set() for _ in range(n)]\n\nfor _ in range(m):\n    s, t = map(int, input().split())\n    edges[s].add(t)\n    edges[t].add(s)\n\nprenum = [None] * n\nparent = [None] * n\nlowest = [None] * n\ncounter = 0\nbridges = set()\n\n\ndef dfs(cur, prev):\n    global counter\n    prenum[cur] = lowest[cur] = counter\n    counter += 1\n    for edge in edges[cur]:\n        if prenum[edge] is not None:\n            if edge != prev:\n                lowest[cur] = min(lowest[cur], prenum[edge])\n            continue\n        parent[edge] = cur\n        dfs(edge, cur)\n        lowest[cur] = min(lowest[cur], lowest[edge])\n    if prenum[cur] == lowest[cur]:\n        bridges.add((cur, prev) if cur < prev else (prev, cur))\n\n\ndfs(0, -1)\n\nfor bridge in sorted(bridges)[1:]:\n    print(*bridge)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass LowLinks:\n    def __init__(self, edges, v, root=0):\n        self.edges = edges\n        self.root = root\n        self.ord = [None] * v\n        self.low = [None] * v\n        self.cnt = 0\n        self.bridges = []\n        self.articulations = set()\n        self.par = [None] * v\n\n    def build(self):\n        self.search(self.root)\n\n    def search(self, x):\n        self.ord[x] = self.cnt\n        self.low[x] = self.cnt\n        self.cnt += 1\n        dim = 0\n        for to in self.edges[x]:\n            if to == self.par[x]:continue\n            if self.ord[to] != None:\n                self.low[x] = min(self.low[x], self.ord[to])\n            else:\n                self.par[to] = x\n                self.search(to)\n                dim += 1\n                self.low[x] = min(self.low[x], self.low[to])\n\n                if x != self.root and self.ord[x] <= self.low[to]:\n                    self.articulations.add(x)\n\n            if x == self.root and dim > 1:\n                self.articulations.add(x)\n\n            if self.ord[x] < self.low[to]:\n                self.bridges.append((x, to))\n\n\nsys.setrecursionlimit(1000000)\nv, e = map(int, input().split())\nedges = [[] for _ in range(v)]\nfor _ in range(e):\n    s, t = map(int, input().split())\n    edges[s].append(t)\n    edges[t].append(s)\n\nlowlinks = LowLinks(edges, v)\nlowlinks.build()\nif lowlinks.bridges:\n    bridges = sorted(lowlinks.bridges, key=lambda x: (min(x), max(x)))\n    for bridge in bridges:\n        print(min(bridge), max(bridge))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef low_link(nodes):\n    N = len(nodes)\n    visited = [False] * N\n    prenum = [0] * N\n    parent = [0] * N\n    lowest = [0] * N\n    bridges = []\n    timer = 1\n\n    def rec(cur, prev, timer):\n        # curを訪問した直後の処理\n        prenum[cur] = lowest[cur] = timer\n        timer += 1\n        visited[cur] = True\n        for nxt in nodes[cur]:\n            if not visited[nxt]:\n                # curからvへ訪問する直前の処理\n                parent[nxt] = cur\n                timer = rec(nxt, cur, timer)\n                # nxtの探索が終了した直後の処理\n                lowest[cur] = min(lowest[cur], lowest[nxt])\n                # より近い経路を含まないなら橋とする\n                if lowest[nxt] == prenum[nxt]:\n                    # 番号の小さい方から入れる\n                    bridges.append((min(cur, nxt), max(cur, nxt)))\n            elif nxt != prev:\n                # cur -> nxt がback-edgeの場合の処理\n                lowest[cur] = min(lowest[cur], prenum[nxt])\n        return timer\n    # 必要な各値の取得(非連結に対応するため全頂点から)\n    for i in range(N):\n        if not visited[i]:\n            timer = rec(i, -1, timer)\n\n    # 間接点\n    aps = set()\n    # ルートの子ノードの数\n    np = 0\n    for i in range(1, N):\n        p = parent[i]\n        if p == 0:\n            np += 1\n        # 条件2の確認\n        elif prenum[p] <= lowest[i]:\n            aps.add(p)\n    # 条件1の確認\n    if np > 1:\n        aps.add(0)\n\n    return aps, bridges\n\nN, M = MAP()\nnodes = [[] for i in range(N)]\nfor i in range(M):\n    u, v = MAP()\n    nodes[u].append(v)\n    nodes[v].append(u)\n\naps, bridges = low_link(nodes)\n\nbridges = sorted(bridges)\nfor x in bridges:\n    print(*x)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    v, e = map(int, readline().split())\n    from collections import defaultdict\n    g = defaultdict(list)\n\n    for _ in range(e):\n        s, t = map(int, readline().split())\n        g[s].append(t)\n        g[t].append(s)\n\n    visited = set()\n    lowest = [None] * v\n    parent = [None] * v\n    prenum = [None] * v\n    child = defaultdict(list)\n    root = 0\n\n    # dfs??§tree?????????\n    stack = [(root, None)]\n    while stack:\n        u, prev = stack.pop()\n        if u not in visited:\n            parent[u] = prev\n            if prev is not None:\n                child[prev].append(u)\n            visited |= {u}\n            prenum[u] = lowest[u] = len(visited)\n\n        stack.extend([(v, u) for v in g[u] if v not in visited])\n\n    # lowest????¨????\n    from collections import Counter\n    leaf = [i for i in range(v) if not child[i]]\n    unfinished = Counter()\n    for li in leaf:\n        while li is not None:\n            candidate = [prenum[li]] + [prenum[i] for i in g[li] if i != parent[li]] + [lowest[i] for i in child[li]]\n            lowest[li] = min(candidate)\n            li = parent[li]\n            if li is not None and 1 < len(child[li]):\n                unfinished[li] += 1\n                if unfinished[li] < len(child[li]):\n                    break\n\n    # ????????????\n    bridge = []\n    for i in range(v):\n        if child[i]:\n            for j in child[i]:\n                if prenum[i] < lowest[j]:\n                    bridge.append((i, j) if i < j else (j, i))\n    bridge.sort()\n    for bi in bridge:\n        print(*bi)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nN,M=MAP()\nnodes=[[] for i in range(N)]\nfor i in range(M):\n    u,v=MAP()\n    nodes[u].append(v)\n    nodes[v].append(u)\n\ntimer=1\nprenum=[0]*(N+1)\nlowest=[0]*(N+1)\nans=[]\ndef rec(cur, prev):\n    global timer\n    # curを訪問した直後の処理\n    prenum[cur]=lowest[cur]=timer\n    timer+=1\n\n    for nxt in nodes[cur]:\n        # 未訪問なら再帰探索する\n        if not prenum[nxt]:\n            rec(nxt, cur)\n            # nxtの探索が終了した直後の処理\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n            # より近い経路を含まないなら橋とする\n            if lowest[nxt]==prenum[nxt]:\n                # 番号の小さい方から入れる\n                ans.append((min(cur, nxt), max(cur, nxt)))\n        # 訪問済の場合、親への経路は無視して、他は近い経路となるか確認を取る\n        elif nxt!=prev:\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n\nrec(0, -1)\n\nans.sort()\nfor edge in ans:\n    print(*edge)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom typing import List, Set\n\n\nsys.setrecursionlimit(200000)\n\n\ndef dfs(cur : int, prev: int) -> None:\n    global prenum, parent, lowest, counter, bridges\n    prenum[cur] = lowest[cur] = counter\n    counter += 1\n    for edge in edges[cur]:\n        if prenum[edge] != sys.maxsize:\n            if edge != prev:\n                lowest[cur] = min(lowest[cur], prenum[edge])\n            continue\n        parent[edge] = cur\n        dfs(edge, cur)\n        lowest[cur] = min(lowest[cur], lowest[edge])\n    if prenum[cur] == lowest[cur]:\n        bridges.add((cur, prev) if cur < prev else (prev, cur))\n\n\nif __name__ == \"__main__\":\n    V, E = map(int, input().split())\n    edges: List[Set[int]] = [set() for _ in range(V)]\n\n    for _ in range(E):\n        s, t = map(int, input().split())\n        edges[s].add(t)\n        edges[t].add(s)\n\n    prenum = [sys.maxsize] * V\n    parent = [sys.maxsize] * V\n    lowest = [sys.maxsize] * V\n    counter = 0\n    bridges = set()  # type: ignore\n\n    dfs(0, -1)\n    for bridge in sorted(bridges)[1:]:\n        print(*bridge)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\n# sys.setrecursionlimit(int(3e6))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort()\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "import operator\ndef connection(G,s,t):\n    how_many_point=len(G[0])\n    tip=[0]\n\n    G_flag=[0 for i in range(how_many_point)]\n    G_flag[0]=1\n    flag=0\n    while len(tip)>0:\n        \n        tip_cash=[]\n        for i in tip:\n            for j in range(how_many_point):\n                if G[i][j]==1 and G_flag[j]==0:\n                    tip_cash.append(j)\n                    G_flag[j]=1\n                    if j==s:\n                        flag+=1\n                    if j==t:\n                        flag+=1\n                    if flag==2:\n                        return True\n        tip=list(set(tip_cash))\n\n    if G_flag==[1 for i in range(how_many_point)]:\n        return True\n    else:\n        return False\n\n\n\n\nV,E=[int(i) for i in input().split(\" \")]\nG_original=[[0 for i in range(V)] for j in range(V)]\ns=[]\nt=[]\nfor i in range(E):\n    si,ti=[int(j) for j in input().split(\" \")]\n    s.append(si)\n    t.append(ti)\n    G_original[si][ti]=1\n    G_original[ti][si]=1\n\n\nanswer=[]\nclass Point:\n    def __init__(self,s,t):\n        self.s=s\n        self.t=t\n\n\nfor i in range(E):\n    G=G_original.copy()\n    G[s[i]][t[i]]=0\n    G[t[i]][s[i]]=0\n    if not(connection(G,s[i],t[i])):\n        if s[i]<=t[i]:\n            answer.append(Point(s[i],t[i]))\n        else:\n            answer.append(Point(t[i],s[i]))\n    G[s[i]][t[i]]=1\n    G[t[i]][s[i]]=1\n\n\n\nanswer.sort(key=operator.attrgetter(\"t\"))\nanswer.sort(key=operator.attrgetter(\"s\"))\nfor i in answer:\n    print(\"%d %d\"%(i.s,i.t))\n    "
  },
  {
    "language": "Python",
    "code": "# AOJ GRL_3_B\n# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_3_B\n\nimport sys\n\nsys.setrecursionlimit(100000)\n\nV, E = list(map(int, input().split()))\nEdge = [list(map(int, input().split())) for _ in range(0, E)]\n\nord = [0 for _ in range(0, V)]\nlow = [0 for _ in range(0, V)]\nused = [False for _ in range(0, V)]\nbridge = []\n\nG = [ [] for _ in range(0, V)]\nfor s, t in Edge:\n    G[s] += [t]\n    G[t] += [s]\n\n# pは親となる頂点\ndef dfs(s, p, k):\n    global articulation\n    used[s] = True\n    ord[s] = k\n    low[s] = ord[s]\n    k += 1\n    c = 0\n    \n    # sから始まる辺\n    for t in G[s]:\n        # まだ探索していないか\n        if used[t] == False:\n            c += 1\n            dfs(t, s, k)\n            # DFSの葉の方向進める頂点のlowlinkの最小値\n            low[s] = min(low[s], low[t])\n        # 後退辺か\n        elif t != p:\n            # ord[t]の最小値\n            low[s] = min(low[s], ord[t])\n\nfor s in range(0, V): \n    if used[s] == False:\n        dfs(s, -1, 0)\n\nfor s, t in Edge:\n    if ord[s] < low[t] or ord[t] < low[s]:\n        if s < t:\n            bridge += [(s, t)]\n        else:\n            bridge += [(t, s)]\n\nbridge.sort()\nfor s, t in bridge:\n    print(s, t)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\n\ndef dfs(current, prev):\n    global time\n    # node currentを訪問した直後の処理\n    ord[current] = time\n    low[current] = time\n    time += 1\n    color[current] = BLACK\n\n    for next in G[current]:\n        if color[next] == WHITE:\n            # node currentからnode nextへ訪問する直前の処理\n            parent[next] = current\n            dfs(next, current)\n\n            # node nextの探索が終了した直後の処理\n            low[current] = min(low[current], low[next])\n        elif next != prev:\n            # edge current --> next がback-edgeの場合の処理\n            low[current] = min(low[current], ord[next])\n\n\ndef bridge():\n    global time\n    time = 1\n    dfs(0, -1)  # 0をrootとしてlowの計算\n    for u, v in edges:\n        if ord[u] < low[v] or ord[v] < low[u]:\n            br.add((u, v))\n\n\nG = {}\nedges = set([])\nbr = set([])\nv, n = map(int, input().split())\nfor i in range(0, v):\n    G[i] = []\nfor i in range(n):\n    s, t = map(int, input().split())\n    G[s].append(t)\n    G[t].append(s)\n    edges.add((s, t))\nWHITE = 0\nBLACK = 2\n\ncolor = [WHITE] * (v)\nparent = [0] * (v)\nord = [0] * (v)\nlow = [0] * (v)\nparent = [0] * (v)\nbridge()\nif br:\n    br = list(map(sorted, br))\n    br.sort(key=lambda x: x[0])\n    for ans in br:\n        print(*ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\n\nsys.setrecursionlimit(int(1e5))\n\n\ndef dfs_Tarjan(current, visited, parent, low, disc):\n    global timer\n    children = 0\n    visited[current] = True\n    disc[current] = timer\n    low[current] = timer\n    timer += 1\n\n    for adj in adj_table[current]:\n        if not visited[adj]:\n            parent[adj] = current\n            children += 1\n            dfs_Tarjan(adj, visited, parent, low, disc)\n            low[current] = min(low[current], low[adj])\n            if low[adj] > disc[current]:\n                ans.append(sorted([current, adj]))\n        elif adj != parent[current]:\n            low[current] = min(low[current], disc[adj])\n\n    return None\n\n\ndef dfs_init():\n    visited = [False] * v_num\n    disc = [float(\"Inf\")] * v_num\n    low = [float(\"Inf\")] * v_num\n    parent = [-1] * v_num\n\n    for v in range(v_num):\n        if not visited[v]:\n            dfs_Tarjan(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    v_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n    adj_table = tuple([] for _ in range(v_num))\n    for v_info in edges:\n        source, target = map(int, v_info)\n        adj_table[source].append(target)\n        adj_table[target].append(source)\n        \n    timer = 0\n    ans = list()\n\n    dfs_init()\n    ans.sort()\n    for ele in ans:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef dfs(root,u,parent,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices):\n    vis[u]=1\n    id+=1\n    dfs_num[u] = id\n    dfs_low[u] = id\n    for v in G[u]:\n        if v==parent:continue\n        if vis[v]==-1:\n            dfs(root,v,u,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices)\n            dfs_low[u]=min(dfs_low[u],dfs_low[v])\n            if(dfs_low[v]>dfs_num[u]):\n     \n                puntos.append((u,v))\n            if(dfs_low[v]>=dfs_num[u]):\n                puentes[u]=True\n            if(dfs_low[u]>=dfs_num[root] and u!=root):\n                puentes[root]=True\n        else:\n            dfs_low[u]=min(dfs_low[u],dfs_num[v])\n    \n\ndef main():\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    V = T[0]\n    E = T[1]\n    G = [[] for i in range(V)]\n    for j in range(E):\n        line =[int(x) for x in sys.stdin.readline().strip().split()]\n        G[line[0]].append(line[1])\n        #G[line[1]].append(line[0])\n    n = len(G)\n    id=0\n    dfs_num = [0 for i in range(n)]\n    dfs_low = [0 for i in range(n)]\n    vis = [-1 for i in range(n)]\n    puentes=[False for i in range(n)]\n    puntos=[]\n    raices = [0 for i in range(n)]\n    for i in range(V):\n        if vis[i]==-1:\n            acumulador=0\n            dfs(i,i,-1,G,id,dfs_num,dfs_low,vis,puntos,acumulador,puentes,raices)\n\n    for i in range(len(puentes)):\n        puentes[i] = puentes[i] or raices[i]>1\n    #print(puentes.count(True))\n    T = []\n    #for k in range(len(puentes)):\n       # if(puentes[k]):\n            #T.append(str(k))\n    #print(\" \".join(T))\n    #print(len(puntos))\n    for i in sorted(puntos):\n        print(i[0],i[1])\n\nmain()\n            \n\n"
  },
  {
    "language": "Python",
    "code": "# 橋検出\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**7)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n# 二つの配列ord,miniを持つ。\nV, E = map(int, input().split())\nedge = []\ngraph = [[] for i in range(V)]\nfor i in range(E):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n    graph[y].append(x)\n    edge.append((min(x, y), max(x, y)))\n\norder = [i for i in range(V)]\nmini = [V+1 for i in range(V)]\nvisited = [False for i in range(V)]\n\nused = defaultdict(bool)\nfor node in range(V):\n    for point in graph[node]:\n        used[(node, point)] = False\ncnt = 0\n\n\ndef dfs(node):\n    global cnt\n    visited[node] = True\n    cnt += 1\n    order[node] = cnt\n    mini[node] = cnt\n    for point in graph[node]:\n        if visited[point] == False:\n            used[(node, point)] = True\n            dfs(point)\n            mini[node] = min(mini[node], mini[point])\n        elif not used[(point, node)]:\n            mini[node] = min(mini[node], order[point])\n    return\n\n\ndfs(0)\n\nanswer = []\n\nfor x, y in edge:\n    if order[x] < order[y]:\n        if order[x] < mini[y]:\n            answer.append((x, y))\n    elif order[x] > order[y]:\n        if order[y] < mini[x]:\n            answer.append((x, y))\nanswer.sort()\nfor x, y in answer:\n    print(x, y)\n"
  },
  {
    "language": "Python",
    "code": "from math import inf\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(v,par):\n    global cur\n    vis[v]=1 ; disc[v]=cur ;low[v]=cur \n    cur+=1\n    for i in g[v]:\n        if vis[i]==0:\n            dfs(i,v)\n            low[v]=min(low[i],low[v])\n            if low[i]>disc[v]:\n                apts.add((min(v,i),max(v,i)))\n\n        elif i!=par: low[v]=min(disc[i],low[v])\n   \ndef articulation_pts():\n    global apts,disc,low,vis\n    disc=[0]*n ; low=[inf]*n ; vis=[0]*n ; apts=set()  \n    for i in range(n):\n        if vis[i]==0:\n            dfs(i,-1)\n\nn,e=map(int,input().split())\ncur=0\ng=[[] for i in range(n)]\nfor i in range(e):\n    x,y=map(int,input().split())\n    g[x].append(y)\n    g[y].append(x)\narticulation_pts()\napts=sorted(apts)\nfor i in apts:\n    print(*i)\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef seq():\n    a = 1\n    while True:\n        yield a\n        a += 1\n\ndef dfs(here, went, connect, discovery, low, answer, seq):\n    went |= {here}\n    discovery[here] = low[here] = next(seq)\n    child = 0\n    for con in connect[here]:\n        if con not in went:\n            parent[con] = here\n            child += 1\n            dfs(con, went, connect, discovery, low, answer, seq)\n            low[here] = min(low[here], low[con])\n            if discovery[here] < low[con]:\n                answer[min(here,con)].append(max(here,con))\n        elif parent[here] != con:\n            low[here] = min(low[here], discovery[con])\n\nvertices, edges = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nfor _ in range(edges):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = defaultdict(list)\nnew_seq = seq()\nwent = set()\ndiscovery = [0 for n in range(vertices)]\nlow = [float(\"inf\") for n in range(vertices)]\nparent = [None for n in range(vertices)]\ndfs(0, went, connect, discovery, low, answer, new_seq)\n\nfor k in range(answer.keys()):\n    for n in range(answer[k]):\n        print(k,n)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef seq():\n    a = 1\n    while True:\n        yield a\n        a += 1\n\ndef dfs(here, went, connect, discovery, low, answer, seq):\n    went |= {here}\n    discovery[here] = low[here] = next(seq)\n    child = 0\n    for con in connect[here]:\n        if con not in went:\n            parent[con] = here\n            child += 1\n            dfs(con, went, connect, discovery, low, answer, seq)\n            low[here] = min(low[here], low[con])\n            if discovery[here] < low[con]:\n                answer[min(here,con)].append(max(here,con))\n        elif parent[here] != con:\n            low[here] = min(low[here], discovery[con])\n\nvertices, edges = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nfor _ in range(edges):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = defaultdict(list)\nnew_seq = seq()\nwent = set()\ndiscovery = [0 for n in range(vertices)]\nlow = [float(\"inf\") for n in range(vertices)]\nparent = [None for n in range(vertices)]\ndfs(0, went, connect, discovery, low, answer, new_seq)\n\nfor k in sorted(answer.keys()):\n    for n in sorted(answer[k]):\n        print(k,n)"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\n\nedges = [set() for _ in range(n)]\n\nfor _ in range(m):\n    s, t = map(int, input().split())\n    edges[s].add(t)\n    edges[t].add(s)\n\nprenum = [None] * n\nparent = [None] * n\nlowest = [None] * n\ncounter = 0\nbridges = set()\n\n\ndef dfs(cur, prev):\n    global counter\n    prenum[cur] = lowest[cur] = counter\n    counter += 1\n    for edge in edges[cur]:\n        if prenum[edge] is not None:\n            if edge != prev:\n                lowest[cur] = min(lowest[cur], prenum[edge])\n            continue\n        parent[edge] = cur\n        dfs(edge, cur)\n        lowest[cur] = min(lowest[cur], lowest[edge])\n    if prenum[cur] == lowest[cur]:\n        bridges.add((cur, prev) if cur < prev else (prev, cur))\n\n\ndfs(0, -1)\n\nfor bridge in sorted(bridges)[1:]:\n    print(*bridge)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            lowest[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        for v in adj_v:\n            lowest[u] = min(lowest[u], lowest[v])\n            adj[u].remove(v)\n            adj[v].remove(u)\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if prenum[p] < lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "#関節点(そのノードを除くとグラフが非連結になる点)\nimport sys\nclass LowLinks:\n    def __init__(self, edges, v, root=0):\n        self.edges = edges\n        self.root = root\n        self.ord = [None] * v\n        self.low = [None] * v\n        self.cnt = 0\n        self.bridges = []\n        self.articulations = set()\n        self.par = [None] * v\n\n    def build(self):\n        self.search(self.root)\n\n    def search(self, x):\n        self.ord[x] = self.cnt\n        self.low[x] = self.cnt\n        self.cnt += 1\n        dim = 0\n        for to in self.edges[x]:\n            if to == self.par[x]:continue\n            if self.ord[to] != None:\n                self.low[x] = min(self.low[x], self.ord[to])\n            else:\n                self.par[to] = x\n                self.search(to)\n                dim += 1\n                self.low[x] = min(self.low[x], self.low[to])\n\n                if x != self.root and self.ord[x] <= self.low[to]:\n                    self.articulations.add(x)\n\n            if x == self.root and dim > 1:\n                self.articulations.add(x)\n\n            if self.ord[x] < self.low[to]:\n                self.bridges.append((x, to))\n\nsys.setrecursionlimit(1000000)\nn,m=map(int,input().split())\nedges=[[] for _ in range(n)]\nfor _ in range(m):\n    s, t = map(int, input().split())\n    edges[s].append(t)\n    edges[t].append(s)\n\nl=LowLinks(edges,n)\nl.build()\nans=[]\nfor i,j in l.bridges:\n    if i>j:\n        ans.append((j,i))\n    else:\n        ans.append((i,j))\nans.sort()\nfor i,j in ans:\n    print(i,j)\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            lowest[v] = cnt\n            prenum[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        for v in adj_v:\n            lowest[u] = min(lowest[u], prenum[v])\n            adj[u].remove(v)\n            adj[v].remove(u)\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\n\ndef dfs(v, tm):\n    dts[v] = est[v] = tm + 1\n    child = 0\n\n    for i in adj[v]:\n        if est[i] == float('inf'):\n            child += 1\n            parents[i] = v\n            dfs(i, tm + 1)\n            est[v] = min(est[v], est[i])\n\n            if est[i] > dts[v]: \n                bridges.append((v, i)) if v < i else bridges.append((i, v))\n\n        elif parents[v] != i:\n            est[v] = min(est[v], dts[i])\n\nnv, ne = map(int, input().split(' '))\nadj = [[] for _ in range(nv)]\nest = [float('inf')] * nv\nparents = [None] * nv\ndts = [0] * nv\nbridges = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n    adj[s].append(t)\n    adj[t].append(s)\n\ndfs(0, 0)\nbridges.sort(key=lambda tup: (tup[0], tup[1]))\n[print(str(bridge[0]) + ' ' + str(bridge[1])) for bridge in bridges]"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nfrom operator import itemgetter\n\nsys.setrecursionlimit(int(3e6))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort(key=itemgetter(0))\n    res = sorted(res, key=itemgetter(1))\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "import sys\n\naumento = 0\ndef dfs(u,parent,G,id,dfs_num,dfs_low,vis,puntos,acumulador):\n    #if(u==parent):acumulador+=1\n    vis[u]=1\n    id+=1\n    dfs_num[u] = id\n    dfs_low[u] = id\n    for v in G[u]:\n        if v==parent:continue\n        if vis[v]==-1:\n            dfs(v,u,G,id,dfs_num,dfs_low,vis,puntos,acumulador)\n            dfs_low[u]=min(dfs_low[u],dfs_low[v])\n            if(dfs_low[v]>dfs_num[u]):\n                puntos.append((u,v))\n        else:\n            dfs_low[u]=min(dfs_low[u],dfs_num[v])\n    \n\ndef main():\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    V = T[0]\n    E = T[1]\n    G = [[] for i in range(V)]\n    for j in range(E):\n        line =[int(x) for x in sys.stdin.readline().strip().split()]\n        G[line[0]].append(line[1])\n        G[line[1]].append(line[0])\n    n = len(G)\n    id=0\n    dfs_num = [0 for i in range(n)]\n    dfs_low = [0 for i in range(n)]\n    vis = [-1 for i in range(n)]\n    #puntos=[False for i in range(n)]\n    puntos=[]\n    for i in range(V):\n        if vis[i]==-1:\n            acumulador=0\n            dfs(i,-1,G,id,dfs_num,dfs_low,vis,puntos,acumulador)\n            #puntos[i]=acumulador>1\n    for i in sorted(puntos):\n        print(i[0],i[1])\n\nmain()\n            \n\n"
  },
  {
    "language": "Python",
    "code": "from typing import List\nfrom typing import Tuple\nfrom functools import cmp_to_key\nimport sys\n\nsys.setrecursionlimit(100000)\n\ndef find_bridges(adj, n) -> List[Tuple[int, int]]:\n    mark = [False for _ in range(n)] \n    edges = []\n    low_link = [None for _ in range(n)]\n    id = [0]\n\n    for v in range(n):\n        if not mark[v]:\n            ____find_bridges(v, -1, adj, id, low_link, mark, edges)\n    return edges\n\n\ndef ____find_bridges(node: int, parent: int, adj, id: List[int], low_link: List[int], mark: List[bool], edges):\n\n    mark[node] = True\n    low_link[node] = id[0]\n    node_id = id[0]\n\n    for v in adj[node]:\n        if v == parent: continue\n        if not mark[v]:\n            id[0] += 1\n            ____find_bridges(v, node, adj, id, low_link, mark, edges)\n        low_link[node] = min(low_link[node], low_link[v])\n        if low_link[v] > node_id:\n            edges.append([node, v])\n\ndef read() -> Tuple[List, int]:\n\n    info = [int(e) for e in input().split()]\n    n, e = info[0], info[1]\n    adj = [[] for _ in range(n)]\n    for _ in range(e):\n        edge = [int(i) for i in input().split()]\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    \n    return adj, n\n\ndef custom_cmp(edgeA, edgeB):\n    if edgeA[0] == edgeB[0]:\n        return edgeA[1] - edgeB[1]\n    \n    return edgeA[0] - edgeB[0]\n\ndef process_output(edges: List[List[int]]) -> List[List[int]]:\n    for edge in edges:\n        edge.sort()\n    n_edges = list(sorted(edges, key=cmp_to_key(custom_cmp)))\n    return n_edges\n\ndef show(edges):\n    for edge in edges:\n        print('%d %d' % (edge[0], edge[1]))\n\nadj, n = read()\nedges = find_bridges(adj, n)\nn_edges = process_output(edges)\nshow(n_edges)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(int(3e6))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort()\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\nfrom sys import stdin\nreadline = stdin.readline\n\n\ndef main():\n    v, e = map(int, readline().split())\n    from collections import defaultdict\n    g = defaultdict(list)\n\n    for _ in range(e):\n        s, t = map(int, readline().split())\n        g[s].append(t)\n        g[t].append(s)\n\n    visited = set()\n    lowest = [None] * v\n    parent = [None] * v\n    prenum = [None] * v\n    child = defaultdict(list)\n    root = 0\n\n    # dfs??§tree?????????\n    stack = [(root, None)]\n    while stack:\n        u, prev = stack.pop()\n        if u not in visited:\n            parent[u] = prev\n            if prev is not None:\n                child[prev].append(u)\n            visited |= {u}\n            prenum[u] = lowest[u] = len(visited)\n\n        stack.extend([(v, u) for v in g[u] if v not in visited])\n\n    # lowest????¨????\n    from collections import Counter\n    leaf = [i for i in range(v) if not child[i]]\n    unfinished = Counter()\n    for li in leaf:\n        while li is not None:\n            candidate = [prenum[li]] + [prenum[i] for i in g[li] if i != parent[li]] + [lowest[i] for i in child[li]]\n            lowest[li] = min(candidate)\n            li = parent[li]\n            if li is not None and 1 < len(child[li]):\n                unfinished[li] += 1\n                if unfinished[li] < len(child[li]):\n                    break\n\n    # ????????????\n    bridge = []\n    for i in range(v):\n        if child[i]:\n            for j in child[i]:\n                if prenum[i] < lowest[j]:\n                    if i > j:\n                        i, j = j, i\n                    bridge.append((i, j))\n    bridge.sort()\n    for bi in bridge:\n        print(*bi)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        lowest[u] = min(lowest[u], prenum[u])\n        for v in adj_v:\n            l = min(lowest[u], lowest[v])\n            lowest[u] = l\n            lowest[v] = l\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\nimport sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj = [[] for i in range(V)]\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj[s].append(t)\n    adj[t].append(s)\n\n\n# dfs traverse\nprenum = [1] + [None] * (V - 1)\nparent = [0] * V\nlowest = [1] + [V] * (V - 1)\n\nimport collections\n\npath = collections.deque()\npath.append(0)\n\ncnt = 1\n\nwhile path:\n    u = path[-1]\n    adj_v = adj[u]\n    for v in adj_v:\n        if not prenum[v]:\n            parent[v] = u\n            path.append(v)\n            cnt += 1\n            prenum[v] = cnt\n            lowest[v] = cnt\n            adj[u].remove(v)\n            adj[v].remove(u)\n            break\n    if u == path[-1]:\n        for v in adj_v:\n            l = min(lowest[u], prenum[v])\n            lowest[u] = l\n            lowest[v] = l\n        p = parent[u]\n        lowest[p] = min(lowest[u], lowest[p])\n        path.pop()\n\n\n# output\n\nbridge = []\n\nfor u in range(1, V):\n    p = parent[u]\n    if lowest[p] != lowest[u]:\n        b = [p, u]\n        b.sort()\n        bridge.append(b)\n\nbridge.sort()\n\nfor b in bridge:\n    print(*b)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, M = map(int, readline().split())\n\nG = [[] for i in range(N)]\nfor i in range(M):\n    u, v = map(int, readline().split())\n    G[u].append(v)\n    G[v].append(u)\n\n# a chain decomposition\ndef construct(G, N):\n    P = [0]*N\n    G0 = [[] for i in range(N)]\n    V = []\n    lb = [0]*N\n    def dfs(v, p):\n        P[v] = p\n        V.append(v)\n        lb[v] = len(V)\n        for w in G[v]:\n            if w == p:\n                continue\n            if lb[w]:\n                if lb[v] < lb[w]:\n                    # a backedge\n                    G0[v].append(w)\n                continue\n            # a tree edge\n            dfs(w, v)\n    dfs(0, -1)\n\n    used = [0]*N\n    first = 1\n    B = []\n    used[0] = 1\n    ap = [0]*N\n    for u in V:\n        if not used[u]:\n            # (u, p) is a bridge\n            p = P[u]\n            B.append((u, p) if u < p else (p, u))\n            if len(G[u]) > 1:\n                ap[u] = 1\n            if len(G[p]) > 1:\n                ap[p] = 1\n        cycle = 0\n        for v in G0[u]:\n            w = v\n            while w != u and not used[w]:\n                used[w] = 1\n                w = P[w]\n            if w == u:\n                cycle = 1\n        if cycle:\n            if not first:\n                ap[u] = 1\n            first = 0\n    # v is a cut vertex\n    A = [v for v in range(N) if ap[v]]\n\n    return B, A\n\nB, A = construct(G, N)\n\nB.sort()\nfor u, v in B:\n    write(\"%d %d\\n\" % (u, v))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef seq():\n    a = 1\n    while True:\n        yield a\n        a += 1\n\ndef dfs(here, went, connect, discovery, low, answer, seq):\n    went |= {here}\n    discovery[here] = low[here] = next(seq)\n    child = 0\n    for con in connect[here]:\n        if con not in went:\n            parent[con] = here\n            child += 1\n            dfs(con, went, connect, discovery, low, answer, seq)\n            low[here] = min(low[here], low[con])\n            if discovery[here] < low[con]:\n                answer[min(here,con)].append(max(here,con))\n        elif parent[here] != con:\n            low[here] = min(low[here], discovery[con])\n\nvertices, edges = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nfor _ in range(edges):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = defaultdict(list)\nnew_seq = seq()\nwent = set()\ndiscovery = [0 for n in range(vertices)]\nlow = [float(\"inf\") for n in range(vertices)]\nparent = [None for n in range(vertices)]\ndfs(0, went, connect, discovery, low, answer, new_seq)\n\nfor k in range(answer.keys()):\n    for n in range(answer[k]):\n        print(k,n)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n5 4\n0 1\n1 2\n2 3\n3 4\n\noutput:\n0 1\n1 2\n2 3\n3 4\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(int(1e5))\n\n\ndef generate_adj_table(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        # undirected graph\n        init_adj_table[v_to].append(v_from)\n    return init_adj_table\n\n\ndef graph_dfs(u, visited, parent, low, disc):\n    global Time\n    # Count of children in current node\n    children = 0\n\n    # Mark the current node as visited and print it\n    visited[u] = True\n\n    # Initialize discovery time and low value\n    disc[u] = Time\n    low[u] = Time\n    Time += 1\n\n    # Recur for all the vertices adjacent to this vertex\n    for v in adj_table[u]:\n        # If v is not visited yet, then make it a child of u\n        # in DFS tree and recur for it\n        if not visited[v]:\n            parent[v] = u\n            children += 1\n            graph_dfs(v, visited, parent, low, disc)\n\n            # Check if the subtree rooted with v has a connection to\n            # one of the ancestors of u\n            low[u] = min(low[u], low[v])\n\n            ''' If the lowest vertex reachable from subtree\n            under v is below u in DFS tree, then u-v is\n            a bridge'''\n            if low[v] > disc[u]:\n                ans.append(sorted([u, v]))\n        elif v != parent[u]:  # Update low value of u for parent function calls.\n            low[u] = min(low[u], disc[v])\n\n    return None\n\n\ndef bridge():\n    visited = [False] * vertices\n    disc = [float(\"Inf\")] * vertices\n    low = [float(\"Inf\")] * vertices\n    parent = [-1] * vertices\n\n    for v in range(vertices):\n        if not visited[v]:\n            graph_dfs(v, visited, parent, low, disc)\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n    Time = 0\n    ans = []\n\n    init_adj_table = tuple([] for _ in range(vertices))\n    adj_table = generate_adj_table(v_info)\n    res = bridge()\n    res.sort()\n    for ele in res:\n        print(*ele)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N, M = map(int, input().split())\n    edges = [[] for _ in [0] * N]\n    for _ in [0] * M:\n        a, b = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    bridges = sorted((a, b) if a < b else (b, a) for a, b in get_lowlink(edges, M)[0])\n    for a, b in bridges:\n        print(a, b)\n\n\ndef get_lowlink(edges, edge_num):\n    import sys\n    sys.setrecursionlimit(10**7)\n\n    n = len(edges)\n    order = [-1] * n\n    low = [float(\"inf\")] * n\n    bridges = []\n    articulations = [0] if edge_num == n-1 and len(edges[0]) > 1 else []\n    append_bridge, append_articulation = bridges.append, articulations.append\n\n    def dfs(v, prev, k):\n        order[v] = low[v] = k\n\n        is_articulation = False\n        for dest in edges[v]:\n            if order[dest] == -1:\n                dfs(dest, v, k + 1)\n                if low[v] > low[dest]:\n                    low[v] = low[dest]\n                if order[v] < low[dest]:\n                    append_bridge((v, dest))\n                is_articulation |= order[v] <= low[dest]\n\n            elif dest != prev and low[v] > order[dest]:\n                low[v] = order[dest]\n\n        if v > 0 and is_articulation:\n            append_articulation(v)\n\n    dfs(0, 0, 0)\n    return bridges, articulations\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nN,M=MAP()\nnodes=[[] for i in range(N)]\nfor i in range(M):\n    u,v=MAP()\n    nodes[u].append(v)\n    nodes[v].append(u)\n\nvisited=[False]*N\ntimer=1\nprenum=[0]*(N+1)\nlowest=[0]*(N+1)\nans=[]\ndef rec(cur, prev):\n    global timer\n    # curを訪問した直後の処理\n    prenum[cur]=lowest[cur]=timer\n    timer+=1\n\n    visited[cur]=True\n    for nxt in nodes[cur]:\n        # 未訪問なら再帰探索する\n        if not visited[nxt]:\n            rec(nxt, cur)\n            # nxtの探索が終了した直後の処理\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n            # より近い経路を含まないなら橋とする\n            if lowest[nxt]==prenum[nxt]:\n                ans.append((cur, nxt))\n        # 訪問済の場合、親への経路は無視して、他は近い経路となるか確認を取る\n        elif nxt!=prev:\n            lowest[cur]=min(lowest[cur], lowest[nxt])\n\nrec(0, -1)\n\nans.sort()\nfor edge in ans:\n    print(*edge)\n\n"
  },
  {
    "language": "Rust",
    "code": "#[macro_use]\nmod input_mcr {\n    // ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n    // diff: using Parser\n    #[macro_export(local_inner_macros)]\n    macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\n    #[macro_export(local_inner_macros)]\n    macro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\n    #[macro_export(local_inner_macros)]\n    macro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, char_) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()[0]\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, line) => {\n        $parser.next_line()\n    };\n    ($parser:ident, line_) => {\n        $parser.next_line().chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, i64_) => {\n        $parser.fast_i64()\n    };\n    ($parser:ident, usize_) => {\n        $parser.fast_i64() as usize\n    };\n    ($parser:ident, usize1_) => {\n        ($parser.fast_i64() - 1) as usize\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\n    use std::io;\n    use std::io::BufRead;\n    use std::str;\n\n    // ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n    // ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n    // diff: using std::io::BufRead::fill_buf()\n    pub struct Parser<R> {\n        pub reader: R,\n        buf: Vec<u8>,\n        pos: usize,\n    }\n\n    impl Parser<io::Empty> {\n        pub fn from_str(s: &str) -> Parser<io::Empty> {\n            Parser {\n                reader: io::empty(),\n                buf: s.as_bytes().to_vec(),\n                pos: 0,\n            }\n        }\n    }\n\n    impl<R: BufRead> Parser<R> {\n        pub fn new(reader: R) -> Parser<R> {\n            Parser {\n                reader: reader,\n                buf: vec![],\n                pos: 0,\n            }\n        }\n        pub fn update_buf(&mut self) {\n            self.buf.clear();\n            self.pos = 0;\n            loop {\n                let (len, complete) = {\n                    let buf2 = self.reader.fill_buf().unwrap();\n                    self.buf.extend_from_slice(buf2);\n                    let len = buf2.len();\n                    (len, buf2[len - 1] <= 0x20)\n                };\n                self.reader.consume(len);\n                if complete {\n                    break;\n                }\n            }\n        }\n        pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n            loop {\n                let mut begin = self.pos;\n                while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                    begin += 1;\n                }\n                let mut end = begin;\n                while end < self.buf.len() && (self.buf[end] > 0x20) {\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.parse::<T>();\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n        pub fn next_line(&mut self) -> String {\n            loop {\n                let mut begin = self.pos;\n                if begin < self.buf.len() && (self.buf[begin] < 0x20) {\n                    begin += 1;\n                }\n                let mut end = begin;\n                while end < self.buf.len() && (self.buf[end] >= 0x20) {\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.to_string();\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n        pub fn fast_i64(&mut self) -> i64 {\n            loop {\n                let mut begin = self.pos;\n                while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                    begin += 1;\n                }\n                if begin == self.buf.len() {\n                    self.update_buf();\n                    continue;\n                }\n                let mut res = 0;\n                let (is_positive, mut end) = match self.buf[begin] {\n                    b'+' => (true, begin + 1),\n                    b'-' => (false, begin + 1),\n                    _ => (true, begin),\n                };\n                while end < self.buf.len() && (self.buf[end] > 0x20) {\n                    res = res * 10 + (self.buf[end] as i64 - '0' as i64);\n                    end += 1;\n                }\n                if begin != self.buf.len() {\n                    self.pos = end;\n                    return if is_positive { res } else { -res };\n                } else {\n                    self.update_buf();\n                }\n            }\n        }\n    }\n}\n\nmod unionfind {\n    struct UnionFindNode {\n        parent: usize,\n        num: usize,\n    }\n\n    impl UnionFindNode {\n        fn new(parent: usize) -> UnionFindNode {\n            UnionFindNode {\n                parent: parent,\n                num: 1,\n            }\n        }\n    }\n\n    pub struct UnionFind(Vec<UnionFindNode>);\n\n    impl UnionFind {\n        pub fn new(n: usize) -> UnionFind {\n            let mut xs = vec![];\n            for i in 0..n {\n                xs.push(UnionFindNode::new(i));\n            }\n            UnionFind(xs)\n        }\n        pub fn root(&mut self, i: usize) -> usize {\n            let parent = self.0[i].parent;\n            if parent == i {\n                i\n            } else {\n                let res = self.root(parent);\n                self.0[i].parent = res;\n                res\n            }\n        }\n        pub fn unite(&mut self, i: usize, k: usize) {\n            let i = self.root(i);\n            let k = self.root(k);\n            if i == k {\n                return;\n            }\n            let (i, k) = if self.0[i].num < self.0[k].num {\n                (i, k)\n            } else {\n                (k, i)\n            };\n            self.0[i].parent = k;\n            self.0[k].num += self.0[i].num;\n        }\n        pub fn is_same_set(&mut self, i: usize, k: usize) -> bool {\n            self.root(i) == self.root(k)\n        }\n        pub fn num(&mut self, i: usize) -> usize {\n            let i = self.root(i);\n            self.0[i].num\n        }\n    }\n}\n\nuse input_mcr::*;\nuse std::cmp::*;\n\nuse unionfind::*;\n\nstruct RootedTreeWithLCA {\n    parent: Vec<Vec<usize>>,\n    depth: Vec<usize>,\n}\n\nimpl RootedTreeWithLCA {\n    pub fn new(ps: &[usize]) -> RootedTreeWithLCA {\n        let n = ps.len();\n        let m = n.next_power_of_two().trailing_zeros() as usize + 1;\n        let mut parent = vec![vec![]; m];\n        for k in 0..n {\n            parent[0].push(ps[k]);\n        }\n        for i in 1..m {\n            for k in 0..n {\n                let a = parent[i - 1][k];\n                let b = parent[i - 1][a];\n                parent[i].push(b);\n            }\n        }\n        let mut graph = vec![vec![]; n];\n        for i in 0..n {\n            graph[ps[i]].push(i);\n        }\n        let inf = 1 << 50;\n        let mut depth = vec![inf; n];\n        depth[0] = 0;\n        let mut q = std::collections::VecDeque::new();\n        q.push_back(0);\n        while let Some(v) = q.pop_front() {\n            for &next in &graph[v] {\n                if depth[v] + 1 < depth[next] {\n                    depth[next] = depth[v] + 1;\n                    q.push_back(next);\n                }\n            }\n        }\n        // eprintln!(\"depth = {:?}\", depth);\n        RootedTreeWithLCA {\n            parent: parent,\n            depth: depth,\n        }\n    }\n    pub fn lca(&self, x: usize, y: usize) -> usize {\n        let (mut x, mut y) = if self.depth[x] <= self.depth[y] {\n            (x, y)\n        } else {\n            (y, x)\n        };\n        let m = self.parent.len();\n        //// eprintln!(\"(1): x = {}, y = {}\", x, y);\n        for i in (0..m).rev() {\n            if (self.depth[y] - self.depth[x]) & (1 << i) != 0 {\n                y = self.parent[i][y];\n            }\n        }\n        //// eprintln!(\"(2): x = {}, y = {}\", x, y);\n        if x == y {\n            return x;\n        }\n        assert_eq!(self.depth[x], self.depth[y]);\n        for i in (0..m).rev() {\n            if self.parent[i][x] != self.parent[i][y] {\n                x = self.parent[i][x];\n                y = self.parent[i][y];\n            }\n        }\n        //// eprintln!(\"(3): x = {}, y = {}\", x, y);\n        assert_eq!(self.parent[0][x], self.parent[0][y]);\n        self.parent[0][x]\n    }\n    pub fn dist(&self, x: usize, y: usize) -> usize {\n        self.depth[x] + self.depth[y] - 2 * self.depth[self.lca(x, y)]\n    }\n}\n\nfn two_edge_connected_components(\n    n: usize,\n    es: &[(usize, usize)],\n) -> (UnionFind, RootedTreeWithLCA, Vec<(usize, usize)>) {\n    let mut graph = vec![vec![]; n];\n    for &(s, t) in es {\n        graph[s].push(t);\n        graph[t].push(s);\n    }\n\n    fn dfs(\n        graph: &Vec<Vec<usize>>,\n        i: usize,\n        prev: Option<usize>,\n        count: &mut Vec<i64>,\n        ds: &mut Vec<Option<i64>>,\n        uf: &mut UnionFind,\n        new_edges: &mut Vec<(usize, usize)>,\n    ) -> i64 {\n        for &next in &graph[i] {\n            if Some(next) == prev {\n                continue;\n            }\n            if ds[next].is_none() {\n                ds[next] = Some(ds[i].unwrap() + 1);\n                let t = dfs(graph, next, Some(i), count, ds, uf, new_edges);\n                // eprintln!(\"fe: {} -> {}, t = {}\", i, next, t);\n                count[i] += t;\n                if t != 0 {\n                    uf.unite(i, next);\n                } else {\n                    new_edges.push((i, next));\n                }\n            } else if ds[next].unwrap() < ds[i].unwrap() {\n                // eprintln!(\"be: {}+1, {}-1\", next, i);\n                count[next] += 1;\n                count[i] -= 1;\n            }\n        }\n        count[i]\n    }\n\n    let mut count = vec![0; n];\n    let mut ds = vec![None; n];\n    ds[0] = Some(0);\n    let mut uf = UnionFind::new(n);\n    let mut bridges = vec![];\n    dfs(&graph, 0, None, &mut count, &mut ds, &mut uf, &mut bridges);\n    let mut ps: Vec<usize> = (0..n).collect();\n    for &(s, t) in &bridges {\n        ps[uf.root(t)] = uf.root(s);\n    }\n    // eprintln!(\"ps = {:?}\", ps);\n    (uf, RootedTreeWithLCA::new(&ps), bridges)\n}\n\nfn main() {\n    input! {\n        n: usize,\n        m: usize,\n        es: [(usize,usize); m],\n    }\n    let (_, _, mut bridges) = two_edge_connected_components(n, &es);\n    for i in 0..bridges.len() {\n        let (a, b) = bridges[i];\n        bridges[i] = (min(a, b), max(a, b));\n    }\n    bridges.sort();\n    for &x in &bridges {\n        println!(\"{} {}\", x.0, x.1);\n    }\n}\n\nfn main3() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize,\n    }\n    let mut ps: Vec<usize> = (0..n).collect();\n    for i in 0..n {\n        input! {\n            parser = parser,\n            m: usize,\n            xs: [usize; m],\n        }\n        for &x in &xs {\n            ps[x] = i;\n        }\n    }\n    let r_tree = RootedTreeWithLCA::new(&ps);\n    input! {\n        parser = parser,\n        q: usize,\n        qs: [(usize,usize); q],\n    }\n    for &(s, t) in &qs {\n        println!(\"{}\", r_tree.lca(s, t));\n    }\n}\n\nfn main2() {\n    input! {\n        n: usize,\n        m: usize,\n        es: [(usize1,usize1); m],\n        q: usize,\n        qs: [(usize1,usize1,usize1); q],\n    }\n    let (mut uf, r_tree, _) = two_edge_connected_components(n, &es);\n    for i in 0..n {\n        // eprintln!(\"root of {} = {}\", i, uf.root(i));\n    }\n    for &(a, b, c) in &qs {\n        let a = uf.root(a);\n        let b = uf.root(b);\n        let c = uf.root(c);\n        // eprintln!(\"a = {}, b = {}, c = {}\", a, b, c);\n        //// eprintln!(\"a^b = {}\", r_tree.lca(a,b));\n        //// eprintln!(\"b^a = {}\", r_tree.lca(b,a));\n        //// eprintln!(\"a^c = {}\", r_tree.lca(a,c));\n        //// eprintln!(\"c^a = {}\", r_tree.lca(c,a));\n        //// eprintln!(\"b^c = {}\", r_tree.lca(b,c));\n        //// eprintln!(\"c^b = {}\", r_tree.lca(c,b));\n        let res = r_tree.dist(a, b) + r_tree.dist(b, c) == r_tree.dist(a, c);\n        println!(\"{}\", if res { \"OK\" } else { \"NG\" });\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "/// Thank you tanakh!!!\n///  https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let mut s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!(n: usize, m: usize, edges: [(usize, usize); m]);\n    let mut graph = vec![vec![]; n];\n    for &(a, b) in edges.iter() {\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n\n    let mut low_link = LowLink::new(n);\n    low_link.run(&graph);\n    low_link.articulations.sort();\n    low_link.bridges.sort();\n\n    for &(a, b) in low_link.bridges.iter() {\n        println!(\"{} {}\", a, b);\n    }\n}\n\nstruct LowLink {\n    articulations: Vec<usize>,\n    bridges: Vec<(usize, usize)>,\n    visit: Vec<bool>,\n    ord: Vec<usize>,\n    low: Vec<usize>,\n    k: usize,\n}\n\nimpl LowLink {\n    fn new(n: usize) -> Self {\n        LowLink {\n            articulations: vec![],\n            bridges: vec![],\n            visit: vec![false; n],\n            ord: vec![0; n],\n            low: vec![0; n],\n            k: 0,\n        }\n    }\n\n    fn run(&mut self, graph: &Vec<Vec<usize>>) {\n        let n = graph.len();\n        for i in 0..n {\n            if !self.visit[i] {\n                self.dfs(i, None, graph);\n            }\n        }\n    }\n    fn dfs(&mut self, v: usize, p: Option<usize>, graph: &Vec<Vec<usize>>) {\n        self.visit[v] = true;\n        self.ord[v] = self.k;\n        self.k += 1;\n        self.low[v] = self.ord[v];\n\n        let mut is_articulation = false;\n        let mut count = 0;\n        for &next in graph[v].iter() {\n            if !self.visit[next] {\n                count += 1;\n                self.dfs(next, Some(v), graph);\n                if self.low[v] > self.low[next] {\n                    self.low[v] = self.low[next];\n                }\n                if p.is_some() && self.ord[v] <= self.low[next] {\n                    is_articulation = true;\n                }\n                if self.ord[v] < self.low[next] {\n                    let (v, next) = if v < next { (v, next) } else { (next, v) };\n                    self.bridges.push((v, next));\n                }\n            } else if p.is_none() || next != p.unwrap() && self.low[v] > self.ord[next] {\n                self.low[v] = self.ord[next];\n            }\n        }\n\n        if p.is_none() && count > 1 {\n            is_articulation = true;\n        }\n        if is_articulation {\n            self.articulations.push(v);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let (n, e) = get!(usize, usize);\n    let st = get!(usize, usize; e);\n\n    let mut g = vec![Vec::new(); n];\n\n    for (s, t) in st {\n        g[s].push(t);\n        g[t].push(s);\n    }\n\n    let mut que = VecDeque::new();\n    que.push_back((0, 0));\n\n    let mut visited = vec![false; n];\n    let mut bridge = vec![true; n];\n    let mut parent = vec![0; n];\n\n    while let Some((i, p)) = que.pop_front() {\n        if visited[i] {\n            bridge[p] = false;\n            continue;\n        }\n        parent[i] = p;\n        visited[i] = true;\n\n        for &to in &g[i] {\n            if to != p {\n                if !visited[to] {\n                    que.push_back((to, i));\n                } else {\n                    bridge[i] = false;\n                }\n            }\n        }\n    }\n\n    let mut ans: Vec<(usize, usize)> = (1..n)\n        .filter(|&i| bridge[i])\n        .map(|i| (min(i, parent[i]), max(i, parent[i])))\n        .collect();\n\n    ans.sort();\n\n    util::with_bufwriter(|mut out| {\n        for (s, t) in ans {\n            writeln!(out, \"{} {}\", s, t).unwrap();\n        }\n    });\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn minmax(p: (usize, usize)) -> (usize, usize) {\n    if p.0 <= p.1 {\n        p\n    } else {\n        (p.1, p.0)\n    }\n}\n\nstruct LowLink<'a> {\n    g: &'a [Vec<usize>],\n    used: Vec<bool>,\n    ord: Vec<usize>,\n    low: Vec<usize>,\n    articulation: Vec<usize>,\n    bridge: Vec<(usize, usize)>,\n}\n\nimpl <'a> LowLink<'a> {\n    fn new(g: &'a [Vec<usize>]) -> LowLink {\n        let n = g.len();\n        let mut used = vec![false; n];\n        let mut ord = vec![0; n];\n        let mut low = vec![0; n];\n        let articulation = vec![];\n        let bridge = vec![];\n        LowLink {\n            g,\n            used,\n            ord,\n            low,\n            articulation,\n            bridge,\n        }\n    }\n    fn build(&mut self) {\n        self.do_build(0, 0, None);\n        self.articulation.sort();\n        self.bridge.sort();\n    }\n    fn do_build(&mut self, u: usize, k: usize, par: Option<usize>) -> usize {\n        let mut k = k;\n        self.used[u] = true;\n        self.ord[u] = k;\n        k += 1;\n        self.low[u] = self.ord[u];\n        let mut is_articulation = false;\n        let mut cnt = 0;\n        for &v in &self.g[u] {\n            if !self.used[v] {\n               cnt += 1; \n               k = self.do_build(v, k, Some(u));\n               self.low[u] = std::cmp::min(self.low[u], self.low[v]);\n               is_articulation |= par.is_some() && self.low[v] >= self.ord[u];\n               if self.ord[u] < self.low[v] {\n                   self.bridge.push(minmax((u, v)));\n               }\n            } else if Some(v) != par {\n                self.low[u] = std::cmp::min(self.low[u], self.ord[v]);\n            } else {}\n        }\n        is_articulation |= par.is_none() && cnt > 1;\n        if is_articulation {\n            self.articulation.push(u);\n        }\n        k\n    }\n}\nfn solve() {\n    input! {\n        V: usize, E: usize,\n        ES: [(usize, usize); E],\n    }\n\n    let mut g = vec![vec![]; V];\n    for i in 0..E {\n        let (s,t) = ES[i];\n        g[s].push(t);\n        g[t].push(s);\n    }\n\n    let mut lowlink = LowLink::new(&g);\n    lowlink.build();\n\n    let mut bri = lowlink.bridge;\n    bri.sort();\n\n    for x in bri {\n        println!(\"{} {}\", x.0, x.1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\nfn bridges(g: &[Vec<usize>]) -> Vec<(usize, usize)> {\n    fn dfs(\n        i: usize,\n        p: usize,\n        g: &[Vec<usize>],\n        t: usize,\n        visited: &mut [bool],\n        pre: &mut [usize],\n        low: &mut [usize],\n        res: &mut Vec<(usize, usize)>,\n    ) -> usize {\n        visited[i] = true;\n        pre[i] = t;\n        low[i] = t;\n\n        for &to in &g[i] {\n            if p != to {\n                if visited[to] {\n                    low[i] = min(low[i], low[to]);\n                } else {\n                    low[i] = min(low[i], dfs(to, i, g, t + 1, visited, pre, low, res));\n\n                    if low[to] == pre[to] {\n                        res.push((i, to));\n                    }\n                }\n            }\n        }\n\n        low[i]\n    }\n\n    let n = g.len();\n    let mut visited = vec![false; n];\n    let mut pre = vec![0; n];\n    let mut low = vec![0; n];\n    let mut res = Vec::new();\n\n    dfs(0, 0, g, 0, &mut visited, &mut pre, &mut low, &mut res);\n    res\n}\n\nfn solve() {\n    let (n, e) = get!(usize, usize);\n    let st = get!(usize, usize; e);\n\n    let mut g = vec![Vec::new(); n];\n\n    for (s, t) in st {\n        g[s].push(t);\n        g[t].push(s);\n    }\n\n    let mut ans = bridges(&g);\n\n    for st in &mut ans {\n        *st = (min(st.0, st.1), (max(st.0, st.1)));\n    }\n\n    ans.sort();\n\n    util::with_bufwriter(|mut out| {\n        for (s, t) in ans {\n            writeln!(out, \"{} {}\", s, t).unwrap();\n        }\n    });\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "pub mod spaghetti_source {\n\npub mod graph {\n\n    pub mod articulation_point {\n        use super::{Edge, Graph};\n        use std::cmp::{max, min, Ordering};\n        use std::collections::{BTreeSet, VecDeque};\n        pub fn articulation_point(g: &Graph) -> (Vec<usize>, Vec<EdgeSet>) {\n            let n = g.len();\n            let mut low = vec![0 ; n];\n            let mut num = vec![0 ; n];\n            let mut art = BTreeSet::new();\n            let mut bcomp = Vec::new();\n            let mut s = VecDeque::new();\n            for u in 0..n {\n                if num[u] == 0 {\n                    let mut time = 0;\n                    visit(g, u, &mut art, &mut bcomp, &mut s, &mut num,\n                          &mut low, &mut time);\n                }\n            }\n            (art.into_iter().collect(), bcomp)\n        }\n        fn visit(g: &Graph, v: usize, art: &mut BTreeSet<usize>,\n                 bcomp: &mut Vec<EdgeSet>, s: &mut VecDeque<Edge>,\n                 num: &mut Vec<i32>, low: &mut Vec<i32>, time: &mut i32) {\n            *time += 1;\n            low[v] = *time;\n            num[v] = *time;\n            for e in &g[v] {\n                let w = e.dst;\n                if num[w] < num[v] { s.push_back(e.clone()); }\n                if num[w] == 0 {\n                    visit(g, w, art, bcomp, s, num, low, time);\n                    low[v] = min(low[v], low[w]);\n                    if (num[v] == 1 && num[w] != 2) ||\n                           (num[v] != 1 && low[w] >= num[v]) {\n                        art.insert(v);\n                    }\n                    if low[w] >= num[v] {\n                        bcomp.push(EdgeSet::new());\n                        while let Some(f) = s.pop_back() {\n                            let n = bcomp.len();\n                            let end = f.src == v && f.dst == w;\n                            bcomp[n - 1].insert(UndirectEdge(f));\n                            if end { break ; }\n                        }\n                    }\n                } else { low[v] = min(low[v], num[w]); }\n            }\n        }\n        pub type EdgeSet = BTreeSet<UndirectEdge>;\n        #[derive(Eq, PartialEq, Debug)]\n        pub struct UndirectEdge(Edge);\n        impl UndirectEdge {\n            pub fn min_v(&self) -> usize { min(self.0.src, self.0.dst) }\n            pub fn max_v(&self) -> usize { max(self.0.src, self.0.dst) }\n        }\n        impl Ord for UndirectEdge {\n            fn cmp(&self, other: &UndirectEdge) -> Ordering {\n                self.min_v().cmp(&other.min_v()).then_with(||\n                                                               self.max_v().cmp(&other.max_v()))\n            }\n        }\n        impl PartialOrd for UndirectEdge {\n            fn partial_cmp(&self, other: &UndirectEdge) -> Option<Ordering> {\n                Some(self.cmp(other))\n            }\n        }\n    }\n    pub mod bridge {\n        use super::{Edge, Graph};\n        use std::collections::VecDeque;\n        pub fn bridge(g: &Graph) -> (Vec<Edge>, Vec<Vec<usize>>) {\n            let n = g.len();\n            let mut num = vec![0 ; n];\n            let mut in_stq = vec![false ; n];\n            let mut roots = VecDeque::new();\n            let mut stq = VecDeque::new();\n            let mut time = 0;\n            let mut brdg = VecDeque::new();\n            let mut tecomp = Vec::new();\n            for u in 0..n {\n                if num[u] == 0 {\n                    visit(g, u, n, &mut brdg, &mut tecomp, &mut roots,\n                          &mut stq, &mut in_stq, &mut num, &mut time);\n                    brdg.pop_back();\n                }\n            }\n            (brdg.into_iter().collect(), tecomp)\n        }\n        fn visit(g: &Graph, v: usize, u: usize, brdg: &mut VecDeque<Edge>,\n                 tecomp: &mut Vec<Vec<usize>>, roots: &mut VecDeque<usize>,\n                 stq: &mut VecDeque<usize>, in_stq: &mut Vec<bool>,\n                 num: &mut Vec<usize>, time: &mut usize) {\n            *time += 1;\n            num[v] = *time;\n            stq.push_back(v);\n            in_stq[v] = true;\n            roots.push_back(v);\n            for e in &g[v] {\n                let w = e.dst;\n                if num[w] == 0 {\n                    visit(g, w, v, brdg, tecomp, roots, stq, in_stq, num,\n                          time);\n                } else if u != w && in_stq[w] {\n                    while num[*roots.back().unwrap()] > num[w] {\n                        roots.pop_back();\n                    }\n                }\n            }\n            if v == *roots.back().unwrap() {\n                brdg.push_back(Edge{src: u, dst: v, weight: 0,});\n                tecomp.push(Vec::new());\n                loop  {\n                    let w = stq.pop_back().unwrap();\n                    in_stq[w] = false;\n                    let n = tecomp.len();\n                    tecomp[n - 1].push(w);\n                    if v == w { break ; }\n                }\n                roots.pop_back();\n            }\n        }\n    }\n    use std::cmp::Ordering;\n    pub type Weight = i32;\n    #[derive(Eq, PartialEq, Debug, Clone)]\n    pub struct Edge {\n        pub src: usize,\n        pub dst: usize,\n        pub weight: Weight,\n    }\n    impl Ord for Edge {\n        fn cmp(&self, other: &Edge) -> Ordering {\n            self.weight.cmp(&other.weight).reverse().then_with(||\n                                                                   self.src.cmp(&other.src)).then_with(||\n                                                                                                           self.dst.cmp(&other.dst))\n        }\n    }\n    impl PartialOrd for Edge {\n        fn partial_cmp(&self, other: &Edge) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }\n    }\n    pub type Edges = Vec<Edge>;\n    pub type Graph = Vec<Edges>;\n    pub type Array = Vec<Weight>;\n    pub type Matrix = Vec<Array>;\n}\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() { assert_eq!(2 + 2 , 4); }\n}\n}\n\n\nuse spaghetti_source::graph::bridge::bridge;\nuse spaghetti_source::graph::{Edge, Edges};\n\nfn main() {\n    let (n, m) = readln();\n    let mut g = vec![Edges::new(); n];\n    for _ in 0..m {\n        let (x, y): (usize, usize) = readln();\n        g[x].push(Edge {\n            src: x,\n            dst: y,\n            weight: 0,\n        });\n        g[y].push(Edge {\n            src: y,\n            dst: x,\n            weight: 0,\n        });\n    }\n    let (brdg, _) = bridge(&g);\n    let mut answer = brdg.into_iter()\n        .map(|e| Edge {\n            src: std::cmp::min(e.src, e.dst),\n            dst: std::cmp::max(e.src, e.dst),\n            weight: e.weight,\n        })\n        .collect::<Vec<_>>();\n    answer.sort();\n    for e in answer {\n        println!(\"{} {}\", e.src, e.dst);\n    }\n}\n\npub trait FromLn {\n    fn fromln(s: &str) -> Self;\n}\npub fn readln<T: FromLn>() -> T {\n    let mut buf = String::new();\n    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();\n    T::fromln(buf.trim())\n}\npub fn readlns<T: FromLn>(n: usize) -> Vec<T> {\n    let mut vs = vec![];\n    for _ in 0..n {\n        vs.push(readln());\n    }\n    vs\n}\nmacro_rules! fromln_primitives {\n    ($($t:ty),*) => { $(\n        impl FromLn for $t {\n            fn fromln(s: &str) -> $t {\n                s.parse().unwrap()\n            }\n        }\n    )* }\n}\nfromln_primitives!(String, bool, f32, f64, isize, i8, i16, i32, i64, usize, u8, u16, u32, u64);\nimpl<T> FromLn for Vec<T>\nwhere\n    T: FromLn,\n{\n    fn fromln(s: &str) -> Vec<T> {\n        s.split_whitespace().map(T::fromln).collect()\n    }\n}\nimpl FromLn for Vec<char> {\n    fn fromln(s: &str) -> Vec<char> {\n        s.chars().collect()\n    }\n}\nmacro_rules! fromln_tuple {\n    ($($t:ident),*) => {\n        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {\n            fn fromln(s: &str) -> ($($t),*) {\n                let mut it = s.split_whitespace();\n                let t = ($($t::fromln(it.next().unwrap())),*);\n                assert_eq!(it.next(), None);\n                t\n            }\n        }\n    }\n}\nfromln_tuple!(A, B);\nfromln_tuple!(A, B, C);\nfromln_tuple!(A, B, C, D);\nfromln_tuple!(A, B, C, D, E);\nfromln_tuple!(A, B, C, D, E, F);\n\n"
  },
  {
    "language": "Rust",
    "code": "fn solve(edges: Vec<Vec<usize>>, nodes: usize) {\n    let mut is_used: Vec<bool> = vec![false; nodes];\n    let mut lowlink: Vec<usize> = vec![1000000000; nodes];\n    let mut orders: Vec<usize> = vec![0; nodes];\n    let mut order = 0;\n    let mut is_dfs_edge: Vec<_> = edges.iter().map(|es| vec![false; es.len()]).collect();\n    let mut dfs_stack = vec![];\n    let mut bridges = vec![];\n    fn min(x: usize, y: usize) -> usize {\n        if x < y {\n            x\n        } else {\n            y\n        }\n    }\n    fn max(x: usize, y: usize) -> usize {\n        if x < y {\n            y\n        } else {\n            x\n        }\n    }\n\n    for i in 0..nodes {\n        if is_used[i] {\n            continue;\n        }\n        dfs_stack.push(i);\n        // Root node\n        'outer: while !dfs_stack.is_empty() {\n            let node = *dfs_stack.last().unwrap();\n            if !is_used[node] {\n                is_used[node] = true;\n                orders[node] = order;\n                lowlink[node] = order;\n                order += 1;\n            }\n            for (idx, &to) in edges[node].iter().enumerate() {\n                if !is_used[to] {\n                    // DFS.\n                    dfs_stack.push(to);\n                    is_dfs_edge[node][idx] = true;\n                    continue 'outer;\n                }\n            }\n            let last = dfs_stack.pop().unwrap();\n            let parent = *dfs_stack.last().unwrap_or(&10000000);\n            for (&to, &is_dfs) in edges[last].iter().zip(is_dfs_edge[node].iter()) {\n                if to == parent {\n                    continue;\n                } else if is_dfs {\n                    let low = lowlink[to];\n                    lowlink[last] = min(lowlink[last], low);\n                } else {\n                    lowlink[last] = min(lowlink[last], orders[to]);\n                }\n                if orders[last] < lowlink[to] {\n                    let from = min(last, to);\n                    let to = max(last, to);\n                    bridges.push((from, to));\n                }\n            }\n        }\n    }\n    bridges.sort();\n    for (s, t) in bridges {\n        println!(\"{} {}\", s, t);\n    }\n}\n\nfn main() {\n    use std::io::{BufRead, BufReader};\n    let input = std::io::stdin();\n    let input: Vec<_> = BufReader::new(input.lock())\n        .lines()\n        .filter_map(|e| e.ok())\n        .collect();\n    let (nodes, _num_edges) = {\n        let x: Vec<usize> = input[0]\n            .split_whitespace()\n            .filter_map(|e| e.parse().ok())\n            .collect();\n        (x[0], x[1])\n    };\n    let mut edges: Vec<Vec<_>> = vec![vec![]; nodes];\n    for line in input[1..].iter() {\n        let edge: Vec<usize> = line\n            .split_whitespace()\n            .filter_map(|e| e.parse().ok())\n            .collect();\n        edges[edge[0]].push(edge[1]);\n        edges[edge[1]].push(edge[0]);\n    }\n    solve(edges, nodes);\n}\n\n"
  }
]