[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1000\n\nint graph[MAX_NODES][MAX_NODES];\nint visited[MAX_NODES];\nint low[MAX_NODES];\nint disc[MAX_NODES];\nint parent[MAX_NODES];\nint time_stamp;\nint num_nodes, num_edges;\n\nvoid add_edge(int u, int v) {\n    graph[u][++graph[u][0]] = v;\n    graph[v][++graph[v][0]] = u;\n}\n\nvoid find_bridges(int u, int bridges[MAX_NODES][2], int* bridge_count) {\n    visited[u] = 1;\n    disc[u] = low[u] = ++time_stamp;\n\n    for (int i = 1; i <= graph[u][0]; i++) {\n        int v = graph[u][i];\n\n        if (!visited[v]) {\n            parent[v] = u;\n            find_bridges(v, bridges, bridge_count);\n            low[u] = (low[u] < low[v]) ? low[u] : low[v];\n\n            if (low[v] > disc[u]) {\n                if (u < v) {\n                    bridges[*bridge_count][0] = u;\n                    bridges[*bridge_count][1] = v;\n                } else {\n                    bridges[*bridge_count][0] = v;\n                    bridges[*bridge_count][1] = u;\n                }\n                (*bridge_count)++;\n            }\n        } else if (v != parent[u]) {\n            low[u] = (low[u] < disc[v]) ? low[u] : disc[v];\n        }\n    }\n}\n\nint compare(const void* a, const void* b) {\n    int* x = *(int**)a;\n    int* y = *(int**)b;\n    if (x[0] != y[0]) return x[0] - y[0];\n    return x[1] - y[1];\n}\n\nint main() {\n    scanf(\"%d %d\", &num_nodes, &num_edges);\n    memset(graph, 0, sizeof(graph));\n    memset(visited, 0, sizeof(visited));\n    memset(parent, -1, sizeof(parent));\n\n    for (int i = 0; i < num_edges; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    time_stamp = 0;\n    int bridges[MAX_NODES][2];\n    int bridge_count = 0;\n\n    for (int i = 0; i < num_nodes; i++) {\n        if (!visited[i]) {\n            find_bridges(i, bridges, &bridge_count);\n        }\n    }\n\n    qsort(bridges, bridge_count, sizeof(bridges[0]), compare);\n\n    for (int i = 0; i < bridge_count; i++) {\n        printf(\"%d %d\\n\", bridges[i][0], bridges[i][1]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nEdge edges[MAX];\nint adj[MAX][MAX];\nint adj_size[MAX];\nint visited[MAX];\nint discovery[MAX];\nint low[MAX];\nint parent[MAX];\nint time;\nint bridge_count;\nEdge bridges[MAX];\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nvoid dfs(int u) {\n    visited[u] = 1;\n    discovery[u] = low[u] = ++time;\n    \n    for (int i = 0; i < adj_size[u]; ++i) {\n        int v = adj[u][i];\n        if (!visited[v]) {\n            parent[v] = u;\n            dfs(v);\n            low[u] = min(low[u], low[v]);\n            if (low[v] > discovery[u]) {\n                int a = u < v ? u : v;\n                int b = u < v ? v : u;\n                bridges[bridge_count].u = a;\n                bridges[bridge_count].v = b;\n                bridge_count++;\n            }\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], discovery[v]);\n        }\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    if (edgeA->u != edgeB->u) {\n        return edgeA->u - edgeB->u;\n    } else {\n        return edgeA->v - edgeB->v;\n    }\n}\n\nint main() {\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    \n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges[i].u = u;\n        edges[i].v = v;\n        adj[u][adj_size[u]++] = v;\n        adj[v][adj_size[v]++] = u;\n    }\n    \n    for (int i = 0; i < V; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    \n    qsort(bridges, bridge_count, sizeof(Edge), compare);\n    \n    for (int i = 0; i < bridge_count; ++i) {\n        printf(\"%d %d\\n\", bridges[i].u, bridges[i].v);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> disc, low;\nvector<bool> visited;\nvector<pair<int, int>> bridges;\nint timeCounter;\n\nvoid dfs(int u, int parent = -1) {\n    visited[u] = true;\n    disc[u] = low[u] = ++timeCounter;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (visited[v]) {\n            low[u] = min(low[u], disc[v]);\n        } else {\n            dfs(v, u);\n            low[u] = min(low[u], low[v]);\n            if (low[v] > disc[u]) {\n                bridges.push_back({min(u, v), max(u, v)});\n            }\n        }\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    adj.resize(V);\n    disc.resize(V, 0);\n    low.resize(V, 0);\n    visited.resize(V, false);\n    timeCounter = 0;\n\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int i = 0; i < V; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    sort(bridges.begin(), bridges.end());\n    for (auto& bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BridgesInGraph {\n    private int V;\n    private LinkedList<Integer> adj[];\n    private int time = 0;\n    private static final int NIL = -1;\n\n    BridgesInGraph(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList();\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n        adj[w].add(v);\n    }\n\n    void bridgeUtil(int u, boolean visited[], int disc[], int low[], int parent[], List<int[]> bridges) {\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        Iterator<Integer> i = adj[u].iterator();\n        while (i.hasNext()) {\n            int v = i.next();\n            if (!visited[v]) {\n                parent[v] = u;\n                bridgeUtil(v, visited, disc, low, parent, bridges);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if (low[v] > disc[u]) {\n                    int[] edge = new int[]{Math.min(u, v), Math.max(u, v)};\n                    bridges.add(edge);\n                }\n            } else if (v != parent[u]) {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n    List<int[]> getBridges() {\n        boolean visited[] = new boolean[V];\n        int disc[] = new int[V];\n        int low[] = new int[V];\n        int parent[] = new int[V];\n        List<int[]> bridges = new ArrayList<>();\n\n        for (int i = 0; i < V; i++) {\n            parent[i] = NIL;\n            visited[i] = false;\n        }\n\n        for (int i = 0; i < V; i++)\n            if (!visited[i])\n                bridgeUtil(i, visited, disc, low, parent, bridges);\n\n        bridges.sort((a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n\n        return bridges;\n    }\n\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        BridgesInGraph g = new BridgesInGraph(V);\n\n        for (int i = 0; i < E; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            g.addEdge(u, v);\n        }\n\n        List<int[]> bridges = g.getBridges();\n        for (int[] edge : bridges) {\n            System.out.println(edge[0] + \" \" + edge[1]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:22:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FindBridges {\n    private static List<List<Integer>> graph;\n    private static int[] disc;\n    private static int[] low;\n    private static int[] parent;\n    private static boolean[] visited;\n    private static int time;\n    private static List<int[]> bridges;\n\n    public static List<int[]> findBridges(int n, int[][] edges) {\n        graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        disc = new int[n];\n        low = new int[n];\n        parent = new int[n];\n        visited = new boolean[n];\n        time = 0;\n        bridges = new ArrayList<>();\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i);\n            }\n        }\n        \n        bridges.sort((a, b) -> {\n            if (a[0] != b[0]) return Integer.compare(a[0], b[0]);\n            return Integer.compare(a[1], b[1]);\n        });\n        \n        return bridges;\n    }\n    \n    private static void dfs(int u) {\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v);\n                \n                low[u] = Math.min(low[u], low[v]);\n                \n                if (low[v] > disc[u]) {\n                    bridges.add(new int[]{Math.min(u, v), Math.max(u, v)});\n                }\n            } else if (v != parent[u]) {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        int[][] edges = new int[m][2];\n        for (int i = 0; i < m; i++) {\n            edges[i][0] = scanner.nextInt();\n            edges[i][1] = scanner.nextInt();\n        }\n        \n        List<int[]> result = findBridges(n, edges);\n        \n        for (int[] bridge : result) {\n            System.out.println(bridge[0] + \" \" + bridge[1]);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:22:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Bridge {\npublic:\n    vector<vector<int>> graph;\n    vector<int> disc, low;\n    vector<bool> visited;\n    vector<pair<int, int>> bridges;\n    int time;\n\n    void findBridges(int v, int parent) {\n        visited[v] = true;\n        disc[v] = low[v] = ++time;\n\n        for (int u : graph[v]) {\n            if (!visited[u]) {\n                findBridges(u, v);\n                low[v] = min(low[v], low[u]);\n\n                if (low[u] > disc[v]) {\n                    int x = min(u, v);\n                    int y = max(u, v);\n                    bridges.push_back({x, y});\n                }\n            }\n            else if (u != parent) {\n                low[v] = min(low[v], disc[u]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> getBridges(int n) {\n        time = 0;\n        visited.assign(n, false);\n        disc.assign(n, 0);\n        low.assign(n, 0);\n        bridges.clear();\n\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                findBridges(i, -1);\n            }\n        }\n\n        sort(bridges.begin(), bridges.end());\n        return bridges;\n    }\n\n    void addEdge(int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Bridge bridge;\n    bridge.graph.resize(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        bridge.addEdge(u, v);\n    }\n\n    vector<pair<int, int>> bridges = bridge.getBridges(n);\n\n    for (auto b : bridges) {\n        cout << b.first << \" \" << b.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_bridges(V, E, edges):\n    from collections import defaultdict\n\n    def dfs(at, parent, visited, ids, low, bridges, graph):\n        visited[at] = True\n        current_id = dfs.time\n        ids[at] = low[at] = current_id\n        dfs.time += 1\n        \n        for to in graph[at]:\n            if to == parent:\n                continue\n            if not visited[to]:\n                dfs(to, at, visited, ids, low, bridges, graph)\n                low[at] = min(low[at], low[to])\n                if ids[at] < low[to]:\n                    bridges.append((min(at, to), max(at, to)))\n            else:\n                low[at] = min(low[at], ids[to])\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * V\n    ids = [-1] * V\n    low = [-1] * V\n    bridges = []\n\n    dfs.time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, -1, visited, ids, low, bridges, graph)\n\n    bridges.sort()\n    return bridges\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    V = int(data[0])\n    E = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(E):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n    \n    bridges = find_bridges(V, E, edges)\n    \n    for u, v in bridges:\n        print(u + 1, v + 1)\n\n# For execution in a local environment, uncomment the following lines:\n# if __name__ == \"__main__\":\n#     main()",
    "timestamp": "2025-08-13 10:11:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BridgesInGraph {\n\n    private int time = 0;\n    private List<List<Integer>> bridges = new ArrayList<>();\n\n    public List<List<Integer>> findBridges(int nodes, int[][] edges) {\n        List<Integer>[] graph = new ArrayList[nodes];\n        for (int i = 0; i < nodes; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        boolean[] visited = new boolean[nodes];\n        int[] disc = new int[nodes];\n        int[] low = new int[nodes];\n        int[] parent = new int[nodes];\n        Arrays.fill(parent, -1);\n\n        for (int i = 0; i < nodes; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, disc, low, parent, graph);\n            }\n        }\n\n        List<List<Integer>> result = new ArrayList<>(bridges);\n        for (List<Integer> bridge : result) {\n            Collections.sort(bridge);\n        }\n        result.sort((a, b) -> {\n            if (!a.get(0).equals(b.get(0))) {\n                return Integer.compare(a.get(0), b.get(0));\n            }\n            return Integer.compare(a.get(1), b.get(1));\n        });\n        return result;\n    }\n\n    private void dfs(int u, boolean[] visited, int[] disc, int[] low, int[] parent, List<Integer>[] graph) {\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n\n        for (int v : graph[u]) {\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v, visited, disc, low, parent, graph);\n\n                low[u] = Math.min(low[u], low[v]);\n\n                if (low[v] > disc[u]) {\n                    bridges.add(Arrays.asList(u, v));\n                }\n            } else if (v != parent[u]) {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        int[][] edges = new int[E][2];\n\n        for (int i = 0; i < E; i++) {\n            edges[i][0] = scanner.nextInt();\n            edges[i][1] = scanner.nextInt();\n        }\n\n        BridgesInGraph graph = new BridgesInGraph();\n        List<List<Integer>> result = graph.findBridges(V, edges);\n\n        for (List<Integer> bridge : result) {\n            System.out.println(bridge.get(0) + \" \" + bridge.get(1));\n        }\n    }\n}",
    "timestamp": "2025-08-13 10:11:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_VERTICES 10000\n#define MAX_EDGES 100000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint V, E;\nint time = 0;\nint adj[MAX_VERTICES][MAX_VERTICES];\nint discovery[MAX_VERTICES];\nint low[MAX_VERTICES];\nint parent[MAX_VERTICES];\nint visited[MAX_VERTICES];\nEdge bridges[MAX_EDGES];\nint bridge_count = 0;\n\nvoid add_edge(int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\n\nvoid bridge_util(int u) {\n    visited[u] = 1;\n    discovery[u] = low[u] = ++time;\n    \n    for (int v = 0; v < V; v++) {\n        if (adj[u][v]) {\n            if (!visited[v]) {\n                parent[v] = u;\n                bridge_util(v);\n\n                low[u] = (low[u] < low[v]) ? low[u] : low[v];\n\n                if (low[v] > discovery[u]) {\n                    bridges[bridge_count].u = u < v ? u : v;\n                    bridges[bridge_count].v = u < v ? v : u;\n                    bridge_count++;\n                }\n            }\n            else if (v != parent[u]) {\n                low[u] = (low[u] < discovery[v]) ? low[u] : discovery[v];\n            }\n        }\n    }\n}\n\nvoid find_bridges() {\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            bridge_util(i);\n        }\n    }\n}\n\nint compare_edges(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    if (edgeA->u != edgeB->u)\n        return edgeA->u - edgeB->u;\n    return edgeA->v - edgeB->v;\n}\n\nint main() {\n    scanf(\"%d %d\", &V, &E);\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    memset(parent, -1, sizeof(parent));\n    memset(discovery, 0, sizeof(discovery));\n    memset(low, 0, sizeof(low));\n\n    find_bridges();\n    \n    qsort(bridges, bridge_count, sizeof(Edge), compare_edges);\n    \n    for (int i = 0; i < bridge_count; i++) {\n        printf(\"%d %d\\n\", bridges[i].u, bridges[i].v);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:11:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_bridges(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    disc = [float('inf')] * n\n    low = [float('inf')] * n\n    parent = [-1] * n\n    bridges = []\n    time = [0]\n    \n    def dfs(u):\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n        \n        for v in graph[u]:\n            if disc[v] == float('inf'):\n                parent[v] = u\n                dfs(v)\n                low[u] = min(low[u], low[v])\n                \n                if low[v] > disc[u]:\n                    bridges.append(tuple(sorted([u, v])))\n            elif v != parent[u]:\n                low[u] = min(low[u], disc[v])\n    \n    for i in range(n):\n        if disc[i] == float('inf'):\n            dfs(i)\n    \n    return sorted(bridges)\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = find_bridges(n, edges)\n    for bridge in result:\n        print(f\"{bridge[0]} {bridge[1]}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:12:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef find_bridges():\n    sys.setrecursionlimit(1 << 25)\n    V, E = map(int, sys.stdin.readline().split())\n    adj = defaultdict(list)\n    for _ in range(E):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    disc = [0] * V\n    low = [0] * V\n    time = 1\n    bridges = []\n    \n    def dfs(u, parent):\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n        for v in adj[u]:\n            if v == parent:\n                continue\n            if disc[v] == 0:\n                dfs(v, u)\n                low[u] = min(low[u], low[v])\n                if low[v] > disc[u]:\n                    bridges.append((min(u, v), max(u, v)))\n            else:\n                low[u] = min(low[u], disc[v])\n    \n    for i in range(V):\n        if disc[i] == 0:\n            dfs(i, -1)\n    \n    bridges.sort()\n    for u, v in bridges:\n        print(u, v)\n\nfind_bridges()",
    "timestamp": "2025-08-13 10:12:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int u, int parent, int &time, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &disc, vector<int> &low, vector<pair<int, int>> &bridges) {\n    visited[u] = true;\n    disc[u] = low[u] = ++time;\n    \n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v, u, time, adj, visited, disc, low, bridges);\n            low[u] = min(low[u], low[v]);\n            \n            if (low[v] > disc[u]) {\n                bridges.emplace_back(min(u, v), max(u, v));\n            }\n        } else if (v != parent) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n}\n\nvector<pair<int, int>> findBridges(int V, vector<vector<int>> &adj) {\n    vector<bool> visited(V, false);\n    vector<int> disc(V, -1), low(V, -1);\n    vector<pair<int, int>> bridges;\n    int time = 0;\n    \n    for (int i = 0; i < V; ++i) {\n        if (!visited[i]) {\n            dfs(i, -1, time, adj, visited, disc, low, bridges);\n        }\n    }\n    \n    return bridges;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    \n    vector<vector<int>> adj(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<pair<int, int>> bridges = findBridges(V, adj);\n    sort(bridges.begin(), bridges.end());\n    \n    for (auto &bridge : bridges) {\n        cout << bridge.first << \" \" << bridge.second << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:33"
  }
]