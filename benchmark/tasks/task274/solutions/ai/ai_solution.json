[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int width, height;\n} Piece;\n\ntypedef struct {\n    Piece king;\n    Piece* pawns;\n    int pawn_count;\n    int width, height;\n    int** obstacles;\n} Board;\n\ntypedef struct Node {\n    Board board;\n    int moves;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    Node* head;\n    Node* tail;\n} Queue;\n\nQueue* create_queue() {\n    Queue* q = (Queue*)malloc(sizeof(Queue));\n    q->head = q->tail = NULL;\n    return q;\n}\n\nvoid enqueue(Queue* q, Board board, int moves) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->board = board;\n    newNode->moves = moves;\n    newNode->next = NULL;\n\n    if (q->tail == NULL) {\n        q->head = q->tail = newNode;\n    } else {\n        q->tail->next = newNode;\n        q->tail = newNode;\n    }\n}\n\nNode* dequeue(Queue* q) {\n    if (q->head == NULL) return NULL;\n\n    Node* temp = q->head;\n    q->head = q->head->next;\n\n    if (q->head == NULL) q->tail = NULL;\n\n    return temp;\n}\n\nbool is_empty(Queue* q) {\n    return q->head == NULL;\n}\n\nBoard copy_board(Board* original) {\n    Board copy;\n    copy.king = original->king;\n    copy.width = original->width;\n    copy.height = original->height;\n\n    copy.pawn_count = original->pawn_count;\n    copy.pawns = (Piece*)malloc(copy.pawn_count * sizeof(Piece));\n    memcpy(copy.pawns, original->pawns, copy.pawn_count * sizeof(Piece));\n\n    copy.obstacles = (int**)malloc(copy.height * sizeof(int*));\n    for (int i = 0; i < copy.height; i++) {\n        copy.obstacles[i] = (int*)malloc(copy.width * sizeof(int));\n        memcpy(copy.obstacles[i], original->obstacles[i], copy.width * sizeof(int));\n    }\n\n    return copy;\n}\n\nvoid free_board(Board* board) {\n    free(board->pawns);\n    for (int i = 0; i < board->height; i++) {\n        free(board->obstacles[i]);\n    }\n    free(board->obstacles);\n}\n\nbool is_goal(Board* board) {\n    return (board->king.pos.x == 0 && board->king.pos.y == 0);\n}\n\nbool can_move(Board* board, Piece* piece, int dx, int dy) {\n    int new_x = piece->pos.x + dx;\n    int new_y = piece->pos.y + dy;\n\n    if (new_x < 0 || new_y < 0 || new_x + piece->width > board->width || new_y + piece->height > board->height) {\n        return false;\n    }\n\n    for (int y = new_y; y < new_y + piece->height; y++) {\n        for (int x = new_x; x < new_x + piece->width; x++) {\n            if (board->obstacles[y][x]) {\n                return false;\n            }\n        }\n    }\n\n    for (int i = 0; i < board->pawn_count; i++) {\n        Piece* pawn = &board->pawns[i];\n        if (pawn->pos.x < new_x + piece->width && pawn->pos.x + pawn->width > new_x &&\n            pawn->pos.y < new_y + piece->height && pawn->pos.y + pawn->height > new_y) {\n            return false;\n        }\n    }\n\n    if (piece->width == 2 && piece->height == 2) {\n        for (int y = new_y; y < new_y + 2; y++) {\n            for (int x = new_x; x < new_x + 2; x++) {\n                if (x >= board->king.pos.x && x < board->king.pos.x + 2 &&\n                    y >= board->king.pos.y && y < board->king.pos.y + 2) {\n                    continue;\n                }\n                if (board->king.pos.x < new_x + 2 && board->king.pos.x + 2 > new_x &&\n                    board->king.pos.y < new_y + 2 && board->king.pos.y + 2 > new_y) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nvoid apply_move(Board* board, Piece* piece, int dx, int dy) {\n    piece->pos.x += dx;\n    piece->pos.y += dy;\n}\n\nunsigned long hash_board(Board* board) {\n    unsigned long hash = 5381;\n    hash = ((hash << 5) + hash) + board->king.pos.x;\n    hash = ((hash << 5) + hash) + board->king.pos.y;\n\n    for (int i = 0; i < board->pawn_count; i++) {\n        hash = ((hash << 5) + hash) + board->pawns[i].pos.x;\n        hash = ((hash << 5) + hash) + board->pawns[i].pos.y;\n    }\n\n    return hash;\n}\n\nint min_moves(Board* initial) {\n    Queue* q = create_queue();\n    enqueue(q, *initial, 0);\n\n    int visited_capacity = 100000;\n    unsigned long* visited = (unsigned long*)malloc(visited_capacity * sizeof(unsigned long));\n    int visited_size = 0;\n\n    int min_moves = -1;\n\n    while (!is_empty(q)) {\n        Node* node = dequeue(q);\n        Board current = node->board;\n        int moves = node->moves;\n\n        if (is_goal(&current)) {\n            min_moves = moves;\n            free(node);\n            break;\n        }\n\n        unsigned long h = hash_board(&current);\n        bool found = false;\n        for (int i = 0; i < visited_size; i++) {\n            if (visited[i] == h) {\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            free_board(&current);\n            free(node);\n            continue;\n        }\n\n        if (visited_size >= visited_capacity) {\n            visited_capacity *= 2;\n            visited = (unsigned long*)realloc(visited, visited_capacity * sizeof(unsigned long));\n        }\n        visited[visited_size++] = h;\n\n        int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        for (int i = 0; i < 4; i++) {\n            int dx = directions[i][0];\n            int dy = directions[i][1];\n\n            if (can_move(&current, &current.king, dx, dy)) {\n                Board next = copy_board(&current);\n                apply_move(&next, &next.king, dx, dy);\n                enqueue(q, next, moves + 1);\n            }\n\n            for (int j = 0; j < current.pawn_count; j++) {\n                if (can_move(&current, &current.pawns[j], dx, dy)) {\n                    Board next = copy_board(&current);\n                    apply_move(&next, &next.pawns[j], dx, dy);\n                    enqueue(q, next, moves + 1);\n                }\n            }\n        }\n\n        free_board(&current);\n        free(node);\n    }\n\n    while (!is_empty(q)) {\n        Node* node = dequeue(q);\n        free_board(&node->board);\n        free(node);\n    }\n\n    free(visited);\n    free(q);\n\n    return min_moves;\n}\n\nint main() {\n    int width, height;\n    scanf(\"%d %d\", &height, &width);\n\n    Board board;\n    board.width = width;\n    board.height = height;\n\n    board.obstacles = (int**)malloc(height * sizeof(int*));\n    for (int i = 0; i < height; i++) {\n        board.obstacles[i] = (int*)malloc(width * sizeof(int));\n        for (int j = 0; j < width; j++) {\n            scanf(\"%d\", &board.obstacles[i][j]);\n        }\n    }\n\n    scanf(\"%d %d\", &board.king.pos.y, &board.king.pos.x);\n    board.king.width = 2;\n    board.king.height = 2;\n\n    scanf(\"%d\", &board.pawn_count);\n    board.pawns = (Piece*)malloc(board.pawn_count * sizeof(Piece));\n    for (int i = 0; i < board.pawn_count; i++) {\n        scanf(\"%d %d\", &board.pawns[i].pos.y, &board.pawns[i].pos.x);\n        board.pawns[i].width = 1;\n        board.pawns[i].height = 1;\n    }\n\n    int result = min_moves(&board);\n    printf(\"%d\\n\", result);\n\n    free_board(&board);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nstruct State {\n    int king_x, king_y;\n    vector<pair<int, int>> pawns;\n    int moves;\n\n    bool operator==(const State& other) const {\n        if (king_x != other.king_x || king_y != other.king_y || pawns.size() != other.pawns.size())\n            return false;\n        for (size_t i = 0; i < pawns.size(); ++i) {\n            if (pawns[i] != other.pawns[i])\n                return false;\n        }\n        return true;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<State> {\n        size_t operator()(const State& s) const {\n            size_t h = hash<int>()(s.king_x) ^ hash<int>()(s.king_y);\n            for (const auto& p : s.pawns) {\n                h ^= hash<int>()(p.first) ^ hash<int>()(p.second);\n            }\n            return h;\n        }\n    };\n}\n\nbool is_valid(int x, int y, int rows, int cols, const vector<vector<bool>>& obstacles, const State& state) {\n    if (x < 0 || y < 0 || x >= rows || y >= cols || obstacles[x][y])\n        return false;\n    for (const auto& p : state.pawns) {\n        if (p.first == x && p.second == y)\n            return false;\n    }\n    return true;\n}\n\nbool is_king_at_goal(const State& state) {\n    return state.king_x == 0 && state.king_y == 0;\n}\n\nvector<State> generate_next_states(const State& current, int rows, int cols, const vector<vector<bool>>& obstacles) {\n    vector<State> next_states;\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    // Try moving the king\n    for (int i = 0; i < 4; ++i) {\n        int new_king_x = current.king_x + dx[i];\n        int new_king_y = current.king_y + dy[i];\n        bool can_move = true;\n        for (int kx = 0; kx < 2; ++kx) {\n            for (int ky = 0; ky < 2; ++ky) {\n                int x = new_king_x + kx;\n                int y = new_king_y + ky;\n                if (!is_valid(x, y, rows, cols, obstacles, current)) {\n                    can_move = false;\n                    break;\n                }\n            }\n            if (!can_move) break;\n        }\n        if (can_move) {\n            State next = current;\n            next.king_x = new_king_x;\n            next.king_y = new_king_y;\n            next.moves = current.moves + 1;\n            next_states.push_back(next);\n        }\n    }\n\n    // Try moving pawns\n    for (size_t idx = 0; idx < current.pawns.size(); ++idx) {\n        auto pawn = current.pawns[idx];\n        for (int i = 0; i < 4; ++i) {\n            int new_pawn_x = pawn.first + dx[i];\n            int new_pawn_y = pawn.second + dy[i];\n            if (is_valid(new_pawn_x, new_pawn_y, rows, cols, obstacles, current)) {\n                State next = current;\n                next.pawns[idx] = {new_pawn_x, new_pawn_y};\n                next.moves = current.moves + 1;\n                next_states.push_back(next);\n            }\n        }\n    }\n\n    return next_states;\n}\n\nint solve_puzzle(int rows, int cols, const vector<vector<bool>>& obstacles, const State& initial) {\n    queue<State> q;\n    unordered_set<State> visited;\n    q.push(initial);\n    visited.insert(initial);\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (is_king_at_goal(current)) {\n            return current.moves;\n        }\n\n        vector<State> next_states = generate_next_states(current, rows, cols, obstacles);\n        for (const auto& next : next_states) {\n            if (visited.find(next) == visited.end()) {\n                visited.insert(next);\n                q.push(next);\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    vector<vector<bool>> obstacles(rows, vector<bool>(cols, false));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            char c;\n            cin >> c;\n            obstacles[i][j] = (c == '#');\n        }\n    }\n\n    State initial;\n    initial.moves = 0;\n    int pawn_count = 0;\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            char c;\n            cin >> c;\n            if (c == 'K') {\n                initial.king_x = i;\n                initial.king_y = j;\n            } else if (c == 'P') {\n                initial.pawns.push_back({i, j});\n            }\n        }\n    }\n\n    int result = solve_puzzle(rows, cols, obstacles, initial);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass State {\n    int kingX, kingY;\n    Set<String> pawns;\n    int moves;\n\n    State(int kingX, int kingY, Set<String> pawns, int moves) {\n        this.kingX = kingX;\n        this.kingY = kingY;\n        this.pawns = new HashSet<>(pawns);\n        this.moves = moves;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        State state = (State) o;\n        return kingX == state.kingX && kingY == state.kingY && pawns.equals(state.pawns);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(kingX, kingY, pawns);\n    }\n}\n\npublic class SlidingBlockPuzzle {\n    static final int[][] KING_DIRS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static int minMoves(int width, int height, int kingX, int kingY, Set<String> pawns) {\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n\n        State start = new State(kingX, kingY, pawns, 0);\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.kingX == 0 && current.kingY == 0) {\n                return current.moves;\n            }\n\n            for (int[] dir : KING_DIRS) {\n                int newKingX = current.kingX + dir[0];\n                int newKingY = current.kingY + dir[1];\n\n                if (canMoveKing(width, height, newKingX, newKingY, current.pawns)) {\n                    Set<String> newPawns = new HashSet<>(current.pawns);\n                    State newState = new State(newKingX, newKingY, newPawns, current.moves + 1);\n\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n\n            for (String pawn : current.pawns) {\n                String[] parts = pawn.split(\",\");\n                int px = Integer.parseInt(parts[0]);\n                int py = Integer.parseInt(parts[1]);\n\n                for (int[] dir : KING_DIRS) {\n                    int newPx = px + dir[0];\n                    int newPy = py + dir[1];\n\n                    if (canMovePawn(width, height, current.kingX, current.kingY, px, py, newPx, newPy, current.pawns)) {\n                        Set<String> newPawns = new HashSet<>(current.pawns);\n                        newPawns.remove(pawn);\n                        newPawns.add(newPx + \",\" + newPy);\n                        State newState = new State(current.kingX, current.kingY, newPawns, current.moves + 1);\n\n                        if (!visited.contains(newState)) {\n                            visited.add(newState);\n                            queue.add(newState);\n                        }\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean canMoveKing(int width, int height, int kingX, int kingY, Set<String> pawns) {\n        if (kingX < 0 || kingY < 0 || kingX + 1 >= width || kingY + 1 >= height) {\n            return false;\n        }\n\n        for (int x = kingX; x <= kingX + 1; x++) {\n            for (int y = kingY; y <= kingY + 1; y++) {\n                if (pawns.contains(x + \",\" + y)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private static boolean canMovePawn(int width, int height, int kingX, int kingY, int px, int py, int newPx, int newPy, Set<String> pawns) {\n        if (newPx < 0 || newPy < 0 || newPx >= width || newPy >= height) {\n            return false;\n        }\n\n        if (pawns.contains(newPx + \",\" + newPy)) {\n            return false;\n        }\n\n        if ((newPx >= kingX && newPx <= kingX + 1) && (newPy >= kingY && newPy <= kingY + 1)) {\n            return false;\n        }\n\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 20:54:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass SlidingBlockPuzzle {\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    static class State {\n        int[][] board;\n        int moves;\n        int kingX, kingY;\n\n        State(int[][] board, int moves, int kingX, int kingY) {\n            this.board = new int[board.length][board[0].length];\n            for (int i = 0; i < board.length; i++) {\n                this.board[i] = board[i].clone();\n            }\n            this.moves = moves;\n            this.kingX = kingX;\n            this.kingY = kingY;\n        }\n    }\n\n    public static int solve(int[][] board, int kingX, int kingY) {\n        int rows = board.length;\n        int cols = board[0].length;\n        Set<String> visited = new HashSet<>();\n        Queue<State> queue = new LinkedList<>();\n\n        State initial = new State(board, 0, kingX, kingY);\n        queue.offer(initial);\n        visited.add(boardToString(board));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.kingX == 0 && current.kingY == 0) {\n                return current.moves;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newKingX = current.kingX + dx[d];\n                int newKingY = current.kingY + dy[d];\n\n                if (isValidMove(current.board, current.kingX, current.kingY, newKingX, newKingY)) {\n                    int[][] newBoard = new int[rows][cols];\n                    for (int i = 0; i < rows; i++) {\n                        newBoard[i] = current.board[i].clone();\n                    }\n\n                    movePiece(newBoard, current.kingX, current.kingY, newKingX, newKingY);\n\n                    String boardStr = boardToString(newBoard);\n                    if (!visited.contains(boardStr)) {\n                        visited.add(boardStr);\n                        queue.offer(new State(newBoard, current.moves + 1, newKingX, newKingY));\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private static boolean isValidMove(int[][] board, int kingX, int kingY, int newKingX, int newKingY) {\n        int rows = board.length;\n        int cols = board[0].length;\n\n        if (newKingX < 0 || newKingX + 1 >= rows || newKingY < 0 || newKingY + 1 >= cols) {\n            return false;\n        }\n\n        for (int x = newKingX; x <= newKingX + 1; x++) {\n            for (int y = newKingY; y <= newKingY + 1; y++) {\n                if (board[x][y] != 0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private static void movePiece(int[][] board, int kingX, int kingY, int newKingX, int newKingY) {\n        for (int x = kingX; x <= kingX + 1; x++) {\n            for (int y = kingY; y <= kingY + 1; y++) {\n                board[x][y] = 0;\n            }\n        }\n\n        for (int x = newKingX; x <= newKingX + 1; x++) {\n            for (int y = newKingY; y <= newKingY + 1; y++) {\n                board[x][y] = 1;\n            }\n        }\n    }\n\n    private static String boardToString(int[][] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : board) {\n            for (int cell : row) {\n                sb.append(cell);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        int[][] board = {\n            {0, 0, 0, 0, 0},\n            {0, 1, 1, 0, 0},\n            {0, 1, 1, 0, 0},\n            {0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 0}\n        };\n        int kingX = 1;\n        int kingY = 1;\n        int minMoves = solve(board, kingX, kingY);\n        System.out.println(\"Minimum moves: \" + minMoves);\n    }\n}",
    "timestamp": "2025-08-05 20:55:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 10\n#define MAX_PIECES 20\n\ntypedef struct {\n    int x, y, width, height;\n} Piece;\n\ntypedef struct {\n    int grid[MAX_SIZE][MAX_SIZE];\n    Piece pieces[MAX_PIECES];\n    int piece_count;\n    int rows, cols;\n} Board;\n\ntypedef struct {\n    Board state;\n    int moves;\n} QueueItem;\n\nint is_valid_move(Board* board, Piece* piece, int dx, int dy) {\n    int new_x = piece->x + dx;\n    int new_y = piece->y + dy;\n\n    // Check bounds\n    if (new_x < 0 || new_y < 0 || \n        new_x + piece->width > board->cols || \n        new_y + piece->height > board->rows) {\n        return 0;\n    }\n\n    // Check collision with other pieces\n    for (int i = 0; i < board->piece_count; i++) {\n        Piece* other = &board->pieces[i];\n        if (other != piece) {\n            if (!(new_x + piece->width <= other->x || \n                  new_x >= other->x + other->width || \n                  new_y + piece->height <= other->y || \n                  new_y >= other->y + other->height)) {\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}\n\nvoid move_piece(Board* board, Piece* piece, int dx, int dy) {\n    piece->x += dx;\n    piece->y += dy;\n}\n\nint solve_puzzle(Board* initial_board) {\n    int visited[MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE] = {0};\n    QueueItem queue[100000];\n    int front = 0, rear = 0;\n\n    queue[rear++] = (QueueItem){*initial_board, 0};\n\n    while (front < rear) {\n        QueueItem current = queue[front++];\n        Board* board = &current.state;\n\n        // Check goal state\n        Piece* king = &board->pieces[0];\n        if (king->x == 0 && king->y == 0) {\n            return current.moves;\n        }\n\n        // Try moving each piece\n        for (int i = 0; i < board->piece_count; i++) {\n            Piece* piece = &board->pieces[i];\n            int directions[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n\n            for (int d = 0; d < 4; d++) {\n                int dx = directions[d][0];\n                int dy = directions[d][1];\n\n                if (is_valid_move(board, piece, dx, dy)) {\n                    Board new_board = *board;\n                    Piece* new_piece = &new_board.pieces[i];\n\n                    move_piece(&new_board, new_piece, dx, dy);\n\n                    // Avoid revisiting states\n                    if (!visited[new_piece->x][new_piece->y][king->x][king->y]) {\n                        visited[new_piece->x][new_piece->y][king->x][king->y] = 1;\n                        queue[rear++] = (QueueItem){new_board, current.moves + 1};\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;  // No solution\n}\n\nint main() {\n    Board board = {0};\n    // Example initialization would happen here\n    int result = solve_puzzle(&board);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> board;\n    int kingX, kingY;\n    int moves;\n    \n    bool operator==(const State& other) const {\n        return board == other.board;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State& state) const {\n        string key;\n        for (const auto& row : state.board) {\n            for (int cell : row) {\n                key += to_string(cell) + \",\";\n            }\n        }\n        return hash<string>()(key);\n    }\n};\n\nclass SlidingBlockSolver {\nprivate:\n    int rows, cols;\n    vector<pair<int, int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n\n    bool isValidMove(State& state, int x, int y, int dx, int dy) {\n        int newX = x + dx, newY = y + dy;\n        \n        if (newX < 0 || newX >= rows || newY < 0 || newY >= cols) \n            return false;\n        \n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                if (state.board[x+i][y+j] == 0 || \n                    state.board[newX+i][newY+j] != 0) \n                    return false;\n            }\n        }\n        return true;\n    }\n\n    void movePiece(State& state, int x, int y, int dx, int dy) {\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                state.board[x+dx][y+dy] = state.board[x+i][y+j];\n                state.board[x+i][y+j] = 0;\n            }\n        }\n        state.kingX += dx;\n        state.kingY += dy;\n    }\n\npublic:\n    int solve(vector<vector<int>>& initialBoard) {\n        rows = initialBoard.size();\n        cols = initialBoard[0].size();\n        \n        State start;\n        start.board = initialBoard;\n        start.moves = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (initialBoard[i][j] == 2) {\n                    start.kingX = i;\n                    start.kingY = j;\n                    break;\n                }\n            }\n        }\n        \n        queue<State> q;\n        unordered_set<State, StateHash> visited;\n        \n        q.push(start);\n        visited.insert(start);\n        \n        while (!q.empty()) {\n            State current = q.front();\n            q.pop();\n            \n            if (current.kingX == 0 && current.kingY == 0) \n                return current.moves;\n            \n            for (auto& dir : directions) {\n                int dx = dir.first, dy = dir.second;\n                \n                if (isValidMove(current, current.kingX, current.kingY, dx, dy)) {\n                    State next = current;\n                    movePiece(next, current.kingX, current.kingY, dx, dy);\n                    next.moves++;\n                    \n                    if (visited.find(next) == visited.end()) {\n                        q.push(next);\n                        visited.insert(next);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    vector<vector<int>> board = {\n        {0, 0, 0, 0},\n        {0, 2, 2, 0},\n        {0, 2, 2, 0},\n        {0, 0, 0, 0}\n    };\n    \n    SlidingBlockSolver solver;\n    int minMoves = solver.solve(board);\n    \n    cout << \"Minimum moves: \" << minMoves << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_moves_to_corner(starting_position, width, height):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def is_valid(x, y, w, h):\n        return 0 <= x < h and 0 <= y < w\n\n    def can_move_to(pos, piece, new_x, new_y):\n        px, py, pw, ph = piece\n        for dx in range(pw):\n            for dy in range(ph):\n                nx, ny = new_x + dx, new_y + dy\n                if not is_valid(nx, ny, width, height) or pos[nx][ny] != '.':\n                    return False\n        return True\n\n    def move_piece(pos, piece, dir):\n        px, py, pw, ph = piece\n        dx, dy = dir\n        new_x, new_y = px + dx, py + dy\n        if not can_move_to(pos, piece, new_x, new_y):\n            return pos, False\n        \n        for dx in range(pw):\n            for dy in range(ph):\n                pos[px + dx][py + dy] = '.'\n        for dx in range(pw):\n            for dy in range(ph):\n                pos[new_x + dx][new_y + dy] = 'K' if pw == 2 else 'P'\n        \n        return pos, True\n\n    def serialize_pos(pos):\n        return tuple(map(tuple, pos))\n\n    def locate_pieces(pos):\n        pieces = []\n        for x in range(height):\n            for y in range(width):\n                if pos[x][y] == 'K':\n                    pieces.append((x, y, 2, 2))\n                elif pos[x][y] == 'P':\n                    pieces.append((x, y, 1, 1))\n        return pieces\n\n    def is_goal(pos):\n        return pos[0][0] == 'K' and pos[0][1] == 'K' and pos[1][0] == 'K' and pos[1][1] == 'K'\n\n    starting_pos = [list(row) for row in starting_position]\n    queue = deque([(starting_pos, 0)])\n    visited = {serialize_pos(starting_pos)}\n\n    while queue:\n        current_pos, moves = queue.popleft()\n        if is_goal(current_pos):\n            return moves\n\n        pieces = locate_pieces(current_pos)\n        for piece in pieces:\n            for dir in directions:\n                new_pos = [row[:] for row in current_pos]\n                new_pos, moved = move_piece(new_pos, piece, dir)\n                if moved:\n                    serialized_pos = serialize_pos(new_pos)\n                    if serialized_pos not in visited:\n                        visited.add(serialized_pos)\n                        queue.append((new_pos, moves + 1))\n\n    return -1\n\n# Example usage:\nstarting_position = [\n    \"..K.\",\n    \"..K.\",\n    \"PP..\",\n    \"....\"\n]\nwidth = 4\nheight = 4\n\nprint(min_moves_to_corner(starting_position, width, height))",
    "timestamp": "2025-08-13 03:56:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SlidingBlockPuzzle {\n    private static final int EMPTY = 0;\n    private static final int KING = 2;\n    private static final int PAWN = 1;\n    private static final int[][] DIRECTIONS = {\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\n    };\n\n    static class State {\n        int[][] board;\n        int kingRow, kingCol;\n        int moveCount;\n\n        public State(int[][] board, int kingRow, int kingCol, int moveCount) {\n            this.board = board;\n            this.kingRow = kingRow;\n            this.kingCol = kingCol;\n            this.moveCount = moveCount;\n        }\n\n        @Override\n        public int hashCode() {\n            return Arrays.deepHashCode(board);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            State state = (State) obj;\n            return Arrays.deepEquals(board, state.board);\n        }\n    }\n\n    public static int minMovesToSolvePuzzle(int[][] initialBoard) {\n        int startKingRow = -1, startKingCol = -1;\n        int rows = initialBoard.length;\n        int cols = initialBoard[0].length;\n        \n        // Locate the king's starting position\n        outerLoop: for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (initialBoard[i][j] == KING && initialBoard[i + 1][j] == KING &&\n                    initialBoard[i][j + 1] == KING && initialBoard[i + 1][j + 1] == KING) {\n                    startKingRow = i;\n                    startKingCol = j;\n                    break outerLoop;\n                }\n            }\n        }\n\n        State initialState = new State(copyBoard(initialBoard), startKingRow, startKingCol, 0);\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n        \n        queue.add(initialState);\n        visited.add(initialState);\n        \n        while (!queue.isEmpty()) {\n            State currentState = queue.poll();\n            \n            if (currentState.kingRow == 0 && currentState.kingCol == 0) {\n                return currentState.moveCount;\n            }\n\n            for (int[] dir : DIRECTIONS) {\n                int newKingRow = currentState.kingRow + dir[0];\n                int newKingCol = currentState.kingCol + dir[1];\n                \n                if (canMoveKing(currentState.board, currentState.kingRow, currentState.kingCol, newKingRow, newKingCol)) {\n                    int[][] newBoard = moveKing(currentState.board, currentState.kingRow, currentState.kingCol, newKingRow, newKingCol);\n                    State newState = new State(newBoard, newKingRow, newKingCol, currentState.moveCount + 1);\n                    \n                    if (visited.add(newState)) {\n                        queue.add(newState);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n\n    private static boolean canMoveKing(int[][] board, int kr, int kc, int nkr, int nkc) {\n        int rows = board.length;\n        int cols = board[0].length;\n        \n        if (nkr < 0 || nkr >= rows - 1 || nkc < 0 || nkc >= cols - 1) {\n            return false;\n        }\n\n        return (board[nkr][nkc] == EMPTY && board[nkr + 1][nkc] == EMPTY &&\n                board[nkr][nkc + 1] == EMPTY && board[nkr + 1][nkc + 1] == EMPTY);\n    }\n\n    private static int[][] moveKing(int[][] board, int kr, int kc, int nkr, int nkc) {\n        int[][] newBoard = copyBoard(board);\n        newBoard[kr][kc] = EMPTY;\n        newBoard[kr + 1][kc] = EMPTY;\n        newBoard[kr][kc + 1] = EMPTY;\n        newBoard[kr + 1][kc + 1] = EMPTY;\n        newBoard[nkr][nkc] = KING;\n        newBoard[nkr + 1][nkc] = KING;\n        newBoard[nkr][nkc + 1] = KING;\n        newBoard[nkr + 1][nkc + 1] = KING;\n        return newBoard;\n    }\n\n    private static int[][] copyBoard(int[][] board) {\n        int rows = board.length;\n        int cols = board[0].length;\n        int[][] newBoard = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            newBoard[i] = Arrays.copyOf(board[i], cols);\n        }\n        return newBoard;\n    }\n    \n    public static void main(String[] args) {\n        int[][] initialBoard = {\n            {0, 0, 1, 1},\n            {0, 0, 1, 1},\n            {1, 1, 2, 2},\n            {1, 1, 2, 2}\n        };\n        System.out.println(minMovesToSolvePuzzle(initialBoard)); // Output depends on the puzzle configuration\n    }\n}",
    "timestamp": "2025-08-13 03:57:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX 8\n#define INF 1000000\n#define DIRECTIONS 4\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int grid[MAX][MAX];\n    Point king;\n    int distance;\n} State;\n\nint dx[DIRECTIONS] = {0, 0, 1, -1};\nint dy[DIRECTIONS] = {1, -1, 0, 0};\n\nint n, m;\nState initial;\nbool visited[MAX][MAX][MAX][MAX];\n\nbool isValidMove(int x, int y) {\n    return x >= 0 && y >= 0 && x < n && y < m;\n}\n\nbool canMove(Point piece, int dir, State *s) {\n    for (int i = 0; i < 2; i++) {\n        int nx = piece.x + dx[dir] + i;\n        int ny = piece.y + dy[dir] + (1 - i);\n        if (isValidMove(nx, ny) && s->grid[nx][ny] == 0) continue;\n        return false;\n    }\n    return true;\n}\n\nbool isGoal(State *s) {\n    return s->king.x == 0 && s->king.y == 0;\n}\n\nint bfs() {\n    State queue[INF];\n    int front = 0, rear = 0, minMoves = INF;\n\n    memcpy(queue[rear++].grid, initial.grid, sizeof(initial.grid));\n    queue[rear - 1].king = initial.king;\n    queue[rear - 1].distance = 0;\n\n    while (front < rear) {\n        State current = queue[front++];\n        if (isGoal(&current)) {\n            minMoves = current.distance;\n            break;\n        }\n        if (visited[current.king.x][current.king.y][current.distance % MAX][current.distance % MAX]) continue;\n        visited[current.king.x][current.king.y][current.distance % MAX][current.distance % MAX] = true;\n\n        for (int dir = 0; dir < DIRECTIONS; dir++) {\n            if (canMove(current.king, dir, &current)) {\n                State newState;\n                memcpy(newState.grid, current.grid, sizeof(current.grid));\n                newState.king.x = current.king.x + dx[dir];\n                newState.king.y = current.king.y + dy[dir];\n                newState.distance = current.distance + 1;\n\n                for (int i = 0; i < 2; i++) {\n                    int ox = current.king.x + i;\n                    int oy = current.king.y + (1 - i);\n                    int nx = newState.king.x + i;\n                    int ny = newState.king.y + (1 - i);\n                    newState.grid[ox][oy] = 0;\n                    newState.grid[nx][ny] = 1;\n                }\n\n                if (!visited[newState.king.x][newState.king.y][newState.distance % MAX][newState.distance % MAX]) {\n                    queue[rear++] = newState;\n                }\n            }\n        }\n    }\n\n    return minMoves;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            scanf(\"%d\", &initial.grid[i][j]);\n\n    scanf(\"%d %d\", &initial.king.x, &initial.king.y);\n    int result = bfs();\n    if (result == INF) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 03:57:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef solve_sliding_block_maze(board: List[List[int]], king_pos: Tuple[int, int]) -> int:\n    rows, cols = len(board), len(board[0])\n    \n    def is_valid_move(x: int, y: int) -> bool:\n        return 0 <= x < rows and 0 <= y < cols and board[x][y] == 0\n    \n    def get_possible_moves(x: int, y: int, piece_size: int) -> List[Tuple[int, int, int, int]]:\n        moves = []\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if piece_size == 2:\n                if (is_valid_move(new_x, new_y) and \n                    is_valid_move(new_x, new_y+1) and \n                    is_valid_move(new_x+1, new_y) and \n                    is_valid_move(new_x+1, new_y+1)):\n                    moves.append((x, y, new_x, new_y))\n            else:\n                if is_valid_move(new_x, new_y):\n                    moves.append((x, y, new_x, new_y))\n        \n        return moves\n    \n    def bfs() -> int:\n        queue = deque([(king_pos[0], king_pos[1], 0)])\n        visited = set([(king_pos[0], king_pos[1])])\n        \n        while queue:\n            x, y, moves = queue.popleft()\n            \n            if x == 0 and y == 0:\n                return moves\n            \n            for new_x, new_y, nx, ny in get_possible_moves(x, y, 2):\n                if (nx, ny) not in visited:\n                    queue.append((nx, ny, moves + 1))\n                    visited.add((nx, ny))\n        \n        return -1\n    \n    return bfs()\n\n# Example usage\nboard = [\n    [0, 0, 0, 0],\n    [0, 1, 1, 0],\n    [0, 1, 1, 0],\n    [0, 0, 0, 0]\n]\nking_pos = (2, 1)\nprint(solve_sliding_block_maze(board, king_pos))",
    "timestamp": "2025-08-13 03:57:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_puzzle(board):\n    rows = len(board)\n    if rows == 0:\n        return -1\n    cols = len(board[0])\n    \n    # Find initial positions of the king (2x2 block)\n    king_pos = None\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            if board[i][j] == 2 and board[i][j+1] == 2 and board[i+1][j] == 2 and board[i+1][j+1] == 2:\n                king_pos = (i, j)\n                break\n        if king_pos is not None:\n            break\n    \n    if not king_pos:\n        return -1\n    \n    # Find all pawn positions\n    pawns = []\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 1:\n                pawns.append((i, j))\n    \n    # The target is (0, 0)\n    target = (0, 0)\n    \n    # Directions: up, down, left, right\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    visited = set()\n    queue = deque()\n    \n    initial_state = (king_pos[0], king_pos[1], frozenset(pawns))\n    queue.append((initial_state, 0))\n    visited.add(initial_state)\n    \n    while queue:\n        current_state, moves = queue.popleft()\n        k_r, k_c, current_pawns = current_state\n        \n        if (k_r, k_c) == target:\n            return moves\n        \n        # Check all possible moves\n        for dr, dc in dirs:\n            new_k_r = k_r + dr\n            new_k_c = k_c + dc\n            \n            # Check if the new king position is valid (2x2 block)\n            if 0 <= new_k_r < rows - 1 and 0 <= new_k_c < cols - 1:\n                # Check the four cells of the new king position\n                cells = [(new_k_r, new_k_c), (new_k_r, new_k_c + 1), \n                         (new_k_r + 1, new_k_c), (new_k_r + 1, new_k_c + 1)]\n                valid = True\n                new_pawns = set(current_pawns)\n                \n                for (r, c) in cells:\n                    if board[r][c] == -1:  # Obstacle\n                        valid = False\n                        break\n                    if (r, c) in current_pawns:\n                        # The pawn must be pushed\n                        new_r = r + dr\n                        new_c = c + dc\n                        if (new_r, new_c) in cells or not (0 <= new_r < rows and 0 <= new_c < cols):\n                            valid = False\n                            break\n                        if board[new_r][new_c] == -1:\n                            valid = False\n                            break\n                        if (new_r, new_c) in new_pawns:\n                            valid = False\n                            break\n                        new_pawns.remove((r, c))\n                        new_pawns.add((new_r, new_c))\n                \n                if valid:\n                    new_state = (new_k_r, new_k_c, frozenset(new_pawns))\n                    if new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, moves + 1))\n    \n    return -1",
    "timestamp": "2025-08-13 03:58:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> board;\n    int kingX, kingY;\n    int moves;\n    \n    State(const vector<vector<int>>& b, int kx, int ky, int m)\n        : board(b), kingX(kx), kingY(ky), moves(m) {}\n};\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool isValidMove(const vector<vector<int>>& board, int x, int y, int kingX, int kingY) {\n    if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size()) return false;\n    if (board[x][y] != 0) return false;\n    \n    // Ensure the position does not overlap with the king's area except allowed spots\n    return !(x >= kingX && x < kingX + 2 && y >= kingY && y < kingY + 2 &&\n             !(x == kingX + 2 || y == kingY + 2));\n}\n\nstring stateHash(const vector<vector<int>>& board) {\n    string hash = \"\";\n    for (int i = 0; i < board.size(); ++i) {\n        for (int j = 0; j < board[0].size(); ++j) {\n            hash += to_string(board[i][j]) + \",\";\n        }\n    }\n    return hash;\n}\n\nint minimumMoves(vector<vector<int>> board, int kingX, int kingY) {\n    queue<State> q;\n    unordered_set<string> visited;\n\n    q.push(State(board, kingX, kingY, 0));\n    visited.insert(stateHash(board));\n    \n    while (!q.empty()) {\n        State state = q.front();\n        q.pop();\n        \n        if (state.kingX == 0 && state.kingY == 0) return state.moves;\n        \n        // Try to move a piece\n        for (int i = 0; i < state.board.size(); ++i) {\n            for (int j = 0; j < state.board[0].size(); ++j) {\n                if (state.board[i][j] == 1 || (i == state.kingX && j == state.kingY)) {\n                    for (int dir = 0; dir < 4; ++dir) {\n                        int ni = i + dx[dir];\n                        int nj = j + dy[dir];\n                        if (isValidMove(state.board, ni, nj, state.kingX, state.kingY)) {\n                            vector<vector<int>> newBoard = state.board;\n                            swap(newBoard[i][j], newBoard[ni][nj]);\n                            if (visited.find(stateHash(newBoard)) == visited.end()) {\n                                q.push(State(newBoard, state.kingX, state.kingY, state.moves + 1));\n                                visited.insert(stateHash(newBoard));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Try moving the king piece\n        for (int dir = 0; dir < 4; ++dir) {\n            int nkX = state.kingX + dx[dir];\n            int nkY = state.kingY + dy[dir];\n            int nkXOther = state.kingX + 1 + dx[dir];\n            int nkYOther = state.kingY + 1 + dy[dir];\n\n            if (isValidMove(state.board, nkX, state.kingY) &&\n                isValidMove(state.board, state.kingX, nkY) &&\n                isValidMove(state.board, nkXOther, state.kingY + 1) &&\n                isValidMove(state.board, state.kingX + 1, nkYOther)) {\n                \n                vector<vector<int>> newBoard = state.board;\n                swap(newBoard[state.kingX][state.kingY], newBoard[nkX][nkY]);\n                swap(newBoard[state.kingX+1][state.kingY+1], newBoard[nkXOther][nkYOther]);\n                \n                if (visited.find(stateHash(newBoard)) == visited.end()) {\n                    q.push(State(newBoard, nkX, nkY, state.moves + 1));\n                    visited.insert(stateHash(newBoard));\n                }\n            }\n        }\n    }\n    return -1; // no solution found\n}\n\nint main() {\n    vector<vector<int>> board = {\n        {0, 0, 0, 0},\n        {0, 0, 1, 1},\n        {0, 1, 1, 1},\n        {2, 2, 0, 0},\n    };\n    int kingX = 3, kingY = 0;\n    \n    cout << minimumMoves(board, kingX, kingY) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:15:55"
  }
]