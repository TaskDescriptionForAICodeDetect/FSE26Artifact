[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define INF ( 1<<29 )\n \ntypedef pair<int,int> P;\n \nint H,W;\nchar fie[51][51];\n \nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n \nint dx2[]={0,2,0,-1};\nint dy2[]={-1,0,2,0};\nint dx3[]={1,2,1,-1};\nint dy3[]={-1,1,2,1};\n \nint bmem[51][51];\n \n \nstruct state{\n  int x,y,d,c;\n  bool operator<(const state &a) const {\n    return c > a.c;\n  }\n};\n \nbool check(int x,int y,int kx,int ky){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( kx <= x && x <= kx + 1 && ky <= y && y <= ky + 1 ) return false; \n  if( fie[x][y] == '*' ) return false;\n  if( bmem[x][y] > -1 ) return false;\n  return true;\n}\n \nint bfs(int sx,int sy,int tx,int ty,int kx,int ky){\n  memset(bmem,-1,sizeof(bmem));\n  queue<P> q;\n  q.push( P(sx,sy) );\n  bmem[sx][sy] = 0;\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    int x = p.first, y = p.second;\n    if( x == tx && y == ty ) return bmem[x][y];\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( check( nx, ny, kx, ky ) ) {\n    q.push( P(nx,ny) );\n    bmem[nx][ny] = bmem[x][y] + 1;\n      }\n    }\n  }\n  return INF;   \n}\n \nint dmem[51][51][5];\n \nint solve(int x1,int y1,int x2,int y2,int kx,int ky){\n  priority_queue<state> q;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<4;k++) dmem[j][i][k] = INF;\n \n  for(int i=0;i<4;i++){\n    int px1 = kx + dx2[i], py1 = ky + dy2[i];\n    int px2 = kx + dx3[i], py2 = ky + dy3[i];\n     \n    int sca1 = bfs(x1,y1,px1,py1,kx,ky);\n    int sca2 = bfs(x1,y1,px2,py2,kx,ky);\n    int scb1 = bfs(x2,y2,px1,py1,kx,ky);\n    int scb2 = bfs(x2,y2,px2,py2,kx,ky);\n \n    int sc =  min( sca1 + scb2, sca2 + scb1 );\n    if( sc >= INF ) continue;\n    dmem[kx][ky][i] = sc;\n    q.push( (state){kx,ky,i,sc} );\n  }\n \n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    kx = p.x, ky = p.y;\n    int d = p.d, c = p.c;\n     \n    x1 = kx + dx2[d], y1 = ky + dy2[d];\n    x2 = kx + dx3[d], y2 = ky + dy3[d];\n    if( c > dmem[kx][ky][d] ) continue;\n    if( kx == 0 && ky == 0 ) return c;\n    for(int i=0;i<4;i++){\n      int nx = kx + dx[i], ny = ky + dy[i];\n      int px1 = kx + dx2[i], py1 = ky + dy2[i];\n      int px2 = kx + dx3[i], py2 = ky + dy3[i];\n       \n      int sca1 = bfs(x1,y1,px1,py1,kx,ky);\n      int sca2 = bfs(x1,y1,px2,py2,kx,ky);\n      int scb1 = bfs(x2,y2,px1,py1,kx,ky);\n      int scb2 = bfs(x2,y2,px2,py2,kx,ky);\n \n      int sc =  min( sca1 + scb2, sca2 + scb1 ) + 1;      \n      if( sc >= INF ) continue;\n      int nd = (i+2)%4;\n      if( sc + c < dmem[nx][ny][nd] ){\n    q.push( (state){nx,ny,nd,sc+c} );\n    dmem[nx][ny][nd] = sc + c;\n      }      \n    }\n  }\n  return -1;\n}\n \n \nint main(){\n  while( cin >> H >> W && (H||W) ){\n    int x1, y1,x2,y2, kx, ky;\n    bool f1 = false,f2 = false;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n    cin >> fie[j][i];\n    if( fie[j][i] == '.' ){\n      if( !f1 ){\n        x1 = j; y1 = i;  f1 = true;\n      } else {\n        x2 = j; y2 = i;\n      }\n    } else if ( fie[j][i] == 'X' && !f2) {\n      kx = j; ky = i; f2 = true;\n    }\n      }\n    }\n \n    if( kx == 0 && ky == 0 ) cout << 0 << endl;\n    else cout << solve(x1,y1,x2,y2,kx,ky) << endl;;\n     \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\ntypedef pair<int,PP>iPP;\n#define F first\n#define S second\n\nint h,w;\nint dis[31][31][31][31][8];\nint dp[31][31][8][8];\nint DX[]={0,1,2,2,1,0,-1,-1};\nint DY[]={-1,-1,0,1,2,2,1,0};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[55];\n\nvoid BFS_INIT(){\n    r(i,31)r(j,31)r(k,31)r(l,31)r(q,8)dis[i][j][k][l][q]=1e9;\n    r(i,h-1)r(j,w-1){\n        if(s[i][j]=='*'||s[i][j]=='*'||s[i][j]=='*'||s[i+1][j+1]=='*')continue;\n        set<P>st;\n        r(Y,2)r(X,2)st.insert(P(i+Y,j+X));\n        r(k,8){\n            int y=i+DY[k];\n            int x=j+DX[k];\n            if(y<0||x<0||y>=h||x>=w)continue;\n            if(s[y][x]=='*')continue;\n            dis[i][j][y][x][k]=0;\n            queue<P>q;\n            q.push(P(y,x));\n            //cout<<i<<j<<k<<endl;\n            while(!q.empty()){\n                int y=q.front().F;\n                int x=q.front().S;q.pop();\n                r(l,4){\n                    int ny=y+dy[l];\n                    int nx=x+dx[l];\n                    if(ny<0||nx<0||ny>=h||nx>=w)continue;\n                    if(s[ny][nx]=='*')continue;\n                    if(st.count(P(ny,nx)))continue;\n                    if(dis[i][j][ny][nx][k]!=1e9)continue;\n                    dis[i][j][ny][nx][k]=dis[i][j][y][x][k]+1;\n                    //cout<<i<<' '<<j<<' '<<ny<<' '<<nx<<' '<<k<<endl;\n                    q.push(P(ny,nx));\n                }\n            }\n        }\n    }\n}\n\nvoid STATE_INIT(){\n    int sx1,sx2,sy1,sy2,c=0,cnt=0,sx,sy;\n    r(i,31)r(j,31)r(k,8)r(l,8)dp[i][j][k][l]=1e9;\n    r(i,h)r(j,w){\n        if(s[i][j]=='.'){\n            if(!c)sx1=j,sy1=i,c++;\n            else sx2=j,sy2=i;\n        }\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        int gx1=sx+DX[i];\n        int gy1=sy+DY[i];\n        int gx2=sx+DX[j];\n        int gy2=sy+DY[j];\n        if(gx1<0||gy1<0||gx1>=w||gy1>=h)continue;\n        if(gx2<0||gy2<0||gx2>=w||gy2>=h)continue;\n        //cout<<i<<j<<' '<<dis[sy][sx][sy1][sx1][i]<<' '<<dis[sy][sx][sy2][sx2][j]<<endl;\n        if(dis[sy][sx][sy1][sx1][i]==1e9)continue;\n        if(dis[sy][sx][sy2][sx2][i]==1e9)continue;\n        dp[sy][sx][i][j]=dis[sy][sx][sy1][sx1][i]+dis[sy][sx][sy2][sx2][j];\n        dp[sy][sx][i][j]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n        dp[sy][sx][j][i]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n    }\n}\n\nint COST(int y,int x,int a,int b,int A,int B){\n    if(a!=A){\n        int Y=y+DY[a];\n        int X=x+DX[a];\n        return dis[y][x][Y][X][A];\n    }\n    if(b!=B){\n        int Y=y+DY[b];\n        int X=x+DX[b];\n        return dis[y][x][Y][X][B];\n    }\n}\n\nvoid DIJKSTRA(){\n    priority_queue<iPP,vector<iPP>,greater<iPP> >q;\n    int sx,sy,cnt=0;\n    r(i,h)r(j,w){\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        if(dp[sy][sx][i][j]==1e9)continue;\n        //cout<<i<<j<<' '<<dp[sy][sx][i][j]<<endl;\n        q.push(iPP(dp[sy][sx][i][j],PP(P(sy,sx),P(i,j))));\n    }\n    while(!q.empty()){\n        iPP p=q.top();q.pop();\n        int ky=p.S.F.F;\n        int kx=p.S.F.S;\n        int a=p.S.S.F;\n        int b=p.S.S.S;\n        int cost=p.F;\n        //cout<<ky<<' '<<kx<<' '<<a<<' '<<b<<' '<<cost<<endl;\n        if(!kx&&!ky){\n            cout<<cost<<endl;\n            return ;\n        }\n        if(dp[ky][kx][a][b]<cost)continue;\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,i,b)+cost;\n            if(dp[ky][kx][i][b]<=ncost)continue;\n            dp[ky][kx][i][b]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(i,b))));\n        }\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,a,i)+cost;\n            if(dp[ky][kx][a][i]<=ncost)continue;\n            dp[ky][kx][a][i]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(a,i))));\n        }\n        if(!((a+1==b) && (a%2==0)))continue;\n        //cout<<a<<' '<<b<<' '<<ky<<kx<<endl;\n        if(a==0)ky--,a=4,b=5;\n        else if(a==2)kx++,a=6,b=7;\n        else if(a==4)ky++,a=0,b=1;\n        else if(a==6)kx--,a=2,b=3;\n        int ncost=cost+1;\n        if(dp[ky][kx][a][b]<=ncost)continue;\n        dp[ky][kx][a][b]=ncost;\n        q.push(iPP(ncost,PP(P(ky,kx),P(a,b))));\n    }\n    cout<<-1<<endl;\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        r(i,h)cin>>s[i];\n        if(s[0][0]=='X'){\n            cout<<0<<endl;\n            continue;\n        }\n        BFS_INIT();\n        STATE_INIT();\n        DIJKSTRA();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,m,INF=1<<29,dxx[4]={-1,0,1,0},dyy[4]={0,-1,0,1};\nint dx[8]={-1,-1,0,1,2,2,0,1},dy[8]={0,1,-1,-1,0,1,2,2};\nstring s[55];\nbool check(int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\nbool check(int x,int y,int xx,int yy) {\n  if(x>=0&&x<n&&y>=0&&y<m) {\n    if(s[x][y]=='*') return 0;\n    if(x==xx&&(y==yy||y==yy+1)) return 0;\n    if(x==xx+1&&(y==yy||y==yy+1)) return 0;\n    return 1;\n  }\n  return 0;\n}\n\nint calc(int sx,int sy,int tx,int ty,int xx,int yy) {\n  if(!check(sx,sy,xx,yy)||!check(tx,ty,xx,yy)) return INF;\n  int d[n][m];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++) d[i][j]=INF;\n  d[sx][sy]=0;\n  queue<P> que;\n  que.push(P(sx,sy));\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    for(int i=0; i<4; i++) {\n      int x=p.F+dxx[i],y=p.S+dyy[i];\n      if(!check(x,y,xx,yy)||d[x][y]<=d[p.F][p.S]+1) continue;\n      d[x][y]=d[p.F][p.S]+1;\n      que.push(P(x,y));\n    }\n  }\n  return d[tx][ty];\n}\n\nint main() {\n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<4;k++)d[i][j][k]=INF;\n    vector<P> v;\n    P p=P(-1,-1);\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++) {\n        if(s[i][j]=='.')v.push_back(P(i,j));\n        if(s[i][j]=='X'&&p.F==-1) p=P(i,j);\n      }\n    if(p==P(0,0)) {\n      cout << 0 << endl;\n      continue;\n    }\n    priority_queue<PP> que;\n    for(int i=0; i<4; i++) {\n      int b[2]={0,1};\n      do {\n        int cost=calc(v[0].F,v[0].S,p.F+dx[i*2+b[0]],p.S+dy[i*2+b[0]],p.F,p.S);\n        cost+=calc(v[1].F,v[1].S,p.F+dx[i*2+b[1]],p.S+dy[i*2+b[1]],p.F,p.S);\n        d[p.F][p.S][i]=min(d[p.F][p.S][i],cost);\n      } while(next_permutation(b,b+2));\n      que.push(PP(P(0,i),p));\n    }\n    while(!que.empty()) {\n      PP pp=que.top();que.pop();\n      int x=pp.S.F,y=pp.S.S,k=pp.F.S,c=pp.F.F;\n      if(d[x][y][k]<c) continue;\n      for(int i=0; i<4; i++) {\n        int xx=x+dxx[i],yy=y+dyy[i]; \n        int cost=INF;\n        int b[2]={0,1};\n        do {\n          int sum=calc(x+dx[k*2],y+dy[k*2],x+dx[i*2+b[0]],y+dy[i*2+b[0]],x,y);\n          sum+=calc(x+dx[k*2+1],y+dy[k*2+1],x+dx[i*2+b[1]],y+dy[i*2+b[1]],x,y);\n          cost=min(cost,sum);\n        }while(next_permutation(b,b+2));\n        if(!check(xx,yy)||d[xx][yy][(i+2)%4]<=d[x][y][k]+cost+1) continue;\n        d[xx][yy][(i+2)%4]=d[x][y][k]+cost+1;\n        que.push(PP(P(d[xx][yy][(i+2)%4],(i+2)%4),P(xx,yy)));\n      }\n    }\n    int ans=INF;\n    for(int i=0; i<4; i++) ans=min(ans,d[0][0][i]);\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 50;\nconst int INF = 1 << 28;\n\nint h, w, cost[N][N][4][4];\nchar pz[N][N];\nint dy[8] = {-1, -1, 0, 1, 2, 2, 1, 0};\nint dx[8] = {0, 1, 2, 2, 1, 0, -1, -1};\nint dy2[4] = {-1, 0, 1, 0};\nint dx2[4] = {0, 1, 0, -1};\n\nvoid bfs(int sy, int sx, int vis[N][N]){\n  fill(vis[0], vis[N], INF);\n  vis[sy][sx] = 0;\n  queue<P> q;\n  q.push(P(sy * w + sx, 0));\n  while(!q.empty()){\n    P u = q.front(); q.pop();\n    int uy = u.first / w;\n    int ux = u.first % w;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(pz[ny][nx] == '*') continue;\n      if(vis[ny][nx] != INF) continue;\n      vis[ny][nx] = u.second + 1;\n      q.push(P(ny * w + nx, u.second + 1));\n    }\n  }\n}\n\nint calc(int y, int x, P f1, P f2, int t){\n  if(pz[y][x] == '*' || pz[y+1][x] == '*' || pz[y][x+1] == '*' || pz[y+1][x+1] == '*') return INF;\n  int ny1 = y + dy[t*2];\n  int nx1 = x + dx[t*2];\n  int ny2 = y + dy[t*2+1];\n  int nx2 = x + dx[t*2+1];\n  if(min(ny1, ny2) < 0 || max(ny1, ny2) >= h) return INF;\n  if(min(nx1, nx2) < 0 || max(nx1, nx2) >= w) return INF;\n  if(pz[ny1][nx1] == '*' || pz[ny2][nx2] == '*') return INF;\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = '*';\n  int vis[2][N][N];\n  bfs(f1.first, f1.second, vis[0]);\n  bfs(f2.first, f2.second, vis[1]);\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = 'X';\n  /*if(y == 0 && x == 0 && t == 2){\n    cout << f1.first << ' ' << f1.second << ' ';\n    cout << f2.first << ' ' << f2.second << \" -> \";\n    cout << ny1 << ' ' << nx1 << ' ';\n    cout << ny2 << ' ' << nx2 << ' ';\n    cout << vis[0][ny1][nx1]  << ' ' << vis[0][ny2][nx2] << ' ';\n    cout << vis[1][ny1][nx1]  << ' ' << vis[1][ny2][nx2] << endl;\n    }*/\n  return min(vis[0][ny1][nx1] + vis[1][ny2][nx2], vis[0][ny2][nx2] + vis[1][ny1][nx1]);\n}\n\nclass S{\npublic:\n  P p;\n  int fd, c;\n  S(){}\n  S(P p, int fd, int c) : p(p), fd(fd), c(c) {}\n  bool operator < (const S& s) const { return c > s.c; }\n};\n\nint solve(P s, P p1, P p2){\n  int dist[N][N][4];\n  priority_queue<S> que;\n  fill(dist[0][0], dist[N][0], INF);\n  for(int i=0;i<4;i++){\n    int ny = s.first + dy2[i];\n    int nx = s.second + dx2[i];\n    if(ny < 0 || ny+1 >= h) continue;\n    if(nx < 0 || nx+1 >= w) continue;\n    if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n    int nfd = (1 - i / 2) * 2 + i % 2;\n    dist[s.first][s.second][i] = calc(s.first, s.second, p1, p2, i);\n    que.push(S(P(s.first, s.second), i, dist[s.first][s.second][i]));\n  }\n  while(!que.empty()){\n    S u = que.top(); que.pop();\n    int uy = u.p.first;\n    int ux = u.p.second;\n    //cout << \"(\" << uy << \",\" << ux << \",\" << u.fd << \") = \" << u.c << endl;\n    if(dist[uy][ux][u.fd] < u.c) continue;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny+1 >= h) continue;\n      if(nx < 0 || nx+1 >= w) continue;\n      if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n      int nc = cost[uy][ux][u.fd][i];\n      int nfd = (1 - i / 2) * 2 + i % 2;\n      if(dist[ny][nx][nfd] > dist[uy][ux][u.fd] + nc + 1){\n        dist[ny][nx][nfd] = dist[uy][ux][u.fd] + nc + 1;\n        que.push(S(P(ny, nx), nfd, dist[ny][nx][nfd]));\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++) res = min(res, dist[0][0][i]);\n  return res == INF ? -1 : res;\n}\n\nmain(){\n  while(cin >> h >> w && (h|w)){\n    P s, p1, p2;\n    s = p1 = p2 = P(-1, -1);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> pz[i][j];\n        if(pz[i][j] == 'X' && s.first == -1) s = P(i, j);\n        if(pz[i][j] == '.'){\n          if(p1.first == -1) p1 = P(i, j);\n          else if(p2.first == -1) p2 = P(i, j);\n        }\n      }\n    }\n    if(pz[0][0] == 'X'){\n      cout << 0 << endl;\n      continue;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int f=0;f<4;f++){\n          for(int t=0;t<4;t++){\n            cost[i][j][f][t] = calc(i, j, P(i+dy[f*2], j+dx[f*2]), P(i+dy[f*2+1], j+dx[f*2+1]), t);\n            //cout << P(i+dy[f*2], j+dx[f*2]).first << ' ' << P(i+dy[f*2], j+dx[f*2]).second << endl;\n            //cout << i << ' ' << j << ' ' << f << ' ' << t << ' ' << cost[i][j][f][t] << endl;\n          }\n        }\n      }\n    }\n    cout << solve(s, p1, p2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define MAX 51\nusing namespace std;\nint h,w;\nstring G[MAX];\nint mincost[MAX*MAX][4][4];\nint dx[] = {+0,+1,+0,-1};//&#9757;↑→↓←\nint dy[] = {-1,+0,+1,+0};\nint kdx[] = {0,1,1,0};\nint kdy[] = {0,0,1,1};\n\n/*\n\no <- od \n2 <- d2\n   o2\n  2KKo\n  oKK2\n   2o    \n\n */\nint dx2[] = {+1,+0,-1,+0};\nint dy2[] = {+0,+1,+0,-1};\n\nint odx[] = {+0,+2,+1,-1};\nint ody[] = {-1,+0,+2,+1};\n\nstruct P\n{\n  int x,y;\n  P(int x=-1,int y=-1):x(x),y(y){}\n};\n\nstruct Pox\n{\n  P p;\n  int cost;\n  Pox(P p = P(),int cost=-1):p(p),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nstruct Pess\n{\n  P p;\n  int cost;\n  int dir;\n  Pess(P p = P(),int cost=-1,int dir=-1):p(p),cost(cost),dir(dir){}\n  bool operator < (const Pess &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\ninline\nint getIndex(P p){ return p.x+p.y*w; }\n\nint open_mincost[MAX*MAX];\n\nvoid open_the_door(P pxl,P king)//do not move the king before using this function\n{\n\n  priority_queue<Pox> Q;\n  Q.push(Pox(pxl,0));\n  bool used[MAX*MAX];\n  bool in_king[MAX*MAX];\n  rep(i,MAX*MAX)open_mincost[i] = inf,used[i] = false,in_king[i] = false;\n  open_mincost[getIndex(pxl)] = 0;\n  int cnt = 0;\n  rep(i,4)\n    {\n      int kx = king.x + kdx[i];\n      int ky = king.y + kdy[i];\n\n      if(!(0 <= kx && kx < w && 0 <= ky && ky < h))\n\t{\n\t  //cout << \"XXXXX error XXXXX\" << endl;\n\t  //cout << kx << \",\" << ky << \" are out of the range\" << endl;\n\t  assert(false);\n\t}\n      //cout << \"king : \" << kx << \",\" << ky << \" = \" << getIndex(P(kx,ky))<< endl;\n      in_king[getIndex(P(kx,ky))] = true;\n    }\n\n  rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(0 <= x1 && x1 < w && 0 <= y1 && y1 < h && G[y1][x1] != '*')\n\t{\t\n\t  //cout << \"add \" << x1 << \",\" << y1 << endl;\n\t  used[getIndex(P(x1,y1))] = true;\n\t  cnt++; \n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(0 <= x2 && x2 < w && 0 <= y2 && y2 < h && G[y2][x2] != '*')\n\t{\n\t  //cout << \"add \" << x2 << \",\" << y2 << endl;\n\t  used[getIndex(P(x2,y2))] = true;\n\t  cnt++; \n\t}\n\n    }\n  //cout << \"cnt = \" << cnt << endl;\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      if(used[getIndex(pox.p)])\n\t{\n\t  //cout <<\"here \"<< pox.p.x << \",\" << pox.p.y << endl;\n\t  used[getIndex(pox.p)] = false;\n\t  cnt--;\n\t}\n      if(cnt <= 0)\n\treturn;\n\n      rep(i,4)\n\t{\n\t  int nx = pox.p.x + dx[i];\n\t  int ny = pox.p.y + dy[i];\n\t  //cout << \"from\" << pox.p.x << \",\" << pox.p.y << \" want to go to \" << nx << \",\" << ny << endl;\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  //cout << \"---1\" << endl;\n\t  if(G[ny][nx] == '*')continue;\n\t  //cout << \"---3 \" << nx << \",\" << ny << \" \" << in_king[getIndex(P(nx,ny))] << endl;\t    \n\t  if(in_king[getIndex(P(nx,ny))])continue;\n\t  //cout << \"---4\" << endl;\n\t  //cout << \"now : \" << open_mincost[getIndex(P(nx,ny))] << \" >? \"<< pox.cost+1 << endl;\n\t  if(open_mincost[getIndex(P(nx,ny))] > pox.cost+1)\n\t    {\n\t      //cout << \"goto \" << nx << \",\" << ny  << \" : cost = \" << pox.cost+1<< endl;\n\t      //assert(!(nx == 3 && ny == 2));\n\t      open_mincost[getIndex(P(nx,ny))] = pox.cost+1;\n\t      Q.push(Pox(P(nx,ny),pox.cost+1));\n\t    }\n\t}\n    }\n}\n\nvoid init_mincost()\n{\n  int temp[4][2];\n  rep(i,MAX*MAX)rep(j,4)rep(k,4)mincost[i][j][k] = inf;\n\n  rep(i,h)\n    {\n      if(i+1 >= h)continue;\n      rep(j,w)\n\t{\n\t  if(G[i][j] == '*')continue;\n\t  if(j+1 >= w)continue;\n\t  rep(k,4)\n\t    {\n\t      int nx = j + odx[k];\n\t      int ny = i + ody[k];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '*')continue;\n\n\t      int mx = nx + dx2[k];\n\t      int my = ny + dy2[k];\n\t      if(!(0 <= mx && mx < w && 0 <= my && my < h))continue;\n\t      if(G[my][mx] == '*')continue;\n\n\t      open_the_door(P(nx,ny),P(j,i));//calculate the minimum cost from P(nx,ny) to all cells\n\t      rep(l,4)\n\t\t{//store the information about the minimum cost from P(nx,ny)\n\t\t  int x1 = j + odx[l];\n\t\t  int y1 = i + ody[l];\n\t\t  if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t\t    {\n\t\t      temp[l][0] = temp[l][1] = inf;\n\t\t      continue;\n\t\t    }\n\t\t  int x2 = x1 + dx2[l];\n\t\t  int y2 = y1 + dy2[l];\n\t\t  if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t\t    {\n\t\t      temp[l][0] = temp[l][1] = inf;\n\t\t      continue;\n\t\t    }\n\t\t  temp[l][0] = open_mincost[getIndex(P(x1,y1))];\n\t\t  temp[l][1] = open_mincost[getIndex(P(x2,y2))];\n\n\t\t}\n\t      /*\n\t\t  if(j == 4 && i == 2 && k == 2)\n\t\t    {\n\t\t      cout << \"origine!\" << endl;\n\t\t      cout << temp[3][0] << \" \" << temp[3][1] << endl;\n\t\t    }\n\t      */\n\t      open_the_door(P(mx,my),P(j,i));//caluclate the minimum cost from P(mx,my) to all cells\n\n\t      rep(l,4)\n\t\t{\n\t\t  int x1 = j + odx[l];\n\t\t  int y1 = i + ody[l];\n\t\t  if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t\t    {\n\t\t      continue;\n\t\t    }\n\t\t  int x2 = x1 + dx2[l];\n\t\t  int y2 = y1 + dy2[l];\n\t\t  if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t\t    {\n\t\t      continue;\n\t\t    }\n\t\t  mincost[getIndex(P(j,i))][k][l] = min(temp[l][0]+open_mincost[getIndex(P(x2,y2))],\n\t\t\t\t\t\t\ttemp[l][1]+open_mincost[getIndex(P(x1,y1))]);\n\n\n\t\t  if(k == l)\n\t\t    {\n\t\t      assert(mincost[getIndex(P(j,i))][k][l] == 0);\n\t\t    }\n\t\t}\n\n\t      /*\n\t\t  if(j == 4 && i == 2 && k == 2)\n\t\t    {\n\t\t      cout << \"habeii!\" << endl;\n\t\t      cout << mincost[getIndex(P(4,2))][2][3] << endl;\n\t\t    }\n\t      */\n\t    }\n\t}\n    }\n\n}\n\n/* collisionする場合ってありえる？\n->そもそも関係ない気がする！！！\nXXXXXXX\n      X\nXXXXX↓X\n   →collision!!!\nXXXXX\nXXXXXXXXXXXX.................................................\n.....XXXXXXX......................................\n.XXX.....XXXX.....................................\n...XXXXX....X.....................................\nKK.....X.XX.X.....................................\nKKXXXX...X........................................\n..X..XXXXX........................................\n.....XXXXX........................................\n..................................................\n */\n\n\n\nint King_Of_The_King[4];//&#9757;上、右、下、左\n\nbool check(int x,int y)\n{\n  //cout << \"isok? \" << x << \",\" << y << \" \"; \n  rep(i,4)\n    {\n      int kx = x + kdx[i];\n      int ky = y + kdy[i];\n      if(!(0 <= kx && kx < w && 0 <= ky && ky < h))\n\t{\n\t  //cout << \"NO!\" << endl;\n\t  return false;\n\t}\n      if(G[ky][kx] == '*')\n\t{\n\t  //cout << \"NO!!\" << endl;\n\t  return false;\n\t}\n    }\n  //cout << \" oK!\" << endl;\n  return true;\n}\n\nint costc[MAX*MAX][4];\nvoid dijkstra(P king)\n{\n  priority_queue<Pess> Q;\n  rep(i,4)\n    Q.push(Pess(king,King_Of_The_King[i],i));\n\n  rep(i,MAX*MAX)rep(j,4)costc[i][j] = inf;\n  rep(i,4)costc[getIndex(king)][i] = King_Of_The_King[i];\n\n  while(!Q.empty())\n    {\n      Pess pess = Q.top(); Q.pop();\n      //cout << \"------------- \" << pess.p.x << \",\" << pess.p.y << endl;\n      if(pess.p.x == 0 && pess.p.y == 0)\n\t{\n\t  cout << pess.cost << endl;\n\t  return;\n\t}\n      rep(i,4)\n\t{\n\t  int nx = pess.p.x + dx[i];\n\t  int ny = pess.p.y + dy[i];\n\t  if(!check(nx,ny))continue;\n\t  //cout << \"to \" << nx << \",\" << ny << \"  \" << costc[getIndex(P(nx,ny))][(i+2)%2] << \" > \" << pess.cost << \"+\" << mincost[getIndex(pess.p)][pess.dir][i]+1 << \" mincost[\"<<pess.p.x << \",\"<< pess.p.y<<\"][\"<<pess.dir<<\"][\"<<i<<\"]\"<< endl;\n\t  if(costc[getIndex(P(nx,ny))][(i+2)%2] > pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1)\n\t    {\n\t      //cout << \"from \" << pess.p.x << \",\" << pess.p.y << \" to \" << nx << \",\" << ny << endl;\n\t      costc[getIndex(P(nx,ny))][(i+2)%2] = pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1;\n\t      Q.push(Pess(P(nx,ny),pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1,(i+2)%4));\t    \n\t    }\n\t}\n    }\n  cout << -1 << endl;\n}\n\n//its time to play the game\nvoid move_open_to_the_side_of_King(P o1,P o2,P king)\n{\n  int temp[4][2];\n\n  open_the_door(o1,king);\n  rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t{\n\t  //temp[i][0] = temp[i][1] = inf;\n\t  temp[i][0] = temp[i][1] = 0;\n\t  continue;\n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t{\n\t  //temp[i][0] = temp[i][1] = inf;\n\t  temp[i][0] = temp[i][1] = 0;\n\t  continue;\n\t}\n      temp[i][0] = open_mincost[getIndex(P(x1,y1))];\n      temp[i][1] = open_mincost[getIndex(P(x2,y2))];\n    }\n\n  open_the_door(o2,king);\n rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t{\n\t  //King_Of_The_King[i] = inf;\n\t  King_Of_The_King[i] = 0;\n\t  continue;\n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t{\n\t  //King_Of_The_King[i] = inf;\n\t  King_Of_The_King[i] = 0;\n\t  continue;\n\t}\n\n      //cout << temp[i][0] << \",\" << temp[i][1] << \" \" << open_mincost[getIndex(P(x2,y2))] << \",\" << open_mincost[getIndex(P(x1,y1))] << endl;\n      King_Of_The_King[i] = min(temp[i][0]+open_mincost[getIndex(P(x2,y2))],\n\t\t\t\ttemp[i][1]+open_mincost[getIndex(P(x1,y1))]);\n    }\n\n}\n\n\n\n\nint main()\n{\n  //clock_t st,ed;\n  //st = clock();\n  while(cin >> h >> w,h|w)\n    {\n\n      vector<P> open;\n      P king;\n\n      rep(i,h)\n\t{\n\t  cin >> G[i];\n\t  rep(j,w)\n\t    {\n\t      if(G[i][j]  == '.')\n\t\topen.push_back(P(j,i));\n\t      \n\t      if(G[i][j] == 'X' && king.x == -1 && king.y == -1)\n\t\tking = P(j,i);\n\t    }\n\t}\n\n      if(king.x == 0 && king.y == 0)\n\t{\n\t  cout << 0 << endl;\n\t  continue;\n\t}\n\n      init_mincost();\n      move_open_to_the_side_of_King(open[0],open[1],king);\n      dijkstra(king);\n      //move_open_to_the_side_of_King(open[0],open[1],king);\n      //cout << King_Of_The_King[0] << endl;\n      //cout << King_Of_The_King[1] << endl;\n      //cout << King_Of_The_King[2] << endl;\n      //cout << King_Of_The_King[3] << endl;\n\n      //open_the_door(P(4,4),P(4,2));\n      \n      //cout << open_mincost[getIndex(P(3,2))] << endl;\n      //cout << open_mincost[getIndex(P(3,3))] << endl;\n      /*\n      init_mincost();\n      int cnt = 1;\n      rep(i,h)\n      {\n      rep(j,w)\n      {\n\t//cout << \"from \" << j << \" \" << i << endl;\n      rep(k,4)\n      {\n      rep(l,4)\n      {\n\tif(cnt == 113)\n\t  {\n\t    cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t  }\n\tcnt++;\n\tif(mincost[j+i*w][k][l] >= inf)cout << 0 << endl;\n\telse cout << mincost[j+i*w][k][l]+1 << endl;\n      }\n      }\n      }\n      }\n      */\n      //cout << mincost[getIndex(P(3,3))][0][2] << endl;\n      \n    }\n  //ed = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 50;\nconst int INF = 1 << 28;\n\nint h, w, cost[N][N][4][4];\nchar pz[N][N];\nint dy[8] = {-1, -1, 0, 1, 2, 2, 1, 0};\nint dx[8] = {0, 1, 2, 2, 1, 0, -1, -1};\nint dy2[4] = {-1, 0, 1, 0};\nint dx2[4] = {0, 1, 0, -1};\n\nvoid bfs(int sy, int sx, int vis[N][N]){\n  fill(vis[0], vis[N], INF);\n  vis[sy][sx] = 0;\n  queue<P> q;\n  q.push(P(sy * w + sx, 0));\n  while(!q.empty()){\n    P u = q.front(); q.pop();\n    int uy = u.first / w;\n    int ux = u.first % w;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(pz[ny][nx] == '*') continue;\n      if(vis[ny][nx] != INF) continue;\n      vis[ny][nx] = u.second + 1;\n      q.push(P(ny * w + nx, u.second + 1));\n    }\n  }\n}\n\nint calc(int y, int x, P f1, P f2, int t){\n  if(pz[y][x] == '*' || pz[y+1][x] == '*' || pz[y][x+1] == '*' || pz[y+1][x+1] == '*') return INF;\n  int ny1 = y + dy[t*2];\n  int nx1 = x + dx[t*2];\n  int ny2 = y + dy[t*2+1];\n  int nx2 = x + dx[t*2+1];\n  if(min(ny1, ny2) < 0 || max(ny1, ny2) >= h) return INF;\n  if(min(nx1, nx2) < 0 || max(nx1, nx2) >= w) return INF;\n  if(pz[ny1][nx1] == '*' || pz[ny2][nx2] == '*') return INF;\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = '*';\n  int vis[2][N][N];\n  bfs(f1.first, f1.second, vis[0]);\n  bfs(f2.first, f2.second, vis[1]);\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = 'X';\n  return min(vis[0][ny1][nx1] + vis[1][ny2][nx2], vis[0][ny2][nx2] + vis[1][ny1][nx1]);\n}\n\nclass S{\npublic:\n  P p;\n  int fd, c;\n  S(){}\n  S(P p, int fd, int c) : p(p), fd(fd), c(c) {}\n  bool operator < (const S& s) const { return c > s.c; }\n};\n\nint solve(P s, P p1, P p2){\n  int dist[N][N][4];\n  priority_queue<S> que;\n  fill(dist[0][0], dist[N][0], INF);\n  for(int i=0;i<4;i++){\n    int ny = s.first + dy2[i];\n    int nx = s.second + dx2[i];\n    if(ny < 0 || ny+1 >= h) continue;\n    if(nx < 0 || nx+1 >= w) continue;\n    if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n    int nfd = (1 - i / 2) * 2 + i % 2;\n    dist[s.first][s.second][i] = calc(s.first, s.second, p1, p2, i);\n    que.push(S(P(s.first, s.second), i, dist[s.first][s.second][i]));\n  }\n  while(!que.empty()){\n    S u = que.top(); que.pop();\n    int uy = u.p.first;\n    int ux = u.p.second;\n    if(dist[uy][ux][u.fd] < u.c) continue;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny+1 >= h) continue;\n      if(nx < 0 || nx+1 >= w) continue;\n      if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n      int nc = cost[uy][ux][u.fd][i];\n      int nfd = (1 - i / 2) * 2 + i % 2;\n      if(dist[ny][nx][nfd] > dist[uy][ux][u.fd] + nc + 1){\n        dist[ny][nx][nfd] = dist[uy][ux][u.fd] + nc + 1;\n        que.push(S(P(ny, nx), nfd, dist[ny][nx][nfd]));\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++) res = min(res, dist[0][0][i]);\n  return res == INF ? -1 : res;\n}\n\nmain(){\n  while(cin >> h >> w && (h|w)){\n    P s, p1, p2;\n    s = p1 = p2 = P(-1, -1);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> pz[i][j];\n        if(pz[i][j] == 'X' && s.first == -1) s = P(i, j);\n        if(pz[i][j] == '.'){\n          if(p1.first == -1) p1 = P(i, j);\n          else if(p2.first == -1) p2 = P(i, j);\n        }\n      }\n    }\n    if(pz[0][0] == 'X'){\n      cout << 0 << endl;\n      continue;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int f=0;f<4;f++){\n          for(int t=0;t<4;t++){\n            cost[i][j][f][t] = calc(i, j, P(i+dy[f*2], j+dx[f*2]), P(i+dy[f*2+1], j+dx[f*2+1]), t);\n          }\n        }\n      }\n    }\n    cout << solve(s, p1, p2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tqueue<tuple<pii,pii,pii,int>> q;\n\t\t{\n\t\t\tpii king(-1,-1);\n\t\t\tvector<pii> opens;\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X' && king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\tif(grid[i][j]=='.') opens.emplace_back(i,j);\n\t\t\t}\n\t\t\tq.emplace(king,opens[0],opens[1],0);\n\t\t}\n\t\t\n\t\tint res=-1;\n\t\tset<tuple<pii,pii,pii>> vis;\n\t\twhile(q.size()){\n\t\t\tpii ck,co1,co2; int step;\n\t\t\ttie(ck,co1,co2,step)=q.front(); q.pop();\n\t\t\tif(vis.count(make_tuple(ck,co1,co2))) continue;\n\t\t\tvis.insert(make_tuple(ck,co1,co2));\n\t\t\t\n\t\t\tif(ck==mp(0,0)){\n\t\t\t\tres=step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(k,4){\n\t\t\t\tint ni,nj;\n\t\t\t\tni=co1.first+\"\\xff\\x1\\0\\0\"[k],nj=co1.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co2\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=mp(ni,nj),no2=co2; if(no1>no2) swap(no1,no2);\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tni=co2.first+\"\\xff\\x1\\0\\0\"[k],nj=co2.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co1\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=co1,no2=mp(ni,nj); if(no1>no2) swap(no1,no2);\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.first==co2.first && co1.second+1==co2.second){\n\t\t\t\tif(ck.first==co1.first+1 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first-1,ck.second),no1(co1.first+2,co1.second),no2(co2.first+2,co2.second);\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.first==co1.first-2 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first+1,ck.second),no1(co1.first-2,co1.second),no2(co2.first-2,co2.second);\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.second==co2.second && co1.first+1==co2.first){\n\t\t\t\tif(ck.second==co1.second+1 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second-1),no1(co1.first,co1.second+2),no2(co2.first,co2.second+2);\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.second==co1.second-2 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second+1),no1(co1.first,co1.second-2),no2(co2.first,co2.second-2);\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nbool u[52][52][52][52];\nbool u2[50][50][2][50][50];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    auto inside=[H,W](int y,int x){\n      return 0<=y&&y<H&&0<=x&&x<W;\n    };\n    char g[52][52];\n    int sy[2],sx[2],sn=0;\n    int sky=-1,skx;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='.'){\n\t  sy[sn]=i;\n\t  sx[sn]=j;\n\t  sn++;\n\t}\n\tif(sky<0&&g[i][j]=='X'){\n\t  sky=i;\n\t  skx=j;\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n      continue;\n    }\n    fill(***begin(u),***end(u),false);\n    queue<tuple<int,int,int,int,int> > que;\n    que.push(make_tuple(0,sy[0],sx[0],sy[1],sx[1]));\n    //    priority_queue<tuple<int,int,int,int,int,int>,vector<tuple<int,int,int,int,int,int> >,greater<tuple<int,int,int,int,int,int> > > que2;\n    set<tuple<int,int,int,int,int,int> >que2;\n    while(!que.empty()){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      auto c=que.front();\n      que.pop();\n      int t,y1,x1,y2,x2;\n      tie(t,y1,x1,y2,x2)=c;\n      if(u[y1][x1][y2][x2]++)continue;\n      for(int i=0;i<4;i++){\n\tint ny1=y1+dy[i];\n\tint nx1=x1+dx[i];\n\tint ny2=y2+dy[i];\n\tint nx2=x2+dx[i];\n\tif(inside(ny1,nx1)&&inside(ny2,nx2)&&g[ny1][nx1]=='X'&&g[ny2][nx2]=='X'){\n\t  que2.insert(make_tuple(t,min(y1,y2),min(x1,x2),x1!=x2,sky,skx));\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<4;j++){\n\t  int ny1=i?y1+dy[j]:y1;\n\t  int nx1=i?x1+dx[j]:x1;\n\t  int ny2=i?y2:y2+dy[j];\n\t  int nx2=i?x2:x2+dx[j];\n\t  if(!inside(ny1,nx1)||!inside(ny2,nx2)||ny1==ny2&&nx1==nx2||g[ny1][nx1]=='X'||g[ny1][nx1]=='*'||g[ny2][nx2]=='X'||g[ny2][nx2]=='*')continue;\n\t  que.push(make_tuple(t+1,ny1,nx1,ny2,nx2));\n\t}\n      }\n    }\n    fill(****begin(u2),****end(u2),false);\n    while(!que2.empty()){\n      auto c=*que2.begin();\n      int t,y,x,d,ky,kx;\n      tie(t,y,x,d,ky,kx)=c;\n      if(ky==0&&kx==0)break;\n      que2.erase(que2.begin());\n      if(u2[y][x][d][ky][kx]++)continue;\n      //      cout<<ky<<' '<<kx<<endl;\n      for(int i=0;i<6;i++){\n\tstatic int ndy[2][6]={\n\t  {-1,2,0,1,0,1},\n\t  {0,0,1,1,-1,-1}\n\t};\n\tstatic int ndx[2][6]={\n\t  {0,0,-1,-1,1,1},\n\t  {-1,2,0,1,0,1}\n\t};\n\tint cy=y+ndy[d][i];\n\tint cx=x+ndx[d][i];\n\tif(inside(cy,cx)&&g[cy][cx]!='*'&&(cy<ky||ky+2<=cy||cx<kx||kx+2<=cx)){\n\t  static int hdy[2][6]={\n\t    {-1,1,0,1,0,1},\n\t    {0,0,0,0,-1,-1}\n\t  };\n\t  static int hdx[2][6]={\n\t    {0,0,-1,-1,0,0},\n\t    {-1,1,0,1,0,1}\n\t  };\n\t  if(!u2[y+hdy[d][i]][x+hdx[d][i]][d^(i>=2)][ky][kx]){\n\t    que2.insert(make_tuple(t+2,y+hdy[d][i],x+hdx[d][i],d^(i>=2),ky,kx));\n\t  }\n\t}\n      }\n      if(y==ky&&d==0){\n\tif(kx-1==x){\n\t  que2.insert(make_tuple(t+1,y,x+2,d,ky,kx-1));\n\t}else if(kx+2==x){\n\t  que2.insert(make_tuple(t+1,y,x-2,d,ky,kx+1));\n\t}\n      }else if(x==kx&&d==1){\n\tif(ky-1==y){\n\t  que2.insert(make_tuple(t+1,y+2,x,d,ky-1,kx));\n\t}else if(ky+2==y){\n\t  que2.insert(make_tuple(t+1,y-2,x,d,ky+1,kx));\n\t}\n      }\n    }\n    cout<<(que2.empty()?-1:get<0>(*que2.begin()))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define miz(x,y) x=min(x,y)\ntypedef pair<int,int> P;\nstruct state{\n\tint x,y,di;\n\tbool operator < (const state& r) const{\n\t\tif(x!=r.x) return x<r.x;\n\t\tif(y!=r.y) return y<r.y;\n\t\treturn di<r.di;\n\t}\n};\nstruct edge{\n\tstate to;\n\tint cost;\n};\ntypedef pair<int,state> pa;\nmap<state,vector<edge> > mp;\nint H,W,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ddx[8]={2,2,1,0,-1,-1,0,1};\nint ddy[8]={0,1,2,2,1,0,-1,-1};\nint inf=1e8;\nstring board[50];\nbool is(int x,int y){\n\tif(x<0||H<=x||y<0||W<=y) return false;\n\tif(board[x][y]=='*') return false;\n\treturn true;\n}\nint calcd(P s,P t,vector<P> vc){\n\tqueue<P> que;\n\tint d[50][50]={};\n\trep(i,H) rep(j,W) d[i][j]=inf;\n\tque.push(s);\n\td[s.fs][s.sc]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tif(p==t) break;\n\t\tint x=p.fs,y=p.sc;\n\t\trep(j,4){\n\t\t\tint nx=x+dx[j],ny=y+dy[j];\n\t\t\tif(d[nx][ny]!=inf) continue;\n\t\t\tbool can=is(nx,ny);\n\t\t\trep(k,4) if(nx==vc[k].fs&&ny==vc[k].sc) can=false;\n\t\t\tif(!can) continue;\n\t\t\tque.push(P(nx,ny));\n\t\t\td[nx][ny]=d[x][y]+1;\n\t\t}\n\t}\n\treturn d[t.fs][t.sc];\n}\nint calccost(int x,int y,int d1,int d2){\n\tint ret=inf;\n\tvector<P> banned;\n\trep(i,2) rep(j,2) banned.pb(P(x+i,y+j));\n\tP s1=P(x+ddx[d1*2],y+ddy[d1*2]);\n\tP s2=P(x+ddx[d1*2+1],y+ddy[d1*2+1]);\n\tP t1=P(x+ddx[d2*2],y+ddy[d2*2]);\n\tP t2=P(x+ddx[d2*2+1],y+ddy[d2*2+1]);\n\tmiz(ret,calcd(s1,t1,banned)+calcd(s2,t2,banned));\n\tmiz(ret,calcd(s1,t2,banned)+calcd(s2,t1,banned));\n\treturn ret;\n}\nint calccost2(int x,int y,int di,P s1,P s2){\n\tint ret=inf;\n\tvector<P> banned;\n\trep(i,2) rep(j,2) banned.pb(P(x+i,y+j));\n\tP t1=P(x+ddx[di*2],y+ddy[di*2]);\n\tP t2=P(x+ddx[di*2+1],y+ddy[di*2+1]);\n\tmiz(ret,calcd(s1,t1,banned)+calcd(s2,t2,banned));\n\tmiz(ret,calcd(s1,t2,banned)+calcd(s2,t1,banned));\n\treturn ret;\n}\nbool canput(int x,int y,int di){\n\treturn is(x+ddx[di*2],y+ddy[di*2])&&is(x+ddx[di*2+1],y+ddy[di*2+1]);\n}\npriority_queue<pa,vector<pa>,greater<pa> > que;\nmap<state,int> d;\nint main(){\n\twhile(true){\n\t\tmp.clear();\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\trep(i,H) cin>>board[i];\n\t\trep(i,H-1) rep(j,W-1){\n\t\t\tbool king=true;\n\t\t\trep(k1,2) rep(k2,2) if(!is(i+k1,j+k2)) king=false;\n\t\t\tif(!king) continue;\n//\t\t\tshow(i);\n//\t\t\tshow(j);\n\t\t\trep(d1,4){\n//\t\t\t\tif(i==1&&j==0) show(d1);\n\t\t\t\tif( !canput(i,j,d1) ) continue;\n\t\t\t\trep(d2,4){\n\t\t\t\t\tif(d1==d2) continue;\n\t\t\t\t\tif( !canput(i,j,d2) ) continue;\n//\t\t\t\t\tif(i==1&&j==0&&d1==1) show(d2);\n\t\t\t\t\tint cost=calccost(i,j,d1,d2);\n\t\t\t\t\tif(cost!=inf){\n\t\t\t\t\t\tmp[state{i,j,d1}].pb(edge{state{i,j,d2},cost});\n//\t\t\t\t\t\tprintf(\"i=%d, j=%d, d1=%d, d2=%d  cost=%d\\n\",i,j,d1,d2,cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,H-1) rep(j,W-1) rep(di,4){\n\t\t\tif( !canput(i,j,di) ) continue;\n\t\t\tmp[state{i,j,di}].pb(edge{state{i+dx[di],j+dy[di],(di+2)%4},1});\n//\t\t\tprintf(\"i=%d, j=%d, di=%d,  -> %d %d %d\\n\",i,j,di,i+dx[di],j+dy[di],(di+2)%4);\n\t\t}\n\t\twhile(!que.empty()) que.pop();\n\t\td.clear();\n\t\tint sx,sy;\n\t\tP s1,s2;\n\t\tint cnt=0;\n\t\trep(i,H) rep(j,W) if(board[i][j]=='X'){\n\t\t\tsx=i,sy=j;\n\t\t\tgoto br;\n\t\t}\n\t\tbr:\n\t\tif(sx==0&&sy==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H) rep(j,W) if(board[i][j]=='.'){\n\t\t\tif(cnt==0) s1=P(i,j),cnt++;\n\t\t\telse s2=P(i,j);\n\t\t}\n\t\trep(di,4){\n\t\t\tif(!canput(sx,sy,di)) continue;\n\t\t\tint cost=calccost2(sx,sy,di,s1,s2);\n\t\t\tif(cost!=inf){\n\t\t\t\tque.push(pa(cost,state{sx,sy,di}));\n\t\t\t\td[state{sx,sy,di}]=cost;\n//\t\t\t\tshow(sx);\n//\t\t\t\tshow(sy);\n//\t\t\t\tshow(di);\n//\t\t\t\tshow(cost);\n//\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tpa pat=que.top();\n\t\t\tque.pop();\n\t\t\tstate st=pat.sc;\n\t\t\tint dist=pat.fs;\n\t\t\tif(d[st]<dist) continue;\n\t\t\tfor(auto e : mp[st]){\n\t\t\t\tif(d.find(e.to)==d.end()||d[e.to]>d[st]+e.cost){\n\t\t\t\t\td[e.to]=d[st]+e.cost;\n\t\t\t\t\tque.push(pa(d[e.to],e.to));\n//\t\t\t\t\tshow(e.to.x);\n//\t\t\t\t\tshow(e.to.y);\n//\t\t\t\t\tshow(e.to.di);\n//\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tstate start=state{0,0,0};\n\t\tif(d.find(start)!=d.end()) miz(ans,d[start]);\n\t\tstart=state{0,0,1};\n\t\tif(d.find(start)!=d.end()) miz(ans,d[start]);\n\t\tif(ans==inf) ans=-1;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > P;\ntypedef pair< int , P > PP;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\n\nint d[50][50];\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      d[i][j]=1e8;\n  d[sy][sx]=0;\n  \n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(y==ty&&x==tx)break;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n  \n  return d[ty][tx];\n}\n\nint dd[50][50][4];\nint solve(int sy,int sx,int sd){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<4;k++)\n        dd[i][j][k]=1e8;\n\n  dd[sy][sx][sd]=0;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  Q.push( PP(0, P(sy*50+sx,sd) ) );\n\n  while(!Q.empty()){\n    PP pp = Q.top();Q.pop();\n    int y=pp.second.first/50;\n    int x=pp.second.first%50;\n    int dir=pp.second.second;\n    if(y==0&&x==0)return dd[y][x][dir];\n    if(pp.first > dd[y][x][dir])continue;\n    \n    for(int i=0;i<4;i++){\n      int ncost=dd[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax)+calc(y,x,by,bx,By,Bx) ,\n                  calc(y,x,ay,ax,By,Bx)+calc(y,x,by,bx,Ay,Ax) );\n\n      ncost++;\n      if(dd[ny][nx][i]>ncost){\n        dd[ny][nx][i]=ncost;\n        Q.push(PP(ncost,P(ny*50+nx,i)));\n        \n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sy,sx,py0,px0,ay,ax) + calc(sy,sx,py1,px1,by,bx)\n                    , calc(sy,sx,py0,px0,by,bx) + calc(sy,sx,py1,px1,ay,ax) );\n\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P> P3;\n \nstring s[55];\nint h, w;\n \nint Ady[4]={-1,0,2,1};\nint Adx[4]={0,2,1,-1};\nint Bdy[4]={-1,1,2,0};\nint Bdx[4]={1,2,0,-1};\n \nint bfs(P st, P g){\n  \n  int d[55][55];\n  queue<P3> q;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) d[i][j]=INF;\n \n  d[st.first][st.second]=0;\n  q.push(P3(0,st));\n  \n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n   \n  while(!q.empty()){\n     \n    P3 t=q.front(); q.pop();\n     \n    int cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n     \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(s[ny][nx]=='*') continue;\n      if(d[ny][nx]!=INF) continue;\n      d[ny][nx]=cost+1;\n      q.push(P3(cost+1,P(ny,nx)));\n    }\n     \n  }\n   \n  return d[g.first][g.second];\n}\n \nint min_cost2(P A, P B, P C, P D){\n   \n  int r = bfs(A, B);\n  \n  r+=bfs(C, D);\n \n  if(r>INF) r=INF;\n   \n  return r;\n}\n \nint min_cost(vector<P> start, P A, P B, P C){\n   \n  int dy[4]={0,0,1,1};\n  int dx[4]={0,1,0,1};\n   \n  P g1=start[0], g2=start[1];\n \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='*';\n \n  int res=INF;\n   \n  res=min(res, min_cost2(A, g1, B, g2));\n  res=min(res, min_cost2(A, g2, B, g1));\n  \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='.';\n \n  return res;\n}\n \nint d[55][55][4];\n   \nbool check(P p){\n  if(p.first<0||h<=p.first||p.second<0||w<=p.second) return false;\n  if(s[p.first][p.second]=='*') return false;\n  return true;\n}\n \nvector<P> get(P A, int idx){\n   \n  vector<P> res;\n   \n  res.push_back(P(A.first+Ady[idx], A.second+Adx[idx]));\n  res.push_back(P(A.first+Bdy[idx], A.second+Bdx[idx]));\n   \n  return res;\n}\n \npriority_queue<P2,vector<P2>,greater<P2> > q;\n \nint dijkstra(){\n   \n  int res = INF;\n   \n  while(!q.empty()){\n     \n    P2 t = q.top(); q.pop();\n     \n    int cost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int idx=t.second.second;\n     \n    if(y==0&&x==0) res=min(res, cost);\n    \n    if(d[y][x][idx]<cost) continue;\n\n    for(int i=0;i<4;i++){\n       \n      P A = P(y+Ady[i], x+Adx[i]);\n      P B = P(y+Bdy[i], x+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n \n      vector<P> start=get(P(y,x), idx);\n       \n      if(!check(start[0])||!check(start[1])) continue;\n     \n      int add_cost = min_cost(start,A,B,P(y,x));\n       \n      if(add_cost==INF) continue;\n \n      int dy[4]={-1,0,1,0};\n      int dx[4]={0,1,0,-1};\n       \n      int ny=y+dy[i], nx=x+dx[i];\n      int ncost=cost+add_cost+1;\n      \n      if(d[ny][nx][(i+2)%4]>ncost){\n\td[ny][nx][(i+2)%4] = ncost;\n\tq.push(P2(P(ncost,ny),P(nx,(i+2)%4)));\n      }\n      \n    }\n \n  }\n \n  if(res==INF) res=-1;\n   \n  return res;  \n}\n \nint main(){\n   \n  while(1){\n     \n    cin>>h>>w;\n    if(!h&&!w) break;\n \n    vector<P> start;\n    int sy=-1, sx;\n     \n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.')\n\t  start.push_back(P(i,j));\n\tif(sy==-1&&s[i][j]=='X') sy=i, sx=j;\n      }\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++) d[i][j][k]=INF;\n     \n    for(int i=0;i<4;i++){\n       \n      P A = P(sy+Ady[i], sx+Adx[i]);\n      P B = P(sy+Bdy[i], sx+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n      \n      int cost = min_cost(start,A,B,P(sy,sx));\n      \n      d[sy][sx][i] = cost;\n       \n      q.push(P2(P(cost,sy),P(sx,i)));\n    }\n \n    if(sy==0&&sx==0) cout<<0<<endl;\n    else cout<<dijkstra()<<endl;\n    \n    while(!q.empty()) q.pop();\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nchar b[50][50];\nint st[2];\nint pos;\nint dp[4*50*50*50+50*50+50];\nint dis[2][50*50+50];\nvector<P> e[4*50*50+50*50+50];\nqueue<int> que;\npriority_queue<P, vector<P>, greater<P> > pque;\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\nint ddy[4][2] = {{1,1},{0,-1},{-2,-2},{0,-1}};\nint ddx[4][2] = {{0,-1},{1,1},{0,-1},{-2,-2}};\n\nvoid bfs(int now, int id, int p){\n    rep(i,50*50+50) dis[id][i] = INF;\n    dis[id][now] = 0;\n    que.push(now);\n    while(!que.empty()){\n        int y = que.front()/50, x = que.front()%50;\n        que.pop();\n        rep(i,4){\n            int yy = y+dy[i], xx = x+dx[i];\n            if(0>yy||yy>=h||0>xx||xx>=w) continue;\n            if(b[yy][xx] == '*') continue;\n            if(yy == p/50 && xx == p%50) continue;\n            if(yy == p/50-1 && xx == p%50) continue;\n            if(yy == p/50 && xx == p%50-1) continue;\n            if(yy == p/50-1 && xx == p%50-1) continue;\n            if(dis[id][yy*50+xx] != INF) continue;\n            dis[id][yy*50+xx] = dis[id][y*50+x]+1;\n            que.push(yy*50+xx);\n        }\n    }\n}\n\nbool inrange(int y, int x){\n    if(b[y][x] == '*') return false;\n    if(b[y-1][x] == '*') return false;\n    if(b[y][x-1] == '*') return false;\n    if(b[y-1][x-1] == '*') return false;\n    return true;\n}\n\nvoid init(){\n    rep(i,2){\n        bfs(st[i],i,pos);\n    }\n    int py = pos/50, px = pos%50;\n    rep(i,4){\n        if(0>py+ddy[i][0]||py+ddy[i][0]>=h||0>px+ddx[i][0]||px+ddx[i][0]>=w) continue;\n        if(0>py+ddy[i][1]||py+ddy[i][1]>=h||0>px+ddx[i][1]||px+ddx[i][1]>=w) continue;\n        int d1 = dis[0][(py+ddy[i][0])*50+px+ddx[i][0]]+dis[1][(py+ddy[i][1])*50+px+ddx[i][1]];\n        int d2 = dis[0][(py+ddy[i][1])*50+px+ddx[i][1]]+dis[1][(py+ddy[i][0])*50+px+ddx[i][0]];\n        d1 = min(d1,d2);\n        if(d1 >= INF) continue;\n        pque.push(P(d1,i*50*50+py*50+px));\n        dp[i*50*50+py*50+px] = d1;\n    }\n    for(int i = 1; i < h; i++) for(int j = 1; j < w; j++) rep(k,4){\n        if(!inrange(i,j)) continue;\n        if(0>i+ddy[k][0]||i+ddy[k][0]>=h||0>j+ddx[k][0]||j+ddx[k][0]>=w) continue;\n        if(0>i+ddy[k][1]||i+ddy[k][1]>=h||0>j+ddx[k][1]||j+ddx[k][1]>=w) continue;\n        if(b[i+ddy[k][0]][j+ddx[k][0]] == '*') continue;\n        if(b[i+ddy[k][1]][j+ddx[k][1]] == '*') continue;\n        bfs((i+ddy[k][0])*50+j+ddx[k][0],0,i*50+j);\n        bfs((i+ddy[k][1])*50+j+ddx[k][1],1,i*50+j);\n        rep(l,4){\n            if(k == l) continue;\n            if(0>i+ddy[k][0]||i+ddy[k][0]>=h||0>j+ddx[k][0]||j+ddx[k][0]>=w) continue;\n            if(0>i+ddy[k][1]||i+ddy[k][1]>=h||0>j+ddx[k][1]||j+ddx[k][1]>=w) continue;\n            if(b[i+ddy[k][0]][j+ddx[k][0]] == '*') continue;\n            if(b[i+ddy[k][1]][j+ddx[k][1]] == '*') continue;\n            int d1 = dis[0][(i+ddy[l][0])*50+j+ddx[l][0]]+dis[1][(i+ddy[l][1])*50+j+ddx[l][1]];\n            int d2 = dis[0][(i+ddy[l][1])*50+j+ddx[l][1]]+dis[1][(i+ddy[l][0])*50+j+ddx[l][0]];\n            d1 = min(d1,d2);\n            if(d1 >= INF) continue;\n            e[k*50*50+i*50+j].push_back(P(l*50*50+i*50+j,d1));\n        }\n    }\n}\n\nvoid solve(){\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    while(!pque.empty()) pque.pop();\n    rep(i,4*50*50+50*50+50) e[i].clear();\n    rep(i,4*50*50*50+50*50+50) dp[i] = INF;\n    int cnt = 0;\n    rep(i,h) rep(j,w) if(b[i][j] == '.'){\n        st[cnt++] = i*50+j;\n        b[i][j] = 'o';\n    }\n    rep(i,h) rep(j,w) if(b[i][j] == 'X'){\n        pos = 50*i+j;\n        b[i][j] = 'o';\n    }\n    if(pos == 51){\n        cout << 0 << endl;\n        return;\n    }\n    rep(i,4){\n        int ii = (i+2)%4;\n        for(int j = 1; j < h; j++){\n            int jj = j+dy[i];\n            for(int k = 1; k < w; k++){\n                int kk = k+dx[i];\n                if(1>jj||jj>=h||1>kk||kk>=w) continue;\n                if(!inrange(j,k)) continue;\n                if(!inrange(jj,kk)) continue;\n                e[i*50*50+j*50+k].push_back(P(ii*50*50+jj*50+kk,1));\n            }\n        }\n    }\n    init();\n    while(!pque.empty()){\n        P p = pque.top();\n        pque.pop();\n        if(p.first > dp[p.second]) continue;\n        rep(i,e[p.second].size()){\n            P to = e[p.second][i];\n            if(dp[to.first] > dp[p.second]+to.second){\n                dp[to.first] = dp[p.second]+to.second;\n                pque.push(P(dp[to.first],to.first));\n            }\n        }\n    }\n    int ans = INF;\n    rep(i,4) ans = min(ans,dp[i*50*50+1*50+1]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> h >> w){\n        if(h == 0 && w == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > P;\ntypedef pair< int , P > PP;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\n\nint d[50][50];\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      d[i][j]=1e8;\n  d[sy][sx]=0;\n  \n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(y==ty&&x==tx)break;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n  \n  return d[ty][tx];\n}\n\nint dd[50][50][4];\nint solve(int sy,int sx,int sd){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<4;k++)\n        dd[i][j][k]=1e8;\n\n  dd[sy][sx][sd]=0;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  Q.push( PP(0, P(sy*50+sx,sd) ) );\n\n  while(!Q.empty()){\n    PP pp = Q.top();Q.pop();\n    int y=pp.second.first/50;\n    int x=pp.second.first%50;\n    int dir=pp.second.second;\n    if(y==0&&x==0)return dd[y][x][dir];\n    \n    for(int i=0;i<4;i++){\n      int ncost=dd[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax,true)+calc(y,x,by,bx,By,Bx,true) ,\n                  calc(y,x,ay,ax,By,Bx,true)+calc(y,x,by,bx,Ay,Ax,true) );\n\n      ncost++;\n      if(dd[ny][nx][i]>ncost){\n        dd[ny][nx][i]=ncost;\n        Q.push(PP(ncost,P(ny*50+nx,i)));\n        \n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sx,sy,py0,px0,ay,ax) + calc(sx,sy,py1,px1,by,bx)\n                    , calc(sx,sy,py0,px0,by,bx) + calc(sx,sy,py1,px1,ay,ax) );\n\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { -1,0,2,1 };\nconst int dy2[4] = { 0,2,1,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint getdis(const vector<vector<int>>&field, const int fx, const int fy,const int gx,const int gy) {\n\tint ans = 999999;\n\tqueue<aa>que;\n\tvector<vector<int>>memo(field.size(), vector<int>(field[0].size(),999999));\n\tque.push(aa{ fx,fy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tconst int nextx = atop.x + dx[i];\n\t\t\tconst int nexty = atop.y + dy[i];\n\t\t\tif (!field[nexty][nextx]) {\n\t\t\t\tif (atop.turn + 1 < memo[nexty][nextx]) {\n\t\t\t\t\tmemo[nexty][nextx] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ nextx,nexty,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\t\n}\nstruct bb {\n\tint kx;\n\tint ky;\n\tint opway;\n\tint turn;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bb&l, const bb&r) {\n\t\treturn l.turn> r.turn;\n\t}\n};\nint memo2[60][60][4];\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 60; ++i) {\n\t\t\tfor (int j = 0; j < 60; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo2[i][j][k] = 999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, true));\n\t\tpriority_queue<bb, vector<bb>, Compare>que;\n\t\t{\n\t\t\tint kx = 99, ky = 99;\n\t\t\tint ox[2];\n\t\t\tint oy[2];\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (st[j] == 'X') {\n\t\t\t\t\t\tkx = min(kx, j + 1);\n\t\t\t\t\t\tky = min(ky, i + 1);\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == 'o') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == '*') {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t\tox[num] = j + 1;\n\t\t\t\t\t\toy[num] = i + 1;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kx == 1 && ky == 1) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\n\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tconst int fx = ox[op^lu];\n\t\t\t\t\t\tconst int fy = oy[op^lu];\n\t\t\t\t\t\tint gx = kx + dx2[way];\n\t\t\t\t\t\tint gy = ky + dy2[way];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(way + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(way + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tmemo2[kx][ky][way] = amin;\n\t\t\t\t\tque.push(bb{ kx,ky,way,amin });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tbb atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int fkx = atop.kx;\n\t\t\tconst int fky = atop.ky;\n\t\t\tconst int fway = atop.opway;\n\t\t\tconst int fturn = atop.turn;\n\t\t\tif (fkx == 1 && fky == 1) {\n\t\t\t\tans = fturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int tway = 0; tway < 4; ++tway) {\n\t\t\t\tif (fway == tway)continue;\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tint fx = fkx + dx2[fway];\n\t\t\t\t\t\tint fy = fky + dy2[fway];\n\t\t\t\t\t\tint gx = fkx + dx2[tway];\n\t\t\t\t\t\tint gy = fky + dy2[tway];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(tway + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(tway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op^lu) {\n\t\t\t\t\t\t\tfx += dx[(fway + 1) % 4];\n\t\t\t\t\t\t\tfy += dy[(fway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (memo2[fkx][fky][tway]>fturn + amin) {\n\t\t\t\t\t\tmemo2[fkx][fky][tway] = fturn + amin;\n\t\t\t\t\t\tque.push(bb{ fkx,fky,tway,fturn + amin });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nkx = fkx + dx[fway];\n\t\t\t\tconst int nky = fky + dy[fway];\n\t\t\t\tconst int nway = (fway + 2) % 4;\n\t\t\t\tif (memo2[nkx][nky][nway] > fturn + 1) {\n\t\t\t\t\tmemo2[nkx][nky][nway] = fturn + 1;\n\t\t\t\t\tque.push(bb{ nkx,nky,nway,fturn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\n\nint d[50][50];\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  \n  \n  int cc=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      d[i][j]=1e8;\n      if( abs(sy-i)<=3 && abs(sx-j)<=3 &&t[i][j]!='*') cc++;\n    }\n  }\n  \n  d[sy][sx]=0;\n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n\n    if(y==ty&&x==tx)break;\n    if( abs(y-sy)<=3 && abs(x-sx)<=3 ) cc--;\n\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n  \n  return d[ty][tx];\n}\n\nint dd[50][50][4];\nint solve(int sy,int sx,int sd,int d[50][50][4]=dd){\n\n  fill( (int*)d[0] , (int*)d[50], 1e8);\n  d[sy][sx][sd]=0;\n  queue<int> qy,qx,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qd.push(sd);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int dir=qd.front();qd.pop();\n    if(y==0&&x==0)return d[y][x][dir];\n    for(int i=0;i<4;i++){\n      int ncost=d[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax,true)+calc(y,x,by,bx,By,Bx,true) ,\n                  calc(y,x,ay,ax,By,Bx,true)+calc(y,x,by,bx,Ay,Ax,true) );\n      ncost++;\n      if(d[ny][nx][i]>ncost){\n        d[ny][nx][i]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qd.push(i);\n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sx,sy,py0,px0,ay,ax) + calc(sx,sy,py1,px1,by,bx)\n                    , calc(sx,sy,py0,px0,by,bx) + calc(sx,sy,py1,px1,ay,ax) );\n\n      //      cout<<i<<' '<<cost<<endl;\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nbool in(int h,int w,int i,int j){return 0<=i && i<h && 0<=j && j<w;}\nbool in(int h,int w,pii p){return in(h,w,p.first,p.second);}\n\nint calc(vs grid,pii king,pii a,pii b)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\tvvi dist(h,vi(w,INF));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(a.first,a.second,0);\n\twhile(q.size()){\n\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\tif(!in(h,w,i,j) || grid[i][j]=='*' || dist[i][j]!=INF) continue;\n\t\tdist[i][j]=d;\n\t\tif(mp(i,j)==b) return d;\n\t\trep(k,4)\n\t\t\tq.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t}\n\treturn dist[b.first][b.second];\n}\n\nint calc(vs grid,pii king,pii p1,pii p2,pii q1,pii q2)\n{\n\treturn min(calc(grid,king,p1,q1)+calc(grid,king,p2,q2),\n\t\t\t\t\t\t calc(grid,king,p1,q2)+calc(grid,king,p2,q1));\n\t//int h=grid.size(),w=grid[0].size();\n\t//rep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\t//vvvvi dist(h,vvvi(w,vvi(h,vi(w,INF))));\n\t//queue<tuple<int,int,int,int,int>> q;\n\t//q.emplace(p1.first,p1.second,p2.first,p2.second,0);\n\t//while(q.size()){\n\t//\tint i1,j1,i2,j2,d; tie(i1,j1,i2,j2,d)=q.front(); q.pop();\n\t//\tif(!in(h,w,i1,j1) || !in(h,w,i2,j2) || grid[i1][j1]=='*' || grid[i2][j2]=='*'\n\t//\t|| (i1==i2 && j1==j2) || dist[i1][j1][i2][j2]!=INF) continue;\n\t//\tdist[i1][j1][i2][j2]=dist[i2][j2][i1][j1]=d;\n\t//\trep(k,4){\n\t//\t\tq.emplace(i1+\"\\xff\\x1\\0\\0\"[k],j1+\"\\0\\0\\xff\\x1\"[k],i2,j2,d+1);\n\t//\t\tq.emplace(i1,j1,i2+\"\\xff\\x1\\0\\0\"[k],j2+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t//\t}\n\t//}\n\t//return dist[q1.first][q1.second][q2.first][q2.second];\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t//dump(mp(h,w));\n\t\t//rep(i,h) cout<<grid[i]<<endl;\n\t\t\n\t\tif(grid[0][0]=='X'){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);});\n\t\t{\n\t\t\tpii king(-1,-1),open1(-1,-1),open2(-1,-1);\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X'){\n\t\t\t\t\tif(king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='.')\n\t\t\t\t\t(open1==mp(-1,-1)?open1:open2)=mp(i,j);\n\t\t\t\telse if(grid[i][j]=='o')\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\tint ki=king.first,kj=king.second;\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,calc(grid,king,open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,calc(grid,king,open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,calc(grid,king,open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,calc(grid,king,open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\t\n\t\tvvvi dist(h,vvi(w,vi(4,INF)));\n\t\twhile(pq.size()){\n\t\t\t//if(rand()%1000==0) printf(\"> %d\\n\",pq.size());\n\t\t\tint ki,kj,dir,step; tie(ki,kj,dir,step)=pq.top(); pq.pop();\n\t\t\tif(!in(h,w,ki,kj) || dist[ki][kj][dir]!=INF) continue;\n\t\t\tdist[ki][kj][dir]=step;\n\t\t\tif(step>=INF) break;\n\t\t\t\n\t\t\tpii open1,open2;\n\t\t\tif(dir==0) open1=mp(ki-1,kj),open2=mp(ki-1,kj+1);\n\t\t\tif(dir==1) open1=mp(ki+2,kj),open2=mp(ki+2,kj+1);\n\t\t\tif(dir==2) open1=mp(ki,kj-1),open2=mp(ki+1,kj-1);\n\t\t\tif(dir==3) open1=mp(ki,kj+2),open2=mp(ki+1,kj+2);\n\t\t\t\n\t\t\tpq.emplace(ki+\"\\xff\\x1\\0\\0\"[dir],kj+\"\\0\\0\\xff\\x1\"[dir],dir^1,step+1);\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,step+calc(grid,mp(ki,kj),open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,step+calc(grid,mp(ki,kj),open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\tint res=*min_element(all(dist[0][0]));\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 50\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint h,w;\nchar mp[N][N];\nint G[N][N][4][4];\n\nbool in(int y,int x){return 0<=y && 0<=x && y < h && x < w && mp[y][x]!='*';}\nvoid king(int y,int x,char ch){\n  mp[y][x] = ch;\n  mp[y][x+1] = ch;\n  mp[y+1][x] = ch;\n  mp[y+1][x+1] = ch;\n}\n\nint bfs(int sy,int sx,int gy,int gx){\n  if(mp[sy][sx] == '*') return INF;\n  vector<vector<int> >D(h,vector<int>(w,-1));\n  queue<P> Q({P(sy,sx)});\n  D[sy][sx] = 0;\n\n  int dx[] ={0,0,1,-1};\n  int dy[] ={1,-1,0,0};\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    if(y == gy && x == gx) return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(!in(ny,nx) || D[ny][nx] != -1) continue;\n      Q.push(P(ny,nx));\n      D[ny][nx] = D[y][x] + 1;\n    }\n  }\n  return INF;\n}\n\nvoid buildG(int y,int x){\n  if(G[y][x][0][0]!=-1) return;\n  king(y,x,'*');\n\n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n\n  for(int i=0;i<4;i++)\n    for(int k=0;k<4;k++){\n      int d[2][2];\n      for(int j=0;j<2;j++)\n        for(int l=0;l<2;l++){\n          d[j][l] = INF;\n          int sx = x + dxi[i] + j * ((i+1)%2);\n          int sy = y + dyi[i] + j * (i%2);\n          int gx = x + dxi[k] + l * ((k+1)%2);\n          int gy = y + dyi[k] + l * (k%2);\n          if(!in(sy,sx) || !in(gy,gx)) continue;\n          d[j][l] = bfs(sy,sx,gy,gx);\n        }\n      G[y][x][i][k] = INF;\n      for(int j=0;j<2;j++) \n        for(int l=0;l<2;l++) Min(G[y][x][i][k],d[j][l] + d[!j][!l]);\n    }\n\n  king(y,x,'.');\n}\n\nvoid initQD(priority_queue<PP,vector<PP>, greater<PP> >&Q,int D[4][N][N]){\n  int x=-1,y=-1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j] == 'X' && x == -1) y = i, x = j;\n\n  if(y == 0 && x == 0){\n    D[0][0][0] = 0;\n    Q.push(PP(P(0,0),P(0,0)));\n    return;\n  }\n\n  king(y,x,'*');\n  vector<int> dotx,doty;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == '.') dotx.push_back(j),doty.push_back(i);\n    \n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n  for(int i=0;i<4;i++){\n    int sx0 = x + dxi[i] + 0;\n    int sy0 = y + dyi[i] + 0;\n    int sx1 = x + dxi[i] + (i+1)%2;\n    int sy1 = y + dyi[i] + i%2;\n    if(!in(sy0,sx0) || !in(sy1,sx1))continue;\n    int a = bfs(sy0,sx0,doty[0],dotx[0]) + bfs(sy1,sx1,doty[1],dotx[1]);\n    int b = bfs(sy0,sx0,doty[1],dotx[1]) + bfs(sy1,sx1,doty[0],dotx[0]);\n    int cost = min(a,b);\n    Q.push(PP(P(cost,i),P(y,x)));\n    D[i][y][x] = cost;\n  }\n  \n  king(y,x,'.');\n}\n\nint dijkstra(){\n  int D[4][N][N];\n  for(int i=0;i<4;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++) D[i][j][k] = INF;\n  priority_queue<PP,vector<PP>, greater<PP> > Q;\n  initQD(Q,D);\n\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int dir = t.first.second;\n    int y = t.second.first;\n    int x = t.second.second;\n    if(y == 0 && x == 0) return cost;\n    if(D[dir][y][x] < cost) continue;\n\n    buildG(y,x);\n    int dx[] = {0,1,0,-1};\n    int dy[] = {-1,0,1,0};\n    for(int i=0;i<4;i++){\n      int ndir = (dir + i)%4;\n      int nx = x + dx[(ndir+2)%4];\n      int ny = y + dy[(ndir+2)%4];\n      if(!in(ny,nx)) continue;\n      int ncost = cost + G[y][x][dir][(ndir+2)%4] + 1;\n      if(D[ndir][ny][nx]<=ncost) continue;\n      Q.push(PP(P(ncost,ndir),P(ny,nx)));\n      D[ndir][ny][nx] = ncost;\n    }    \n  }\n  return -1;\n}\n\n\nsigned main(){\n  while(1){\n    cin>>h>>w;\n    if(!h && !w) break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    memset(G,-1,sizeof(G));\n    cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nbool in(int h,int w,int i,int j){return 0<=i && i<h && 0<=j && j<w;}\n\nint calc(vs grid,pii king,pii a,pii b)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\tvvi dist(h,vi(w,INF));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(a.first,a.second,0);\n\twhile(q.size()){\n\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\tif(!in(h,w,i,j) || grid[i][j]=='*' || dist[i][j]!=INF) continue;\n\t\tdist[i][j]=d;\n\t\tif(mp(i,j)==b) return d;\n\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t}\n\treturn dist[b.first][b.second];\n}\n\nint calc(vs grid,pii king,pii p1,pii p2,pii q1,pii q2)\n{\n\treturn min(calc(grid,king,p1,q1)+calc(grid,king,p2,q2),\n\t\t\t\t\t\t calc(grid,king,p1,q2)+calc(grid,king,p2,q1));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tif(grid[0][0]=='X'){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);});\n\t\t{\n\t\t\tpii king(-1,-1),open1(-1,-1),open2(-1,-1);\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X'){\n\t\t\t\t\tif(king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='.')\n\t\t\t\t\t(open1==mp(-1,-1)?open1:open2)=mp(i,j);\n\t\t\t\telse if(grid[i][j]=='o')\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\tint ki=king.first,kj=king.second;\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,calc(grid,king,open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,calc(grid,king,open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,calc(grid,king,open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,calc(grid,king,open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\t\n\t\tvvvi dist(h,vvi(w,vi(4,INF)));\n\t\tint res=-1;\n\t\twhile(pq.size()){\n\t\t\tint ki,kj,dir,step; tie(ki,kj,dir,step)=pq.top(); pq.pop();\n\t\t\tif(step>=INF) break;\n\t\t\tif(!in(h,w,ki,kj) || dist[ki][kj][dir]!=INF) continue;\n\t\t\tdist[ki][kj][dir]=step;\n\t\t\tif(ki==0 && kj==0){\n\t\t\t\tres=step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tpii open1,open2;\n\t\t\tif(dir==0) open1=mp(ki-1,kj),open2=mp(ki-1,kj+1);\n\t\t\tif(dir==1) open1=mp(ki+2,kj),open2=mp(ki+2,kj+1);\n\t\t\tif(dir==2) open1=mp(ki,kj-1),open2=mp(ki+1,kj-1);\n\t\t\tif(dir==3) open1=mp(ki,kj+2),open2=mp(ki+1,kj+2);\n\t\t\t\n\t\t\tpq.emplace(ki+\"\\xff\\x1\\0\\0\"[dir],kj+\"\\0\\0\\xff\\x1\"[dir],dir^1,step+1);\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,step+calc(grid,mp(ki,kj),open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,step+calc(grid,mp(ki,kj),open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1 << 28;\nint posxK[4] = { 0, 0, 1, 1 }, posyK[4] = { 0, 1, 0, 1 };\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint dxS[4][2] = {\n\t{ 2, 2 },\n\t{ 0, 1 },\n\t{ -1, -1 },\n\t{ 0, 1 }\n};\nint dyS[4][2] = {\n\t{ 0, 1 },\n\t{ 2, 2 },\n\t{ 0, 1 },\n\t{ -1, -1 }\n};\n\nint H, W;\nstring b[50];\nint NG[50][50];\n\nstruct P{\n\tint x, y;\n};\n\nbool In(int x, int y){\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool InKing(int x, int y){\n\tfor(int i = 0; i < 4; i++){\n\t\tif(!In(x + posxK[i], y + posyK[i])) return false;\n\t}\n\treturn true;\n}\n\nbool CheckNG(int x, int y){\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + posxK[i], ny = y + posyK[i];\n\t\tif(In(nx, ny) && b[ny][nx] == '*') return false;\n\t}\n\treturn true;\n}\n\nvoid setNG(int kx, int ky){\n\tfor(int i = 0; i < 4; i++){\n\t\tNG[ky + posyK[i]][kx + posxK[i]] = 1;\n\t}\n}\n\nvoid resetNG(int kx, int ky){\n\tfor(int i = 0; i < 4; i++){\n\t\tNG[ky + posyK[i]][kx + posxK[i]] = 0;\n\t}\n}\n\n\nvoid bfs(int x, int y, int table[50][50]){\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\ttable[y][x] = 0;\n\tqueue<P> q;\n\tq.push({ x, y });\n\twhile(q.size()){\n\t\tx = q.front().x, y = q.front().y;\n\t\tint d = table[y][x];\n\t\tq.pop();\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(!In(nx, ny) || NG[ny][nx]) continue;\n\t\t\tif(table[ny][nx] > d + 1){\n\t\t\t\ttable[ny][nx] = d + 1;\n\t\t\t\tq.push({ nx, ny });\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct State{\n\tP kingpos;\n\tint dir, cost;\n\tbool operator < (const State& x) const{\n\t\treturn cost > x.cost;\n\t}\n};\n\nint sx = -1, sy = -1;\nvector<P> sp;\nvoid debug(State s){\n\tstatic string b2[50];\n\tfor(int i = 0; i < H; i++){\n\t\tb2[i] = b[i];\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tint x = s.kingpos.x + posxK[i], y = s.kingpos.y + posyK[i];\n\t\tb2[y][x] = 'X';\n\t}\n\tif(s.dir == 4){\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tb2[sp[i].y][sp[i].x] = '.';\n\t\t}\n\t}\n\telse{\n\t\tint pd = (s.dir + 2) % 4;\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tb2[s.kingpos.y + dyS[pd][i]][s.kingpos.x + dxS[pd][i]] = '.';\n\t\t}\n\t}\n\tfor(int i = 0; i < H; i++){\n\t\tcout << b2[i] << endl;\n\t}\n\tcout << endl;\n}\n\nint bfsdist[2][50][50];\nint dist[50][50][5];\n\nint dijkstra(int kx, int ky, int sx1, int sy1, int sx2, int sy2){\n\tif(kx == 0 && ky == 0) return 0;\n\tint ans = INF;\n\tfill((int*)begin(dist), (int*)end(dist), INF);\n\tdist[ky][kx][4] = 0;\n\tpriority_queue<State> q;\n\tq.push({ {kx, ky}, 4, 0 });\n\twhile(q.size()){\n\t\tState s = q.top();\n\t\t//cout << \"pop\" << endl;\n\t\t//debug(s);\n\t\tP kp = s.kingpos;\n\t\tint c = s.cost;\n\t\tq.pop();\n\t\tif(dist[kp.y][kp.x][s.dir] < c) continue;\n\t\tP sp[2];\n\t\tif(s.dir == 4){\n\t\t\tsp[0] = { sx1, sy1 };\n\t\t\tsp[1] = { sx2, sy2 };\n\t\t}\n\t\telse{\n\t\t\tint pd = (s.dir + 2) % 4;\n\t\t\tsp[0] = { kp.x + dxS[pd][0], kp.y + dyS[pd][0] };\n\t\t\tsp[1] = { kp.x + dxS[pd][1], kp.y + dyS[pd][1] };\n\t\t}\n\t\tsetNG(kp.x, kp.y);\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tbfs(sp[i].x, sp[i].y, bfsdist[i]);\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nkx = kp.x + dx[i], nky = kp.y + dy[i];\n\t\t\tif(!InKing(nkx, nky)) continue;\n\t\t\tif(!CheckNG(nkx, nky)) continue;\n\t\t\tint nsx1 = kp.x + dxS[i][0], nsy1 = kp.y + dyS[i][0];\n\t\t\tint nsx2 = kp.x + dxS[i][1], nsy2 = kp.y + dyS[i][1];\n\t\t\tint bfsCost = bfsdist[0][nsy1][nsx1] + bfsdist[1][nsy2][nsx2];\n\t\t\tbfsCost = min(bfsCost, bfsdist[1][nsy1][nsx1] + bfsdist[0][nsy2][nsx2]);\n\t\t\tif(bfsCost >= INF) continue;\n\t\t\tif(dist[nky][nkx][i] > c + bfsCost + 1){\n\t\t\t\tdist[nky][nkx][i] = c + bfsCost + 1;\n\t\t\t\tState ns = { { nkx, nky }, i, c + bfsCost + 1 };\n\t\t\t\t//debug(ns);\n\t\t\t\tq.push(ns);\n\t\t\t\tif(nkx == 0 && nky == 0) ans = min(ans, c + bfsCost + 1);\n\t\t\t}\n\t\t}\n\t\tresetNG(kp.x, kp.y);\n\t}\n\tif(ans == INF) ans = -1;\n\treturn ans;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\twhile(cin >> H >> W, H){\n\t\tsp.clear();\n\t\tsx = -1, sy = -1;\n\t\tmemset(NG, 0, sizeof NG);\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> b[i];\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(b[i][j] == 'X'){\n\t\t\t\t\tif(sx == -1) sx = j, sy = i;\n\t\t\t\t\tb[i][j] = 'o';\n\t\t\t\t}\n\t\t\t\tif(b[i][j] == '.'){\n\t\t\t\t\tsp.push_back({ j, i });\n\t\t\t\t\tb[i][j] = 'o';\n\t\t\t\t}\n\t\t\t\tif(b[i][j] == '*'){\n\t\t\t\t\tNG[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = dijkstra(sx, sy, sp[0].x, sp[0].y, sp[1].x, sp[1].y);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,m,INF=1<<29,dxx[4]={-1,0,1,0},dyy[4]={0,-1,0,1};\nint dx[8]={-1,-1,0,1,2,2,0,1},dy[8]={0,1,-1,-1,0,1,2,2};\nstring s[55];\nbool check(int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\nbool check(int x,int y,int xx,int yy) {\n  if(x>=0&&x<n&&y>=0&&y<m) {\n    if(s[x][y]=='*') return 0;\n    if(x==xx&&(y==yy||y==yy+1)) return 0;\n    if(x==xx+1&&(y==yy||y==yy+1)) return 0;\n    return 1;\n  }\n  return 0;\n}\n \nint calc(int sx,int sy,int tx,int ty,int xx,int yy) {\n  if(!check(sx,sy,xx,yy)||!check(tx,ty,xx,yy)) return INF;\n  int d[n][m];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++) d[i][j]=INF;\n  d[sx][sy]=0;\n  queue<P> que;\n  que.push(P(sx,sy));\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    if(p.F==tx&&p.S==ty) return d[tx][ty];\n    for(int i=0; i<4; i++) {\n      int x=p.F+dxx[i],y=p.S+dyy[i];\n      if(!check(x,y,xx,yy)||d[x][y]<=d[p.F][p.S]+1) continue;\n      d[x][y]=d[p.F][p.S]+1;\n      que.push(P(x,y));\n    }\n  }\n  return d[tx][ty];\n}\n \nint main() {\n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<4;k++)d[i][j][k]=INF;\n    vector<P> v;\n    P p=P(-1,-1);\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++) {\n        if(s[i][j]=='.')v.push_back(P(i,j));\n        if(s[i][j]=='X'&&p.F==-1) p=P(i,j);\n      }\n    if(p==P(0,0)) {\n      cout << 0 << endl;\n      continue;\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    for(int i=0; i<4; i++) {\n      int b[2]={0,1};\n      do {\n        int cost=calc(v[0].F,v[0].S,p.F+dx[i*2+b[0]],p.S+dy[i*2+b[0]],p.F,p.S);\n        cost+=calc(v[1].F,v[1].S,p.F+dx[i*2+b[1]],p.S+dy[i*2+b[1]],p.F,p.S);\n        d[p.F][p.S][i]=min(d[p.F][p.S][i],cost);\n      } while(next_permutation(b,b+2));\n      que.push(PP(P(0,i),p));\n    }\n    while(!que.empty()) {\n      PP pp=que.top();que.pop();\n      int x=pp.S.F,y=pp.S.S,k=pp.F.S,c=pp.F.F;\n      if(x==0&&y==0) {\n        cout << d[0][0][k] << endl;\n        goto end;\n      }\n      if(d[x][y][k]<c) continue;\n      for(int i=0; i<4; i++) {\n        int xx=x+dxx[i],yy=y+dyy[i]; \n        int cost=INF;\n        int b[2]={0,1};\n        do {\n          int sum=calc(x+dx[k*2],y+dy[k*2],x+dx[i*2+b[0]],y+dy[i*2+b[0]],x,y);\n          sum+=calc(x+dx[k*2+1],y+dy[k*2+1],x+dx[i*2+b[1]],y+dy[i*2+b[1]],x,y);\n          cost=min(cost,sum);\n        }while(next_permutation(b,b+2));\n        if(!check(xx,yy)||d[xx][yy][(i+2)%4]<=d[x][y][k]+cost+1) continue;\n        d[xx][yy][(i+2)%4]=d[x][y][k]+cost+1;\n        que.push(PP(P(d[xx][yy][(i+2)%4],(i+2)%4),P(xx,yy)));\n      }\n    }\n    cout << -1 << endl;\n  end:;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { -1,0,2,1 };\nconst int dy2[4] = { 0,2,1,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint getdis(const vector<vector<int>>&field, const int fx, const int fy,const int gx,const int gy) {\n\tint ans = 999999;\n\tqueue<aa>que;\n\tvector<vector<int>>memo(field.size(), vector<int>(field[0].size(),999999));\n\tque.push(aa{ fx,fy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tconst int nextx = atop.x + dx[i];\n\t\t\tconst int nexty = atop.y + dy[i];\n\t\t\tif (!field[nexty][nextx]) {\n\t\t\t\tif (atop.turn + 1 < memo[nexty][nextx]) {\n\t\t\t\t\tmemo[nexty][nextx] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ nextx,nexty,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nstruct bb {\n\tint kx;\n\tint ky;\n\tint opway;\n\tint turn;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bb&l, const bb&r) {\n\t\treturn l.turn> r.turn;\n\t}\n};\nint memo2[52][52][4];\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 52; ++i) {\n\t\t\tfor (int j = 0; j < 52; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo2[i][j][k] = 999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, true));\n\t\tpriority_queue<bb, vector<bb>, Compare>que;\n\t\t{\n\t\t\tint kx = 99, ky = 99;\n\t\t\tint ox[2];\n\t\t\tint oy[2];\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (st[j] == 'X') {\n\t\t\t\t\t\tkx = min(kx, j + 1);\n\t\t\t\t\t\tky = min(ky, i + 1);\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == 'o') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[j]=='.'){\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t\tox[num] = j + 1;\n\t\t\t\t\t\toy[num] = i + 1;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kx == 1 && ky == 1) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tconst int fx = ox[op^lu];\n\t\t\t\t\t\tconst int fy = oy[op^lu];\n\t\t\t\t\t\tint gx = kx + dx2[way];\n\t\t\t\t\t\tint gy = ky + dy2[way];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(way + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(way + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tmemo2[kx][ky][way] = amin;\n\t\t\t\t\tque.push(bb{ kx,ky,way,amin });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tbb atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int fkx = atop.kx;\n\t\t\tconst int fky = atop.ky;\n\t\t\tconst int fway = atop.opway;\n\t\t\tconst int fturn = atop.turn;\n\t\t\tif (fkx == 1 && fky == 1) {\n\t\t\t\tans = fturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int tway = 0; tway < 4; ++tway) {\n\t\t\t\tif (fway == tway)continue;\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tint fx = fkx + dx2[fway];\n\t\t\t\t\t\tint fy = fky + dy2[fway];\n\t\t\t\t\t\tint gx = fkx + dx2[tway];\n\t\t\t\t\t\tint gy = fky + dy2[tway];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(tway + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(tway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op^lu) {\n\t\t\t\t\t\t\tfx += dx[(fway + 1) % 4];\n\t\t\t\t\t\t\tfy += dy[(fway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (memo2[fkx][fky][tway]>fturn + amin) {\n\t\t\t\t\t\tmemo2[fkx][fky][tway] = fturn + amin;\n\t\t\t\t\t\tque.push(bb{ fkx,fky,tway,fturn + amin });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nkx = fkx + dx[fway];\n\t\t\t\tconst int nky = fky + dy[fway];\n\t\t\t\tconst int nway = (fway + 2) % 4;\n\t\t\t\tif (memo2[nkx][nky][nway] > fturn + 1) {\n\t\t\t\t\tmemo2[nkx][nky][nway] = fturn + 1;\n\t\t\t\t\tque.push(bb{ nkx,nky,nway,fturn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nchar str[60][60];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bfs[60][60];\nint ijk[60][60][4];\nint v[60][60][4];\nint dis[2][2];\nint a,b;\nint calc(vector<pair<int,int> >st,vector<pair<int,int> >go,int xr,int xc){\n\tfor(int l=0;l<2;l++){\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[j][k]=99999999;\n\t\tbfs[st[l].first][st[l].second]=0;\n\t\tqueue<pair<int,int> >Q;\n\t\tQ.push(make_pair(st[l].first,st[l].second));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint tr=row+dx[j];int tc=col+dy[j];\n\t\t\t\tif(tr<0||tc<0||tr>=a||tc>=b)continue;\n\t\t\t\tif(str[tr][tc]=='*')continue;\n\t\t\t\tif(tr==xr&&tc==xc)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc)continue;\n\t\t\t\tif(tr==xr&&tc==xc+1)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc+1)continue;\n\t\t\t\tif(bfs[tr][tc]>bfs[row][col]+1){\n\t\t\t\t\tbfs[tr][tc]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(tr,tc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[l][0]=bfs[go[0].first][go[0].second];\n\t\tdis[l][1]=bfs[go[1].first][go[1].second];\n\t}\n\treturn min(dis[0][0]+dis[1][1],dis[0][1]+dis[1][0]);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++){\n\t\t\tijk[i][j][k]=999999999;\n\t\t\tv[i][j][k]=0;\n\t\t}\n\t\tint sr,sc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tsr=i;sc=j;\n\t\t\t}\n\t\t}\n\t\tsr--;sc--;\n\t\tpriority_queue<pair<int,pair<pair<int,int>,int> > >Q;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tvector<pair<int,int> >st;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(str[j][k]=='.'){\n\t\t\t\tst.push_back(make_pair(j,k));\n\t\t\t}\n\t\t\tvector<pair<int,int> >go;\n\t\t\tif(i==0){go.push_back(make_pair(sr,sc+2));go.push_back(make_pair(sr+1,sc+2));}\n\t\t\tif(i==1){go.push_back(make_pair(sr+2,sc));go.push_back(make_pair(sr+2,sc+1));}\n\t\t\tif(i==2){go.push_back(make_pair(sr,sc-1));go.push_back(make_pair(sr+1,sc-1));}\n\t\t\tif(i==3){go.push_back(make_pair(sr-1,sc));go.push_back(make_pair(sr-1,sc+1));}\n\t\t\tint co=calc(st,go,sr,sc);\n\t\t\tif(co<99999999){\n\t\t\t\tijk[sr][sc][i]=co;\n\t\t\t\tQ.push(make_pair(-co,make_pair(make_pair(sr,sc),i)));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint row=Q.top().second.first.first;\n\t\t\tint col=Q.top().second.first.second;\n\t\t\tint dir=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][dir])continue;\n\t\t\tv[row][col][dir]=1;\n\t\t\tvector<pair<int,int> >st;\n\t\t\tif(dir==0){st.push_back(make_pair(row,col+2));st.push_back(make_pair(row+1,col+2));}\n\t\t\tif(dir==1){st.push_back(make_pair(row+2,col));st.push_back(make_pair(row+2,col+1));}\n\t\t\tif(dir==2){st.push_back(make_pair(row,col-1));st.push_back(make_pair(row+1,col-1));}\n\t\t\tif(dir==3){st.push_back(make_pair(row-1,col));st.push_back(make_pair(row-1,col+1));}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tvector<pair<int,int> >go;\n\t\t\t\tif(i==0){go.push_back(make_pair(row,col+2));go.push_back(make_pair(row+1,col+2));}\n\t\t\t\tif(i==1){go.push_back(make_pair(row+2,col));go.push_back(make_pair(row+2,col+1));}\n\t\t\t\tif(i==2){go.push_back(make_pair(row,col-1));go.push_back(make_pair(row+1,col-1));}\n\t\t\t\tif(i==3){go.push_back(make_pair(row-1,col));go.push_back(make_pair(row-1,col+1));}\n\t\t\t\tint co=calc(st,go,row,col);\n\t\t\t\tif(!v[row][col][i]&&ijk[row][col][i]>cost+co){\n\t\t\t\t\tijk[row][col][i]=cost+co;\n\t\t\t\t\tQ.push(make_pair(-cost-co,make_pair(make_pair(row,col),i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!v[row+dx[dir]][col+dy[dir]][dir^2]&&ijk[row+dx[dir]][col+dy[dir]][dir^2]>cost+1){\n\t\t\t\tijk[row+dx[dir]][col+dy[dir]][dir^2]=cost+1;\n\t\t\t\tQ.push(make_pair(-cost-1,make_pair(make_pair(row+dx[dir],col+dy[dir]),dir^2)));\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tret=min(ret,ijk[0][0][i]);\n\t\t}\n\t\tif(ret>9999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\nint n,m;\nchar mp[60][60];\nbool isok(int x,int y)\n{\n    return x>=1&&x<=n&&y>=1&&y<=m&&mp[x][y]!='*';\n}\n\nstruct point\n{\n    int x,y;\n    point (int a,int b){x=a;y=b;}\n    point(){}\n    bool operator ==(const point &s)const\n    {\n        return x==s.x&&y==s.y;\n    }\n};\nstruct node\n{\n    point king;\n    point sp[2];\n    int dis;\n    bool operator <(const node &x)const\n    {\n        return dis>x.dis;\n    }\n}t,f;\nint vis[60][60][4];\nstruct node2\n{\n    int dis;\n    point p;\n};\nbool can(point &p,point &no)\n{\n    point a=point(no.x+dx[3],no.y+dy[3]);\n    point b=point(no.x+dx[1],no.y+dy[1]);\n    point c=point(no.x+dx[1]+dx[3],no.y+dy[1]+dy[3]);\n    if(p==no||p==a||p==b||p==c) return false;\n    return true;\n}\nbool use[60][60];\nint go(point  sp1,point sp2,point ed1,point ed2,node &no)\n{\n\n    if(sp1==ed1&&sp2==ed2) return 0;\n    if(sp1==ed2&&sp1==ed1) return 0;\n    queue<node2> q;\n    node2 t,f;\n    t.p=sp1;\n    t.dis=0;\n    q.push(t);\n    memset(use,0,sizeof(use));\n    use[t.p.x][t.p.y]=true;\n    int sp1dis1=-1,sp1dis2=-1;\n    int sp2dis1=-1,sp2dis2=-1;\n    while(!q.empty())\n    {\n        f=q.front();q.pop();\n        if(f.p.x==ed1.x&&f.p.y==ed1.y) sp1dis1=f.dis;\n        if(f.p.x==ed2.x&&f.p.y==ed2.y) sp1dis2=f.dis;\n        for(int d=0;d<4;d++)\n        {\n            t.p.x=f.p.x+dx[d];\n            t.p.y=f.p.y+dy[d];\n            t.dis=f.dis+1;\n            if(isok(t.p.x,t.p.y)&&can(t.p,no.king)&&use[t.p.x][t.p.y]==0)\n            {\n                use[t.p.x][t.p.y]=true;\n                q.push(t);\n            }\n        }\n    }\n    t.p=sp2;\n    t.dis=0;\n    q.push(t);\n    memset(use,0,sizeof(use));\n    use[t.p.x][t.p.y]=true;\n    while(!q.empty())\n    {\n        f=q.front();q.pop();\n        if(f.p.x==ed1.x&&f.p.y==ed1.y) sp2dis1=f.dis;\n        if(f.p.x==ed2.x&&f.p.y==ed2.y) sp2dis2=f.dis;\n        for(int d=0;d<4;d++)\n        {\n            t.p.x=f.p.x+dx[d];\n            t.p.y=f.p.y+dy[d];\n            t.dis=f.dis+1;\n            if(isok(t.p.x,t.p.y)&&can(t.p,no.king)&&use[t.p.x][t.p.y]==0)\n            {\n                use[t.p.x][t.p.y]=true;\n\n                q.push(t);\n            }\n        }\n    }\n    int ans=0x3f3f3f3f;\n    if(sp1dis1!=-1&&sp2dis2!=-1) ans=min(ans,sp1dis1+sp2dis2);\n    if(sp1dis2!=-1&&sp2dis1!=-1) ans=min(ans,sp1dis2+sp2dis1);\n    if(ans==0x3f3f3f3f) return -1;\n    return ans;\n}\nint bfs()\n{\n    if(t.king.x==1&&t.king.y==1) return 0;\n    memset(vis,0x3f,sizeof(vis));\n    queue<node> q;\n    q.push(t);\n    while(!q.empty())\n    {\n        f=q.front();q.pop();\n        if(f.king.x==1&&f.king.y==1)\n        {\n            return f.dis;\n        }\n        int tmp;\n        t=f;\n        t.king.x+=dx[0];\n        t.king.y+=dy[0];\n        if(isok(t.king.x,t.king.y))\n        {\n\n            point ed2=point(t.king.x+dx[3],t.king.y+dy[3]);\n            tmp=go(t.sp[0],t.sp[1],t.king,ed2,f);\n            if(tmp!=-1&&t.dis+tmp<vis[t.king.x][t.king.y][1])\n                {\n                    vis[t.king.x][t.king.y][1]=t.dis+tmp;\n                    t.dis+=tmp;\n                    t.dis++;\n                    t.sp[0].x=f.king.x+dx[1];\n                    t.sp[0].y=f.king.y+dy[1];\n                    t.sp[1].x=f.king.x+dx[1]+dx[3];\n                    t.sp[1].y=f.king.y+dy[1]+dy[3];\n                    q.push(t);\n                }\n        }\n        t=f;\n        t.king.x+=dx[1];\n        t.king.y+=dy[1];\n        if(isok(t.king.x,t.king.y))\n        {\n            point ed2=point(t.king.x+dx[1]+dx[3],t.king.y+dy[1]+dy[3]);\n            tmp=go(t.sp[0],t.sp[1],point(t.king.x+dx[1],t.king.y+dy[1]),ed2,f);\n            if(tmp!=-1&&t.dis+tmp<vis[t.king.x][t.king.y][0])\n                {\n                    vis[t.king.x][t.king.y][0]=t.dis+tmp;\n                    t.dis+=tmp;\n                    t.dis++;\n                    t.sp[0].x=f.king.x;\n                    t.sp[0].y=f.king.y;\n                    t.sp[1].x=f.king.x+dx[3];\n                    t.sp[1].y=f.king.y+dy[3];\n                    q.push(t);\n                }\n        }\n        t=f;\n        t.king.x+=dx[2];\n        t.king.y+=dy[2];\n        if(isok(t.king.x,t.king.y))\n        {\n            point ed2=point(t.king.x+dx[1],t.king.y+dy[1]);\n            tmp=go(t.sp[0],t.sp[1],t.king,ed2,f);\n            if(tmp!=-1&&t.dis+tmp<vis[t.king.x][t.king.y][3])\n                {\n                    vis[t.king.x][t.king.y][3]=t.dis+tmp;\n                    t.dis+=tmp;\n                    t.dis++;\n                    t.sp[0].x=f.king.x+dx[3];\n                    t.sp[0].y=f.king.y+dy[3];\n                    t.sp[1].x=f.king.x+dx[3]+dx[1];\n                    t.sp[1].y=f.king.y+dy[3]+dy[1];\n                    q.push(t);\n                }\n        }\n        t=f;\n        t.king.x+=dx[3];\n        t.king.y+=dy[3];\n        if(isok(t.king.x,t.king.y))\n        {\n            point ed2=point(t.king.x+dx[3]+dx[1],t.king.y+dy[3]+dy[1]);\n            tmp=go(t.sp[0],t.sp[1],point(t.king.x+dx[3],t.king.y+dy[3]),ed2,f);\n            if(tmp!=-1&&t.dis+tmp<vis[t.king.x][t.king.y][2])\n                {\n                    vis[t.king.x][t.king.y][2]=t.dis+tmp;\n                    t.dis+=tmp;\n                    t.dis++;\n                    t.sp[0].x=f.king.x;\n                    t.sp[0].y=f.king.y;\n                    t.sp[1].x=f.king.x+dx[1];\n                    t.sp[1].y=f.king.y+dy[1];\n                    q.push(t);\n                }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(!n&&!m) break;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%s\",mp[i]+1);\n        }\n        int f=0;\n        int z=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                if(f==0&&mp[i][j]=='X')\n                {\n                    t.king.x=i;\n                    t.king.y=j;\n                    f=1;\n                }\n                if(mp[i][j]=='.')\n                {\n                    t.sp[z].x=i;\n                    t.sp[z].y=j;\n                    z++;\n                }\n            }\n        }\n\n        t.dis=0;\n        printf(\"%d\\n\",bfs());\n    }\n    return 0;\n}\n/*\n3 3\noo.\noXX\n.XX\n3 3\nXXo\nXX.\no.o\n3 5\n.o*XX\noooXX\noooo.\n7 12\noooooooooooo\nooooo*****oo\noooooo****oo\no**ooo***ooo\no***ooooo..o\no**ooooooXXo\nooooo****XXo\n5 30\noooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooo\no***************************oo\nXX.ooooooooooooooooooooooooooo\nXX.ooooooooooooooooooooooooooo\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tqueue<tuple<pii,pii,pii,int>> q;\n\t\tset<tuple<pii,pii,pii>> vis;\n\t\t{\n\t\t\tpii king(-1,-1);\n\t\t\tvector<pii> opens;\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X' && king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\tif(grid[i][j]=='.') opens.emplace_back(i,j);\n\t\t\t}\n\t\t\tq.emplace(king,opens[0],opens[1],0);\n\t\t\tvis.insert(make_tuple(king,opens[0],opens[1]));\n\t\t}\n\t\t\n\t\tint res=-1;\n\t\twhile(q.size()){\n\t\t\tpii ck,co1,co2; int step;\n\t\t\ttie(ck,co1,co2,step)=q.front(); q.pop();\n\t\t\tif(ck==mp(0,0)){\n\t\t\t\tres=step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni,nj;\n\t\t\t\tni=co1.first+\"\\xff\\x1\\0\\0\"[k],nj=co1.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co2\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=mp(ni,nj),no2=co2; if(no1>no2) swap(no1,no2);\n\t\t\t\t\tif(vis.insert(make_tuple(ck,no1,no2)).second)\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tni=co2.first+\"\\xff\\x1\\0\\0\"[k],nj=co2.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co1\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=co1,no2=mp(ni,nj); if(no1>no2) swap(no1,no2);\n\t\t\t\t\tif(vis.insert(make_tuple(ck,no1,no2)).second)\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.first==co2.first && co1.second+1==co2.second){\n\t\t\t\tif(ck.first==co1.first+1 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first-1,ck.second),no1(co1.first+2,co1.second),no2(co2.first+2,co2.second);\n\t\t\t\t\tif(vis.insert(make_tuple(nk,no1,no2)).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.first==co1.first-2 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first+1,ck.second),no1(co1.first-2,co1.second),no2(co2.first-2,co2.second);\n\t\t\t\t\tif(vis.insert(make_tuple(nk,no1,no2)).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.second==co2.second && co1.first+1==co2.first){\n\t\t\t\tif(ck.second==co1.second+1 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second-1),no1(co1.first,co1.second+2),no2(co2.first,co2.second+2);\n\t\t\t\t\tif(vis.insert(make_tuple(nk,no1,no2)).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.second==co1.second-2 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second+1),no1(co1.first,co1.second-2),no2(co2.first,co2.second-2);\n\t\t\t\t\tif(vis.insert(make_tuple(nk,no1,no2)).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 50\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint h,w;\nchar mp[N][N];\nint G[N][N][4][4];\n\nbool in(int y,int x){return 0<=y && 0<=x && y < h && x < w && mp[y][x]!='*';}\nvoid king(int y,int x,char ch){\n  mp[y][x] = ch;\n  mp[y][x+1] = ch;\n  mp[y+1][x] = ch;\n  mp[y+1][x+1] = ch;\n}\n\nint bfs(int sy,int sx,int gy,int gx){\n  if(mp[sy][sx] == '*') return INF;\n  vector<vector<int> >D(h,vector<int>(w,-1));\n  queue<P> Q({P(sy,sx)});\n  D[sy][sx] = 0;\n\n  int dx[] ={0,0,1,-1};\n  int dy[] ={1,-1,0,0};\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    if(y == gy && x == gx) return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(!in(ny,nx) || D[ny][nx] != -1) continue;\n      Q.push(P(ny,nx));\n      D[ny][nx] = D[y][x] + 1;\n    }\n  }\n  return INF;\n}\n\nvoid buildG(int y,int x){\n  if(G[y][x][0][0]!=-1) return;\n  king(y,x,'*');\n\n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n\n  for(int i=0;i<4;i++)\n    for(int k=0;k<4;k++){\n      int d[2][2];\n      for(int j=0;j<2;j++)\n        for(int l=0;l<2;l++){\n          d[j][l] = INF;\n          int sx = x + dxi[i] + j * ((i+1)%2);\n          int sy = y + dyi[i] + j * (i%2);\n          int gx = x + dxi[k] + l * ((k+1)%2);\n          int gy = y + dyi[k] + l * (k%2);\n          if(!in(sy,sx) || !in(gy,gx)) continue;\n          d[j][l] = bfs(sy,sx,gy,gx);\n        }\n      G[y][x][i][k] = INF;\n      for(int j=0;j<2;j++) \n        for(int l=0;l<2;l++) Min(G[y][x][i][k],d[j][l] + d[!j][!l]);\n    }\n\n  king(y,x,'.');\n}\n\nvoid initQD(priority_queue<PP,vector<PP>, greater<PP> >&Q,int D[4][N][N]){\n  int x=-1,y=-1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j] == 'X' && x == -1) y = i, x = j;\n\n  if(y == 0 && x == 0){\n    D[0][0][0] = 0;\n    Q.push(PP(P(0,0),P(0,0)));\n    return;\n  }\n\n  king(y,x,'*');\n  vector<int> dotx,doty;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == '.') dotx.push_back(j),doty.push_back(i);\n    \n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n  for(int i=0;i<4;i++){\n    int sx0 = x + dxi[i] + 0;\n    int sy0 = y + dyi[i] + 0;\n    int sx1 = x + dxi[i] + (i+1)%2;\n    int sy1 = y + dyi[i] + i%2;\n    if(!in(sy0,sx0) || !in(sy1,sx1))continue;\n    int a = bfs(sy0,sx0,doty[0],dotx[0]) + bfs(sy1,sx1,doty[1],dotx[1]);\n    int b = bfs(sy0,sx0,doty[1],dotx[1]) + bfs(sy1,sx1,doty[0],dotx[0]);\n    int cost = min(a,b);\n    Q.push(PP(P(cost,i),P(y,x)));\n    D[i][y][x] = cost;\n  }\n  \n  king(y,x,'.');\n}\n\nint dijkstra(){\n  int D[4][N][N];\n  for(int i=0;i<4;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++) D[i][j][k] = INF;\n  priority_queue<PP,vector<PP>, greater<PP> > Q;\n  initQD(Q,D);\n\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int dir = t.first.second;\n    int y = t.second.first;\n    int x = t.second.second;\n    if(y == 0 && x == 0) return cost;\n    if(D[dir][y][x] < cost) continue;\n\n    buildG(y,x);\n    int dx[] = {0,1,0,-1};\n    int dy[] = {-1,0,1,0};\n    for(int i=0;i<4;i++){\n      int ndir = (dir + i)%4;\n      int nx = x + dx[(ndir+2)%4];\n      int ny = y + dy[(ndir+2)%4];\n      if(!in(ny,nx)) continue;\n      int ncost = cost + G[y][x][dir][(ndir+2)%4] + 1;\n      if(D[ndir][ny][nx]<=ncost) continue;\n      Q.push(PP(P(ncost,ndir),P(ny,nx)));\n      D[ndir][ny][nx] = ncost;\n    }    \n  }\n  return -1;\n}\n\n\nsigned main(){\n  while(1){\n    cin>>h>>w;\n    if(!h && !w) break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    memset(G,-1,sizeof(G));\n    cout<<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n#include <sstream>\n#include <cstring>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid filll_all(T& a, const T& v) { a = v; }\ntemplate<typename A, size_t N, typename T>\nvoid filll_all(A(&a)[N], const T& v) { for (auto& aa : a) { filll_all(aa, v); } }\n\nint H, W;\nstd::string mapmap[60];\nconst int64_t INF = 50505050;\n\n\n\nbool is_in(int h, int w) {\n\tif (h < 0 || H <= h) {\n\t\treturn false;\n\t}\n\tif (w < 0 || W <= w) {\n\t\treturn false;\n\t}\n\tif (mapmap[h][w] == '*') {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint64_t dist1[50][50];\nint64_t dist2[50][50];\nvoid distfunc(int h, int w, int starth, int startw, int64_t(&distarray)[50][50]) {\n\n\tint64_t(&dist)[50][50] = distarray;\n\n\n\tstd::vector<std::pair<int, int>> que;\n\tque.push_back({ starth ,startw });\n\tfilll_all(dist, INF);\n\tdist[starth][startw] = 0;\n\n\tint count = 0;\n\twhile (!que.empty()) {\n\t\t++count;\n\t\tstd::vector<std::pair<int, int>> next;\n\n\n\t\tfor (auto& v : que) {\n\n\t\t\tconst int diffh[4] = { -1,0,1,0 };\n\t\t\tconst int diffw[4] = { 0,1,0,-1 };\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint nexth = v.first + diffh[i];\n\t\t\t\tint nextw = v.second + diffw[i];\n\t\t\t\tif (is_in(nexth, nextw) &&\n\t\t\t\t\t!((h == nexth && w == nextw) || (h + 1 == nexth && w == nextw) || (h == nexth && w + 1 == nextw) || (h + 1 == nexth && w + 1 == nextw))\n\t\t\t\t\t&& count < dist[nexth][nextw]) {\n\t\t\t\t\tdist[nexth][nextw] = count;\n\t\t\t\t\tnext.push_back({ nexth, nextw });\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tque = std::move(next);\n\t}\n\n\n}\nint64_t dp[50][50][4];\nbool visited[50][50][4];\nint64_t func(int h, int w, int now, int v) {\n\n\tpriority_queue<pair<pair<int, int>, pair<int, int> > > pq;\n\n\tpq.push({ {-v, now}, {h, w} });\n\n\tmemset(visited, 0, sizeof(visited));\n\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\n\t\tint v = -p.first.first;\n\t\tint now = p.first.second;\n\t\tint h = p.second.first;\n\t\tint w = p.second.second;\n\n\t\tif (!is_in(h, w)) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (!is_in(h + 1, w)) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (!is_in(h, w + 1)) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (!is_in(h + 1, w + 1)) {\n\t\t\treturn INF;\n\t\t}\n\n\t\tif (visited[h][w][now]) continue;\n\t\tvisited[h][w][now] = true;\n\n\t\tif (h == 0 && w == 0) {\n\t\t\treturn v;\n\t\t}\n\n\t\tconst int diffh0[4] = { -1,0,1,0 };\n\t\tconst int diffw0[4] = { 0,1,0,-1 };\n\n\t\tconst int diffh2[4] = { -1,1,2,1 };\n\t\tconst int diffw2[4] = { 1,2,1,-1 };\n\t\tif (!is_in(h + diffh2[now], w + diffw2[now])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdistfunc(h, w, h + diffh2[now], w + diffw2[now], dist2);\n\n\t\tconst int diffh1[4] = { -1,0,2,0 };\n\t\tconst int diffw1[4] = { 0,2,0,-1 };\n\t\tif (!is_in(h + diffh1[now], w + diffw1[now])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdistfunc(h, w, h + diffh1[now], w + diffw1[now], dist1);\n\n\t\tint dist11[4] = {};\n\t\tint dist12[4] = {};\n\t\tint dist21[4] = {};\n\t\tint dist22[4] = {};\n\t\tfor (int next = 0; next < 4; next++) {\n\t\t\tint nexth1 = h + diffh1[next];\n\t\t\tint nextw1 = w + diffw1[next];\n\t\t\tif (!is_in(nexth1, nextw1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nexth2 = h + diffh2[next];\n\t\t\tint nextw2 = w + diffw2[next];\n\t\t\tif (!is_in(nexth2, nextw2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdist11[next] = dist1[h + diffh1[next]][w + diffw1[next]];\n\t\t\tdist22[next] = dist2[h + diffh2[next]][w + diffw2[next]];\n\t\t\tdist21[next] = dist2[h + diffh1[next]][w + diffw1[next]];\n\t\t\tdist12[next] = dist1[h + diffh2[next]][w + diffw2[next]];\n\t\t}\n\n\t\tfor (int next = 0; next < 4; next++) {\n\t\t\tint nexth1 = h + diffh1[next];\n\t\t\tint nextw1 = w + diffw1[next];\n\t\t\tif (!is_in(nexth1, nextw1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nexth2 = h + diffh2[next];\n\t\t\tint nextw2 = w + diffw2[next];\n\t\t\tif (!is_in(nexth2, nextw2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint nextv = v + std::min(dist11[next] + dist22[next], dist21[next] + dist12[next]) + 1;\n\t\t\tif (nextv < INF) {\n\t\t\t\tpq.push({ {-nextv, next ^ 2}, {h + diffh0[next], w + diffw0[next]} });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INF;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfilll_all(dp, (int64_t)-1);\n\t\tfor (size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> mapmap[i];\n\t\t}\n\n\t\tint defh = -1, defw = -1;\n\t\tfor (size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (mapmap[i][j] == 'X') {\n\t\t\t\t\tdefh = i;\n\t\t\t\t\tdefw = j;\n\t\t\t\t\tgoto ROOPROOPROOP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tROOPROOPROOP:;\n\t\tif (defh == 0 && defw == 0) {\n\t\t\tcout << \"0\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint count = 0;\n\t\tfor (size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (mapmap[i][j] == '.') {\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tdistfunc(defh, defw, i, j, dist1);\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdistfunc(defh, defw, i, j, dist2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tconst int diffh2[4] = { -1,1,2,1 };\n\t\tconst int diffw2[4] = { 1,2,1,-1 };\n\t\tconst int diffh1[4] = { -1,0,2,0 };\n\t\tconst int diffw1[4] = { 0,2,0,-1 };\n\n\t\tauto h = defh;\n\t\tauto w = defw;\n\t\tint64_t res = INF;\n\t\tint dist11[4] = {};\n\t\tint dist12[4] = {};\n\t\tint dist21[4] = {};\n\t\tint dist22[4] = {};\n\t\tfor (int next = 0; next < 4; next++)\n\t\t{\n\t\t\tint nexth1 = h + diffh1[next];\n\t\t\tint nextw1 = w + diffw1[next];\n\t\t\tif (!is_in(nexth1, nextw1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nexth2 = h + diffh2[next];\n\t\t\tint nextw2 = w + diffw2[next];\n\t\t\tif (!is_in(nexth2, nextw2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdist11[next] = dist1[h + diffh1[next]][w + diffw1[next]];\n\t\t\tdist22[next] = dist2[h + diffh2[next]][w + diffw2[next]];\n\t\t\tdist21[next] = dist2[h + diffh1[next]][w + diffw1[next]];\n\t\t\tdist12[next] = dist1[h + diffh2[next]][w + diffw2[next]];\n\t\t}\n\n\t\tfor (int next = 0; next < 4; next++) {\n\t\t\tint nexth1 = h + diffh1[next];\n\t\t\tint nextw1 = w + diffw1[next];\n\t\t\tif (!is_in(nexth1, nextw1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nexth2 = h + diffh2[next];\n\t\t\tint nextw2 = w + diffw2[next];\n\t\t\tif (!is_in(nexth2, nextw2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint v = std::min(dist11[next] + dist22[next], dist21[next] + dist12[next]);\n\n\t\t\tres = min(res, func(h, w, next, v));\n\t\t}\n\n\t\tif (res == INF) {\n\t\t\tcout << \"-1\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << res << '\\n';\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct state {\n\tint x, y, d, dist;\n\tstate(int x_, int y_, int d_, int dist_):x(x_), y(y_), d(d_), dist(dist_) {}\n\tstate(const state &s):x(s.x), y(s.y), d(s.d), dist(s.dist) {}\n\tbool operator>(const state &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\n#define X first\n#define Y second\n\nconstexpr int INF = (1 << 28);\nconstexpr int MAX_SIZE = 50;\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\nconstexpr int ddx[4][2] = {{2, 2}, {-1, -1}, {0, 1}, {0, 1}};\nconstexpr int ddy[4][2] = {{0, 1}, {0, 1}, {2, 2}, {-1, -1}};\n\nint h, w;\nstring field[MAX_SIZE + 2];\nint dist[MAX_SIZE + 2][MAX_SIZE + 2][4];\n\ninline void overwrite(int x, int y, char c) {\n\tfield[y][x] = field[y][x+1] = field[y+1][x] = field[y+1][x+1] = c;\n}\n\nvector<vector<int>> bfs(const pair<int, int> &start) {\n\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\tqueue<pair<int, int>> que;\n\tque.push(start);\n\tcost[start.Y][start.X] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().X;\n\t\tconst int y = que.front().Y;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(field[ny][nx] == '*') continue;\n\t\t\tif(cost[ny][nx] > cost[y][x] + 1) {\n\t\t\t\tque.push({nx, ny});\n\t\t\t\tcost[ny][nx] = cost[y][x] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\nint dijkstra(const vector<state> &start) {\n\tfill(dist[0][0], dist[0][0] + (MAX_SIZE + 2) * (MAX_SIZE + 2) * 4, INF);\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfor(const auto &s : start) {\n\t\tque.push(s);\n\t\tdist[s.x][s.y][s.d] = s.dist;\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(s.dist > dist[s.x][s.y][s.d]) continue;\n\t\tif(s.x == 1 && s.y == 1) return s.dist;\n\n\t\toverwrite(s.x, s.y, '*');\n\t\tconst auto c1 = bfs({s.x+ddx[s.d][0], s.y+ddy[s.d][0]});\n\t\tconst auto c2 = bfs({s.x+ddx[s.d][1], s.y+ddy[s.d][1]});\n\t\toverwrite(s.x, s.y, 'o');\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = s.x + dx[d], ny = s.y + dy[d];\n\t\t\tconst int nx1 = s.x + ddx[d][0], nx2 = s.x + ddx[d][1];\n\t\t\tconst int ny1 = s.y + ddy[d][0], ny2 = s.y + ddy[d][1];\n\n\t\t\tif(field[ny1][nx1] == '*' || field[ny2][nx2] == '*') continue;\n\t\t\tint n_dist = s.dist + 1;\n\t\t\tif(s.d != d) n_dist += min(c1[ny1][nx1] + c2[ny2][nx2], c1[ny2][nx2] + c2[ny1][nx1]);\n\t\t\tif(dist[nx][ny][(d ^ 1)] > n_dist) {\n\t\t\t\tdist[nx][ny][(d ^ 1)] = n_dist;\n\t\t\t\tque.push({nx, ny, (d ^ 1), n_dist});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfield[0] = field[h + 1] = string(w + 2, '*');\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tcin >> field[i];\n\t\t\tfield[i] = '*' + field[i] + '*';\n\t\t}\n\n\t\tint sx = INF, sy = INF;\n\t\tvector<pair<int, int>> ps;\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\tps.emplace_back(x, y);\n\t\t\t\t\tfield[y][x] = 'o';\n\t\t\t\t}\n\t\t\t\telse if(field[y][x] == 'X') {\n\t\t\t\t\tchmin(sx, x);\n\t\t\t\t\tchmin(sy, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(sx == 1 && sy == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\toverwrite(sx, sy, '*');\n\t\tconst auto c1 = bfs(ps[0]);\n\t\tconst auto c2 = bfs(ps[1]);\n\t\toverwrite(sx, sy, 'o');\n\n\t\tvector<state> start;\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tint init_dist = INF;\n\t\t\tfor(int i = 0; i <= 1; ++i) {\n\t\t\t\tchmin(init_dist, c1[sy+ddy[d][i]][sx+ddx[d][i]] + c2[sy+ddy[d][1-i]][sx+ddx[d][1-i]]);\n\t\t\t}\n\t\t\tif(init_dist == INF) continue;\n\t\t\tstart.emplace_back(sx, sy, d, init_dist);\n\t\t}\n\n\t\tcout << dijkstra(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint bx[4][2] = { {2, 2}, {0, 1}, {-1, -1}, {0, 1}};\nint by[4][2] = { {0, 1}, {2, 2}, {0, 1}, {-1, -1}};\nint from[4][2] = { {0, 1}, {1, 0}, {0, 1}, {1, 0} };\nint to[4][2] = { {0, 1}, {1, 0}, {1, 0}, {0, 1} };\nint H, W;\nint bfs(const vector<string>& grid, int sx, int sy, int gx, int gy){\n  queue<int> qx, qy;\n  int d[50][50]; memset(d, -1, sizeof(d));\n  qx.push(sx); qy.push(sy);\n  d[sy][sx] = 0;\n  //printf(\"start %d %d\\n\", sx, sy);\n  //REP(y, H){ cout<<grid[y]<<endl; }\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    if(x == gx && y == gy) return d[y][x];\n    REP(r, 4){\n      int nx = x + dx[r];\n      int ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] != '*' && d[ny][nx] == -1){\n        d[ny][nx] = d[y][x] + 1;\n        qx.push(nx); qy.push(ny);\n      }\n    }\n  }\n  return INF;\n}\nstruct S{\n  int x, y, r, d;\n  S(int x, int y, int r, int d) : x(x), y(y), r(r), d(d) {}\n  bool operator < (const S& s) const {\n    return d > s.d;\n  }\n  void print(){\n    printf(\"x = %d y = %d r = %d d = %d\\n\", x, y, r, d);\n  }\n};\n\nint main(){\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    vector<string> grid_sub(H, string('.', W));\n    REP(i, H) cin>>grid[i];\n    int sx = W, sy = H;\n    REP(y, H) REP(x, W)if(grid[y][x] == 'X'){\n      sx = min(x, sx); sy = min(sy, y); \n    }\n    if(sx == 0 && sy == 0){\n      cout<<0<<endl;\n      continue;\n    }\n    priority_queue<S> que;\n    REP(r, 4){\n      int nx = sx + dx[r];\n      int ny = sy + dy[r];\n      bool ok = true;\n      if(!valid(nx, ny, W, H) || !valid(nx + 1, ny + 1, W, H)) continue;\n      REP(dx, 2)REP(dy, 2) if(grid[ny + dy][nx + dx] == '*') ok = false;\n      if(!ok) continue;\n      //printf(\">nx = %d ny = %d r = %d\\n\", nx, ny, r);\n      /* 空白が目的地 */\n      vector<int> tx, ty;\n      REP(y, H)REP(x, W) if(grid[y][x] == '.'){\n        //printf(\"tx = %d ty = %d\\n\", x, y);\n        tx.push_back(x); ty.push_back(y);\n      }\n      /* 大ピースが進む場所が出発地 */\n      vector<int> fx, fy;\n      REP(i, 2){ fx.push_back(sx + bx[r][i]); fy.push_back(sy + by[r][i]); }\n      //REP(i, 2) printf(\"fx = %d fy = %d\\n\", fx[i], fy[i]);\n      int cost = INF;\n      REP(k, 4){\n        //printf(\"> k = %d\\n\", k);\n        REP(y, H)REP(x, W){\n          if(grid[y][x] == '*') grid_sub[y][x] = '*';\n          else if(sx <= x && x <= sx + 1 && sy <= y && y <= sy + 1) grid_sub[y][x] = '*';\n          else if(grid[y][x] == 'o') grid_sub[y][x] = '.';\n          else grid_sub[y][x] = '.';\n        }\n        int f1 = from[k][0], t1 = to[k][0];\n        int f2 = from[k][1], t2 = to[k][1];\n        int c1 = bfs(grid_sub, fx[f1], fy[f1], tx[t1], ty[t1]);\n        int c2 = bfs(grid_sub, fx[f2], fy[f2], tx[t2], ty[t2]);\n        //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f1], fy[f1], tx[t1], ty[t1], c1);\n        //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f2], fy[f2], tx[t2], ty[t2], c2);\n        cost = min(cost, c1 + c2 + 1);\n      }\n      if(cost == INF) continue;\n      que.push(S(nx, ny, (r + 2) % 4, cost));\n    }\n    bool used[50][50][4] = {};\n    bool output = false;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == 0 && s.y == 0){\n        printf(\"%d\\n\", s.d);\n        output = true;\n        break;\n      }\n      if(used[s.y][s.x][s.r]) continue;\n      used[s.y][s.x][s.r] = true;\n      //s.print();\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        bool ok = true;\n        if(!valid(nx, ny, W, H) || !valid(nx + 1, ny + 1, W, H)) continue;\n        REP(dx, 2)REP(dy, 2) if(grid[ny + dy][nx + dx] == '*') ok = false;\n        if(!ok) continue;\n        //printf(\">nx = %d ny = %d r = %d\\n\", nx, ny, r);\n        /* 空白が目的地 */\n        vector<int> tx, ty;\n        REP(i, 2){ tx.push_back(s.x + bx[s.r][i]); ty.push_back(s.y + by[s.r][i]); }\n        /* 大ピースが進む場所が出発地 */\n        vector<int> fx, fy;\n        REP(i, 2){ fx.push_back(s.x + bx[r][i]); fy.push_back(s.y + by[r][i]); }\n        //REP(i, 2) printf(\"fx = %d fy = %d\\n\", fx[i], fy[i]);\n        int cost = INF;\n        REP(k, 4){\n          //printf(\"> k = %d\\n\", k);\n          REP(y, H)REP(x, W){\n            if(grid[y][x] == '*') grid_sub[y][x] = '*';\n            else if(s.x <= x && x <= s.x + 1 && s.y <= y && y <= s.y + 1) grid_sub[y][x] = '*';\n            else if(grid[y][x] == 'o') grid_sub[y][x] = '.';\n            else grid_sub[y][x] = '.';\n          }\n          int f1 = from[k][0], t1 = to[k][0];\n          int f2 = from[k][1], t2 = to[k][1];\n          int c1 = bfs(grid_sub, fx[f1], fy[f1], tx[t1], ty[t1]);\n          int c2 = bfs(grid_sub, fx[f2], fy[f2], tx[t2], ty[t2]);\n          //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f1], fy[f1], tx[t1], ty[t1], c1);\n          //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f2], fy[f2], tx[t2], ty[t2], c2);\n          cost = min(cost, c1 + c2 + 1);\n        }\n        if(cost == INF) continue;\n        if(!used[ny][nx][(r + 2) % 4]){\n          que.push(S(nx, ny, (r + 2) % 4, s.d + cost));\n        }\n      }\n    }\n    if(!output) cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <string>\n#define INF 7000\nusing namespace std;\nint h,w;\nbool fie[51][51];\nint res=INF;\nint sx,sy;\nstruct data{\n};\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tsx=sy=-1;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='o')fie[i][j]=1;\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tfie[i][j]=1;\n\t\t\t\t\tif(sx==-1){\n\t\t\t\t\t\tsx=j;\n\t\t\t\t\t\tsy=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//dfs()\n\t\tif(cnt>2)while(1);\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cassert>\n#include<climits>\n#include<iomanip>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 51\nusing namespace std;\nint h,w;\nstring G[MAX];\nint mincost[MAX*MAX][4][4];\nint dx[] = {+0,+1,+0,-1};//&#9757;↑→↓←\nint dy[] = {-1,+0,+1,+0};\nint kdx[] = {0,1,1,0};\nint kdy[] = {0,0,1,1};\n\n/*\n\no <- od \n2 <- d2\n   o2\n  2KKo\n  oKK2\n   2o    \n\n */\nint dx2[] = {+1,+0,-1,+0};\nint dy2[] = {+0,+1,+0,-1};\n\nint odx[] = {+0,+2,+1,-1};\nint ody[] = {-1,+0,+2,+1};\n\nstruct P\n{\n  int x,y;\n  P(int x=-1,int y=-1):x(x),y(y){}\n};\n\nstruct Pox\n{\n  P p;\n  int cost;\n  Pox(P p = P(),int cost=-1):p(p),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nstruct Pess\n{\n  P p;\n  int cost;\n  int dir;\n  Pess(P p = P(),int cost=-1,int dir=-1):p(p),cost(cost),dir(dir){}\n  bool operator < (const Pess &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\ninline\nint getIndex(P p){ return p.x+p.y*w; }\n\nint open_mincost[MAX*MAX];\n\nvoid open_the_door(P pxl,P king)//do not move the king before using this function\n{\n\n  priority_queue<Pox> Q;\n  Q.push(Pox(pxl,0));\n  bool used[MAX*MAX];\n  bool in_king[MAX*MAX];\n  rep(i,MAX*MAX)open_mincost[i] = inf,used[i] = false,in_king[i] = false;\n  open_mincost[getIndex(pxl)] = 0;\n  int cnt = 0;\n  rep(i,4)\n    {\n      int kx = king.x + kdx[i];\n      int ky = king.y + kdy[i];\n\n      if(!(0 <= kx && kx < w && 0 <= ky && ky < h))\n\t{\n\t  //cout << \"XXXXX error XXXXX\" << endl;\n\t  //cout << kx << \",\" << ky << \" are out of the range\" << endl;\n\t  assert(false);\n\t}\n      //cout << \"king : \" << kx << \",\" << ky << \" = \" << getIndex(P(kx,ky))<< endl;\n      in_king[getIndex(P(kx,ky))] = true;\n    }\n\n  rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(0 <= x1 && x1 < w && 0 <= y1 && y1 < h && G[y1][x1] != '*')\n\t{\t\n\t  //cout << \"add \" << x1 << \",\" << y1 << endl;\n\t  used[getIndex(P(x1,y1))] = true;\n\t  cnt++; \n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(0 <= x2 && x2 < w && 0 <= y2 && y2 < h && G[y2][x2] != '*')\n\t{\n\t  //cout << \"add \" << x2 << \",\" << y2 << endl;\n\t  used[getIndex(P(x2,y2))] = true;\n\t  cnt++; \n\t}\n\n    }\n  //cout << \"cnt = \" << cnt << endl;\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      if(used[getIndex(pox.p)])\n\t{\n\t  //cout <<\"here \"<< pox.p.x << \",\" << pox.p.y << endl;\n\t  used[getIndex(pox.p)] = false;\n\t  cnt--;\n\t}\n      if(cnt <= 0)\n\treturn;\n\n      rep(i,4)\n\t{\n\t  int nx = pox.p.x + dx[i];\n\t  int ny = pox.p.y + dy[i];\n\t  //cout << \"from\" << pox.p.x << \",\" << pox.p.y << \" want to go to \" << nx << \",\" << ny << endl;\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  //cout << \"---1\" << endl;\n\t  if(G[ny][nx] == '*')continue;\n\t  //cout << \"---3 \" << nx << \",\" << ny << \" \" << in_king[getIndex(P(nx,ny))] << endl;\t    \n\t  if(in_king[getIndex(P(nx,ny))])continue;\n\t  //cout << \"---4\" << endl;\n\t  //cout << \"now : \" << open_mincost[getIndex(P(nx,ny))] << \" >? \"<< pox.cost+1 << endl;\n\t  if(open_mincost[getIndex(P(nx,ny))] > pox.cost+1)\n\t    {\n\t      //cout << \"goto \" << nx << \",\" << ny  << \" : cost = \" << pox.cost+1<< endl;\n\t      //assert(!(nx == 3 && ny == 2));\n\t      open_mincost[getIndex(P(nx,ny))] = pox.cost+1;\n\t      Q.push(Pox(P(nx,ny),pox.cost+1));\n\t    }\n\t}\n    }\n}\n\nvoid init_mincost()\n{\n  int temp[4][2];\n  rep(i,MAX*MAX)rep(j,4)rep(k,4)mincost[i][j][k] = inf;\n\n  rep(i,h)\n    {\n      if(i+1 >= h)continue;\n      rep(j,w)\n\t{\n\t  if(G[i][j] == '*')continue;\n\t  if(j+1 >= w)continue;\n\t  rep(k,4)\n\t    {\n\t      int nx = j + odx[k];\n\t      int ny = i + ody[k];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '*')continue;\n\n\t      int mx = nx + dx2[k];\n\t      int my = ny + dy2[k];\n\t      if(!(0 <= mx && mx < w && 0 <= my && my < h))continue;\n\t      if(G[my][mx] == '*')continue;\n\n\t      open_the_door(P(nx,ny),P(j,i));//calculate the minimum cost from P(nx,ny) to all cells\n\t      rep(l,4)\n\t\t{//store the information about the minimum cost from P(nx,ny)\n\t\t  int x1 = j + odx[l];\n\t\t  int y1 = i + ody[l];\n\t\t  if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t\t    {\n\t\t      temp[l][0] = temp[l][1] = inf;\n\t\t      continue;\n\t\t    }\n\t\t  int x2 = x1 + dx2[l];\n\t\t  int y2 = y1 + dy2[l];\n\t\t  if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t\t    {\n\t\t      temp[l][0] = temp[l][1] = inf;\n\t\t      continue;\n\t\t    }\n\t\t  temp[l][0] = open_mincost[getIndex(P(x1,y1))];\n\t\t  temp[l][1] = open_mincost[getIndex(P(x2,y2))];\n\n\t\t}\n\t      /*\n\t\t  if(j == 4 && i == 2 && k == 2)\n\t\t    {\n\t\t      cout << \"origine!\" << endl;\n\t\t      cout << temp[3][0] << \" \" << temp[3][1] << endl;\n\t\t    }\n\t      */\n\t      open_the_door(P(mx,my),P(j,i));//caluclate the minimum cost from P(mx,my) to all cells\n\n\t      rep(l,4)\n\t\t{\n\t\t  int x1 = j + odx[l];\n\t\t  int y1 = i + ody[l];\n\t\t  if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t\t    {\n\t\t      continue;\n\t\t    }\n\t\t  int x2 = x1 + dx2[l];\n\t\t  int y2 = y1 + dy2[l];\n\t\t  if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t\t    {\n\t\t      continue;\n\t\t    }\n\t\t  mincost[getIndex(P(j,i))][k][l] = min(temp[l][0]+open_mincost[getIndex(P(x2,y2))],\n\t\t\t\t\t\t\ttemp[l][1]+open_mincost[getIndex(P(x1,y1))]);\n\n\n\t\t  if(k == l)\n\t\t    {\n\t\t      assert(mincost[getIndex(P(j,i))][k][l] == 0);\n\t\t    }\n\t\t}\n\n\t      /*\n\t\t  if(j == 4 && i == 2 && k == 2)\n\t\t    {\n\t\t      cout << \"habeii!\" << endl;\n\t\t      cout << mincost[getIndex(P(4,2))][2][3] << endl;\n\t\t    }\n\t      */\n\t    }\n\t}\n    }\n\n}\n\n/* collisionする場合ってありえる？\n->そもそも関係ない気がする！！！\nXXXXXXX\n      X\nXXXXX↓X\n   →collision!!!\nXXXXX\nXXXXXXXXXXXX.................................................\n.....XXXXXXX......................................\n.XXX.....XXXX.....................................\n...XXXXX....X.....................................\nKK.....X.XX.X.....................................\nKKXXXX...X........................................\n..X..XXXXX........................................\n.....XXXXX........................................\n..................................................\n */\n\n\n\nint King_Of_The_King[4];//&#9757;上、右、下、左\n\nbool check(int x,int y)\n{\n  //cout << \"isok? \" << x << \",\" << y << \" \"; \n  rep(i,4)\n    {\n      int kx = x + kdx[i];\n      int ky = y + kdy[i];\n      if(!(0 <= kx && kx < w && 0 <= ky && ky < h))\n\t{\n\t  //cout << \"NO!\" << endl;\n\t  return false;\n\t}\n      if(G[ky][kx] == '*')\n\t{\n\t  //cout << \"NO!!\" << endl;\n\t  return false;\n\t}\n    }\n  //cout << \" oK!\" << endl;\n  return true;\n}\n\nint costc[MAX*MAX][4];\nvoid dijkstra(P king)\n{\n  priority_queue<Pess> Q;\n  rep(i,4)\n    Q.push(Pess(king,King_Of_The_King[i],i));\n\n  rep(i,MAX*MAX)rep(j,4)costc[i][j] = inf;\n  rep(i,4)costc[getIndex(king)][i] = King_Of_The_King[i];\n\n  while(!Q.empty())\n    {\n      Pess pess = Q.top(); Q.pop();\n      //cout << \"------------- \" << pess.p.x << \",\" << pess.p.y << endl;\n      if(pess.p.x == 0 && pess.p.y == 0)\n\t{\n\t  cout << pess.cost << endl;\n\t  return;\n\t}\n      rep(i,4)\n\t{\n\t  int nx = pess.p.x + dx[i];\n\t  int ny = pess.p.y + dy[i];\n\t  if(!check(nx,ny))continue;\n\t  //cout << \"to \" << nx << \",\" << ny << \"  \" << costc[getIndex(P(nx,ny))][(i+2)%2] << \" > \" << pess.cost << \"+\" << mincost[getIndex(pess.p)][pess.dir][i]+1 << \" mincost[\"<<pess.p.x << \",\"<< pess.p.y<<\"][\"<<pess.dir<<\"][\"<<i<<\"]\"<< endl;\n\t  if(costc[getIndex(P(nx,ny))][(i+2)%2] > pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1)\n\t    {\n\t      //cout << \"from \" << pess.p.x << \",\" << pess.p.y << \" to \" << nx << \",\" << ny << endl;\n\t      costc[getIndex(P(nx,ny))][(i+2)%2] = pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1;\n\t      Q.push(Pess(P(nx,ny),pess.cost+mincost[getIndex(pess.p)][pess.dir][i]+1,(i+2)%4));\t    \n\t    }\n\t}\n    }\n  cout << -1 << endl;\n}\n\n//its time to play the game\nvoid move_open_to_the_side_of_King(P o1,P o2,P king)\n{\n  int temp[4][2];\n\n  open_the_door(o1,king);\n  rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t{\n\t  //temp[i][0] = temp[i][1] = inf;\n\t  temp[i][0] = temp[i][1] = 0;\n\t  continue;\n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t{\n\t  //temp[i][0] = temp[i][1] = inf;\n\t  temp[i][0] = temp[i][1] = 0;\n\t  continue;\n\t}\n      temp[i][0] = open_mincost[getIndex(P(x1,y1))];\n      temp[i][1] = open_mincost[getIndex(P(x2,y2))];\n    }\n\n  open_the_door(o2,king);\n rep(i,4)\n    {\n      int x1 = king.x + odx[i];\n      int y1 = king.y + ody[i];\n      if(!(0 <= x1 && x1 < w && 0 <= y1 && y1 < h) || G[y1][x1] == '*')\n\t{\n\t  //King_Of_The_King[i] = inf;\n\t  King_Of_The_King[i] = 0;\n\t  continue;\n\t}\n      int x2 = x1 + dx2[i];\n      int y2 = y1 + dy2[i];\n      if(!(0 <= x2 && x2 < w && 0 <= y2 && y2 < h) || G[y2][x2] == '*')\n\t{\n\t  //King_Of_The_King[i] = inf;\n\t  King_Of_The_King[i] = 0;\n\t  continue;\n\t}\n\n      //cout << temp[i][0] << \",\" << temp[i][1] << \" \" << open_mincost[getIndex(P(x2,y2))] << \",\" << open_mincost[getIndex(P(x1,y1))] << endl;\n      King_Of_The_King[i] = min(temp[i][0]+open_mincost[getIndex(P(x2,y2))],\n\t\t\t\ttemp[i][1]+open_mincost[getIndex(P(x1,y1))]);\n    }\n\n}\n\n\n\n\nint main()\n{\n  //clock_t st,ed;\n  //st = clock();\n  while(cin >> h >> w,h|w)\n    {\n\n      vector<P> open;\n      P king;\n\n      rep(i,h)\n\t{\n\t  cin >> G[i];\n\t  rep(j,w)\n\t    {\n\t      if(G[i][j]  == '.')\n\t\topen.push_back(P(j,i));\n\t      \n\t      if(G[i][j] == 'X' && king.x == -1 && king.y == -1)\n\t\tking = P(j,i);\n\t    }\n\t}\n\n      init_mincost();\n      move_open_to_the_side_of_King(open[0],open[1],king);\n      dijkstra(king);\n      //move_open_to_the_side_of_King(open[0],open[1],king);\n      //cout << King_Of_The_King[0] << endl;\n      //cout << King_Of_The_King[1] << endl;\n      //cout << King_Of_The_King[2] << endl;\n      //cout << King_Of_The_King[3] << endl;\n\n      //open_the_door(P(4,4),P(4,2));\n      \n      //cout << open_mincost[getIndex(P(3,2))] << endl;\n      //cout << open_mincost[getIndex(P(3,3))] << endl;\n      /*\n      init_mincost();\n      int cnt = 1;\n      rep(i,h)\n      {\n      rep(j,w)\n      {\n\t//cout << \"from \" << j << \" \" << i << endl;\n      rep(k,4)\n      {\n      rep(l,4)\n      {\n\tif(cnt == 113)\n\t  {\n\t    cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t  }\n\tcnt++;\n\tif(mincost[j+i*w][k][l] >= inf)cout << 0 << endl;\n\telse cout << mincost[j+i*w][k][l]+1 << endl;\n      }\n      }\n      }\n      }\n      */\n      //cout << mincost[getIndex(P(3,3))][0][2] << endl;\n      \n    }\n  //ed = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(ed-st)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 500;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nchar mp[50][50];\nbool b[50][50];\n\nstruct edge {\n\tint to, cost;\n};\n\nvector<edge> G[10000];\n\nint h, w;\nint dist[50][50][2];\nbool isok(int sx, int sy) {\n\tif (sx < 0 || sy < 0 || sx >= h || sy >= w)return false;\n\treturn true;\n}\nbool yaru(int sx,int sy,int id) {\n\tif (sx < 0 || sy < 0 || sx >= h || sy >= w || b[sx][sy])return false;\n\trep(i, h)rep(j, w)dist[i][j][id] = mod;\n\tqueue<P> q;\n\tdist[sx][sy][id] = 0; q.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tP p = q.front(); q.pop();\n\t\trep(j, 4) {\n\t\t\tint nx = p.first + dx[j];\n\t\t\tint ny = p.second + dy[j];\n\t\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w)continue;\n\t\t\tif (b[nx][ny])continue;\n\t\t\tif (dist[p.first][p.second][id] + 1 < dist[nx][ny][id]) {\n\t\t\t\tdist[nx][ny][id] = dist[p.first][p.second][id] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint cx[8] = { 0,1,2,2,0,1,-1,-1 };\nint cy[8] = { 2,2,0,1,-1,-1,0,1 };\n\nint dp[10000];\nvoid solve() {\n\trep(i, 10000) {\n\t\tG[i].clear(); dp[i] = mod;\n\t}\n\trep(i, h)rep(j, w) {\n\t\tcin >> mp[i][j];\n\t\tb[i][j] = (mp[i][j] == '*');\n\t}\n\trep(i, h - 1) {\n\t\trep(j, w - 1) {\n\t\t\tbool valid = true;\n\t\t\trep(x, 2)rep(y, 2)if (b[i + x][j + y])valid = false;\n\t\t\tif (!valid)continue;\n\t\t\trep(x, 2)rep(y, 2)b[i + x][j + y] = true;\n\n\t\t\trep(l, 4) {\n\t\t\t\tint sx[2]; int sy[2];\n\t\t\t\tvalid = true;\n\t\t\t\trep(t, 2) {\n\t\t\t\t\tsx[t] = i + cx[l * 2 + t];\n\t\t\t\t\tsy[t] = j + cy[l * 2 + t];\n\t\t\t\t\tif (!yaru(sx[t], sy[t],t))valid = false;\n\t\t\t\t}\n\t\t\t\tif (!valid)continue;\n\t\t\t\tint sid = i * (w - 1) + j + l * (h - 1)*(w - 1);\n\t\t\t\tint ni = i + dx[l], nj = j + dy[l];\n\t\t\t\tint tid = ni * (w - 1) + nj + (l ^ 2)*(h - 1)*(w - 1);\n\t\t\t\tG[sid].push_back({ tid,1 });\n\t\t\t\tG[tid].push_back({ sid,1 });\n\t\t\t\t\n\t\t\t\tRep(m, l + 1, 4) {\n\t\t\t\t\tint gx[2], gy[2];\n\t\t\t\t\tvalid = true;\n\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\tgx[t] = i + cx[m * 2 + t];\n\t\t\t\t\t\tgy[t] = j + cy[m * 2 + t];\n\t\t\t\t\t\tif (!isok(gx[t], gy[t]))valid = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!valid)continue;\n\t\t\t\t\tint cost = mod;\n\t\t\t\t\trep(t, 2) {\n\t\t\t\t\t\tcost = min(cost, dist[gx[0]][gy[0]][t] + dist[gx[1]][gy[1]][t ^ 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (cost != mod) {\n\t\t\t\t\t\tint sid = i * (w - 1) + j + l * (h - 1)*(w - 1);\n\t\t\t\t\t\tint tid = i * (w - 1) + j + m * (h - 1)*(w - 1);\n\t\t\t\t\t\tG[sid].push_back({ tid,cost });\n\t\t\t\t\t\tG[tid].push_back({ sid,cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(x, 2)rep(y, 2)b[i + x][j + y] = false;\n\t\t}\n\t}\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tvector<P> v;\n\trep(i, h)rep(j, w) {\n\t\tif (mp[i][j] == '.') {\n\t\t\tv.push_back({ i,j });\n\t\t}\n\t}\n\tint lx, ly;\n\tper(i, h)per(j, w) {\n\t\tif (mp[i][j] == 'X') {\n\t\t\tlx = i, ly = j;\n\t\t}\n\t}\n\trep(x, 2)rep(y, 2)b[lx + x][ly + y] = true;\n\trep(t, 2)yaru(v[t].first, v[t].second, t);\n\trep(x, 2)rep(y, 2)b[lx + x][ly + y] = false;\n\t\n\tif (lx == 0 && ly == 0) {\n\t\tcout << 0 << endl; return;\n\t}\n\trep(l, 4) {\n\t\tint sx[2]; int sy[2];\n\t\tbool valid = true;\n\t\trep(t, 2) {\n\t\t\tsx[t] = lx + cx[l * 2 + t];\n\t\t\tsy[t] = ly + cy[l * 2 + t];\n\t\t\tif (!isok(sx[t], sy[t]))valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint cost = mod;\n\t\trep(t, 2) {\n\t\t\tcost = min(cost, dist[sx[0]][sy[0]][t] + dist[sx[1]][sy[1]][1 ^ t]);\n\t\t}\n\t\tint tid = lx * (w - 1) + ly + l * (h - 1)*(w - 1);\n\t\tdp[tid] = cost;\n\t\tq.push({ cost,tid });\n\t}\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (dp[id] < p.first)continue;\n\t\tfor (edge e : G[id]) {\n\t\t\tint nd = e.cost + dp[id];\n\t\t\tif (nd < dp[e.to]) {\n\t\t\t\tdp[e.to] = nd;\n\t\t\t\tq.push({ nd,e.to });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = min(dp[(h - 1)*(w - 1)], dp[0]);\n\tif (ans == mod) {\n\t\tans = -1;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f(); init();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile (cin >>h>>w,h)solve();\n\t//solve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nstruct S{\nint x1,y1,x2,y2,x,y,step;\n}t,que[2000000];\n\nchar mp[50][51];\nbool vis[2000000];\nint tot,nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\nmap<long long,int>li;\n\nint getval()\n{\n    int x1=t.x1,x2=t.x2,y1=t.y1,y2=t.y2;\n\n    if(x1>x2)\n    {\n        swap(x1,x2);\n        swap(y1,y2);\n    }\n    else if(x1==x2 && y1>y2)\n    {\n        swap(x1,x2);\n        swap(y1,y2);\n    }\n\n    long long res=(long long)x1*50+y1;\n\n    res=res*50+x2;\n    res=res*50+y2;\n    res=res*50+t.x;\n    res=res*50+t.y;\n\n    if(!li[res]) return li[res]=tot++;\n\n    else return li[res];\n}\n\nbool check()\n{\n    if(t.x1==t.x2 && t.y1==t.y2) return 0;\n\n    if(mp[t.x1][t.y1]=='*') return 0;\n    if(mp[t.x2][t.y2]=='*') return 0;\n\n    if(t.x1==t.x && t.y1==t.y) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y) return 0;\n    if(t.x1==t.x && t.y1==t.y+1) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y+1) return 0;\n\n    if(t.x2==t.x && t.y2==t.y) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y) return 0;\n    if(t.x2==t.x && t.y2==t.y+1) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y+1) return 0;\n\n    return 1;\n}\n\nbool px(S &p)\n{\n    if(p.x1>p.x2)\n    {\n        swap(p.x1,p.x2);\n        swap(p.y1,p.y2);\n    }\n    else if(p.x1==p.x2 && p.y1>p.y2)\n    {\n        swap(p.x1,p.x2);\n        swap(p.y1,p.y2);\n    }\n}\n\nint main()\n{\n    int n,m,i,j,cnt,top,bottom;\n    bool flag;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<n;i++) scanf(\"%s\",mp[i]);\n\n        cnt=0;\n        flag=0;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++)\n        {\n            if(mp[i][j]=='.')\n            {\n                if(!cnt) t.x1=i,t.y1=j,cnt++;\n                else t.x2=i,t.y2=j;\n            }\n            else if(mp[i][j]=='X' && !flag)\n            {\n                t.x=i,t.y=j;\n\n                flag=1;\n            }\n        }\n\n        tot=1;\n\n        memset(vis,0,sizeof vis);\n\n        vis[getval()]=1;\n\n        li.clear();\n\n        t.step=0;\n\n        top=0;\n        bottom=1;\n\n        que[0]=t;\n\n        while(top<bottom)\n        {\n            t=que[top];\n//printf(\"tot=%d\\n\",tot);\n            if(!t.x && !t.y)\n            {\n                printf(\"%d\\n\",t.step);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t.x1+=nxt[i][0];\n                t.y1+=nxt[i][1];\n\n                if(t.x1>=0 && t.x1<n && t.y1>=0 && t.y1<m && check() && !vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x1-=nxt[i][0];\n                t.y1-=nxt[i][1];\n            }\n\n            for(i=0;i<4;i++)\n            {\n                t.x2+=nxt[i][0];\n                t.y2+=nxt[i][1];\n\n                if(t.x2>=0 && t.x2<n && t.y2>=0 && t.y2<m && check() && !vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x2-=nxt[i][0];\n                t.y2-=nxt[i][1];\n            }\n\n\n            px(t);\n\n            if(t.x1==t.x-1 && t.y1==t.y && t.x2==t.x-1 && t.y2==t.y+1)\n            {\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x+2 && t.y1==t.y && t.x2==t.x+2 && t.y2==t.y+1)\n            {\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y-1 && t.x2==t.x+1 && t.y2==t.y-1)\n            {\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y+2 && t.x2==t.x+1 && t.y2==t.y+2)\n            {\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step--;\n            }\n        }\n\n        if(top==bottom) printf(\"-1\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[55][55][4];\nInt mv[55][55][4][4];\nInt di[8][55][55];\nconst Int INF = 1e9;\nsigned main(){\n  Int n,m;\n  while(cin>>n>>m,n){\n    vector<string> s(n);\n    for(Int i=0;i<n;i++) cin>>s[i];\n    auto in=[&](Int y,Int x){\n      return 0<=y&&y<n&&0<=x&&x<m;\n    };\n    using P = pair<Int, Int>;\n    P st;\n    vector<P> sp;\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<m;j++){\n\tif(s[i][j]=='X'){\n\t  assert(s[i][j+1]=='X');\n\t  assert(s[i+1][j]=='X');\n\t  assert(s[i+1][j+1]=='X');\n\t  s[i][j]=s[i][j+1]='o';\n\t  s[i+1][j]=s[i+1][j+1]='o';\n\t  st=P(i,j);\n\t}\n\tif(s[i][j]=='.') sp.emplace_back(i,j);\n      }\n    }\n    if(st==P(0,0)){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    //cout<<st.first<<\" \"<<st.second<<endl;\n    //cout<<sp.size()<<endl;\n    //for(int i=0;i<n;i++) cout<<s[i]<<endl;cout<<endl;\n    \n    auto bfs=[&](Int sy,Int sx){\n      Int ay[]={-1,-1,0,1,2,2,1,0};\n      Int ax[]={0,1,2,2,1,0,-1,-1};\n\n      if(s[sy][sx]=='*'||\n\t !in(sy,sx+1)||s[sy][sx+1]=='*'||\n\t !in(sy+1,sx)||s[sy+1][sx]=='*'||\n\t !in(sy+1,sx+1)||s[sy+1][sx+1]=='*') return;\n      \n      s[sy][sx]=s[sy][sx+1]='*';\n      s[sy+1][sx]=s[sy+1][sx+1]='*';\n      \n      for(Int k=0;k<8;k++){\n\tInt y=sy+ay[k],x=sx+ax[k];\n\tfor(Int i=0;i<55;i++)\n\t  for(Int j=0;j<55;j++)\n\t    di[k][i][j]=INF;\n\tif(!in(y,x)||s[y][x]=='*') continue;\n\tqueue<P> q;\n\tq.emplace(y,x);\n\tdi[k][y][x]=0;\n\tInt dy[]={0,1,0,-1};\n\tInt dx[]={1,0,-1,0};\n\twhile(!q.empty()){\n\t  P p=q.front();q.pop();\n\t  y=p.first;x=p.second;\n\t  for(Int i=0;i<4;i++){\n\t    Int ny=y+dy[i],nx=x+dx[i];\n\t    if(!in(ny,nx)||s[ny][nx]=='*'||di[k][ny][nx]<=di[k][y][x]+1) continue;\n\t    di[k][ny][nx]=di[k][y][x]+1;\n\t    q.emplace(ny,nx);\n\t  }\n\t}\n      }\n      \n      for(Int i=0;i<4;i++){\n\tfor(Int j=0;j<4;j++){\n\t  if(!in(sy+ay[j*2],sx+ax[j*2])||!in(sy+ay[j*2+1],sx+ax[j*2+1])) continue;\n\t  Int a=di[i*2][sy+ay[j*2]][sx+ax[j*2]]+di[i*2+1][sy+ay[j*2+1]][sx+ax[j*2+1]];\n\t  Int b=di[i*2][sy+ay[j*2+1]][sx+ax[j*2+1]]+di[i*2+1][sy+ay[j*2]][sx+ax[j*2]];\n\t  mv[sy][sx][i][j]=min(a,b);\n\t  //cout<<sy<<\" \"<<sx<<\":\"<<i<<\" \"<<j<<\":\"<<mv[sy][sx][i][j]<<endl;;\n\t}\n      }\n      \n      s[sy][sx]=s[sy][sx+1]='o';\n      s[sy+1][sx]=s[sy+1][sx+1]='o';\n    };\n\n    for(Int i=0;i<55;i++)\n      for(Int j=0;j<55;j++)\n\tfor(Int k=0;k<4;k++){\n\t  dp[i][j][k]=INF;\n\t  for(Int l=0;l<4;l++)\n\t    mv[i][j][k][l]=INF;\n\t}\n\t  \n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    bfs(st.first,st.second);\n\n    using T = tuple<Int, Int, Int, Int>;\n    priority_queue<T,vector<T>,greater<T> > pq;\n    for(Int i=0;i<4;i++){\n      Int a=di[i*2][sp[0].first][sp[0].second]+di[i*2+1][sp[1].first][sp[1].second];\n      Int b=di[i*2][sp[1].first][sp[1].second]+di[i*2+1][sp[0].first][sp[0].second];\n      dp[st.first][st.second][i]=min(a,b);\n      if(dp[st.first][st.second][i]<INF)\n\tpq.emplace(dp[st.first][st.second][i],st.first,st.second,i);\n    }\n    while(!pq.empty()){\n      int d,y,x,k;\n      tie(d,y,x,k)=pq.top();pq.pop();\n      if(dp[y][x][k]<d) continue;\n      //cout<<y<<\" \"<<x<<\" \"<<k<<\":\"<<d<<endl;\n      int dy[]={-1,0,1,0};\n      int dx[]={0,1,0,-1};\n      {\n\tint ny=y+dy[k],nx=x+dx[k],nk=(k+2)%4;\n\tif(dp[y][x][k]+1<dp[ny][nx][nk]){\n\t  dp[ny][nx][nk]=dp[y][x][k]+1;\n\t  pq.emplace(dp[ny][nx][nk],ny,nx,nk);\n\t}\n      }\n      for(int i=0;i<4;i++){\n\tint c=mv[y][x][k][i];\n\t//cout<<i<<\":\"<<dp[y][x][i]<<\" \"<<dp[y][x][k]+c<<endl;\n\tif(dp[y][x][i]<=dp[y][x][k]+c) continue;\n\tdp[y][x][i]=dp[y][x][k]+c;\n\tpq.emplace(dp[y][x][i],y,x,i);\n      }\n    }\n    \n    Int ans=min(dp[0][0][1],dp[0][0][2]);\n    if(ans==INF) ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar ba[50][50];\n\nstruct P {\n  int y, x;\n  int d;\n  int dist;\n  P(int y, int x, int d, int dist) :\n    y(y),x(x),d(d),dist(dist) {}\n  bool operator<(const P &p) const {\n    return dist > p.dist;\n  }\n};\n\nint dist[50][50][4];\n\nint &get(const P &p) {\n  return dist[p.y][p.x][p.d];\n}\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nconst int kdy[4] = {0,0,1,1};\nconst int kdx[4] = {0,1,0,1};\n\nconst int pdy[4][2] = {0,1,2,2,0,1,-1,-1};\nconst int pdx[4][2] = {2,2,0,1,-1,-1,0,1};\n\nint h,w;\n\nbool ok(int y, int x) {\n  return valid(y,x,h,w) && ba[y][x]!='*';\n}\n\nbool isKing(int i, int j, int y, int x) {\n  REP(k,4) {\n    int yy=y+kdy[k];\n    int xx=x+kdx[k];\n    if (yy==i&xx==j) return 1;\n  }\n  return 0;\n}\n\nint dist2[2][50][50];\n\nvoid calcPawnDist(int id, int i, int j, int ky, int kx) {\n  queue<pii> Q;\n  Q.push(pii(i,j));\n  dist2[id][i][j] = 0;\n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    REP(k,4) {\n      int y=p.first+dy[k];\n      int x=p.second+dx[k];\n      if (!ok(y,x) || isKing(y,x,ky,kx) || dist2[id][y][x]!=-1) continue;\n      Q.push(pii(y,x));\n      dist2[id][y][x] = dist2[id][p.first][p.second]+1;\n    }\n  }\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    int ky=-1, kx;\n    vector<pii> ps;\n    REP(i,h)REP(j,w) {\n      if (ky==-1 && ba[i][j]=='X') ky = i, kx = j;\n      if (ba[i][j] == '.') ps.push_back(pii(i,j));\n    }\n    assert(ps.size() == 2 && ky != -1);\n\n    if (ky==0 && kx==0) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    memset(dist2,-1,sizeof(dist2));\n    REP(i,2) {\n      int y = ps[i].first;\n      int x = ps[i].second;\n      calcPawnDist(i,y,x,ky,kx);\n    }\n    \n    memset(dist, 0x3f, sizeof(dist));\n    priority_queue<P> PQ;\n\n    REP(d,4) {\n      int cost[2][2];\n      bool f = 1;\n      REP(i,2) {\n        int y=ky+pdy[d][i];\n        int x=kx+pdx[d][i];\n        if (!ok(y,x)) { f = 0;break; }\n        REP(j,2) {\n          cost[i][j] = dist2[j][y][x];\n          if (cost[i][j] == -1) f = 0;\n        }\n      }\n      if (f) {\n        int dis = min(cost[0][0]+cost[1][1], cost[0][1]+cost[1][0]);\n        dist[ky][kx][d] = dis;\n        PQ.push(P(ky,kx,d,dis));\n      }\n    }\n    \n    int ans = -1;\n    \n    while(!PQ.empty()) {\n      P p = PQ.top(); PQ.pop();\n\n      if (p.dist > get(p)) continue;\n\n      // cout << p.dist << endl;\n      // char c[h][w];\n      // REP(i,h)REP(j,w)c[i][j]=(ba[i][j]=='*'?'*':'o');\n      // REP(k,4) {\n      //   int y=p.y + kdy[k];\n      //   int x=p.x + kdx[k];\n      //   c[y][x]='X';\n      // }\n      // REP(i,2) c[p.y+pdy[p.d][i]][p.x+pdx[p.d][i]] = '.';\n      // REP(i,h) { REP(j,w) cout << c[i][j]; cout << endl;}\n      // cout << endl;\n\n      if (p.y==0 && p.x==0) {\n        ans = p.dist;\n        break;\n      }\n\n      // pawn\n      memset(dist2,-1,sizeof(dist2));\n      REP(i,2) {\n        int y = p.y+pdy[p.d][i];\n        int x = p.x+pdx[p.d][i];\n        calcPawnDist(i,y,x,p.y,p.x);\n      }\n\n      REP(d,4) {\n        int cost[2][2];\n        bool f = 1;\n        REP(i,2) {\n          int ty = p.y+pdy[d][i];\n          int tx = p.x+pdx[d][i];\n          if (!ok(ty,tx)) {f = 0;break;}\n          REP(j,2) {\n            cost[i][j] = dist2[j][ty][tx];\n            if (cost[i][j] == -1) f = 0;\n          }\n        }\n        if (f) {\n          int dis = min(cost[0][0]+cost[1][1], cost[0][1]+cost[1][0]);\n          P nxt(p.y,p.x,d,p.dist+dis);\n          if (get(nxt) > p.dist + dis) {\n            get(nxt) = p.dist + dis;\n            PQ.push(nxt);\n          }\n        }\n      }\n      \n      // king\n      int y = p.y+dy[p.d];\n      int x = p.x+dx[p.d];\n      P nxt(y,x,(p.d+2)%4,p.dist+1);\n      if (get(nxt) > p.dist+1) {\n        get(nxt) = p.dist + 1;\n        PQ.push(nxt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e7\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n\t2,2,\n\t0,1,\n\t-1,-1,\n\t0,1\n};\nint ddy[4][2]={\n\t0,1,\n\t2,2,\n\t0,1,\n\t-1,-1\n};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tint cost,pdir;\n\tP k;\n\tdata(){}\n\tdata(P kk,int cc,int pp){\n\t\tk=kk;\n\t\tcost=cc;\n\t\tpdir=pp;\n\t}\n\tbool operator<(const data &d1)const{\n\t\tif(cost!=d1.cost)return cost>d1.cost;\n\t\tif(k!=d1.k)return k>d1.k;\n\t\treturn pdir>d1.pdir;\n\t}\n};\n\nstruct data2{\n\tP k,o[2];\n\tdata2(){}\n\tdata2(P kk,P o1,P o2){\n\t\tk=kk;\n\t\to[0]=o1;\n\t\to[1]=o2;\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\nbool same(data2 a,data2 b){\n\tif(!same(a.k,b.k))return false;\n\tif(!same(a.o[0],b.o[0]))return false;\n\tif(!same(a.o[1],b.o[1]))return false;\n\treturn true;\n}\n\nint distp[51][51];\nint move_pawn(P f,P t){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tdistp[i][j]=INF;\n\t\t}\n\t}\n\tqueue<P> que;\n\tque.push(f);\n\tdistp[f.first][f.second]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tif(q==t)return distp[q.first][q.second];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nq=q+P(dy[i],dx[i]);\n\t\t\tif(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n\t\t\t\tif(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n\t\t\t\t\tdistp[nq.first][nq.second]=distp[q.first][q.second]+1;\n\t\t\t\t\tque.push(P(nq));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\ndata first_moveking(P k,P o1,P o2,int dir){\n\tdata res;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\ndata moveking(data q,int dir){\n\tdata res;\n\tP k=q.k;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tP o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n\tP o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1+q.cost;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n\tpriority_queue<data> que;\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n\t\t\tdata si=first_moveking(s,o1,o2,i);\n\t\t\tif(si.cost<INF){\n\t\t\t\tque.push(si);\n\t\t\t\tdist[si.k.first][si.k.second][si.pdir]=si.cost;\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n\t\tif(q.k.first+q.k.second==0)return q.cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n\t\t\t\tdata nq=moveking(q,i);\n\t\t\t\tif(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n\t\t\t\t\tdist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n\t\t\t\t\tque.push(nq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tP k,o[2];\n\t\tk.first=k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tif(k.first==-1){\n\t\t\t\t\t\tk.second=j;\n\t\t\t\t\t\tk.first=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\to[cnt].second=j;\n\t\t\t\t\to[cnt++].first=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(k.first+k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 50\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint h,w;\nchar mp[N][N];\nint G[N][N][4][4];\n\nbool in(int y,int x){return 0<=y && 0<=x && y < h && x < w && mp[y][x]!='*';}\n\nint bfs(int sy,int sx,int gy,int gx){\n  if(mp[sy][sx] == '*') return INF;\n  vector<vector<int> >D(h,vector<int>(w,-1));\n  queue<P> Q({P(sy,sx)});\n  D[sy][sx] = 0;\n\n  int dx[] ={0,0,1,-1};\n  int dy[] ={1,-1,0,0};\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    if(y == gy && x == gx) return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(!in(ny,nx) || D[ny][nx] != -1) continue;\n      Q.push(P(ny,nx));\n      D[ny][nx] = D[y][x] + 1;\n    }\n  }\n  return INF;\n}\n\nvoid buildG(int y,int x){\n  if(G[y][x][0][0]!=-1) return;\n  mp[y][x] = '*';\n  mp[y][x+1] = '*';\n  mp[y+1][x] = '*';\n  mp[y+1][x+1] = '*';\n\n  //for(int i=0;i<h;i++)cout<<mp[i]<<endl;\n\n\n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n\n  for(int i=0;i<4;i++)\n    for(int k=0;k<4;k++){\n      int d[2][2];\n      for(int j=0;j<2;j++)\n        for(int l=0;l<2;l++){\n          d[j][l] = INF;\n          int sx = x + dxi[i] + j * ((i+1)%2);\n          int sy = y + dyi[i] + j * (i%2);\n          int gx = x + dxi[k] + l * ((k+1)%2);\n          int gy = y + dyi[k] + l * (k%2);\n          //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<\" \"<<sx<<\" \"<<sy<<\" \"<<gx<<\" \"<<gy<<endl;\n          if(!in(sy,sx) || !in(gy,gx)) continue;\n          d[j][l] = bfs(sy,sx,gy,gx);\n        }\n      G[y][x][i][k] = INF;\n      for(int j=0;j<2;j++) \n        for(int l=0;l<2;l++) Min(G[y][x][i][k],d[j][l] + d[!j][!l]);\n    }\n  \n  /*  cout<<y<<\" \"<<x<<endl;\n  for(int i=0;i<4;i++)\n    for(int j=0;j<4;j++) cout<<\"i=\"<<i<<\" j=\"<<j<<\" \"<<G[y][x][i][j]<<endl;\n  */\n  mp[y][x] = '.';\n  mp[y][x+1] = '.';\n  mp[y+1][x] = '.';\n  mp[y+1][x+1] = '.';\n}\n\nvoid initQD(priority_queue<PP,vector<PP>, greater<PP> >&Q,int D[4][N][N]){\n  int x=-1,y=-1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j] == 'X' && x == -1) y = i, x = j;\n\n  if(y == 0 && x == 0){\n    D[0][0][0] = 0;\n    Q.push(PP(P(0,0),P(0,0)));\n    return;\n  }\n\n  mp[y][x] = '*';\n  mp[y][x+1] = '*';\n  mp[y+1][x] = '*';\n  mp[y+1][x+1] = '*';\n  \n  vector<int> dotx,doty;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == '.') dotx.push_back(j),doty.push_back(i);\n    \n  int dxi[] = {0,2,0,-1};\n  int dyi[] = {-1,0,2,0};\n  for(int i=0;i<4;i++){\n    int sx0 = x + dxi[i] + 0;\n    int sy0 = y + dyi[i] + 0;\n    int sx1 = x + dxi[i] + (i+1)%2;\n    int sy1 = y + dyi[i] + i%2;\n    if(!in(sy0,sx0) || !in(sy1,sx1))continue;\n    int a = bfs(sy0,sx0,doty[0],dotx[0]) + bfs(sy1,sx1,doty[1],dotx[1]);\n    int b = bfs(sy0,sx0,doty[1],dotx[1]) + bfs(sy1,sx1,doty[0],dotx[0]);\n    int cost = min(a,b);\n    Q.push(PP(P(cost,i),P(y,x)));\n    D[i][y][x] = cost;\n  }\n  mp[y][x] = '.';\n  mp[y][x+1] = '.';\n  mp[y+1][x] = '.';\n  mp[y+1][x+1] = '.';\n}\n\nint dijkstra(){\n  int D[4][N][N];\n  \n  for(int i=0;i<4;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++) D[i][j][k] = INF;\n  priority_queue<PP,vector<PP>, greater<PP> > Q;\n  initQD(Q,D);\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int dir = t.first.second;\n    int y = t.second.first;\n    int x = t.second.second;\n    //cout<<\"poped\"<<cost<<\" \"<<dir<<\" \"<<y<<\" \"<<x<<endl;\n    if(y == 0 && x == 0) return cost;\n    if(D[dir][y][x] < cost) continue;\n    buildG(y,x);\n    int dx[] = {0,1,0,-1};\n    int dy[] = {-1,0,1,0};\n    for(int i=0;i<4;i++){\n      int ndir = (dir + i)%4;\n      int nx = x + dx[(ndir+2)%4];\n      int ny = y + dy[(ndir+2)%4];\n      if(!in(ny,nx)) continue;\n      int ncost = cost + G[y][x][dir][(ndir+2)%4] + 1;\n      if(D[ndir][ny][nx]<=ncost) continue;\n      Q.push(PP(P(ncost,ndir),P(ny,nx)));\n      D[ndir][ny][nx] = ncost;\n    }    \n  }\n  return -1;\n}\n\n\nsigned main(){\n  while(1){\n    cin>>h>>w;\n    if(!h && !w) break;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    memset(G,-1,sizeof(G));\n    cout<<dijkstra()<<endl;\n  }\n\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#define maxn 800000\n#define maxm 2000000\nusing namespace std;\n\nstruct S{\nint x1,y1,x2,y2,x,y,step;\n}t,que[maxm];\n\nchar mp[50][51];\nbool vis[maxm];\nint tot,nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}},head[maxn],nxtval[maxm];\n\nlong long val[maxm];\n\nint getval()\n{\n    long long res;\n//printf(\"%d,%d,%d,%d,%d,%d\\n\",t.x1,t.x2,t.y1,t.y2,t.x,t.y);\n    if(t.x1>t.x2)\n    {\n        res=(long long)t.x2*50+t.y2;\n\n        res=res*50+t.x1;\n        res=res*50+t.y1;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n    else if(t.x1==t.x2 && t.y1>t.y2)\n    {\n        res=(long long)t.x2*50+t.y2;\n\n        res=res*50+t.x1;\n        res=res*50+t.y1;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n    else\n    {\n        res=(long long)t.x1*50+t.y1;\n\n        res=res*50+t.x2;\n        res=res*50+t.y2;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n\n    int temp=int(res%maxn);\n\n    for(int e=head[temp];e!=-1;e=nxtval[e])\n    {//printf(\"e=%d,temp=%d,res=%lld\\n\",e,temp,res);\n        if(val[e]==res) return e;\n    }\n\n    val[tot]=res;\n    nxtval[tot]=head[temp];\n    head[temp]=tot;\n\n    return tot++;\n}\n\nbool check()\n{\n    if(t.x1==t.x2 && t.y1==t.y2) return 0;\n\n    if(mp[t.x1][t.y1]=='*') return 0;\n    if(mp[t.x2][t.y2]=='*') return 0;\n\n    if(t.x1==t.x && t.y1==t.y) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y) return 0;\n    if(t.x1==t.x && t.y1==t.y+1) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y+1) return 0;\n\n    if(t.x2==t.x && t.y2==t.y) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y) return 0;\n    if(t.x2==t.x && t.y2==t.y+1) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y+1) return 0;\n\n    return 1;\n}\n\nbool px()\n{\n    if(t.x1>t.x2)\n    {\n        swap(t.x1,t.x2);\n        swap(t.y1,t.y2);\n    }\n    else if(t.x1==t.x2 && t.y1>t.y2)\n    {\n        swap(t.x1,t.x2);\n        swap(t.y1,t.y2);\n    }\n}\n\nint main()\n{\n    int n,m,i,j,cnt,top,bottom,key;\n    bool flag;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<n;i++) scanf(\"%s\",mp[i]);\n\n        cnt=0;\n        flag=0;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++)\n        {\n            if(mp[i][j]=='.')\n            {\n                if(!cnt) t.x1=i,t.y1=j,cnt++;\n                else t.x2=i,t.y2=j;\n            }\n            else if(mp[i][j]=='X' && !flag)\n            {\n                t.x=i,t.y=j;\n\n                flag=1;\n            }\n        }\n\n        for(i=0;i<maxn;i++) head[i]=-1;\n\n        tot=1;\n\n        memset(vis,0,sizeof vis);\n\n        vis[getval()]=1;\n\n        t.step=0;\n\n        top=0;\n        bottom=1;\n\n        que[0]=t;\n\n        while(top<bottom)\n        {\n            t=que[top];\n//puts(\"sss\");\n            if(!t.x && !t.y)\n            {\n                printf(\"%d\\n\",t.step);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t.x1+=nxt[i][0];\n                t.y1+=nxt[i][1];\n\n                if(t.x1>=0 && t.x1<n && t.y1>=0 && t.y1<m && check())\n                {\n                    key=getval();\n\n                    if(vis[key])\n                    {\n                        t.x1-=nxt[i][0];\n                        t.y1-=nxt[i][1];\n                        continue;\n                    }\n\n                    vis[key]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x1-=nxt[i][0];\n                t.y1-=nxt[i][1];\n            }\n\n            for(i=0;i<4;i++)\n            {\n                t.x2+=nxt[i][0];\n                t.y2+=nxt[i][1];\n\n                if(t.x2>=0 && t.x2<n && t.y2>=0 && t.y2<m && check())\n                {\n                    key=getval();\n\n                    if(vis[key])\n                    {\n                        t.x2-=nxt[i][0];\n                        t.y2-=nxt[i][1];\n                        continue;\n                    }\n\n                    vis[key]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x2-=nxt[i][0];\n                t.y2-=nxt[i][1];\n            }\n\n\n            px();\n\n            if(t.x1==t.x-1 && t.y1==t.y && t.x2==t.x-1 && t.y2==t.y+1)\n            {\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x+2 && t.y1==t.y && t.x2==t.x+2 && t.y2==t.y+1)\n            {\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y-1 && t.x2==t.x+1 && t.y2==t.y-1)\n            {\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y+2 && t.x2==t.x+1 && t.y2==t.y+2)\n            {\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step--;\n            }\n        }\n\n        if(top==bottom) printf(\"-1\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e5\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n\t2,2,\n\t0,1,\n\t-1,-1,\n\t0,1\n};\nint ddy[4][2]={\n\t0,1,\n\t2,2,\n\t0,1,\n\t-1,-1\n};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tint cost,pdir;\n\tP k;\n\tdata(){}\n\tdata(P kk,int cc,int pp){\n\t\tk=kk;\n\t\tcost=cc;\n\t\tpdir=pp;\n\t}\n\tbool operator<(const data &d1)const{\n\t\tif(cost!=d1.cost)return cost>d1.cost;\n\t\tif(k!=d1.k)return k>d1.k;\n\t\treturn pdir>d1.pdir;\n\t}\n};\n\nstruct data2{\n\tP k,o[2];\n\tdata2(){}\n\tdata2(P kk,P o1,P o2){\n\t\tk=kk;\n\t\to[0]=o1;\n\t\to[1]=o2;\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\nbool same(data2 a,data2 b){\n\tif(!same(a.k,b.k))return false;\n\tif(!same(a.o[0],b.o[0]))return false;\n\tif(!same(a.o[1],b.o[1]))return false;\n\treturn true;\n}\n\nint distp[51][51];\nint move_pawn(P f,P t){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tdistp[i][j]=INF;\n\t\t}\n\t}\n\tqueue<P> que;\n\tque.push(f);\n\tdistp[f.first][f.second]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tif(q==t)return distp[q.first][q.second];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nq=q+P(dy[i],dx[i]);\n\t\t\tif(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n\t\t\t\tif(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n\t\t\t\t\tdistp[nq.first][nq.second]=distp[q.first][q.second]+1;\n\t\t\t\t\tque.push(P(nq));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\ndata first_moveking(P k,P o1,P o2,int dir){\n\tdata res;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\ndata moveking(data q,int dir){\n\tdata res;\n\tP k=q.k;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tP o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n\tP o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n\t//printf(\"y%d x%d y%d x%d dir%d\\n\",o1.second,o1.first,o2.second,o2.first,dir);\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\t//printf(\"ox%d oy%d ox%d oy%d\\n\",k.second+ddx[dir][0],k.first+ddy[dir][0],k.second+ddx[dir][1],k.first+ddy[dir][1]);\n\t//printf(\"c%d c%d %d %d\\n\",cost1,cost2,k.second+dx[dir],k.first+dy[dir]);\n\tres.cost=min(cost1,cost2)+1+q.cost;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n\tpriority_queue<data> que;\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n\t\t\tdata si=first_moveking(s,o1,o2,i);\n\t\t\tif(si.cost<INF){\n\t\t\t\tque.push(si);\n\t\t\t\tdist[si.k.first][si.k.second][si.pdir]=si.cost;\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n\t\t//printf(\"%d %d\\n\",q.k.first,q.k.second);\n\t\tif(q.k.first+q.k.second==0)return q.cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n\t\t\t\tdata nq=moveking(q,i);\n\t\t\t\tif(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n\t\t\t\t\tdist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n\t\t\t\t\tque.push(nq);\n\t\t\t\t\t//printf(\"%d %d %d\\n\",nq.cost,nq.k.second,nq.k.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tP k,o[2];\n\t\tk.first=k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tif(k.first==-1){\n\t\t\t\t\t\tk.second=j;\n\t\t\t\t\t\tk.first=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\to[cnt].second=j;\n\t\t\t\t\to[cnt++].first=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(k.first+k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <array>\n\nusing namespace std;\n\nenum CellType {\n    CELL_EMPTY,\n    CELL_PAWN,\n    CELL_BLOCK,\n    CELL_KING\n};\ntypedef pair<int,int> Point;\ntypedef unsigned int State;\ntypedef long long LL;\n\nconst LL INF = 50LL*50*2*50*50*100;\nconst Point SPACE_POS[4][2] = {\n    {Point(0, 2), Point(1, 2)},\n    {Point(-1, 1), Point(-1, 0)},\n    {Point(0, -1), Point(1, -1)},\n    {Point(2, 0), Point(2, 1)}\n};\nconst Point DELTA[] = {\n    Point(0, 1),\n    Point(-1, 0),\n    Point(0, -1),\n    Point(1, 0)\n};\nconst int MOVED[] = {\n    2, 3, 0, 1\n};\n\nint H, W;\narray<array<CellType,55>,55> field;\n\nostream& operator <<(ostream &os, const Point &p) {\n    return os << \"(\" << p.first << \",\" << p.second << \")\";\n}\nPoint operator +(const Point &a, const Point &b) {\n    return Point(a.first+b.first, a.second+b.second);\n}\n\nState encode(const Point &king, int dir) {\n    return ((king.first*55)+king.second)*55 + dir;\n}\n\n// Return: (king position, dir)\npair<Point,int> decode(State s) {\n    unsigned int dir = s % 55;\n    s /= 55;\n    Point king(s/55, s%55);\n    for(int i = 0; i <= H+1; ++i) {\n        for(int j = 0; j <= W+1; ++j) {\n            if(field[i][j] != CELL_BLOCK) field[i][j] = CELL_PAWN;\n        }\n    }\n    field[king.first][king.second] = CELL_KING;\n    field[king.first+1][king.second] = CELL_KING;\n    field[king.first][king.second+1] = CELL_KING;\n    field[king.first+1][king.second+1] = CELL_KING;\n    /*\n    for(int r = 0; r <= H+1; ++r) {\n        for(int c = 0; c <= W+1; ++c) {\n            cout << field[r][c];\n        }\n        cout << endl;\n    }\n    cout << dir << endl;\n    */\n    return make_pair(king, dir);\n}\n\narray<array<bool,55>,55> bfs_visited;\nLL bfs(Point start, Point goal) {\n    for(int i = 0; i < 55; ++i) {\n        for(int j = 0; j < 55; ++j) {\n            bfs_visited[i][j] = false;\n        }\n    }\n    static vector<Point> q[2];\n    q[0].clear();\n    q[0].push_back(start);\n    bfs_visited[start.first][start.second] = true;\n    //cout << start << \",\" << goal << endl;\n    for(int turn = 0; q[0].size() > 0; ++turn) {\n        q[1].clear();\n        for(const Point &p : q[0]) {\n            //cout << p << endl;\n            if(p == goal) return turn;\n            for(int i = 0; i < 4; ++i) {\n                const Point np = p + DELTA[i];\n                if(field[np.first][np.second] != CELL_PAWN) continue;\n                if(bfs_visited[np.first][np.second]) continue;\n                bfs_visited[np.first][np.second] = true;\n                q[1].push_back(np);\n            }\n        }\n        q[0].swap(q[1]);\n    }\n    return INF;\n}\n\nvector<pair<LL,State>> load() {\n    Point king;\n    bool king_found = false;\n    for(int i = 0; i < 55; ++i) {\n        for(int j = 0; j < 55; ++j) {\n            field[i][j] = CELL_BLOCK;\n        }\n    }\n    vector<Point> empty_cells;\n    for(int i = 1; i <= H; ++i) {\n        string str;\n        cin >> str;\n        for(int j = 1; j <= W; ++j) {\n            if(str[j-1] == 'o') {\n                field[i][j] = CELL_PAWN;\n            } else if(str[j-1] == '.') {\n                field[i][j] = CELL_PAWN;\n                empty_cells.push_back(Point(i, j));\n            } else if(str[j-1] == '*') {\n                field[i][j] = CELL_BLOCK;\n            } else if(str[j-1] == 'X' && !king_found) {\n                king_found = true;\n                king = Point(i, j);\n                field[i][j] = CELL_KING;\n                field[i+1][j] = CELL_KING;\n                field[i][j+1] = CELL_KING;\n                field[i+1][j+1] = CELL_KING;\n            }\n        }\n    }\n    vector<pair<LL,State>> res;\n    if(king == Point(1, 1)) {\n        res.push_back(make_pair(1, 0));\n        return res;\n    }\n    for(int dir = 0; dir < 4; ++dir) {\n        const Point p1 = king + SPACE_POS[dir][0];\n        const Point p2 = king + SPACE_POS[dir][1];\n        if(field[p1.first][p1.second] == CELL_BLOCK) continue;\n        if(field[p2.first][p2.second] == CELL_BLOCK) continue;\n        //cout << p1 << \" \" << p2 << endl;\n        LL fastest = min(bfs(p1, empty_cells[0]) + bfs(p2, empty_cells[1]), bfs(p1, empty_cells[1]) + bfs(p2, empty_cells[0]));\n        if(fastest >= INF) continue;\n        res.push_back(make_pair(-fastest, encode(king, dir)));\n    }\n    return res;\n}\n\narray<LL,((((55*55)+55)*55)+4)> memo;\nbool solve() {\n    cin >> H >> W;\n    if(!H && !W) return false;\n    vector<pair<LL,State>> initial = load();\n    fill(memo.begin(), memo.end(), INF);\n\n    priority_queue<pair<LL,State>> q;\n    for(const auto &s : initial) {\n        if(s.first > 0) {\n            cout << 0 << endl;\n            return true;\n        }\n        q.push(s);\n        memo[s.second] = -s.first;\n    }\n    while(!q.empty()) {\n        LL cost = -q.top().first;\n        State cur = q.top().second;\n        q.pop();\n        if(cost > memo[cur]) continue;\n        //cout << cur << endl;\n        const pair<Point,int> state = decode(cur);\n        const int dir = state.second;\n        const Point p1 = state.first + SPACE_POS[dir][0];\n        const Point p2 = state.first + SPACE_POS[dir][1];\n        //cout << cost << endl;\n        //cout << state.first << ' ' << p1 << ' ' << p2 << endl;\n        if(state.first == Point(1, 1)) {\n            cout << cost << endl;\n            return true;\n        }\n\n        // to-dir\n        for(int i = 0; i < 4; ++i) {\n            const Point np1 = state.first + SPACE_POS[i][0];\n            const Point np2 = state.first + SPACE_POS[i][1];\n            if(field[np1.first][np1.second] == CELL_BLOCK) continue;\n            if(field[np2.first][np2.second] == CELL_BLOCK) continue;\n            LL fastest = min(bfs(np1, p1) + bfs(np2, p2), bfs(np1, p2) + bfs(np2, p1));\n            if(fastest >= INF) continue;\n            const LL nc = cost + fastest + 1;\n            const State ns = encode(state.first + DELTA[i], MOVED[i]);\n            if(memo[ns] <= nc) continue;\n            memo[ns] = nc;\n            q.push(make_pair(-nc, ns));\n            //cout << ns << state.first+DELTA[i] << MOVED[i] << endl;\n        }\n    }\n    cout << -1 << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nbool in(int h,int w,int i,int j){return 0<=i && i<h && 0<=j && j<w;}\n\nint calc(vs grid,pii king,pii a,pii b)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\tvvi dist(h,vi(w,INF));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(a.first,a.second,0);\n\twhile(q.size()){\n\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\tif(!in(h,w,i,j) || grid[i][j]=='*' || dist[i][j]!=INF) continue;\n\t\tdist[i][j]=d;\n\t\tif(mp(i,j)==b) return d;\n\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t}\n\treturn dist[b.first][b.second];\n}\n\nint calc(vs grid,pii king,pii p1,pii p2,pii q1,pii q2)\n{\n\treturn min(calc(grid,king,p1,q1)+calc(grid,king,p2,q2),\n\t\t\t\t\t\t calc(grid,king,p1,q2)+calc(grid,king,p2,q1));\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tif(grid[0][0]=='X'){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);});\n\t\t{\n\t\t\tpii king(-1,-1),open1(-1,-1),open2(-1,-1);\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X'){\n\t\t\t\t\tif(king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='.')\n\t\t\t\t\t(open1==mp(-1,-1)?open1:open2)=mp(i,j);\n\t\t\t\telse if(grid[i][j]=='o')\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\tint ki=king.first,kj=king.second;\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,calc(grid,king,open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,calc(grid,king,open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,calc(grid,king,open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,calc(grid,king,open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\t\n\t\tvvvi dist(h,vvi(w,vi(4,INF)));\n\t\twhile(pq.size()){\n\t\t\tint ki,kj,dir,step; tie(ki,kj,dir,step)=pq.top(); pq.pop();\n\t\t\tif(!in(h,w,ki,kj) || dist[ki][kj][dir]!=INF) continue;\n\t\t\tdist[ki][kj][dir]=step;\n\t\t\tif(step>=INF) break;\n\t\t\t\n\t\t\tpii open1,open2;\n\t\t\tif(dir==0) open1=mp(ki-1,kj),open2=mp(ki-1,kj+1);\n\t\t\tif(dir==1) open1=mp(ki+2,kj),open2=mp(ki+2,kj+1);\n\t\t\tif(dir==2) open1=mp(ki,kj-1),open2=mp(ki+1,kj-1);\n\t\t\tif(dir==3) open1=mp(ki,kj+2),open2=mp(ki+1,kj+2);\n\t\t\t\n\t\t\tpq.emplace(ki+\"\\xff\\x1\\0\\0\"[dir],kj+\"\\0\\0\\xff\\x1\"[dir],dir^1,step+1);\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,step+calc(grid,mp(ki,kj),open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,step+calc(grid,mp(ki,kj),open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\tint res=*min_element(all(dist[0][0]));\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n//#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\n//using namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=110000007;//減らしてる\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n/*\n 0\n3 1\n 2\n*/\n//Sliding Block Puzzle\nint h,w;\narray<int,4>tomove(const array<array<char,64>,52>&mat,int ay,int ax,int by,int bx,int ky,int kx){\n\t//そっち方向に動くための距離を計算\n\tint i,j;\n\tint dist[52][52];\n\tfor(i=0;i<=h+1;i++){\n\t\tfor(j=0;j<=w+1;j++){\n\t\t\tdist[i][j]=mod;\n\t\t}\n\t}\n\t//axを計算\n\tqueue<pair<int,int>>que;\n\tdist[ay][ax]=0;que.push(mp(ay,ax));\n\twhile(que.size()){\n\t\tint y,x;tie(y,x)=que.front();que.pop();\n\t\tif(y<=0||x<=0||y>h||x>w){continue;}\n\t\tint t=dist[y][x];\n\t\tif(dist[y-1][x]==mod&&mat[y-1][x]=='o'){dist[y-1][x]=t+1;que.push(mp(y-1,x));}\n\t\tif(dist[y+1][x]==mod&&mat[y+1][x]=='o'){dist[y+1][x]=t+1;que.push(mp(y+1,x));}\n\t\tif(dist[y][x-1]==mod&&mat[y][x-1]=='o'){dist[y][x-1]=t+1;que.push(mp(y,x-1));}\n\t\tif(dist[y][x+1]==mod&&mat[y][x+1]=='o'){dist[y][x+1]=t+1;que.push(mp(y,x+1));}\n\t}\n\tint aaa[4][4];\n\t\n\tfor(i=0;i<4;i++){\n\t\tfor(j=0;j<4;j++){aaa[i][j]=dist[i+ky-1][j+kx-1];}\n\t}\n\n\tfor(i=0;i<=h+1;i++){\n\t\tfor(j=0;j<=w+1;j++){\n\t\t\tdist[i][j]=mod;\n\t\t}\n\t}\n\t//axを計算\n\t\n\tdist[by][bx]=0;que.push(mp(by,bx));\n\twhile(que.size()){\n\t\tint y,x;tie(y,x)=que.front();que.pop();\n\t\tif(y<=0||x<=0||y>h||x>w){continue;}\n\t\tint t=dist[y][x];\n\t\tif(dist[y-1][x]==mod&&mat[y-1][x]=='o'){dist[y-1][x]=t+1;que.push(mp(y-1,x));}\n\t\tif(dist[y+1][x]==mod&&mat[y+1][x]=='o'){dist[y+1][x]=t+1;que.push(mp(y+1,x));}\n\t\tif(dist[y][x-1]==mod&&mat[y][x-1]=='o'){dist[y][x-1]=t+1;que.push(mp(y,x-1));}\n\t\tif(dist[y][x+1]==mod&&mat[y][x+1]=='o'){dist[y][x+1]=t+1;que.push(mp(y,x+1));}\n\t}\n\tarray<int,4>ans;\n\t\n\tans[0]=min(aaa[0][1]+dist[ky-1][kx+1],aaa[0][2]+dist[ky-1][kx]);\n\tans[2]=min(aaa[3][1]+dist[ky+2][kx+1],aaa[3][2]+dist[ky+2][kx]);\n\tans[3]=min(aaa[1][0]+dist[ky+1][kx-1],aaa[2][0]+dist[ky][kx-1]);\n\tans[1]=min(aaa[1][3]+dist[ky+1][kx+2],aaa[2][3]+dist[ky][kx+2]);\n\treturn ans;\n}\nbool solve(void){\n\tint i,j;cin>>h>>w;\n\tif(h==0){return false;}\n\tarray<array<char,64>,52> mat;\n\tfor(i=1;i<=h;i++){\n\t\tstring str;\n\t\tcin>>str;\n\t\tfor(j=1;j<=w;j++){mat[i][j]=str[j-1];}\n\t\tmat[i][0]='*';\n\t\tmat[i][w+1]='*';\n\t}\n\tfor(j=0;j<=w+1;j++){mat[0][j]='*';mat[h+1][j]='*';}\n\tint sy,sx;\n\tint steAy=-1,steAx=-1,steBy,steBx;\n\tfor(i=1;i<=h;i++){\n\t\tfor(j=1;j<=w;j++){\n\t\t\tif(mat[i][j]=='X'){sy=i;sx=j;}\n\t\t\tif(mat[i][j]=='.'){\n\t\t\t\tmat[i][j]='o';\n\t\t\t\tif(steAy==-1){steAy=i;steAx=j;}\n\t\t\t\telse{steBy=i;steBx=j;}\n\t\t\t}\n\t\t}\n\t}\n\tsy--;sx--;\n\tif(sy==1&&sx==1){cout<<0<<endl;return true;}\n\t\n\tarray<int,4> staugo;//スタートの動き方の表\n\tstaugo=tomove(mat,steAy,steAx,steBy,steBx,sy,sx);\n\tmat[sy][sx]='o';\n\tmat[sy][sx+1]='o';\n\tmat[sy+1][sx]='o';\n\tmat[sy+1][sx+1]='o';\n\t\n\tarray<array<int,4>,4> ugo[50][50];//動き方の遷移表\n\t\n\tfor(i=1;i<h;i++){\n\t\tfor(j=1;j<w;j++){\n\t\t\tif(mat[i][j]=='*'){continue;}\n\t\t\tif(mat[i][j+1]=='*'){continue;}\n\t\t\tif(mat[i+1][j]=='*'){continue;}\n\t\t\tif(mat[i+1][j+1]=='*'){continue;}\n\t\t\tmat[i][j]='X';\n\t\t\tmat[i][j+1]='X';\n\t\t\tmat[i+1][j]='X';\n\t\t\tmat[i+1][j+1]='X';\n\t\t\tugo[i][j][0]=tomove(mat,i-1,j,i-1,j+1,i,j);\n\t\t\tugo[i][j][1]=tomove(mat,i,j+2,i+1,j+2,i,j);\n\t\t\tugo[i][j][2]=tomove(mat,i+2,j,i+2,j+1,i,j);\n\t\t\tugo[i][j][3]=tomove(mat,i,j-1,i+1,j-1,i,j);\n\t\t\tmat[i][j]='o';\n\t\t\tmat[i][j+1]='o';\n\t\t\tmat[i+1][j]='o';\n\t\t\tmat[i+1][j+1]='o';\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tarray<int,4> dist[52][52];\n\tfor(i=0;i<=h+1;i++){\n\t\tfor(j=0;j<=w+1;j++){\n\t\t\tdist[i][j][0]=mod;\n\t\t\tdist[i][j][1]=mod;\n\t\t\tdist[i][j][2]=mod;\n\t\t\tdist[i][j][3]=mod;\n\t\t}\n\t}\n\tpriority_queue<tuple<int,int,int,int>,vector<tuple<int,int,int,int>>,greater<tuple<int,int,int,int>>>que;\n\tdist[sy][sx]=staugo;\n\tque.push(mt(staugo[0],sy,sx,0));\n\tque.push(mt(staugo[1],sy,sx,1));\n\tque.push(mt(staugo[2],sy,sx,2));\n\tque.push(mt(staugo[3],sy,sx,3));\n\tint dy[4]={-1,0,1,0};\n\tint dx[4]={0,1,0,-1};\n\twhile(que.size()){\n\t\tint t,y,x,d;tie(t,y,x,d)=que.top();que.pop();\n\t\tif(t>dist[y][x][d]){continue;}\n\t\tif(mineq(dist[y+dy[d]][x+dx[d]][d^2],t+1)){que.push(mt(t+1,y+dy[d],x+dx[d],d^2));}\n\t\tif(mineq(dist[y][x][0],t+ugo[y][x][d][0])){que.push(mt(dist[y][x][0],y,x,0));}\n\t\tif(mineq(dist[y][x][1],t+ugo[y][x][d][1])){que.push(mt(dist[y][x][1],y,x,1));}\n\t\tif(mineq(dist[y][x][2],t+ugo[y][x][d][2])){que.push(mt(dist[y][x][2],y,x,2));}\n\t\tif(mineq(dist[y][x][3],t+ugo[y][x][d][3])){que.push(mt(dist[y][x][3],y,x,3));}\n\t}\n\t\n\t\n\tint ans=mod;\n\tmineq(ans,dist[1][1][0]);\n\tmineq(ans,dist[1][1][1]);\n\tmineq(ans,dist[1][1][2]);\n\tmineq(ans,dist[1][1][3]);\n\tif(ans==mod){ans=-1;}\n\tcout<<ans<<endl;\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n/*\n4 7\nooo*XXo\nooooXXo\noooo..o\nooooooo\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e7\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n    2,2,\n    0,1,\n    -1,-1,\n    0,1\n};\nint ddy[4][2]={\n    0,1,\n    2,2,\n    0,1,\n    -1,-1\n};\nP operator +(P p1,P p2){\n    return P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n    return P(p1.first-p2.first,p1.second-p2.second);\n}\n \nint h,w;\nint fie[51][51];\nstruct data{\n    int cost,pdir;\n    P k;\n    data(){}\n    data(P kk,int cc,int pp){\n        k=kk;\n        cost=cc;\n        pdir=pp;\n    }\n    bool operator<(const data &d1)const{\n        if(cost!=d1.cost)return cost>d1.cost;\n        if(k!=d1.k)return k>d1.k;\n        return pdir>d1.pdir;\n    }\n};\n \nstruct data2{\n    P k,o[2];\n    data2(){}\n    data2(P kk,P o1,P o2){\n        k=kk;\n        o[0]=o1;\n        o[1]=o2;\n    }\n};\n \nbool cross(P a,P b){\n    if(a==b)return true;\n    if(a==(b+P(1,0)))return true;\n    if(a==(b+P(0,1)))return true;\n    if(a==(b+P(1,1)))return true;\n    return false;\n}\n \nbool canmove(P a){\n    if(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n    return false;\n}\n \nbool same(P a,P b){\n    return a.first==b.first && a.second==b.second;\n}\n \nbool same(data2 a,data2 b){\n    if(!same(a.k,b.k))return false;\n    if(!same(a.o[0],b.o[0]))return false;\n    if(!same(a.o[1],b.o[1]))return false;\n    return true;\n}\n \nint distp[51][51];\nint move_pawn(P f,P t){\n    for(int i=0;i<50;i++){\n        for(int j=0;j<50;j++){\n            distp[i][j]=INF;\n        }\n    }\n    queue<P> que;\n    que.push(f);\n    distp[f.first][f.second]=0;\n    while(que.size()){\n        P q=que.front();\n        que.pop();\n        if(q==t)return distp[q.first][q.second];\n        for(int i=0;i<4;i++){\n            P nq=q+P(dy[i],dx[i]);\n            if(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n                if(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n                    distp[nq.first][nq.second]=distp[q.first][q.second]+1;\n                    que.push(P(nq));\n                }\n            }\n        }\n    }\n    return INF;\n}\n \ndata first_moveking(P k,P o1,P o2,int dir){\n    data res;\n    fie[k.first][k.second]=-1;\n    fie[k.first+1][k.second]=-1;\n    fie[k.first][k.second+1]=-1;\n    fie[k.first+1][k.second+1]=-1;\n    int cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n    int cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n    res.cost=min(cost1,cost2)+1;\n    fie[k.first][k.second]=0;\n    fie[k.first+1][k.second]=0;\n    fie[k.first][k.second+1]=0;\n    fie[k.first+1][k.second+1]=0;\n    res.pdir=dir;\n    res.k=k+P(dy[dir],dx[dir]);\n    return res;\n}\n \ndata moveking(data q,int dir){\n    data res;\n    P k=q.k;\n    fie[k.first][k.second]=-1;\n    fie[k.first+1][k.second]=-1;\n    fie[k.first][k.second+1]=-1;\n    fie[k.first+1][k.second+1]=-1;\n    P o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n    P o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n    int cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n    int cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n    res.cost=min(cost1,cost2)+1+q.cost;\n    fie[k.first][k.second]=0;\n    fie[k.first+1][k.second]=0;\n    fie[k.first][k.second+1]=0;\n    fie[k.first+1][k.second+1]=0;\n    res.pdir=dir;\n    res.k=k+P(dy[dir],dx[dir]);\n    return res;\n}\n \nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n    priority_queue<data> que;\n    for(int i=0;i<50;i++){\n        for(int j=0;j<50;j++){\n            for(int k=0;k<4;k++){\n                dist[i][j][k]=INF;\n            }\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n            data si=first_moveking(s,o1,o2,i);\n            if(si.cost<INF){\n                que.push(si);\n                dist[si.k.first][si.k.second][si.pdir]=si.cost;\n            }\n        }\n    }\n    while(que.size()){\n        data q=que.top();\n        que.pop();\n        if(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n        if(q.k.first+q.k.second==0)return q.cost;\n        for(int i=0;i<4;i++){\n            if(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n                data nq=moveking(q,i);\n                if(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n                    dist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n                    que.push(nq);\n                }\n            }\n        }\n    }\n    return -1;\n}\n \nint main(void){\n    while(1){\n        scanf(\"%d %d\",&h,&w);\n        if(h+w==0)break;\n        P k,o[2];\n        k.first=k.second=-1;\n        int cnt=0;\n        memset(fie,0,sizeof(fie));\n        for(int i=0;i<h;i++){\n            string str;\n            cin >> str;\n            for(int j=0;j<w;j++){\n                if(str[j]=='*')fie[i][j]=-1;\n                if(str[j]=='X'){\n                    if(k.first==-1){\n                        k.second=j;\n                        k.first=i;\n                    }\n                }\n                if(str[j]=='.'){\n                    o[cnt].second=j;\n                    o[cnt++].first=i;\n                }\n            }\n        }\n        if(k.first+k.second==0)printf(\"0\\n\");\n        else if(cnt<2)printf(\"-1\\n\");\n        else printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\tusing first_argument_type=decltype(helper(&Functor::operator()));\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nbool in(int h,int w,int i,int j){return 0<=i && i<h && 0<=j && j<w;}\nbool in(int h,int w,pii p){return in(h,w,p.first,p.second);}\n\nint calc(vs grid,pii king,pii a,pii b)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\tvvi dist(h,vi(w,INF));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(a.first,a.second,0);\n\twhile(q.size()){\n\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\tif(!in(h,w,i,j) || grid[i][j]=='*' || dist[i][j]!=INF) continue;\n\t\tdist[i][j]=d;\n\t\trep(k,4)\n\t\t\tq.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t}\n\treturn dist[b.first][b.second];\n}\n\nint calc(vs grid,pii king,pii p1,pii p2,pii q1,pii q2)\n{\n\treturn min(calc(grid,king,p1,q1)+calc(grid,king,p2,q2),\n\t\t\t\t\t\t calc(grid,king,p1,q2)+calc(grid,king,p2,q1));\n\t//int h=grid.size(),w=grid[0].size();\n\t//rep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\t//vvvvi dist(h,vvvi(w,vvi(h,vi(w,INF))));\n\t//queue<tuple<int,int,int,int,int>> q;\n\t//q.emplace(p1.first,p1.second,p2.first,p2.second,0);\n\t//while(q.size()){\n\t//\tint i1,j1,i2,j2,d; tie(i1,j1,i2,j2,d)=q.front(); q.pop();\n\t//\tif(!in(h,w,i1,j1) || !in(h,w,i2,j2) || grid[i1][j1]=='*' || grid[i2][j2]=='*'\n\t//\t|| (i1==i2 && j1==j2) || dist[i1][j1][i2][j2]!=INF) continue;\n\t//\tdist[i1][j1][i2][j2]=dist[i2][j2][i1][j1]=d;\n\t//\trep(k,4){\n\t//\t\tq.emplace(i1+\"\\xff\\x1\\0\\0\"[k],j1+\"\\0\\0\\xff\\x1\"[k],i2,j2,d+1);\n\t//\t\tq.emplace(i1,j1,i2+\"\\xff\\x1\\0\\0\"[k],j2+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t//\t}\n\t//}\n\t//return dist[q1.first][q1.second][q2.first][q2.second];\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t//dump(mp(h,w));\n\t\t//rep(i,h) cout<<grid[i]<<endl;\n\t\t\n\t\tif(grid[0][0]=='X'){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);});\n\t\t{\n\t\t\tpii king(-1,-1),open1(-1,-1),open2(-1,-1);\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X'){\n\t\t\t\t\tif(king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='.')\n\t\t\t\t\t(open1==mp(-1,-1)?open1:open2)=mp(i,j);\n\t\t\t\telse if(grid[i][j]=='o')\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\tint ki=king.first,kj=king.second;\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,calc(grid,king,open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,calc(grid,king,open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,calc(grid,king,open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,calc(grid,king,open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\t\n\t\tvvvi dist(h,vvi(w,vi(4,INF)));\n\t\twhile(pq.size()){\n\t\t\t//if(rand()%1000==0) printf(\"> %d\\n\",pq.size());\n\t\t\tint ki,kj,dir,step; tie(ki,kj,dir,step)=pq.top(); pq.pop();\n\t\t\tif(!in(h,w,ki,kj) || dist[ki][kj][dir]!=INF) continue;\n\t\t\tdist[ki][kj][dir]=step;\n\t\t\tif(step>=INF) break;\n\t\t\t\n\t\t\tpii open1,open2;\n\t\t\tif(dir==0) open1=mp(ki-1,kj),open2=mp(ki-1,kj+1);\n\t\t\tif(dir==1) open1=mp(ki+2,kj),open2=mp(ki+2,kj+1);\n\t\t\tif(dir==2) open1=mp(ki,kj-1),open2=mp(ki+1,kj-1);\n\t\t\tif(dir==3) open1=mp(ki,kj+2),open2=mp(ki+1,kj+2);\n\t\t\t\n\t\t\tpq.emplace(ki+\"\\xff\\x1\\0\\0\"[dir],kj+\"\\0\\0\\xff\\x1\"[dir],dir^1,step+1);\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,step+calc(grid,mp(ki,kj),open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,step+calc(grid,mp(ki,kj),open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\tint res=*min_element(all(dist[0][0]));\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<ll,int>;\n\nstruct edge{\n    int to;\n    ll cost;\n};\n\nconst int dx[4]={1,0,-1,0}, dy[4]={0,-1,0,1};\nconst int sy[4][2] = {{0,1}, {-1,-1}, {0,1}, {2,2}};\nconst int sx[4][2] = {{2,2}, {0,1}, {-1,-1}, {0,1}};\n\nconst int N = 10010;\nconst ll INF = LLONG_MAX/3;\n\nvector<edge> G[N];\nll d[N];\n\nint main(){\n    int H,W;\n    while(cin >>H >>W,H){\n        vector<string> s(H);\n        rep(i,H) cin >>s[i];\n\n        auto ID = [&](int y, int x, int dir){\n            return 4*(W*y+x) + dir;\n        };\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<H && 0<=x && x<W;\n        };\n\n        auto king_can_place = [&](int ly, int lx){\n            bool ret = false;\n            if(0<=ly && ly<H-1 && 0<=lx && lx<W-1){\n                ret = true;\n                rep(i,2)rep(j,2) ret &= (s[ly+i][lx+j]!='*');\n            }\n            return ret;\n        };\n\n        rep(i,N) G[i].clear();\n        int src = 10000, dst = src+1;\n\n        // make graph\n        rep(ly,H-1)rep(lx,W-1){\n            if(!king_can_place(ly,lx)) continue;\n\n            vector<string> f(s);\n            rep(i,H)rep(j,W)if(f[i][j]!='*') f[i][j] = '.';\n            rep(i,2)rep(j,2) f[ly+i][lx+j] = 'X';\n\n            rep(dir,4){\n                pi br[2];\n                bool ok = true;\n                rep(i,2){\n                    int yy = ly+sy[dir][i], xx = lx+sx[dir][i];\n                    if(!IN(yy,xx) || f[yy][xx]!='.') ok = false;\n                    br[i] = {yy,xx};\n                }\n                if(!ok) continue;\n\n                int nx = lx+dx[dir], ny = ly+dy[dir];\n\n                if(king_can_place(ny,nx)){\n                    int u = ID(ly,lx,dir), v = ID(ny,nx,dir^2);\n                    G[u].pb({v,1});\n                    G[v].pb({u,1});\n                }\n\n                vector<vector<ll>> dist[2];\n                rep(i,2){\n                    vector<vector<ll>> td(H,vector<ll>(W,INF));\n                    queue<pi> que;\n\n                    td[br[i].fi][br[i].se] = 0;\n                    que.push(br[i]);\n                    while(!que.empty()){\n                        pi pos = que.front();\n                        que.pop();\n                        rep(dd,4){\n                            int yy = pos.fi+dy[dd], xx = pos.se+dx[dd];\n                            if(IN(yy,xx) && f[yy][xx]=='.' && td[yy][xx] > td[pos.fi][pos.se]+1){\n                                td[yy][xx] = td[pos.fi][pos.se]+1;\n                                que.push({yy,xx});\n                            }\n                        }\n                    }\n\n                    dist[i] = td;\n                }\n\n\n                rep(ndir,4)if(dir != ndir){\n                    pi nbr[2];\n                    bool nok = true;\n                    rep(i,2){\n                        int yy = ly+sy[ndir][i], xx = lx+sx[ndir][i];\n                        if(!IN(yy,xx) || f[yy][xx]!='.') nok = false;\n                        nbr[i] = {yy,xx};\n                    }\n                    if(!nok) continue;\n\n                    ll COST = INF;\n                    rep(i,2) COST = min(COST, dist[i][nbr[0].fi][nbr[0].se]+dist[!i][nbr[1].fi][nbr[1].se]);\n                    if(COST<INF){\n                        int u = ID(ly,lx,dir), v = ID(ly,lx,ndir);\n                        G[u].pb({v,COST});\n                    }\n                }\n            }\n        }\n\n        // make edge from src\n        vector<pi> start_br;\n        rep(i,H)rep(j,W){\n            if(s[i][j]=='.') start_br.pb({i,j});\n        }\n        assert(start_br.size() == 2);\n\n        pi king;\n        for(int i=H-1; i>=0; --i)for(int j=W-1; j>=0; --j){\n            if(s[i][j]=='X') king = {i,j};\n        }\n        if(king == pi(0,0)) G[src].pb({dst,0});\n\n        vector<string> f(s);\n        rep(i,H)rep(j,W)if(f[i][j]!='*') f[i][j] = '.';\n        rep(i,2)rep(j,2) f[king.fi+i][king.se+j] = 'X';\n\n        vector<vector<ll>> dist[2];\n        rep(i,2){\n            vector<vector<ll>> td(H,vector<ll>(W,INF));\n            queue<pi> que;\n\n            td[start_br[i].fi][start_br[i].se] = 0;\n            que.push(start_br[i]);\n            while(!que.empty()){\n                pi pos = que.front();\n                que.pop();\n                rep(dd,4){\n                    int yy = pos.fi+dy[dd], xx = pos.se+dx[dd];\n                    if(IN(yy,xx) && f[yy][xx]=='.' && td[yy][xx] > td[pos.fi][pos.se]+1){\n                        td[yy][xx] = td[pos.fi][pos.se]+1;\n                        que.push({yy,xx});\n                    }\n                }\n            }\n\n            dist[i] = td;\n        }\n\n        rep(ndir,4){\n            pi nbr[2];\n            bool nok = true;\n            rep(i,2){\n                int yy = king.fi+sy[ndir][i], xx = king.se+sx[ndir][i];\n                if(!IN(yy,xx) || f[yy][xx]!='.') nok = false;\n                nbr[i] = {yy,xx};\n            }\n            if(!nok) continue;\n\n            ll COST = INF;\n            rep(i,2) COST = min(COST, dist[i][nbr[0].fi][nbr[0].se]+dist[!i][nbr[1].fi][nbr[1].se]);\n            if(COST<INF){\n                int v = ID(king.fi,king.se,ndir);\n                // printf(\"src -> %d %lld\\n\",v,COST);\n                G[src].pb({v,COST});\n            }\n        }\n\n        // make edge to dst\n        rep(dir,4){\n            bool ok = true;\n            rep(i,2){\n                int yy = 0+sy[dir][i], xx = 0+sx[dir][i];\n                if(!IN(yy,xx) || s[yy][xx]=='*') ok = false;\n            }\n            if(!ok) continue;\n\n            // printf(\" %d -> dst\\n\",ID(0,0,dir));\n            G[ID(0,0,dir)].pb({dst,0});\n        }\n\n\n        // dijkstra\n        fill(d,d+N,INF);\n        priority_queue<P, vector<P>, greater<P>> pq;\n        d[src] = 0;\n        pq.push({0,src});\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n            int v = now.se;\n            // printf(\" %lld , %d\\n\",d[v],v);\n\n            if(now.fi>d[v]) continue;\n\n            for(const auto &e:G[v]){\n                if(d[e.to] > d[v]+e.cost){\n                    d[e.to] = d[v]+e.cost;\n                    pq.push({d[e.to],e.to});\n                }\n            }\n        }\n\n        ll ans = d[dst];\n        if(ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P> P3;\n\nstring s[55];\nint h, w;\n\nint Ady[4]={-1,0,2,1};\nint Adx[4]={0,2,1,-1};\nint Bdy[4]={-1,1,2,0};\nint Bdx[4]={1,2,0,-1};\n\nint bfs(P st, P g){\n  \n  int d[55][55];\n  queue<P3> q;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) d[i][j]=INF;\n\n  d[st.first][st.second]=0;\n  q.push(P3(0,st));\n\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  \n  while(!q.empty()){\n    \n    P3 t=q.front(); q.pop();\n    \n    int cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(s[ny][nx]=='*') continue;\n      if(d[ny][nx]!=INF) continue;\n      d[ny][nx]=cost+1;\n      q.push(P3(cost+1,P(ny,nx)));\n    }\n    \n  }\n  \n  return d[g.first][g.second];\n}\n\nint min_cost2(P A, P B, P C, P D){\n  \n  int r = bfs(A, B);\n  \n  s[B.first][B.second]='*';\n\n  r+=bfs(C, D);\n\n  s[B.first][B.second]='.';\n  \n  if(r>INF) r=INF;\n  \n  return r;\n}\n\nint min_cost(vector<P> start, P A, P B, P C){\n  \n  int dy[4]={0,0,1,1};\n  int dx[4]={0,1,0,1};\n  \n  P g1=start[0], g2=start[1];\n\n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='*';\n\n  int res=INF;\n  \n  res=min(res, min_cost2(A, g1, B, g2));\n  res=min(res, min_cost2(A, g2, B, g1));\n  res=min(res, min_cost2(B, g1, A, g2));\n  res=min(res, min_cost2(B, g2, A, g1));\n  \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='.';\n\n  return res;\n}\n\nint d[55][55][4];\n  \nbool check(P p){\n  if(p.first<0||h<=p.first||p.second<0||w<=p.second) return false;\n  if(s[p.first][p.second]=='*') return false;\n  return true;\n}\n\nvector<P> get(P A, int idx){\n  \n  vector<P> res;\n  \n  res.push_back(P(A.first+Ady[idx], A.second+Adx[idx]));\n  res.push_back(P(A.first+Bdy[idx], A.second+Bdx[idx]));\n  \n  return res;\n}\n\npriority_queue<P2,vector<P2>,greater<P2> > q;\n\nint dijkstra(){\n  \n  int res = INF;\n  \n  while(!q.empty()){\n    \n    P2 t = q.top(); q.pop();\n    \n    int cost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int idx=t.second.second;\n    \n    if(y==0&&x==0) res=min(res, cost);\n\n    if(d[y][x][idx]<cost) continue;\n    \n    \n    for(int i=0;i<4;i++){\n      \n      P A = P(y+Ady[i], x+Adx[i]);\n      P B = P(y+Bdy[i], x+Bdx[i]);\n      \n      if(!check(A)||!check(B)) continue;\n\n      vector<P> start=get(P(y,x), idx);\n      \n      if(!check(start[0])||!check(start[1])) continue;\n\t\n      int add_cost = min_cost(start,A,B,P(y,x));\n      \n      if(add_cost==INF) continue;\n\n      int dy[4]={-1,0,1,0};\n      int dx[4]={0,1,0,-1};\n      \n      int ny=y+dy[i], nx=x+dx[i];\n      int ncost=cost+add_cost+1;\n\n      if(d[ny][nx][i]>ncost){\n\td[ny][nx][i] = ncost;\n\tq.push(P2(P(ncost,ny),P(nx,(i+2)%4)));\n      }\n      \n    }\n\n  }\n\n  if(res==INF) res=-1;\n  \n  return res;  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n\n    vector<P> start;\n    int sy=-1, sx;\n    \n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.')\n\t  start.push_back(P(i,j));\n\tif(sy==-1&&s[i][j]=='X') sy=i, sx=j;\n      }\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++) d[i][j][k]=INF;\n    \n    for(int i=0;i<4;i++){\n      \n      P A = P(sy+Ady[i], sx+Adx[i]);\n      P B = P(sy+Bdy[i], sx+Bdx[i]);\n      \n      if(!check(A)||!check(B)) continue;\n      \n      int cost = min_cost(start,A,B,P(sy,sx));\n      \n      d[sy][sx][i] = cost;\n      \n      q.push(P2(P(cost,sy),P(sx,i)));\n    }\n\n    if(sy==0&&sx==0) cout<<0<<endl;\n    else cout<<dijkstra()<<endl;\n\n    while(!q.empty()) q.pop();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { -1,0,2,1 };\nconst int dy2[4] = { 0,2,1,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint getdis(const vector<vector<int>>&field, const int fx, const int fy,const int gx,const int gy) {\n\tint ans = 999999;\n\tqueue<aa>que;\n\tvector<vector<int>>memo(field.size(), vector<int>(field[0].size(),999999));\n\tque.push(aa{ fx,fy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tconst int nextx = atop.x + dx[i];\n\t\t\tconst int nexty = atop.y + dy[i];\n\t\t\tif (!field[nexty][nextx]) {\n\t\t\t\tif (atop.turn + 1 < memo[nexty][nextx]) {\n\t\t\t\t\tmemo[nexty][nextx] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ nextx,nexty,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nstruct bb {\n\tint kx;\n\tint ky;\n\tint opway;\n\tint turn;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bb&l, const bb&r) {\n\t\treturn l.turn> r.turn;\n\t}\n};\nint memo2[60][60][4];\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 60; ++i) {\n\t\t\tfor (int j = 0; j < 60; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo2[i][j][k] = 999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, true));\n\t\tpriority_queue<bb, vector<bb>, Compare>que;\n\t\t{\n\t\t\tint kx = 99, ky = 99;\n\t\t\tint ox[2];\n\t\t\tint oy[2];\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (st[j] == 'X') {\n\t\t\t\t\t\tkx = min(kx, j + 1);\n\t\t\t\t\t\tky = min(ky, i + 1);\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == 'o') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[j]=='.'){\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t\tox[num] = j + 1;\n\t\t\t\t\t\toy[num] = i + 1;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kx == 1 && ky == 1) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tconst int fx = ox[op^lu];\n\t\t\t\t\t\tconst int fy = oy[op^lu];\n\t\t\t\t\t\tint gx = kx + dx2[way];\n\t\t\t\t\t\tint gy = ky + dy2[way];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(way + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(way + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tmemo2[kx][ky][way] = amin;\n\t\t\t\t\tque.push(bb{ kx,ky,way,amin });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tbb atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int fkx = atop.kx;\n\t\t\tconst int fky = atop.ky;\n\t\t\tconst int fway = atop.opway;\n\t\t\tconst int fturn = atop.turn;\n\t\t\tif (fkx == 1 && fky == 1) {\n\t\t\t\tans = fturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int tway = 0; tway < 4; ++tway) {\n\t\t\t\tif (fway == tway)continue;\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tint fx = fkx + dx2[fway];\n\t\t\t\t\t\tint fy = fky + dy2[fway];\n\t\t\t\t\t\tint gx = fkx + dx2[tway];\n\t\t\t\t\t\tint gy = fky + dy2[tway];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(tway + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(tway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op^lu) {\n\t\t\t\t\t\t\tfx += dx[(fway + 1) % 4];\n\t\t\t\t\t\t\tfy += dy[(fway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (memo2[fkx][fky][tway]>fturn + amin) {\n\t\t\t\t\t\tmemo2[fkx][fky][tway] = fturn + amin;\n\t\t\t\t\t\tque.push(bb{ fkx,fky,tway,fturn + amin });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nkx = fkx + dx[fway];\n\t\t\t\tconst int nky = fky + dy[fway];\n\t\t\t\tconst int nway = (fway + 2) % 4;\n\t\t\t\tif (memo2[nkx][nky][nway] > fturn + 1) {\n\t\t\t\t\tmemo2[nkx][nky][nway] = fturn + 1;\n\t\t\t\t\tque.push(bb{ nkx,nky,nway,fturn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\nconst int INF = 1<<29;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n, m;\nstring fi[55];\nint dist[55][55][55][55];\nint dp[55][55][6];\n\ninline int len(pint s1, pint s2, pint t1, pint t2) {\n    int res = INF;\n    chmin(res, dist[s1.first][s1.second][t1.first][t1.second] + dist[s2.first][s2.second][t2.first][t2.second]);\n    chmin(res, dist[s1.first][s1.second][t2.first][t2.second] + dist[s2.first][s2.second][t1.first][t1.second]);\n    return res;\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> n >> m) {\n        if (n == 0) break;\n        for (int i = 0; i < n; ++i) cin >> fi[i];\n        \n        int ikx = -1, iky = -1, iex[2] = {-1}, iey[2] = {-1};\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n            if (fi[i][j] == 'X') {\n                if (ikx != -1) continue;\n                ikx = i, iky = j;\n            }\n            if (fi[i][j] == '.') {\n                if (iex[0] != -1) iex[1] = i, iey[1] = j;\n                else iex[0] = i, iey[0] = j;\n            }\n        }\n        //cout << pint(iex[0],iey[0]) << \", \" << pint(iex[1],iey[1]) << endl;\n        \n        int res = INF;\n        for (int i = 0; i < 55; ++i) for (int j = 0; j < 55; ++j) for (int k = 0; k < 6; ++k) dp[i][j][k] = INF;\n        dp[ikx][iky][4] = 0;\n        priority_queue< pair<int,pair<pint,int> >, vector<pair<int,pair<pint,int> > >, greater<pair<int,pair<pint,int> > > > que;\n        que.push( MP(0, MP(pint(ikx,iky),4)) );\n        while (!que.empty()) {\n            int dis = que.top().first;\n            int kx = que.top().second.first.first;\n            int ky = que.top().second.first.second;\n            int dir = que.top().second.second;\n            que.pop();\n            \n            if (kx == 0 && ky == 0) {\n                chmin(res, dis);\n                break;\n            }\n            if (dis > dp[kx][ky][dir]) continue;\n            \n            //cout << pint(kx,ky) << \", \" << dir << \" : \" << dis << endl;\n            \n            int pex[2], pey[2], nex[2], ney[2];\n            if (dir == 4) pex[0] = iex[0], pey[0] = iey[0], pex[1] = iex[1], pey[1] = iey[1];\n            if (dir == 0) pex[0] = kx-1, pey[0] = ky, pex[1] = kx-1, pey[1] = ky+1;\n            if (dir == 1) pex[0] = kx, pey[0] = ky-1, pex[1] = kx+1, pey[1] = ky-1;\n            if (dir == 2) pex[0] = kx+2, pey[0] = ky, pex[1] = kx+2, pey[1] = ky+1;\n            if (dir == 3) pex[0] = kx, pey[0] = ky+2, pex[1] = kx+1, pey[1] = ky+2;\n            \n            for (int it = 0; it < 2; ++it) {\n                int ix = pex[it], iy = pey[it];\n                for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) dist[ix][iy][i][j] = INF;\n                dist[ix][iy][ix][iy] = 0;\n               \n                //if (fi[i][j] == '*') continue;\n                //dist[i][j][i][j] = 0;\n                queue<pint> que;\n                que.push(pint(ix, iy));\n                while (!que.empty()) {\n                    int x = que.front().first, y = que.front().second; que.pop();\n                    for (int k = 0; k < 4; ++k) {\n                        int nx = x + dx[k], ny = y + dy[k];\n                        if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n                        if (fi[nx][ny] == '*') continue;\n                        if (nx == kx && ny == ky) continue;\n                        if (nx == kx+1 && ny == ky) continue;\n                        if (nx == kx && ny == ky+1) continue;\n                        if (nx == kx+1 && ny == ky+1) continue;\n                        if (dist[ix][iy][nx][ny] == INF) {\n                            dist[ix][iy][nx][ny] = dist[ix][iy][x][y] + 1;\n                            que.push(pint(nx, ny));\n                        }\n                    }\n                }\n            }\n            \n            for (int i = 0; i < 4; ++i) {\n                int nkx = kx + dx[i], nky = ky + dy[i];\n                if (nkx < 0 || nkx >= n-1 || nky < 0 || nky >= m-1) continue;\n                if (i == 2) nex[0] = kx-1, ney[0] = ky, nex[1] = kx-1, ney[1] = ky+1;\n                if (i == 3) nex[0] = kx, ney[0] = ky-1, nex[1] = kx+1, ney[1] = ky-1;\n                if (i == 0) nex[0] = kx+2, ney[0] = ky, nex[1] = kx+2, ney[1] = ky+1;\n                if (i == 1) nex[0] = kx, ney[0] = ky+2, nex[1] = kx+1, ney[1] = ky+2;\n                \n                if (fi[nex[0]][ney[0]] == '*' || fi[nex[1]][ney[1]] == '*') continue;\n                int l = len(pint(pex[0],pey[0]), pint(pex[1],pey[1]), pint(nex[0],ney[0]), pint(nex[1],ney[1])) + 1;\n                \n                if (l >= INF) continue;\n                if (chmin(dp[nkx][nky][i], dp[kx][ky][dir] + l)) {\n                    que.push( MP(dp[kx][ky][dir]+l, MP(pint(nkx,nky), i)) );\n                }\n            }\n        }\n        \n        if (res < INF) cout << res << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > P;\ntypedef pair< int , P > PP;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\n\nint d[50][50];\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      d[i][j]=1e8;\n  d[sy][sx]=0;\n  \n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if(y==ty&&x==tx)break;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n  \n  return d[ty][tx];\n}\n\nint dd[50][50][4];\nint solve(int sy,int sx,int sd){\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<4;k++)\n        dd[i][j][k]=1e8;\n\n  dd[sy][sx][sd]=0;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  Q.push( PP(0, P(sy*50+sx,sd) ) );\n\n  while(!Q.empty()){\n    PP pp = Q.top();Q.pop();\n    int y=pp.second.first/50;\n    int x=pp.second.first%50;\n    int dir=pp.second.second;\n    if(y==0&&x==0)return dd[y][x][dir];\n    if(pp.first > dd[y][x][dir])continue;\n    \n    for(int i=0;i<4;i++){\n      int ncost=dd[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      \n      ncost+=min( calc(y,x,ay,ax,Ay,Ax)+calc(y,x,by,bx,By,Bx) ,\n                  calc(y,x,ay,ax,By,Bx)+calc(y,x,by,bx,Ay,Ax) );\n\n      ncost++;\n      if(dd[ny][nx][i]>ncost){\n        dd[ny][nx][i]=ncost;\n        Q.push(PP(ncost,P(ny*50+nx,i)));\n        \n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sy,sx,py0,px0,ay,ax) + calc(sy,sx,py1,px1,by,bx)\n                    , calc(sy,sx,py0,px0,by,bx) + calc(sy,sx,py1,px1,ay,ax) );\n\n      ans=min(ans,cost+solve(sy,sx,(i+2)%4));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int y, x;\n  int d;\n  int dist;\n  P(int y, int x, int d, int dist) :\n    y(y),x(x),d(d),dist(dist) {}\n  bool operator<(const P &p) const {\n    return dist > p.dist;\n  }\n};\n\nstruct Dijkstra {\n  int dist[50][50][4];\n\n  void init();\n  void transition(const P &p);\n  void pawnMove(const vector<pii> &ps, int ky, int kx, int offset);\n  bool goal(const P &p) {\n    return (p.y==0&&p.x==0);\n  }\n\n  \n  int &getDist(const P &p) {\n    return dist[p.y][p.x][p.d];\n  }\n  priority_queue<P> Q;  \n  void updateQ(const P &p) {\n    if (getDist(p) > p.dist) {\n      getDist(p) = p.dist;\n      Q.push(p);\n    }\n  }\n  int go() {\n    while(!Q.empty()) Q.pop();\n    int res = -1;\n    memset(dist,0x3f,sizeof(dist));\n    init();\n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n      if (p.dist > getDist(p)) continue;\n      if (goal(p)) {\n        res = p.dist;\n        break;\n      }\n      // print(p);\n      transition(p);\n    }\n    return res;\n  }\n  void print(const P &p);\n} dijkstra;\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nconst int kdy[4] = {0,0,1,1};\nconst int kdx[4] = {0,1,0,1};\n\nconst int pdy[4][2] = {0,1,2,2,0,1,-1,-1};\nconst int pdx[4][2] = {2,2,0,1,-1,-1,0,1};\n\nint h,w;\nchar ba[50][50];\n\nbool ok(int y, int x) {\n  return valid(y,x,h,w) && ba[y][x]!='*';\n}\n\nbool isKing(int i, int j, int y, int x) {\n  REP(k,4) {\n    int yy=y+kdy[k];\n    int xx=x+kdx[k];\n    if (yy==i&xx==j) return 1;\n  }\n  return 0;\n}\n\nint dist2[2][50][50];\n\nvoid calcPawnDist(int id, int i, int j, int ky, int kx) {\n  queue<pii> Q;\n  Q.push(pii(i,j));\n  dist2[id][i][j] = 0;\n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    REP(k,4) {\n      int y=p.first+dy[k];\n      int x=p.second+dx[k];\n      if (!ok(y,x) || isKing(y,x,ky,kx) || dist2[id][y][x]!=-1) continue;\n      Q.push(pii(y,x));\n      dist2[id][y][x] = dist2[id][p.first][p.second]+1;\n    }\n  }\n}\n\nvoid Dijkstra::pawnMove(const vector<pii> &ps, int ky, int kx, int distOffset=0) {\n  memset(dist2,-1,sizeof(dist2));\n  REP(i,2) calcPawnDist(i,ps[i].first,ps[i].second,ky,kx);\n\n  REP(d,4) {\n    int cost[2][2];\n    bool f = 1;\n    REP(i,2) {\n      int y=ky+pdy[d][i];\n      int x=kx+pdx[d][i];\n      if (!ok(y,x)) { f = 0;break; }\n      REP(j,2) {\n        cost[i][j] = dist2[j][y][x];\n        if (cost[i][j] == -1) f = 0;\n      }\n    }\n    if (f) {\n      int dis = min(cost[0][0]+cost[1][1], cost[0][1]+cost[1][0]);\n      P tmp(ky,kx,d,distOffset+dis);\n      updateQ(tmp);\n    }\n  }\n}\n\nvoid Dijkstra::init() {\n  int ky=-1, kx;\n  vector<pii> ps;\n  REP(i,h)REP(j,w) {\n    if (ky==-1 && ba[i][j]=='X') ky = i, kx = j;\n    if (ba[i][j] == '.') ps.push_back(pii(i,j));\n  }  \n  pawnMove(ps,ky,kx);\n}\n\nvoid Dijkstra::transition(const P &p) {\n  // pawn\n  vector<pii> ps;\n  REP(i,2) ps.push_back(pii(p.y+pdy[p.d][i], p.x+pdx[p.d][i]));\n  pawnMove(ps,p.y,p.x,p.dist);\n  // king\n  P nxt(p.y+dy[p.d],p.x+dx[p.d],(p.d+2)%4,p.dist+1);\n  updateQ(nxt);\n}\n\n\nvoid Dijkstra::print(const P &p) {\n  cout << p.dist << endl;\n  char c[h][w];\n  REP(i,h)REP(j,w)c[i][j]=(ba[i][j]=='*'?'*':'o');\n  REP(k,4) {\n    int y=p.y + kdy[k];\n    int x=p.x + kdx[k];\n    c[y][x]='X';\n  }\n  REP(i,2) c[p.y+pdy[p.d][i]][p.x+pdx[p.d][i]] = '.';\n  REP(i,h) { REP(j,w) cout << c[i][j]; cout << endl;}\n  cout << endl;    \n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    if (ba[0][0]=='X') {\n      cout << 0 << endl;\n      continue;\n    }\n    cout << dijkstra.go() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\n\n\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\n\nint kdx1[]={-1,0,2,1};\nint kdy1[]={0,2,1,-1};\n\nint kdx2[]={-1,1,2,0};\nint kdy2[]={1,2,0,-1};\n\nint h,w;\n\nconst int INF=1<<28;\n\nstring in[100];\n\nbool overking(PI a,PI king){\n  return\n    king.F<=a.F && a.F<=king.F+1 &&\n    king.S<=a.S && a.S<=king.S+1;\n}\n\nbool inboard(PI a){\n  if(a.F<0 || a.S<0 || a.F>=h || a.S>=w) return false;\n  return in[a.F][a.S]!='*';\n}\n\nbool costvis[50][50];\n\nint getcost(PI a,PI b,PI king){\n  memset(costvis,0,sizeof(costvis));\n  queue<pair<int,PI > > q;\n  q.push(mp(0,a));\n\n  /*\n  cout << \"getcost start \"<<a.F<<' '<<a.S<<endl;\n  cout << \"getcost goal \"<<b.F<<' '<<b.S<<endl;\n  */\n  \n  while(!q.empty()){\n    int cc=q.front().F;\n    PI cv=q.front().S;\n    q.pop();\n    if(costvis[cv.F][cv.S]) continue;\n    //cout <<\"getcost \"<<cv.F<<' '<<cv.S<<\" cost \"<<cc<<endl;\n    if(b==cv) return cc;\n    costvis[cv.F][cv.S]=true;\n    rep(i,4){\n      int nx=cv.F+dx[i];\n      int ny=cv.S+dy[i];\n      if(overking(mp(nx,ny),king) || !inboard(mp(nx,ny))) continue;\n      q.push(mp(cc+1,mp(nx,ny)));\n    }\n  }\n\n  return INF;\n}\n\nbool vis[4][50][50];\n\n\nvoid solve(){\n\n  vector<PI> pawn;\n  PI king;\n  rep(i,h) cin >> in[i];\n  \n  rep(i,h){\n    // cout << in[i]<<endl;\n    rep(j,w){\n      if(in[i][j]=='.') pawn.pb(mp(i,j));\n      if(in[i][j]=='X' && i+1<h && j+1<w && in[i+1][j+1]=='X') king=PI(i,j);\n    }\n  }\n\n  if(king == mp(0,0)){\n    cout<<0<<endl;\n    return;\n  }\n\n  priority_queue<pair<PI,PI> > q; // cost,dir,pos\n  \n  rep(i,4){\n    int cost=INF;\n    PI k1=mp(king.F+kdx1[i],king.S+kdy1[i]);\n    PI k2=mp(king.F+kdx2[i],king.S+kdy2[i]);    \n    if(!(inboard(k1) && inboard(k2))) continue;\n\n    cost = min(cost,getcost(pawn[0],k1,king)+getcost(pawn[1],k2,king));\n    cost = min(cost,getcost(pawn[0],k2,king)+getcost(pawn[1],k1,king));\n    //cout << \"start \"<<i<<' '<<cost<<endl;\n    if(cost < INF/4){\n      q.push(mp(mp(-cost,i),king));\n    }\n  }\n\n  memset(vis,0,sizeof(vis));\n  while(!q.empty()){\n    int cc=-q.top().F.F;\n    int dir=q.top().F.S;\n    PI king=q.top().S;\n    q.pop();\n    if(vis[dir][king.F][king.S]) continue;\n    vis[dir][king.F][king.S]=true;\n    //cout << dir <<' ' <<king.F<< ' '<<king.S<<' '<<cc<<endl;\n    if(king==mp(0,0)){\n      cout<<cc<<endl;\n      return;\n    }\n    pawn[0]=mp(king.F+kdx1[dir],king.S+kdy1[dir]);\n    pawn[1]=mp(king.F+kdx2[dir],king.S+kdy2[dir]);\n    rep(i,4){\n      if(dir==i){\n\tPI nc=mp(-cc-1,(i+2)&3);\n\tPI pos=mp(king.F+dx[i],king.S+dy[i]);\n\tq.push(mp(nc,pos));\n\tcontinue;\n      }\n      \n      int cost = INF;\n      if(!(inboard(mp(king.F+kdx1[i],king.S+kdy1[i])) &&\n\t   inboard(mp(king.F+kdx2[i],king.S+kdy2[i])))) continue;\n      PI k1=mp(king.F+kdx1[i],king.S+kdy1[i]);\n      PI k2=mp(king.F+kdx2[i],king.S+kdy2[i]);\n      cost = min(cost,getcost(pawn[0],k1,king)+getcost(pawn[1],k2,king));\n      cost = min(cost,getcost(pawn[0],k2,king)+getcost(pawn[1],k1,king));\n      if(cost>INF/4) continue;\n      PI nking=mp(king.F+dx[i],king.S+dy[i]);\n      q.push(mp(mp(-cost-1-cc,(i+2)&3),nking));\n    }\n  }\n\n  cout << -1 << endl;\n\n}\n\nmain(){\n  while(cin>>h>>w,w) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<climits>\n#define inf (1<<29)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define MAX 251\nusing namespace std;\nint h,w;\nstring G[MAX];\nint mincost[MAX][MAX][MAX];//mincost[open1][open2][king] := the minimum cost\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\nint kdx[] = {0,1,0,1};\nint kdy[] = {0,0,1,1};\nint sdx[] = {};\nint sdy[] = {};\n\nstruct Point\n{\n  int x,y;\n  Point(int x=-1,int y=-1):x(x),y(y){}\n  bool operator < (const Point &a)const\n  {\n    if(x != a.x)return x < a.x;\n    return y < a.y;\n  }\n};\n\nstruct State\n{\n  Point king;\n  Point op[2];\n  int cost;\n  State(Point king,Point op1,Point op2,int cost = -1):king(king),cost(cost){ op[0] = op1,op[1] = op2; }\n  bool operator < (const State &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint toIndex(Point p){ \n  assert(0 <= p.x+p.y*w && p.x+p.y*w < MAX);\nreturn p.x+p.y*w; \n}\n\nvoid trace(Point p1,Point p2,Point p3)\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  if(G[i][j] == '*')\n\t    {\n\t      cout << G[i][j];\n\t      continue;\n\t    }\n\t  if(p1.x == j && p1.y == i)\n\t    {\n\t      cout << '.';\n\t      continue;\n\t    }\n\t  if(p2.x == j && p2.y == i)\n\t    {\n\t      cout << '.'; \n\t      continue;\n\t    }\n\n\t  bool check_king = true;\n\t  rep(k,4)\n\t    {\n\t      int nx = p3.x + kdx[k];\n\t      int ny = p3.y + kdy[k];\n\t      if(nx == j && ny == i)\n\t\t{\n\t\t  cout << 'X';\n\t\t  check_king = false;\n\t\t  continue;\n\t\t}\n\t    }\n\t  if(!check_king)continue;\n\t  cout << 'o';\n\t}\n      cout << endl;\n    }\n  cout << endl << endl;\n}\n\nbool slide_check(int dir,Point &p1,Point &p2,Point king)\n{\n  map<Point,bool> exist;\n  exist[p1] = true;\n  exist[p2] = true;\n  rep(i,4)\n    {\n      int nx = king.x + kdx[i];\n      int ny = king.y + kdy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))return false;\n      if(G[ny][nx] == '*')return false;\n    }\n  //下、右、上、左\n  Point pp1,pp2;\n  if(dir == 0)\n    {\n      // 0,  1, 2,   3\n      //今、右、下、斜め\n      pp1 = Point(king.x+kdx[2],king.y+kdy[2]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x,king.y-1);\n      p2 = Point(king.x+1,king.y-1);\n    }\n  if(dir == 1)\n    {\n      pp1 = Point(king.x+kdx[1],king.y+kdy[1]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x-1,king.y);\n      p2 = Point(king.x-1,king.y+1);\n    }\n  if(dir == 2)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[1],king.y+kdy[1]);\n      p1 = Point(king.x,king.y+2);\n      p2 = Point(king.x+1,king.y+2);\n    }\n  if(dir == 3)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[2],king.y+kdy[2]);\n      p1 = Point(king.x+2,king.y);\n      p2 = Point(king.x+2,king.y+1);\n    }\n  if(!(exist[pp1] && exist[pp2]))return false;\n\n  return true;\n}\n\nvoid dijkstra(Point st,Point op1,Point op2)\n{\n  priority_queue<State> Q;\n  Q.push(State(st,op1,op2,0));\n  rep(i,MAX)rep(j,MAX)rep(k,MAX)mincost[i][j][k] = inf;\n  mincost[toIndex(op1)][toIndex(op2)][toIndex(st)] = 0;\n  mincost[toIndex(op2)][toIndex(op1)][toIndex(st)] = 0;\n\n  while(!Q.empty())\n    {\n      State state = Q.top(); Q.pop();\n      //cout << \"the cost = \" << state.cost << endl;\n      //trace(state.op[0],state.op[1],state.king);\n      if(toIndex(state.king) == 0)\n\t{\n\t  cout << state.cost << endl;\n\t  return;\n\t}\n\n\n      Point king = state.king;\n      rep(i,2)//move the open square\n\t{\n\t  Point p = state.op[i];\n\t  rep(j,4)\n\t    {\n\t      int nx = p.x + dx[j];\n\t      int ny = p.y + dy[j];\t      \n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '*')continue;\n\n\t      bool check_king = true;\n\t      rep(k,4)\n\t\t{//the place (ny,ny) is on the king\n\t\t  int kx = king.x + kdx[k];\n\t\t  int ky = king.y + kdy[k];\n\t\t  assert(0 <= kx && kx < w && 0 <= ky && ky < h);\n\t\t  if(kx == nx && ky == ny)\n\t\t    {\n\t\t      check_king = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if(!check_king)continue;\n\t      if(nx == state.op[(i+1)%2].x && ny == state.op[(i+1)%2].y)continue;//the new place is on the other open squeare\n\n\t      Point pp[2];\n\t      pp[0] = (i == 0 ? Point(nx,ny): state.op[0]);\t      \n\t      pp[1] = (i == 0 ? state.op[1] : Point(nx,ny));\n\n\t      int index1 = toIndex(pp[0]);\n\t      int index2 = toIndex(pp[1]);\n\t      int index3 = toIndex(state.king);\n\t      if(mincost[index1][index2][index3] > state.cost + 1)\n\t\t{\n\t\t  mincost[index1][index2][index3] = state.cost + 1;\n\t\t  mincost[index2][index1][index3] = state.cost + 1; \n\t\t  Q.push(State(state.king,pp[0],pp[1],state.cost+1));\n\t\t}\n\t    }\n\t}\n\n      rep(i,4)//move the king\n\t{\n\t  int nx = state.king.x + dx[i];\n\t  int ny = state.king.y + dy[i];\n\t  Point sop1 = state.op[0];\n\t  Point sop2 = state.op[1];\n\t  if(!slide_check(i,sop1,sop2,Point(nx,ny)))continue;\n\n\t  int index1 = toIndex(sop1);\n\t  int index2 = toIndex(sop2);\n\t  int index3 = toIndex(Point(nx,ny));\n\t  if(mincost[index1][index2][index3] > state.cost + 1)\n\t    {\n\t      mincost[index1][index2][index3] = state.cost + 1;\n\t      mincost[index2][index1][index3] = state.cost + 1;\n\t      Q.push(State(Point(nx,ny),sop1,sop2,state.cost+1));\n\t    }\n\t}\n    }  \n  cout << -1 << endl;\n}\n\nint main()\n{\n  clock_t stc,edc;\n  stc = clock();\n  while(cin >> h >> w,h|w)\n    {\n      Point st;\n      vector<Point> op;\n      rep(i,h)\n\t{\n\t  cin >> G[i];\n\t  rep(j,w)\n\t    {\n\t      if((st.x == -1 && st.y == -1) && G[i][j] == 'X')\n\t\t{\n\t\t  st.x = j,st.y = i;\n\t\t}\n\t      if(G[i][j] == '.')op.push_back(Point(j,i));\n\t    }\n\t}\n      assert(op.size() == 2);\n      dijkstra(st,op[0],op[1]);\n    }\n  edc = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(edc-stc)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e7\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n\t2,2,\n\t0,1,\n\t-1,-1,\n\t0,1\n};\nint ddy[4][2]={\n\t0,1,\n\t2,2,\n\t0,1,\n\t-1,-1\n};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tint cost,pdir;\n\tP k;\n\tdata(){}\n\tdata(P kk,int cc,int pp){\n\t\tk=kk;\n\t\tcost=cc;\n\t\tpdir=pp;\n\t}\n\tbool operator<(const data &d1)const{\n\t\tif(cost!=d1.cost)return cost>d1.cost;\n\t\tif(k!=d1.k)return k>d1.k;\n\t\treturn pdir>d1.pdir;\n\t}\n};\n\nstruct data2{\n\tP k,o[2];\n\tdata2(){}\n\tdata2(P kk,P o1,P o2){\n\t\tk=kk;\n\t\to[0]=o1;\n\t\to[1]=o2;\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\nbool same(data2 a,data2 b){\n\tif(!same(a.k,b.k))return false;\n\tif(!same(a.o[0],b.o[0]))return false;\n\tif(!same(a.o[1],b.o[1]))return false;\n\treturn true;\n}\n\nint distp[51][51];\nint move_pawn(P f,P t){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tdistp[i][j]=INF;\n\t\t}\n\t}\n\tqueue<P> que;\n\tque.push(f);\n\tdistp[f.first][f.second]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tif(q==t)return distp[q.first][q.second];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nq=q+P(dy[i],dx[i]);\n\t\t\tif(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n\t\t\t\tif(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n\t\t\t\t\tdistp[nq.first][nq.second]=distp[q.first][q.second]+1;\n\t\t\t\t\tque.push(P(nq));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\ndata first_moveking(P k,P o1,P o2,int dir){\n\tdata res;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\ndata moveking(data q,int dir){\n\tdata res;\n\tP k=q.k;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tP o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n\tP o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n\t//printf(\"y%d x%d y%d x%d dir%d\\n\",o1.second,o1.first,o2.second,o2.first,dir);\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\t//printf(\"ox%d oy%d ox%d oy%d\\n\",k.second+ddx[dir][0],k.first+ddy[dir][0],k.second+ddx[dir][1],k.first+ddy[dir][1]);\n\t//printf(\"c%d c%d %d %d\\n\",cost1,cost2,k.second+dx[dir],k.first+dy[dir]);\n\tres.cost=min(cost1,cost2)+1+q.cost;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n\tpriority_queue<data> que;\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n\t\t\tdata si=first_moveking(s,o1,o2,i);\n\t\t\tif(si.cost<INF){\n\t\t\t\tque.push(si);\n\t\t\t\tdist[si.k.first][si.k.second][si.pdir]=si.cost;\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n\t\t//printf(\"%d %d\\n\",q.k.first,q.k.second);\n\t\tif(q.k.first+q.k.second==0)return q.cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n\t\t\t\tdata nq=moveking(q,i);\n\t\t\t\tif(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n\t\t\t\t\tdist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n\t\t\t\t\tque.push(nq);\n\t\t\t\t\t//printf(\"%d %d %d\\n\",nq.cost,nq.k.second,nq.k.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tP k,o[2];\n\t\tk.first=k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tif(k.first==-1){\n\t\t\t\t\t\tk.second=j;\n\t\t\t\t\t\tk.first=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\to[cnt].second=j;\n\t\t\t\t\to[cnt++].first=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(k.first+k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <utility>\n#include <map>\n#include <queue>\n#include <string>\n#define INF 7000\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tP k,o[2];\n\tbool operator<(const data &d1)const{\n\t\tif(k!=d1.k)return k<d1.k;\n\t\tif(o[0]!=d1.o[0])return o[0]<d1.o[0];\n\t\treturn o[1]<d1.o[1];\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\ndata moveking(data q,int dir){\n\tif(cross(q.o[0]+P(dx[dir],dy[dir]),q.k) && cross(q.o[1]+P(dx[dir],dy[dir]),q.k)){\n\t\tq.o[0]=q.o[0]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.o[1]=q.o[1]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.k=q.k-P(dx[dir],dy[dir]);\n\t}\n\treturn q;\n}\n\ndata movepawn(data q,int dir,int s){\n\tP nmove=q.o[s]+P(dx[dir],dy[dir]);\n\tif(canmove(nmove) && !same(nmove,q.o[1-s])){\n\t\tif(!cross(nmove,q.k) && fie[nmove.second][nmove.first]!=-1){\n\t\t\tq.o[s]=nmove;\n\t\t}\n\t}\n\treturn q;\n}\n\nmap<data,int> used;\n\nint bfs(data s){\n\tused.clear();\n\tqueue<data> que;\n\tque.push(s);\n\tused[s]=0;\n\twhile(que.size()){\n\t\tdata q=que.front();\n\t\tque.pop();\n\t\tint cost=used[q];\n\t\tif(cost>INF)continue;\n\t\t//printf(\"%d %d %d %d %d\\n\",cost,q.o[0].first,q.o[0].second,q.o[1].first,q.o[1].second);\n\t\tif(q.k.first+q.k.second==0)return cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdata nq=moveking(q,i);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,0);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,1);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tdata s;\n\t\ts.k.first=s.k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='o')fie[i][j]=1;\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tfie[i][j]=1;\n\t\t\t\t\tif(s.k.first==-1){\n\t\t\t\t\t\ts.k.first=j;\n\t\t\t\t\t\ts.k.second=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\ts.o[cnt].first=j;\n\t\t\t\t\ts.o[cnt++].second=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s.k.first+s.k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",bfs(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e7\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n\t2,2,\n\t0,1,\n\t-1,-1,\n\t0,1\n};\nint ddy[4][2]={\n\t0,1,\n\t2,2,\n\t0,1,\n\t-1,-1\n};\nP add(P p1,P p2){\n\tP p3;\n\tp3.x=\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP minus(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tint cost,pdir;\n\tP k;\n\tdata(){}\n\tdata(P kk,int cc,int pp){\n\t\tk=kk;\n\t\tcost=cc;\n\t\tpdir=pp;\n\t}\n\tbool operator<(const data &d1)const{\n\t\tif(cost!=d1.cost)return cost>d1.cost;\n\t\tif(k!=d1.k)return k>d1.k;\n\t\treturn pdir>d1.pdir;\n\t}\n};\n\nstruct data2{\n\tP k,o[2];\n\tdata2(){}\n\tdata2(P kk,P o1,P o2){\n\t\tk=kk;\n\t\to[0]=o1;\n\t\to[1]=o2;\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\nbool same(data2 a,data2 b){\n\tif(!same(a.k,b.k))return false;\n\tif(!same(a.o[0],b.o[0]))return false;\n\tif(!same(a.o[1],b.o[1]))return false;\n\treturn true;\n}\n\nint distp[51][51];\nint move_pawn(P f,P t){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<50;j++){\n\t\t\tdistp[i][j]=INF;\n\t\t}\n\t}\n\tqueue<P> que;\n\tque.push(f);\n\tdistp[f.first][f.second]=0;\n\twhile(que.size()){\n\t\tP q=que.front();\n\t\tque.pop();\n\t\tif(q==t)return distp[q.first][q.second];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tP nq=q+P(dy[i],dx[i]);\n\t\t\tif(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n\t\t\t\tif(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n\t\t\t\t\tdistp[nq.first][nq.second]=distp[q.first][q.second]+1;\n\t\t\t\t\tque.push(P(nq));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\ndata first_moveking(P k,P o1,P o2,int dir){\n\tdata res;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\ndata moveking(data q,int dir){\n\tdata res;\n\tP k=q.k;\n\tfie[k.first][k.second]=-1;\n\tfie[k.first+1][k.second]=-1;\n\tfie[k.first][k.second+1]=-1;\n\tfie[k.first+1][k.second+1]=-1;\n\tP o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n\tP o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n\tint cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n\tint cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n\tres.cost=min(cost1,cost2)+1+q.cost;\n\tfie[k.first][k.second]=0;\n\tfie[k.first+1][k.second]=0;\n\tfie[k.first][k.second+1]=0;\n\tfie[k.first+1][k.second+1]=0;\n\tres.pdir=dir;\n\tres.k=k+P(dy[dir],dx[dir]);\n\treturn res;\n}\n\nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n\tint i,j,k;\n\tpriority_queue<data> que;\n\tfor(i=0;i<50;i++){\n\t\tfor(j=0;j<50;j++){\n\t\t\tfor(k=0;k<4;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<4;i++){\n\t\tif(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n\t\t\tdata si=first_moveking(s,o1,o2,i);\n\t\t\tif(si.cost<INF){\n\t\t\t\tque.push(si);\n\t\t\t\tdist[si.k.first][si.k.second][si.pdir]=si.cost;\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n\t\tif(q.k.first+q.k.second==0)return q.cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n\t\t\t\tdata nq=moveking(q,i);\n\t\t\t\tif(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n\t\t\t\t\tdist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n\t\t\t\t\tque.push(nq);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tP k,o[2];\n\t\tk.first=k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tif(k.first==-1){\n\t\t\t\t\t\tk.second=j;\n\t\t\t\t\t\tk.first=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\to[cnt].second=j;\n\t\t\t\t\to[cnt++].first=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(k.first+k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar ba[50][50];\n\nstruct P {\n  int y, x;\n  int d;\n  int dist;\n  P(int y, int x, int d, int dist) :\n    y(y),x(x),d(d),dist(dist) {}\n  bool operator<(const P &p) const {\n    return dist > p.dist;\n  }\n};\n\nint dist[50][50][4];\n\nint &get(const P &p) {\n  return dist[p.y][p.x][p.d];\n}\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nconst int kdy[4] = {0,0,1,1};\nconst int kdx[4] = {0,1,0,1};\n\nconst int pdy[4][2] = {0,1,2,2,0,1,-1,-1};\nconst int pdx[4][2] = {2,2,0,1,-1,-1,0,1};\n\nint h,w;\n\nbool ok(int y, int x) {\n  return valid(y,x,h,w) && ba[y][x]!='#';\n}\n\nbool isKing(int i, int j, int y, int x) {\n  REP(k,4) {\n    int yy=y+kdy[k];\n    int xx=x+kdx[k];\n    if (yy==i&xx==j) return 1;\n  }\n  return 0;\n}\n\nint dist2[2][50][50];\n\nvoid calcPawnDist(int id, int i, int j, int ky, int kx) {\n  queue<pii> Q;\n  Q.push(pii(i,j));\n  dist2[id][i][j] = 0;\n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    REP(k,4) {\n      int y=p.first+dy[k];\n      int x=p.second+dx[k];\n      if (!ok(y,x) || isKing(y,x,ky,kx) || dist2[id][y][x]!=-1) continue;\n      Q.push(pii(y,x));\n      dist2[id][y][x] = dist2[id][p.first][p.second]+1;\n    }\n  }\n}\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    int ky=-1, kx;\n    vector<pii> ps;\n    REP(i,h)REP(j,w) {\n      if (ky==-1 && ba[i][j]=='X') ky = i, kx = j;\n      if (ba[i][j] == '.') ps.push_back(pii(i,j));\n    }\n    assert(ps.size() == 2 && ky != -1);\n\n    if (ky==0 && kx==0) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    memset(dist2,-1,sizeof(dist2));\n    REP(i,2) {\n      int y = ps[i].first;\n      int x = ps[i].second;\n      calcPawnDist(i,y,x,ky,kx);\n    }\n    \n    memset(dist, 0x3f, sizeof(dist));\n    priority_queue<P> PQ;\n\n    REP(d,4) {\n      int cost[2][2];\n      bool f = 1;\n      REP(i,2) {\n        int y=ky+pdy[d][i];\n        int x=kx+pdx[d][i];\n        if (!ok(y,x)) { f = 0;break; }\n        REP(j,2) {\n          cost[i][j] = dist2[j][y][x];\n        }\n      }\n      if (f) {\n        int dis = min(cost[0][0]+cost[1][1], cost[0][1]+cost[1][0]);\n        dist[ky][kx][d] = dis;\n        PQ.push(P(ky,kx,d,dis));\n      }\n    }\n    \n    int ans = -1;\n    \n    while(!PQ.empty()) {\n      P p = PQ.top(); PQ.pop();\n\n      if (p.dist > get(p)) continue;\n\n      // cout << p.dist << endl;\n      // char c[h][w];\n      // REP(i,h)REP(j,w)c[i][j]=(ba[i][j]=='#'?'#':'o');\n      // REP(k,4) {\n      //   int y=p.y + kdy[k];\n      //   int x=p.x + kdx[k];\n      //   c[y][x]='X';\n      // }\n      // REP(i,2) c[p.y+pdy[p.d][i]][p.x+pdx[p.d][i]] = '.';\n      // REP(i,h) { REP(j,w) cout << c[i][j]; cout << endl;}\n      // cout << endl;\n\n      if (p.y==0 && p.x==0) {\n        ans = p.dist;\n        break;\n      }\n\n      // pawn\n      memset(dist2,-1,sizeof(dist2));\n      REP(i,2) {\n        int y = p.y+pdy[p.d][i];\n        int x = p.x+pdx[p.d][i];\n        calcPawnDist(i,y,x,p.y,p.x);\n      }\n\n      REP(d,4) {\n        int cost[2][2];\n        bool f = 1;\n        REP(i,2) {\n          int ty = p.y+pdy[d][i];\n          int tx = p.x+pdx[d][i];\n          if (!ok(ty,tx)) {f = 0;break;}\n          REP(j,2) {\n            cost[i][j] = dist2[j][ty][tx];\n          }\n        }\n        if (f) {\n          int dis = min(cost[0][0]+cost[1][1], cost[0][1]+cost[1][0]);\n          P nxt(p.y,p.x,d,p.dist+dis);\n          if (get(nxt) > p.dist + dis) {\n            get(nxt) = p.dist + dis;\n            PQ.push(nxt);\n          }\n        }\n      }\n      \n      // king\n      int y = p.y+dy[p.d];\n      int x = p.x+dx[p.d];\n      P nxt(y,x,(p.d+2)%4,p.dist+1);\n      if (get(nxt) > p.dist+1) {\n        get(nxt) = p.dist + 1;\n        PQ.push(nxt);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 50;\nconst int INF = 1 << 28;\n\nint h, w, cost[N][N][4][4];\nchar pz[N][N];\nint dy[8] = {-1, -1, 0, 1, 2, 2, 1, 0};\nint dx[8] = {0, 1, 2, 2, 1, 0, -1, -1};\nint dy2[4] = {-1, 0, 1, 0};\nint dx2[4] = {0, 1, 0, -1};\n\nvoid bfs(int sy, int sx, int vis[N][N]){\n  fill(vis[0], vis[N], INF);\n  vis[sy][sx] = 0;\n  queue<P> q;\n  q.push(P(sy * w + sx, 0));\n  while(!q.empty()){\n    P u = q.front(); q.pop();\n    int uy = u.first / w;\n    int ux = u.first % w;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(pz[ny][nx] == '*') continue;\n      if(vis[ny][nx] != INF) continue;\n      vis[ny][nx] = u.second + 1;\n      q.push(P(ny * w + nx, u.second + 1));\n    }\n  }\n}\n\nint calc(int y, int x, P f1, P f2, int t){\n  if(pz[y][x] == '*' || pz[y+1][x] == '*' || pz[y][x+1] == '*' || pz[y+1][x+1] == '*') return INF;\n  int ny1 = y + dy[t*2];\n  int nx1 = x + dx[t*2];\n  int ny2 = y + dy[t*2+1];\n  int nx2 = x + dx[t*2+1];\n  if(min(ny1, ny2) < 0 || max(ny1, ny2) >= h) return INF;\n  if(min(nx1, nx2) < 0 || max(nx1, nx2) >= w) return INF;\n  if(pz[ny1][nx1] == '*' || pz[ny2][nx2] == '*') return INF;\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = '*';\n  int vis[2][N][N];\n  bfs(f1.first, f1.second, vis[0]);\n  bfs(f2.first, f2.second, vis[1]);\n  pz[y][x] = pz[y+1][x] = pz[y][x+1] = pz[y+1][x+1] = 'X';\n  return min(vis[0][ny1][nx1] + vis[1][ny2][nx2], vis[0][ny2][nx2] + vis[1][ny1][nx1]);\n}\n\nclass S{\npublic:\n  P p;\n  int fd, c;\n  S(){}\n  S(P p, int fd, int c) : p(p), fd(fd), c(c) {}\n  bool operator < (const S& s) const { return c > s.c; }\n};\n\nint solve(P s, P p1, P p2){\n  int dist[N][N][4];\n  priority_queue<S> que;\n  fill(dist[0][0], dist[N][0], INF);\n  for(int i=0;i<4;i++){\n    int ny = s.first + dy2[i];\n    int nx = s.second + dx2[i];\n    if(ny < 0 || ny+1 >= h) continue;\n    if(nx < 0 || nx+1 >= w) continue;\n    if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n    int nfd = (1 - i / 2) * 2 + i % 2;\n    dist[s.first][s.second][i] = calc(s.first, s.second, p1, p2, i);\n    que.push(S(P(s.first, s.second), i, dist[s.first][s.second][i]));\n  }\n  while(!que.empty()){\n    S u = que.top(); que.pop();\n    int uy = u.p.first;\n    int ux = u.p.second;\n    if(dist[uy][ux][u.fd] < u.c) continue;\n    for(int i=0;i<4;i++){\n      int ny = uy + dy2[i];\n      int nx = ux + dx2[i];\n      if(ny < 0 || ny+1 >= h) continue;\n      if(nx < 0 || nx+1 >= w) continue;\n      if(pz[ny][nx] == '*' || pz[ny+1][nx] == '*' || pz[ny][nx+1] == '*' || pz[ny+1][nx+1] == '*') continue;\n      int nc = cost[uy][ux][u.fd][i];\n      int nfd = (1 - i / 2) * 2 + i % 2;\n      if(dist[ny][nx][nfd] > dist[uy][ux][u.fd] + nc + 1){\n        dist[ny][nx][nfd] = dist[uy][ux][u.fd] + nc + 1;\n        que.push(S(P(ny, nx), nfd, dist[ny][nx][nfd]));\n      }\n    }\n  }\n  int res = INF;\n  for(int i=0;i<4;i++) res = min(res, dist[0][0][i]);\n  return res == INF ? -1 : res;\n}\n\nmain(){\n  while(cin >> h >> w && (h|w)){\n    P s, p1, p2;\n    s = p1 = p2 = P(-1, -1);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> pz[i][j];\n        if(pz[i][j] == 'X' && s.first == -1) s = P(i, j);\n        if(pz[i][j] == '.'){\n          if(p1.first == -1) p1 = P(i, j);\n          else if(p2.first == -1) p2 = P(i, j);\n        }\n      }\n    }\n    if(pz[0][0] == 'X'){\n      cout << 0 << endl;\n      continue;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int f=0;f<4;f++){\n          for(int t=0;t<4;t++){\n            cost[i][j][f][t] = calc(i, j, P(i+dy[f*2], j+dx[f*2]), P(i+dy[f*2+1], j+dx[f*2+1]), t);\n          }\n        }\n      }\n    }\n    cout << solve(s, p1, p2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \n // RLDU\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint ex[] = {0, 1, 0, 1};\nint ey[] = {0, 0, 1, 1};\n\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int MAXH = 51;\nconst int MAXW = 51;\n\n#define fprintf(...) void(0)\n\nint H, W;\nint dist[55][55][4];\nint cost[55][55];\n\nvector< vector<int> > nbx = { {0, 1}, {0, 1}, {2, 2}, {-1, -1} };\nvector< vector<int> > nby = { {2, 2}, {-1, -1}, {0, 1}, {0, 1} };\n\nstruct Elem {\n    int bx, by, dir, cost;\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n\nvoid bfs(const vector<string>& board, int sx, int sy) {\n    fill(cost[0], cost[H+1], INF);\n    cost[sx][sy] = 0;\n\n    queue< pii > que;\n    que.push(make_pair(sx, sy));\n\n    while(que.size()) {\n        int x, y; tie(x, y) = que.front(); que.pop();\n        for(int k=0; k<4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if(board[nx][ny] == '*') continue;\n\n            if(cost[nx][ny] > cost[x][y] + 1) {\n                cost[nx][ny] = cost[x][y] + 1;\n                que.push(make_pair(nx, ny));\n            }\n        }\n    }\n}\n\nint pre_compute(vector<string> board, int dir, int lx, int ly) {\n    // king があるところを壁にする\n    for(int k=0; k<4; k++) {\n        int nx = lx + ex[k], ny = ly + ey[k];\n        board[nx][ny] = '*';\n    }\n\n    vector<pii> init_plc;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == '.') {\n                init_plc.push_back(make_pair(i, j));\n            }\n        }\n    }\n\n    int rec[2][2] = {};\n    for(int i=0; i<2; i++) {\n        int x, y; tie(x, y) = init_plc[i];\n        bfs(board, x, y);\n        for(int k=0; k<2; k++) {\n            int nx = lx + nbx[dir][k];\n            int ny = ly + nby[dir][k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) rec[i][k] = INF;\n            else rec[i][k] = cost[nx][ny];\n\n            fprintf(stderr, \"(%lld, %lld) -> (%lld, %lld): cost = %lld\\n\", x, y, nx, ny, rec[i][k]);\n        }\n    }\n\n    int vl = rec[0][0] + rec[1][1];\n    int vr = rec[0][1] + rec[1][0];\n    int res = min(vl, vr);\n    if(res >= INF) return -1;\n    else return res;\n}\n\nint compute(vector<string>& wall_only, int lx, int ly, int dir, int n_dir) {\n    // king があるところを壁にする\n    for(int k=0; k<4; k++) {\n        int nx = lx + ex[k], ny = ly + ey[k];\n        wall_only[nx][ny] = '*';\n    }\n\n    int rec[2][2] = {};\n    queue<pii> que;\n    for(int i=0; i<2; i++) {\n        int x = lx + nbx[dir][i];\n        int y = ly + nby[dir][i];\n\n        bfs(wall_only, x, y);\n        for(int k=0; k<2; k++) {\n            int nx = lx + nbx[n_dir][k];\n            int ny = ly + nby[n_dir][k];\n            if(nx < 0 || nx >= H || ny < 0 || ny >= W) rec[i][k] = INF;\n            else rec[i][k] = cost[nx][ny];\n        }\n    }\n\n    // 壁にしたところを元に戻す\n    for(int k=0; k<4; k++) {\n        int nx = lx + ex[k], ny = ly + ey[k];\n        wall_only[nx][ny] = '.';\n    }\n\n    int vl = rec[0][0] + rec[1][1];\n    int vr = rec[0][1] + rec[1][0];\n    int res = min(vl, vr);\n    if(res >= INF) return -1;\n    else return res;\n}\n\nsigned main() {\n    while(cin >> H >> W, H) {\n        int lx = -1, ly = -1;\n        fill(dist[0][0], dist[MAXH + 1][MAXH + 1], INF);\n\n        vector<string> board(H, string(W, '.')), wall_only(H, string(W, '.'));\n        for(int i=0; i<H; i++) {\n            cin >> board[i];\n\n            for(int j=0; j<W; j++) {\n                if(board[i][j] == '*') {\n                    wall_only[i][j] = '*';\n                }\n\n                // 左上\n                if(board[i][j] == 'X' && lx < 0) {\n                    lx = i; ly = j;\n                }\n            }\n        }\n\n        priority_queue<Elem> que;\n        for(int k=0; k<4; k++) {\n            int i_cost = pre_compute(board, k, lx, ly);\n            if(i_cost < 0) continue;\n            que.push(Elem{lx, ly, k, i_cost});\n            fprintf(stderr, \"dir = %lld, i_cost = %lld\\n\", k, i_cost);\n            dist[lx][ly][k] = i_cost;\n        }\n\n        while(que.size()) {\n            Elem cur = que.top(); que.pop();\n            int x = cur.bx, y = cur.by;\n\n            int nx = x + dx[cur.dir];\n            int ny = y + dy[cur.dir];\n            int cost = cur.cost + 1;\n            fprintf(stderr, \"nx = %lld, ny = %lld, cost = %lld\\n\", nx, ny, cost);\n\n            int rest_dir = cur.dir ^ 1;\n            for(int k=0; k<4; k++) {\n                int n_cost;\n                if(k == rest_dir) {\n                    n_cost = cost;\n                }\n                else {\n                    // (nx, ny) に king が置いてあって、\n                    // rest_dir 方向があいている状態から\n                    // k 方向をあけるために必要なコスト\n                    int add_cost = compute(wall_only, nx, ny, rest_dir, k);\n                    fprintf(stderr, \"nx = %lld, ny = %lld, dir = %lld, nxt_dir = %lld, cost = %lld\\n\", nx, ny, rest_dir, k, add_cost);\n                    if(add_cost < 0) continue;\n                    else n_cost = cost + add_cost;\n                }\n\n                if(dist[nx][ny][k] > n_cost) {\n                    dist[nx][ny][k] = n_cost;\n                    que.push(Elem{nx, ny, k, n_cost});\n                }\n            }\n        }\n\n        int ans = INF;\n        if(lx == 0 && ly == 0) ans = 0;\n        for(int k=0; k<4; k++) {\n            fprintf(stderr, \"k = %lld, cand = %lld\\n\", k, dist[0][0][k]);\n            ans = min(ans, dist[0][0][k]);\n        }\n        cout << (ans == INF ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<queue>\n#include<tuple>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int t,y,x,s;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n  \nint H,W;\nchar g[52][52];\nint INF=1e9;\n\nvector<int> to_pos(int py1,int px1,int ky,int kx){\n  vector<int> ps(8,INF);\n  queue<tuple<int,int,int> > que1;\n  que1.push(make_tuple(0,py1,px1));\n  bool u1[50][50]={};\n  while(!que1.empty()){\n    int t1,y1,x1;\n    tie(t1,y1,x1)=que1.front();\n    que1.pop();\n    if(u1[y1][x1]++)continue;\n    for(int i=0;i<8;i++){\n      static int dy[]={-1,-1,0,1,2,2,1,0};\n      static int dx[]={0,1,2,2,1,0,-1,-1};\n      if(y1==ky+dy[i]&&x1==kx+dx[i]){\n\tps[i]=t1;\n      }\n    }\n    for(int i=0;i<4;i++){\n      const static int d[]={0,1,0,-1,0};\n      int ny=y1+d[i];\n      int nx=x1+d[i+1];\n      if(0<=ny&&ny<H&&0<=nx&&nx<W&&g[ny][nx]!='*'&&!(ky<=ny&&ny<ky+2&&kx<=nx&&nx<kx+2)){\n\tque1.push(make_tuple(t1+1,ny,nx));\n      }\n    }\n  }\n  return ps;\n}\n\nvector<int> move_pawns(int py1,int px1,int py2,int px2,int ky,int kx){\n  auto p1=to_pos(py1,px1,ky,kx);\n  auto p2=to_pos(py2,px2,ky,kx);\n  vector<int> r(4);\n  for(int i=0;i<4;i++){\n    r[i]=min(p1[i*2]+p2[i*2+1],p1[i*2+1]+p2[i*2]);\n  }\n  return r;\n}\n\nint main(){\n  for(;cin>>H>>W,H|W;){\n    int ky,kx=-1;\n    int sy1,sx1=-1,sy2,sx2;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='X'){\n\t  if(kx<0){\n\t    ky=i;\n\t    kx=j;\n\t  }\n\t}else if(g[i][j]=='.'){\n\t  if(sx1<0){\n\t    sy1=i;\n\t    sx1=j;\n\t  }else{\n\t    sy2=i;\n\t    sx2=j;\n\t  }\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n    }else{\n      auto r=move_pawns(sy1,sx1,sy2,sx2,ky,kx);\n      priority_queue<S> que;\n      for(int i=0;i<4;i++){\n\tif(r[i]<INF){\n\t  que.push({r[i],ky,kx,i});\n\t}\n      }\n      bool u[50][50][4]={};\n      while(!que.empty()){\n\tauto c=que.top();\n\tif(c.y==0&&c.x==0)break;\n\tque.pop();\n\tif(u[c.y][c.x][c.s]++)continue;\n\tconst static int dy[]={-1,0,1,0};\n\tconst static int dx[]={0,1,0,-1};\n\tque.push({c.t+1,c.y+dy[c.s],c.x+dx[c.s],c.s^2});\n\tconst static int py[][2]={{-1,-1},{0,1},{2,2},{1,0}};\n\tconst static int px[][2]={{0,1},{2,2},{1,0},{-1,-1}};\n\tauto r=move_pawns(c.y+py[c.s][0],c.x+px[c.s][0],c.y+py[c.s][1],c.x+px[c.s][1],c.y,c.x);\n\tfor(int i=0;i<4;i++){\n\t  if(r[i]<INF){\n\t    que.push({c.t+r[i],c.y,c.x,i});\n\t  }\n\t}\n      }\n      cout<<(que.empty()?-1:que.top().t)<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nstruct S{\nint x1,y1,x2,y2,x,y,step;\n}t,que[1500000];\n\nchar mp[50][51];\nbool vis[1500000];\nint tot,nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}},head[1500000],nxtval[1500000];\n\nlong long val[1500000];\n\nint getval()\n{\n    int x1=t.x1,x2=t.x2,y1=t.y1,y2=t.y2;\n\n    if(x1>x2)\n    {\n        swap(x1,x2);\n        swap(y1,y2);\n    }\n    else if(x1==x2 && y1>y2)\n    {\n        swap(x1,x2);\n        swap(y1,y2);\n    }\n\n    long long res=(long long)x1*50+y1;\n\n    res=res*50+x2;\n    res=res*50+y2;\n    res=res*50+t.x;\n    res=res*50+t.y;\n\n    int temp=int(res%1500000);\n\n    for(int e=head[temp];e!=-1;e=nxtval[e])\n    {\n        if(val[e]==res) return e;\n    }\n\n    val[tot]=res;\n    nxtval[tot]=head[temp];\n    head[temp]=tot;\n\n    return tot++;\n}\n\nbool check()\n{\n    if(t.x1==t.x2 && t.y1==t.y2) return 0;\n\n    if(mp[t.x1][t.y1]=='*') return 0;\n    if(mp[t.x2][t.y2]=='*') return 0;\n\n    if(t.x1==t.x && t.y1==t.y) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y) return 0;\n    if(t.x1==t.x && t.y1==t.y+1) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y+1) return 0;\n\n    if(t.x2==t.x && t.y2==t.y) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y) return 0;\n    if(t.x2==t.x && t.y2==t.y+1) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y+1) return 0;\n\n    return 1;\n}\n\nbool px(S &p)\n{\n    if(p.x1>p.x2)\n    {\n        swap(p.x1,p.x2);\n        swap(p.y1,p.y2);\n    }\n    else if(p.x1==p.x2 && p.y1>p.y2)\n    {\n        swap(p.x1,p.x2);\n        swap(p.y1,p.y2);\n    }\n}\n\nint main()\n{\n    int n,m,i,j,cnt,top,bottom;\n    bool flag;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<n;i++) scanf(\"%s\",mp[i]);\n\n        cnt=0;\n        flag=0;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++)\n        {\n            if(mp[i][j]=='.')\n            {\n                if(!cnt) t.x1=i,t.y1=j,cnt++;\n                else t.x2=i,t.y2=j;\n            }\n            else if(mp[i][j]=='X' && !flag)\n            {\n                t.x=i,t.y=j;\n\n                flag=1;\n            }\n        }\n\n        for(i=0;i<1500000;i++) head[i]=-1;\n\n        tot=1;\n\n        memset(vis,0,sizeof vis);\n\n        vis[getval()]=1;\n\n        t.step=0;\n\n        top=0;\n        bottom=1;\n\n        que[0]=t;\n\n        while(top<bottom)\n        {\n            t=que[top];\n//printf(\"tot=%d\\n\",tot);\n            if(!t.x && !t.y)\n            {\n                printf(\"%d\\n\",t.step);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t.x1+=nxt[i][0];\n                t.y1+=nxt[i][1];\n\n                if(t.x1>=0 && t.x1<n && t.y1>=0 && t.y1<m && check() && !vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x1-=nxt[i][0];\n                t.y1-=nxt[i][1];\n            }\n\n            for(i=0;i<4;i++)\n            {\n                t.x2+=nxt[i][0];\n                t.y2+=nxt[i][1];\n\n                if(t.x2>=0 && t.x2<n && t.y2>=0 && t.y2<m && check() && !vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x2-=nxt[i][0];\n                t.y2-=nxt[i][1];\n            }\n\n\n            px(t);\n\n            if(t.x1==t.x-1 && t.y1==t.y && t.x2==t.x-1 && t.y2==t.y+1)\n            {\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x+2 && t.y1==t.y && t.x2==t.x+2 && t.y2==t.y+1)\n            {\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y-1 && t.x2==t.x+1 && t.y2==t.y-1)\n            {\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y+2 && t.x2==t.x+1 && t.y2==t.y+2)\n            {\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step++;\n\n                if(!vis[getval()])\n                {\n                    vis[getval()]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step--;\n            }\n        }\n\n        if(top==bottom) printf(\"-1\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n#include <sstream>\n#include <cstring>\n\nusing namespace std;\n\ntemplate<typename T>\nvoid filll_all(T& a, const T& v) { a = v; }\ntemplate<typename A, size_t N, typename T>\nvoid filll_all(A(& a)[N], const T& v) { for (auto& aa : a) { filll_all(aa, v); } }\n\nint H, W;\nstd::string mapmap[60];\nconst int64_t INF = 50505050;\n\nbool is_in(int h, int w) {\n  if (h < 0 || H <= h) {\n    return false;\n  }\n  if (w < 0 || W <= w) {\n    return false;\n  }\n  if (mapmap[h][w] == '*') {\n    return false;\n  }\n  return true;\n}\n\nint64_t dist1[51][51];\nint64_t dist2[51][51];\nvoid distfunc(int h, int w, int starth, int startw, int64_t(&distarray)[51][51]) {\n\n  int64_t(&dist)[51][51] = distarray;\n\n  std::vector<std::pair<int, int>> que;\n  que.push_back({ starth ,startw });\n  filll_all(dist, INF);\n  dist[starth][startw] = 0;\n\n  int count = 0;\n  while (!que.empty()) {\n    ++count;\n    std::vector<std::pair<int, int>> next;\n\n    for (auto& v : que) {\n\n      const int diffh[4] = { -1,0,1,0 };\n      const int diffw[4] = { 0,1,0,-1 };\n\n      for (int i = 0; i < 4; ++i) {\n        int nexth = v.first + diffh[i];\n        int nextw = v.second + diffw[i];\n        if (is_in(nexth, nextw) &&\n            !((h == nexth && w == nextw) || (h + 1 == nexth && w == nextw) || (h == nexth && w + 1 == nextw) || (h + 1 == nexth && w + 1 == nextw))\n            && count < dist[nexth][nextw]) {\n          dist[nexth][nextw] = count;\n          next.push_back({ nexth, nextw });\n        }\n\n      }\n    }\n\n    que = std::move(next);\n  }\n\n\n}\nint64_t dp[51][51][4];\nbool visited[51][51][4];\nint64_t func(int h, int w, int now, int v) {\n\n  priority_queue<pair<pair<long long,int>,pair<int,int> > > pq;\n\n  pq.push({{-v, now}, {h, w}});\n\n  memset(visited, 0, sizeof(visited));\n\n  while(pq.size()) {\n    auto p = pq.top();\n    pq.pop();\n\n    long long v = -p.first.first;\n    int now = p.first.second;\n    int h = p.second.first;\n    int w = p.second.second;\n\n    if (!is_in(h, w)) continue;\n    if (!is_in(h+1, w)) continue;\n    if (!is_in(h, w+1)) continue;\n    if (!is_in(h+1, w+1)) continue;\n\n    if (visited[h][w][now]) continue;\n    visited[h][w][now] = true;\n\n    if (h == 0 && w == 0) {\n      return v;\n    }\n\n    const int diffh0[4] = { -1,0,1,0 };\n    const int diffw0[4] = { 0,1,0,-1 };\n\n    const int diffh2[4] = { -1,1,2,1 };\n    const int diffw2[4] = { 1,2,1,-1 };\n    if (!is_in(h + diffh2[now], w + diffw2[now])) {\n      continue;\n    }\n    distfunc(h, w, h + diffh2[now], w + diffw2[now], dist2);\n\n    const int diffh1[4] = { -1,0,2,0 };\n    const int diffw1[4] = { 0,2,0,-1 };\n    if (!is_in(h + diffh1[now], w + diffw1[now])) {\n      continue;\n    }\n    distfunc(h, w, h + diffh1[now], w + diffw1[now], dist1);\n\n    int dist11[4] = {};\n    int dist12[4] = {};\n    int dist21[4] = {};\n    int dist22[4] = {};\n    for (int next = 0; next < 4; next++)  {\n      int nexth1 = h + diffh1[next];\n      int nextw1 = w + diffw1[next];\n      if (!is_in(nexth1, nextw1)) {\n        continue;\n      }\n      int nexth2 = h + diffh2[next];\n      int nextw2 = w + diffw2[next];\n      if (!is_in(nexth2, nextw2)) {\n        continue;\n      }\n\n      dist11[next] = dist1[h + diffh1[next]][w + diffw1[next]];\n      dist22[next] = dist2[h + diffh2[next]][w + diffw2[next]];\n      dist21[next] = dist2[h + diffh1[next]][w + diffw1[next]];\n      dist12[next] = dist1[h + diffh2[next]][w + diffw2[next]];\n    }\n\n    for (int next = 0; next < 4; next++) {\n      int nexth1 = h + diffh1[next];\n      int nextw1 = w + diffw1[next];\n      if (!is_in(nexth1, nextw1)) {\n        continue;\n      }\n      int nexth2 = h + diffh2[next];\n      int nextw2 = w + diffw2[next];\n      if (!is_in(nexth2, nextw2)) {\n        continue;\n      }\n\n      int64_t nextv = (int64_t)v + std::min(dist11[next] + dist22[next], dist21[next] + dist12[next]) + 1;\n\n      pq.push({{-nextv, next^2}, {h + diffh0[next], w + diffw0[next]}});\n    }\n  }\n\n  return INF;\n}\n\nint main() {\n  while (true) {\n    cin >> H >> W;\n    if (H==0 && W==0) {\n      break;\n    }\n\n    filll_all(dp, (int64_t)-1);\n    for (size_t i = 0; i < H; i++) {\n      cin >> mapmap[i];\n    }\n\n    int defh = -1, defw = -1;\n    for (size_t i = 0; i < H; i++) {\n      for (size_t j = 0; j < W; j++) {\n        if (defh == -1 && mapmap[i][j] == 'X') {\n          defh = i;\n          defw = j;\n        }\n      }\n    }\n\n    if (defh == 0 &&  defw == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    int count = 0;\n    for (size_t i = 0; i < H; i++) {\n      for (size_t j = 0; j < W; j++) {\n        if (mapmap[i][j] == '.') {\n          if (count == 0) {\n            distfunc(defh, defw, i, j, dist1);\n            ++count;\n          } else {\n            distfunc(defh, defw, i, j, dist2);\n          }\n        }\n      }\n    }\n\n    const int diffh2[4] = { -1,1,2,1 };\n    const int diffw2[4] = { 1,2,1,-1 };\n    const int diffh1[4] = { -1,0,2,0 };\n    const int diffw1[4] = { 0,2,0,-1 };\n\n    auto h = defh;\n    auto w = defw;\n    int64_t res = INF;\n    int dist11[4] = {};\n    int dist12[4] = {};\n    int dist21[4] = {};\n    int dist22[4] = {};\n    for (int next = 0; next < 4; next++) {\n      int nexth1 = h + diffh1[next];\n      int nextw1 = w + diffw1[next];\n      if (!is_in(nexth1, nextw1)) {\n        continue;\n      }\n      int nexth2 = h + diffh2[next];\n      int nextw2 = w + diffw2[next];\n      if (!is_in(nexth2, nextw2)) {\n        continue;\n      }\n\n      dist11[next] = dist1[h + diffh1[next]][w + diffw1[next]];\n      dist22[next] = dist2[h + diffh2[next]][w + diffw2[next]];\n      dist21[next] = dist2[h + diffh1[next]][w + diffw1[next]];\n      dist12[next] = dist1[h + diffh2[next]][w + diffw2[next]];\n    }\n\n    for (int next = 0; next < 4; next++) {\n      int nexth1 = h + diffh1[next];\n      int nextw1 = w + diffw1[next];\n      if (!is_in(nexth1, nextw1)) {\n        continue;\n      }\n      int nexth2 = h + diffh2[next];\n      int nextw2 = w + diffw2[next];\n      if (!is_in(nexth2, nextw2)) {\n        continue;\n      }\n\n      long long v = std::min(dist11[next] + dist22[next], dist21[next] + dist12[next]);\n\n      res = min(res, func(h, w, next, v));\n    }\n\n    if (res >= INF) {\n      cout << \"-1\\n\";\n    } else {\n      cout << res << '\\n';\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef vector<int> vint;\n\nint h, w, kingx, kingy;\nchar fd[54][54];\nvector<vpii> G;\nvpii hole0;\n\nint hdy[] = {-1, -1, 0, 1, 2, 2, 1, 0};\nint hdx[] = {0, 1, 2, 2, 1, 0, -1, -1};\nint kdy[] = {-1, 0, 1, 0};\nint kdx[] = {0, 1, 0, -1};\n\nconst int INF = 1000000000;\n\ninline int vindex(int y, int x, int i){\n\treturn (y * w + x) * 4 + i;\n}\n\nvoid calccost(int hy, int hx, vector<vint> &tbl){\n\ttbl.assign(h + 2, vint(w + 2, INF));\n\tif(fd[hy][hx] != 1) return;\n\n\tqueue<int> q;\n\tint t = 1;\n\tq.push(hy << 8 | hx);\n\tq.push(-1);\n\ttbl[hy][hx] = 0;\n\n\twhile(q.size() > 1){\n\t\tif(q.front() == -1){\n\t\t\tq.push(-1);\n\t\t\t++t;\n\t\t}\n\t\telse{\n\t\t\thy = q.front() >> 8;\n\t\t\thx = q.front() & 0xff;\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tint ny = hy + kdy[i];\n\t\t\t\tint nx = hx + kdx[i];\n\t\t\t\tif(fd[ny][nx] == 1 && tbl[ny][nx] == INF){\n\t\t\t\t\ttbl[ny][nx] = t;\n\t\t\t\t\tq.push(ny << 8 | nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\ninline void add_edge(int from, int to, int cost){\n\tG[from].push_back(pii(cost, to));\n}\n\nint solve(){\n\tif(kingy == 1 && kingx == 1) return 0;\n\n\tG.assign(h * w * 4, vpii());\n\n\tvector<vint> tbl[2];\n\tint ty[2], tx[2];\n\n\t//edge from init\n\tfor(int k = 0; k < 2; ++k){\n\t\tint fy = hole0[k].first;\n\t\tint fx = hole0[k].second;\n\t\tcalccost(fy, fx, tbl[k]);\n\t}\n\n\tfor(int i = 0; i < 4; ++i){\n\t\tfor(int k = 0; k < 2; ++k){\n\t\t\tty[k] = kingy + hdy[i * 2 + k];\n\t\t\ttx[k] = kingx + hdx[i * 2 + k];\n\t\t}\n\n\t\tint minsum = INF;\n\t\tfor(int k = 0; k < 2; ++k){\n\t\t\tint sum = tbl[0][ty[k]][tx[k]] + tbl[1][ty[1-k]][tx[1-k]];\n\t\t\tminsum = min(minsum, sum);\n\t\t}\n\t\t\n\t\tif(minsum != INF){\n\t\t\tadd_edge(0, vindex(kingy, kingx, i), minsum);\n\t\t}\n\t}\n\n\tfor(int y = 0; y < 2; ++y)\n\tfor(int x = 0; x < 2; ++x){\n\t\tfd[kingy + y][kingx + x] = 1;\n\t}\n\n\tfor(int y = 1; y < h; ++y){\n\t\tfor(int x = 1; x < w; ++x){\n\t\t\tif(!fd[y][x] || !fd[y+1][x] || !fd[y][x+1] || !fd[y+1][x+1]){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfd[y][x] = fd[y+1][x] = fd[y][x+1] = fd[y+1][x+1] = 2;\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tint idx = vindex(y, x, i);\n\t\t\t\tint nearidx = vindex(y + kdy[i], x + kdx[i], (i + 2) & 3);\n\t\t\t\tadd_edge(idx, nearidx, 1);\n\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\tint fy = y + hdy[i * 2 + k];\n\t\t\t\t\tint fx = x + hdx[i * 2 + k];\n\t\t\t\t\tcalccost(fy, fx, tbl[k]);\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tif(i == j) continue;\n\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tty[k] = y + hdy[j * 2 + k];\n\t\t\t\t\t\ttx[k] = x + hdx[j * 2 + k];\n\t\t\t\t\t}\n\n\t\t\t\t\tint minsum = INF;\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tint sum =\n\t\t\t\t\t\t\ttbl[0][ty[k]][tx[k]] +\n\t\t\t\t\t\t\ttbl[1][ty[1-k]][tx[1-k]];\n\t\t\t\t\t\tminsum = min(minsum, sum);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(minsum != INF){\n\t\t\t\t\t\tadd_edge(idx, vindex(y, x, j), minsum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfd[y][x] = fd[y+1][x] = fd[y][x+1] = fd[y+1][x+1] = 1;\n\t\t}\n\t}\n\n\tpriority_queue<pii,vpii,greater<pii> > pq;\n\tpq.push( pii(0, 0) );\n\tvector<int> mindist(h * w * 4, INF);\n\tmindist[0] = 0;\n\t\n\tint lastv = vindex(1, 1, 0);\n\twhile(!pq.empty()){\n\t\tint c = pq.top().first;\n\t\tint v = pq.top().second;\n\t\tpq.pop();\n\n\t\tif(mindist[v] != c){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(lastv <= v && v <= lastv + 3){\n\t\t\treturn c;\n\t\t}\n\n\t\tfor(int i = 0; i < G[v].size(); ++i){\n\t\t\tint nc = c + G[v][i].first;\n\t\t\tint nv = G[v][i].second;\n\n\t\t\tif(mindist[nv] > nc){\n\t\t\t\tmindist[nv] = nc;\n\t\t\t\tpq.push(pii(nc, nv));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tchar buf[55];\n\twhile(scanf(\"%d%d\", &h, &w), h){\n\t\tmemset(fd, 0, sizeof fd);\n\t\tkingx = kingy = -1;\n\t\thole0.clear();\n\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\" %s\", buf + 1);\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tif(buf[j] == 'o'){\n\t\t\t\t\tfd[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if(buf[j] == 'X'){\n\t\t\t\t\tfd[i][j] = 9;\n\t\t\t\t\tif(kingx == -1){\n\t\t\t\t\t\tkingx = j;\n\t\t\t\t\t\tkingy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(buf[j] == '.'){\n\t\t\t\t\tfd[i][j] = 1;\n\t\t\t\t\thole0.push_back( pii(i, j) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P> P3;\n \nstring s[55];\nint h, w;\n \nint Ady[4]={-1,0,2,1};\nint Adx[4]={0,2,1,-1};\nint Bdy[4]={-1,1,2,0};\nint Bdx[4]={1,2,0,-1};\n \nint bfs(P st, P g){\n  \n  int d[55][55];\n  queue<P3> q;\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) d[i][j]=INF;\n \n  d[st.first][st.second]=0;\n  q.push(P3(0,st));\n \n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n   \n  while(!q.empty()){\n     \n    P3 t=q.front(); q.pop();\n     \n    int cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n     \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(s[ny][nx]=='*') continue;\n      if(d[ny][nx]!=INF) continue;\n      d[ny][nx]=cost+1;\n      q.push(P3(cost+1,P(ny,nx)));\n    }\n     \n  }\n   \n  return d[g.first][g.second];\n}\n \nint min_cost2(P A, P B, P C, P D){\n   \n  int r = bfs(A, B);\n   \n  s[B.first][B.second]='*';\n \n  r+=bfs(C, D);\n \n  s[B.first][B.second]='.';\n   \n  if(r>INF) r=INF;\n   \n  return r;\n}\n \nint min_cost(vector<P> start, P A, P B, P C){\n   \n  int dy[4]={0,0,1,1};\n  int dx[4]={0,1,0,1};\n   \n  P g1=start[0], g2=start[1];\n \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='*';\n \n  int res=INF;\n   \n  res=min(res, min_cost2(A, g1, B, g2));\n  res=min(res, min_cost2(A, g2, B, g1));\n  res=min(res, min_cost2(B, g1, A, g2));\n  res=min(res, min_cost2(B, g2, A, g1));\n   \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='.';\n \n  return res;\n}\n \nint d[55][55][4];\n   \nbool check(P p){\n  if(p.first<0||h<=p.first||p.second<0||w<=p.second) return false;\n  if(s[p.first][p.second]=='*') return false;\n  return true;\n}\n \nvector<P> get(P A, int idx){\n   \n  vector<P> res;\n   \n  res.push_back(P(A.first+Ady[idx], A.second+Adx[idx]));\n  res.push_back(P(A.first+Bdy[idx], A.second+Bdx[idx]));\n   \n  return res;\n}\n \npriority_queue<P2,vector<P2>,greater<P2> > q;\n \nint dijkstra(){\n   \n  int res = INF;\n   \n  while(!q.empty()){\n     \n    P2 t = q.top(); q.pop();\n     \n    int cost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int idx=t.second.second;\n     \n    if(y==0&&x==0) res=min(res, cost);\n \n    if(d[y][x][idx]<cost) continue;\n     \n     \n    for(int i=0;i<4;i++){\n       \n      P A = P(y+Ady[i], x+Adx[i]);\n      P B = P(y+Bdy[i], x+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n \n      vector<P> start=get(P(y,x), idx);\n       \n      if(!check(start[0])||!check(start[1])) continue;\n     \n      int add_cost = min_cost(start,A,B,P(y,x));\n       \n      if(add_cost==INF) continue;\n \n      int dy[4]={-1,0,1,0};\n      int dx[4]={0,1,0,-1};\n       \n      int ny=y+dy[i], nx=x+dx[i];\n      int ncost=cost+add_cost+1;\n \n      if(d[ny][nx][i]>ncost){\n\td[ny][nx][i] = ncost;\n\tq.push(P2(P(ncost,ny),P(nx,(i+2)%4)));\n      }\n       \n    }\n \n  }\n \n  if(res==INF) res=-1;\n   \n  return res;  \n}\n \nint main(){\n   \n  while(1){\n     \n    cin>>h>>w;\n    if(!h&&!w) break;\n \n    vector<P> start;\n    int sy=-1, sx;\n     \n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.')\n\t  start.push_back(P(i,j));\n\tif(sy==-1&&s[i][j]=='X') sy=i, sx=j;\n      }\n    }\n     \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++) d[i][j][k]=INF;\n     \n    for(int i=0;i<4;i++){\n       \n      P A = P(sy+Ady[i], sx+Adx[i]);\n      P B = P(sy+Bdy[i], sx+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n       \n      int cost = min_cost(start,A,B,P(sy,sx));\n       \n      d[sy][sx][i] = cost;\n       \n      q.push(P2(P(cost,sy),P(sx,i)));\n    }\n \n    if(sy==0&&sx==0) cout<<0<<endl;\n    else cout<<dijkstra()<<endl;\n \n    while(!q.empty()) q.pop();\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <utility>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint fie[51][51];\nstruct data{\n\tP k,o[2];\n\tbool operator<(const data &d1)const{\n\t\tif(k!=d1.k)return k<d1.k;\n\t\tif(o[0]!=d1.o[0])return o[0]<d1.o[0];\n\t\treturn o[1]<d1.o[1];\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\ndata moveking(data q,int dir){\n\tif(cross(q.o[0]+P(dx[dir],dy[dir]),q.k) && cross(q.o[1]+P(dx[dir],dy[dir]),q.k)){\n\t\tq.o[0]=q.o[0]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.o[1]=q.o[1]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.k=q.k-P(dx[dir],dy[dir]);\n\t}\n\treturn q;\n}\n\ndata movepawn(data q,int dir,int s){\n\tP nmove=q.o[s]+P(dx[dir],dy[dir]);\n\tif(canmove(nmove) && !same(nmove,q.o[1-s])){\n\t\tif(!cross(nmove,q.k) && fie[nmove.second][nmove.first]!=-1){\n\t\t\tq.o[s]=nmove;\n\t\t}\n\t}\n\treturn q;\n}\n\nmap<data,int> used;\n\nint bfs(data s){\n\tused.clear();\n\tqueue<data> que;\n\tque.push(s);\n\tused[s]=0;\n\twhile(que.size()){\n\t\tdata q=que.front();\n\t\tque.pop();\n\t\tint cost=used[q];\n\t\t//printf(\"%d %d %d %d %d\\n\",cost,q.o[0].first,q.o[0].second,q.o[1].first,q.o[1].second);\n\t\tif(q.k.first+q.k.second==0)return cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdata nq=moveking(q,i);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,0);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,1);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tdata s;\n\t\ts.k.first=s.k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='o')fie[i][j]=1;\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tfie[i][j]=1;\n\t\t\t\t\tif(s.k.first==-1){\n\t\t\t\t\t\ts.k.first=j;\n\t\t\t\t\t\ts.k.second=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\ts.o[cnt].first=j;\n\t\t\t\t\ts.o[cnt++].second=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s.k.first+s.k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",bfs(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint n,m,INF=1<<29,dxx[4]={-1,0,1,0},dyy[4]={0,-1,0,1};\nint dx[8]={-1,-1,0,1,2,2,0,1},dy[8]={0,1,-1,-1,0,1,2,2};\nstring s[55];\nbool check(int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\nbool check(int x,int y,int xx,int yy) {\n  if(x>=0&&x<n&&y>=0&&y<m) {\n    if(s[x][y]=='*') return 0;\n    if(x==xx&&(y==yy||y==yy+1)) return 0;\n    if(x==xx+1&&(y==yy||y==yy+1)) return 0;\n    return 1;\n  }\n  return 0;\n}\n\nint calc(int sx,int sy,int tx,int ty,int xx,int yy) {\n  if(!check(sx,sy,xx,yy)||!check(tx,ty,xx,yy)) return INF;\n  int d[n][m];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++) d[i][j]=INF;\n  d[sx][sy]=0;\n  queue<P> que;\n  que.push(P(sx,sy));\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    for(int i=0; i<4; i++) {\n      int x=p.F+dxx[i],y=p.S+dyy[i];\n      if(!check(x,y,xx,yy)||d[x][y]<=d[p.F][p.S]+1) continue;\n      d[x][y]=d[p.F][p.S]+1;\n      que.push(P(x,y));\n    }\n  }\n  return d[tx][ty];\n}\n\nint main() {\n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<4;k++)d[i][j][k]=INF;\n    vector<P> v;\n    P p=P(-1,-1);\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++) {\n        if(s[i][j]=='.')v.push_back(P(i,j));\n        if(s[i][j]=='X'&&p.F==-1) p=P(i,j);\n      }\n    if(p==P(0,0)) {\n      cout << 0 << endl;\n      continue;\n    }\n    priority_queue<PP,vector<PP>,greater<PP> > que;\n    for(int i=0; i<4; i++) {\n      int b[2]={0,1};\n      do {\n        int cost=calc(v[0].F,v[0].S,p.F+dx[i*2+b[0]],p.S+dy[i*2+b[0]],p.F,p.S);\n        cost+=calc(v[1].F,v[1].S,p.F+dx[i*2+b[1]],p.S+dy[i*2+b[1]],p.F,p.S);\n        d[p.F][p.S][i]=min(d[p.F][p.S][i],cost);\n      } while(next_permutation(b,b+2));\n      que.push(PP(P(0,i),p));\n    }\n    while(!que.empty()) {\n      PP pp=que.top();que.pop();\n      int x=pp.S.F,y=pp.S.S,k=pp.F.S,c=pp.F.F;\n      if(d[x][y][k]<c) continue;\n      for(int i=0; i<4; i++) {\n        int xx=x+dxx[i],yy=y+dyy[i]; \n        int cost=INF;\n        int b[2]={0,1};\n        do {\n          int sum=calc(x+dx[k*2],y+dy[k*2],x+dx[i*2+b[0]],y+dy[i*2+b[0]],x,y);\n          sum+=calc(x+dx[k*2+1],y+dy[k*2+1],x+dx[i*2+b[1]],y+dy[i*2+b[1]],x,y);\n          cost=min(cost,sum);\n        }while(next_permutation(b,b+2));\n        if(!check(xx,yy)||d[xx][yy][(i+2)%4]<=d[x][y][k]+cost+1) continue;\n        d[xx][yy][(i+2)%4]=d[x][y][k]+cost+1;\n        que.push(PP(P(d[xx][yy][(i+2)%4],(i+2)%4),P(xx,yy)));\n      }\n    }\n    int ans=INF;\n    for(int i=0; i<4; i++) ans=min(ans,d[0][0][i]);\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\nconst int inf = (int)1e9;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int sdx1[] = {-1, 0, 2, 1};\nconst int sdy1[] = {0, 2, 1, -1};\nconst int sdx2[] = {-1, 1, 2, 0};\nconst int sdy2[] = {1, 2, 0, -1};\n\ninline int to_state(int x, int y, int dir, int h, int w)\n{ return (x * w + y) * 4 + dir; }\ninline int to_x(int state, int h, int w)\n{ return state / 4 / w; }\ninline int to_y(int state, int h, int w)\n{ return state / 4 % w; }\ninline int to_dir(int state, int h, int w)\n{ return state % 4; }\ninline int to_pos(int x, int y, int h, int w)\n{ return x * w + y; }\ninline int pos_to_x(int pos, int h, int w)\n{ return pos / w; }\ninline int pos_to_y(int pos, int h, int w)\n{ return pos % w; }\ninline bool is_valid(int x, int y, int h, int w)\n{ return x >= 0 && x < h && y >= 0 && y < w; }\n\nvector<int> calc_dist(int start_x, int start_y, int kx, int ky, vector<string> &field)\n{\n\tconst int h = field.size(), w = field[0].size();\n\tvector<int> dist(h * w, inf);\n\tqueue<pair<int, int> > q;\n\n\tq.push({0, to_pos(start_x, start_y, h, w)});\n\n\twhile(!q.empty()) {\n\n\t\tconst int d = q.front().first;\n\t\tconst int pos = q.front().second;\n\t\tq.pop();\n\t\tif(dist[pos] < inf)\n\t\t\tcontinue;\n\t\tdist[pos] = d;\n\n\t\tconst int x = pos_to_x(pos, h, w);\n\t\tconst int y = pos_to_y(pos, h, w);\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tconst int nx = x + dx[i];\n\t\t\tconst int ny = y + dy[i];\n\t\t\tif(!is_valid(nx, ny, h, w))\n\t\t\t\tcontinue;\n\t\t\tif(field[nx][ny] == '*')\n\t\t\t\tcontinue;\n\t\t\tbool ok = true;\n\t\t\tfor(int k = 0; k < 4; ++k) {\n\t\t\t\tif(nx == kx + k / 2 && ny == ky + k % 2)\n\t\t\t\t\tok = false;\n\t\t\t}\n\t\t\tif(ok)\n\t\t\t\tq.push({d + 1, to_pos(nx, ny, h, w)});\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nvoid add_next(int sx1, int sy1, int sx2, int sy2, int x, int y, int dir, int step,\n\tvector<string> &f, priority_queue<pair<int, int> > &q)\n{\n\tconst int h = f.size(), w = f[0].size();\n\tconst vector<int> d1 = calc_dist(sx1, sy1, x, y, f);\n\tconst vector<int> d2 = calc_dist(sx2, sy2, x, y, f);\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tif(i == dir)\n\t\t\tcontinue;\n\t\tconst int nx1 = x + sdx1[i];\n\t\tconst int ny1 = y + sdy1[i];\n\t\tconst int nx2 = x + sdx2[i];\n\t\tconst int ny2 = y + sdy2[i];\n\t\tif(!is_valid(nx1, ny1, h, w) || !is_valid(nx2, ny2, h, w))\n\t\t\tcontinue;\n\t\tconst int len1 = d1[to_pos(nx1, ny1, h, w)] + d2[to_pos(nx2, ny2, h, w)];\n\t\tconst int len2 = d1[to_pos(nx2, ny2, h, w)] + d2[to_pos(nx1, ny1, h, w)];\n\t\tconst int len = min(len1, len2);\n\t\tif(len < inf)\n\t\t\tq.push({-(step + len), to_state(x, y, i, h, w)});\n\t}\n}\n\nint main()\n{\n\twhile(true) {\n\n\t\tint h, w;\n\t\tvector<string> field;\n\t\tint sp1x = -1, sp1y = -1, sp2x = -1, sp2y = -1;\n\t\tint kx = -1, ky = -1;\n\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tif(h == 0)\n\t\t\tbreak;\n\t\tfield.resize(h);\n\t\tfor(int x = 0; x < h; ++x) {\n\t\t\tchar buf[64];\n\t\t\tscanf(\" %s\", buf);\n\t\t\tfield[x] = buf;\n\t\t\tfor(int y = 0; y < w; ++y) {\n\t\t\t\tif(buf[y] == 'X' && kx == -1)\n\t\t\t\t\tkx = x, ky = y;\n\t\t\t\tif(buf[y] == '.') {\n\t\t\t\t\tif(sp1x == -1)\n\t\t\t\t\t\tsp1x = x, sp1y = y;\n\t\t\t\t\telse\n\t\t\t\t\t\tsp2x = x, sp2y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(kx == 0 && ky == 0) {\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<int> cost(h * w * 4, inf);\n\t\tpriority_queue<pair<int, int> > q;\n\n\t\tadd_next(sp1x, sp1y, sp2x, sp2y, kx, ky, -1, 0, field, q);\n\n\t\twhile(!q.empty()) {\n\n\t\t\tconst int step = -q.top().first;\n\t\t\tconst int state = q.top().second;\n\t\t\tq.pop();\n\t\t\tif(cost[state] <= step)\n\t\t\t\tcontinue;\n\t\t\tcost[state] = step;\n\n\t\t\tconst int x = to_x(state, h, w);\n\t\t\tconst int y = to_y(state, h, w);\n\t\t\tconst int dir = to_dir(state, h, w);\n\t\t\t//printf(\"%d, %d, %d -> %d\\n\", x, y, dir, step);\n\n\t\t\tq.push({-(step + 1), to_state(x + dx[dir], y + dy[dir], dir ^ 2, h, w)});\n\n\t\t\tconst int sx1 = x + sdx1[dir], sy1 = y + sdy1[dir];\n\t\t\tconst int sx2 = x + sdx2[dir], sy2 = y + sdy2[dir];\n\n\t\t\tadd_next(sx1, sy1, sx2, sy2, x, y, dir, step, field, q);\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t\tans = min(ans, cost[to_state(0, 0, i, h, w)]);\n\n\t\tprintf(\"%d\\n\", ans < inf ? ans : -1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nbool vis[50][50][9][50][50], occ[55][55];\nint n, m;\nchar s[55][55];\nint dir[4][2]={-1,0,0,1,0,-1,1,0};\nint dir2[8][2]={-1,0,-1,1,0,2,1,2,1,-1,0,-1,2,0,2,1};\n\ninline int get(int x1,int y1,int x2,int y2) {\n    for(int i = 0;i < 8; i++) {\n        int x=dir2[i][0]+x1, y=dir2[i][1]+y1;\n        if(x==x2 && y==y2) return i;\n    }\n    return -1;\n}\n\nstruct PP {\n    int x1,y1,d,x2,y2,step;\n    PP(){}\n    PP(int x1,int y1,int d,int x2,int y2,int step):\n        x1(x1),y1(y1),d(d),x2(x2),y2(y2),step(step){}\n};\n\nqueue<PP> qu, qu2;\n\ninline bool check(int x,int y) {\n    if(x<0||y<0||x>=n||y>=m||occ[x][y]||s[x][y]=='*') return false;\n    return true;\n}\n\ninline void add(int x1,int y1,int d,int x2,int y2,int step) {\n    if(!vis[x1][y1][d][x2][y2]) {\n        vis[x1][y1][d][x2][y2]=1;\n        qu.push(PP(x1,y1,d,x2,y2,step));\n    }\n}\n\nint solve() {\n    int sx = -1, sy;\n    int x1=-1, y1, x2, y2;\n    for(int i = 0;i < n; i++) {\n        for(int j = 0;j < m; j++) {\n            if(s[i][j]=='X') {\n                if(sx==-1) sx = i, sy = j;\n            } else if(s[i][j]=='.') {\n                if(x1==-1) x1 = i, y1 = j;\n                else    x2 = i, y2 = j;\n            }\n        }\n    }\n    if(sx==0 && sy==0) return 0;\n    memset(occ, 0, sizeof(occ));\n    int id1 = get(sx,sy,x1,y1), id2 = get(sx,sy,x2,y2);\n    while(!qu.empty()) {\n        PP cur = qu.front(); qu.pop();\n        vis[cur.x1][cur.y1][cur.d][cur.x2][cur.y2]=false;\n    }\n    while(!qu2.empty()) {\n        PP cur = qu2.front(); qu2.pop();\n        vis[cur.x1][cur.y1][cur.d][cur.x2][cur.y2]=false;\n    }\n    if(id1==-1 && id2==-1) qu.push(PP(x1,y1,8,x2,y2,0)),vis[x1][y1][8][x2][y2]=true;\n    else if(id1==-1) qu.push(PP(sx,sy,id2,x1,y1,0)),vis[sx][sy][id2][x1][y1]=true;\n    else if(id2==-1) qu.push(PP(sx,sy,id1,x2,y2,0)),vis[sx][sy][id1][x2][y2]=true;\n    else    qu.push(PP(sx,sy,id1,x2,y2,0)),vis[sx][sy][id1][x2][y2]=true;\n    while(!qu.empty()) {\n        PP cur = qu.front(); qu.pop();\n        qu2.push(cur);\n        x1=cur.x1;y1=cur.y1;x2=cur.x2;y2=cur.y2;\n        int d = cur.d;\n//        printf(\"x1=%d y1=%d x2=%d y2=%d d=%d step=%d\\n\",x1,y1,x2,y2,d,cur.step);\n        if(d != 8 && x1==0 && y1==0) return cur.step;\n        if(d == 8) {\n            for(int i = 0;i < 4; i++) {\n                int x = x1+dir[i][0];\n                int y = y1+dir[i][1];\n                if(check(x,y)) {\n                    if(x==x2 && y==y2) continue;\n                    int id = get(sx,sy,x,y);\n                    if(id != -1) {\n                        add(sx,sy,id,x2,y2,cur.step+1);\n                    } else {\n                        add(x,y,8,x2,y2,cur.step+1);\n                    }\n                }\n            }\n            for(int i = 0;i < 4; i++) {\n                int x = x2+dir[i][0];\n                int y = y2+dir[i][1];\n                if(check(x,y)) {\n                    if(x==x1 && y==y1) continue;\n                    int id = get(sx,sy,x,y);\n                    if(id != -1)\n                        add(sx,sy,id,x1,y1,cur.step+1);\n                    else\n                        add(x1,y1,8,x,y,cur.step+1);\n                }\n            }\n        } else {\n            int x = x1, y = y1;\n            x1 = x+dir2[d][0]; y1 = y+dir2[d][1];\n            int is = get(x,y,x2,y2);\n            occ[x][y]=occ[x+1][y]=occ[x][y+1]=occ[x+1][y+1]=occ[x1][y1]=occ[x2][y2]=1;\n            for(int i = 0;i < 4; i++) {\n                int xx = x2+dir[i][0];\n                int yy = y2+dir[i][1];\n                if(check(xx,yy)) {\n                    add(x,y,d,xx,yy,cur.step+1);\n                }\n            }\n            if(is != -1) {\n                if(is/2 == d/2) {\n                    int xx=x+dir[d/2][0],yy=y+dir[d/2][1];\n                    add(xx,yy,7-is,xx+dir2[7-d][0],yy+dir2[7-d][1],cur.step+1);\n                }\n                for(int i = 0;i < 4; i++) {\n                    int xx=x1+dir[i][0], yy=y1+dir[i][1];\n                    if(check(xx,yy)) {\n                        add(x,y,is,xx,yy,cur.step+1);\n                    }\n                }\n            }\n            occ[x][y]=occ[x+1][y]=occ[x][y+1]=occ[x+1][y+1]=occ[x1][y1]=occ[x2][y2]=0;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &m) == 2 && n) {\n        for(int i = 0;i < n; i++) scanf(\"%s\", s[i]);\n        printf(\"%d\\n\", solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nbool u[52][52][52][52];\nbool u2[50][50][2][50][50];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    auto inside=[H,W](int y,int x){\n      return 0<=y&&y<H&&0<=x&&x<W;\n    };\n    char g[52][52];\n    int sy[2],sx[2],sn=0;\n    int sky=-1,skx;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='.'){\n\t  sy[sn]=i;\n\t  sx[sn]=j;\n\t  sn++;\n\t}\n\tif(sky<0&&g[i][j]=='X'){\n\t  sky=i;\n\t  skx=j;\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n      continue;\n    }\n    fill(***begin(u),***end(u),false);\n    queue<tuple<int,int,int,int,int> > que;\n    que.push(make_tuple(0,sy[0],sx[0],sy[1],sx[1]));\n    priority_queue<tuple<int,int,int,int,int,int>,vector<tuple<int,int,int,int,int,int> >,greater<tuple<int,int,int,int,int,int> > > que2;\n    while(!que.empty()){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      auto c=que.front();\n      que.pop();\n      int t,y1,x1,y2,x2;\n      tie(t,y1,x1,y2,x2)=c;\n      if(u[y1][x1][y2][x2]++)continue;\n      for(int i=0;i<4;i++){\n\tint ny1=y1+dy[i];\n\tint nx1=x1+dx[i];\n\tint ny2=y2+dy[i];\n\tint nx2=x2+dx[i];\n\tif(inside(ny1,nx1)&&inside(ny2,nx2)&&g[ny1][nx1]=='X'&&g[ny2][nx2]=='X'){\n\t  que2.push(make_tuple(t,min(y1,y2),min(x1,x2),x1!=x2,sky,skx));\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<4;j++){\n\t  int ny1=i?y1+dy[j]:y1;\n\t  int nx1=i?x1+dx[j]:x1;\n\t  int ny2=i?y2:y2+dy[j];\n\t  int nx2=i?x2:x2+dx[j];\n\t  if(!inside(ny1,nx1)||!inside(ny2,nx2)||ny1==ny2&&nx1==nx2||g[ny1][nx1]=='X'||g[ny1][nx1]=='*'||g[ny2][nx2]=='X'||g[ny2][nx2]=='*')continue;\n\t  que.push(make_tuple(t+1,ny1,nx1,ny2,nx2));\n\t}\n      }\n    }\n    fill(****begin(u2),****end(u2),false);\n    while(!que2.empty()){\n      auto c=que2.top();\n      int t,y,x,d,ky,kx;\n      tie(t,y,x,d,ky,kx)=c;\n      if(g[y][x]=='*'||g[y+(d==0)][x+(d==1)]=='*'){\n\tcout<<'E'<<endl;\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<2;j++){\n\t  if(g[ky+i][kx+j]=='*'){\n\t    cout<<'K'<<endl;\n\t  }\n\t}\n      }\n      \n      if(ky==0&&kx==0)break;\n      que2.pop();\n      if(u2[y][x][d][ky][kx]++)continue;\n      //      cout<<ky<<' '<<kx<<endl;\n      for(int i=0;i<6;i++){\n\tstatic int ndy[2][6]={\n\t  {-1,2,0,1,0,1},\n\t  {0,0,1,1,-1,-1}\n\t};\n\tstatic int ndx[2][6]={\n\t  {0,0,-1,-1,1,1},\n\t  {-1,2,0,1,0,1}\n\t};\n\tint cy=y+ndy[d][i];\n\tint cx=x+ndx[d][i];\n\tif(inside(cy,cx)&&g[cy][cx]!='*'&&(cy<ky||ky+2<=cy||cx<kx||kx+2<=cx)){\n\t  static int hdy[2][6]={\n\t    {-1,1,0,1,0,1},\n\t    {0,0,0,0,-1,-1}\n\t  };\n\t  static int hdx[2][6]={\n\t    {0,0,-1,-1,0,0},\n\t    {-1,1,0,1,0,1}\n\t  };\n\t  que2.push(make_tuple(t+2,y+hdy[d][i],x+hdx[d][i],d^(i>=2),ky,kx));\n\t}\n      }\n      if(y==ky&&d==0){\n\tif(kx-1==x){\n\t  que2.push(make_tuple(t+1,y,x+2,d,ky,kx-1));\n\t}else if(kx+2==x){\n\t  que2.push(make_tuple(t+1,y,x-2,d,ky,kx+1));\n\t}\n      }else if(x==kx&&d==1){\n\tif(ky-1==y){\n\t  que2.push(make_tuple(t+1,y+2,x,d,ky-1,kx));\n\t}else if(ky+2==y){\n\t  que2.push(make_tuple(t+1,y-2,x,d,ky+1,kx));\n\t}\n      }\n    }\n    cout<<(que2.empty()?-1:get<0>(que2.top()))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct point{\n\tint x,y;\n\tbool operator<(const point &p)const{ return true; } // dummy\n};\n\nint h,w;\nchar B[52][53];\n\nvector<point> get_space_pos(point king,int dir){\n\tvector<point> res;\n\tint t=king.y,l=king.x,b=king.y+1,r=king.x+1;\n\tif(dir==0) res.push_back((point){r+1,t}), res.push_back((point){r+1,b});\n\tif(dir==1) res.push_back((point){l,t-1}), res.push_back((point){r,t-1});\n\tif(dir==2) res.push_back((point){l-1,t}), res.push_back((point){l-1,b});\n\tif(dir==3) res.push_back((point){l,b+1}), res.push_back((point){r,b+1});\n\treturn res;\n}\n\nint bfs(const point &s,const point &g){\n\tif(B[s.y][s.x]=='*' || B[g.y][g.x]=='*') return INF;\n\n\tstatic int d[52][52];\n\trep(i,h) rep(j,w) d[i][j]=INF;\n\td[s.y][s.x]=0;\n\n\tint head=0,tail=0;\n\tstatic int Q[52*52]; Q[tail++]=s.y*w+s.x;\n\twhile(head<tail){\n\t\tint y=Q[head]/w,x=Q[head]%w; head++;\n\n\t\tif(y==g.y && x==g.x) return d[y][x];\n\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(B[yy][xx]!='*' && d[yy][xx]==INF){\n\t\t\t\td[yy][xx]=d[y][x]+1;\n\t\t\t\tQ[tail++]=yy*w+xx;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INF;\n}\n\n// 2 つの space が p0, p1 にあるとき, これらを p2, p3 に移動させるための最小コスト\nint calc_space_moving_cost(const point &p0,const point &p1,const point &p2,const point &p3,const point king){\n\n\tstatic char tmp[52][53];\n\tmemcpy(tmp,B,sizeof B);\n\n\t// king のマスを障害物にする\n\tB[king.y+0][king.x+0]='*';\n\tB[king.y+0][king.x+1]='*';\n\tB[king.y+1][king.x+0]='*';\n\tB[king.y+1][king.x+1]='*';\n\n\tint d02=bfs(p0,p2);\n\tint d03=bfs(p0,p3);\n\tint d12=bfs(p1,p2);\n\tint d13=bfs(p1,p3);\n// printf(\"  d02 = %d\\n\",d02);\n// printf(\"  d03 = %d\\n\",d03);\n// printf(\"  d12 = %d\\n\",d12);\n// printf(\"  d13 = %d\\n\",d13);\n\n\tmemcpy(B,tmp,sizeof B);\n\n\treturn min(d02+d13,d03+d12);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&h,&w),h){\n\t\trep(j,w+2) B[0][j]='*';\n\t\trep(i,h){\n\t\t\tB[i+1][0]='*';\n\t\t\tscanf(\"%s\",B[i+1]+1);\n\t\t\tB[i+1][w+1]='*';\n\t\t}\n\t\trep(j,w+2) B[h+1][j]='*';\n\t\trep(i,h+2) B[i][w+2]='\\0';\n\t\th+=2;\n\t\tw+=2;\n\n\t\t// king と space の初期位置\n\t\tpoint king0={-1,-1};\n\t\tvector<point> space0;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='X' && king0.x==-1) king0=(point){j,i};\n\t\t\tif(B[i][j]=='.') space0.push_back((point){j,i});\n\t\t}\n\n\t\tif(king0.y==1 && king0.x==1){ puts(\"0\"); continue; }\n\n\t\tstatic int space_cost[52][52][4][4];\n\t\tmemset(space_cost,-1,sizeof space_cost);\n\n\t\t// Dijkstra\n\t\tstatic int d[52][52][4];\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k]=INF;\n\n\t\tint ans=-1;\n\t\tpriority_queue< pair<int,pair<point,int> > > Q; // <-cost,<king の位置,space が king の四方どの向きについているか>>\n\t\trep(dir,4){\n\t\t\tvector<point> space=get_space_pos(king0,dir);\n\t\t\tint cost=calc_space_moving_cost(space0[0],space0[1],space[0],space[1],king0);\n\t\t\tif(cost<INF){\n\t\t\t\td[king0.y][king0.x][dir]=cost;\n\t\t\t\tQ.push(make_pair(-cost,make_pair(king0,dir)));\n\t\t\t}\n\t\t}\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,dir=Q.top().second.second;\n\t\t\tpoint king=Q.top().second.first; Q.pop();\n\n\t\t\tif(d[king.y][king.x][dir]<d_now) continue;\n\n\t\t\tif(king.y==1 && king.x==1){ ans=d_now; break; }\n\n\t\t\t// king を動かす\n\t\t\tpoint king2={king.x+dx[dir],king.y+dy[dir]};\n\t\t\tint dir2=(dir+2)%4;\n\t\t\tif(d[king2.y][king2.x][dir2]>d_now+1){\n\t\t\t\td[king2.y][king2.x][dir2]=d_now+1;\n\t\t\t\tQ.push(make_pair(-(d_now+1),make_pair(king2,dir2)));\n\t\t\t}\n\n\t\t\t// space を動かす\n\t\t\tvector<point> space=get_space_pos(king,dir);\n\t\t\tfor(dir2=0;dir2<4;dir2++) if(dir2!=dir) {\n\t\t\t\tvector<point> space2=get_space_pos(king,dir2);\n\n\t\t\t\tint &cost=space_cost[king.y][king.x][dir][dir2];  // 毎回計算しなおすと遅いので一回計算したものはメモする\n\t\t\t\tif(cost==-1){\n\t\t\t\t\tcost=calc_space_moving_cost(space[0],space[1],space2[0],space2[1],king);\n\t\t\t\t}\n\n\t\t\t\tif(d[king.y][king.x][dir2]>d_now+cost){\n\t\t\t\t\td[king.y][king.x][dir2]=d_now+cost;\n\t\t\t\t\tQ.push(make_pair(-(d_now+cost),make_pair(king,dir2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\ntemplate<typename Functor>\nstruct functor_traits{\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...));\n\ttemplate<typename C,typename Ret,typename Arg,typename... Args>\n\tstatic Arg helper(Ret(C::*)(Arg,Args...)const);\n\ttypedef decltype(helper(&Functor::operator())) first_argument_type;\n};\ntemplate<typename Compare,typename T=typename functor_traits<Compare>::first_argument_type>\npriority_queue<T,vector<T>,Compare> make_priority_queue(Compare comp){\n\treturn priority_queue<T,vector<T>,Compare>(move(comp));\n}\n\nbool in(int h,int w,int i,int j){return 0<=i && i<h && 0<=j && j<w;}\nbool in(int h,int w,pii p){return in(h,w,p.first,p.second);}\n\nint calc(vs grid,pii king,pii a,pii b)\n{\n\tint h=grid.size(),w=grid[0].size();\n\trep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\tvvi dist(h,vi(w,INF));\n\tqueue<tuple<int,int,int>> q;\n\tq.emplace(a.first,a.second,0);\n\twhile(q.size()){\n\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\tif(!in(h,w,i,j) || grid[i][j]=='*' || dist[i][j]!=INF) continue;\n\t\tdist[i][j]=d;\n\t\trep(k,4)\n\t\t\tq.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t}\n\treturn dist[b.first][b.second];\n}\n\nint calc(vs grid,pii king,pii p1,pii p2,pii q1,pii q2)\n{\n\treturn min(calc(grid,king,p1,q1)+calc(grid,king,p2,q2),\n\t\t\t\t\t\t calc(grid,king,p1,q2)+calc(grid,king,p2,q1));\n\t//int h=grid.size(),w=grid[0].size();\n\t//rep(i,2) rep(j,2) grid[king.first+i][king.second+j]='*';\n\t//vvvvi dist(h,vvvi(w,vvi(h,vi(w,INF))));\n\t//queue<tuple<int,int,int,int,int>> q;\n\t//q.emplace(p1.first,p1.second,p2.first,p2.second,0);\n\t//while(q.size()){\n\t//\tint i1,j1,i2,j2,d; tie(i1,j1,i2,j2,d)=q.front(); q.pop();\n\t//\tif(!in(h,w,i1,j1) || !in(h,w,i2,j2) || grid[i1][j1]=='*' || grid[i2][j2]=='*'\n\t//\t|| (i1==i2 && j1==j2) || dist[i1][j1][i2][j2]!=INF) continue;\n\t//\tdist[i1][j1][i2][j2]=dist[i2][j2][i1][j1]=d;\n\t//\trep(k,4){\n\t//\t\tq.emplace(i1+\"\\xff\\x1\\0\\0\"[k],j1+\"\\0\\0\\xff\\x1\"[k],i2,j2,d+1);\n\t//\t\tq.emplace(i1,j1,i2+\"\\xff\\x1\\0\\0\"[k],j2+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t//\t}\n\t//}\n\t//return dist[q1.first][q1.second][q2.first][q2.second];\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t//dump(mp(h,w));\n\t\t//rep(i,h) cout<<grid[i]<<endl;\n\t\t\n\t\tif(grid[0][0]=='X'){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tauto pq=make_priority_queue([](tuple<int,int,int,int> a,tuple<int,int,int,int> b){return get<3>(a)>get<3>(b);});\n\t\t{\n\t\t\tpii king(-1,-1),open1(-1,-1),open2(-1,-1);\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X'){\n\t\t\t\t\tif(king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(grid[i][j]=='.')\n\t\t\t\t\t(open1==mp(-1,-1)?open1:open2)=mp(i,j);\n\t\t\t\telse if(grid[i][j]=='o')\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t}\n\t\t\tint ki=king.first,kj=king.second;\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,calc(grid,king,open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,calc(grid,king,open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,calc(grid,king,open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,calc(grid,king,open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\t\n\t\tvvvi dist(h,vvi(w,vi(4,INF)));\n\t\twhile(pq.size()){\n\t\t\t//if(rand()%1000==0) printf(\"> %d\\n\",pq.size());\n\t\t\tint ki,kj,dir,step; tie(ki,kj,dir,step)=pq.top(); pq.pop();\n\t\t\tif(!in(h,w,ki,kj) || dist[ki][kj][dir]!=INF) continue;\n\t\t\tdist[ki][kj][dir]=step;\n\t\t\tif(step>=INF) break;\n\t\t\t\n\t\t\tpii open1,open2;\n\t\t\tif(dir==0) open1=mp(ki-1,kj),open2=mp(ki-1,kj+1);\n\t\t\tif(dir==1) open1=mp(ki+2,kj),open2=mp(ki+2,kj+1);\n\t\t\tif(dir==2) open1=mp(ki,kj-1),open2=mp(ki+1,kj-1);\n\t\t\tif(dir==3) open1=mp(ki,kj+2),open2=mp(ki+1,kj+2);\n\t\t\t\n\t\t\tpq.emplace(ki+\"\\xff\\x1\\0\\0\"[dir],kj+\"\\0\\0\\xff\\x1\"[dir],dir^1,step+1);\n\t\t\tif(in(h,w,ki-1,kj) && grid[ki-1][kj]!='*' && grid[ki-1][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,0,step+calc(grid,mp(ki,kj),open1,open2,mp(ki-1,kj),mp(ki-1,kj+1)));\n\t\t\tif(in(h,w,ki+2,kj) && grid[ki+2][kj]!='*' && grid[ki+2][kj+1]!='*')\n\t\t\t\tpq.emplace(ki,kj,1,step+calc(grid,mp(ki,kj),open1,open2,mp(ki+2,kj),mp(ki+2,kj+1)));\n\t\t\tif(in(h,w,ki,kj-1) && grid[ki][kj-1]!='*' && grid[ki+1][kj-1]!='*')\n\t\t\t\tpq.emplace(ki,kj,2,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj-1),mp(ki+1,kj-1)));\n\t\t\tif(in(h,w,ki,kj+2) && grid[ki][kj+2]!='*' && grid[ki+1][kj+2]!='*')\n\t\t\t\tpq.emplace(ki,kj,3,step+calc(grid,mp(ki,kj),open1,open2,mp(ki,kj+2),mp(ki+1,kj+2)));\n\t\t}\n\t\tint res=*min_element(all(dist[0][0]));\n\t\tcout<<(res<INF?res:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#define INF 99999999\nusing namespace std;\n\nstruct S{\nint x1,y1,x2,y2,x,y,step;\n\nbool operator<(const S &p) const\n{\n    return step>p.step;\n}\n\n}t1,oldt1;\n\nstruct Q{\nint x1,y1,x2,y2,step;\n}t2,que2[1000000];\n\nchar mp[50][51];\nbool vis2[50][50];\nint n,m,nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}},vis1[50][50];\n\nint h(int fx)\n{\n    int i,j,p,q,ex1,ex2,ey1,ey2,x1,x2,y1,y2,top,bottom;\n\n    switch(fx)\n    {\n        case 0:ex1=oldt1.x+2,ey1=oldt1.y,ex2=oldt1.x+2,ey2=oldt1.y+1;break;\n        case 1:ex1=oldt1.x,ey1=oldt1.y+2,ex2=oldt1.x+1,ey2=oldt1.y+2;break;\n        case 2:ex1=oldt1.x-1,ey1=oldt1.y,ex2=oldt1.x-1,ey2=oldt1.y+1;break;\n        case 3:ex1=oldt1.x,ey1=oldt1.y-1,ex2=oldt1.x+1,ey2=oldt1.y-1;break;\n    }\n\n    return min(abs(t1.x1-ex1)+abs(t1.y1-ey1)+abs(t1.x2-ex2)+abs(t1.y2-ey2),abs(t1.x1-ex2)+abs(t1.y1-ey2)+abs(t1.x2-ex1)+abs(t1.y2-ey1));\n}\n\nint bfs(int fx)\n{\n    int i,j,ex1,ex2,ey1,ey2,top,bottom,res=INF,temp;\n\n    switch(fx)\n    {\n        case 0:ex1=oldt1.x+2,ey1=oldt1.y,ex2=oldt1.x+2,ey2=oldt1.y+1;break;\n        case 1:ex1=oldt1.x,ey1=oldt1.y+2,ex2=oldt1.x+1,ey2=oldt1.y+2;break;\n        case 2:ex1=oldt1.x-1,ey1=oldt1.y,ex2=oldt1.x-1,ey2=oldt1.y+1;break;\n        case 3:ex1=oldt1.x,ey1=oldt1.y-1,ex2=oldt1.x+1,ey2=oldt1.y-1;break;\n    }\n\n    t2.x1=t1.x1;\n    t2.x2=t1.x2;\n    t2.y1=t1.y1;\n    t2.y2=t1.y2;\n\n    for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n    t2.step=0;\n\n    vis2[t2.x1][t2.y1]=1;\n\n    top=0;\n    bottom=1;\n\n    que2[0]=t2;\n\n    while(top<bottom)\n    {\n        t2=que2[top];\n\n        if(t2.x1==ex1 && t2.y1==ey1)\n        {\n            temp=t2.step;\n\n            break;\n        }\n\n        top++;\n\n        for(i=0;i<4;i++)\n        {\n            t2.x1+=nxt[i][0];\n            t2.y1+=nxt[i][1];\n\n            if(t2.x1<0 || t2.x1>n || t2.y1<0 || t2.y1>m) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(mp[t2.x1][t2.y1]=='*') {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(t2.x1==oldt1.x && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n\n            if(!vis2[t2.x1][t2.y1])\n            {\n                t2.step++;\n\n                vis2[t2.x1][t2.y1]=1;\n\n                que2[bottom++]=t2;\n\n                t2.step--;\n            }\n\n\n            t2.x1-=nxt[i][0];\n            t2.y1-=nxt[i][1];\n        }\n    }\n\n    if(top<bottom)\n    {\n\n        t2.x1=ex1;\n        t2.x2=t1.x2;\n        t2.y1=ey1;\n        t2.y2=t1.y2;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n        t2.step=0;\n\n        vis2[t2.x2][t2.y2]=1;\n\n        top=0;\n        bottom=1;\n\n        que2[0]=t2;\n\n        while(top<bottom)\n        {\n            t2=que2[top];\n\n            if(t2.x2==ex2 && t2.y2==ey2)\n            {\n                temp+=t2.step;\n\n                res=min(res,temp);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t2.x2+=nxt[i][0];\n                t2.y2+=nxt[i][1];\n\n                if(t2.x2<0 || t2.x2>n || t2.y2<0 || t2.y2>m) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(mp[t2.x2][t2.y2]=='*') {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(t2.x2==oldt1.x && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n\n                if(!vis2[t2.x2][t2.y2])\n                {\n                    t2.step++;\n\n                    vis2[t2.x2][t2.y2]=1;\n\n                    que2[bottom++]=t2;\n\n                    t2.step--;\n                }\n\n\n                t2.x2-=nxt[i][0];\n                t2.y2-=nxt[i][1];\n            }\n        }\n    }\n\n//----------------------------\n    t2.x1=t1.x1;\n    t2.x2=t1.x2;\n    t2.y1=t1.y1;\n    t2.y2=t1.y2;\n\n    for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n    t2.step=0;\n\n    vis2[t2.x2][t2.y2]=1;\n\n    top=0;\n    bottom=1;\n\n    que2[0]=t2;\n\n    while(top<bottom)\n    {\n        t2=que2[top];\n\n        if(t2.x2==ex2 && t2.y2==ey2)\n        {\n            temp=t2.step;\n\n            break;\n        }\n\n        top++;\n\n        for(i=0;i<4;i++)\n        {\n            t2.x2+=nxt[i][0];\n            t2.y2+=nxt[i][1];\n\n            if(t2.x2<0 || t2.x2>n || t2.y2<0 || t2.y2>m) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(mp[t2.x2][t2.y2]=='*') {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(t2.x2==oldt1.x && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n\n            if(!vis2[t2.x2][t2.y2])\n            {\n                t2.step++;\n\n                vis2[t2.x2][t2.y2]=1;\n\n                que2[bottom++]=t2;\n\n                t2.step--;\n            }\n\n\n            t2.x2-=nxt[i][0];\n            t2.y2-=nxt[i][1];\n        }\n    }\n\n    if(top<bottom)\n    {\n\n        t2.x1=t1.x1;\n        t2.x2=ex2;\n        t2.y1=t1.y1;\n        t2.y2=ey2;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n        t2.step=0;\n\n        vis2[t2.x1][t2.y1]=1;\n\n        top=0;\n        bottom=1;\n\n        que2[0]=t2;\n\n        while(top<bottom)\n        {\n            t2=que2[top];\n\n            if(t2.x1==ex1 && t2.y1==ey1)\n            {\n                temp+=t2.step;\n\n                res=min(res,temp);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t2.x1+=nxt[i][0];\n                t2.y1+=nxt[i][1];\n\n                if(t2.x1<0 || t2.x1>n || t2.y1<0 || t2.y1>m) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(mp[t2.x1][t2.y1]=='*') {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(t2.x1==oldt1.x && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n\n                if(!vis2[t2.x1][t2.y1])\n                {\n                    t2.step++;\n\n                    vis2[t2.x1][t2.y1]=1;\n\n                    que2[bottom++]=t2;\n\n                    t2.step--;\n                }\n\n\n                t2.x1-=nxt[i][0];\n                t2.y1-=nxt[i][1];\n            }\n        }\n    }\n\n//----------------------------------\n//----------------------------------\n\n    t2.x1=t1.x1;\n    t2.x2=t1.x2;\n    t2.y1=t1.y1;\n    t2.y2=t1.y2;\n\n    for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n    t2.step=0;\n\n    vis2[t2.x1][t2.y1]=1;\n\n    top=0;\n    bottom=1;\n\n    que2[0]=t2;\n\n    while(top<bottom)\n    {\n        t2=que2[top];\n\n        if(t2.x1==ex2 && t2.y1==ey2)\n        {\n            temp=t2.step;\n\n            break;\n        }\n\n        top++;\n\n        for(i=0;i<4;i++)\n        {\n            t2.x1+=nxt[i][0];\n            t2.y1+=nxt[i][1];\n\n            if(t2.x1<0 || t2.x1>n || t2.y1<0 || t2.y1>m) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(mp[t2.x1][t2.y1]=='*') {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n            if(t2.x1==oldt1.x && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n            if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n\n            if(!vis2[t2.x1][t2.y1])\n            {\n                t2.step++;\n\n                vis2[t2.x1][t2.y1]=1;\n\n                que2[bottom++]=t2;\n\n                t2.step--;\n            }\n\n\n            t2.x1-=nxt[i][0];\n            t2.y1-=nxt[i][1];\n        }\n    }\n\n    if(top<bottom)\n    {\n\n        t2.x1=ex2;\n        t2.x2=t1.x2;\n        t2.y1=ey2;\n        t2.y2=t1.y2;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n        t2.step=0;\n\n        vis2[t2.x2][t2.y2]=1;\n\n        top=0;\n        bottom=1;\n\n        que2[0]=t2;\n\n        while(top<bottom)\n        {\n            t2=que2[top];\n\n            if(t2.x2==ex1 && t2.y2==ey1)\n            {\n                temp+=t2.step;\n\n                res=min(res,temp);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t2.x2+=nxt[i][0];\n                t2.y2+=nxt[i][1];\n\n                if(t2.x2<0 || t2.x2>n || t2.y2<0 || t2.y2>m) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(mp[t2.x2][t2.y2]=='*') {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n                if(t2.x2==oldt1.x && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n                if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n\n                if(!vis2[t2.x2][t2.y2])\n                {\n                    t2.step++;\n\n                    vis2[t2.x2][t2.y2]=1;\n\n                    que2[bottom++]=t2;\n\n                    t2.step--;\n                }\n\n\n                t2.x2-=nxt[i][0];\n                t2.y2-=nxt[i][1];\n            }\n        }\n    }\n\n//----------------------------\n    t2.x1=t1.x1;\n    t2.x2=t1.x2;\n    t2.y1=t1.y1;\n    t2.y2=t1.y2;\n\n    for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n    t2.step=0;\n\n    vis2[t2.x2][t2.y2]=1;\n\n    top=0;\n    bottom=1;\n\n    que2[0]=t2;\n\n    while(top<bottom)\n    {\n        t2=que2[top];\n\n        if(t2.x2==ex1 && t2.y2==ey1)\n        {\n            temp=t2.step;\n\n            break;\n        }\n\n        top++;\n\n        for(i=0;i<4;i++)\n        {\n            t2.x2+=nxt[i][0];\n            t2.y2+=nxt[i][1];\n\n            if(t2.x2<0 || t2.x2>n || t2.y2<0 || t2.y2>m) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(mp[t2.x2][t2.y2]=='*') {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(t2.x2==oldt1.x && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n            if(t2.x2==oldt1.x+1 && t2.y2==oldt1.y+1) {t2.x2-=nxt[i][0];t2.y2-=nxt[i][1];continue;}\n\n            if(!vis2[t2.x2][t2.y2])\n            {\n                t2.step++;\n\n                vis2[t2.x2][t2.y2]=1;\n\n                que2[bottom++]=t2;\n\n                t2.step--;\n            }\n\n            t2.x2-=nxt[i][0];\n            t2.y2-=nxt[i][1];\n        }\n    }\n\n    if(top<bottom)\n    {\n        t2.x1=t1.x1;\n        t2.x2=ex1;\n        t2.y1=t1.y1;\n        t2.y2=ey1;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++) vis2[i][j]=0;\n\n        t2.step=0;\n\n        vis2[t2.x1][t2.y1]=1;\n\n        top=0;\n        bottom=1;\n\n        que2[0]=t2;\n\n        while(top<bottom)\n        {\n            t2=que2[top];\n\n            if(t2.x1==ex2 && t2.y1==ey2)\n            {\n                temp+=t2.step;\n\n                res=min(res,temp);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t2.x1+=nxt[i][0];\n                t2.y1+=nxt[i][1];\n\n                if(t2.x1<0 || t2.x1>n || t2.y1<0 || t2.y1>m) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(t2.x1==t2.x2 && t2.y1==t2.y2) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(mp[t2.x1][t2.y1]=='*') {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n                if(t2.x1==oldt1.x && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n                if(t2.x1==oldt1.x+1 && t2.y1==oldt1.y+1) {t2.x1-=nxt[i][0];t2.y1-=nxt[i][1];continue;}\n\n\n                if(!vis2[t2.x1][t2.y1])\n                {\n                    t2.step++;\n\n                    vis2[t2.x1][t2.y1]=1;\n\n                    que2[bottom++]=t2;\n\n                    t2.step--;\n                }\n\n\n                t2.x1-=nxt[i][0];\n                t2.y1-=nxt[i][1];\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    int i,j,cnt;\n    bool flag;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<n;i++) scanf(\"%s\",mp[i]);\n\n        cnt=0;\n        flag=0;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++)\n        {\n            if(mp[i][j]=='.')\n            {\n                if(!cnt) t1.x1=i,t1.y1=j,cnt++;\n                else t1.x2=i,t1.y2=j;\n            }\n            else if(mp[i][j]=='X' && !flag)\n            {\n                t1.x=i,t1.y=j;\n\n                flag=1;\n            }\n        }\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++) vis1[i][j]=INF;\n\n        vis1[t1.x][t1.y]=0;\n\n        t1.step=0;\n\n        priority_queue<S>que1;\n\n        que1.push(t1);\n\n        while(!que1.empty())\n        {\n            t1=que1.top();\n\n            if(!t1.x && !t1.y)\n            {\n                printf(\"%d\\n\",t1.step);\n\n                break;\n            }\n\n            que1.pop();\n\n            oldt1=t1;\n\n            for(i=0;i<4;i++)\n            {\n                t1.x+=nxt[i][0];\n                t1.y+=nxt[i][1];\n\n                if(t1.x>=0 && t1.x<n-1 && t1.y>=0 && t1.y<m-1 && mp[t1.x][t1.y]!='*' && mp[t1.x][t1.y+1]!='*' && mp[t1.x+1][t1.y]!='*' && mp[t1.x+1][t1.y+1]!='*')\n                {\n                    int step=bfs(i);\n\n                    if(step<INF)\n                    {\n                        t1.step+=bfs(i)+1;\n\n                        switch(i)\n                        {\n                            case 0:t1.x1=oldt1.x,t1.y1=oldt1.y,t1.x2=oldt1.x,t1.y2=oldt1.y+1;break;\n                            case 1:t1.x1=oldt1.x,t1.y1=oldt1.y,t1.x2=oldt1.x+1,t1.y2=oldt1.y;break;\n                            case 2:t1.x1=oldt1.x+1,t1.y1=oldt1.y,t1.x2=oldt1.x+1,t1.y2=oldt1.y+1;break;\n                            case 3:t1.x1=oldt1.x,t1.y1=oldt1.y+1,t1.x2=oldt1.x+1,t1.y2=oldt1.y+1;break;\n                        }\n\n                        if(t1.step<vis1[t1.x][t1.y])\n                        {\n                            vis1[t1.x][t1.y]=t1.step;\n\n                            que1.push(t1);\n                        }\n                    }\n                }\n\n                t1=oldt1;\n            }\n        }\n\n        if(que1.empty()) printf(\"-1\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar ba[50][50];\n\nstruct P2 {\n  int y1, x1;\n  int y2, x2;\n  P2(int y1, int x1, int y2, int x2) :\n    y1(y1),x1(x1),y2(y2),x2(x2) {}\n};\nint dist2[50][50][50][50];\n\nstruct P {\n  int ky, kx;\n  int py, px;\n  int d;\n  int dist;\n  P(int ky, int kx, int py, int px, int d, int dist) :\n    ky(ky),kx(kx),py(py),px(px),d(d),dist(dist) {}\n  bool operator<(const P &p) const {\n    return dist > p.dist;\n  }\n};\nint dist[50][50][50][50][2];\n\nint &get(const P2 &p) {\n  return dist2[p.y1][p.x1][p.y2][p.x2];\n}\n\nint &get(const P &p) {\n  return dist[p.ky][p.kx][p.py][p.px][p.d];\n}\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nconst int dy2[2][4] = {{0,0,-1,-1},\n                       {0,0,1,1}};\nconst int dx2[2][4] = {{0,1,0,1},\n                       {-1,0,-1,0}};\n\nconst int kdy[4] = {0,0,1,1};\nconst int kdx[4] = {0,1,0,1};\n\nconst int dy3[4] = {0,0,0,1};\nconst int dx3[4] = {0,0,1,0};\n\nint h,w;\n\nbool collideKing(int y, int x, int d, int ky, int kx) {\n  int y2 = y+dy[d];\n  int x2 = x+dx[d];\n  if (!valid(y,x,h,w) || !valid(y2,x2,h,w)) return 1;\n  if (ba[y][x] == '*' || ba[y2][x2] == '*') return 1;\n  REP(i,4) {\n    int kyy = ky+kdy[i];\n    int kxx = kx+kdx[i];\n    if (y==kyy&&x==kxx || y2==kyy&&x2==kxx) return 1;\n  }\n  return 0;\n}\n\nbool okKing(int y, int x) {\n  REP(i,4) {\n    int yy = y+kdy[i];\n    int xx = x+kdx[i];\n    if (!valid(yy,xx,h,w)) return 0;\n    if (ba[yy][xx] == '*') return 0;\n  }\n  return 1;\n}\n\nint countCollide(int y, int x, int d, int ky, int kx) {\n  int y2 = y+dy[d];\n  int x2 = x+dx[d];\n  if (!valid(y,x,h,w) || !valid(y2,x2,h,w)) return 0;\n  int cnt = 0;\n  REP(i,4) {\n    int kyy = ky+kdy[i];\n    int kxx = kx+kdx[i];\n    if (y==kyy&&x==kxx || y2==kyy&&x2==kxx) cnt++;\n  }\n  return cnt;\n}\n\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    int ky=-1, kx;\n    vector<pii> ps;\n    REP(i,h)REP(j,w) {\n      if (ky==-1 && ba[i][j]=='X') {\n        ky = i, kx = j;\n      }\n      if (ba[i][j] == '.') {\n        ps.push_back(pii(i,j));\n      }\n    }\n    assert(ps.size() == 2 && ky != -1);\n\n    if (ky==0 && kx==0) {\n      cout << 0 << endl;\n      continue;\n    }\n    \n    memset(dist, 0x3f, sizeof(dist));\n    priority_queue<P> PQ;\n    \n    queue<P2> Q;\n    memset(dist2,-1,sizeof(dist2));\n    P2 tmp(ps[0].first,ps[0].second,ps[1].first,ps[1].second);\n    Q.push(tmp);\n    get(tmp) = 0;\n    \n    while(!Q.empty()) {\n      P2 p = Q.front(); Q.pop();\n      \n      int cost = get(p);\n      // cout << p.y1 << \" \" << p.x1 << \" , \" << p.y2 << \" \" << p.x2 << endl;\n      if (abs(p.y1-p.y2)+abs(p.x1-p.x2) == 1) {\n        int d = 0;\n        if (p.x1==p.x2) d = 1;\n        P pq(ky,kx,min(p.y1,p.y2),min(p.x1,p.x2),d,cost);\n        if (get(pq) > cost) {\n          PQ.push(pq);\n          get(pq) = cost;\n        }\n      }\n      REP(i,4) {\n        int y = p.y1 + dy[i];\n        int x = p.x1 + dx[i];\n        if (!valid(y,x,h,w) || ba[y][x]=='*' || ba[y][x]=='X') continue;\n        P2 nxt(y,x,p.y2,p.x2);\n        if (get(nxt) == -1) {\n          get(nxt) = cost+1;\n          Q.push(nxt);\n        }\n      }\n      REP(i,4) {\n        int y = p.y2 + dy[i];\n        int x = p.x2 + dx[i];\n        if (!valid(y,x,h,w) || ba[y][x]=='*' || ba[y][x]=='X') continue;\n        P2 nxt(p.y1,p.x1,y,x);\n        if (get(nxt) == -1) {\n          get(nxt) = cost+1;\n          Q.push(nxt);\n        }        \n      }\n    }\n\n    int ans = -1;\n    \n    while(!PQ.empty()) {\n      P p = PQ.top(); PQ.pop();\n\n      if (p.dist > get(p)) continue;\n\n      if (p.ky==0 && p.kx==0) {\n        ans = p.dist;\n        break;\n      }\n\n      // cout << p.ky << \" \" << p.kx << \" \" << p.py << \" \" << p.px << \" \" << p.d << \" \" << p.dist << endl;\n      // pawn\n      // slide\n      REP(i,4) {\n        int y = p.py + dy[i];\n        int x = p.px + dx[i];\n        if (!valid(y,x,h,w) || collideKing(y,x,p.d,p.ky,p.kx) || ba[y][x]=='*') continue;\n        P nxt(p.ky,p.kx,y,x,p.d,p.dist+2);\n        if (get(nxt) > p.dist + 2) {\n          get(nxt) = p.dist + 2;\n          PQ.push(nxt);\n        }\n      }\n      // rotate\n      REP(i,4) {\n        int y = p.py+dy2[p.d][i];\n        int x = p.px+dx2[p.d][i];\n        if (!valid(y,x,h,w) || collideKing(y,x,!p.d,p.ky,p.kx) || ba[y][x]=='*') continue;\n        P nxt(p.ky,p.kx,y,x,!p.d,p.dist+2);\n        if (get(nxt) > p.dist + 2) {\n          get(nxt) = p.dist + 2;\n          PQ.push(nxt);\n        }\n      }   \n      // king\n      REP(i,4) {\n        int y = p.ky + dy[i];\n        int x = p.kx + dx[i];\n        if (countCollide(p.py,p.px,p.d,y,x)!=2) continue;\n        P nxt(y,x,\n              p.ky+dy3[i],p.kx+dx3[i],\n              p.d,p.dist+1);\n\n        if (get(nxt) > p.dist+1) {\n          get(nxt) = p.dist + 1;\n          PQ.push(nxt);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nchar str[60][60];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bfs[60][60];\nint ijk[60][60][4];\nint v[60][60][4];\nint dis[2][2];\nint a,b;\nint calc(vector<pair<int,int> >st,vector<pair<int,int> >go,int xr,int xc){\n\tfor(int l=0;l<2;l++){\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[j][k]=99999999;\n\t\tbfs[st[l].first][st[l].second]=0;\n\t\tqueue<pair<int,int> >Q;\n\t\tQ.push(make_pair(st[l].first,st[l].second));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint tr=row+dx[j];int tc=col+dy[j];\n\t\t\t\tif(tr<0||tc<0||tr>=a||tc>=b)continue;\n\t\t\t\tif(str[tr][tc]=='*')continue;\n\t\t\t\tif(tr==xr&&tc==xc)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc)continue;\n\t\t\t\tif(tr==xr&&tc==xc+1)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc+1)continue;\n\t\t\t\tif(bfs[tr][tc]>bfs[row][col]+1){\n\t\t\t\t\tbfs[tr][tc]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(tr,tc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[l][0]=bfs[go[0].first][go[0].second];\n\t\tdis[l][1]=bfs[go[1].first][go[1].second];\n\t}\n\treturn min(dis[0][0]+dis[1][1],dis[0][1]+dis[1][0]);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++){\n\t\t\tijk[i][j][k]=999999999;\n\t\t\tv[i][j][k]=0;\n\t\t}\n\t\tint sr,sc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tsr=i;sc=j;\n\t\t\t}\n\t\t}\n\t\tsr--;sc--;\n\t\tpriority_queue<pair<int,pair<pair<int,int>,int> > >Q;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tvector<pair<int,int> >st;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(str[j][k]=='.'){\n\t\t\t\tst.push_back(make_pair(j,k));\n\t\t\t}\n\t\t\tvector<pair<int,int> >go;\n\t\t\tif(i==0){go.push_back(make_pair(sr,sc+2));go.push_back(make_pair(sr+1,sc+2));}\n\t\t\tif(i==1){go.push_back(make_pair(sr+2,sc));go.push_back(make_pair(sr+2,sc+1));}\n\t\t\tif(i==2){go.push_back(make_pair(sr,sc-1));go.push_back(make_pair(sr+1,sc-1));}\n\t\t\tif(i==3){go.push_back(make_pair(sr-1,sc));go.push_back(make_pair(sr-1,sc+1));}\n\t\t\tint co=calc(st,go,sr,sc);\n\t\t\tif(co<99999999){\n\t\t\t\tijk[sr][sc][i]=co;\n\t\t\t\tQ.push(make_pair(-co,make_pair(make_pair(sr,sc),i)));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint row=Q.top().second.first.first;\n\t\t\tint col=Q.top().second.first.second;\n\t\t\tint dir=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][dir])continue;\n\t\t\tv[row][col][dir]=1;\n\t\t\tvector<pair<int,int> >st;\n\t\t\tif(dir==0){st.push_back(make_pair(row,col+2));st.push_back(make_pair(row+1,col+2));}\n\t\t\tif(dir==1){st.push_back(make_pair(row+2,col));st.push_back(make_pair(row+2,col+1));}\n\t\t\tif(dir==2){st.push_back(make_pair(row,col-1));st.push_back(make_pair(row+1,col-1));}\n\t\t\tif(dir==3){st.push_back(make_pair(row-1,col));st.push_back(make_pair(row-1,col+1));}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tvector<pair<int,int> >go;\n\t\t\t\tif(i==0){go.push_back(make_pair(row,col+2));go.push_back(make_pair(row+1,col+2));}\n\t\t\t\tif(i==1){go.push_back(make_pair(row+2,col));go.push_back(make_pair(row+2,col+1));}\n\t\t\t\tif(i==2){go.push_back(make_pair(row,col-1));go.push_back(make_pair(row+1,col-1));}\n\t\t\t\tif(i==3){go.push_back(make_pair(row-1,col));go.push_back(make_pair(row-1,col+1));}\n\t\t\t\tint co=calc(st,go,row,col);\n\t\t\t\tif(!v[row][col][i]&&ijk[row][col][i]>cost+co){\n\t\t\t\t\tijk[row][col][i]=cost+co;\n\t\t\t\t\tQ.push(make_pair(-cost-co,make_pair(make_pair(row,col),i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!v[row+dx[dir]][col+dy[dir]][dir^2]&&ijk[row+dx[dir]][col+dy[dir]][dir^2]>cost+1){\n\t\t\t\tijk[row+dx[dir]][col+dy[dir]][dir^2]=cost+1;\n\t\t\t\tQ.push(make_pair(-cost-1,make_pair(make_pair(row+dx[dir],col+dy[dir]),dir^2)));\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tret=min(ret,ijk[0][0][i]);\n\t\t}\n\t\tif(ret>9999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 50\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Data{\n\tData(){\n\t\trow = col = 0;\n\t}\n\tData(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tInfo(Data arg_king,int arg_sum_cost,DIR arg_can_move_dir){\n\t\tking.row = arg_king.row;\n\t\tking.col = arg_king.col;\n\t\tsum_cost = arg_sum_cost;\n\t\tcan_move_dir = arg_can_move_dir;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tData king;\n\tint sum_cost;\n\tDIR can_move_dir;\n};\n\nstruct State{\n\tState(int arg_row,int arg_col,int arg_sum_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint row,col,sum_cost;\n};\n\nint H,W;\nint min_cost[NUM][NUM][4],memo[NUM][NUM][4][4],min_dist[NUM][NUM];\nint diff_row[4] = {-1,0,1,0},diff_col[4] = {0,1,0,-1};\nint diff_row_king[4] = {0,0,1,1},diff_col_king[4] = {0,1,0,1};\nchar base_map[NUM][NUM+1];\nData first_king,first_space[2];\nDIR dir_array[4] = {North,East,South,West},rev_array[4] = {South,West,North,East};\n\nbool rangeCheck(Data data){\n\tif(data.row >= 0 && data.row <= H-1 && data.col >= 0 && data.col <= W-1){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvector<Data> calc_space_loc(Data king,DIR dir){\n\n\tvector<Data> ret;\n\n\tswitch(dir){\n\n\tcase North:\n\t\tret.push_back(Data(king.row-1,king.col));\n\t\tret.push_back(Data(king.row-1,king.col+1));\n\t\tbreak;\n\n\tcase East:\n\t\tret.push_back(Data(king.row,king.col+2));\n\t\tret.push_back(Data(king.row+1,king.col+2));\n\t\tbreak;\n\n\tcase South:\n\t\tret.push_back(Data(king.row+2,king.col));\n\t\tret.push_back(Data(king.row+2,king.col+1));\n\t\tbreak;\n\n\tcase West:\n\t\tret.push_back(Data(king.row,king.col-1));\n\t\tret.push_back(Data(king.row+1,king.col-1));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint dijkstra(Data from, Data to){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tmin_dist[row][col] = BIG_NUM;\n\t\t}\n\t}\n\n\tmin_dist[from.row][from.col] = 0;\n\n\tpriority_queue<State> Q;\n\tQ.push(State(from.row,from.col,0));\n\n\tint next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().row == to.row && Q.top().col == to.col){\n\t\t\treturn Q.top().sum_cost;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tnext_row = Q.top().row+diff_row[i];\n\t\t\tnext_col = Q.top().col+diff_col[i];\n\n\t\t\tif(rangeCheck(Data(next_row,next_col)) == false || base_map[next_row][next_col] == '*')continue;\n\n\t\t\tif(min_dist[next_row][next_col] > Q.top().sum_cost+1){\n\t\t\t\tmin_dist[next_row][next_col] = Q.top().sum_cost+1;\n\t\t\t\tQ.push(State(next_row,next_col,Q.top().sum_cost+1));\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\treturn BIG_NUM;\n}\n\nint calc_move_cost(Data from_1,Data from_2,Data to_1,Data to_2,Data king){\n\n\tif(base_map[to_1.row][to_1.col] == '*' || base_map[to_2.row][to_2.col] =='*')return BIG_NUM;\n\n\t//王のいるマスを、障害マスにする\n\tfor(int i = 0; i < 4; i++){\n\t\tbase_map[king.row+diff_row_king[i]][king.col+diff_col_king[i]] = '*';\n\t}\n\n\tint cost_1,cost_2,cost_3,cost_4;\n\tint ret_1 = BIG_NUM,ret_2 = BIG_NUM;\n\n\tcost_1 = dijkstra(from_1,to_1);\n\tif(cost_1 != BIG_NUM){\n\t\tcost_2 = dijkstra(from_2,to_2);\n\t\tif(cost_2 != BIG_NUM){\n\t\t\tret_1 = cost_1+cost_2;\n\t\t}\n\t}\n\n\tcost_3 = dijkstra(from_1,to_2);\n\tif(cost_3 != BIG_NUM){\n\t\tcost_4 = dijkstra(from_2,to_1);\n\t\tif(cost_4 != BIG_NUM){\n\t\t\tret_2 = cost_3+cost_4;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tbase_map[king.row+diff_row_king[i]][king.col+diff_col_king[i]] = 'X';\n\t}\n\n\treturn min(ret_1,ret_2);\n}\n\nvoid func(){\n\n\tbool FLG = false;\n\tint first_space_index = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\n\t\tif(!FLG){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(base_map[row][col] == 'X'){\n\t\t\t\t\tfirst_king.set(row,col);\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] == '.'){\n\t\t\t\tfirst_space[first_space_index++].set(row,col);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(first_king.row == 0 && first_king.col == 0){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tmin_cost[row][col][a] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<Info> Q;\n\tvector<Data> ret;\n\tint add_cost;\n\n\tfor(int i = 0; i < 4; i++){\n\n\t\tret = calc_space_loc(first_king,dir_array[i]);\n\t\tif(rangeCheck(ret[0]) == false || rangeCheck(ret[1]) == false)continue;\n\n\t\tadd_cost = calc_move_cost(first_space[0],first_space[1],ret[0],ret[1],first_king);\n\t\tif(add_cost == BIG_NUM)continue;\n\n\t\tQ.push(Info(first_king,add_cost,dir_array[i]));\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tfor(int b = 0; b < 4; b++){\n\t\t\t\t\tmemo[row][col][a][b] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tData next_king;\n\tDIR next_can_move_dir;\n\tvector<Data> from_space,to_space;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().king.row == 0 && Q.top().king.col == 0){\n\t\t\tprintf(\"%d\\n\",Q.top().sum_cost);\n\t\t\treturn;\n\t\t}\n\n\t\tnext_king.set(Q.top().king.row+diff_row[Q.top().can_move_dir],Q.top().king.col+diff_col[Q.top().can_move_dir]);\n\t\tnext_can_move_dir = rev_array[Q.top().can_move_dir];\n\n\t\tif(min_cost[next_king.row][next_king.col][next_can_move_dir] > Q.top().sum_cost+1){\n\t\t\tmin_cost[next_king.row][next_king.col][next_can_move_dir] = Q.top().sum_cost+1;\n\t\t\tQ.push(Info(next_king,Q.top().sum_cost+1,next_can_move_dir));\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\tif(Q.top().can_move_dir == dir_array[i])continue;\n\n\t\t\tnext_can_move_dir = dir_array[i];\n\n\t\t\tif(memo[Q.top().king.row][Q.top().king.col][Q.top().can_move_dir][next_can_move_dir] != -1){\n\n\t\t\t\tadd_cost = memo[Q.top().king.row][Q.top().king.col][Q.top().can_move_dir][next_can_move_dir];\n\n\t\t\t}else{\n\n\t\t\t\tfrom_space = calc_space_loc(Q.top().king,Q.top().can_move_dir);\n\t\t\t\tto_space = calc_space_loc(Q.top().king,next_can_move_dir);\n\t\t\t\tif(rangeCheck(to_space[0]) == false || rangeCheck(to_space[1]) == false)continue;\n\n\t\t\t\tadd_cost = calc_move_cost(from_space[0],from_space[1],to_space[0],to_space[1],Q.top().king);\n\n\t\t\t\tmemo[Q.top().king.row][Q.top().king.col][Q.top().can_move_dir][next_can_move_dir] = add_cost;\n\t\t\t}\n\n\t\t\tif(add_cost == BIG_NUM)continue;\n\n\t\t\tif(min_cost[Q.top().king.row][Q.top().king.col][next_can_move_dir] > Q.top().sum_cost+add_cost){\n\t\t\t\tmin_cost[Q.top().king.row][Q.top().king.col][next_can_move_dir] = Q.top().sum_cost+add_cost;\n\t\t\t\tQ.push(Info(Q.top().king,Q.top().sum_cost+add_cost,next_can_move_dir));\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\ntypedef pair<int,PP>iPP;\n#define F first\n#define S second\n\nint h,w;\nint dis[31][31][31][31][8];\nint dp[31][31][8][8];\nint DX[]={0,1,2,2,1,0,-1,-1};\nint DY[]={-1,-1,0,1,2,2,1,0};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[55];\n\nvoid BFS_INIT(){\n    r(i,31)r(j,31)r(k,31)r(l,31)r(q,8)dis[i][j][k][l][q]=1e9;\n    r(i,h-1)r(j,w-1){\n        if(s[i][j]=='*'||s[i][j]=='*'||s[i][j]=='*'||s[i+1][j+1]=='*')continue;\n        set<P>st;\n        r(Y,2)r(X,2)st.insert(P(i+Y,j+X));\n        r(k,8){\n            int y=i+DY[k];\n            int x=j+DX[k];\n            if(y<0||x<0||y>=h||x>=w)continue;\n            if(s[y][x]=='*')continue;\n            dis[i][j][y][x][k]=0;\n            queue<P>q;\n            q.push(P(y,x));\n            //cout<<i<<j<<k<<endl;\n            while(!q.empty()){\n                int y=q.front().F;\n                int x=q.front().S;q.pop();\n                r(l,4){\n                    int ny=y+dy[l];\n                    int nx=x+dx[l];\n                    if(ny<0||nx<0||ny>=h||nx>=w)continue;\n                    if(s[ny][nx]=='*')continue;\n                    if(st.count(P(ny,nx)))continue;\n                    if(dis[i][j][ny][nx][k]!=1e9)continue;\n                    dis[i][j][ny][nx][k]=dis[i][j][y][x][k]+1;\n                    //cout<<i<<' '<<j<<' '<<ny<<' '<<nx<<' '<<k<<endl;\n                    q.push(P(ny,nx));\n                }\n            }\n        }\n    }\n}\n\nvoid STATE_INIT(){\n    int sx1,sx2,sy1,sy2,c=0,cnt=0,sx,sy;\n    r(i,31)r(j,31)r(k,8)r(l,8)dp[i][j][k][l]=1e9;\n    r(i,h)r(j,w){\n        if(s[i][j]=='.'){\n            if(!c)sx1=j,sy1=i,c++;\n            else sx2=j,sy2=i;\n        }\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        int gx1=sx+DX[i];\n        int gy1=sy+DY[i];\n        int gx2=sx+DX[j];\n        int gy2=sy+DY[j];\n        if(gx1<0||gy1<0||gx1>=w||gy1>=h)continue;\n        if(gx2<0||gy2<0||gx2>=w||gy2>=h)continue;\n        //cout<<i<<j<<' '<<dis[sy][sx][sy1][sx1][i]<<' '<<dis[sy][sx][sy2][sx2][j]<<endl;\n        if(dis[sy][sx][sy1][sx1][i]==1e9)continue;\n        if(dis[sy][sx][sy2][sx2][i]==1e9)continue;\n        dp[sy][sx][i][j]=dis[sy][sx][sy1][sx1][i]+dis[sy][sx][sy2][sx2][j];\n        dp[sy][sx][i][j]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n        dp[sy][sx][j][i]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n    }\n}\n\nint COST(int y,int x,int a,int b,int A,int B){\n    if(a!=A){\n        int Y=y+DY[a];\n        int X=x+DX[a];\n        return dis[y][x][Y][X][A];\n    }\n    if(b!=B){\n        int Y=y+DY[b];\n        int X=x+DX[b];\n        return dis[y][x][Y][X][B];\n    }\n}\n\nvoid DIJKSTRA(){\n    priority_queue<iPP,vector<iPP>,greater<iPP> >q;\n    int sx,sy,cnt=0;\n    r(i,h)r(j,w){\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        if(dp[sy][sx][i][j]==1e9)continue;\n        //cout<<i<<j<<' '<<dp[sy][sx][i][j]<<endl;\n        q.push(iPP(dp[sy][sx][i][j],PP(P(sy,sx),P(i,j))));\n    }\n    while(!q.empty()){\n        iPP p=q.top();q.pop();\n        int ky=p.S.F.F;\n        int kx=p.S.F.S;\n        int a=p.S.S.F;\n        int b=p.S.S.S;\n        int cost=p.F;\n        if(a==b)continue;\n        //cout<<ky<<' '<<kx<<' '<<a<<' '<<b<<' '<<cost<<endl;\n        if(!kx&&!ky){\n            cout<<cost<<endl;\n            return ;\n        }\n        if(dp[ky][kx][a][b]<cost)continue;\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,i,b)+cost;\n            if(dp[ky][kx][i][b]<=ncost)continue;\n            dp[ky][kx][i][b]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(i,b))));\n        }\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,a,i)+cost;\n            if(dp[ky][kx][a][i]<=ncost)continue;\n            dp[ky][kx][a][i]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(a,i))));\n        }\n        if(a>b)swap(a,b);\n        if(!((a+1==b) && (a%2==0)))continue;\n        //cout<<a<<' '<<b<<' '<<ky<<kx<<endl;\n        if(a==0)ky--,a=4,b=5;\n        else if(a==2)kx++,a=6,b=7;\n        else if(a==4)ky++,a=0,b=1;\n        else if(a==6)kx--,a=2,b=3;\n        int ncost=cost+1;\n        if(dp[ky][kx][a][b]<=ncost)continue;\n        dp[ky][kx][a][b]=ncost;\n        q.push(iPP(ncost,PP(P(ky,kx),P(a,b))));\n    }\n    cout<<-1<<endl;\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        r(i,h)cin>>s[i];\n        if(s[0][0]=='X'){\n            cout<<0<<endl;\n            continue;\n        }\n        BFS_INIT();\n        STATE_INIT();\n        DIJKSTRA();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\nmap< int , int > mp[50][50][50][50];\n\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  \n  if(flg && mp[gy][gx][sy][sx].count(ty*50+tx)>0 ){\n    return mp[gy][gx][sy][sx][ty*50+tx];\n  }\n\n  int d[50][50];\n  \n  int cc=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      d[i][j]=1e8;\n      if( abs(sy-i)<=3 && abs(sx-j)<=3 &&t[i][j]!='*') cc++;\n    }\n  }\n  \n  d[sy][sx]=0;\n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if( abs(y-sy)<=3 && abs(x-sx)<=3 ) cc--;\n    if(flg&&cc==0)break;\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n\n  if(flg)\n    for(int i=-3;i<=3;i++)\n      for(int j=-3;j<=3;j++)\n        if(0<=sy+i&&sy+i<H && 0<=sx+j&&sx+j<W)\n          mp[gy][gx][sy][sx][ (sy+i)*50+sx ]=d[sy+i][sx+j];\n  \n  return d[ty][tx];\n}\n\n\nint solve(int sy,int sx,int sd){\n  int d[50][50][4];\n  fill( (int*)d[0] , (int*)d[50], 1e8);\n  d[sy][sx][sd]=0;\n  queue<int> qy,qx,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qd.push(sd);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int dir=qd.front();qd.pop();\n    if(y==0&&x==0)return d[y][x][dir];\n    for(int i=0;i<4;i++){\n      int ncost=d[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax,true)+calc(y,x,by,bx,By,Bx,true) ,\n                  calc(y,x,ay,ax,By,Bx,true)+calc(y,x,by,bx,Ay,Ax,true) );\n      ncost++;\n      if(d[ny][nx][i]>ncost){\n        d[ny][nx][i]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qd.push(i);\n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    for(int i=0;i<H*W;i++)\n      for(int j=0;j<H*W;j++)\n        mp[i/W][i%W][j/W][j%W].clear();\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sx,sy,py0,px0,ay,ax) + calc(sx,sy,py1,px1,by,bx)\n                    , calc(sx,sy,py0,px0,by,bx) + calc(sx,sy,py1,px1,ay,ax) );\n\n      //      cout<<i<<' '<<cost<<endl;\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nchar str[60][60];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint bfs[60][60];\nint ijk[60][60][4];\nint v[60][60][4];\nint dis[2][2];\nint a,b;\nint calc(vector<pair<int,int> >st,vector<pair<int,int> >go,int xr,int xc){\n\tfor(int l=0;l<2;l++){\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)bfs[j][k]=99999999;\n\t\tbfs[st[l].first][st[l].second]=0;\n\t\tqueue<pair<int,int> >Q;\n\t\tQ.push(make_pair(st[l].first,st[l].second));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint tr=row+dx[j];int tc=col+dy[j];\n\t\t\t\tif(tr<0||tc<0||tr>=a||tc>=b)continue;\n\t\t\t\tif(str[tr][tc]=='*')continue;\n\t\t\t\tif(tr==xr&&tc==xc)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc)continue;\n\t\t\t\tif(tr==xr&&tc==xc+1)continue;\n\t\t\t\tif(tr==xr+1&&tc==xc+1)continue;\n\t\t\t\tif(bfs[tr][tc]>bfs[row][col]+1){\n\t\t\t\t\tbfs[tr][tc]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(tr,tc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[l][0]=bfs[go[0].first][go[0].second];\n\t\tdis[l][1]=bfs[go[1].first][go[1].second];\n\t}\n\treturn min(dis[0][0]+dis[1][1],dis[0][1]+dis[1][0]);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++){\n\t\t\tijk[i][j][k]=999999999;\n\t\t\tv[i][j][k]=0;\n\t\t}\n\t\tint sr,sc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tsr=i;sc=j;\n\t\t\t}\n\t\t}\n\t\tsr--;sc--;\n\t\tpriority_queue<pair<int,pair<pair<int,int>,int> > >Q;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tvector<pair<int,int> >st;\n\t\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)if(str[j][k]=='.'){\n\t\t\t\tst.push_back(make_pair(j,k));\n\t\t\t}\n\t\t\tvector<pair<int,int> >go;\n\t\t\tif(i==0){go.push_back(make_pair(sr,sc+2));go.push_back(make_pair(sr+1,sc+2));}\n\t\t\tif(i==1){go.push_back(make_pair(sr+2,sc));go.push_back(make_pair(sr+2,sc+1));}\n\t\t\tif(i==2){go.push_back(make_pair(sr,sc-1));go.push_back(make_pair(sr+1,sc-1));}\n\t\t\tif(i==3){go.push_back(make_pair(sr-1,sc));go.push_back(make_pair(sr-1,sc+1));}\n\t\t\tint co=calc(st,go,sr,sc);\n\t\t\tif(co<99999999){\n\t\t\t\tijk[sr][sc][i]=co;\n\t\t\t\tQ.push(make_pair(-co,make_pair(make_pair(sr,sc),i)));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint row=Q.top().second.first.first;\n\t\t\tint col=Q.top().second.first.second;\n\t\t\tint dir=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[row][col][dir])continue;\n\t\t\tv[row][col][dir]=1;\n\t\t\tvector<pair<int,int> >st;\n\t\t\tif(dir==0){st.push_back(make_pair(row,col+2));st.push_back(make_pair(row+1,col+2));}\n\t\t\tif(dir==1){st.push_back(make_pair(row+2,col));st.push_back(make_pair(row+2,col+1));}\n\t\t\tif(dir==2){st.push_back(make_pair(row,col-1));st.push_back(make_pair(row+1,col-1));}\n\t\t\tif(dir==3){st.push_back(make_pair(row-1,col));st.push_back(make_pair(row-1,col+1));}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(v[row][col][i])continue;\n\t\t\t\tvector<pair<int,int> >go;\n\t\t\t\tif(i==0){go.push_back(make_pair(row,col+2));go.push_back(make_pair(row+1,col+2));}\n\t\t\t\tif(i==1){go.push_back(make_pair(row+2,col));go.push_back(make_pair(row+2,col+1));}\n\t\t\t\tif(i==2){go.push_back(make_pair(row,col-1));go.push_back(make_pair(row+1,col-1));}\n\t\t\t\tif(i==3){go.push_back(make_pair(row-1,col));go.push_back(make_pair(row-1,col+1));}\n\t\t\t\tint co=calc(st,go,row,col);\n\t\t\t\tif(!v[row][col][i]&&ijk[row][col][i]>cost+co){\n\t\t\t\t\tijk[row][col][i]=cost+co;\n\t\t\t\t\tQ.push(make_pair(-cost-co,make_pair(make_pair(row,col),i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!v[row+dx[dir]][col+dy[dir]][dir^2]&&ijk[row+dx[dir]][col+dy[dir]][dir^2]>cost+1){\n\t\t\t\tijk[row+dx[dir]][col+dy[dir]][dir^2]=cost+1;\n\t\t\t\tQ.push(make_pair(-cost-1,make_pair(make_pair(row+dx[dir],col+dy[dir]),dir^2)));\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tret=min(ret,ijk[0][0][i]);\n\t\t}\n\t\tif(ret>9999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\ntypedef pair<int,PP>iPP;\n#define F first\n#define S second\n\nint h,w;\nint dis[51][51][51][51][8];\nint dp[51][51][8][8];\nint DX[]={0,1,2,2,1,0,-1,-1};\nint DY[]={-1,-1,0,1,2,2,1,0};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[55];\n\nvoid BFS_INIT(){\n    r(i,51)r(j,51)r(k,51)r(l,51)r(q,8)dis[i][j][k][l][q]=1e9;\n    r(i,h-1)r(j,w-1){\n        if(s[i][j]=='*'||s[i][j]=='*'||s[i][j]=='*'||s[i+1][j+1]=='*')continue;\n        set<P>st;\n        r(Y,2)r(X,2)st.insert(P(i+Y,j+X));\n        r(k,8){\n            int y=i+DY[k];\n            int x=j+DX[k];\n            if(y<0||x<0||y>=h||x>=w)continue;\n            dis[i][j][y][x][k]=0;\n            queue<P>q;\n            q.push(P(y,x));\n            //cout<<i<<j<<k<<endl;\n            while(!q.empty()){\n                int y=q.front().F;\n                int x=q.front().S;q.pop();\n                r(l,4){\n                    int ny=y+dy[l];\n                    int nx=x+dx[l];\n                    if(ny<0||nx<0||ny>=h||nx>=w)continue;\n                    if(s[ny][nx]=='*')continue;\n                    if(st.count(P(ny,nx)))continue;\n                    if(dis[i][j][ny][nx][k]!=1e9)continue;\n                    dis[i][j][ny][nx][k]=dis[i][j][y][x][k]+1;\n                    //cout<<i<<' '<<j<<' '<<ny<<' '<<nx<<' '<<k<<endl;\n                    q.push(P(ny,nx));\n                }\n            }\n        }\n    }\n}\n\nvoid STATE_INIT(){\n    int sx1,sx2,sy1,sy2,c=0,cnt=0,sx,sy;\n    r(i,51)r(j,51)r(k,8)r(l,8)dp[i][j][k][l]=1e9;\n    r(i,h)r(j,w){\n        if(s[i][j]=='.'){\n            if(!c)sx1=j,sy1=i,c++;\n            else sx2=j,sy2=i;\n        }\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        int gx1=sx+DX[i];\n        int gy1=sy+DY[i];\n        int gx2=sx+DX[j];\n        int gy2=sy+DY[j];\n        if(gx1<0||gy1<0||gx1>=w||gy1>=h)continue;\n        if(gx2<0||gy2<0||gx2>=w||gy2>=h)continue;\n        //cout<<i<<j<<' '<<dis[sy][sx][sy1][sx1][i]<<' '<<dis[sy][sx][sy2][sx2][j]<<endl;\n        if(dis[sy][sx][sy1][sx1][i]==1e9)continue;\n        if(dis[sy][sx][sy2][sx2][i]==1e9)continue;\n        dp[sy][sx][i][j]=dis[sy][sx][sy1][sx1][i]+dis[sy][sx][sy2][sx2][j];\n        dp[sy][sx][i][j]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n        dp[sy][sx][j][i]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n    }\n}\n\nint COST(int y,int x,int a,int b,int A,int B){\n    if(a!=A){\n        int Y=y+DY[a];\n        int X=x+DX[a];\n        return dis[y][x][Y][X][A];\n    }\n    if(b!=B){\n        int Y=y+DY[b];\n        int X=x+DX[b];\n        return dis[y][x][Y][X][B];\n    }\n}\n\nvoid DIJKSTRA(){\n    priority_queue<iPP,vector<iPP>,greater<iPP> >q;\n    int sx,sy,cnt=0;\n    r(i,h)r(j,w){\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        if(dp[sy][sx][i][j]==1e9)continue;\n        //cout<<i<<j<<' '<<dp[sy][sx][i][j]<<endl;\n        q.push(iPP(dp[sy][sx][i][j],PP(P(sy,sx),P(i,j))));\n    }\n    while(!q.empty()){\n        iPP p=q.top();q.pop();\n        int ky=p.S.F.F;\n        int kx=p.S.F.S;\n        int a=p.S.S.F;\n        int b=p.S.S.S;\n        int cost=p.F;\n        //cout<<ky<<' '<<kx<<' '<<a<<' '<<b<<' '<<cost<<endl;\n        if(!kx&&!ky){\n            cout<<cost<<endl;\n            return ;\n        }\n        if(dp[ky][kx][a][b]<cost)continue;\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,i,b)+cost;\n            if(dp[ky][kx][i][b]<=ncost)continue;\n            dp[ky][kx][i][b]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(i,b))));\n        }\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,a,i)+cost;\n            if(dp[ky][kx][a][i]<=ncost)continue;\n            dp[ky][kx][a][i]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(a,i))));\n        }\n        if(!((a+1==b) && (a%2==0)))continue;\n        //cout<<a<<' '<<b<<' '<<ky<<kx<<endl;\n        if(a==0)ky--,a=4,b=5;\n        else if(a==2)kx++,a=6,b=7;\n        else if(a==4)ky++,a=0,b=1;\n        else if(a==6)kx--,a=2,b=3;\n        int ncost=cost+1;\n        if(dp[ky][kx][a][b]<=ncost)continue;\n        dp[ky][kx][a][b]=ncost;\n        q.push(iPP(ncost,PP(P(ky,kx),P(a,b))));\n    }\n    cout<<-1<<endl;\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        r(i,h)cin>>s[i];\n        BFS_INIT();\n        STATE_INIT();\n        DIJKSTRA();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <string>\n#define INF 1e7\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[4][2]={\n    2,2,\n    0,1,\n    -1,-1,\n    0,1\n};\nint ddy[4][2]={\n    0,1,\n    2,2,\n    0,1,\n    -1,-1\n};\nP operator +(P p1,P p2){\n    return P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n    return P(p1.first-p2.first,p1.second-p2.second);\n}\n \nint h,w;\nint fie[51][51];\nstruct data{\n    int cost,pdir;\n    P k;\n    data(){}\n    data(P kk,int cc,int pp){\n        k=kk;\n        cost=cc;\n        pdir=pp;\n    }\n    bool operator<(const data &d1)const{\n        if(cost!=d1.cost)return cost>d1.cost;\n        if(k!=d1.k)return k>d1.k;\n        return pdir>d1.pdir;\n    }\n};\n \nstruct data2{\n    P k,o[2];\n    data2(){}\n    data2(P kk,P o1,P o2){\n        k=kk;\n        o[0]=o1;\n        o[1]=o2;\n    }\n};\n\nint distp[51][51];\nint move_pawn(P f,P t){\n    for(int i=0;i<50;i++){\n        for(int j=0;j<50;j++){\n            distp[i][j]=INF;\n        }\n    }\n    queue<P> que;\n    que.push(f);\n    distp[f.first][f.second]=0;\n    while(que.size()){\n        P q=que.front();\n        que.pop();\n        if(q==t)return distp[q.first][q.second];\n        for(int i=0;i<4;i++){\n            P nq=q+P(dy[i],dx[i]);\n            if(nq.first>=0 && nq.first<h && nq.second>=0 && nq.second<w){\n                if(distp[nq.first][nq.second]==INF && fie[nq.first][nq.second]!=-1){\n                    distp[nq.first][nq.second]=distp[q.first][q.second]+1;\n                    que.push(P(nq));\n                }\n            }\n        }\n    }\n    return INF;\n}\n \ndata first_moveking(P k,P o1,P o2,int dir){\n    data res;\n    fie[k.first][k.second]=-1;\n    fie[k.first+1][k.second]=-1;\n    fie[k.first][k.second+1]=-1;\n    fie[k.first+1][k.second+1]=-1;\n    int cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n    int cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n    res.cost=min(cost1,cost2)+1;\n    fie[k.first][k.second]=0;\n    fie[k.first+1][k.second]=0;\n    fie[k.first][k.second+1]=0;\n    fie[k.first+1][k.second+1]=0;\n    res.pdir=dir;\n    res.k=k+P(dy[dir],dx[dir]);\n    return res;\n}\n \ndata moveking(data q,int dir){\n    data res;\n    P k=q.k;\n    fie[k.first][k.second]=-1;\n    fie[k.first+1][k.second]=-1;\n    fie[k.first][k.second+1]=-1;\n    fie[k.first+1][k.second+1]=-1;\n    P o1=k+P(ddy[(q.pdir+2)%4][0],ddx[(q.pdir+2)%4][0]);\n    P o2=k+P(ddy[(q.pdir+2)%4][1],ddx[(q.pdir+2)%4][1]);\n    int cost1=move_pawn(o1,k+P(ddy[dir][0],ddx[dir][0]))+move_pawn(o2,k+P(ddy[dir][1],ddx[dir][1]));\n    int cost2=move_pawn(o1,k+P(ddy[dir][1],ddx[dir][1]))+move_pawn(o2,k+P(ddy[dir][0],ddx[dir][0]));\n    res.cost=min(cost1,cost2)+1+q.cost;\n    fie[k.first][k.second]=0;\n    fie[k.first+1][k.second]=0;\n    fie[k.first][k.second+1]=0;\n    fie[k.first+1][k.second+1]=0;\n    res.pdir=dir;\n    res.k=k+P(dy[dir],dx[dir]);\n    return res;\n}\n \nint dist[51][51][4];\nint dijkstra(P s,P o1,P o2){\n    priority_queue<data> que;\n    for(int i=0;i<50;i++){\n        for(int j=0;j<50;j++){\n            for(int k=0;k<4;k++){\n                dist[i][j][k]=INF;\n            }\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(s.second+dx[i]>=0 && s.second+dx[i]<w-1 && s.first+dy[i]>=0 && s.first+dy[i]<h-1){\n            data si=first_moveking(s,o1,o2,i);\n            if(si.cost<INF){\n                que.push(si);\n                dist[si.k.first][si.k.second][si.pdir]=si.cost;\n            }\n        }\n    }\n    while(que.size()){\n        data q=que.top();\n        que.pop();\n        if(q.cost>dist[q.k.first][q.k.second][q.pdir])continue;\n        if(q.k.first+q.k.second==0)return q.cost;\n        for(int i=0;i<4;i++){\n            if(q.k.second+dx[i]>=0 && q.k.second+dx[i]<w-1 && q.k.first+dy[i]>=0 && q.k.first+dy[i]<h-1){\n                data nq=moveking(q,i);\n                if(nq.cost<dist[nq.k.first][nq.k.second][nq.pdir]){\n                    dist[nq.k.first][nq.k.second][nq.pdir]=nq.cost;\n                    que.push(nq);\n                }\n            }\n        }\n    }\n    return -1;\n}\n \nint main(void){\n    while(1){\n        scanf(\"%d %d\",&h,&w);\n        if(h+w==0)break;\n        P k,o[2];\n        k.first=k.second=-1;\n        int cnt=0;\n        memset(fie,0,sizeof(fie));\n        for(int i=0;i<h;i++){\n            string str;\n            cin >> str;\n            for(int j=0;j<w;j++){\n                if(str[j]=='*')fie[i][j]=-1;\n                if(str[j]=='X'){\n                    if(k.first==-1){\n                        k.second=j;\n                        k.first=i;\n                    }\n                }\n                if(str[j]=='.'){\n                    o[cnt].second=j;\n                    o[cnt++].first=i;\n                }\n            }\n        }\n        if(k.first+k.second==0)printf(\"0\\n\");\n        else if(cnt<2)printf(\"-1\\n\");\n        else printf(\"%d\\n\",dijkstra(k,o[0],o[1]));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#define maxn 1000000\nusing namespace std;\n\nstruct S{\nint x1,y1,x2,y2,x,y,step;\n}t,que[1500000];\n\nchar mp[50][51];\nbool vis[1500000];\nint tot,nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}},head[maxn],nxtval[1500000];\n\nlong long val[1500000];\n\nint getval()\n{\n    long long res;\n//printf(\"%d,%d,%d,%d,%d,%d\\n\",t.x1,t.x2,t.y1,t.y2,t.x,t.y);\n    if(t.x1>t.x2)\n    {\n        res=(long long)t.x2*50+t.y2;\n\n        res=res*50+t.x1;\n        res=res*50+t.y1;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n    else if(t.x1==t.x2 && t.y1>t.y2)\n    {\n        res=(long long)t.x2*50+t.y2;\n\n        res=res*50+t.x1;\n        res=res*50+t.y1;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n    else\n    {\n        res=(long long)t.x1*50+t.y1;\n\n        res=res*50+t.x2;\n        res=res*50+t.y2;\n        res=res*50+t.x;\n        res=res*50+t.y;\n    }\n\n    int temp=int(res%maxn);\n\n    for(int e=head[temp];e!=-1;e=nxtval[e])\n    {//printf(\"e=%d,temp=%d,res=%lld\\n\",e,temp,res);\n        if(val[e]==res) return e;\n    }\n\n    val[tot]=res;\n    nxtval[tot]=head[temp];\n    head[temp]=tot;\n\n    return tot++;\n}\n\nbool check()\n{\n    if(t.x1==t.x2 && t.y1==t.y2) return 0;\n\n    if(mp[t.x1][t.y1]=='*') return 0;\n    if(mp[t.x2][t.y2]=='*') return 0;\n\n    if(t.x1==t.x && t.y1==t.y) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y) return 0;\n    if(t.x1==t.x && t.y1==t.y+1) return 0;\n    if(t.x1==t.x+1 && t.y1==t.y+1) return 0;\n\n    if(t.x2==t.x && t.y2==t.y) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y) return 0;\n    if(t.x2==t.x && t.y2==t.y+1) return 0;\n    if(t.x2==t.x+1 && t.y2==t.y+1) return 0;\n\n    return 1;\n}\n\nbool px()\n{\n    if(t.x1>t.x2)\n    {\n        swap(t.x1,t.x2);\n        swap(t.y1,t.y2);\n    }\n    else if(t.x1==t.x2 && t.y1>t.y2)\n    {\n        swap(t.x1,t.x2);\n        swap(t.y1,t.y2);\n    }\n}\n\nint main()\n{\n    int n,m,i,j,cnt,top,bottom,key;\n    bool flag;\n\n    while(~scanf(\"%d%d\",&n,&m) && n+m)\n    {\n        for(i=0;i<n;i++) scanf(\"%s\",mp[i]);\n\n        cnt=0;\n        flag=0;\n\n        for(i=0;i<n;i++) for(j=0;j<m;j++)\n        {\n            if(mp[i][j]=='.')\n            {\n                if(!cnt) t.x1=i,t.y1=j,cnt++;\n                else t.x2=i,t.y2=j;\n            }\n            else if(mp[i][j]=='X' && !flag)\n            {\n                t.x=i,t.y=j;\n\n                flag=1;\n            }\n        }\n\n        for(i=0;i<maxn;i++) head[i]=-1;\n\n        tot=1;\n\n        memset(vis,0,sizeof vis);\n\n        vis[getval()]=1;\n\n        t.step=0;\n\n        top=0;\n        bottom=1;\n\n        que[0]=t;\n\n        while(top<bottom)\n        {\n            t=que[top];\n//puts(\"sss\");\n            if(!t.x && !t.y)\n            {\n                printf(\"%d\\n\",t.step);\n\n                break;\n            }\n\n            top++;\n\n            for(i=0;i<4;i++)\n            {\n                t.x1+=nxt[i][0];\n                t.y1+=nxt[i][1];\n\n                if(t.x1>=0 && t.x1<n && t.y1>=0 && t.y1<m && check())\n                {\n                    key=getval();\n\n                    if(vis[key])\n                    {\n                        t.x1-=nxt[i][0];\n                        t.y1-=nxt[i][1];\n                        continue;\n                    }\n\n                    vis[key]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x1-=nxt[i][0];\n                t.y1-=nxt[i][1];\n            }\n\n            for(i=0;i<4;i++)\n            {\n                t.x2+=nxt[i][0];\n                t.y2+=nxt[i][1];\n\n                if(t.x2>=0 && t.x2<n && t.y2>=0 && t.y2<m && check())\n                {\n                    key=getval();\n\n                    if(vis[key])\n                    {\n                        t.x2-=nxt[i][0];\n                        t.y2-=nxt[i][1];\n                        continue;\n                    }\n\n                    vis[key]=1;\n\n                    t.step++;\n\n                    que[bottom++]=t;\n\n                    t.step--;\n                }\n\n                t.x2-=nxt[i][0];\n                t.y2-=nxt[i][1];\n            }\n\n\n            px();\n\n            if(t.x1==t.x-1 && t.y1==t.y && t.x2==t.x-1 && t.y2==t.y+1)\n            {\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x+2 && t.y1==t.y && t.x2==t.x+2 && t.y2==t.y+1)\n            {\n                t.x++;\n\n                t.x1-=2;\n                t.x2-=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.x--;\n\n                t.x1+=2;\n                t.x2+=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y-1 && t.x2==t.x+1 && t.y2==t.y-1)\n            {\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step--;\n            }\n\n            if(t.x1==t.x && t.y1==t.y+2 && t.x2==t.x+1 && t.y2==t.y+2)\n            {\n                t.y++;\n\n                t.y1-=2;\n                t.y2-=2;\n\n                t.step++;\n\n                key=getval();\n\n                if(!vis[key])\n                {\n                    vis[key]=1;\n\n                    que[bottom++]=t;\n                }\n\n                t.y--;\n\n                t.y1+=2;\n                t.y2+=2;\n\n                t.step--;\n            }\n        }\n\n        if(top==bottom) printf(\"-1\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint bx[4][2] = { {2, 2}, {0, 1}, {-1, -1}, {0, 1}};\nint by[4][2] = { {0, 1}, {2, 2}, {0, 1}, {-1, -1}};\nint from[2][2] = {{0, 1}, {0, 1}};\nint to[2][2] = {{0, 1}, {1, 0}};\nint H, W;\nint bfs(const vector<string>& grid, int sx, int sy, int gx, int gy){\n  queue<int> qx, qy;\n  int d[50][50]; memset(d, -1, sizeof(d));\n  qx.push(sx); qy.push(sy);\n  d[sy][sx] = 0;\n  //printf(\"start %d %d\\n\", sx, sy);\n  //REP(y, H){ cout<<grid[y]<<endl; }\n  while(!qx.empty()){\n    int x = qx.front(); qx.pop();\n    int y = qy.front(); qy.pop();\n    if(x == gx && y == gy) return d[y][x];\n    REP(r, 4){\n      int nx = x + dx[r];\n      int ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] != '*' && d[ny][nx] == -1){\n        d[ny][nx] = d[y][x] + 1;\n        qx.push(nx); qy.push(ny);\n      }\n    }\n  }\n  return INF;\n}\nstruct S{\n  int x, y, r, d;\n  S(int x, int y, int r, int d) : x(x), y(y), r(r), d(d) {}\n  bool operator < (const S& s) const {\n    return d > s.d;\n  }\n  void print(){\n    printf(\"x = %d y = %d r = %d d = %d\\n\", x, y, r, d);\n  }\n};\n\nint main(){\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    vector<string> grid_sub(H, string('.', W));\n    REP(i, H) cin>>grid[i];\n    int sx = W, sy = H;\n    REP(y, H) REP(x, W)if(grid[y][x] == 'X'){\n      sx = min(x, sx); sy = min(sy, y); \n    }\n    if(sx == 0 && sy == 0){\n      cout<<0<<endl;\n      continue;\n    }\n    priority_queue<S> que;\n    bool used[50][50][4] = {};\n    bool output = false;\n    que.push(S(sx, sy, -1, 0));\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(s.x == 0 && s.y == 0){\n        printf(\"%d\\n\", s.d);\n        output = true;\n        break;\n      }\n      if(s.r != -1 && used[s.y][s.x][s.r]) continue;\n      if(s.r != -1) used[s.y][s.x][s.r] = true;\n      //s.print();\n      REP(r, 4){\n        int nx = s.x + dx[r];\n        int ny = s.y + dy[r];\n        bool ok = true;\n        if(!valid(nx, ny, W, H) || !valid(nx + 1, ny + 1, W, H)) continue;\n        REP(dx, 2)REP(dy, 2) if(grid[ny + dy][nx + dx] == '*') ok = false;\n        if(!ok) continue;\n        //printf(\">nx = %d ny = %d r = %d\\n\", nx, ny, r);\n        /* 空白が目的地 */\n        vector<int> tx, ty;\n        if(s.r == -1){ //最初の移動\n          REP(y, H)REP(x, W) if(grid[y][x] == '.'){\n          //printf(\"tx = %d ty = %d\\n\", x, y);\n            tx.push_back(x); ty.push_back(y);\n          }\n        }else{\n          REP(i, 2){\n            tx.push_back(s.x + bx[s.r][i]); ty.push_back(s.y + by[s.r][i]);\n          }\n        }\n        /* 大ピースが進む場所が出発地 */\n        vector<int> fx, fy;\n        REP(i, 2){ fx.push_back(s.x + bx[r][i]); fy.push_back(s.y + by[r][i]); }\n        //REP(i, 2) printf(\"fx = %d fy = %d\\n\", fx[i], fy[i]);\n        int cost = INF;\n        REP(k, 2){\n          //printf(\"> k = %d\\n\", k);\n          REP(y, H)REP(x, W){\n            if(grid[y][x] == '*') grid_sub[y][x] = '*';\n            else if(s.x <= x && x <= s.x + 1 && s.y <= y && y <= s.y + 1) grid_sub[y][x] = '*';\n            else if(grid[y][x] == 'o') grid_sub[y][x] = '.';\n            else grid_sub[y][x] = '.';\n          }\n          int f1 = from[k][0], t1 = to[k][0];\n          int f2 = from[k][1], t2 = to[k][1];\n          int c1 = bfs(grid_sub, fx[f1], fy[f1], tx[t1], ty[t1]);\n          int c2 = bfs(grid_sub, fx[f2], fy[f2], tx[t2], ty[t2]);\n          //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f1], fy[f1], tx[t1], ty[t1], c1);\n          //printf(\"(%d, %d) -> (%d, %d) : %d\\n\", fx[f2], fy[f2], tx[t2], ty[t2], c2);\n          cost = min(cost, c1 + c2 + 1);\n        }\n        if(cost == INF) continue;\n        if(!used[ny][nx][(r + 2) % 4]){\n          que.push(S(nx, ny, (r + 2) % 4, s.d + cost));\n        }\n      }\n    }\n    if(!output) cout<<-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt dp[55][55][4];\nInt mv[55][55][4][4];\nInt di[8][55][55];\nconst Int INF = 1e9;\nsigned main(){\n  Int n,m;\n  while(cin>>n>>m,n){\n    vector<string> s(n);\n    for(Int i=0;i<n;i++) cin>>s[i];\n    auto in=[&](Int y,Int x){\n      return 0<=y&&y<n&&0<=x&&x<m;\n    };\n    using P = pair<Int, Int>;\n    P st;\n    vector<P> sp;\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<m;j++){\n\tif(s[i][j]=='X'){\n\t  assert(s[i][j+1]=='X');\n\t  assert(s[i+1][j]=='X');\n\t  assert(s[i+1][j+1]=='X');\n\t  s[i][j]=s[i][j+1]='o';\n\t  s[i+1][j]=s[i+1][j+1]='o';\n\t  st=P(i,j);\n\t}\n\tif(s[i][j]=='.') sp.emplace_back(i,j);\n      }\n    }\n    if(st==P(0,0)){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    //cout<<st.first<<\" \"<<st.second<<endl;\n    //cout<<sp.size()<<endl;\n    //for(int i=0;i<n;i++) cout<<s[i]<<endl;cout<<endl;\n    \n    auto bfs=[&](Int sy,Int sx){\n      Int ay[]={-1,-1,0,1,2,2,1,0};\n      Int ax[]={0,1,2,2,1,0,-1,-1};\n\n      if(s[sy][sx]=='*'||\n\t !in(sy,sx+1)||s[sy][sx+1]=='*'||\n\t !in(sy+1,sx)||s[sy+1][sx]=='*'||\n\t !in(sy+1,sx+1)||s[sy+1][sx+1]=='*') return;\n      \n      s[sy][sx]=s[sy][sx+1]='*';\n      s[sy+1][sx]=s[sy+1][sx+1]='*';\n      \n      for(Int k=0;k<8;k++){\n\tInt y=sy+ay[k],x=sx+ax[k];\n\tfor(Int i=0;i<55;i++)\n\t  for(Int j=0;j<55;j++)\n\t    di[k][i][j]=INF;\n\tif(!in(y,x)||s[y][x]=='*') continue;\n\tqueue<P> q;\n\tq.emplace(y,x);\n\tdi[k][y][x]=0;\n\tInt dy[]={0,1,0,-1};\n\tInt dx[]={1,0,-1,0};\n\twhile(!q.empty()){\n\t  P p=q.front();q.pop();\n\t  y=p.first;x=p.second;\n\t  for(Int i=0;i<4;i++){\n\t    Int ny=y+dy[i],nx=x+dx[i];\n\t    if(!in(ny,nx)||s[ny][nx]=='*'||di[k][ny][nx]<=di[k][y][x]+1) continue;\n\t    di[k][ny][nx]=di[k][y][x]+1;\n\t    q.emplace(ny,nx);\n\t  }\n\t}\n      }\n      \n      for(Int i=0;i<4;i++){\n\tfor(Int j=0;j<4;j++){\n\t  if(!in(sy+ay[j*2],sx+ax[j*2])||!in(sy+ay[j*2+1],sx+ax[j*2+1])) continue;\n\t  Int a=di[i*2][sy+ay[j*2]][sx+ax[j*2]]+di[i*2+1][sy+ay[j*2+1]][sx+ax[j*2+1]];\n\t  Int b=di[i*2][sy+ay[j*2+1]][sx+ax[j*2+1]]+di[i*2+1][sy+ay[j*2]][sx+ax[j*2]];\n\t  mv[sy][sx][i][j]=min(a,b);\n\t  //cout<<sy<<\" \"<<sx<<\":\"<<i<<\" \"<<j<<\":\"<<mv[sy][sx][i][j]<<endl;;\n\t}\n      }\n      \n      s[sy][sx]=s[sy][sx+1]='o';\n      s[sy+1][sx]=s[sy+1][sx+1]='o';\n    };\n\n    for(Int i=0;i<55;i++)\n      for(Int j=0;j<55;j++)\n\tfor(Int k=0;k<4;k++){\n\t  dp[i][j][k]=INF;\n\t  for(Int l=0;l<4;l++)\n\t    mv[i][j][k][l]=INF;\n\t}\n\t  \n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    bfs(st.first,st.second);\n\n    using T = tuple<Int, Int, Int, Int>;\n    priority_queue<T,vector<T>,greater<T> > pq;\n    for(Int i=0;i<4;i++){\n      Int a=di[i*2][sp[0].first][sp[0].second]+di[i*2+1][sp[1].first][sp[1].second];\n      Int b=di[i*2][sp[1].first][sp[1].second]+di[i*2+1][sp[0].first][sp[0].second];\n      dp[st.first][st.second][i]=min(a,b);\n      if(dp[st.first][st.second][i]<INF)\n\tpq.emplace(dp[st.first][st.second][i],st.first,st.second,i);\n    }\n    while(!pq.empty()){\n      int d,y,x,k;\n      tie(d,y,x,k)=pq.top();pq.pop();\n      if(dp[y][x][k]<d) continue;\n      //cout<<y<<\" \"<<x<<\" \"<<k<<\":\"<<d<<endl;\n      int dy[]={-1,0,1,0};\n      int dx[]={0,1,0,-1};\n      {\n\tint ny=y+dy[k],nx=x+dx[k],nk=(k+2)%4;\n\tif(dp[y][x][k]+1<dp[ny][nx][nk]){\n\t  dp[ny][nx][nk]=dp[y][x][k]+1;\n\t  pq.emplace(dp[ny][nx][nk],ny,nx,nk);\n\t}\n      }\n      for(int i=0;i<4;i++){\n\tint c=mv[y][x][k][i];\n\t//cout<<i<<\":\"<<dp[y][x][i]<<\" \"<<dp[y][x][k]+c<<endl;\n\tif(dp[y][x][i]<=dp[y][x][k]+c) continue;\n\tdp[y][x][i]=dp[y][x][k]+c;\n\tpq.emplace(dp[y][x][i],y,x,i);\n      }\n    }\n    \n    Int ans=min(dp[0][0][1],dp[0][0][2]);\n    if(ans==INF) ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_H\t(50)\n#define MAX_W\t(50)\n#define MAX_HW\t(MAX_H * MAX_W)\n\n#define NBITS\t(12)\n#define NBITS2\t(NBITS * 2)\n#define MASK\t((1 << NBITS) - 1)\n\n#define INF\t(1 << 30)\n\n/* typedef */\n\ntypedef long long ll;\ntypedef map<ll,int> mlli;\ntypedef queue<ll> qll;\n\n/* global variables */\n\nint dxys[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\nbool flds[MAX_HW];\nmlli dists;\nqll q;\nll vs[12];\n\n/* subroutines */\n\ninline ll mkid(ll op0, ll op1, ll kp) {\n  return op0 << NBITS2 | op1 << NBITS | kp;\n}\n\ninline ll getop0(ll id) { return id >> NBITS2; }\ninline ll getop1(ll id) { return (id >> NBITS) & MASK; }\ninline ll getkp(ll id) { return id & MASK; }\n\n/* main */\n\nint main() {\n  for (;;) {\n    int h, w;\n    cin >> h >> w;\n    if ((h | w) == 0) break;\n\n    int hw = h * w;\n    int w2 = w * 2;\n\n    int opos0 = -1, opos1 = -1, kpos = -1;\n    memset(flds, true, sizeof(bool) * MAX_HW);\n  \n    for (int y = 0; y < h; y++) {\n      string line;\n      cin >> line;\n      for (int x = 0; x < w; x++) {\n\tint pos = y * w + x;\n\tswitch (line[x]) {\n\tcase 'X':\n\t  if (kpos < 0) kpos = pos;\n\t  break;\n\tcase '*':\n\t  flds[pos] = false;\n\t  break;\n\tcase '.':\n\t  if (opos0 < 0) opos0 = pos;\n\t  else opos1 = pos;\n\t}\n      }\n    }\n\n    ll st = mkid(opos0, opos1, kpos);\n\n    dists.clear();\n    dists[st] = 0;\n\n    while (! q.empty()) q.pop();\n    q.push(st);\n\n    int min_d = INF;\n\n    while (! q.empty()) {\n      ll u = q.front();\n      q.pop();\n\n      int ud = dists[u];\n      int uk = getkp(u);\n\n      if (uk == 0) {\n\tmin_d = ud;\n\tbreak;\n      }\n\n      int uo0 = getop0(u);\n      int uo1 = getop1(u);\n      if (uo0 >= uo1) {\n\tprintf(\"error: uo0=%d,uo1=%d\\n\", uo0, uo1);\n\texit(0);\n      }\n      \n      int uo0x = uo0 % w;\n      int uo0y = uo0 / w;\n      int uo1x = uo1 % w;\n      int uo1y = uo1 / w;\n      int ukx = uk % w;\n      int uky = uk / w;\n\n      int nvs = 0;\n\n      // move king\n      if (ukx > 0 && uo0 == uk - 1 && uo1 == uk - 1 + w)\n\tvs[nvs++] = mkid(uo0 + 2, uo1 + 2, uk - 1);\n      else if (ukx < w - 2 && uo0 == uk + 2 && uo1 == uk + 2 + w)\n\tvs[nvs++] = mkid(uo0 - 2, uo1 - 2, uk + 1);\n      else if (uky > 0 && uo0 == uk - w && uo1 == uk - w + 1)\n\tvs[nvs++] = mkid(uo0 + w2, uo1 + w2, uk - w);\n      else if (uky < h - 2 && uo0 == uk + 2 * w && uo1 == uk + 2 * w + 1)\n\tvs[nvs++] = mkid(uo0 - w2, uo1 - w2, uk + w);\n\n      int uk1 = uk + 1;\n      int uk2 = uk + w;\n      int uk3 = uk + w + 1;\n      \n      for (int di = 0; di < 4; di++) {\n\tint dx = dxys[di][0];\n\tint dy = dxys[di][1];\n\n\t// move open space 0\n\tint vo0x = uo0x + dx;\n\tint vo0y = uo0y + dy;\n\tint vo0 = vo0y * w + vo0x;\n\tif (vo0x >= 0 && vo0x < w && vo0y >= 0 && vo0y < h &&\n\t    flds[vo0] && vo0 != uo1 &&\n\t    vo0 != uk && vo0 != uk1 && vo0 != uk2 && vo0 != uk3) {\n\t  if (vo0 < uo1)\n\t    vs[nvs++] = mkid(vo0, uo1, uk);\n\t  else\n\t    vs[nvs++] = mkid(uo1, vo0, uk);\n\t}\n\n\t// move open space 1\n\tint vo1x = uo1x + dx;\n\tint vo1y = uo1y + dy;\n\tint vo1 = vo1y * w + vo1x;\n\tif (vo1x >= 0 && vo1x < w && vo1y >= 0 && vo1y < h &&\n\t    flds[vo1] && vo1 != uo0 &&\n\t    vo1 != uk && vo1 != uk1 && vo1 != uk2 && vo1 != uk3) {\n\t  if (uo0 < vo1)\n\t    vs[nvs++] = mkid(uo0, vo1, uk);\n\t  else\n\t    vs[nvs++] = mkid(vo1, uo0, uk);\n\t}\n      }\n\n      int nvd = ud + 1;\n\n      for (int vi = 0; vi < nvs; vi++) {\n\tll v = vs[vi];\n\tif (dists.find(v) == dists.end()) {\n\t  q.push(v);\n\t  dists[v] = nvd;\n\t}\n      }\n    }\n\n    cout << (min_d >= INF ? -1 : min_d) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nint n,m,INF=1<<29,dxx[4]={-1,0,1,0},dyy[4]={0,-1,0,1};\nint dx[8]={-1,-1,0,1,2,2,0,1},dy[8]={0,1,-1,-1,0,1,2,2};\nstring s[55];\nbool check(int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\nbool check(int x,int y,int xx,int yy) {\n  if(x>=0&&x<n&&y>=0&&y<m) {\n    if(s[x][y]=='*') return 0;\n    if(x==xx&&(y==yy||y==yy+1)) return 0;\n    if(x==xx+1&&(y==yy||y==yy+1)) return 0;\n    return 1;\n  }\n  return 0;\n}\n\nint calc(int sx,int sy,int tx,int ty,int xx,int yy) {\n  if(!check(sx,sy,xx,yy)||!check(tx,ty,xx,yy)) return INF;\n  int d[n][m];\n  for(int i=0;i<n;i++)for(int j=0;j<m;j++) d[i][j]=INF;\n  d[sx][sy]=0;\n  queue<P> que;\n  que.push(P(sx,sy));\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    for(int i=0; i<4; i++) {\n      int x=p.F+dxx[i],y=p.S+dyy[i];\n      if(!check(x,y,xx,yy)||d[x][y]<=d[p.F][p.S]+1) continue;\n      d[x][y]=d[p.F][p.S]+1;\n      que.push(P(x,y));\n    }\n  }\n  return d[tx][ty];\n}\n\nint main() {\n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[n][m][4];\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<4;k++)d[i][j][k]=INF;\n    vector<P> v;\n    P p=P(-1,-1);\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++) {\n        if(s[i][j]=='.')v.push_back(P(i,j));\n        if(s[i][j]=='X'&&p.F==-1) p=P(i,j);\n      }\n    if(p==P(0,0)) {\n      cout << 0 << endl;\n      continue;\n    }\n    queue<PP> que;\n    for(int i=0; i<4; i++) {\n      int b[2]={0,1};\n      do {\n        int cost=calc(v[0].F,v[0].S,p.F+dx[i*2+b[0]],p.S+dy[i*2+b[0]],p.F,p.S);\n        cost+=calc(v[1].F,v[1].S,p.F+dx[i*2+b[1]],p.S+dy[i*2+b[1]],p.F,p.S);\n        d[p.F][p.S][i]=min(d[p.F][p.S][i],cost);\n      } while(next_permutation(b,b+2));\n      que.push(PP(p,i));\n    }\n    while(!que.empty()) {\n      PP pp=que.front();que.pop();\n      int x=pp.F.F,y=pp.F.S,k=pp.S;\n      for(int i=0; i<4; i++) {\n        int cost=INF;\n        int b[2]={0,1};\n        do {\n          int sum=calc(x+dx[k*2],y+dy[k*2],x+dx[i*2+b[0]],y+dy[i*2+b[0]],x,y);\n          sum+=calc(x+dx[k*2+1],y+dy[k*2+1],x+dx[i*2+b[1]],y+dy[i*2+b[1]],x,y);\n          cost=min(cost,sum);\n        }while(next_permutation(b,b+2));\n        int xx=x+dxx[i],yy=y+dyy[i]; \n        if(!check(xx,yy)||d[xx][yy][(i+2)%4]<=d[x][y][k]+cost+1) continue;\n        d[xx][yy][(i+2)%4]=d[x][y][k]+cost+1;\n        que.push(PP(P(xx,yy),(i+2)%4));\n      }\n    }\n    int ans=INF;\n    for(int i=0; i<4; i++) ans=min(ans,d[0][0][i]);\n    if(ans==INF) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct state {\n\tint x, y, d, dist;\n\tstate(int x_, int y_, int d_, int dist_):x(x_), y(y_), d(d_), dist(dist_) {}\n\tstate(const state &s):x(s.x), y(s.y), d(s.d), dist(s.dist) {}\n\tbool operator>(const state &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\n#define X first\n#define Y second\n\nconstexpr int INF = (1 << 28);\nconstexpr int MAX_SIZE = 50;\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\nconstexpr int ddx[4][2] = {{2, 2}, {-1, -1}, {0, 1}, {0, 1}};\nconstexpr int ddy[4][2] = {{0, 1}, {0, 1}, {2, 2}, {-1, -1}};\n\nint h, w;\nstring field[MAX_SIZE + 2];\nint dist[MAX_SIZE + 2][MAX_SIZE + 2][4];\n\nvoid overwrite(int x, int y, char c) {\n\tfor(int i = 0; i <= 1; ++i) {\n\t\tfor(int j = 0; j <= 1; ++j) {\n\t\t\tfield[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nvector<vector<int>> bfs(const pair<int, int> &start) {\n\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\tqueue<pair<int, int>> que;\n\tque.push(start);\n\tcost[start.Y][start.X] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().X;\n\t\tconst int y = que.front().Y;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(field[ny][nx] == '*') continue;\n\t\t\tif(cost[ny][nx] > cost[y][x] + 1) {\n\t\t\t\tque.push({nx, ny});\n\t\t\t\tcost[ny][nx] = cost[y][x] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\nint dijkstra(const vector<state> &start) {\n\tfill(dist[0][0], dist[0][0] + (MAX_SIZE + 2) * (MAX_SIZE + 2) * 4, INF);\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfor(const auto &s : start) {\n\t\tque.push(s);\n\t\tdist[s.x][s.y][s.d] = s.dist;\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(s.dist > dist[s.x][s.y][s.d]) continue;\n\t\tif(s.x == 1 && s.y == 1) return s.dist;\n\n\t\toverwrite(s.x, s.y, '*');\n\t\tconst auto c1 = bfs({s.x+ddx[s.d][0], s.y+ddy[s.d][0]});\n\t\tconst auto c2 = bfs({s.x+ddx[s.d][1], s.y+ddy[s.d][1]});\n\t\toverwrite(s.x, s.y, 'o');\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = s.x + dx[d], ny = s.y + dy[d];\n\t\t\tconst int nx1 = s.x + ddx[d][0], nx2 = s.x + ddx[d][1];\n\t\t\tconst int ny1 = s.y + ddy[d][0], ny2 = s.y + ddy[d][1];\n\n\t\t\tif(field[ny1][nx1] == '*' || field[ny2][nx2] == '*') continue;\n\t\t\tint n_dist = s.dist + 1;\n\t\t\tif(s.d != d) n_dist += min(c1[ny1][nx1] + c2[ny2][nx2], c1[ny2][nx2] + c2[ny1][nx1]);\n\t\t\tif(dist[nx][ny][(d ^ 1)] > n_dist) {\n\t\t\t\tdist[nx][ny][(d ^ 1)] = n_dist;\n\t\t\t\tque.push({nx, ny, (d ^ 1), n_dist});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfield[0] = field[h + 1] = string(w + 2, '*');\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tcin >> field[i];\n\t\t\tfield[i] = '*' + field[i] + '*';\n\t\t}\n\n\t\tint sx = INF, sy = INF;\n\t\tvector<pair<int, int>> ps;\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\tps.emplace_back(x, y);\n\t\t\t\t\tfield[y][x] = 'o';\n\t\t\t\t}\n\t\t\t\telse if(field[y][x] == 'X') {\n\t\t\t\t\tchmin(sx, x);\n\t\t\t\t\tchmin(sy, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(sx == 1 && sy == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\toverwrite(sx, sy, '*');\n\t\tconst auto c1 = bfs(ps[0]);\n\t\tconst auto c2 = bfs(ps[1]);\n\t\toverwrite(sx, sy, 'o');\n\n\t\tvector<state> start;\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tint init_dist = INF;\n\t\t\tfor(int i = 0; i <= 1; ++i) {\n\t\t\t\tchmin(init_dist, c1[sy+ddy[d][i]][sx+ddx[d][i]] + c2[sy+ddy[d][1-i]][sx+ddx[d][1-i]]);\n\t\t\t}\n\t\t\tif(init_dist == INF) continue;\n\t\t\tstart.emplace_back(sx, sy, d, init_dist);\n\t\t}\n\n\t\tcout << dijkstra(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF ( 1<<29 )\n\ntypedef pair<int,int> P;\n\nint H,W;\nchar fie[51][51];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint dx2[]={0,2,0,-1};\nint dy2[]={-1,0,2,0};\nint dx3[]={1,2,1,-1};\nint dy3[]={-1,1,2,1};\n\nint bmem[51][51];\n\n\nstruct state{\n  int x,y,d,c;\n  bool operator<(const state &a) const {\n    return c > a.c;\n  }\n};\n\nbool check(int x,int y,int kx,int ky){\n  if( x < 0 || y < 0 || x >= W || y >= H ) return false;\n  if( kx <= x && x <= kx + 1 && ky <= y && y <= ky + 1 ) return false; \n  if( fie[x][y] == '*' ) return false;\n  if( bmem[x][y] > -1 ) return false;\n  return true;\n}\n\nint bfs(int sx,int sy,int tx,int ty,int kx,int ky){\n  memset(bmem,-1,sizeof(bmem));\n  queue<P> q;\n  q.push( P(sx,sy) );\n  bmem[sx][sy] = 0;\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    int x = p.first, y = p.second;\n    if( x == tx && y == ty ) return bmem[x][y];\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( check( nx, ny, kx, ky ) ) {\n\tq.push( P(nx,ny) );\n\tbmem[nx][ny] = bmem[x][y] + 1;\n      }\n    }\n  }\n  return INF;   \n}\n\nint dmem[51][51][5];\n\nint solve(int x1,int y1,int x2,int y2,int kx,int ky){\n  priority_queue<state> q;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<4;k++) dmem[j][i][k] = INF;\n\n  for(int i=0;i<4;i++){\n    int px1 = kx + dx2[i], py1 = ky + dy2[i];\n    int px2 = kx + dx3[i], py2 = ky + dy3[i];\n    \n    int sca1 = bfs(x1,y1,px1,py1,kx,ky);\n    int sca2 = bfs(x1,y1,px2,py2,kx,ky);\n    int scb1 = bfs(x2,y2,px1,py1,kx,ky);\n    int scb2 = bfs(x2,y2,px2,py2,kx,ky);\n\n    int sc =  min( sca1 + scb2, sca2 + scb1 );\n    if( sc >= INF ) continue;\n    dmem[kx][ky][i] = sc;\n    q.push( (state){kx,ky,i,sc} );\n  }\n\n  while( !q.empty() ){\n    state p = q.top(); q.pop();\n    kx = p.x, ky = p.y;\n    int d = p.d, c = p.c;\n    \n    x1 = kx + dx2[d], y1 = ky + dy2[d];\n    x2 = kx + dx3[d], y2 = ky + dy3[d];\n    if( c > dmem[kx][ky][d] ) continue;\n    if( kx == 0 && ky == 0 ) return c;\n    for(int i=0;i<4;i++){\n      int nx = kx + dx[i], ny = ky + dy[i];\n      int px1 = kx + dx2[i], py1 = ky + dy2[i];\n      int px2 = kx + dx3[i], py2 = ky + dy3[i];\n      \n      int sca1 = bfs(x1,y1,px1,py1,kx,ky);\n      int sca2 = bfs(x1,y1,px2,py2,kx,ky);\n      int scb1 = bfs(x2,y2,px1,py1,kx,ky);\n      int scb2 = bfs(x2,y2,px2,py2,kx,ky);\n\n      int sc =  min( sca1 + scb2, sca2 + scb1 ) + 1;      \n      if( sc >= INF ) continue;\n      int nd = (i+2)%4;\n      if( sc + c < dmem[nx][ny][nd] ){\n\tq.push( (state){nx,ny,nd,sc+c} );\n\tdmem[nx][ny][nd] = sc + c;\n      }      \n    }\n  }\n  return -1;\n}\n\n\nint main(){\n  while( cin >> H >> W && (H||W) ){\n    int x1, y1,x2,y2, kx, ky;\n    bool f1 = false,f2 = false;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[j][i];\n\tif( fie[j][i] == '.' ){\n\t  if( !f1 ){\n\t    x1 = j; y1 = i;  f1 = true;\n\t  } else {\n\t    x2 = j; y2 = i;\n\t  }\n\t} else if ( fie[j][i] == 'X' && !f2) {\n\t  kx = j; ky = i; f2 = true;\n\t}\n      }\n    }\n\n    if( kx == 0 && ky == 0 ) cout << 0 << endl;\n    else cout << solve(x1,y1,x2,y2,kx,ky) << endl;;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<climits>\n#define inf (1<<29)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define MAX 251\nusing namespace std;\ntypedef pair<int,int> ii;\ntypedef pair<ii,int> iii;\nint h,w;\nstring G[51];\n//int mincost[MAX][MAX][MAX];//mincost[open1][open2][king] := the minimum cost\nmap<iii,bool> mincost;\n\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\nint kdx[] = {0,1,0,1};\nint kdy[] = {0,0,1,1};\nint sdx[] = {};\nint sdy[] = {};\n\nstruct Point\n{\n  int x,y;\n  Point(int x=-1,int y=-1):x(x),y(y){}\n  bool operator < (const Point &a)const\n  {\n    if(x != a.x)return x < a.x;\n    return y < a.y;\n  }\n};\n\nstruct State\n{\n  Point king;\n  Point op[2];\n  int cost;\n  State(Point king,Point op1,Point op2,int cost = -1):king(king),cost(cost){ op[0] = op1,op[1] = op2; }\n  bool operator < (const State &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint toIndex(Point p){ return p.x+p.y*w;  }\n\nvoid trace(Point p1,Point p2,Point p3)\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  if(G[i][j] == '*')\n\t    {\n\t      cout << G[i][j];\n\t      continue;\n\t    }\n\t  if(p1.x == j && p1.y == i)\n\t    {\n\t      cout << '.';\n\t      continue;\n\t    }\n\t  if(p2.x == j && p2.y == i)\n\t    {\n\t      cout << '.'; \n\t      continue;\n\t    }\n\n\t  bool check_king = true;\n\t  rep(k,4)\n\t    {\n\t      int nx = p3.x + kdx[k];\n\t      int ny = p3.y + kdy[k];\n\t      if(nx == j && ny == i)\n\t\t{\n\t\t  cout << 'X';\n\t\t  check_king = false;\n\t\t  continue;\n\t\t}\n\t    }\n\t  if(!check_king)continue;\n\t  cout << 'o';\n\t}\n      cout << endl;\n    }\n  cout << endl << endl;\n}\n\nbool slide_check(int dir,Point &p1,Point &p2,Point king)\n{\n  map<Point,bool> exist;\n  exist[p1] = true;\n  exist[p2] = true;\n  rep(i,4)\n    {\n      int nx = king.x + kdx[i];\n      int ny = king.y + kdy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))return false;\n      if(G[ny][nx] == '*')return false;\n    }\n  //下、右、上、左\n  Point pp1,pp2;\n  if(dir == 0)\n    {\n      // 0,  1, 2,   3\n      //今、右、下、斜め\n      pp1 = Point(king.x+kdx[2],king.y+kdy[2]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x,king.y-1);\n      p2 = Point(king.x+1,king.y-1);\n    }\n  if(dir == 1)\n    {\n      pp1 = Point(king.x+kdx[1],king.y+kdy[1]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x-1,king.y);\n      p2 = Point(king.x-1,king.y+1);\n    }\n  if(dir == 2)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[1],king.y+kdy[1]);\n      p1 = Point(king.x,king.y+2);\n      p2 = Point(king.x+1,king.y+2);\n    }\n  if(dir == 3)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[2],king.y+kdy[2]);\n      p1 = Point(king.x+2,king.y);\n      p2 = Point(king.x+2,king.y+1);\n    }\n  if(!(exist[pp1] && exist[pp2]))return false;\n\n  return true;\n}\n\nvoid dijkstra(Point st,Point op1,Point op2)\n{\n  priority_queue<State> Q;\n  Q.push(State(st,op1,op2,0));\n  //mincost[toIndex(op1)][toIndex(op2)][toIndex(st)] = 0;\n  //mincost[toIndex(op2)][toIndex(op1)][toIndex(st)] = 0;\n  mincost[iii(ii(toIndex(op1),toIndex(op2)),toIndex(st))] = true;\n  mincost[iii(ii(toIndex(op2),toIndex(op1)),toIndex(st))] = true;\n\n\n  while(!Q.empty())\n    {\n      State state = Q.top(); Q.pop();\n      //cout << \"the cost = \" << state.cost << endl;\n      //trace(state.op[0],state.op[1],state.king);\n      if(toIndex(state.king) == 0)\n\t{\n\t  cout << state.cost << endl;\n\t  return;\n\t}\n\n\n      Point king = state.king;\n      rep(i,2)//move the open square\n\t{\n\t  Point p = state.op[i];\n\t  rep(j,4)\n\t    {\n\t      int nx = p.x + dx[j];\n\t      int ny = p.y + dy[j];\t      \n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '*')continue;\n\n\t      bool check_king = true;\n\t      rep(k,4)\n\t\t{//the place (ny,ny) is on the king\n\t\t  int kx = king.x + kdx[k];\n\t\t  int ky = king.y + kdy[k];\n\t\t  assert(0 <= kx && kx < w && 0 <= ky && ky < h);\n\t\t  if(kx == nx && ky == ny)\n\t\t    {\n\t\t      check_king = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if(!check_king)continue;\n\t      if(nx == state.op[(i+1)%2].x && ny == state.op[(i+1)%2].y)continue;//the new place is on the other open squeare\n\n\t      Point pp[2];\n\t      pp[0] = (i == 0 ? Point(nx,ny): state.op[0]);\t      \n\t      pp[1] = (i == 0 ? state.op[1] : Point(nx,ny));\n\n\t      int index1 = toIndex(pp[0]);\n\t      int index2 = toIndex(pp[1]);\n\t      int index3 = toIndex(state.king);\n\t      if(!mincost[iii(ii(index1,index2),index3)])\n\t\t{\n\t\t  mincost[iii(ii(index1,index2),index3)] = true;\n\t\t  mincost[iii(ii(index2,index1),index3)] = true;\n\t\t  Q.push(State(state.king,pp[0],pp[1],state.cost+1));\n\t\t}\n\t    }\n\t}\n\n      rep(i,4)//move the king\n\t{\n\t  int nx = state.king.x + dx[i];\n\t  int ny = state.king.y + dy[i];\n\t  Point sop1 = state.op[0];\n\t  Point sop2 = state.op[1];\n\t  if(!slide_check(i,sop1,sop2,Point(nx,ny)))continue;\n\n\t  int index1 = toIndex(sop1);\n\t  int index2 = toIndex(sop2);\n\t  int index3 = toIndex(Point(nx,ny));\n\t  //if(mincost[index1][index2][index3] > state.cost + 1)\n\t  if(!mincost[iii(ii(index1,index2),index3)])\n\t    {\n\t      mincost[iii(ii(index1,index2),index3)] = true;\n\t      mincost[iii(ii(index2,index1),index3)] = true;\n\t      //mincost[index1][index2][index3] = state.cost + 1;\n\t      //mincost[index2][index1][index3] = state.cost + 1;\n\t      Q.push(State(Point(nx,ny),sop1,sop2,state.cost+1));\n\t    }\n\t}\n    }  \n  cout << -1 << endl;\n}\n\nint main()\n{\n  clock_t stc,edc;\n  stc = clock();\n  while(cin >> h >> w,h|w)\n    {\n      mincost.clear();\n      Point st;\n      vector<Point> op;\n      rep(i,h)\n\t{\n\t  cin >> G[i];\n\t  rep(j,w)\n\t    {\n\t      if((st.x == -1 && st.y == -1) && G[i][j] == 'X')\n\t\t{\n\t\t  st.x = j,st.y = i;\n\t\t}\n\t      if(G[i][j] == '.')op.push_back(Point(j,i));\n\t    }\n\t}\n      assert(op.size() == 2);\n      dijkstra(st,op[0],op[1]);\n    }\n  edc = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(edc-stc)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nbool u[52][52][52][52];\nbool u2[50][50][2][50][50];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    auto inside=[H,W](int y,int x){\n      return 0<=y&&y<H&&0<=x&&x<W;\n    };\n    char g[52][52];\n    int sy[2],sx[2],sn=0;\n    int sky=-1,skx;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='.'){\n\t  sy[sn]=i;\n\t  sx[sn]=j;\n\t  sn++;\n\t}\n\tif(sky<0&&g[i][j]=='X'){\n\t  sky=i;\n\t  skx=j;\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n      continue;\n    }\n    fill(***begin(u),***end(u),false);\n    queue<tuple<int,int,int,int,int> > que;\n    que.push(make_tuple(0,sy[0],sx[0],sy[1],sx[1]));\n    //    priority_queue<tuple<int,int,int,int,int,int>,vector<tuple<int,int,int,int,int,int> >,greater<tuple<int,int,int,int,int,int> > > que2;\n    set<tuple<int,int,int,int,int,int> >que2;\n    while(!que.empty()){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      auto c=que.front();\n      que.pop();\n      int t,y1,x1,y2,x2;\n      tie(t,y1,x1,y2,x2)=c;\n      if(u[y1][x1][y2][x2]++)continue;\n      for(int i=0;i<4;i++){\n\tint ny1=y1+dy[i];\n\tint nx1=x1+dx[i];\n\tint ny2=y2+dy[i];\n\tint nx2=x2+dx[i];\n\tif(inside(ny1,nx1)&&inside(ny2,nx2)&&g[ny1][nx1]=='X'&&g[ny2][nx2]=='X'){\n\t  que2.insert(make_tuple(t,min(y1,y2),min(x1,x2),x1!=x2,sky,skx));\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<4;j++){\n\t  int ny1=i?y1+dy[j]:y1;\n\t  int nx1=i?x1+dx[j]:x1;\n\t  int ny2=i?y2:y2+dy[j];\n\t  int nx2=i?x2:x2+dx[j];\n\t  if(!inside(ny1,nx1)||!inside(ny2,nx2)||ny1==ny2&&nx1==nx2||g[ny1][nx1]=='X'||g[ny1][nx1]=='*'||g[ny2][nx2]=='X'||g[ny2][nx2]=='*')continue;\n\t  que.push(make_tuple(t+1,ny1,nx1,ny2,nx2));\n\t}\n      }\n    }\n    fill(****begin(u2),****end(u2),false);\n    while(!que2.empty()){\n      auto c=*que2.begin();\n      int t,y,x,d,ky,kx;\n      tie(t,y,x,d,ky,kx)=c;\n      if(ky==0&&kx==0)break;\n      que2.erase(que2.begin());\n      if(u2[y][x][d][ky][kx]++)continue;\n      //      cout<<ky<<' '<<kx<<endl;\n      for(int i=0;i<6;i++){\n\tstatic int ndy[2][6]={\n\t  {-1,2,0,1,0,1},\n\t  {0,0,1,1,-1,-1}\n\t};\n\tstatic int ndx[2][6]={\n\t  {0,0,-1,-1,1,1},\n\t  {-1,2,0,1,0,1}\n\t};\n\tint cy=y+ndy[d][i];\n\tint cx=x+ndx[d][i];\n\tif(inside(cy,cx)&&g[cy][cx]!='*'&&(cy<ky||ky+2<=cy||cx<kx||kx+2<=cx)){\n\t  static int hdy[2][6]={\n\t    {-1,1,0,1,0,1},\n\t    {0,0,0,0,-1,-1}\n\t  };\n\t  static int hdx[2][6]={\n\t    {0,0,-1,-1,0,0},\n\t    {-1,1,0,1,0,1}\n\t  };\n\t  que2.insert(make_tuple(t+2,y+hdy[d][i],x+hdx[d][i],d^(i>=2),ky,kx));\n\t}\n      }\n      if(y==ky&&d==0){\n\tif(kx-1==x){\n\t  que2.insert(make_tuple(t+1,y,x+2,d,ky,kx-1));\n\t}else if(kx+2==x){\n\t  que2.insert(make_tuple(t+1,y,x-2,d,ky,kx+1));\n\t}\n      }else if(x==kx&&d==1){\n\tif(ky-1==y){\n\t  que2.insert(make_tuple(t+1,y+2,x,d,ky-1,kx));\n\t}else if(ky+2==y){\n\t  que2.insert(make_tuple(t+1,y-2,x,d,ky+1,kx));\n\t}\n      }\n    }\n    cout<<(que2.empty()?-1:get<0>(*que2.begin()))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\ntypedef pair<int,PP>iPP;\n#define F first\n#define S second\n\nint h,w;\nint dis[31][31][31][31][8];\nint dp[31][31][8][8];\nint DX[]={0,1,2,2,1,0,-1,-1};\nint DY[]={-1,-1,0,1,2,2,1,0};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nstring s[55];\n\nvoid BFS_INIT(){\n    r(i,31)r(j,31)r(k,31)r(l,31)r(q,8)dis[i][j][k][l][q]=1e9;\n    r(i,h-1)r(j,w-1){\n        if(s[i][j]=='*'||s[i][j]=='*'||s[i][j]=='*'||s[i+1][j+1]=='*')continue;\n        set<P>st;\n        r(Y,2)r(X,2)st.insert(P(i+Y,j+X));\n        r(k,8){\n            int y=i+DY[k];\n            int x=j+DX[k];\n            if(y<0||x<0||y>=h||x>=w)continue;\n            dis[i][j][y][x][k]=0;\n            queue<P>q;\n            q.push(P(y,x));\n            //cout<<i<<j<<k<<endl;\n            while(!q.empty()){\n                int y=q.front().F;\n                int x=q.front().S;q.pop();\n                r(l,4){\n                    int ny=y+dy[l];\n                    int nx=x+dx[l];\n                    if(ny<0||nx<0||ny>=h||nx>=w)continue;\n                    if(s[ny][nx]=='*')continue;\n                    if(st.count(P(ny,nx)))continue;\n                    if(dis[i][j][ny][nx][k]!=1e9)continue;\n                    dis[i][j][ny][nx][k]=dis[i][j][y][x][k]+1;\n                    //cout<<i<<' '<<j<<' '<<ny<<' '<<nx<<' '<<k<<endl;\n                    q.push(P(ny,nx));\n                }\n            }\n        }\n    }\n}\n\nvoid STATE_INIT(){\n    int sx1,sx2,sy1,sy2,c=0,cnt=0,sx,sy;\n    r(i,31)r(j,31)r(k,8)r(l,8)dp[i][j][k][l]=1e9;\n    r(i,h)r(j,w){\n        if(s[i][j]=='.'){\n            if(!c)sx1=j,sy1=i,c++;\n            else sx2=j,sy2=i;\n        }\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        int gx1=sx+DX[i];\n        int gy1=sy+DY[i];\n        int gx2=sx+DX[j];\n        int gy2=sy+DY[j];\n        if(gx1<0||gy1<0||gx1>=w||gy1>=h)continue;\n        if(gx2<0||gy2<0||gx2>=w||gy2>=h)continue;\n        //cout<<i<<j<<' '<<dis[sy][sx][sy1][sx1][i]<<' '<<dis[sy][sx][sy2][sx2][j]<<endl;\n        if(dis[sy][sx][sy1][sx1][i]==1e9)continue;\n        if(dis[sy][sx][sy2][sx2][i]==1e9)continue;\n        dp[sy][sx][i][j]=dis[sy][sx][sy1][sx1][i]+dis[sy][sx][sy2][sx2][j];\n        dp[sy][sx][i][j]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n        dp[sy][sx][j][i]=min(dp[sy][sx][i][j],dp[sy][sx][j][i]);\n    }\n}\n\nint COST(int y,int x,int a,int b,int A,int B){\n    if(a!=A){\n        int Y=y+DY[a];\n        int X=x+DX[a];\n        return dis[y][x][Y][X][A];\n    }\n    if(b!=B){\n        int Y=y+DY[b];\n        int X=x+DX[b];\n        return dis[y][x][Y][X][B];\n    }\n}\n\nvoid DIJKSTRA(){\n    priority_queue<iPP,vector<iPP>,greater<iPP> >q;\n    int sx,sy,cnt=0;\n    r(i,h)r(j,w){\n        if(s[i][j]=='X'&&!cnt){\n            cnt++;\n            sx=j;sy=i;\n        }\n    }\n    r(i,8)r(j,8){\n        if(dp[sy][sx][i][j]==1e9)continue;\n        //cout<<i<<j<<' '<<dp[sy][sx][i][j]<<endl;\n        q.push(iPP(dp[sy][sx][i][j],PP(P(sy,sx),P(i,j))));\n    }\n    while(!q.empty()){\n        iPP p=q.top();q.pop();\n        int ky=p.S.F.F;\n        int kx=p.S.F.S;\n        int a=p.S.S.F;\n        int b=p.S.S.S;\n        int cost=p.F;\n        //cout<<ky<<' '<<kx<<' '<<a<<' '<<b<<' '<<cost<<endl;\n        if(!kx&&!ky){\n            cout<<cost<<endl;\n            return ;\n        }\n        if(dp[ky][kx][a][b]<cost)continue;\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,i,b)+cost;\n            if(dp[ky][kx][i][b]<=ncost)continue;\n            dp[ky][kx][i][b]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(i,b))));\n        }\n        r(i,8){\n            int ncost=COST(ky,kx,a,b,a,i)+cost;\n            if(dp[ky][kx][a][i]<=ncost)continue;\n            dp[ky][kx][a][i]=ncost;\n            q.push(iPP(ncost,PP(P(ky,kx),P(a,i))));\n        }\n        if(!((a+1==b) && (a%2==0)))continue;\n        //cout<<a<<' '<<b<<' '<<ky<<kx<<endl;\n        if(a==0)ky--,a=4,b=5;\n        else if(a==2)kx++,a=6,b=7;\n        else if(a==4)ky++,a=0,b=1;\n        else if(a==6)kx--,a=2,b=3;\n        int ncost=cost+1;\n        if(dp[ky][kx][a][b]<=ncost)continue;\n        dp[ky][kx][a][b]=ncost;\n        q.push(iPP(ncost,PP(P(ky,kx),P(a,b))));\n    }\n    cout<<-1<<endl;\n}\n\nint main(){\n    while(cin>>h>>w,h){\n        r(i,h)cin>>s[i];\n        BFS_INIT();\n        STATE_INIT();\n        DIJKSTRA();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nbool u[52][52][52][52];\nbool u2[50][50][2][50][50];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    auto inside=[H,W](int y,int x){\n      return 0<=y&&y<H&&0<=x&&x<W;\n    };\n    char g[52][52];\n    int sy[2],sx[2],sn=0;\n    int sky=-1,skx;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='.'){\n\t  sy[sn]=i;\n\t  sx[sn]=j;\n\t  sn++;\n\t}\n\tif(sky<0&&g[i][j]=='X'){\n\t  sky=i;\n\t  skx=j;\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n      continue;\n    }\n    fill(***begin(u),***end(u),false);\n    queue<tuple<int,int,int,int,int> > que;\n    que.push(make_tuple(0,sy[0],sx[0],sy[1],sx[1]));\n    //    priority_queue<tuple<int,int,int,int,int,int>,vector<tuple<int,int,int,int,int,int> >,greater<tuple<int,int,int,int,int,int> > > que2;\n    set<tuple<int,char,char,char,char,char> >que2;\n    while(!que.empty()){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      auto c=que.front();\n      que.pop();\n      int t,y1,x1,y2,x2;\n      tie(t,y1,x1,y2,x2)=c;\n      if(u[y1][x1][y2][x2]++)continue;\n      for(int i=0;i<4;i++){\n\tint ny1=y1+dy[i];\n\tint nx1=x1+dx[i];\n\tint ny2=y2+dy[i];\n\tint nx2=x2+dx[i];\n\tif(inside(ny1,nx1)&&inside(ny2,nx2)&&g[ny1][nx1]=='X'&&g[ny2][nx2]=='X'){\n\t  que2.insert(make_tuple(t,min(y1,y2),min(x1,x2),x1!=x2,sky,skx));\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<4;j++){\n\t  int ny1=i?y1+dy[j]:y1;\n\t  int nx1=i?x1+dx[j]:x1;\n\t  int ny2=i?y2:y2+dy[j];\n\t  int nx2=i?x2:x2+dx[j];\n\t  if(!inside(ny1,nx1)||!inside(ny2,nx2)||ny1==ny2&&nx1==nx2||g[ny1][nx1]=='X'||g[ny1][nx1]=='*'||g[ny2][nx2]=='X'||g[ny2][nx2]=='*')continue;\n\t  que.push(make_tuple(t+1,ny1,nx1,ny2,nx2));\n\t}\n      }\n    }\n    fill(****begin(u2),****end(u2),false);\n    while(!que2.empty()){\n      auto c=*que2.begin();\n      int t,y,x,d,ky,kx;\n      tie(t,y,x,d,ky,kx)=c;\n      if(ky==0&&kx==0)break;\n      que2.erase(que2.begin());\n      if(u2[y][x][d][ky][kx]++)continue;\n      //      cout<<ky<<' '<<kx<<endl;\n      for(int i=0;i<6;i++){\n\tstatic int ndy[2][6]={\n\t  {-1,2,0,1,0,1},\n\t  {0,0,1,1,-1,-1}\n\t};\n\tstatic int ndx[2][6]={\n\t  {0,0,-1,-1,1,1},\n\t  {-1,2,0,1,0,1}\n\t};\n\tint cy=y+ndy[d][i];\n\tint cx=x+ndx[d][i];\n\tif(inside(cy,cx)&&g[cy][cx]!='*'&&(cy<ky||ky+2<=cy||cx<kx||kx+2<=cx)){\n\t  static int hdy[2][6]={\n\t    {-1,1,0,1,0,1},\n\t    {0,0,0,0,-1,-1}\n\t  };\n\t  static int hdx[2][6]={\n\t    {0,0,-1,-1,0,0},\n\t    {-1,1,0,1,0,1}\n\t  };\n\t  que2.insert(make_tuple(t+2,y+hdy[d][i],x+hdx[d][i],d^(i>=2),ky,kx));\n\t}\n      }\n      if(y==ky&&d==0){\n\tif(kx-1==x){\n\t  que2.insert(make_tuple(t+1,y,x+2,d,ky,kx-1));\n\t}else if(kx+2==x){\n\t  que2.insert(make_tuple(t+1,y,x-2,d,ky,kx+1));\n\t}\n      }else if(x==kx&&d==1){\n\tif(ky-1==y){\n\t  que2.insert(make_tuple(t+1,y+2,x,d,ky-1,kx));\n\t}else if(ky+2==y){\n\t  que2.insert(make_tuple(t+1,y-2,x,d,ky+1,kx));\n\t}\n      }\n    }\n    cout<<(que2.empty()?-1:get<0>(*que2.begin()))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { -1,0,2,1 };\nconst int dy2[4] = { 0,2,1,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint getdis(const vector<vector<int>>&field, const int fx, const int fy,const int gx,const int gy) {\n\tint ans = 999999;\n\tqueue<aa>que;\n\tvector<vector<int>>memo(field.size(), vector<int>(field[0].size(),999999));\n\tque.push(aa{ fx,fy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tconst int nextx = atop.x + dx[i];\n\t\t\tconst int nexty = atop.y + dy[i];\n\t\t\tif (!field[nexty][nextx]) {\n\t\t\t\tif (atop.turn + 1 < memo[nexty][nextx]) {\n\t\t\t\t\tmemo[nexty][nextx] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ nextx,nexty,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nstruct bb {\n\tint kx;\n\tint ky;\n\tint opway;\n\tint turn;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bb&l, const bb&r) {\n\t\treturn l.turn> r.turn;\n\t}\n};\nint memo2[52][52][4];\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 52; ++i) {\n\t\t\tfor (int j = 0; j < 52; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo2[i][j][k] = 999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, true));\n\t\tpriority_queue<bb, vector<bb>, Compare>que;\n\t\t{\n\t\t\tint kx = 99, ky = 99;\n\t\t\tint ox[2];\n\t\t\tint oy[2];\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (st[j] == 'X') {\n\t\t\t\t\t\tkx = min(kx, j + 1);\n\t\t\t\t\t\tky = min(ky, i + 1);\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == 'o') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[j]=='.'){\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t\tox[num] = j + 1;\n\t\t\t\t\t\toy[num] = i + 1;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kx == 1 && ky == 1) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tconst int fx = ox[op^lu];\n\t\t\t\t\t\tconst int fy = oy[op^lu];\n\t\t\t\t\t\tint gx = kx + dx2[way];\n\t\t\t\t\t\tint gy = ky + dy2[way];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(way + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(way + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tmemo2[kx][ky][way] = amin;\n\t\t\t\t\tque.push(bb{ kx,ky,way,amin });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tbb atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int fkx = atop.kx;\n\t\t\tconst int fky = atop.ky;\n\t\t\tconst int fway = atop.opway;\n\t\t\tconst int fturn = atop.turn;\n\t\t\tif (fkx == 1 && fky == 1) {\n\t\t\t\tans = fturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int tway = 0; tway < 4; ++tway) {\n\t\t\t\tif (fway == tway)continue;\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tint fx = fkx + dx2[fway];\n\t\t\t\t\t\tint fy = fky + dy2[fway];\n\t\t\t\t\t\tint gx = fkx + dx2[tway];\n\t\t\t\t\t\tint gy = fky + dy2[tway];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(tway + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(tway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op^lu) {\n\t\t\t\t\t\t\tfx += dx[(fway + 1) % 4];\n\t\t\t\t\t\t\tfy += dy[(fway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tconst int nturn = fturn + amin;\n\t\t\t\t\tif (memo2[fkx][fky][tway]>nturn) {\n\t\t\t\t\t\tmemo2[fkx][fky][tway] = nturn;\n\t\t\t\t\t\tque.push(bb{ fkx,fky,tway,nturn\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nkx = fkx + dx[fway];\n\t\t\t\tconst int nky = fky + dy[fway];\n\t\t\t\tconst int nway = (fway + 2) % 4;\n\t\t\t\tconst int nturn = fturn + 1;\n\t\t\t\tif (memo2[nkx][nky][nway] > nturn) {\n\t\t\t\t\tmemo2[nkx][nky][nway] = nturn;\n\t\t\t\t\tque.push(bb{ nkx,nky,nway,nturn });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<utility>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P> Stat;\n\nconst int inf=1e8;\n\nconst int di[]={0,-1,0,1},dj[]={1,0,-1,0};\nconst int di2[4][2]={{0,1},{-1,-1},{0,1},{2,2}};\nconst int dj2[4][2]={{2,2},{0,1},{-1,-1},{0,1}};\n\nchar field[55][55];\nint W,H;\nP stKing,p1,p2;\nchar ch[55];\n\nint dis[55][55];\nvoid bfs(P king,P st){\n\tfor(int i=0;i<55;i++) for(int j=0;j<55;j++) dis[i][j]=inf;\n\tint i0=king.first,j0=king.second;\n\tfor(int i=0;i<=1;i++) for(int j=0;j<=1;j++){\n\t\tfield[i0+i][j0+j]='*';\n\t}\n\tqueue<int> qi,qj;\n\tqi.push(st.first);\n\tqj.push(st.second);\n\tdis[st.first][st.second]=0;\n\twhile(!qi.empty()){\n\t\tint ci=qi.front(),cj=qj.front();\n\t\tqi.pop();qj.pop();\n\t\tint cd=dis[ci][cj];\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ni=ci+di[i],nj=cj+dj[i];\n\t\t\tif(field[ni][nj]=='*') continue;\n\t\t\tif(dis[ni][nj]<=cd+1) continue;\n\t\t\tdis[ni][nj]=cd+1;\n\t\t\tqi.push(ni);qj.push(nj);\n\t\t}\n\t}\n//\tif(king==P(2,2)&&st==P(1,3)){\n//\t\tfor(int i=1;i<=3;i++){\n//\t\t\tfor(int j=1;j<=3;j++) printf(\"%d \",dis[i][j]);\n//\t\t\tprintf(\"\\n\");\n//\t\t}\n//\t}\n\tfor(int i=0;i<=1;i++) for(int j=0;j<=1;j++){\n\t\tfield[i0+i][j0+j]='o';\n\t}\n}\n\nint getD(P king,P p1,P p2,P q1,P q2){\n//\tprintf(\"%d %d %d %d %d %d %d %d %d %d\\n\",king.first,king.second,p1.first,p1.second,\n//\t\tp2.first,p2.second,q1.first,q1.second,q2.first,q2.second);\n\tint res=inf;\n\tint tmp1=0,tmp2=0;\n\tbfs(king,p1);\n\tint i1=q1.first,j1=q1.second;\n\tint i2=q2.first,j2=q2.second;\n//\tif(king==P(2,2)&&p1==P(1,3)){\n//\t\tprintf(\"--- %d %d %d %d --\\n\",i1,j1,i2,j2);\n//\t}\n\ttmp1+=dis[i1][j1];\n\ttmp2+=dis[i2][j2];\n//\tprintf(\"%d %d\\n\",dis[i1][j1],dis[i2][j2]);\n\tbfs(king,p2);\n\ttmp1+=dis[i2][j2];\n\ttmp2+=dis[i1][j1];\n//\tprintf(\"%d %d\\n\",dis[i2][j2],dis[i1][j1]);\n\tres=min(res,tmp1);\n\tres=min(res,tmp2);\n\treturn res;\n}\n\nvector<P> getAdj(P king,int dir){\n\tvector<P> res;\n//\tprintf(\"%d %d %d\\n\",king.first,king.second,dir);\n\tfor(int i=0;i<2;i++){\n\t\tres.push_back(king);\n\t\tres[i].first+=di2[dir][i];\n\t\tres[i].second+=dj2[dir][i];\n//\t\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\t}\n\treturn res;\n}\n\nbool isvalid(P king,P p1,P p2){\n\tfor(int i=0;i<2;i++) for(int j=0;j<2;j++){\n\t\tif(field[king.first+i][king.second+j]=='*') return false;\n\t}\n\tif(field[p1.first][p1.second]=='*') return false;\n\tif(field[p2.first][p2.second]=='*') return false;\n\treturn true;\n}\n\nbool isvalid(Stat s){\n\treturn isvalid(s[0],s[1],s[2]);\n}\n\nvector<Stat> stats;\n\nstruct edge{\n\tint to,cost;\n\tedge(){}\n\tedge(int a,int b):to(a),cost(b){}\n};\n\nvector<edge> G[20200];\nint dis2[20200];\n\nvoid print(Stat s){\n\tfor(int i=0;i<3;i++){\n\t\tprintf(\"%d %d \",s[i].first,s[i].second);\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid getGraph(){\n//\tprintf(\"getGraph\\n\");\n\tStat ini;\n\tini.push_back(stKing);\n\tini.push_back(p1);\n\tini.push_back(p2);\n\tstats.push_back(ini);\n//\tprint(ini);\n\tfor(int i=1;i<H;i++) for(int j=1;j<W;j++){\n\t\tfor(int k=0;k<4;k++){\n\t\t\tvector<P> emp=getAdj(P(i,j),k);\n\t\t\tvector<P> cur;\n\t\t\tcur.push_back(P(i,j));\n\t\t\tfor(int t=0;t<2;t++) cur.push_back(emp[t]);\n\t\t\tif(isvalid(cur)==false) continue;\n\t\t\tstats.push_back(cur);\n//\t\t\tprint(cur);\n\t\t}\n\t}\n\tfor(int i=0;i<stats.size();i++) for(int j=0;j<stats.size();j++){\n\t\tif(i==j) continue;\n\t\tStat st1=stats[i],st2=stats[j];\n\t\tif(abs(st1[0].first-st2[0].first)+abs(st1[0].second-st2[0].second)==0){\n\t\t\tint d=getD(st1[0],st1[1],st1[2],st2[1],st2[2]);\n\t\t\tG[i].push_back(edge(j,d));\n//\t\t\tprintf(\"%d->%d %d\\n\",i,j,d);\n\t\t}\n\t\telse if(abs(st1[0].first-st2[0].first)+abs(st1[0].second-st2[0].second)==1){\n\t\t\tvector<P> tmp1,tmp2;\n\t\t\tfor(int k=0;k<2;k++) for(int m=0;m<2;m++){\n\t\t\t\ttmp1.push_back(P(st1[0].first+k,st1[0].second+m));\n\t\t\t\ttmp2.push_back(P(st2[0].first+k,st2[0].second+m));\n\t\t\t}\n\t\t\tfor(int k=1;k<=2;k++) tmp1.push_back(st1[k]);\n\t\t\tfor(int k=1;k<=2;k++) tmp2.push_back(st2[k]);\n\t\t\tsort(tmp1.begin(),tmp1.end());\n\t\t\tsort(tmp2.begin(),tmp2.end());\n\t\t\tif(tmp1==tmp2){\n\t\t\t\tG[i].push_back(edge(j,1));\n//\t\t\t\tprintf(\"%d->%d %d\\n\",i,j,1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra(int s){\n\tfor(int i=0;i<20200;i++) dis2[i]=inf;\n\tdis2[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tint d=p.first;\n\t\tif(dis2[v]<d) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint nv=G[v][i].to;\n\t\t\tint nd=d+G[v][i].cost;\n\t\t\tif(dis2[nv]<=nd) continue;\n\t\t\tdis2[nv]=nd;\n\t\t\tque.push(P(nd,nv));\n\t\t}\n\t}\n}\n\nvoid init(){\n\tfor(int i=0;i<20200;i++) G[i].clear();\n\tstats.clear();\n}\n\nint main(){\n\tint testnum=0;\n\twhile(true){\n\t\tscanf(\"%d%d\",&H,&W);\n\t\tif(H+W==0) break;\n\t\tfor(int i=0;i<55;i++) for(int j=0;j<55;j++) field[i][j]='*';\n\t\tfor(int i=0;i<H;i++){\n\t\t\tscanf(\"%s\",ch);\n\t\t\tfor(int j=0;j<W;j++) field[i+1][j+1]=ch[j];\n\t\t}\n\t\tfor(int i=1;i<=H;i++) for(int j=1;j<=W;j++){\n\t\t\tif(field[i][j]=='X'){\n\t\t\t\tstKing=P(i,j);\n\t\t\t\tgoto ed;\n\t\t\t}\n\t\t}\n\t\ted:;\n\t\tp1=P(-1,-1);\n\t\tfor(int i=1;i<=H;i++) for(int j=1;j<=W;j++){\n\t\t\tif(field[i][j]!='.') continue;\n\t\t\tif(p1==P(-1,-1)) p1=P(i,j);\n\t\t\telse p2=P(i,j);\n\t\t}\n\t\tinit();\n\t\tgetGraph();\n\t\tdijkstra(0);\n\t\tint ans=inf;\n\t\tfor(int i=0;i<stats.size();i++){\n\t\t\tif(stats[i][0]==P(1,1)){\n\t\t\t\tans=min(ans,dis2[i]);\n\t\t\t}\n\t\t}\n\t\tif(ans==inf) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n//\t\tif(testnum<100){\n//\t\t\tprintf(\"%d %d\\n\",stats[0][0].first,stats[0][0].second);\n//\t\t}\n//\t\tbreak;\n\t\ttestnum++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nconst int dx2[4] = { -1,0,2,1 };\nconst int dy2[4] = { 0,2,1,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint turn;\n};\nint getdis(const vector<vector<int>>&field, const int fx, const int fy,const int gx,const int gy) {\n\tint ans = 999999;\n\tqueue<aa>que;\n\tvector<vector<int>>memo(field.size(), vector<int>(field[0].size(),999999));\n\tque.push(aa{ fx,fy,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.x == gx&&atop.y == gy) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tconst int nextx = atop.x + dx[i];\n\t\t\tconst int nexty = atop.y + dy[i];\n\t\t\tif (!field[nexty][nextx]) {\n\t\t\t\tif (atop.turn + 1 < memo[nexty][nextx]) {\n\t\t\t\t\tmemo[nexty][nextx] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ nextx,nexty,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nstruct bb {\n\tint kx;\n\tint ky;\n\tint opway;\n\tint turn;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const bb&l, const bb&r) {\n\t\treturn l.turn> r.turn;\n\t}\n};\nint memo2[52][52][4];\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 52; ++i) {\n\t\t\tfor (int j = 0; j < 52; ++j) {\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tmemo2[i][j][k] = 999999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, true));\n\t\tpriority_queue<bb, vector<bb>, Compare>que;\n\t\t{\n\t\t\tint kx = 99, ky = 99;\n\t\t\tint ox[2];\n\t\t\tint oy[2];\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (st[j] == 'X') {\n\t\t\t\t\t\tkx = min(kx, j + 1);\n\t\t\t\t\t\tky = min(ky, i + 1);\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (st[j] == 'o') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[j]=='.'){\n\t\t\t\t\t\tfield[i + 1][j + 1] = false;\n\t\t\t\t\t\tox[num] = j + 1;\n\t\t\t\t\t\toy[num] = i + 1;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (kx == 1 && ky == 1) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tconst int fx = ox[op^lu];\n\t\t\t\t\t\tconst int fy = oy[op^lu];\n\t\t\t\t\t\tint gx = kx + dx2[way];\n\t\t\t\t\t\tint gy = ky + dy2[way];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(way + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(way + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[ky + ay][kx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tmemo2[kx][ky][way] = amin;\n\t\t\t\t\tque.push(bb{ kx,ky,way,amin });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tbb atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int fkx = atop.kx;\n\t\t\tconst int fky = atop.ky;\n\t\t\tconst int fway = atop.opway;\n\t\t\tconst int fturn = atop.turn;\n\t\t\tif (fkx == 1 && fky == 1) {\n\t\t\t\tans = fturn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int tway = 0; tway < 4; ++tway) {\n\t\t\t\tif (fway == tway)continue;\n\t\t\t\tint amin = 999999;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int op = 0; op < 2; ++op) {\n\t\t\t\t\tint atime = 0;\n\t\t\t\t\tfor (int lu = 0; lu < 2; ++lu) {\n\t\t\t\t\t\tint fx = fkx + dx2[fway];\n\t\t\t\t\t\tint fy = fky + dy2[fway];\n\t\t\t\t\t\tint gx = fkx + dx2[tway];\n\t\t\t\t\t\tint gy = fky + dy2[tway];\n\t\t\t\t\t\tif (lu == 1) {\n\t\t\t\t\t\t\tgx += dx[(tway + 1) % 4];\n\t\t\t\t\t\t\tgy += dy[(tway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (op^lu) {\n\t\t\t\t\t\t\tfx += dx[(fway + 1) % 4];\n\t\t\t\t\t\t\tfy += dy[(fway + 1) % 4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (field[gy][gx])ok = false;\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tatime += getdis(field, fx, fy, gx, gy);\n\t\t\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\t\t\tfield[fky + ay][fkx + ax] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tamin = min(amin, atime);\n\t\t\t\t}\n\t\t\t\tif (!ok)continue;\n\t\t\t\telse {\n\t\t\t\t\tconst int nturn = fturn + amin;\n\t\t\t\t\tif (memo2[fkx][fky][tway]>nturn) {\n\t\t\t\t\t\tmemo2[fkx][fky][tway] = nturn;\n\t\t\t\t\t\tque.push(bb{ fkx,fky,tway,nturn });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tconst int nkx = fkx + dx[fway];\n\t\t\t\tconst int nky = fky + dy[fway];\n\t\t\t\tconst int nway = (fway + 2) % 4;\n\t\t\t\tconst int nturn = fturn + 1;\n\t\t\t\tif (memo2[nkx][nky][nway] > nturn) {\n\t\t\t\t\tmemo2[nkx][nky][nway] = nturn;\n\t\t\t\t\tque.push(bb{ nkx,nky,nway,nturn });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\n\nint d[50][50];\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n\n  \n  \n  int cc=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      d[i][j]=1e8;\n      if( abs(sy-i)<=3 && abs(sx-j)<=3 &&t[i][j]!='*') cc++;\n    }\n  }\n  \n  d[sy][sx]=0;\n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if( abs(y-sy)<=3 && abs(x-sx)<=3 ) cc--;\n    if(flg&&cc==0)break;\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n  \n  return d[ty][tx];\n}\n\nint dd[50][50][4];\nint solve(int sy,int sx,int sd,int d[50][50][4]=dd){\n\n  fill( (int*)d[0] , (int*)d[50], 1e8);\n  d[sy][sx][sd]=0;\n  queue<int> qy,qx,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qd.push(sd);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int dir=qd.front();qd.pop();\n    if(y==0&&x==0)return d[y][x][dir];\n    for(int i=0;i<4;i++){\n      int ncost=d[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax,true)+calc(y,x,by,bx,By,Bx,true) ,\n                  calc(y,x,ay,ax,By,Bx,true)+calc(y,x,by,bx,Ay,Ax,true) );\n      ncost++;\n      if(d[ny][nx][i]>ncost){\n        d[ny][nx][i]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qd.push(i);\n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sx,sy,py0,px0,ay,ax) + calc(sx,sy,py1,px1,by,bx)\n                    , calc(sx,sy,py0,px0,by,bx) + calc(sx,sy,py1,px1,ay,ax) );\n\n      //      cout<<i<<' '<<cost<<endl;\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P> P3;\n \nstring s[55];\nint h, w;\n \nint Ady[4]={-1,0,2,1};\nint Adx[4]={0,2,1,-1};\nint Bdy[4]={-1,1,2,0};\nint Bdx[4]={1,2,0,-1};\n \nint bfs(P st, P g){\n  \n  int d[55][55];\n  queue<P3> q;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) d[i][j]=INF;\n \n  d[st.first][st.second]=0;\n  q.push(P3(0,st));\n  \n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n   \n  while(!q.empty()){\n     \n    P3 t=q.front(); q.pop();\n     \n    int cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n     \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(s[ny][nx]=='*') continue;\n      if(d[ny][nx]!=INF) continue;\n      d[ny][nx]=cost+1;\n      q.push(P3(cost+1,P(ny,nx)));\n    }\n     \n  }\n   \n  return d[g.first][g.second];\n}\n \nint min_cost2(P A, P B, P C, P D){\n   \n  int r = bfs(A, B);\n  \n  r+=bfs(C, D);\n \n  if(r>INF) r=INF;\n   \n  return r;\n}\n \nint min_cost(vector<P> start, P A, P B, P C){\n   \n  int dy[4]={0,0,1,1};\n  int dx[4]={0,1,0,1};\n   \n  P g1=start[0], g2=start[1];\n \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='*';\n \n  int res=INF;\n   \n  res=min(res, min_cost2(A, g1, B, g2));\n  res=min(res, min_cost2(A, g2, B, g1));\n  \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='.';\n \n  return res;\n}\n \nint d[55][55][4];\n   \nbool check(P p){\n  if(p.first<0||h<=p.first||p.second<0||w<=p.second) return false;\n  if(s[p.first][p.second]=='*') return false;\n  return true;\n}\n \nvector<P> get(P A, int idx){\n   \n  vector<P> res;\n   \n  res.push_back(P(A.first+Ady[idx], A.second+Adx[idx]));\n  res.push_back(P(A.first+Bdy[idx], A.second+Bdx[idx]));\n   \n  return res;\n}\n \npriority_queue<P2,vector<P2>,greater<P2> > q;\n \nint dijkstra(){\n   \n  int res = INF;\n   \n  while(!q.empty()){\n     \n    P2 t = q.top(); q.pop();\n     \n    int cost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int idx=t.second.second;\n     \n    if(y==0&&x==0) res=min(res, cost);\n    \n    if(d[y][x][idx]<cost) continue;\n\n    for(int i=0;i<4;i++){\n       \n      P A = P(y+Ady[i], x+Adx[i]);\n      P B = P(y+Bdy[i], x+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n \n      vector<P> start=get(P(y,x), idx);\n       \n      if(!check(start[0])||!check(start[1])) continue;\n     \n      int add_cost = min_cost(start,A,B,P(y,x));\n       \n      if(add_cost==INF) continue;\n \n      int dy[4]={-1,0,1,0};\n      int dx[4]={0,1,0,-1};\n       \n      int ny=y+dy[i], nx=x+dx[i];\n      int ncost=cost+add_cost+1;\n      \n      if(d[ny][nx][(i+2)%4]>ncost){\n\td[ny][nx][(i+2)%4] = ncost;\n\tq.push(P2(P(ncost,ny),P(nx,(i+2)%4)));\n      }\n      \n    }\n \n  }\n \n  if(res==INF) res=-1;\n   \n  return res;  \n}\n \nint main(){\n   \n  while(1){\n     \n    cin>>h>>w;\n    if(!h&&!w) break;\n \n    vector<P> start;\n    int sy=-1, sx;\n     \n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.')\n\t  start.push_back(P(i,j));\n\tif(sy==-1&&s[i][j]=='X') sy=i, sx=j;\n      }\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++) d[i][j][k]=INF;\n     \n    for(int i=0;i<4;i++){\n       \n      P A = P(sy+Ady[i], sx+Adx[i]);\n      P B = P(sy+Bdy[i], sx+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n      \n      int cost = min_cost(start,A,B,P(sy,sx));\n      \n      d[sy][sx][i] = cost;\n       \n      q.push(P2(P(cost,sy),P(sx,i)));\n    }\n \n    if(sy==0&&sx==0) cout<<0<<endl;\n    else cout<<dijkstra()<<endl;\n    \n    while(!q.empty()) q.pop();\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <utility>\n#include <map>\n#include <queue>\n#include <string>\n#define INF 7000\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nP operator +(P p1,P p2){\n\treturn P(p1.first+p2.first,p1.second+p2.second);\n}\nP operator -(P p1,P p2){\n\treturn P(p1.first-p2.first,p1.second-p2.second);\n}\n\nint h,w;\nint res;\nint fie[51][51];\nstruct data{\n\tP k,o[2];\n\tbool operator<(const data &d1)const{\n\t\tif(k!=d1.k)return k<d1.k;\n\t\tif(o[0]!=d1.o[0])return o[0]<d1.o[0];\n\t\treturn o[1]<d1.o[1];\n\t}\n};\n\nbool cross(P a,P b){\n\tif(a==b)return true;\n\tif(a==(b+P(1,0)))return true;\n\tif(a==(b+P(0,1)))return true;\n\tif(a==(b+P(1,1)))return true;\n\treturn false;\n}\n\nbool canmove(P a){\n\tif(a.first>=0 && a.first<w && a.second>=0 && a.second<h)return true;\n\treturn false;\n}\n\nbool same(P a,P b){\n\treturn a.first==b.first && a.second==b.second;\n}\n\ndata moveking(data q,int dir){\n\tif(cross(q.o[0]+P(dx[dir],dy[dir]),q.k) && cross(q.o[1]+P(dx[dir],dy[dir]),q.k)){\n\t\tq.o[0]=q.o[0]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.o[1]=q.o[1]+P(dx[dir]*2,dy[dir]*2);\n\t\tq.k=q.k-P(dx[dir],dy[dir]);\n\t}\n\treturn q;\n}\n\ndata movepawn(data q,int dir,int s){\n\tP nmove=q.o[s]+P(dx[dir],dy[dir]);\n\tif(canmove(nmove) && !same(nmove,q.o[1-s])){\n\t\tif(!cross(nmove,q.k) && fie[nmove.second][nmove.first]!=-1){\n\t\t\tq.o[s]=nmove;\n\t\t}\n\t}\n\treturn q;\n}\n\nbool same(data a,data b){\n\tif(!same(a.k,b.k))return false;\n\tif(!same(a.o[0],b.o[0]))return false;\n\tif(!same(a.o[1],b.o[1]))return false;\n\treturn true;\n}\n\nmap<data,int> used;\n\nint bfs(data s){\n\tused.clear();\n\tqueue<data> que;\n\tif(s.o[0]>s.o[1])swap(s.o[0],s.o[1]);\n\tque.push(s);\n\tused[s]=0;\n\twhile(que.size()){\n\t\tdata q=que.front();\n\t\tque.pop();\n\t\tint cost=used[q];\n\t\tif(cost>INF)continue;\n\t\t//printf(\"%d %d %d %d %d\\n\",cost,q.o[0].first,q.o[0].second,q.o[1].first,q.o[1].second);\n\t\tif(q.k.first+q.k.second==0)return cost;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdata nq=moveking(q,i);\n\t\t\tif(nq.o[0]>nq.o[1])swap(nq.o[0],nq.o[1]);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,0);\n\t\t\tif(nq.o[0]>nq.o[1])swap(nq.o[0],nq.o[1]);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t\tnq=movepawn(q,i,1);\n\t\t\tif(nq.o[0]>nq.o[1])swap(nq.o[0],nq.o[1]);\n\t\t\tif(used.find(nq)==used.end()){\n\t\t\t\tused[nq]=cost+1;\n\t\t\t\tque.push(nq);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(h+w==0)break;\n\t\tdata s;\n\t\ts.k.first=s.k.second=-1;\n\t\tint cnt=0;\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='o')fie[i][j]=1;\n\t\t\t\tif(str[j]=='*')fie[i][j]=-1;\n\t\t\t\tif(str[j]=='X'){\n\t\t\t\t\tfie[i][j]=1;\n\t\t\t\t\tif(s.k.first==-1){\n\t\t\t\t\t\ts.k.first=j;\n\t\t\t\t\t\ts.k.second=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(str[j]=='.'){\n\t\t\t\t\ts.o[cnt].first=j;\n\t\t\t\t\ts.o[cnt++].second=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s.k.first+s.k.second==0)printf(\"0\\n\");\n\t\telse if(cnt<2)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",bfs(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) cin >> F[i];\n        return true;\n    }\n\n    const int INF = 1<<28;\n    const int MAX_H = 51;\n    const int MAX_W = 51;\n\n    const int dy[4] = {0, -1, 0, 1};\n    const int dx[4] = {-1, 0, 1, 0};\n\n    struct S {\n        int y, x;\n        int cost;\n        S(int y, int x, int cost) : y(y), x(x), cost(cost) {}\n    };\n    int dist(int ky, int kx, int sy, int sx, int gy, int gx) {\n        vector< vector<bool> > used(H, vector<bool>(W, false));\n        queue<S> Q;\n        Q.push(S(sy, sx, 0));\n        used[sy][sx] = true;\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            if (c.y == gy && c.x == gx) return c.cost;\n            for (int i = 0; i < 4; i++) {\n                int ny = c.y + dy[i];\n                int nx = c.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '*') continue;\n                if (ky <= ny && ny <= ky + 1 && kx <= nx && nx <= kx + 1) continue;\n                if (used[ny][nx]) continue;\n                used[ny][nx] = true;\n                Q.push(S(ny, nx, c.cost + 1));\n            }\n        }\n        return INF;\n    }\n\n    struct T {\n        int y, x;\n        int k; // which direction the king came?\n        int cost;\n        T(int y, int x, int k, int cost) : y(y), x(x), k(k), cost(cost) {}\n    };\n    bool operator<(const T& a, const T& b) {\n        return a.cost > b.cost;\n    }\n    ostream& operator<<(ostream& os, const T& t) {\n        return os << \"T((\" << t.y << \",\" << t.x << \"), \" << t.k << \", \" << t.cost << \")\";\n    }\n\n    bool check(int y, int x) {\n        // can the king move into (y, x)?\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                int ny = y + i;\n                int nx = x + j;\n                if (ny < 0 || ny >= H) return false;\n                if (nx < 0 || nx >= W) return false;\n                if (F[ny][nx] == '*') return false;\n            }\n        }\n        return true;\n    }\n\n    T move(int k, int y, int x, int past_cost, int sy0, int sx0, int sy1, int sx1) {\n        int kny = y + dy[k];\n        int knx = x + dx[k];\n        if (!check(kny, knx)) throw -1;\n        int ny, nx, my, mx;\n        switch (k) {\n            case 0: ny = y; nx = x - 1; my = y + 1; mx = x - 1; break;\n            case 1: ny = y - 1; nx = x; my = y - 1; mx = x + 1; break;\n            case 2: ny = y; nx = x + 2; my = y + 1; mx = x + 2; break;\n            case 3: ny = y + 2; nx = x; my = y + 2; mx = x + 1; break;\n            default: break;\n        }\n        int cost = min(\n                     dist(y, x, ny, nx, sy0, sx0) + dist(y, x, my, mx, sy1, sx1),\n                     dist(y, x, ny, nx, sy1, sx1) + dist(y, x, my, mx, sy0, sx0)\n                   );\n        return T(kny, knx, (k + 2) % 4, past_cost + cost + 1);\n    }\n\n    void solve() {\n        int sy0, sx0, sy1, sx1;\n        int ky, kx;\n        int c = 0;\n        bool found_king = false;\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n            if (F[i][j] == 'X' && !found_king) {\n                ky = i;\n                kx = j;\n                found_king = true;\n            }\n            if (F[i][j] == '.') {\n                (c == 0 ? sy0 : sy1) = i;\n                (c == 0 ? sx0 : sx1) = j;\n                c++;\n            }\n        }\n        assert(c == 2);\n\n        int D[MAX_H][MAX_W][5];\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) for (int k = 0; k < 5; k++) D[i][j][k] = INF;\n        D[ky][kx][4] = 0;\n        priority_queue<T> PQ;\n        for (int i = 0; i < 4; i++) {\n            try {\n                T t = move(i, ky, kx, 0, sy0, sx0, sy1, sx1);\n                PQ.push(t);\n                D[t.y][t.x][t.k] = t.cost;\n            } catch (int e) {}\n        }\n        while (!PQ.empty()) {\n            T c = PQ.top(); PQ.pop();\n            for (int i = 0; i < 4; i++) {\n                int ny, nx, my, mx;\n                switch (c.k) {\n                    case 0: ny = c.y; nx = c.x - 1; my = c.y + 1; mx = c.x - 1; break;\n                    case 1: ny = c.y - 1; nx = c.x; my = c.y - 1; mx = c.x + 1; break;\n                    case 2: ny = c.y; nx = c.x + 2; my = c.y + 1; mx = c.x + 2; break;\n                    case 3: ny = c.y + 2; nx = c.x; my = c.y + 2; mx = c.x + 1; break;\n                    default: break;\n                }\n                try {\n                    T t = move(i, c.y, c.x, c.cost, ny, nx, my, mx);\n                    if (D[t.y][t.x][t.k] > t.cost) {\n                        PQ.push(t);\n                        D[t.y][t.x][t.k] = t.cost;\n                    }\n                } catch (int e) {}\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < 5; i++) {\n            ans = min(ans, D[0][0][i]);\n        }\n        if (ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <queue>\n#include <deque>\n#include <vector>\n\n#define frs first\n#define scn second\n#define mpr make_pair\n#define pbk push_back\nusing namespace std;\n\nconst int kInf = numeric_limits< int >::max() / 10;\ntypedef pair< int, int > Pr;\ntypedef pair< int, pair< Pr, int > > PQNode;\ntypedef priority_queue< PQNode, vector< PQNode >, greater< PQNode > > PQue;\n\nconst int kNxt1[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\nconst int kNxt2[4][2][2] = {\n  {{-1, 0}, {-1, 1}},\n  {{0, 2}, {1, 2}},\n  {{2, 0}, {2, 1}},\n  {{0, -1}, {1, -1}}\n};\n\nint H, W;\nchar plt[52][52];\nPr king, fc1, fc2;\nint f[52][52][4];\n\nvoid read();\nvoid soups_on();\nvoid yee_haw();\nint sugar_cube(Pr, Pr, Pr, Pr, Pr);\nint bfs(Pr, Pr);\n\ninline bool is_valid(Pr p) {\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j)\n      if (plt[p.frs + i][p.scn + j] == '*')\n        return false;\n  return true;\n}\n\nint main() {\n  while (cin >> H >> W, H + W)\n    read(), soups_on();\n\n  return 0;\n}\n\nvoid read() {\n  king.frs = king.scn = -1;\n  fc1.frs = fc1.scn = fc2.frs = fc2.scn = -1;\n  fill(&plt[0][0], &plt[52][0], '*');\n  for (int i = 1; i <= H; ++i)\n    for (int j = 1; j <= W; ++j) {\n      cin >> plt[i][j];\n      if (plt[i][j] == 'X') {\n        plt[i][j] = 'o';\n        if (king.frs == -1)\n          king.frs = i, king.scn = j;\n      }\n      else if (plt[i][j] == '.') {\n        plt[i][j] = 'o';\n        if (fc1.frs == -1)\n          fc1.frs = i, fc1.scn = j;\n        else\n          fc2.frs = i, fc2.scn = j;\n      }\n    }\n}\n\nvoid soups_on() {\n  if (king.frs == 1 && king.scn == 1) {\n    cout << \"0\\n\";\n    return;\n  }\n\n  fill(&f[0][0][0], &f[52][0][0], kInf);\n  yee_haw();\n\n  PQue pq;\n  PQNode tp;\n  Pr uk, vk, s1, s2, g1, g2;\n  int ud, vd, cst, res, ln;\n\n  for (int i = 0; i < 4; ++i)\n    if ((cst = f[king.frs][king.scn][i]) < kInf)\n      pq.push(mpr(cst, mpr(king, i)));\n\n  res = kInf;\n  while (!pq.empty()) {\n    tp = pq.top(), pq.pop();\n    cst = tp.frs, uk = tp.scn.frs, ud = tp.scn.scn;\n\n    if (cst > f[uk.frs][uk.scn][ud])  continue;\n    if (uk.frs == 1 && uk.scn == 1) {\n      res = cst;\n      break;\n    }\n\n    // move king piece\n    vk = uk, vk.frs += kNxt1[ud][0], vk.scn += kNxt1[ud][1];\n    vd = (ud + 2) % 4;\n    if (is_valid(vk) && f[vk.frs][vk.scn][vd] > cst + 1) {\n      f[vk.frs][vk.scn][vd] = cst + 1;\n      pq.push(mpr(cst + 1, mpr(vk, vd)));\n    }\n\n    // move free spaces\n    for (int i = 0; i < 4; ++i) {\n      if (i == ud)  continue;\n      vk = uk, vd = i;\n      s1 = s2 = g1 = g2 = uk;\n      s1.frs += kNxt2[ud][0][0], s1.scn += kNxt2[ud][0][1];\n      s2.frs += kNxt2[ud][1][0], s2.scn += kNxt2[ud][1][1];\n      g1.frs += kNxt2[vd][0][0], g1.scn += kNxt2[vd][0][1];\n      g2.frs += kNxt2[vd][1][0], g2.scn += kNxt2[vd][1][1];\n      ln = sugar_cube(s1, s2, g1, g2, uk);\n      if (f[vk.frs][vk.scn][vd] > cst + ln) {\n        f[vk.frs][vk.scn][vd] = cst + ln;\n        pq.push(mpr(cst + ln, mpr(vk, vd)));\n      }\n    }\n  }\n\n  cout << (res < kInf ? res : -1) << \"\\n\";\n}\n\nint sugar_cube(Pr s1, Pr s2, Pr g1, Pr g2, Pr kp) {\n  int ret = kInf;\n\n  // mark king as wall\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j)\n      plt[kp.frs + i][kp.scn + j] = '*';\n\n  ret = min(ret, bfs(s1, g1) + bfs(s2, g2));\n  ret = min(ret, bfs(s1, g2) + bfs(s2, g1));\n\n  // mark king back as pawn\n  for (int i = 0; i <= 1; ++i)\n    for (int j = 0; j <= 1; ++j)\n      plt[kp.frs + i][kp.scn + j] = 'o';\n\n  return ret;\n}\n\nvoid yee_haw() {\n  for (int i = 0; i < 4; ++i) {\n    Pr g1, g2;\n    g1.frs = king.frs + kNxt2[i][0][0], g1.scn = king.scn + kNxt2[i][0][1];\n    g2.frs = king.frs + kNxt2[i][1][0], g2.scn = king.scn + kNxt2[i][1][1];\n    f[king.frs][king.scn][i] = min(f[king.frs][king.scn][i],\n                                   sugar_cube(fc1, fc2, g1, g2, king));\n  }\n}\n\nint bfs(Pr ss, Pr gs) {\n  static int vst[52][52], vst_cnt;\n  deque< pair< Pr, int > > que;\n  Pr cs, ns;\n  int stp;\n\n  if (ss == gs)\n    return 0;\n\n  vst[ss.frs][ss.scn] = ++vst_cnt, que.pbk(mpr(ss, 0));\n  while (!que.empty()) {\n    cs = que.front().frs, stp = que.front().scn, que.pop_front();\n    for (int i = 0; i < 4; ++i) {\n      ns = cs, ns.frs += kNxt1[i][0], ns.scn += kNxt1[i][1];\n      if (plt[ns.frs][ns.scn] == 'o' && vst[ns.frs][ns.scn] != vst_cnt) {\n        if (ns == gs)\n          return stp + 1;\n        vst[ns.frs][ns.scn] = vst_cnt, que.pbk(mpr(ns, stp + 1));\n      }\n    }\n  }\n\n  return kInf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\ntypedef pair<int,P> P3;\n \nstring s[55];\nint h, w;\n \nint Ady[4]={-1,0,2,1};\nint Adx[4]={0,2,1,-1};\nint Bdy[4]={-1,1,2,0};\nint Bdx[4]={1,2,0,-1};\n \nint bfs(P st, P g){\n  \n  int d[55][55];\n  queue<P3> q;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) d[i][j]=INF;\n \n  d[st.first][st.second]=0;\n  q.push(P3(0,st));\n  \n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n   \n  while(!q.empty()){\n     \n    P3 t=q.front(); q.pop();\n     \n    int cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n     \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx) continue;\n      if(s[ny][nx]=='*') continue;\n      if(d[ny][nx]!=INF) continue;\n      d[ny][nx]=cost+1;\n      q.push(P3(cost+1,P(ny,nx)));\n    }\n     \n  }\n   \n  return d[g.first][g.second];\n}\n \nint min_cost2(P A, P B, P C, P D){\n   \n  int r = bfs(A, B);\n  \n  s[B.first][B.second]='*';\n  \n  r+=bfs(C, D);\n \n  s[B.first][B.second]='.';\n   \n  if(r>INF) r=INF;\n   \n  return r;\n}\n \nint min_cost(vector<P> start, P A, P B, P C){\n   \n  int dy[4]={0,0,1,1};\n  int dx[4]={0,1,0,1};\n   \n  P g1=start[0], g2=start[1];\n \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='*';\n \n  int res=INF;\n   \n  res=min(res, min_cost2(A, g1, B, g2));\n  res=min(res, min_cost2(A, g2, B, g1));\n  res=min(res, min_cost2(B, g1, A, g2));\n  res=min(res, min_cost2(B, g2, A, g1));\n   \n  for(int i=0;i<4;i++)\n    s[C.first+dy[i]][C.second+dx[i]]='.';\n \n  return res;\n}\n \nint d[55][55][4];\n   \nbool check(P p){\n  if(p.first<0||h<=p.first||p.second<0||w<=p.second) return false;\n  if(s[p.first][p.second]=='*') return false;\n  return true;\n}\n \nvector<P> get(P A, int idx){\n   \n  vector<P> res;\n   \n  res.push_back(P(A.first+Ady[idx], A.second+Adx[idx]));\n  res.push_back(P(A.first+Bdy[idx], A.second+Bdx[idx]));\n   \n  return res;\n}\n \npriority_queue<P2,vector<P2>,greater<P2> > q;\n \nint dijkstra(){\n   \n  int res = INF;\n   \n  while(!q.empty()){\n     \n    P2 t = q.top(); q.pop();\n     \n    int cost=t.first.first;\n    int y=t.first.second;\n    int x=t.second.first;\n    int idx=t.second.second;\n     \n    if(y==0&&x==0) res=min(res, cost);\n    \n    if(d[y][x][idx]<cost) continue;\n\n    for(int i=0;i<4;i++){\n       \n      P A = P(y+Ady[i], x+Adx[i]);\n      P B = P(y+Bdy[i], x+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n \n      vector<P> start=get(P(y,x), idx);\n       \n      if(!check(start[0])||!check(start[1])) continue;\n     \n      int add_cost = min_cost(start,A,B,P(y,x));\n       \n      if(add_cost==INF) continue;\n \n      int dy[4]={-1,0,1,0};\n      int dx[4]={0,1,0,-1};\n       \n      int ny=y+dy[i], nx=x+dx[i];\n      int ncost=cost+add_cost+1;\n      \n      if(d[ny][nx][(i+2)%4]>ncost){\n\td[ny][nx][(i+2)%4] = ncost;\n\tq.push(P2(P(ncost,ny),P(nx,(i+2)%4)));\n      }\n      \n    }\n \n  }\n \n  if(res==INF) res=-1;\n   \n  return res;  \n}\n \nint main(){\n   \n  while(1){\n     \n    cin>>h>>w;\n    if(!h&&!w) break;\n \n    vector<P> start;\n    int sy=-1, sx;\n     \n    for(int i=0;i<h;i++){\n      cin>>s[i];\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='.')\n\t  start.push_back(P(i,j));\n\tif(sy==-1&&s[i][j]=='X') sy=i, sx=j;\n      }\n    }\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<4;k++) d[i][j][k]=INF;\n     \n    for(int i=0;i<4;i++){\n       \n      P A = P(sy+Ady[i], sx+Adx[i]);\n      P B = P(sy+Bdy[i], sx+Bdx[i]);\n       \n      if(!check(A)||!check(B)) continue;\n      \n      int cost = min_cost(start,A,B,P(sy,sx));\n      \n      d[sy][sx][i] = cost;\n       \n      q.push(P2(P(cost,sy),P(sx,i)));\n    }\n \n    if(sy==0&&sx==0) cout<<0<<endl;\n    else cout<<dijkstra()<<endl;\n    \n    while(!q.empty()) q.pop();\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <set>\nusing namespace std;\n#define  MP make_pair\n#define  PB push_back\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define fi first\n#define se second\n#define inf 1000000007\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\npair<pair<int,int>,pair<int,int> >tugi(int i,int j,int dir){\n    if(dir==0){\n        return MP(MP(i,j+2),MP(i+1,j+2));\n    }else if(dir==1){\n        return MP(MP(i,j-1),MP(i+1,j-1));\n    }else if(dir==2){\n        return MP(MP(i+2,j),MP(i+2,j+1));\n    }else if(dir==3){\n        return MP(MP(i-1,j),MP(i-1,j+1));\n    }\n}\npair<pair<int,int>,pair<int,int> > mae(int i,int j,int dir){\n    if(dir==0){\n        return MP(MP(i,j-1),MP(i+1,j-1));\n    }else if(dir==1){\n        return MP(MP(i,j+2),MP(i+1,j+2));\n    }else if(dir==2){\n        return MP(MP(i-1,j),MP(i-1,j+1));\n    }else if(dir==3){\n        return MP(MP(i+2,j),MP(i+2,j+1));\n    }\n}\n\nint n,m;\nvector<string>s;\nvector<vector<bool> > ng;\nvector<vector<vector<bool> > > flag;\n\nbool lmov(int i,int j,int dir){\n    if(j+dx[dir]<0||j+dx[dir]+1>=m)return false;\n    if(i+dy[dir]<0||i+dy[dir]+1>=n)return false;\n    if(s[i+dy[dir]][j+dx[dir]]=='*')return false;\n    if(s[i+dy[dir]+1][j+dx[dir]]=='*')return false;\n    if(s[i+dy[dir]][j+dx[dir]+1]=='*')return false;\n    if(s[i+dy[dir]+1][j+dx[dir]+1]=='*')return false;\n    return true;\n}\nbool smov(int i,int j,int dir){\n    if(j+dx[dir]<0||j+dx[dir]>=m)return false;\n    if(i+dy[dir]<0||i+dy[dir]>=n)return false;\n    if(s[i+dy[dir]][j+dx[dir]]=='*')return false;\n    return true;\n}\n\nint oridst(pair<int,int>b,pair<int,int>a){\n    //cerr << a.fi << \" \" << a.se << \" \"<< b.fi << \" \" << b.se << endl;\n    queue<pair<int,pair<int,int> > >q;\n    q.push(MP(0,a));\n    vector<vector<bool> > reached(n,vector<bool>(m));\n    int res = inf;\n    while(!q.empty()){\n        auto x= q.front();\n        if(x.se==b){\n            res = x.fi;\n            break;\n        }\n        q.pop();\n        rep(i,4){\n            if(smov(x.se.fi,x.se.se,i)){\n                if(s[x.se.fi+dy[i]][x.se.se+dx[i]]!='X'){\n                    if(!reached[x.se.fi+dy[i]][x.se.se+dx[i]]){\n                        reached[x.se.fi+dy[i]][x.se.se+dx[i]] = true;\n                        q.push(MP(x.fi+1,MP(x.se.fi+dy[i],x.se.se+dx[i])));\n                    }\n                }\n            }\n        }\n    }\n\n\n    return res+1;\n}\nint secdst(pair<int,int>b,pair<int,int>a,pair<int,int>now){\n    //cerr << a.fi << \" \" << a.se << \" \"<< b.fi << \" \" << b.se << endl;\n    queue<pair<int,pair<int,int> > >q;\n    set<pair<int,int> > st;\n    st.insert(MP(now.fi,now.se));\n    st.insert(MP(now.fi+1,now.se));\n    st.insert(MP(now.fi+1,now.se+1));\n    st.insert(MP(now.fi,now.se+1));\n    q.push(MP(0,a));\n    vector<vector<bool> > reached(n,vector<bool>(m));\n    int res = inf;\n    while(!q.empty()){\n        auto x= q.front();\n        if(x.se==b){\n            res = x.fi;\n            break;\n        }\n        q.pop();\n        rep(i,4){\n            if(smov(x.se.fi,x.se.se,i)){\n                if(st.count(MP(x.se.fi+dy[i],x.se.se+dx[i]))==0){\n                    if(!reached[x.se.fi+dy[i]][x.se.se+dx[i]]){\n                        reached[x.se.fi+dy[i]][x.se.se+dx[i]] = true;\n                        q.push(MP(x.fi+1,MP(x.se.fi+dy[i],x.se.se+dx[i])));\n                    }\n                }\n            }\n        }\n    }\n\n\n    return res+1;\n}\nint main(){\n    \n    while(1){\n        cin >> n >> m;\n        if(n==0&&m==0)break;\n        s.resize(n);\n        rep(i,n)cin >> s[i];\n        ng.resize(n);\n        rep(i,n)ng[i].resize(m);\n        int px = 10000;\n        int py = 10000;\n        vector<pair<int,int> > oridot; \n        rep(i,n){\n            rep(j,m){\n                if(s[i][j]=='*'){\n                    ng[i][j] = 1;\n                }\n                if(s[i][j]=='X'){\n                    py = min(py,i);\n                    px = min(px,j);\n                }\n                if(s[i][j]=='.'){\n                    oridot.push_back(MP(i,j));\n                }\n            }\n        }\n        if(py==0&&px==0){\n            cout << 0 << endl;\n            continue;\n        }\n        vector<vector<vector<vector<bool> > > >reached(n,vector<vector<vector<bool>>>(m,vector<vector<bool>>(4,vector<bool>(4))));\n        \n        priority_queue<pair<pair<int,pair<int,int> >,pair<int,int> >,vector<pair<pair<int,pair<int,int>>,pair<int,int> > >,greater<pair<pair<int,pair<int,int>>,pair<int,int> > > > pq;\n        for(int i=0;i<4;i++){\n            if(lmov(py,px,i)){\n                pair<int,int> t1,t2;\n                t1 = tugi(py,px,i).fi;\n                t2 = tugi(py,px,i).se;\n                if(s[t1.fi][t1.se]=='.'&&s[t2.fi][t2.se]=='.'){\n                    pq.push(MP(MP(1,MP(i,0)),MP(py+dy[i],px+dx[i])));\n                    reached[py+dy[i]][px+dx[i]][i][0]= true;\n                    reached[py+dy[i]][px+dx[i]][i][1]= true;\n                    reached[py+dy[i]][px+dx[i]][i][2]= true;\n                    reached[py+dy[i]][px+dx[i]][i][3]= true;\n                }else if(s[t1.fi][t1.se]=='o'&&s[t2.fi][t2.se]=='.'){\n                    int dst;\n                    if(t2==oridot[0]){\n                        dst = oridst(t1,oridot[1]);\n                    }else{\n                        dst = oridst(t1,oridot[0]);\n                    }\n                    if(dst>=inf)continue;\n                    pq.push(MP(MP(dst,MP(i,0)),MP(py+dy[i],px+dx[i])));\n                    reached[py+dy[i]][px+dx[i]][i][0]= true;\n                    reached[py+dy[i]][px+dx[i]][i][1]= true;\n                    reached[py+dy[i]][px+dx[i]][i][2]= true;\n                    reached[py+dy[i]][px+dx[i]][i][3]= true;\n                }else if(s[t1.fi][t1.se]=='.'&&s[t2.fi][t2.se]=='o'){\n                    int dst;\n                    if(t1==oridot[0]){\n                        dst = oridst(t2,oridot[1]);\n                    }else{\n                        dst = oridst(t2,oridot[0]);\n                    }\n                    if(dst>=inf)continue;\n                    pq.push(MP(MP(dst,MP(i,0)),MP(py+dy[i],px+dx[i])));\n                    reached[py+dy[i]][px+dx[i]][i][0]= true;\n                    reached[py+dy[i]][px+dx[i]][i][1]= true;\n                    reached[py+dy[i]][px+dx[i]][i][2]= true;\n                    reached[py+dy[i]][px+dx[i]][i][3]= true;\n                }else{\n                    int dst= oridst(t2,oridot[1])+oridst(t1,oridot[0]);\n                    dst = min(dst,oridst(t2,oridot[0])+oridst(t1,oridot[1]));\n                    if(dst>=inf)continue;\n                    pq.push(MP(MP(dst-1,MP(i,0)),MP(py+dy[i],px+dx[i])));\n                    reached[py+dy[i]][px+dx[i]][i][0]= true;\n                    reached[py+dy[i]][px+dx[i]][i][1]= true;\n                    reached[py+dy[i]][px+dx[i]][i][2]= true;\n                    reached[py+dy[i]][px+dx[i]][i][3]= true;\n                }\n            }\n        }\n        // while(!pq.empty()){\n        //     auto x = pq.top();\n        //     cerr << x.first.first << \" \" << x.fi.se << endl;\n        //     pq.pop();\n        // }\n        reached[py][px][0][0]= true;\n        reached[py][px][1][0]= true;\n        reached[py][px][2][0]= true;\n        reached[py][px][3][0]= true;\n        reached[py][px][0][1]= true;\n        reached[py][px][1][1]= true;\n        reached[py][px][2][1]= true;\n        reached[py][px][3][1]= true;\n        reached[py][px][0][2]= true;\n        reached[py][px][1][2]= true;\n        reached[py][px][2][2]= true;\n        reached[py][px][3][2]= true;\n        reached[py][px][0][3]= true;\n        reached[py][px][1][3]= true;\n        reached[py][px][2][3]= true;\n        reached[py][px][3][3]= true;\n        int ans = inf;\n        vector<vector<vector<int> > >shortest(n,vector<vector<int>>(m,vector<int>(4,inf)));\n        \n        while(!pq.empty()){\n            auto x = pq.top();\n            pq.pop();\n\n            if(x.se==MP(0,0)){\n                ans = min(ans,x.fi.fi);\n                break;\n            }\n            auto now = x.second;\n            //cerr << now.fi << \" \" << now.se << \" \" << x.fi.se << \"  \" << x.fi.fi  << endl;\n            int dir = x.fi.se.fi;\n            int dir2 = x.fi.se.se;\n            int dst = x.fi.fi;\n            shortest[now.fi][now.se][dir]= min(shortest[now.fi][now.se][dir],dst);\n            if(shortest[now.fi][now.se][dir]!=dst)continue;\n            // if(reached[now.fi][now.se][dir])continue;\n            for(int i=0;i<4;i++){\n                if(lmov(now.fi,now.se,i)&&!reached[now.fi+dy[i]][now.se+dx[i]][i][dir]){\n                    pair<int,int> t1,t2,s1,s2;\n                    t1 = tugi(now.fi,now.se,i).fi;\n                    t2 = tugi(now.fi,now.se,i).se;\n                    s1 = mae(now.fi,now.se,dir).fi;\n                    s2 = mae(now.fi,now.se,dir).se;\n                    // cerr << t1.first << \" \" << t1.second << \" \" << t2.first << \" \" << t2.second<< endl;\n                    // cerr << s1.first << \" \" << s1.second << \" \" << s2.first << \" \" << s2.second<< endl;\n                    int dst2= secdst(t2,s1,now)+secdst(t1,s2,now);\n                    \n                    dst2 = min(dst2,secdst(t2,s2,now)+secdst(t1,s1,now));\n                    //cerr << dst2 << endl;\n                    if(dst-1+dst2>=inf)continue;\n                    if(shortest[now.fi+dy[i]][now.se+dx[i]][dir]<=dst-1+dst2)continue;\n                    shortest[now.fi][now.se][dir]=dst-1+dst2;\n                    reached[now.fi+dy[i]][now.se+dx[i]][i][dir]= true;\n                    pq.push(MP(MP(dst-1+dst2,MP(i,dir)),MP(now.fi+dy[i],now.se+dx[i])));\n                    \n                }\n            }\n        }\n        if(ans==inf){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n        s.clear();\n        ng.clear();\n        flag.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nint H, W;\nint field[52][52];\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\n\nint sdx[4][2] = {\n  {0, 1},\n  {-1, -1},\n  {0, 1},\n  {2, 2},\n};\n\nint sdy[4][2] = {\n  {2, 2},\n  {0, 1},\n  {-1, -1},\n  {0, 1},\n};\n\nstruct state{\n  // cost, kingのupper-leftの位置、spaceの方角\n  int cost, r, c, d;\n  state(){}\n  state(int _cost, int _r, int _c, int _d) : cost(_cost), r(_r), c(_c), d(_d){}\n};\n\nbool operator<(const state &s1, const state &s2) {return s1.cost > s2.cost;}\n\nint bfs(int r1, int c1, int r2, int c2){\n  int dist[52][52];  \n  memset(dist, -1, sizeof(dist));\n  dist[r1][c1] = 0;\n  queue<P> que;\n  que.push(P(r1, c1));\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    int r = p.first;\n    int c = p.second;\n    if(r == r2 && c == c2) return dist[r2][c2];\n    REP(i, 4){\n      int nr = r + dx[i];\n      int nc = c + dy[i];\n      if(field[nr][nc] && dist[nr][nc] == -1) {\n        dist[nr][nc] = dist[r][c] + 1;\n        que.push(P(nr, nc));\n      }\n    }\n  }\n  return -1;\n}\n\nvector<P> get_space(int r, int c, int i){\n  vector<P> ans;\n  // cout << r << \" \" << c << endl;\n  ans.PB(P(r + sdx[i][0], c + sdy[i][0]));\n  ans.PB(P(r + sdx[i][1], c + sdy[i][1]));  \n  return ans;\n}\n\nint calc_dist2(const vector<P> &src, const vector<P> &dst){\n  int ans = -1;\n  \n  int d0 = bfs(src[0].first, src[0].second, dst[0].first, dst[0].second);\n  int d1 = bfs(src[1].first, src[1].second, dst[1].first, dst[1].second);\n  if(d0 >= 0 && d1 >= 0) ans = d0 + d1;\n  \n  int d2 = bfs(src[1].first, src[1].second, dst[0].first, dst[0].second);\n  int d3 = bfs(src[0].first, src[0].second, dst[1].first, dst[1].second);\n  if(d2 >= 0 && d3 >= 0 && (ans == -1 || ans > d2 + d3)) ans = d2 + d3;\n  return ans;\n}\n\nbool ok(vector<P> &vp){\n  return field[vp[0].first][vp[0].second] >0 && field[vp[1].first][vp[1].second] > 0;\n}\n\nvoid init(P king, vector<P> space, priority_queue<state> &que, int dist[52][52][4]){\n  assert(space.size() == 2);\n  int r = king.first;\n  int c = king.second;\n  REP(i, 2)REP(j, 2) field[r+i][c+j] = 0;\n  REP(i, 4){\n    vector<P> vp = get_space(r, c, i);\n    if(!ok(vp)) continue;\n    int cost = calc_dist2(space, vp);\n    if(cost >= 0){\n      dist[r][c][i] = cost;\n      que.push(state(cost, r, c, i));\n    }\n  }\n  REP(i, 2)REP(j, 2) field[r+i][c+j] = 1;\n}\n\n\nint calc_cost(int r, int c, int d, int i){\n  if(d == i) return 0;\n  vector<P> src = get_space(r, c, d);\n  vector<P> dst = get_space(r, c, i);\n  \n  if(ok(src) && ok(dst)){\n    // cout << src[0].first << \" \" << src[0].second  << endl;\n    // cout << src[1].first << \" \" << src[1].second  << endl;    \n    return calc_dist2(src, dst);\n  }else{\n    return -1;\n  }\n}\n\nint dijkstra(P king, vector<P> space){\n  if(king == P(1, 1)) return 0;\n  \n  int dist[52][52][4];\n  memset(dist, -1, sizeof(dist));\n  \n  priority_queue<state> que;\n  init(king, space, que, dist);\n\n  while(!que.empty()){\n\n    \n  \n    state s = que.top(); que.pop();\n    // REP(i, H + 2){\n    //   REP(j, W + 2){\n    //     cout << field[i][j];\n    //   }\n    //   cout << endl;\n    // }\n    \n    if(s.r == 1 && s.c == 1) return s.cost;\n    \n    if(s.cost > dist[s.r][s.c][s.d]) continue;\n    REP(i, 2)REP(j, 2) field[s.r+i][s.c+j] = 0;\n    \n    REP(i, 4){\n      int r2 = s.r + dx[i];\n      int c2 = s.c + dy[i];\n      int cost = calc_cost(s.r, s.c, s.d, i) + 1;\n      int &D = dist[r2][c2][(i+2)%4];\n      if(cost > 0 && (D == -1 || D > s.cost + cost)){\n        D = s.cost + cost;\n        que.push(state(D, r2, c2, (i+2)%4));\n      }\n    }\n    \n    REP(i, 2)REP(j, 2) field[s.r+i][s.c+j] = 1;\n  }\n  return -1;\n}\n\nint main(){\n  char c;\n  while(cin >> H >> W && H && W){\n    memset(field, 0, sizeof(field));\n    \n    P king;\n    vector<P> space;\n    \n    REP(i, H) REP(j, W){\n      cin >> c;\n      if(c == '.')  space.PB(P(i+1, j+1));\n      if(c == 'X')  king = P(i + 1, j + 1);\n      field[i+1][j+1] = c == '*' ? 0 : 1;\n    }\n    king.first--;\n    king.second--;\n    cout << dijkstra(king, space)<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint ey[]={-1,-1,0,1,2,2,1,0};\nint ex[]={0,1,2,2,1,0,-1,-1};\n\n\nint H,W;\nchar t[50][50];\nint sy,sx;\nint py0,px0,py1,px1;\n\n\nmap< int , int > mp[50][50][50][50];\n\n\nint calc(int gy,int gx,int sy,int sx,int ty,int tx,bool flg=false){\n  flg=false;\n  \n  if(flg && mp[gy][gx][sy][sx].count(ty*50+tx)>0 ){\n    return mp[gy][gx][sy][sx][ty*50+tx];\n  }\n\n  int d[50][50];\n  \n  int cc=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      d[i][j]=1e8;\n      if( abs(sy-i)<=3 && abs(sx-j)<=3 &&t[i][j]!='*') cc++;\n    }\n  }\n  \n  d[sy][sx]=0;\n  queue<int> qy,qx;\n  qy.push(sy);\n  qx.push(sx);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    if( abs(y-sy)<=3 && abs(x-sx)<=3 ) cc--;\n    if(flg&&cc==0)break;\n    \n    for(int i=0;i<4;i++){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      if(t[ny][nx]=='*')continue;\n      if(gy<=ny&&ny<gy+2&&gx<=nx&&nx<gx+2)continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n\n  if(flg)\n    for(int i=-3;i<=3;i++)\n      for(int j=-3;j<=3;j++)\n        if(0<=sy+i&&sy+i<H && 0<=sx+j&&sx+j<W)\n          mp[gy][gx][sy][sx][ (sy+i)*50+sx ]=d[sy+i][sx+j];\n  \n  return d[ty][tx];\n}\n\n\nint solve(int sy,int sx,int sd){\n  int d[50][50][4];\n  fill( (int*)d[0] , (int*)d[50], 1e8);\n  d[sy][sx][sd]=0;\n  queue<int> qy,qx,qd;\n  qy.push(sy);\n  qx.push(sx);\n  qd.push(sd);\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    int dir=qd.front();qd.pop();\n    if(y==0&&x==0)return d[y][x][dir];\n    for(int i=0;i<4;i++){\n      int ncost=d[y][x][dir];\n      int ay=y+ey[i*2],ax=x+ex[i*2];\n      int by=y+ey[i*2+1],bx=x+ex[i*2+1];\n      int flg=(dir+2)%4;\n      int Ay=y+ey[flg*2],Ax=x+ex[flg*2];\n      int By=y+ey[flg*2+1],Bx=x+ex[flg*2+1];\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ay<0||ax<0||ay>=H||ax>=W)continue;\n      if(by<0||bx<0||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      ncost+=min( calc(y,x,ay,ax,Ay,Ax,true)+calc(y,x,by,bx,By,Bx,true) ,\n                  calc(y,x,ay,ax,By,Bx,true)+calc(y,x,by,bx,Ay,Ax,true) );\n      ncost++;\n      if(d[ny][nx][i]>ncost){\n        d[ny][nx][i]=ncost;\n        qy.push(ny);\n        qx.push(nx);\n        qd.push(i);\n      }\n    }\n  }\n  return 1e8;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    \n    sy=sx=-1;\n    py0=px0=-1;\n    py1=px1=-1;\n    for(int i=0;i<H*W;i++)\n      for(int j=0;j<H*W;j++)\n        mp[i/W][i%W][j/W][j%W].clear();\n    \n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>t[i][j];\n        if(t[i][j]=='X'&&sy==-1&&sx==-1){\n          sy=i;\n          sx=j;\n        }\n        if(t[i][j]=='.'){\n          py0=py1;\n          px0=px1;\n          py1=i;\n          px1=j;\n        }\n      }\n    }\n    \n    int ans=1e9;\n    if(sy==0&&sx==0)ans=0;\n    \n    for(int i=0;i<4;i++){\n      int ay=sy+ey[i*2],ax=sx+ex[i*2];\n      int by=sy+ey[i*2+1],bx=sx+ex[i*2+1];\n      if(ay<0||ax<0||by<0||bx<0)continue;\n      if(ay>=H||ax>=W||by>=H||bx>=W)continue;\n      if(t[ay][ax]=='*'||t[by][bx]=='*')continue;\n      int cost=min(   calc(sx,sy,py0,px0,ay,ax) + calc(sx,sy,py1,px1,by,bx)\n                    , calc(sx,sy,py0,px0,by,bx) + calc(sx,sy,py1,px1,ay,ax) );\n\n      //      cout<<i<<' '<<cost<<endl;\n      ans=min(ans,cost+solve(sy,sx,i));\n    }\n    if(ans>=1e8)ans=-1;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<endl)\n\nstruct DUMP : stringstream {\n\ttemplate<class T>\n\tDUMP &operator,(const T &t) {\n\t\tif(this->tellp()) *this << \", \";\n\t\t*this << t;\n\t\treturn *this;\n\t}\n};\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct state {\n\tint x, y, d, dist;\n\tstate(int x_, int y_, int d_, int dist_):x(x_), y(y_), d(d_), dist(dist_) {}\n\tstate(const state &s):x(s.x), y(s.y), d(s.d), dist(s.dist) {}\n\tbool operator>(const state &s) const {\n\t\treturn dist > s.dist;\n\t}\n};\n\n#define X first\n#define Y second\n\nconstexpr int INF = (1 << 28);\nconstexpr int MAX_SIZE = 50;\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\nconstexpr int ddx[4][2] = {{2, 2}, {-1, -1}, {0, 1}, {0, 1}};\nconstexpr int ddy[4][2] = {{0, 1}, {0, 1}, {2, 2}, {-1, -1}};\n\nint h, w;\nstring field[MAX_SIZE + 2];\nint dist[MAX_SIZE + 2][MAX_SIZE + 2][4];\n\nvoid overwrite(int x, int y, char c) {\n\tfor(int i = 0; i <= 1; ++i) {\n\t\tfor(int j = 0; j <= 1; ++j) {\n\t\t\tfield[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nvector<vector<int>> bfs(const vector<pair<int, int>> &start) {\n\tvector<vector<int>> cost(h + 2, vector<int>(w + 2, INF));\n\tqueue<pair<int, int>> que;\n\tfor(const auto &p : start) {\n\t\tque.push(p);\n\t\tcost[p.Y][p.X] = 0;\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().X;\n\t\tconst int y = que.front().Y;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d], ny = y + dy[d];\n\t\t\tif(field[ny][nx] == '*') continue;\n\t\t\tif(cost[ny][nx] > cost[y][x] + 1) {\n\t\t\t\tque.push({nx, ny});\n\t\t\t\tcost[ny][nx] = cost[y][x] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\nint dijkstra(const vector<state> &start) {\n\tfill(dist[0][0], dist[0][0] + (MAX_SIZE + 2) * (MAX_SIZE + 2) * 4, INF);\n\tpriority_queue<state, vector<state>, greater<state>> que;\n\tfor(const auto &s : start) {\n\t\tque.push(s);\n\t\tdist[s.x][s.y][s.d] = s.dist;\n\t}\n\n\twhile(!que.empty()) {\n\t\tconst state s = que.top();\n\t\tque.pop();\n\n\t\tif(s.dist > dist[s.x][s.y][s.d]) continue;\n\t\tif(s.x == 1 && s.y == 1) return s.dist;\n\n\t\toverwrite(s.x, s.y, '*');\n\t\tconst auto cost = bfs({{s.x+ddx[s.d][0], s.y+ddy[s.d][0]}, {s.x+ddx[s.d][1], s.y+ddy[s.d][1]}});\n\t\toverwrite(s.x, s.y, 'o');\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = s.x + dx[d], ny = s.y + dy[d];\n\t\t\tconst int nx1 = s.x + ddx[d][0], nx2 = s.x + ddx[d][1];\n\t\t\tconst int ny1 = s.y + ddy[d][0], ny2 = s.y + ddy[d][1];\n\n\t\t\tif(field[ny1][nx1] == '*' || field[ny2][nx2] == '*') continue;\n\t\t\tint n_dist = s.dist + 2 * min(cost[ny1][nx1], cost[ny2][nx2]) + 1;\n\t\t\tif(s.d != d) n_dist += 2;\n\t\t\tif(dist[nx][ny][(d ^ 1)] > n_dist) {\n\t\t\t\tdist[nx][ny][(d ^ 1)] = n_dist;\n\t\t\t\tque.push({nx, ny, (d ^ 1), n_dist});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfield[0] = field[h + 1] = string(w + 2, '*');\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tcin >> field[i];\n\t\t\tfield[i] = '*' + field[i] + '*';\n\t\t}\n\n\t\tint sx = INF, sy = INF;\n\t\tvector<pair<int, int>> ps;\n\n\t\tfor(int y = 1; y <= h; ++y) {\n\t\t\tfor(int x = 1; x <= w; ++x) {\n\t\t\t\tif(field[y][x] == '.') {\n\t\t\t\t\tps.emplace_back(x, y);\n\t\t\t\t\tfield[y][x] = 'o';\n\t\t\t\t}\n\t\t\t\telse if(field[y][x] == 'X') {\n\t\t\t\t\tchmin(sx, x);\n\t\t\t\t\tchmin(sy, y);\n\t\t\t\t\tfield[y][x] = 'o';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(sx == 1 && sy == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst auto c1 = bfs({ps[0]});\n\t\tconst auto c2 = bfs({ps[1]});\n\n\t\tvector<state> start;\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tint init_cost = INF;\n\t\t\tfor(int i = 0; i <= 1; ++i) {\n\t\t\t\tchmin(init_cost, c1[sy+ddy[d][i]][sx+ddx[d][i]] + c2[sy+ddy[d][1-i]][sx+ddx[d][1-i]]);\n\t\t\t}\n\t\t\tif(init_cost == INF) continue;\n\t\t\tstart.emplace_back(sx, sy, d, init_cost);\n\t\t}\n\n\t\tcout << dijkstra(start) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n    auto val = table(args...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\n\nint main() {\n    int h, w;\n    while(cin >> h >> w, h) {\n        vector<string> v(h);\n        int sy = -1, sx = -1;\n        for(int i = 0; i < h; ++i) {\n            cin >> v[i];\n            for(int j = 0; j < w; ++j) {\n                if(v[i][j] == 'X' && sy == -1) {\n                    sy = i, sx = j;\n                }\n            }\n        }\n        if(sy == 0 && sx == 0) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        auto in_range = [&] (int y, int x) {\n                            return 0 <= y && y < h && 0 <= x && x < w;\n                        };\n        auto is_king = [&] (int y, int x, int ky, int kx) {\n            return    (y == ky && x == kx) || (y == ky + 1 && x == kx)\n                   || (y == ky && x == kx + 1) || (y == ky + 1 && x == kx + 1);\n        };\n        auto d = table(h, w, 4, inf);\n        auto calc_dist = [&] (int y1, int x1, int y2, int x2, int ky, int kx) {\n            queue<tuple<int, int, int, int>> que;\n            auto dist = table(h, w, h, w, inf);\n            vector<int> sy2 = {y1, y2}, sx2 = {x1, x2};\n            dist[sy2[0]][sx2[0]][sy2[1]][sx2[1]] = 0;\n            que.emplace(sy2[0], sx2[0], sy2[1], sx2[1]);\n            while(!que.empty()) {\n                vector<int> y(2), x(2); tie(y[0], x[0], y[1], x[1]) = que.front();\n                que.pop();\n                for(int i = 0; i < 2; ++i) {\n                    for(int j = 0; j < 4; ++j) {\n                        const int ny = y[i] + dy[j], nx = x[i] + dx[j];\n                        const int ny1 = (i == 0 ? ny : y[0]), nx1 = (i == 0 ? nx : x[0]);\n                        const int ny2 = (i == 1 ? ny : y[1]), nx2 = (i == 1 ? nx : x[1]);\n                        if(!in_range(ny, nx) || v[ny][nx] == '*' || is_king(ny, nx, ky, kx) || dist[ny1][nx1][ny2][nx2] != inf) continue;\n                        dist[ny1][nx1][ny2][nx2] = dist[y[0]][x[0]][y[1]][x[1]] + 1;\n                        que.emplace(ny1, nx1, ny2, nx2);\n                    }\n                }\n            }\n            return dist;\n        };\n\n        using S = tuple<int, int, int, int>;\n        priority_queue<S, vector<S>, greater<>> que;\n        { // calc initial\n            vector<int> sy2, sx2;\n            for(int i = 0; i < h; ++i) {\n                for(int j = 0; j < w; ++j) {\n                    if(v[i][j] == '.') sy2.push_back(i), sx2.push_back(j);\n                }\n            }\n            auto init = calc_dist(sy2[0], sx2[0], sy2[1], sx2[1], sy, sx);\n            if(sy + 2 < h) {\n                d[sy][sx][0] = min(init[sy + 2][sx][sy + 2][sx + 1], init[sy + 2][sx + 1][sy + 2][sx]);\n                if(d[sy][sx][0] != inf) que.emplace(d[sy][sx][0], sy, sx, 0);\n            }\n            if(sx + 2 < w) {\n                d[sy][sx][1] = min(init[sy][sx + 2][sy + 1][sx + 2], init[sy + 1][sx + 2][sy][sx + 2]);\n                if(d[sy][sx][1] != inf) que.emplace(d[sy][sx][1], sy, sx, 1);\n            }\n            if(sy - 1 >= 0) {\n                d[sy][sx][2] = min(init[sy - 1][sx][sy - 1][sx + 1], init[sy - 1][sx + 1][sy - 1][sx]);\n                if(d[sy][sx][2] != inf) que.emplace(d[sy][sx][2], sy, sx, 2);\n            }\n            if(sx - 1 >= 0) {\n                d[sy][sx][3] = min(init[sy][sx - 1][sy + 1][sx - 1], init[sy + 1][sx - 1][sy][sx - 1]);\n                if(d[sy][sx][3] != inf) que.emplace(d[sy][sx][3], sy, sx, 3);\n            }\n        }\n        while(!que.empty()) {\n            int cur_d, ky, kx, dir; tie(cur_d, ky, kx, dir) = que.top();\n            que.pop();\n            if(d[ky][kx][dir] < cur_d) continue;\n            { // move king\n                const int nky = ky + dy[dir], nkx = kx + dx[dir];\n                if(d[nky][nkx][(dir + 2) % 4] > cur_d + 1) {\n                    d[nky][nkx][(dir + 2) % 4] = cur_d + 1;\n                    que.emplace(cur_d + 1, nky, nkx, (dir + 2) % 4);\n                }\n            }\n            { // move empty cell\n                int sy1, sx1, sy2, sx2;\n                if(dir == 0) sy1 = ky + 2, sx1 = kx, sy2 = ky + 2, sx2 = kx + 1;\n                if(dir == 1) sy1 = ky, sx1 = kx + 2, sy2 = ky + 1, sx2 = kx + 2;\n                if(dir == 2) sy1 = ky - 1, sx1 = kx, sy2 = ky - 1, sx2 = kx + 1;\n                if(dir == 3) sy1 = ky, sx1 = kx - 1, sy2 = ky + 1, sx2 = kx - 1;\n                vector<queue<pii>> que2(2);\n                auto d2 = table(h, w, 2, inf);\n                que2[0].emplace(sy1, sx1), que2[1].emplace(sy2, sx2);\n                d2[sy1][sx1][0] = 0, d2[sy2][sx2][1] = 0;\n                for(int i = 0; i < 2; ++i) {\n                    while(!que2[i].empty()) {\n                        int y, x; tie(y, x) = que2[i].front();\n                        que2[i].pop();\n                        for(int j = 0; j < 4; ++j) {\n                            const int ny = y + dy[j], nx = x + dx[j];\n                            if(!in_range(ny, nx) || v[ny][nx] == '*' || is_king(ny, nx, ky, kx)) continue;\n                            if(d2[ny][nx][i] != inf) continue;\n                            d2[ny][nx][i] = d2[y][x][i] + 1;\n                            que2[i].emplace(ny, nx);\n                        }\n                    }\n                }\n                vector<vector<int>> gy(4), gx(4);\n                gy[2] = {ky - 1, ky - 1}, gx[2] = {kx, kx + 1};\n                gy[3] = {ky, ky + 1}, gx[3] = {kx - 1, kx - 1};\n                gy[0] = {ky + 2, ky + 2}, gx[0] = {kx, kx + 1};\n                gy[1] = {ky, ky + 1}, gx[1] = {kx + 2, kx + 2};\n                for(int ndir = 0; ndir < 4; ++ndir) {\n                    if(!in_range(gy[ndir][0], gx[ndir][0]) || !in_range(gy[ndir][1], gx[ndir][1])) continue;\n                    int cost = inf;\n                    for(int j = 0; j < 2; ++j) {\n                        cost = min(cost, d2[gy[ndir][0]][gx[ndir][0]][j] + d2[gy[ndir][1]][gx[ndir][1]][!j]);\n                    }\n                    if(cost == inf) continue;\n                    if(d[ky][kx][ndir] > cur_d + cost) {\n                        d[ky][kx][ndir] = cur_d + cost;\n                        que.emplace(cur_d + cost, ky, kx, ndir);\n                    }\n                }\n            }\n        }\n\n        const int ans = *min_element(begin(d[0][0]), end(d[0][0]));\n        if(ans == inf) {\n            cout << -1 << endl;\n        } else {\n            cout << ans << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nbool u[52][52][52][52];\nbool u2[50][50][2][50][50];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    auto inside=[H,W](int y,int x){\n      return 0<=y&&y<H&&0<=x&&x<W;\n    };\n    char g[52][52];\n    int sy[2],sx[2],sn=0;\n    int sky=-1,skx;\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='.'){\n\t  sy[sn]=i;\n\t  sx[sn]=j;\n\t  sn++;\n\t}\n\tif(sky<0&&g[i][j]=='X'){\n\t  sky=i;\n\t  skx=j;\n\t}\n      }\n    }\n    if(g[0][0]=='X'){\n      cout<<0<<endl;\n      continue;\n    }\n    fill(***begin(u),***end(u),false);\n    set<tuple<int,int,int,int,int> > que;\n    que.insert(make_tuple(0,sy[0],sx[0],sy[1],sx[1]));\n    //    priority_queue<tuple<int,int,int,int,int,int>,vector<tuple<int,int,int,int,int,int> >,greater<tuple<int,int,int,int,int,int> > > que2;\n    set<tuple<int,int,int,int,int,int> >que2;\n    while(!que.empty()){\n      static int dy[]={-1,0,1,0};\n      static int dx[]={0,1,0,-1};\n      auto c=*que.begin();\n      que.erase(que.begin());\n      int t,y1,x1,y2,x2;\n      tie(t,y1,x1,y2,x2)=c;\n      if(u[y1][x1][y2][x2]++)continue;\n      for(int i=0;i<4;i++){\n\tint ny1=y1+dy[i];\n\tint nx1=x1+dx[i];\n\tint ny2=y2+dy[i];\n\tint nx2=x2+dx[i];\n\tif(inside(ny1,nx1)&&inside(ny2,nx2)&&g[ny1][nx1]=='X'&&g[ny2][nx2]=='X'){\n\t  que2.insert(make_tuple(t,min(y1,y2),min(x1,x2),x1!=x2,sky,skx));\n\t}\n      }\n      for(int i=0;i<2;i++){\n\tfor(int j=0;j<4;j++){\n\t  int ny1=i?y1+dy[j]:y1;\n\t  int nx1=i?x1+dx[j]:x1;\n\t  int ny2=i?y2:y2+dy[j];\n\t  int nx2=i?x2:x2+dx[j];\n\t  if(!inside(ny1,nx1)||!inside(ny2,nx2)||ny1==ny2&&nx1==nx2||g[ny1][nx1]=='X'||g[ny1][nx1]=='*'||g[ny2][nx2]=='X'||g[ny2][nx2]=='*')continue;\n\t  que.insert(make_tuple(t+1,ny1,nx1,ny2,nx2));\n\t}\n      }\n    }\n    fill(****begin(u2),****end(u2),false);\n    while(!que2.empty()){\n      auto c=*que2.begin();\n      int t,y,x,d,ky,kx;\n      tie(t,y,x,d,ky,kx)=c;\n      if(ky==0&&kx==0)break;\n      que2.erase(que2.begin());\n      if(u2[y][x][d][ky][kx]++)continue;\n      //      cout<<ky<<' '<<kx<<endl;\n      for(int i=0;i<6;i++){\n\tstatic int ndy[2][6]={\n\t  {-1,2,0,1,0,1},\n\t  {0,0,1,1,-1,-1}\n\t};\n\tstatic int ndx[2][6]={\n\t  {0,0,-1,-1,1,1},\n\t  {-1,2,0,1,0,1}\n\t};\n\tint cy=y+ndy[d][i];\n\tint cx=x+ndx[d][i];\n\tif(inside(cy,cx)&&g[cy][cx]!='*'&&(cy<ky||ky+2<=cy||cx<kx||kx+2<=cx)){\n\t  static int hdy[2][6]={\n\t    {-1,1,0,1,0,1},\n\t    {0,0,0,0,-1,-1}\n\t  };\n\t  static int hdx[2][6]={\n\t    {0,0,-1,-1,0,0},\n\t    {-1,1,0,1,0,1}\n\t  };\n\t  que2.insert(make_tuple(t+2,y+hdy[d][i],x+hdx[d][i],d^(i>=2),ky,kx));\n\t}\n      }\n      if(y==ky&&d==0){\n\tif(kx-1==x){\n\t  que2.insert(make_tuple(t+1,y,x+2,d,ky,kx-1));\n\t}else if(kx+2==x){\n\t  que2.insert(make_tuple(t+1,y,x-2,d,ky,kx+1));\n\t}\n      }else if(x==kx&&d==1){\n\tif(ky-1==y){\n\t  que2.insert(make_tuple(t+1,y+2,x,d,ky-1,kx));\n\t}else if(ky+2==y){\n\t  que2.insert(make_tuple(t+1,y-2,x,d,ky+1,kx));\n\t}\n      }\n    }\n    cout<<(que2.empty()?-1:get<0>(*que2.begin()))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) cin >> F[i];\n        return true;\n    }\n\n    const int INF = 1<<28;\n    const int MAX_H = 51;\n    const int MAX_W = 51;\n\n    const int dy[4] = {0, -1, 0, 1};\n    const int dx[4] = {-1, 0, 1, 0};\n\n    struct S {\n        int y, x;\n        int cost;\n        S(int y, int x, int cost) : y(y), x(x), cost(cost) {}\n    };\n    int dist(int ky, int kx, int sy, int sx, int gy, int gx) {\n        vector< vector<bool> > used(H, vector<bool>(W, false));\n        queue<S> Q;\n        Q.push(S(sy, sx, 0));\n        used[sy][sx] = true;\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            if (c.y == gy && c.x == gx) return c.cost;\n            for (int i = 0; i < 4; i++) {\n                int ny = c.y + dy[i];\n                int nx = c.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '*') continue;\n                if (ky <= ny && ny <= ky + 1 && kx <= nx && nx <= kx + 1) continue;\n                if (used[ny][nx]) continue;\n                used[ny][nx] = true;\n                Q.push(S(ny, nx, c.cost + 1));\n            }\n        }\n        return INF;\n    }\n\n    struct T {\n        int y, x;\n        int k; // which direction the king came?\n        int cost;\n        T(int y, int x, int k, int cost) : y(y), x(x), k(k), cost(cost) {}\n    };\n    bool operator<(const T& a, const T& b) {\n        return a.cost > b.cost;\n    }\n    ostream& operator<<(ostream& os, const T& t) {\n        return os << \"T((\" << t.y << \",\" << t.x << \"), \" << t.k << \", \" << t.cost << \")\";\n    }\n\n    bool check(int y, int x) {\n        // can the king move into (y, x)?\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                int ny = y + i;\n                int nx = x + i;\n                if (ny < 0 || ny >= H) return false;\n                if (nx < 0 || nx >= W) return false;\n                if (F[ny][nx] == '*') return false;\n            }\n        }\n        return true;\n    }\n\n    T move(int k, int y, int x, int past_cost, int sy0, int sx0, int sy1, int sx1) {\n        int kny = y + dy[k];\n        int knx = x + dx[k];\n        if (!check(kny, knx)) throw -1;\n        int ny, nx, my, mx;\n        switch (k) {\n            case 0: ny = y; nx = x - 1; my = y + 1; mx = x - 1; break;\n            case 1: ny = y - 1; nx = x; my = y - 1; mx = x + 1; break;\n            case 2: ny = y; nx = x + 2; my = y + 1; mx = x + 2; break;\n            case 3: ny = y + 2; nx = x; my = y + 2; mx = x + 1; break;\n            default: break;\n        }\n        int cost = min(\n                     dist(y, x, ny, nx, sy0, sx0) + dist(y, x, my, mx, sy1, sx1),\n                     dist(y, x, ny, nx, sy1, sx1) + dist(y, x, my, mx, sy0, sx0)\n                   );\n        return T(kny, knx, (k + 2) % 4, past_cost + cost + 1);\n    }\n\n    void solve() {\n        int sy0, sx0, sy1, sx1;\n        int ky, kx;\n        int c = 0;\n        bool found_king = false;\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n            if (F[i][j] == 'X' && !found_king) {\n                ky = i;\n                kx = j;\n                found_king = true;\n            }\n            if (F[i][j] == '.') {\n                (c == 0 ? sy0 : sy1) = i;\n                (c == 0 ? sx0 : sx1) = j;\n                c++;\n            }\n        }\n        assert(c == 2);\n\n        int D[MAX_H][MAX_W][5];\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) for (int k = 0; k < 5; k++) D[i][j][k] = INF;\n        D[ky][kx][4] = 0;\n        priority_queue<T> PQ;\n        for (int i = 0; i < 4; i++) {\n            try {\n                T t = move(i, ky, kx, 0, sy0, sx0, sy1, sx1);\n                PQ.push(t);\n                D[t.y][t.x][t.k] = t.cost;\n            } catch (int e) {}\n        }\n        while (!PQ.empty()) {\n            T c = PQ.top(); PQ.pop();\n            for (int i = 0; i < 4; i++) {\n                int ny, nx, my, mx;\n                switch (c.k) {\n                    case 0: ny = c.y; nx = c.x - 1; my = c.y + 1; mx = c.x - 1; break;\n                    case 1: ny = c.y - 1; nx = c.x; my = c.y - 1; mx = c.x + 1; break;\n                    case 2: ny = c.y; nx = c.x + 2; my = c.y + 1; mx = c.x + 2; break;\n                    case 3: ny = c.y + 2; nx = c.x; my = c.y + 2; mx = c.x + 1; break;\n                    default: break;\n                }\n                try {\n                    T t = move(i, c.y, c.x, c.cost, ny, nx, my, mx);\n                    if (D[t.y][t.x][t.k] > t.cost) {\n                        PQ.push(t);\n                        D[t.y][t.x][t.k] = t.cost;\n                    }\n                } catch (int e) {}\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < 5; i++) {\n            ans = min(ans, D[0][0][i]);\n        }\n        if (ans == INF) ans = -1;\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar ba[50][50];\n\nstruct P2 {\n  int y1, x1;\n  int y2, x2;\n  P2(int y1, int x1, int y2, int x2) :\n    y1(y1),x1(x1),y2(y2),x2(x2) {}\n};\nshort dist2[50][50][50][50];\n\nstruct P {\n  int ky, kx;\n  int py, px;\n  int d;\n  int dist;\n  P(int ky, int kx, int py, int px, int d, int dist) :\n    ky(ky),kx(kx),py(py),px(px),d(d),dist(dist) {}\n  bool operator<(const P &p) const {\n    return dist > p.dist;\n  }\n};\nint dist[50][50][50][50][2];\n\nshort &get(const P2 &p) {\n  return dist2[p.y1][p.x1][p.y2][p.x2];\n}\n\nint &get(const P &p) {\n  return dist[p.ky][p.kx][p.py][p.px][p.d];\n}\n\nconst int dy[4] = {0,1,0,-1};\nconst int dx[4] = {1,0,-1,0};\n\nconst int dy2[2][4] = {{0,0,-1,-1},\n                       {0,0,1,1}};\nconst int dx2[2][4] = {{0,1,0,1},\n                       {-1,0,-1,0}};\n\nconst int kdy[4] = {0,0,1,1};\nconst int kdx[4] = {0,1,0,1};\n\nconst int dy3[4] = {0,0,0,1};\nconst int dx3[4] = {0,0,1,0};\n\nint h,w;\n\nbool collideKing(int y, int x, int d, int ky, int kx) {\n  int y2 = y+dy[d];\n  int x2 = x+dx[d];\n  if (!valid(y,x,h,w) || !valid(y2,x2,h,w)) return 1;\n  if (ba[y][x] == '*' || ba[y2][x2] == '*') return 1;\n  REP(i,4) {\n    int kyy = ky+kdy[i];\n    int kxx = kx+kdx[i];\n    if (y==kyy&&x==kxx || y2==kyy&&x2==kxx) return 1;\n  }\n  return 0;\n}\n\nbool okKing(int y, int x) {\n  REP(i,4) {\n    int yy = y+kdy[i];\n    int xx = x+kdx[i];\n    if (!valid(yy,xx,h,w)) return 0;\n    if (ba[yy][xx] == '*') return 0;\n  }\n  return 1;\n}\n\nint countCollide(int y, int x, int d, int ky, int kx) {\n  int y2 = y+dy[d];\n  int x2 = x+dx[d];\n  if (!valid(y,x,h,w) || !valid(y2,x2,h,w)) return 0;\n  int cnt = 0;\n  REP(i,4) {\n    int kyy = ky+kdy[i];\n    int kxx = kx+kdx[i];\n    if (y==kyy&&x==kxx || y2==kyy&&x2==kxx) cnt++;\n  }\n  return cnt;\n}\n\n\nint main() {\n  while(cin>>h>>w,h||w) {\n    REP(i,h)REP(j,w)cin>>ba[i][j];\n    int ky=-1, kx;\n    vector<pii> ps;\n    REP(i,h)REP(j,w) {\n      if (ky==-1 && ba[i][j]=='X') {\n        ky = i, kx = j;\n      }\n      if (ba[i][j] == '.') {\n        ps.push_back(pii(i,j));\n      }\n    }\n    assert(ps.size() == 2 && ky != -1);\n\n    if (ky==0 && kx==0) {\n      cout << 0 << endl;\n      continue;\n    }\n    \n    memset(dist, 0x3f, sizeof(dist));\n    priority_queue<P> PQ;\n    \n    queue<P2> Q;\n    memset(dist2,-1,sizeof(dist2));\n    P2 tmp(ps[0].first,ps[0].second,ps[1].first,ps[1].second);\n    Q.push(tmp);\n    get(tmp) = 0;\n    \n    while(!Q.empty()) {\n      P2 p = Q.front(); Q.pop();\n      \n      int cost = get(p);\n      // cout << p.y1 << \" \" << p.x1 << \" , \" << p.y2 << \" \" << p.x2 << endl;\n      if (abs(p.y1-p.y2)+abs(p.x1-p.x2) == 1) {\n        int d = 0;\n        if (p.x1==p.x2) d = 1;\n        P pq(ky,kx,min(p.y1,p.y2),min(p.x1,p.x2),d,cost);\n        if (get(pq) > cost) {\n          PQ.push(pq);\n          get(pq) = cost;\n        }\n      }\n      REP(i,4) {\n        int y = p.y1 + dy[i];\n        int x = p.x1 + dx[i];\n        if (!valid(y,x,h,w) || ba[y][x]=='*' || ba[y][x]=='X') continue;\n        P2 nxt(y,x,p.y2,p.x2);\n        if (get(nxt) == -1) {\n          get(nxt) = cost+1;\n          Q.push(nxt);\n        }\n      }\n      REP(i,4) {\n        int y = p.y2 + dy[i];\n        int x = p.x2 + dx[i];\n        if (!valid(y,x,h,w) || ba[y][x]=='*' || ba[y][x]=='X') continue;\n        P2 nxt(p.y1,p.x1,y,x);\n        if (get(nxt) == -1) {\n          get(nxt) = cost+1;\n          Q.push(nxt);\n        }        \n      }\n    }\n\n    int ans = -1;\n    \n    while(!PQ.empty()) {\n      P p = PQ.top(); PQ.pop();\n\n      if (p.dist > get(p)) continue;\n\n      if (p.ky==0 && p.kx==0) {\n        ans = p.dist;\n        break;\n      }\n\n      // cout << p.ky << \" \" << p.kx << \" \" << p.py << \" \" << p.px << \" \" << p.d << \" \" << p.dist << endl;\n      // pawn\n      // slide\n      REP(i,4) {\n        int y = p.py + dy[i];\n        int x = p.px + dx[i];\n        if (!valid(y,x,h,w) || collideKing(y,x,p.d,p.ky,p.kx) || ba[y][x]=='*') continue;\n        P nxt(p.ky,p.kx,y,x,p.d,p.dist+2);\n        if (get(nxt) > p.dist + 2) {\n          get(nxt) = p.dist + 2;\n          PQ.push(nxt);\n        }\n      }\n      // rotate\n      REP(i,4) {\n        int y = p.py+dy2[p.d][i];\n        int x = p.px+dx2[p.d][i];\n        if (!valid(y,x,h,w) || collideKing(y,x,!p.d,p.ky,p.kx) || ba[y][x]=='*') continue;\n        P nxt(p.ky,p.kx,y,x,!p.d,p.dist+2);\n        if (get(nxt) > p.dist + 2) {\n          get(nxt) = p.dist + 2;\n          PQ.push(nxt);\n        }\n      }   \n      // king\n      REP(i,4) {\n        int y = p.ky + dy[i];\n        int x = p.kx + dx[i];\n        if (countCollide(p.py,p.px,p.d,y,x)!=2) continue;\n        P nxt(y,x,\n              p.ky+dy3[i],p.kx+dx3[i],\n              p.d,p.dist+1);\n\n        if (get(nxt) > p.dist+1) {\n          get(nxt) = p.dist + 1;\n          PQ.push(nxt);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<iostream>\nusing namespace std;\nconst int maxn=60;\nint n,m;\nchar mp[maxn][maxn];\nconst int cx[]={-1,-1,0,1,2,2,0,1};\nconst int cy[]={0,1,2,2,0,1,-1,-1};\nstruct ty\n{\n    int x,y,d,c;\n    ty(int x=0,int y=0,int d=0,int c=0):x(x),y(y),d(d),c(c){}\n    inline bool in_range()\n    {\n        return x>=0&&x<n&&y>=0&&y<m;\n    }\n    ty p1()\n    {\n        return ty(x+cx[d<<1],y+cy[d<<1],0,0);\n    }\n    ty p2()\n    {\n        return ty(x+cx[(d<<1)^1],y+cy[(d<<1)^1],0,0);\n    }\n    void putit()\n    {\n        printf(\"state:%d %d %d %d\\n\",x,y,d,c);\n    }\n}st,p1,p2;\nconst int dx[]={0,0,-1,1};\nconst int dy[]={1,-1,0,0};\nint p2p(ty st,ty en,ty king)\n{\n    if (!st.in_range()) return 10010;\n    if (!en.in_range()) return 10010;\n    queue<ty> qq;\n    bool vis[maxn][maxn];\n    memset(vis,0,sizeof(vis));\n    qq.push(st);\n    st.c=0;\n    vis[st.x][st.y]=1;\n    while (!qq.empty())\n    {\n        ty now=qq.front();\n        qq.pop();\n        if (now.x==en.x&&now.y==en.y) return now.c;\n        for (int i=0;i<4;i++)\n        {\n            ty exp(now.x+dx[i],now.y+dy[i],0,now.c+1);\n            if (exp.in_range()&&mp[exp.x][exp.y]!='*'&&(exp.x<king.x||exp.x>king.x+1||exp.y<king.y||exp.y>king.y+1)&&!vis[exp.x][exp.y])\n            {\n                vis[exp.x][exp.y]=1;\n                if (exp.x==en.x&&exp.y==en.y) return exp.c;\n                qq.push(exp);\n            }\n        }\n    }\n    return 10010;\n}\nqueue<ty> q;\nint cost[maxn][maxn][4];\nvoid BFS()\n{\n    memset(cost,-1,sizeof(cost));\n    if (st.x==0&&st.y==0)\n    {\n        cost[0][0][0]=0;\n        return;\n    }\n    for (int i=0;i<4;i++)\n    {\n        st.d=i;\n        int c1=p2p(p1,st.p1(),st);\n        int c2=p2p(p2,st.p2(),st);\n        int c3=p2p(p2,st.p1(),st);\n        int c4=p2p(p1,st.p2(),st);\n        st.c=min(c1+c2,c3+c4);\n        if (st.c<10010)\n        {\n            q.push(st);\n            cost[st.x][st.y][st.d]=st.c;\n        }\n    }\n    while (!q.empty())\n    {\n        ty now=q.front();\n        q.pop();\n        if (now.c!=cost[now.x][now.y][now.d]) continue;\n        for (int i=0;i<4;i++)\n        {\n            ty exp=now;\n            exp.d=i;\n            int c1=p2p(now.p1(),exp.p1(),now);\n            int c2=p2p(now.p2(),exp.p2(),now);\n            int c3=p2p(now.p1(),exp.p2(),now);\n            int c4=p2p(now.p2(),exp.p1(),now);\n            exp.c=now.c+min(c1+c2,c3+c4);\n            int &c=cost[exp.x][exp.y][exp.d];\n            if (exp.c<10010&&(c==-1||exp.c<c))\n            {\n                c=exp.c;\n                q.push(exp);\n            }\n        }\n        ty exp;\n        switch (now.d)\n        {\n            case 0:exp=ty(now.x-1,now.y,2,now.c+1);break;\n            case 1:exp=ty(now.x,now.y+1,3,now.c+1);break;\n            case 2:exp=ty(now.x+1,now.y,0,now.c+1);break;\n            case 3:exp=ty(now.x,now.y-1,1,now.c+1);break;\n        }\n        if (exp.in_range())\n        {\n            int &c=cost[exp.x][exp.y][exp.d];\n            if (c==-1||exp.c<c)\n            {\n                c=exp.c;\n                q.push(exp);\n            }\n        }\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\",&n,&m)&&(n||m))\n    {\n        for (int i=0;i<n;i++) scanf(\"%s\",mp[i]);\n        st.x=p1.x=-1;\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                if (mp[i][j]=='X'&&st.x==-1)\n                {\n                    st.x=i;\n                    st.y=j;\n                    st.c=0;\n                }\n                else if (mp[i][j]=='.')\n                {\n                    if (p1.x==-1) p1.x=i,p1.y=j;\n                    else p2.x=i,p2.y=j;\n                }\n        BFS();\n        int ans=-1;\n        for (int i=0;i<4;i++)\n            if (ans==-1||(cost[0][0][i]!=-1&&cost[0][0][i]<ans))\n                ans=cost[0][0][i];\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<iomanip>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<climits>\n#define inf (1<<29)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define MAX 251\nusing namespace std;\nint h,w;\nstring G[MAX];\nint mincost[MAX][MAX][MAX];//mincost[open1][open2][king] := the minimum cost\nint dx[] = {0,1,0,-1};//下、右、上、左\nint dy[] = {1,0,-1,0};\nint kdx[] = {0,1,0,1};\nint kdy[] = {0,0,1,1};\nint sdx[] = {};\nint sdy[] = {};\n\nstruct Point\n{\n  int x,y;\n  Point(int x=-1,int y=-1):x(x),y(y){}\n  bool operator < (const Point &a)const\n  {\n    if(x != a.x)return x < a.x;\n    return y < a.y;\n  }\n};\n\nstruct State\n{\n  Point king;\n  Point op[2];\n  int cost;\n  State(Point king,Point op1,Point op2,int cost = -1):king(king),cost(cost){ op[0] = op1,op[1] = op2; }\n  bool operator < (const State &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint toIndex(Point p){ return p.x+p.y*w; }\n\nvoid trace(Point p1,Point p2,Point p3)\n{\n  rep(i,h)\n    {\n      rep(j,w)\n\t{\n\t  if(G[i][j] == '*')\n\t    {\n\t      cout << G[i][j];\n\t      continue;\n\t    }\n\t  if(p1.x == j && p1.y == i)\n\t    {\n\t      cout << '.';\n\t      continue;\n\t    }\n\t  if(p2.x == j && p2.y == i)\n\t    {\n\t      cout << '.'; \n\t      continue;\n\t    }\n\n\t  bool check_king = true;\n\t  rep(k,4)\n\t    {\n\t      int nx = p3.x + kdx[k];\n\t      int ny = p3.y + kdy[k];\n\t      if(nx == j && ny == i)\n\t\t{\n\t\t  cout << 'X';\n\t\t  check_king = false;\n\t\t  continue;\n\t\t}\n\t    }\n\t  if(!check_king)continue;\n\t  cout << 'o';\n\t}\n      cout << endl;\n    }\n  cout << endl << endl;\n}\n\nbool slide_check(int dir,Point &p1,Point &p2,Point king)\n{\n  map<Point,bool> exist;\n  exist[p1] = true;\n  exist[p2] = true;\n  rep(i,4)\n    {\n      int nx = king.x + kdx[i];\n      int ny = king.y + kdy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))return false;\n      if(G[ny][nx] == '*')return false;\n    }\n  //下、右、上、左\n  Point pp1,pp2;\n  if(dir == 0)\n    {\n      // 0,  1, 2,   3\n      //今、右、下、斜め\n      pp1 = Point(king.x+kdx[2],king.y+kdy[2]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x,king.y-1);\n      p2 = Point(king.x+1,king.y-1);\n    }\n  if(dir == 1)\n    {\n      pp1 = Point(king.x+kdx[1],king.y+kdy[1]);\n      pp2 = Point(king.x+kdx[3],king.y+kdy[3]);\n      p1 = Point(king.x-1,king.y);\n      p2 = Point(king.x-1,king.y+1);\n    }\n  if(dir == 2)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[1],king.y+kdy[1]);\n      p1 = Point(king.x,king.y+2);\n      p2 = Point(king.x+1,king.y+2);\n    }\n  if(dir == 3)\n    {\n      pp1 = Point(king.x+kdx[0],king.y+kdy[0]);\n      pp2 = Point(king.x+kdx[2],king.y+kdy[2]);\n      p1 = Point(king.x+2,king.y);\n      p2 = Point(king.x+2,king.y+1);\n    }\n  if(!(exist[pp1] && exist[pp2]))return false;\n\n  return true;\n}\n\nvoid dijkstra(Point st,Point op1,Point op2)\n{\n  priority_queue<State> Q;\n  Q.push(State(st,op1,op2,0));\n  rep(i,MAX)rep(j,MAX)rep(k,MAX)mincost[i][j][k] = inf;\n  mincost[toIndex(op1)][toIndex(op2)][toIndex(st)] = 0;\n  mincost[toIndex(op2)][toIndex(op1)][toIndex(st)] = 0;\n\n  while(!Q.empty())\n    {\n      State state = Q.top(); Q.pop();\n      //cout << \"the cost = \" << state.cost << endl;\n      //trace(state.op[0],state.op[1],state.king);\n      if(toIndex(state.king) == 0)\n\t{\n\t  cout << state.cost << endl;\n\t  return;\n\t}\n\n\n      Point king = state.king;\n      rep(i,2)//move the open square\n\t{\n\t  Point p = state.op[i];\n\t  rep(j,4)\n\t    {\n\t      int nx = p.x + dx[j];\n\t      int ny = p.y + dy[j];\t      \n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(G[ny][nx] == '*')continue;\n\n\t      bool check_king = true;\n\t      rep(k,4)\n\t\t{//the place (ny,ny) is on the king\n\t\t  int kx = king.x + kdx[k];\n\t\t  int ky = king.y + kdy[k];\n\t\t  assert(0 <= kx && kx < w && 0 <= ky && ky < h);\n\t\t  if(kx == nx && ky == ny)\n\t\t    {\n\t\t      check_king = false;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if(!check_king)continue;\n\t      if(nx == state.op[(i+1)%2].x && ny == state.op[(i+1)%2].y)continue;//the new place is on the other open squeare\n\n\t      Point pp[2];\n\t      pp[0] = (i == 0 ? Point(nx,ny): state.op[0]);\t      \n\t      pp[1] = (i == 0 ? state.op[1] : Point(nx,ny));\n\n\t      int index1 = toIndex(pp[0]);\n\t      int index2 = toIndex(pp[1]);\n\t      int index3 = toIndex(state.king);\n\t      if(mincost[index1][index2][index3] > state.cost + 1)\n\t\t{\n\t\t  mincost[index1][index2][index3] = state.cost + 1;\n\t\t  mincost[index2][index1][index3] = state.cost + 1; \n\t\t  Q.push(State(state.king,pp[0],pp[1],state.cost+1));\n\t\t}\n\t    }\n\t}\n\n      rep(i,4)//move the king\n\t{\n\t  int nx = state.king.x + dx[i];\n\t  int ny = state.king.y + dy[i];\n\t  Point sop1 = state.op[0];\n\t  Point sop2 = state.op[1];\n\t  if(!slide_check(i,sop1,sop2,Point(nx,ny)))continue;\n\n\t  int index1 = toIndex(sop1);\n\t  int index2 = toIndex(sop2);\n\t  int index3 = toIndex(Point(nx,ny));\n\t  if(mincost[index1][index2][index3] > state.cost + 1)\n\t    {\n\t      mincost[index1][index2][index3] = state.cost + 1;\n\t      mincost[index2][index1][index3] = state.cost + 1;\n\t      Q.push(State(Point(nx,ny),sop1,sop2,state.cost+1));\n\t    }\n\t}\n    }  \n  cout << -1 << endl;\n}\n\nint main()\n{\n  clock_t stc,edc;\n  stc = clock();\n  while(cin >> h >> w,h|w)\n    {\n      Point st;\n      vector<Point> op;\n      rep(i,h)\n\t{\n\t  cin >> G[i];\n\t  rep(j,w)\n\t    {\n\t      if((st.x == -1 && st.y == -1) && G[i][j] == 'X')\n\t\t{\n\t\t  st.x = j,st.y = i;\n\t\t}\n\t      if(G[i][j] == '.')op.push_back(Point(j,i));\n\t    }\n\t}\n      assert(op.size() == 2);\n      dijkstra(st,op[0],op[1]);\n    }\n  edc = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(edc-stc)/CLOCKS_PER_SEC << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 50;\n\nconst int dx[] = {1,0,0,-1};\nconst int dy[] = {0,1,-1,0};\n\nstruct tri\n{\n    int x,y,z;\n    tri(){}\n    tri(int x_, int y_, int z_) : x(x_), y(y_), z(z_){}\n};\n\nint h,w;\nstring s[MAX_N];\nint dist[MAX_N][MAX_N];\nint cs[MAX_N][MAX_N][4];\nint memo[MAX_N][MAX_N][5][4];\n\nint move(int a, int b, int c, int d)\n{\n    rep(i,h){\n        rep(j,w){\n            dist[i][j] = INF;\n        }\n    }\n    queue<P> que;\n    dist[a][b] = 0;\n    que.push(P(a,b));\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nx = p.fi + dx[i], ny = p.se + dy[i];\n            if(nx >= 0 && nx < h && ny >= 0 && ny < w && s[nx][ny] != '*' && dist[nx][ny] > dist[p.fi][p.se] + 1){\n                dist[nx][ny] = dist[p.fi][p.se] + 1;\n                if(nx == c && ny == d) return dist[c][d];\n                que.push(P(nx,ny));\n            }\n        }\n    }\n    return dist[c][d];\n}\n\nint calc(int a1, int b1, int a2, int b2, int c1, int d1, int c2, int d2)\n{\n    int res = INF;\n    int res1, res2;\n    \n    s[a2][b2] = '*';\n    res1 = move(a1,b1,c1,d1);\n    s[c1][d1] = '*';\n    res2 = move(a2,b2,c2,d2);\n    s[a2][b2] = s[c1][d1] = 'o';\n    cmn(res,res1+res2);\n    \n    s[a2][b2] = '*';\n    res1 = move(a1,b1,c2,d2);\n    s[c2][d2] = '*';\n    res2 = move(a2,b2,c1,d1);\n    s[a2][b2] = s[c2][d2] = 'o';\n    cmn(res,res1+res2);\n    \n    s[a1][b1] = '*';\n    res1 = move(a2,b2,c1,d1);\n    s[c1][d1] = '*';\n    res2 = move(a1,b1,c2,d2);\n    s[a1][b1] = s[c1][d1] = 'o';\n    cmn(res,res1+res2);\n    \n    s[a1][b1] = '*';\n    res1 = move(a2,b2,c2,d2);\n    s[c2][d2] = '*';\n    res2 = move(a1,b1,c1,d1);\n    s[a1][b1] = s[c2][d2] = 'o';\n    cmn(res,res1+res2);\n    \n    return res;\n}\n\n// king が (px,py) にあって (x1,y1), (x2,y2) に空きがある\nvoid solve(int px, int py, int pz, int x1, int y1, int x2, int y2, int cost, queue<tri>& que)\n{\n    rep(i,2){\n        rep(j,2){\n            s[px+i][py+j] = '*';\n        }\n    }\n    // cout << px << \" \" << py << \"\\n\";\n    // print();\n    int nx = px + dx[0], ny = py + dy[0];\n    if(nx < h-1 && s[nx+1][ny] != '*' && s[nx+1][ny+1] != '*'){\n        int d;\n        if(memo[px][py][pz][0] >= 0){\n            d = memo[px][py][pz][0];\n        }else{\n            memo[px][py][pz][0] = d = calc(x1,y1,x2,y2,nx+1,ny,nx+1,ny+1);\n        }\n        if(cs[nx][ny][0] > cost + d + 1){\n            cs[nx][ny][0] = cost + d + 1;\n            que.push(tri(nx,ny,0));\n        }\n    }\n    nx = px + dx[1], ny = py + dy[1];\n    if(ny < w-1 && s[nx][ny+1] != '*' && s[nx+1][ny+1] != '*'){\n        int d;\n        if(memo[px][py][pz][1] >= 0){\n            d = memo[px][py][pz][1];\n        }else{\n            memo[px][py][pz][1] = d = calc(x1,y1,x2,y2,nx,ny+1,nx+1,ny+1);\n        }\n        if(cs[nx][ny][1] > cost + d + 1){\n            cs[nx][ny][1] = cost + d + 1;\n            que.push(tri(nx,ny,1));\n        }\n    }\n    nx = px + dx[2], ny = py + dy[2];\n    if(ny >= 0 && s[nx][ny] != '*' && s[nx+1][ny] != '*'){\n        int d;\n        if(memo[px][py][pz][2] >= 0){\n            d = memo[px][py][pz][2];\n        }else{\n            memo[px][py][pz][2] = d = calc(x1,y1,x2,y2,nx,ny,nx+1,ny);\n        }\n        if(cs[nx][ny][2] > cost + d + 1){\n            cs[nx][ny][2] = cost + d + 1;\n            que.push(tri(nx,ny,2));\n        }\n    }\n    nx = px + dx[3], ny = py + dy[3];\n    if(nx >= 0 && s[nx][ny] != '*' && s[nx][ny+1] != '*'){\n        int d;\n        if(memo[px][py][pz][3] >= 0){\n            d = memo[px][py][pz][3];\n        }else{\n            memo[px][py][pz][3] = d = calc(x1,y1,x2,y2,nx,ny,nx,ny+1);\n        }\n        if(cs[nx][ny][3] > cost + d + 1){\n            cs[nx][ny][3] = cost + d + 1;\n            que.push(tri(nx,ny,3));\n        }\n    }\n    \n    rep(i,2){\n        rep(j,2){\n            s[px+i][py+j] = 'o';\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        cin >> h >> w;\n        if(h == 0) break;\n        bool flag = false;\n        int sth, stw;\n        int a = -1,b,c,d;\n        rep(i,h){\n            cin >> s[i];\n            rep(j,w){\n                if(s[i][j] == 'X'){\n                    if(!flag){\n                        sth = i, stw = j;\n                        flag = true;\n                    }\n                    s[i][j] = 'o';\n                }else if(s[i][j] == '.'){\n                    if(a < 0){\n                        a = i, b = j;\n                    }else{\n                        c = i, d = j;\n                    }\n                    s[i][j] = 'o';\n                }\n                rep(k,4){\n                    cs[i][j][k] = INF;\n                }\n                rep(k,5){\n                    rep(l,4){\n                        memo[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        if(sth == 0 && stw == 0){\n            cout << \"0\\n\";\n            continue;\n        }\n        queue<tri> que;\n        solve(sth,stw,4,a,b,c,d,0,que);\n        while(!que.empty()){\n            tri p = que.front();\n            que.pop();\n            int a,b,c,d;\n            if(p.z == 0){\n                a = p.x-1, b = p.y, c = p.x-1, d = p.y+1;\n            }else if(p.z == 1){\n                a = p.x, b = p.y-1, c = p.x+1, d = p.y-1;\n            }else if(p.z == 2){\n                a = p.x, b = p.y+2, c = p.x+1, d = p.y+2;\n            }else{\n                a = p.x+2, b = p.y, c = p.x+2, d = p.y+1;\n            }\n            solve(p.x,p.y,p.z,a,b,c,d,cs[p.x][p.y][p.z],que);\n        }\n        int res = INF;\n        rep(i,4){\n            cmn(res,cs[0][0][i]);\n        }\n        if(res == INF){\n            cout << \"-1\\n\";\n        }else{\n            cout << res << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntuple<pii,pii,pii> decode(ll x){\n\treturn make_tuple(mp(x&255,x>>8&255),mp(x>>16&255,x>>24&255),mp(x>>32&255,x>>40&255));\n}\nll encode(tuple<pii,pii,pii> x){\n\treturn\n\tget<0>(x).first|get<0>(x).second<<8|\n\tget<1>(x).first<<16|get<1>(x).second<<24|\n\t(ll)get<2>(x).first<<32|(ll)get<2>(x).second<<40;\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w && h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tqueue<tuple<pii,pii,pii,int>> q;\n\t\tset<ll> vis;\n\t\t{\n\t\t\tpii king(-1,-1);\n\t\t\tvector<pii> opens;\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(grid[i][j]=='X' && king==mp(-1,-1)) king=mp(i,j);\n\t\t\t\tif(grid[i][j]=='.') opens.emplace_back(i,j);\n\t\t\t}\n\t\t\tq.emplace(king,opens[0],opens[1],0);\n\t\t\tvis.insert(encode(make_tuple(king,opens[0],opens[1])));\n\t\t}\n\t\t\n\t\tint res=-1;\n\t\twhile(q.size()){\n\t\t\tpii ck,co1,co2; int step;\n\t\t\ttie(ck,co1,co2,step)=q.front(); q.pop();\n\t\t\tif(ck==mp(0,0)){\n\t\t\t\tres=step;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni,nj;\n\t\t\t\tni=co1.first+\"\\xff\\x1\\0\\0\"[k],nj=co1.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co2\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=mp(ni,nj),no2=co2; if(no1>no2) swap(no1,no2);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(ck,no1,no2))).second)\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tni=co2.first+\"\\xff\\x1\\0\\0\"[k],nj=co2.second+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='*' && mp(ni,nj)!=co1\n\t\t\t\t&& (ni<ck.first || ck.first+2<=ni ||nj<ck.second || ck.second+2<=nj)){\n\t\t\t\t\tpii no1=co1,no2=mp(ni,nj); if(no1>no2) swap(no1,no2);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(ck,no1,no2))).second)\n\t\t\t\t\tq.emplace(ck,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.first==co2.first && co1.second+1==co2.second){\n\t\t\t\tif(ck.first==co1.first+1 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first-1,ck.second),no1(co1.first+2,co1.second),no2(co2.first+2,co2.second);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(nk,no1,no2))).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.first==co1.first-2 && ck.second==co1.second){\n\t\t\t\t\tpii nk(ck.first+1,ck.second),no1(co1.first-2,co1.second),no2(co2.first-2,co2.second);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(nk,no1,no2))).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(co1.second==co2.second && co1.first+1==co2.first){\n\t\t\t\tif(ck.second==co1.second+1 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second-1),no1(co1.first,co1.second+2),no2(co2.first,co2.second+2);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(nk,no1,no2))).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t\tif(ck.second==co1.second-2 && ck.first==co1.first){\n\t\t\t\t\tpii nk(ck.first,ck.second+1),no1(co1.first,co1.second-2),no2(co2.first,co2.second-2);\n\t\t\t\t\tif(vis.insert(encode(make_tuple(nk,no1,no2))).second)\n\t\t\t\t\tq.emplace(nk,no1,no2,step+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom heapq import heappush, heappop, heapify\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\nZ = [-1]*(50*50)\n\ndef calc(H, W, G, x0, y0, bx, by, S):\n    S[:] = Z[:H*W]\n    k = y0*W + x0\n    que = deque([k])\n    S[k] = 0\n    for i in [0, 1]:\n        for j in [0, 1]:\n            S[(by+i)*W + (bx+j)] = -2\n    while que:\n        v = que.popleft()\n        cost = S[v]\n        for w in G[v]:\n            if S[w] == -1:\n                S[w] = cost+1\n                que.append(w)\n    return S\n\ndef solve():\n    H, W = map(int, readline().split())\n    if H == W == 0:\n        return False\n    M = [[0]*W for i in range(H)]\n    AS = []; BS = []\n    for i in range(H):\n        s = readline().strip()\n        Mi = M[i]\n        for j, c in enumerate(s):\n            if c == '*':\n                Mi[j] = -1\n            elif c == 'X':\n                Mi[j] = 1\n                AS.append((j, i))\n            elif c == '.':\n                BS.append((j, i))\n    G = [[] for i in range(H*W)]\n    for y in range(H):\n        for x in range(W):\n            k = y*W + x\n            if M[y][x] == -1:\n                continue\n            for dx, dy in dd:\n                nx = x + dx; ny = y + dy\n                if not 0 <= nx < W or not 0 <= ny < H or M[ny][nx] == -1:\n                    continue\n                G[k].append(ny*W + nx)\n\n    sx, sy = min(AS)\n    if sx == sy == 0:\n        write(\"0\\n\")\n        return True\n\n    (x0, y0), (x1, y1) = BS\n\n    ee = [\n        ((-1, 0), (-1, 1)),\n        ((0, -1), (1, -1)),\n        ((2, 0), (2, 1)),\n        ((0, 2), (1, 2)),\n    ]\n    INF = 10**9\n    D = [[[INF]*4 for i in range(W)] for j in range(H)]\n\n    d1 = [0]*(H*W)\n    d2 = [0]*(H*W)\n    calc(H, W, G, x0, y0, sx, sy, d1)\n    calc(H, W, G, x1, y1, sx, sy, d2)\n\n    que0 = []\n    for i in range(4):\n        (dx1, dy1), (dx2, dy2) = ee[i]\n        x1 = sx+dx1; y1 = sy+dy1\n        x2 = sx+dx2; y2 = sy+dy2\n        if not 0 <= x1 <= x2 < W or not 0 <= y1 <= y2 < H:\n            continue\n        k1 = y1*W + x1; k2 = y2*W + x2\n        if d1[k1] == -1 or d2[k2] == -1:\n            continue\n        d = min(d1[k1] + d2[k2], d1[k2] + d2[k1])\n        que0.append((d, sx, sy, i))\n        D[sy][sx][i] = d\n    heapify(que0)\n\n    while que0:\n        cost0, x0, y0, t0 = heappop(que0)\n        if D[y0][x0][t0] < cost0:\n            continue\n        if x0 == y0 == 0:\n            break\n        (dx1, dy1), (dx2, dy2) = ee[t0]\n        x1 = x0 + dx1; y1 = y0 + dy1\n        x2 = x0 + dx2; y2 = y0 + dy2\n        calc(H, W, G, x1, y1, x0, y0, d1)\n        calc(H, W, G, x2, y2, x0, y0, d2)\n\n        for t1 in range(4):\n            (dx3, dy3), (dx4, dy4) = ee[t1]\n            x3 = x0 + dx3; y3 = y0 + dy3\n            x4 = x0 + dx4; y4 = y0 + dy4\n            if not 0 <= x3 <= x4 < W or not 0 <= y3 <= y4 < H:\n                continue\n            k3 = y3*W + x3; k4 = y4*W + x4\n            if d1[k3] == -1 or d2[k4] == -1:\n                continue\n            d = min(d1[k3] + d2[k4], d1[k4] + d2[k3]) + 1\n            dx, dy = dd[t1]\n            nx = x0 + dx; ny = y0 + dy\n            if cost0 + d < D[ny][nx][t1^2]:\n                D[ny][nx][t1^2] = cost0 + d\n                heappush(que0, (cost0 + d, nx, ny, t1^2))\n    res = min(D[0][0][2], D[0][0][3])\n    if res != INF:\n        write(\"%d\\n\" % res)\n    else:\n        write(\"-1\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]