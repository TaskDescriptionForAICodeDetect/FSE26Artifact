[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_SIZE 1000\n\nint grid[MAX_SIZE][MAX_SIZE];\nint minTable[MAX_SIZE][MAX_SIZE][10][10];\nint logTable[MAX_SIZE + 1];\n\nvoid precomputeLog(int n) {\n    logTable[1] = 0;\n    for (int i = 2; i <= n; i++) {\n        logTable[i] = logTable[i / 2] + 1;\n    }\n}\n\nvoid buildSparseTable(int n, int m) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            minTable[i][j][0][0] = grid[i][j];\n        }\n    }\n\n    for (int k = 1; (1 << k) <= n; k++) {\n        for (int i = 0; i + (1 << k) <= n; i++) {\n            for (int j = 0; j < m; j++) {\n                minTable[i][j][k][0] = (minTable[i][j][k - 1][0] < minTable[i + (1 << (k - 1))][j][k - 1][0]) \n                                      ? minTable[i][j][k - 1][0] \n                                      : minTable[i + (1 << (k - 1))][j][k - 1][0];\n            }\n        }\n    }\n\n    for (int l = 1; (1 << l) <= m; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j + (1 << l) <= m; j++) {\n                for (int k = 0; (1 << k) <= n; k++) {\n                    minTable[i][j][k][l] = (minTable[i][j][k][l - 1] < minTable[i][j + (1 << (l - 1))][k][l - 1]) \n                                          ? minTable[i][j][k][l - 1] \n                                          : minTable[i][j + (1 << (l - 1))][k][l - 1];\n                }\n            }\n        }\n    }\n}\n\nint queryMin(int x1, int y1, int x2, int y2) {\n    int kx = logTable[x2 - x1 + 1];\n    int ky = logTable[y2 - y1 + 1];\n\n    int min1 = (minTable[x1][y1][kx][ky] < minTable[x2 - (1 << kx) + 1][y1][kx][ky]) \n               ? minTable[x1][y1][kx][ky] \n               : minTable[x2 - (1 << kx) + 1][y1][kx][ky];\n    int min2 = (minTable[x1][y2 - (1 << ky) + 1][kx][ky] < minTable[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky]) \n               ? minTable[x1][y2 - (1 << ky) + 1][kx][ky] \n               : minTable[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky];\n    return (min1 < min2) ? min1 : min2;\n}\n\nint main() {\n    precomputeLog(MAX_SIZE);\n\n    int n, m, q;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n\n        buildSparseTable(n, m);\n\n        scanf(\"%d\", &q);\n        while (q--) {\n            int x1, y1, x2, y2;\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            printf(\"%d\\n\", queryMin(x1, y1, x2, y2));\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KillifishSafety {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int rows = scanner.nextInt();\n            int cols = scanner.nextInt();\n\n            int[][] grid = new int[rows][cols];\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n\n            int queries = scanner.nextInt();\n            for (int q = 0; q < queries; q++) {\n                int r1 = scanner.nextInt() - 1;\n                int c1 = scanner.nextInt() - 1;\n                int r2 = scanner.nextInt() - 1;\n                int c2 = scanner.nextInt() - 1;\n\n                int minDangerousness = findMinDangerousness(grid, r1, c1, r2, c2);\n                System.out.println(minDangerousness);\n            }\n        }\n        scanner.close();\n    }\n\n    private static int findMinDangerousness(int[][] grid, int r1, int c1, int r2, int c2) {\n        int min = Integer.MAX_VALUE;\n        for (int i = r1; i <= r2; i++) {\n            for (int j = c1; j <= c2; j++) {\n                min = Math.min(min, grid[i][j]);\n            }\n        }\n        return min;\n    }\n}",
    "timestamp": "2025-08-05 19:01:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nvoid buildSparseTable(vector<vector<int>>& grid, vector<vector<vector<vector<int>>>>& st, int n, int m) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            st[i][j][0][0] = grid[i][j];\n        }\n    }\n\n    for (int k = 0; (1 << k) <= n; ++k) {\n        for (int l = 0; (1 << l) <= m; ++l) {\n            if (k == 0 && l == 0) continue;\n            for (int i = 0; i + (1 << k) <= n; ++i) {\n                for (int j = 0; j + (1 << l) <= m; ++j) {\n                    if (k == 0) {\n                        st[i][j][k][l] = min(st[i][j][k][l-1], st[i][j + (1 << (l-1))][k][l-1]);\n                    } else if (l == 0) {\n                        st[i][j][k][l] = min(st[i][j][k-1][l], st[i + (1 << (k-1))][j][k-1][l]);\n                    } else {\n                        int min1 = min(st[i][j][k-1][l-1], st[i + (1 << (k-1))][j][k-1][l-1]);\n                        int min2 = min(st[i][j + (1 << (l-1))][k-1][l-1], st[i + (1 << (k-1))][j + (1 << (l-1))][k-1][l-1]);\n                        st[i][j][k][l] = min(min1, min2);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint queryMin(vector<vector<vector<vector<int>>>>& st, int x1, int y1, int x2, int y2) {\n    int kx = 31 - __builtin_clz(x2 - x1 + 1);\n    int ky = 31 - __builtin_clz(y2 - y1 + 1);\n\n    int min1 = min(st[x1][y1][kx][ky], st[x1][y2 - (1 << ky) + 1][kx][ky]);\n    int min2 = min(st[x2 - (1 << kx) + 1][y1][kx][ky], st[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky]);\n    return min(min1, min2);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    while (cin >> n >> m) {\n        vector<vector<int>> grid(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n\n        int logn = 32 - __builtin_clz(n);\n        int logm = 32 - __builtin_clz(m);\n        vector<vector<vector<vector<int>>>> st(n, vector<vector<vector<int>>>(m, vector<vector<int>>(logn, vector<int>(logm))));\n\n        buildSparseTable(grid, st, n, m);\n\n        int q;\n        cin >> q;\n        while (q--) {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            x1--; y1--; x2--; y2--;\n            cout << queryMin(st, x1, y1, x2, y2) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_SIZE 1001\n\nint grid[MAX_SIZE][MAX_SIZE];\nint prefixSum[MAX_SIZE][MAX_SIZE];\n\nvoid calculatePrefixSum(int rows, int cols) {\n    for (int i = 1; i <= rows; i++) {\n        for (int j = 1; j <= cols; j++) {\n            prefixSum[i][j] = grid[i][j] + \n                              prefixSum[i-1][j] + \n                              prefixSum[i][j-1] - \n                              prefixSum[i-1][j-1];\n        }\n    }\n}\n\nint findMinDangerousness(int r1, int c1, int r2, int c2) {\n    return prefixSum[r2][c2] - \n           prefixSum[r1-1][c2] - \n           prefixSum[r2][c1-1] + \n           prefixSum[r1-1][c1-1];\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int rows, cols, queries;\n        scanf(\"%d %d\", &rows, &cols);\n\n        for (int i = 1; i <= rows; i++) {\n            for (int j = 1; j <= cols; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n\n        calculatePrefixSum(rows, cols);\n\n        scanf(\"%d\", &queries);\n\n        while (queries--) {\n            int r1, c1, r2, c2;\n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            \n            int result = findMinDangerousness(r1, c1, r2, c2);\n            printf(\"%d\\n\", result);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findMinDangerousness(vector<vector<int>>& grid, vector<vector<int>>& queries) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        // 2D prefix min array\n        vector<vector<int>> prefixMin(m + 1, vector<int>(n + 1, INT_MAX));\n        \n        // Compute prefix min array\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixMin[i][j] = min({\n                    prefixMin[i-1][j],\n                    prefixMin[i][j-1],\n                    prefixMin[i-1][j-1],\n                    grid[i-1][j-1]\n                });\n            }\n        }\n        \n        // Process queries\n        vector<int> results;\n        for (auto& query : queries) {\n            int r1 = query[0], c1 = query[1];\n            int r2 = query[2], c2 = query[3];\n            \n            int minVal = INT_MAX;\n            for (int i = r1; i <= r2; i++) {\n                for (int j = c1; j <= c2; j++) {\n                    minVal = min(minVal, grid[i][j]);\n                }\n            }\n            results.push_back(minVal);\n        }\n        \n        return results;\n    }\n};\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        int m, n;\n        cin >> m >> n;\n        \n        vector<vector<int>> grid(m, vector<int>(n));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        \n        int q;\n        cin >> q;\n        vector<vector<int>> queries(q, vector<int>(4));\n        \n        for (int i = 0; i < q; i++) {\n            cin >> queries[i][0] >> queries[i][1] >> queries[i][2] >> queries[i][3];\n        }\n        \n        Solution solution;\n        vector<int> results = solution.findMinDangerousness(grid, queries);\n        \n        for (int result : results) {\n            cout << result << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SparseTable {\n        int[][] log;\n        int[][][][] st;\n\n        public SparseTable(int[][] grid) {\n            int rows = grid.length;\n            int cols = grid[0].length;\n            int logRows = log2(rows) + 1;\n            int logCols = log2(cols) + 1;\n            st = new int[rows][cols][logRows][logCols];\n            log = new int[Math.max(rows, cols) + 1];\n            for (int i = 2; i <= Math.max(rows, cols); i++) {\n                log[i] = log[i / 2] + 1;\n            }\n\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    st[i][j][0][0] = grid[i][j];\n                }\n            }\n\n            for (int k = 0; (1 << k) <= rows; k++) {\n                for (int l = 0; (1 << l) <= cols; l++) {\n                    if (k == 0 && l == 0) continue;\n                    for (int i = 0; i + (1 << k) - 1 < rows; i++) {\n                        for (int j = 0; j + (1 << l) - 1 < cols; j++) {\n                            if (k == 0) {\n                                st[i][j][k][l] = Math.min(st[i][j][k][l - 1], st[i][j + (1 << (l - 1))][k][l - 1]);\n                            } else {\n                                st[i][j][k][l] = Math.min(st[i][j][k - 1][l], st[i + (1 << (k - 1))][j][k - 1][l]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        public int query(int x1, int y1, int x2, int y2) {\n            int kx = log[x2 - x1 + 1];\n            int ky = log[y2 - y1 + 1];\n            int min1 = Math.min(st[x1][y1][kx][ky], st[x2 - (1 << kx) + 1][y1][kx][ky]);\n            int min2 = Math.min(st[x1][y2 - (1 << ky) + 1][kx][ky], st[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky]);\n            return Math.min(min1, min2);\n        }\n\n        private int log2(int n) {\n            return 31 - Integer.numberOfLeadingZeros(n);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        String line;\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            StringTokenizer st = new StringTokenizer(line);\n            int R = Integer.parseInt(st.nextToken());\n            int C = Integer.parseInt(st.nextToken());\n            if (R == 0 && C == 0) break;\n            int[][] grid = new int[R][C];\n            for (int i = 0; i < R; i++) {\n                st = new StringTokenizer(br.readLine());\n                for (int j = 0; j < C; j++) {\n                    grid[i][j] = Integer.parseInt(st.nextToken());\n                }\n            }\n            SparseTable sparseTable = new SparseTable(grid);\n            int Q = Integer.parseInt(br.readLine());\n            while (Q-- > 0) {\n                st = new StringTokenizer(br.readLine());\n                int x1 = Integer.parseInt(st.nextToken()) - 1;\n                int y1 = Integer.parseInt(st.nextToken()) - 1;\n                int x2 = Integer.parseInt(st.nextToken()) - 1;\n                int y2 = Integer.parseInt(st.nextToken()) - 1;\n                pw.println(sparseTable.query(x1, y1, x2, y2));\n            }\n        }\n        pw.close();\n    }\n}",
    "timestamp": "2025-08-05 19:03:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def process_queries(grid, queries):\n    results = []\n    for r1, c1, r2, c2 in queries:\n        min_value = float('inf')\n        for r in range(r1, r2 + 1):\n            for c in range(c1, c2 + 1):\n                if grid[r][c] < min_value:\n                    min_value = grid[r][c]\n        results.append(min_value)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    index = 0\n    number_of_datasets = int(data[index])\n    index += 1\n    all_results = []\n\n    for _ in range(number_of_datasets):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        \n        grid = []\n        for _ in range(n):\n            grid.append(list(map(int, data[index:index + m])))\n            index += m\n        \n        q = int(data[index])\n        index += 1\n        \n        queries = []\n        for _ in range(q):\n            r1 = int(data[index])\n            c1 = int(data[index + 1])\n            r2 = int(data[index + 2])\n            c2 = int(data[index + 3])\n            queries.append((r1, c1, r2, c2))\n            index += 4\n            \n        results = process_queries(grid, queries)\n        all_results.append(results)\n    \n    for results in all_results:\n        for result in results:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:01:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class KillifishSchool {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int datasets = scanner.nextInt();\n        \n        for (int dataSet = 0; dataSet < datasets; dataSet++) {\n            int rows = scanner.nextInt();\n            int cols = scanner.nextInt();\n            \n            int[][] grid = new int[rows][cols];\n            \n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            \n            int queries = scanner.nextInt();\n            \n            for (int query = 0; query < queries; query++) {\n                int row1 = scanner.nextInt();\n                int col1 = scanner.nextInt();\n                int row2 = scanner.nextInt();\n                int col2 = scanner.nextInt();\n                \n                int minDangerousness = Integer.MAX_VALUE;\n                \n                for (int i = row1; i <= row2; i++) {\n                    for (int j = col1; j <= col2; j++) {\n                        minDangerousness = Math.min(minDangerousness, grid[i][j]);\n                    }\n                }\n                \n                System.out.println(minDangerousness);\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 02:01:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_GRID_SIZE 100\n\nint main() {\n    int m, n, q;\n    int grid[MAX_GRID_SIZE][MAX_GRID_SIZE];\n    int x1, y1, x2, y2;\n    int i, j, k, l;\n    \n    while (scanf(\"%d %d\", &m, &n) == 2) {\n        for (i = 0; i < m; i++) {\n            for (j = 0; j < n; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n        \n        scanf(\"%d\", &q);\n        for (k = 0; k < q; k++) {\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            \n            int minimumDangerousness = INT_MAX;\n            for (i = x1; i <= x2; i++) {\n                for (j = y1; j <= y2; j++) {\n                    if (grid[i][j] < minimumDangerousness) {\n                        minimumDangerousness = grid[i][j];\n                    }\n                }\n            }\n            printf(\"%d\\n\", minimumDangerousness);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:01:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_killifish_problem():\n    datasets = int(input())\n    \n    for _ in range(datasets):\n        rows, cols = map(int, input().split())\n        \n        # Read grid\n        grid = []\n        for _ in range(rows):\n            grid.append(list(map(int, input().split())))\n        \n        # Precompute prefix sum 2D grid for efficient range minimum queries\n        prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\n        for i in range(1, rows + 1):\n            for j in range(1, cols + 1):\n                prefix_sum[i][j] = (grid[i-1][j-1] + \n                                    prefix_sum[i-1][j] + \n                                    prefix_sum[i][j-1] - \n                                    prefix_sum[i-1][j-1])\n        \n        # Process queries\n        queries = int(input())\n        for _ in range(queries):\n            r1, c1, r2, c2 = map(int, input().split())\n            \n            # Calculate minimum value in specified subgrid\n            min_value = prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - \\\n                        prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1]\n            \n            area = (r2 - r1 + 1) * (c2 - c1 + 1)\n            result = min_value // area\n            \n            print(result)\n\nsolve_killifish_problem()",
    "timestamp": "2025-08-13 02:01:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        R = int(input[ptr])\n        C = int(input[ptr+1])\n        ptr +=2\n        if R ==0 and C ==0:\n            break\n        grid = []\n        for _ in range(R):\n            row = list(map(int, input[ptr:ptr+C]))\n            ptr +=C\n            grid.append(row)\n        \n        logR = math.floor(math.log2(R)) if R >0 else 0\n        logC = math.floor(math.log2(C)) if C >0 else 0\n        \n        # Preprocess for 2D Sparse Table\n        st = [[[[0 for _ in range(C)] for __ in range(R)] for ___ in range(logC +1)] for ____ in range(logR +1)]\n        \n        # Base case: k1=0, k2=0\n        for i in range(R):\n            for j in range(C):\n                st[0][0][i][j] = grid[i][j]\n        \n        # Preprocess rows (k1=0, k2 varies)\n        for k2 in range(1, logC +1):\n            for i in range(R):\n                for j in range(C - (1 << k2) +1):\n                    st[0][k2][i][j] = min(st[0][k2-1][i][j], st[0][k2-1][i][j + (1 << (k2-1))])\n        \n        # Preprocess columns (k1 varies, k2 varies)\n        for k1 in range(1, logR +1):\n            for k2 in range(logC +1):\n                for i in range(R - (1 << k1) +1):\n                    for j in range(C - (1 << k2) +1):\n                        st[k1][k2][i][j] = min(st[k1-1][k2][i][j], st[k1-1][k2][i + (1 << (k1-1))][j])\n        \n        Q = int(input[ptr])\n        ptr +=1\n        for _ in range(Q):\n            r1 = int(input[ptr])-1\n            c1 = int(input[ptr+1])-1\n            r2 = int(input[ptr+2])-1\n            c2 = int(input[ptr+3])-1\n            ptr +=4\n            \n            k1 = math.floor(math.log2(r2 - r1 +1)) if (r2 - r1 +1) >0 else 0\n            k2 = math.floor(math.log2(c2 - c1 +1)) if (c2 - c1 +1) >0 else 0\n            \n            # Compute the four corners\n            min1 = st[k1][k2][r1][c1]\n            min2 = st[k1][k2][r2 - (1 << k1) +1][c1]\n            min3 = st[k1][k2][r1][c2 - (1 << k2) +1]\n            min4 = st[k1][k2][r2 - (1 << k1) +1][c2 - (1 << k2) +1]\n            \n            res = min(min1, min2, min3, min4)\n            print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:05:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Killifish {\npublic:\n    void processQueries(vector<vector<int>>& grid, vector<tuple<int, int, int, int>>& queries) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        // Precompute minimums for all possible subgrids using DP\n        vector<vector<int>> minDP(n, vector<int>(m, INT_MAX));\n\n        // Fill the DP table\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                // Current cell value\n                minDP[i][j] = grid[i][j];\n\n                // Include value from top\n                if (i > 0) {\n                    minDP[i][j] = min(minDP[i][j], minDP[i - 1][j]);\n                }\n\n                // Include value from left\n                if (j > 0) {\n                    minDP[i][j] = min(minDP[i][j], minDP[i][j - 1]);\n                }\n\n                // Include value from top-left diagonally\n                if (i > 0 && j > 0) {\n                    minDP[i][j] = min(minDP[i][j], minDP[i - 1][j - 1]);\n                }\n            }\n        }\n\n        // Process each query\n        for (const auto& query : queries) {\n            int r1, c1, r2, c2;\n            tie(r1, c1, r2, c2) = query;\n            cout << getSubgridMinimum(minDP, r1, c1, r2, c2) << endl;\n        }\n    }\n\nprivate:\n    int getSubgridMinimum(vector<vector<int>>& minDP, int r1, int c1, int r2, int c2) {\n        // Calculate the minimum dangerousness value in the subgrid\n        int minimumValue = INT_MAX;\n\n        for (int i = r1; i <= r2; ++i) {\n            for (int j = c1; j <= c2; ++j) {\n                minimumValue = min(minimumValue, minDP[i][j]);\n            }\n        }\n\n        return minimumValue;\n    }\n};\n\nint main() {\n    int datas, n, m, q;\n    cin >> datas;\n    for (int d = 0; d < datas; ++d) {\n        cin >> n >> m;\n        vector<vector<int>> grid(n, vector<int>(m));\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n\n        cin >> q;\n        vector<tuple<int, int, int, int>> queries;\n        for (int i = 0; i < q; ++i) {\n            int r1, c1, r2, c2;\n            cin >> r1 >> c1 >> r2 >> c2;\n            queries.emplace_back(r1, c1, r2, c2);\n        }\n\n        Killifish killifish;\n        killifish.processQueries(grid, queries);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:00"
  }
]