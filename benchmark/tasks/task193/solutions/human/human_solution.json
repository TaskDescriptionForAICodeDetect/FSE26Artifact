[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n < n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w){\n            swap(h, w);\n            f = true;\n        }\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            if(f){\n                swap(a.first, a.second);\n                swap(b.first, b.second);\n            }\n            //a.second++; b.second++;\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 650;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][10][10];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n#else\n#define dbg(...) {}\n#endif\n\nconst int INF = INT_MAX;\n\ntemplate<typename T>\nclass SegTree2D {\npublic:\n  int h,w;\n  vector<vector<T>> data;\n  SegTree2D(const int _h, const int _w){\n    h=1;w=1;\n    while(h<_h) h*=2;\n    while(w<_w) w*=2;\n    data.resize(2*h, vector<T>(2*w, INF));\n  }\n  T query(const int kh, int wl, int wr) const {\n    T ret = INF;\n    for(wl+=w, wr+=w; wl<wr; wl/=2, wr/=2){\n      if(wl&1) ret = min(ret, data[kh][wl++]);\n      if(wr&1) ret = min(ret, data[kh][--wr]);\n    }\n    return ret;\n  }\n  T query(int hl, int hr, const int wl, const int wr) const {\n    T ret = INF;\n    for(hl+=h, hr+=h; hl<hr; hl/=2, hr/=2){\n      if(hl&1) ret = min(ret, query(hl++,wl,wr));\n      if(hr&1) ret = min(ret, query(--hr,wl,wr));\n    }\n    return ret;\n  }\n  void updateInner(const int kh, int kw, const T a){\n    kw += w;\n    data[kh][kw] = a;\n    while(kw > 0){\n      kw = kw / 2;\n      data[kh][kw] = min(data[kh][kw*2], data[kh][kw*2+1]);\n    }\n  }\n  void update(int kh, const int kw, const T a){\n    kh += h;\n    updateInner(kh, kw, a);\n    while(kh > 0){\n      kh = kh/2;\n      updateInner(kh, kw, min(data[kh*2][kw+w], data[kh*2+1][kw+w]));\n    }\n  }\n};\n\nint main(){\n  int r,c,q;\n  while(scanf(\"%d %d %d\", &r, &c, &q), r){\n    SegTree2D<int> st(r,c);\n    rep(i,r) rep(j,c){\n      int x;\n      scanf(\"%d\", &x);\n      st.update(i,j,x);\n    }\n    rep(i,q){\n      int x1,y1,x2,y2;\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n      printf(\"%d\\n\", st.query(x1, x2+1, y1, y2+1));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tS *dat;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ():dat(0){\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid build(int n,const S a[]){\n\t\tint m=n;\n\t\tn=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t/*void update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}*/\n\tS query(int a,int b,int k,int l,int r)const{//[a,b)の最小(大)値\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n};\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(xs,xe, 0,0,w);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=2000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  int data[2 * 2 * 2 * 100100];\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[100100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n//メモリ食う　emp共有,片方がempならempでない方を共有->殆ど変わらず\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tif(rmq[i*2+1]==emp && rmq[i*2+2]==emp){\n\t\t\t\trmq[i]=emp;\n\t\t\t}else{\n\t\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(rmq[i]!=emp){\n\t\t\t\tdelete rmq[i];\n\t\t\t}\n\t\t}\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build() {\n\t\tint h = sp[0].size(), w = sp[0][0][0].size(), ir, ic, jr, jc;\n\t\tfor (ir=0;ir<h;ir++)\n\t\t\tfor (jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor (ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor (jr=1;jr<=log2(h);jr++)\n\t\t\tfor (ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor (jc=0;jc<=log2(w);jc++)\n\t\t\t\t\tfor (ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n};\n\nint h, w, q, xa, ya, xb, yb;\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tSPA2<int> sp(h,w);\n\t\tint t;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build();\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1068\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nconst int INF = 1 << 30;\n\nint r, c, q;\nstd::vector<std::vector<int> > segR, segC;\n\nvoid init( std::vector<std::vector<int> > &seg, int n )\n{\n\tint sz = 1;\n\twhile( sz < c )\n\t\tsz <<= 1;\n\n\trep( i, seg.size() )\n\t\tseg[i].resize( 2*sz, INF );\n\n\treturn;\n}\n\nvoid update( std::vector<int> &seg, int k, int x )\n{\n\tk += (seg.size()>>1)-1;\n\tseg[k] = x;\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tseg[k] = std::min( seg[(k<<1)+1], seg[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nint query( const std::vector<int> &seg, int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn INF;\n\telse if( a <= l && r <= b )\n\t\treturn seg[k];\n\t\n\treturn std::min( query( seg, a, b, (k<<1)+1, l, (l+r)>>1 ), query( seg, a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d%d\", &r, &c, &q ), r|c|q )\n\t{\n\t\tsegR.resize( r );\n\t\tsegC.resize( c );\n\t\tinit( segR, c );\n\t\tinit( segC, r );\n\n\t\trep( i, r )\n\t\t{\n\t\t\trep( j, c )\n\t\t\t{\n\t\t\t\tint grid;\n\t\t\t\tscanf( \"%d\", &grid );\n\n\t\t\t\tupdate( segR[i], j, grid );\n\t\t\t\tupdate( segC[j], i, grid );\n\t\t\t}\n\t\t}\n\n\t\trep( i, q )\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf( \"%d%d%d%d\", &r1, &c1, &r2, &c2 );\n\n\t\t\tint ans = INF;\n\n\t\t\tif( r2-r1 <= c2-c1 )\n\t\t\t\trepi( j, r1, r2+1 )\n\t\t\t\t\tans = std::min( ans, query( segR[j], c1, c2+1, 0, 0, segR[j].size()>>1 ) );\n\t\t\telse\n\t\t\t\trepi( j, c1, c2+1 )\n\t\t\t\t\tans = std::min( ans, query( segC[j], r1, r2+1, 0, 0, segC[j].size()>>1 ) );\n\n\t\t\tprintf( \"%d\\n\", ans );\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\t//if(vl<vr)return vl;\n\t//return vr;\n\treturn min(vl,vr);\n}\n\nint main(){\n\tFILE *fp=stdin;\n\t//fp=fopen(\"input.txt\",\"r\");\n\twhile(fscanf(fp,\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\t//while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\t//cin>>t;\n\t\t\t\tfscanf(fp,\"%d\",&t);\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\t//cin>>r1>>c1>>r2>>c2;\n\t\t\tfscanf(fp,\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\t//cout<<res<<endl;\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void destroy();\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void destroy(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Free.\nvoid SegmentTree::destroy() {free(root_);}\nvoid SegmentTree::destroy(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) destroy(node->child[i]);\n  delete[] node->child;\n  delete node;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.destroy();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\nint data[1 << 23];\nint v[1 << 20];\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), w(size(w_)), id(id_), merge(merge_) {\n\t\tfill(data, data + (1 << 23), id);\n\t\tfor (int i = 0; i < h_; i++)\n\t\t\tfor (int j = 0; j < w_; j++)\n\t\t\t\tdata[(h + i) * w * 2 + w + j] = v[i * w_ + j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n\t}\n\tvoid Update(int pi, int pj, T val) {\n\t\tpi += h;\n\t\tpj += w;\n\t\tdata[pi * w * 2 + pj] = val;\n\t\tint tj = pj;\n\t\twhile (tj >>= 1) {\n\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t}\n\t\twhile (pi >>= 1) {\n\t\t\tdata[pi * w * 2 + pj] = merge(data[(pi * 2) * w * 2 + pj], data[(pi * 2 + 1) * w * 2 + pj]);\n\t\t\ttj = pj;\n\t\t\twhile (tj >>= 1) {\n\t\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\tli += h, ri += h + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (li < ri) {\n\t\t\tif (li & 1) {\n\t\t\t\tint l = lj + w, r = rj + w + 1;\n\t\t\t\tT t1 = id, t2 = id;\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) t1 = merge(t1, data[li * w * 2 + l++]);\n\t\t\t\t\tif (r & 1) t2 = merge(data[li * w * 2 + --r], t2);\n\t\t\t\t\tl >>= 1, r >>= 1;\n\t\t\t\t}\n\t\t\t\tres1 = merge(res1, merge(t1, t2));\n\t\t\t\tli++;\n\t\t\t}\n\t\t\tif (ri & 1) {\n\t\t\t\tri--;\n\t\t\t\tint l = lj + w, r = rj + w + 1;\n\t\t\t\tT t1 = id, t2 = id;\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) t1 = merge(t1, data[ri * w * 2 + l++]);\n\t\t\t\t\tif (r & 1) t2 = merge(data[ri * w * 2 + --r], t2);\n\t\t\t\t\tl >>= 1, r >>= 1;\n\t\t\t\t}\n\t\t\t\tres2 = merge(merge(t1, t2), res2);\n\t\t\t}\n\t\t\tli >>= 1, ri >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i * c + j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct SegTree{\n\tvi data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,INT_MAX);\n\t}\n\tvoid Update(int i,int n){\n\t\tdata[size+i]=n;\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=min(data[j],n);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INT_MAX;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INT_MAX,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tbool flg=r>c; // グリッドが縦長\n\t\tif(r>c) swap(r,c);\n\t\tvvi grid(r,vi(c));\n\t\trep(i,r) rep(j,c)\n\t\t\tscanf(\"%d\",&(flg?grid[j][i]:grid[i][j]));\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q)\n\t\t\tscanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\tif(flg){\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tvector<SegTree> st(r,SegTree(c));\n\t\trep(i,r) rep(j,c)\n\t\t\tst[i].Update(j,grid[i][j]);\n\t\t\n\t\trep(i,q){\n\t\t\tint mn=INT_MAX;\n\t\t\trepi(j,r1[i],r2[i]+1)\n\t\t\t\tmn=min(mn,st[j].Query(c1[i],c2[i]+1));\n\t\t\tprintf(\"%d\\n\",mn);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tvector<T> a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector< vector<T> > &v,int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=v[0].size();\n\t\telse   N=v.size();\n\n\t\twhile(n<N) n<<=1;\n\t\ta=vector<T>(2*n-1);\n\n\t\tif(!b) rep(i,N) a[n+i-1]=v[k][i];\n\t\telse   rep(i,N) a[n+i-1]=v[i][k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tvector< RMQ<int> > rmq1(h);\n\t\t// vector< RMQ<int> > rmq2(w);\n\t\trep(i,h) rmq1[i]=RMQ<int>(a,i,0);\n\t\t// rep(j,w) rmq2[j]=RMQ<int>(a,j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tfor(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\t// else        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = pow(2,31) - 1;\nint n;\nvoid powset(int size){\n  n = 1;\n  while( n < size ) n *= 2;\n}\n\nstruct RMQ{\n  vector< int > seg;\n  void update( int i, int x){\n    i += n - 1;\n    seg[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      seg[i] = min( seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n  }\n  int query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) return seg[k];\n    int vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return min( vl, vr);\n  }\n  int query( int a, int b){\n    return query( a, b, 0, 0, n);\n  }\n  RMQ(){\n    seg.assign( n * 2 - 1, INF);\n  }\n};\n\nint main(){\n  int R, C, Q;\n  while(cin >> R >> C >> Q, R){\n    if(R < C){\n      powset(C);\n      vector< RMQ > rmq( R, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          cin >> grid;\n          rmq[i].update(j,grid);\n        }\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        cin >> r1 >> c1 >> r2 >> c2;\n        int ret = INF;\n        for(int i = r1; i <= r2; i++){\n          ret = min( ret, rmq[i].query( c1, c2 + 1));\n        }\n        cout << ret << endl;\n      }\n    }else{\n      powset(R);\n      vector< RMQ > rmq( C, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          cin >> grid;\n          rmq[j].update(i,grid);\n        }\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        cin >> r1 >> c1 >> r2 >> c2;\n        int ret = INF;\n        for(int i = c1; i <= c2; i++){\n          ret = min( ret, rmq[i].query( r1, r2 + 1));\n        }\n        cout << ret << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n#include<set>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tif(rmq[i*2+1]==emp && rmq[i*2+2]==emp){\n\t\t\t\trmq[i]=emp;\n\t\t\t}else if(rmq[i*2+1]==emp || rmq[i*2+2]==emp){\n\t\t\t\trmq[i]=rmq[i*2+1]==emp?rmq[i*2+2]:rmq[i*2+1];\n\t\t\t}else{\n\t\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tstd::set<RMQ<S,T,nil> *> s;\n\t\tfor(int i=0;i<2*h-1;i++){\n\t\t\tif(rmq[i]!=emp && s.find(rmq[i])==s.end()){\n\t\t\t\ts.insert(rmq[i]);\n\t\t\t\tdelete rmq[i];\n\t\t\t}\n\t\t}\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[10000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\ninline int MIN(int a,int b){\n\treturn a<b?a:b;\n}\nstruct SSS{\n\tint p[16];\n}st[1010000];\nSSS *top,*at[1100];\nint tlog[1010000];\nSSS *getptr(int len) {\n\tSSS *p=top;\n\ttop+=(len+1);\n\treturn p;\n}\nvoid ST(SSS st[],int num[],int sz){\n     for(int i=1;i<=sz;i++) st[i].p[0]=num[i];\n     for(int j=1;j<=tlog[sz];j++){\n           for(int i=0;j<=tlog[sz+1-i];i++){\n                st[i].p[j]=MIN(st[i].p[j-1],st[i+(1<<j>>1)].p[j-1]);\n           }\n     }\n}\nint RMQ(SSS st[],int l,int r){\n     int tmp=tlog[r-l+1];\n     return MIN(st[l].p[tmp],st[r-(1<<tmp)+1].p[tmp]);\n}\nint p[1100000],tp[1100000];\nvoid scanf_(int &num){\n\tchar in;\n\tbool neg=false;\n\twhile(((in=getchar())>'9'||in<'0')&&in!='-');\n\tif(in=='-'){\n\t\tneg=true;\n\t\twhile((in=getchar())>'9'||in<'0');\n\t}\n\tnum=in-'0';\n\twhile(in=getchar(),in>='0'&&in<='9')\n\t\tnum*=10,num+=in-'0';\n\tif(neg)\n\tnum=0-num;\n}\nint main(){\n\ttlog[0]=-1;\n\tfor(int i=1;i<1010000;i++){\n\t\ttlog[i]=tlog[i-1]+((i&(i-1))?0:1);\n\t}\n\tint r,c,q,fg;\n\twhile(scanf(\"%d%d%d\",&r,&c,&q),(r||c||q)) {\n\t\ttop=st;\n\t\tif(r<=c) {\n\t\t\tfor(int i=1;i<=r;i++) {\n\t\t\t\tat[i]=getptr(c);\n\t\t\t\tfor(int j=1;j<=c;j++) scanf_(p[j]);\n\t\t\t\tST(at[i],p,c);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=r1;j<=r2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],c1,c2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i=1;i<=r;i++) {\n\t\t\t\tfor(int j=1;j<=c;j++) scanf_(tp[(i-1)*c+j]);\n\t\t\t}\n\t\t\tfor(int i=1;i<=c;i++) {\n\t\t\t\tat[i]=getptr(r);\n\t\t\t\tfor(int j=1;j<=r;j++) p[j]=tp[(j-1)*c+i];\n\t\t\t\tST(at[i],p,r);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=c1;j<=c2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],r1,r2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint _query(int G, int x1, int x2, int k = 0, int l = 0, int r = wbin)\n{\n\tif (x2 <= l || r <= x1) return (INT_MAX);\n\tif (x1 <= l && r <= x2) return (seg[G][k]);\n\t\n\tint lval = _query(G, x1, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(G, x1, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int y1, int x1, int y2, int x2, int k = 0, int l = 0, int r = hbin)\n{\n\tif (y2 <= l || r <= y1) return (INT_MAX);\n\tif (y1 <= l && r <= y2) return (_query(k, x1, x2));\n\t\n\tint lval = query(y1, x1, y2, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(y1, x1, y2, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tprintf(\"%d %d\\n\", seg.size(), seg[0].size());\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query(y1, x1, y2 + 1, x2 + 1));\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#define MAXN 6000000 \nusing namespace std;\nint f[MAXN];\nint n,m,q,hi,hj;\nint min(int a,int b) { if(a<b) return a; else return b; }\nint gg(int i,int ii,int j,int jj)\n{   return i*(hi+1)*m*(hj+1) + ii*(hj+1)*m + j*(hj+1) + jj ;}\nvoid init()\n{\n     int i,j,ii,jj,now;\n     hi = log(n)/log(2);\n     hj = log(m)/log(2);\n     for(i=0;i<n;i++)\n       for(j=0;j<m;j++)\n         scanf(\"%d\",&f[ gg(i,0,j,0) ] );\n         \n     for(j=0;j<m;j++)    \n      for(ii=1;ii<=hi;ii++)\n        for(i=0;i<n-(1<<ii)+1;i++)\n          f[ gg(i,ii,j,0) ] = min( f[ gg(i,ii-1,j,0 ) ] , \n                                   f[ gg(i+( 1<<(ii-1) ) , ii-1,j,0) ] ); \n\n     for(i=0;i<n;i++)    \n      for(jj=1;jj<=hj;jj++)\n        for(j=0;j<m-(1<<jj)+1;j++)\n          f[ gg(i,0,j,jj) ] = min( f[ gg(i,0,j,jj-1) ] , \n                                   f[ gg(i,0,j+( 1<<(jj-1) ),jj-1) ] ); \n     \n     for(ii=1;ii<=hi;ii++)\n       for(i=0;i<n;i++)\n         for(jj=1;jj<=hj;jj++)\n           for(j=0;j<m;j++)\n           {  now = gg(i,ii,j,jj);\n              f[ now ] = min( f[ gg(i,ii-1,j,jj-1) ] , \n                              f[ gg(i,ii-1,j+(1<<(jj-1)),jj-1) ]);\n              f[ now ] = min( f[ gg(i+( 1<<(ii-1) ) ,ii-1,j,jj-1) ] , f[ now ]);\n              f[ now ] = min( f[ gg(i+( 1<<(ii-1) ) ,ii-1,j+( 1<<(jj-1) ),jj-1) ] , f[now] );\n           }                                                                \n}\nvoid solve()\n{\n     int x1,y1,x2,y2,i,ii,j,jj,ans;\n     scanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n     ii = log(x2-x1+1)/log(2);\n     jj = log(y2-y1+1)/log(2);\n     ans = min(f[ gg(x1,ii,y1,jj) ],f[ gg(x2-(1<<ii)+1,ii,y1,jj) ] );\n     ans = min(f[ gg(x1,ii,y2-(1<<jj)+1,jj) ],ans);\n     ans = min(f[ gg(x2-(1<<ii)+1 , ii , y2-(1<<jj)+1 , jj) ] , ans);\n     printf(\"%d\\n\",ans);\n}\nint main()\n{\n    int i;\n    while(scanf(\"%d %d %d\",&n,&m,&q)!=EOF && ( n || m || q))\n    {\n       init();\n       for(i=1;i<=q;i++)\n        solve();     \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n#include <array>\n\ntypedef long long TYPE;\nTYPE inf = 10000000000000000;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d();\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid init(const int h, const int w);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\tTYPE _get(const int i, const int j);\n\tvoid _set(const int i, const int j, const TYPE val);\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n\n\tint height;\n\tint width;\n\n\tint height2;\n\tint width2;\n\tint logwidth;\n\tvector<TYPE> array;\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << _get(i, j) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nTYPE Segment2d::_get(const int i, const int j)\n{\n\treturn array[(i << logwidth) + j];\n}\nvoid Segment2d::_set(const int i, const int j, const TYPE val)\n{\n\tarray[(i << logwidth) + j] = val;\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nvoid Segment2d::init(const int h, const int w)\n{\n\theight = h;\n\twidth = w;\n\twidth2 = 1;\n\tlogwidth = 0;\n\twhile(width2 < width)\n\t{\n\t\twidth2 *= 2;\n\t\tlogwidth++;\n\t} \n\tlogwidth++;\n\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfill(array.begin(), array.end(), inf);\n}\n\nSegment2d::Segment2d()\n{\n\tarray.resize(1 << 22);\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\t_set(y, x, val);\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tconst TYPE val = min(_get(left(ys[i]), xs[0]), _get(right(ys[i]), xs[0]));\n\t\t_set(ys[i], xs[0], val);\n\t}\n\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tconst TYPE val = min(_get(ys[i], left(xs[j])), _get(ys[i], right(xs[j])));\n\t\t\t_set(ys[i], xs[j], val);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn _get(ky, kx);\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg;\n\tseg.init(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tSegment2d seg;\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tseg.init(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\nconst int INF = (1LL << 31) - 1;\nint h, w;\nvector<vector<int> > g;\n\nvector<vector<int> > data;\nint size(int n)\n{\n    int m = 1;\n    while (m < n)\n        m *= 2;\n    return m;\n}\nvoid build_segtree()\n{\n    data = vector<vector<int> >(2 * h - 1, vector<int>(2 * w - 1, INF));\n\n    // x\n    for (int y = 0; y < h; ++y)\n    {\n        const int i = y + (h - 1);\n\n        for (int x = 0; x < w; ++x)\n            data[i][x + (w - 1)] = g[y][x];\n\n        for (int k = w - 2; k >= 0; --k)\n            data[i][k] = min(data[i][2 * k + 1], data[i][2 * k + 2]);\n    }\n\n    // y\n    for (int i = h - 2; i >= 0; --i)\n        for (int j = 0; j < 2 * w - 1; ++j)\n            data[i][j] = min(data[2 * i + 1][j], data[2 * i + 2][j]);\n}\nint x_query(int y_k, int x1, int x2, int k, int l, int r)\n{\n    if (x2 <= l || r <= x1)\n        return INF;\n    else if (x1 <= l && r <= x2)\n        return data[y_k][k];\n\n    int mid = (l + r) / 2;\n    int lv = x_query(y_k, x1, x2, 2 * k + 1, l, mid);\n    int rv = x_query(y_k, x1, x2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint y_query(int x1, int x2, int y1, int y2, int k, int l, int r)\n{\n    if (y2 <= l || r <= y1)\n        return INF;\n    else if (y1 <= l && r <= y2)\n        return x_query(k, x1, x2, 0, 0, w);\n\n    int mid = (l + r) / 2;\n    int lv = y_query(x1, x2, y1, y2, 2 * k + 1, l, mid);\n    int rv = y_query(x1, x2, y1, y2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint main()\n{\n    fast_io();\n\n    int q;\n    while (cin >> h >> w >> q, h)\n    {\n        g = vector<vector<int> >(size(h), vector<int>(size(w), INF));\n        for (int y = 0; y < h; ++y)\n            for (int x = 0; x < w; ++x)\n                cin >> g[y][x];\n        h = size(h);\n        w = size(w);\n\n        build_segtree();\n\n        while (q--)\n        {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            ++x2, ++y2;\n            cout << y_query(x1, x2, y1, y2, 0, 0, h) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INT_MAX;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nlli Cmin(lli a,lli b){\n\tif(a>b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint tree[16500000];\n\nvoid build(int x,int y,int num,int lx,int rx,int ly,int ry,int pos)\n{\n    if(lx==rx&&ly==ry)\n    {\n        tree[pos]=num;\n        return;\n    }\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    if(x<=midx&&y<=midy)\n    {\n        build(x,y,num,lx,midx,ly,midy,pos*4);\n        if(tree[pos]==-1||tree[pos*4]<tree[pos])\n            tree[pos]=tree[pos*4];\n    }\n    if(x<=midx&&y>midy)\n    {\n        build(x,y,num,lx,midx,midy+1,ry,pos*4+1);\n        if(tree[pos]==-1||tree[pos*4+1]<tree[pos])\n            tree[pos]=tree[pos*4+1];\n    }\n    if(x>midx&&y<=midy)\n    {\n        build(x,y,num,midx+1,rx,ly,midy,pos*4+2);\n        if(tree[pos]==-1||tree[pos*4+2]<tree[pos])\n            tree[pos]=tree[pos*4+2];\n    }\n    if(x>midx&&y>midy)\n    {\n        build(x,y,num,midx+1,rx,midy+1,ry,pos*4+3);\n        if(tree[pos]==-1||tree[pos*4+3]<tree[pos])\n            tree[pos]=tree[pos*4+3];\n    }\n //   printf(\"%d %d %d %d %d\\n\",lx,rx,ly,ry,tree[pos]);\n    return;\n}\n\nint query(int x,int y,int xx,int yy,int lx,int rx,int ly,int ry,int pos)\n{\n   // printf(\"%d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry);\n    if(x<=lx&&xx>=rx&&y<=ly&&yy>=ry)\n        return tree[pos];\n    if(lx==rx&&ly==ry)\n        return tree[pos];\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    int now=-1,temp;\n    if(x<=midx&&y<=midy)\n    {\n        temp=query(x,y,xx,yy,lx,midx,ly,midy,pos*4);\n        if(now==-1||temp<now)\n            now=temp;\n    }\n    if(x<=midx&&yy>midy)\n    {\n        temp=query(x,y,xx,yy,lx,midx,midy+1,ry,pos*4+1);\n        if(now==-1||temp<now)\n            now=temp;\n    }\n    if(xx>midx&&y<=midy)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,ly,midy,pos*4+2);\n        if(now==-1||temp<now)\n            now=temp;\n    }\n    if(xx>midx&&yy>midy)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,midy+1,ry,pos*4+3);\n        if(now==-1||temp<now)\n            now=temp;\n    }\n    return now;\n}\n\nint main()\n{\n    int n,m,q,i,j,x,y,xx,yy;\n    while(scanf(\"%d%d%d\",&n,&m,&q)==3)\n    {\n        if(!n&&!m&&!q)\n            break;\n        memset(tree,-1,sizeof(tree));\n        for(i=1;i<=n;i++)\n            for(j=1;j<=m;j++)\n            {\n                scanf(\"%d\",&x);\n                build(i,j,x,1,n,1,m,1);\n            }\n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x,&y,&xx,&yy);\n            printf(\"%d\\n\",query(x+1,y+1,xx+1,yy+1,1,n,1,m,1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint vlog[1000010];\nint R, C, Q;\nvector<vector<vector<int> > > rmq;\nint grid[1000010];\n\ninline void setvalue(int r, int c, int v){ grid[r*C+c] = v; }\ninline int getvalue(int r, int c){ return grid[r*C+c]; }\n\nvoid rmq_build()\n{\n    rmq.clear();\n    for(int i = 0; i < R; i++){\n        rmq.push_back(vector<vector<int> >());\n        for(int k = 0; (1<<k)-1 < C; k++){\n            rmq[i].push_back(vector<int>());\n            for(int j = 0; j + (1<<k)-1 < C; j++){\n                rmq[i][k].push_back(k==0 ? getvalue(i, j) : min(rmq[i][k-1][j], rmq[i][k-1][j+(1<<k-1)]));\n            }\n        }\n    } \n}\n\ninline int rmq_query(int r, int c1, int c2)\n{\n    int k = vlog[c2-c1+1];\n    return min(rmq[r][k][c1], rmq[r][k][c2-(1<<k)+1]);\n}\n\nint main()\n{\n//    freopen(\"SchoolOfKillifish.in\",\"r\",stdin);\n    int r1, c1, r2, c2, v;\n    for(int i = 1; i <= 1000000; i++) vlog[i] = (int)log2((double)i);\n    while(~scanf(\"%d%d%d\", &R, &C, &Q)) {\n        bool rot = (R > C);\n        int rr = R, cc = C;\n        if(rot) swap(R, C);\n        for(int i = 0; i < rr; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\", &v);\n                if(rot) setvalue(j, i, v);\n                else setvalue(i, j, v);\n            }\n        }\n        rmq_build();\n        for(int i = 0; i < Q; i++) {\n            scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n            if(rot) swap(r1, c1), swap(r2, c2);\n            int v = 0x7fffffff;\n            for(int j = r1; j <= r2; j++)\n                v = min(v, rmq_query(j, c1, c2));\n            printf(\"%d\\n\", v);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int N;\n  vector<int> data;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n  void clear() {\n    data.clear();\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n  void clear() {\n    for(int i = 0; i < SQRT_N * K; ++i) data[i].clear();\n    for(int i = 0; i < K; ++i) stat[i].clear();\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    bool doswap = false;\n    if(H > W) {\n      doswap = true;\n      swap(H, W);\n    }\n    Grid g;\n    if(doswap) {\n      REP(y,W) REP(x,H) {\n        int v; cin >> v;\n        g.update(x, y, v);\n      }\n    }\n    else {\n      REP(y,H) REP(x,W) {\n        int v; cin >> v;\n        g.update(y, x, v);\n      }\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      if(doswap) {\n        swap(x1, y1);\n        swap(x2, y2);\n      }\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(r);\n    int cs=sqrt(c);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&i+rs<=b+1&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a-1)*(b+m-1)>6300000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  void update(int k, int x){\n    k += N - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b){\n    return query(a, b, 0, 0, N);\n  }\n  inline int query(int a, int b, int k, int l, int r){\n    if(b <= l || r <= a) return INF;\n    else if(a <= l && r <= b){\n      return data[k];\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int x = x1; x <= x2; x++){\n          res = min(res, rmq[x].query(y1, y2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y, int* grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void destroy();\nprivate:\n  Node* build(int* grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void destroy(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y, int* grid) {\n  size_y_ = y;\n  size_x_ = x;\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(int* grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y * size_x_ + low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Delte nodes.\nvoid SegmentTree::destroy() {destroy(root_);}\nvoid SegmentTree::destroy(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) destroy(node->child[i]);\n  delete node;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    int grid[r * c];\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) cin >> grid[c * y + x];\n    SegmentTree tree(c, r, grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.destroy();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 1 == r&&u + 1 == d) {\n\t\t\tminnum = vs[u][l];\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd)return minnum;\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvector<vector<int>>vs(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconst type INIT = 0xfffffff;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tconst vector<type>& data() const {\n\t\treturn dat;\n\t}\n\n\tvoid merge(const segment_tree& s) {\n\t\tconst vector<type>& tmp = s.data();\n\t\tif(dat.size() != tmp.size()) return;\n\t\tfor(int i = 0; i < (int)dat.size(); ++i) {\n\t\t\tdat[i] = function(dat[i], tmp[i]);\n\t\t}\n\t}\n};\n\nclass segment_tree_2d {\nprivate:\n\tint n;\n\tvector<segment_tree> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int r1, int r2, int c1, int c2, int k, int l, int r) const {\n\t\tif(r <= r1 || r2 <= l)\n\t\t\treturn INIT;\n\n\t\tif(r1 <= l && r <= r2) {\n\t\t\treturn dat[k].query(c1, c2);\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(r1, r2, c1, c2, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(r1, r2, c1, c2, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree_2d(int r, int c) {\n\t\tn = 1;\n\t\twhile(n < r) n *= 2;\n\t\tdat.resize(2 * n - 1, segment_tree(c));\n\t}\n\n\tinline void update(int y, int x, type a) {\n\t\ty += n - 1;\n\t\tdat[y].update(x, a);\n\n\t\twhile(y > 0) {\n\t\t\tconst int child = y;\n\t\t\ty = (y - 1) / 2;\n\t\t\tdat[y].merge(dat[child]);\n\t\t}\n\t}\n\n\tinline type query(int r1, int r2, int c1, int c2) const {\n\t\treturn query(r1, r2, c1, c2, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q, r;) {\n\t\tsegment_tree_2d seg(r, c);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tseg.update(i, j, in);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[y2/B]&&y2%B!=0)y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[x2/B]&&x2%B!=0)x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int MAXN = 1000005;\nlong long map[MAXN];\nint main()\n{\n\tlong long Mina;\n\tint i, j, r, c1, q;\n\tint a, b, c, d;\n\twhile( cin >> r >> c1 >> q ) {\n\t\tif( r == 0 && c == 0 && q == 0 )\n\t\t\tbreak;\n\t\tfor( i = 0 ; i < r ; ++i ) {\n\t\t\tfor( j = 0 ; j < c1 ; ++j ) {\n\t\t\t\tscanf( \"%lld\" , &map[i*c1+j] );\n\t\t\t}\n\t\t}\n\t\twhile( q -- ) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tMina = map[a*c1+b];\n\t\t\tfor( i = a ; i <= c ; ++ i ) {\n\t\t\t\tfor( j = b + 1 ; j <= d ; ++j ) {\n\t\t\t\t\tif( map[i*c1+j] < min )\n\t\t\t\t\t\tMina = map[i*c1+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf( \"%lld\\n\" , Mina );\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint abs(int a,int b){\n\n  int result;\n\n  if(a<b)\n    result=b-a;\n  else\n    result=a-b;\n  return result;\n};\n\nint main(void){\n\n  int n;\n  int min=1000000;\n  int  temp;\n\n  vector <int> student(1001);\n  \n  while(cin >> n,n!=0){\n\n    for(int i=0;i<n;i++){\n      cin >> student[i];\n    }\n\n    sort(student.begin(),student.end(),greater<int>());\n\n    for(int i=0;i<n;i++){\n      \n      temp=abs(student[i],student[i+1]);\n      //cout << temp <<endl;\n\n      if(min>temp)\n\tmin=temp;\n    }\n\n    cout << min <<endl;\n\n    student.clear();\n    min=1000000;\n\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<short> vint;\nclass segtree{\n\tpublic:\n\tint w,h;\n\tvector<vint> data;\n\tsegtree(int h_,int w_){\n\t\tw=h=1;\n\t\twhile(w<w_)\tw<<=1;\n\t\twhile(h<h_)\th<<=1;\n\t\tdata.assign(2*h-1,vint(2*w-1,SHRT_MAX));\n\t}\n\tvoid update(){\n\t\tfor(int i=2*h-2;i>h-2;i--){\n\t\t\tfor(int j=w-2;j>=0;j--){\n\t\t\t\tdata[i][j]=min(data[i][2*j+1],data[i][2*j+2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tdata[i][j]=min(data[2*i+1][j],data[2*i+2][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint minw(int sw,int tw,int hh,int l,int r,int k){\n\t\tif(sw<=l&&r<=tw)\treturn data[hh][k];\n\t\tif(r<=sw||tw<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minw(sw,tw,hh,l,mid,2*k+1),minw(sw,tw,hh,mid,r,2*k+2));\n\t}\n\tint minh(int sh,int sw,int th,int tw,int l,int r,int k){\n\t\tif(sh<=l&&r<=th)\treturn minw(sw,tw,k,0,w,0);\n\t\tif(r<=sh||th<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minh(sh,sw,th,tw,l,mid,2*k+1),minh(sh,sw,th,tw,mid,r,2*k+2));\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint r,c,q;\tcin>>r>>c>>q;\n\t\tif(r+c+q==0)\treturn 0;\n\t\tsegtree seg(r,c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\tcin>>a;\n\t\t\t\tseg.data[i+seg.h-1][j+seg.w-1]=a;\n\t\t\t}\n\t\t}\n\t\tseg.update();\n\t\twhile(q--){\n\t\t\tint sh,sw,th,tw;\tcin>>sh>>sw>>th>>tw;\n\t\t\tcout<<seg.minh(sh,sw,th+1,tw+1,0,seg.h,0)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 9876543210\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct segtree{\n\tint SIZE;\n\tvector<ll> minimum, lazy;\n\n\tsegtree(int n){\n\t\tSIZE = 1;\n\t\twhile(SIZE < n) SIZE *= 2;\n\n\t\tminimum.clear();\n\t\tminimum.resize(SIZE * 2, 0LL);\n\t\tlazy.clear();\n\t\tlazy.resize(SIZE * 2, 0LL);\n\t};\n\n\tvoid lazy_evaluate(int k){\n\t\tminimum[k] += lazy[k];\n\n\t\tif (k < SIZE - 1){ // k isn't leaf of SegmentTree\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t} // end if\n\t\tlazy[k] = 0;\n\t} // end function\n\n\tvoid update(int a, int b, int k, int l, int r, ll x){\n\t\tif (r <= a || b <= l) return;\n\n\t\tif (a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazy_evaluate(k);\n\t\t}else{\n\t\t\tlazy_evaluate(k);\n\t\t\tupdate(a, b, k * 2 + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, k * 2 + 2, (l + r) / 2, r, x);\n\t\t\tminimum[k] = min(minimum[k * 2 + 1], minimum[k * 2 + 2]);\n\t\t\treturn;\n\t\t} // end if\n\t} // end function \n\n\tll query2D(int r1, int c1, int r2, int c2, int C){\n\t\tll res = INF;\n\t\tfor (int r = r1; r <= r2; ++r){\n\t\t\tll curr = query(r * C + c1, r * C + c2 + 1, 0, 0, SIZE);\n\t\t\tres = min(res, curr);\n\t\t} // end for\n\t\treturn res;\n\t} // end function \n\n\tll query(int a, int b, int k, int l, int r){\n\t\tlazy_evaluate(k);\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return minimum[k];\n\t\telse{\n\t\t\tll lch = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll rch = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\t\treturn min(lch, rch);\n\t\t} // end if\n\t} // end function\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint R, C, Q;\n\twhile(cin >> R >> C >> Q){\n\t\tsegtree seg(R*C);\n\n\t\tfor (int i = 0; i < R*C; ++i){\n\t\t\tll grid; cin >> grid;\n\t\t\tseg.update(i, i+1, 0, 0, seg.SIZE, grid);\n\t\t} // end for\n\n\t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2; cin >> r1 >> c1 >> r2 >> c2;\n\t\t\tll ans = seg.query2D(r1, c1, r2, c2, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j+B-1)/B*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j+B-1)/B*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i+B-1)/B*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i+B-1)/B*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nclass point\n{\npublic:\n\tint x;\n\tint y;\n\tpoint(){}\n\tpoint(int _x, int _y) : x(_x), y(_y) {}\n};\n\ntypedef pair<int, point> PIP;\ntypedef map<int, point> MIP;\n\nint r, c, q;\nint r1, r2, c1, c2;\nint grid;\n\nint main()\n{\n\tMIP m;\n\twhile( 1 )\n\t{\n\t\tcin >> r >> c >> q;\n\t\tif(r==0 && c==0 && q==0) break;\n\n\t\tm.clear();\n\t\tfor(int y=0; y<r; y++)\n\t\t{\n\t\t\tfor(int x=0; x<c; x++)\n\t\t\t{\n\t\t\t\tcin >> grid;\n\t\t\t\tm.insert(PIP(grid, point(x, y)));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<q; i++)\n\t\t{\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tMIP::iterator iter = m.begin();\n\t\t\twhile(iter != m.end())\n\t\t\t{\n\t\t\t\tint x = (*iter).second.x;\n\t\t\t\tint y = (*iter).second.y;\n\t\t\t\tif(x>=c1 && y>=r1 && x<=c2 && y<=r2)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\", (*iter).first);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++iter;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint tmp;\nvector< vector<int> > seg;\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(r>c){\n      seg.resize(c);\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++){\n\tseg[i].clear();\n\tfor(int j=0;j<2*n-1;j++)seg[i].push_back( (1<<31)-1 );\n      }\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  int k = i;\n\t  k += n-1;\n\t  seg[j][k] = tmp;\n\t  while(k>0){\n\t    k = (k-1) / 2;\n\t    seg[j][k] = min(seg[j][k*2+1], seg[j][k*2+2]);\n\t  }\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      seg.resize(r);\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++){\n\tseg[i].clear();\n\tfor(int j=0;j<2*n-1;j++)seg[i].push_back( (1<<31)-1 );\n      }\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  int k = j;\n\t  k += n-1;\n\t  seg[i][k] = tmp;\n\t  while(k>0){\n\t    k = (k-1) / 2;\n\t    seg[i][k] = min(seg[i][k*2+1], seg[i][k*2+2]);\n\t  }\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 1 == r&&u + 1 == d) {\n\t\t\tminnum = vs[u][l];\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd)return minnum;\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvector<vector<int>>vs(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = (1 << 22);\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int dat[MAX];    \n\n    int c(int i, int j)\n    {\n        return i * (2 * W - 1) + j;\n    }\n    \n    void init(int h, int w, vector<vector<int>>& grid)\n    {        \n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        \n        for (int i = 0; i < 2 * H - 1; i++) {        \n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[c(i, j)] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[c(i + H - 1, j + W - 1)] = grid[i][j];\n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[c(i, j)] = min(dat[c(i, j * 2 + 1)],\n                                   dat[c(i, j * 2 + 2)]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[c(j, i)] = min(dat[c(j * 2 + 1, i)],\n                                   dat[c(j * 2 + 2, i)]);\n            }\n        }\n    }\n\n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[c(j, k)];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nRMQ2D r;\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        r.init(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << r.query(y1, x1, y2, x2) << endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\ninline void init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\ninline void update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\ninline ll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/1068.test.cpp\"\n#define PROBLEM \"judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1068\"\n\n#include <iostream>\n#line 1 \"segment_tree/segment_tree2d.hpp\"\n#include <cassert>\n#include <vector>\n\n//===\n// memory: O(HW)\n// time: O(logH * logW)\ntemplate<class CommutativeMonoid>\nstruct SegmentTree2D {\n    using M = CommutativeMonoid;\n    using T = typename M::value_type;\n    const std::size_t H, W;\n    std::vector<std::vector<T>> tree;\n\n    SegmentTree2D(size_t H, size_t W):H(H), W(W) {\n        tree.assign(H << 1, std::vector<T>(W << 1, M::identity()));\n    };\n\n    void update(int sy, int sx, T dat) {\n        sy += H;\n        sx += W;\n        int ty, tx;\n        tree[sy][sx] = dat;\n        tx = sx;\n        while (tx > 1) {\n            tx >>= 1;\n            tree[sy][tx] = M::operation(tree[sy][(tx << 1)],\n                    tree[sy][(tx << 1) | 1]);\n        }\n\n        ty = sy;\n        while (ty > 1) {\n            ty >>= 1;\n            tx = sx;\n            tree[ty][tx] = M::operation(tree[(ty << 1)][tx],\n                    tree[(ty << 1) | 1][tx]);\n            while (tx > 1) {\n                tx >>= 1;\n                tree[ty][tx] = M::operation(tree[(ty << 1)][tx],\n                        tree[(ty << 1) | 1][tx]);\n            }\n        }\n    };\n\n    T fold(int sy, int sx, int ty, int tx) {\n        sy += H;\n        ty += H;\n\n        T ret = M::identity();\n        while (sy < ty) {\n            if (sy & 1) ret = M::operation(ret, fold_x(sy++, sx, tx));\n            if (ty & 1) ret = M::operation(fold_x(--ty, sx, tx), ret);\n            sy >>= 1;\n            ty >>= 1;\n        }\n        return ret;\n    };\n    T fold_x(int y, int l, int r) {\n        l += W;\n        r += W;\n        T ret = M::identity();\n        while (l < r) {\n            if (l & 1) ret = M::operation(ret, tree[y][l++]);\n            if (r & 1) ret = M::operation(tree[y][--r], ret);\n            l >>= 1;\n            r >>= 1;\n        }\n        return ret;\n    };\n\n    T at(int sy, int sx) const {\n        return tree[sy + H][sx + W];\n    };\n};\n//===\n#line 5 \"test/aoj/1068.test.cpp\"\n\nusing llong = long long;\nusing namespace std;\n\nstruct Monoid {\n    using value_type = llong;\n    using T = llong;\n\n    inline static T operation(T a, T b) {\n        return min(a, b);\n    };\n    inline static T identity() {\n        return (1ll << 50);\n    };\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    llong r, c, q;\n    llong gr;\n    llong sy, sx, ty, tx;\n\n    cin >> r >> c >> q;\n    while (r != 0 && c != 0 && q != 0) {\n        SegmentTree2D<Monoid> seg(r, c);\n        \n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                cin >> gr;\n                seg.update(i, j, gr);\n            }\n        }\n\n        for (int i = 0; i < q; i++) {\n            cin >> sy >> sx >> ty >> tx;\n\n            cout << seg.fold(sy, sx, ty + 1,  tx + 1) << '\\n';\n        }\n\n        /*\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                cout << seg.at(i, j) << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cin >> r >> c >> q;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int grid[N];\n  int rmq[N];\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    int bs_r = (int)sqrt(r), bs_c = (int)sqrt(c);\n    int bn_r = r/bs_r, bn_c = c/bs_c;\n    if(r%bs_r)bn_r++;\n    if(c%bs_c)bn_c++;\n \n    for(int i=0;i<bn_r;i++){\n      for(int j=0;j<bn_c;j++)rmq[i*bn_c + j] = (1<<31) -1;\n    }\n    \n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c + j];\n\trmq[(i/bs_r) * bn_c + (j/bs_c)] = min(rmq[(i/bs_r) * bn_c + (j/bs_c)],grid[i*c + j]);\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ans = (1<<31) -1;\n\n      int sr = r1/bs_r;\n      if(r1%bs_r){\n\tsr++;\n\tfor(int i=r1;i<sr*bs_r;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int sc = c1/bs_c;\n      if(c1%bs_c){\n\tsc++;\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<sc*bs_c;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gr = r2/bs_r;\n      if( (r2+1)%bs_r){\n\tfor(int i=gr*bs_r;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gc = c2/bs_c;\n      if( (c2+1)%bs_c){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=gc*bs_c;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      if(sr == gr || sc == gc){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n      }else{\n\n\tfor(int i=sr;i<=gr;i++){\n\t  for(int j=sc;j<=gc;j++){\n\t    ans = min(ans,rmq[i*bn_c+j]);\n\t  }\n\t}\n      }\n\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n#include<vector>\nusing namespace std;\n\n\nconst int maxn = 1000000*3;\n\nvector<int> A[ 1000009 ];\nint n;\nstruct node\n{\n    int x1,x2,y1,y2;\n    int min;\n    int ch[4];\n};\nnode tree[maxn];\n \nint tol;\n \nvoid maketree(int x1,int x2,int y1,int y2)\n{\n    int k = ++tol;\n    tree[k].x1 = x1;\n    tree[k].x2 = x2;\n    tree[k].y1 = y1;\n    tree[k].y2 = y2;\n    tree[k].min = 0;\n    if(x1 == x2 && y1==y2)\n    {\n        tree[k].min = A[x1][y1];\n        memset(tree[k].ch,0,sizeof(tree[k].ch));\n        return ;\n    }\n    \n    int midx = (x1+x2)>>1;\n    int midy = (y1+y2)>>1;\n    \n    tree[k].ch[0] = tol+1;\n    maketree(x1,midx,y1,midy); \n    \n    if(midx+1 <= x2 && midy+1 <= y2) \n    {\n        tree[k].ch[1] = tol+1;\n        maketree(midx+1,x2,midy+1,y2);\n    }\n    else\n        tree[k].ch[1] = 0;\n    \n    if(midy+1 <= y2)    \n    {\n        tree[k].ch[2] = tol+1;\n        maketree(x1,midx,midy+1,y2);\n    }\n    else\n        tree[k].ch[2] = 0;\n    \n \n    if(midx+1 <= x2)\n    {\n        tree[k].ch[3] = tol+1;\n        maketree(midx+1,x2,y1,midy);\n    }\n    else\n        tree[k].ch[3] = 0;\n        \n    tree[k].min =  tree[tree[k].ch[0]].min;\n    for(int i=1; i<4; i++)            \n        if(tree[k].ch[i])\n            tree[k].min = min(tree[k].min,tree[tree[k].ch[i]].min);\n}\n \ninline bool cross(int x1,int x2,int y1,int y2,int k)\n{\n    if(x2 < tree[k].x1 || tree[k].x2 < x1   ||  y2 < tree[k].y1 || tree[k].y2 < y1)\n        return false;\n    return true;\n}\n \nint Query(int x1,int x2,int y1,int y2,int k) \n{\n    if(cross(x1,x2,y1,y2,k) == 0)  \n        return INT_MAX;\n \n    if(x1 <= tree[k].x1 && tree[k].x2 <= x2 && y1<= tree[k].y1 && tree[k].y2 <= y2) \n        return tree[k].min;\n    int minx = Query(x1,x2,y1,y2,tree[k].ch[0]);\n \n    for(int i=1; i<4; i++)\n        minx = min(minx,Query(x1,x2,y1,y2,tree[k].ch[i]));\n    return minx;\n}\n\nint main()\n{\n    int r,c,q,temp;\n    int x1,y1,x2,y2;\n    while(( scanf( \"%d%d%d\",&r,&c,&q ),r ))\n    {\n        for( int i=1;i<=r;i++ ){\n            if( A[ i ].size(  )<=1 )\n                A[ i ].push_back( 0 );\n            for( int j=1;j<=c;j++ ){\n                scanf( \"%d\",&temp );\n                if( j>=A[ i ].size(  ) ){\n                    A[ i ].push_back( temp );\n                }\n                else{\n                    A[ i ][ j ]=temp;\n                }\n            }\n        }\n        tol=0;\n        maketree(1,r,1,c);        \n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n            x1++,y1++,x2++,y2++;\n            printf(\"%d\\n\",Query(x1,x2,y1,y2,1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=2100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\nconst int INF = (1LL << 31) - 1;\nint h, w;\nvector<vector<int> > g;\n\nvector<vector<int> > data;\nint size(int n)\n{\n    int m = 1;\n    while (m < n)\n        m *= 2;\n    return m;\n}\nvoid build_segtree()\n{\n    data.clear();\n    data.resize(2 * h - 1, vector<int>(2 * w - 1, INF));\n\n    // x\n    for (int y = 0; y < h; ++y)\n    {\n        const int i = y + (h - 1);\n\n        for (int x = 0; x < w; ++x)\n            data[i][x + (w - 1)] = g[y][x];\n\n        for (int k = w - 2; k >= 0; --k)\n            data[i][k] = min(data[i][2 * k + 1], data[i][2 * k + 2]);\n    }\n\n    // y\n    for (int i = h - 2; i >= 0; --i)\n        for (int j = 0; j < 2 * w - 1; ++j)\n            data[i][j] = min(data[2 * i + 1][j], data[2 * i + 2][j]);\n}\nint x_query(int y_k, int x1, int x2, int k, int l, int r)\n{\n    if (x2 <= l || r <= x1)\n        return INF;\n    else if (x1 <= l && r <= x2)\n        return data[y_k][k];\n\n    int mid = (l + r) / 2;\n    int lv = x_query(y_k, x1, x2, 2 * k + 1, l, mid);\n    int rv = x_query(y_k, x1, x2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint y_query(int x1, int x2, int y1, int y2, int k, int l, int r)\n{\n    if (y2 <= l || r <= y1)\n        return INF;\n    else if (y1 <= l && r <= y2)\n        return x_query(k, x1, x2, 0, 0, w);\n\n    int mid = (l + r) / 2;\n    int lv = y_query(x1, x2, y1, y2, 2 * k + 1, l, mid);\n    int rv = y_query(x1, x2, y1, y2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint main()\n{\n    fast_io();\n\n    int q;\n    while (cin >> h >> w >> q, h)\n    {\n        g.clear();\n        g.resize(size(h), vector<int>(size(w), INF));\n        for (int y = 0; y < h; ++y)\n            for (int x = 0; x < w; ++x)\n                cin >> g[y][x];\n        h = size(h);\n        w = size(w);\n\n        build_segtree();\n\n        while (q--)\n        {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            ++x2, ++y2;\n            cout << y_query(x1, x2, y1, y2, 0, 0, h) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = pow(2,31) - 1;\nint n;\nvoid powset(int size){\n  n = 1;\n  while( n < size ) n *= 2;\n}\n\nstruct RMQ{\n  vector< int > seg;\n  void update( int i, int x){\n    i += n - 1;\n    seg[i] = x;\n  }\n  void build(){\n    for(int i = n - 2; i >= 0; i--){\n      seg[i] = min( seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n  }\n  int query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) return seg[k];\n    int vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return min( vl, vr);\n  }\n  int query( int a, int b){\n    return query( a, b, 0, 0, n);\n  }\n  RMQ(){\n    seg.assign( n * 2, INF);\n  }\n};\n\nint main(){\n  int R, C, Q;\n  while(scanf(\"%d %d %d\", &R, &C, &Q), R){\n    if(R < C){\n      powset(C);\n      vector< RMQ > rmq( R, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\", &grid);\n          rmq[i].update(j,grid);\n        }\n        rmq[i].build();\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = r1; i <= r2; i++){\n          ret = min( ret, rmq[i].query( c1, c2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }else{\n      powset(R);\n      vector< RMQ > rmq( C, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\",&grid);\n          rmq[j].update(i,grid);\n        }\n        rmq[i].build();\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = c1; i <= c2; i++){\n          ret = min( ret, rmq[i].query( r1, r2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SegmentTree2D\n{\n  int H, W;\n  vector< vector<int> > data;\n  SegmentTree2D(){}\n  SegmentTree2D(const vector< vector<int> > &f)\n  {\n    H = W = 1;\n    while(H < (int)f.size()) H <<= 1;\n    while(W < (int)f[0].size()) W <<= 1;\n    data.resize(2*H-1, vector<int>(2*W-1, inf));\n    init(f);\n  }\n  void init(const vector< vector<int> > &f)\n  {\n    for(int i = 0; i < (int)f.size(); i++)\n      for(int j = 0; j < (int)f[i].size(); j++)\n\tdata[i+H-1][j+W-1] = f[i][j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i][j] = min(data[i][2*j+1], data[i][2*j+2]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i][j] = min(data[2*i+1][j], data[2*i+2][j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i][k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nvector< vector<int> > grid;\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    grid.clear(); grid.resize(r, vector<int>(c));\n    rep(i, r) rep(j, c) cin >> grid[i][j];\n\n    segT = SegmentTree2D(grid);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y1][j]);\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y2][j]);\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i)mi=min(mi,fld[i][x1]);\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i)mi=min(mi,fld[i][x2]);\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            for(int j=bx1;j<bx2;++j)\n                mi=min(mi,bucket[by1][j]);\n\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < MAX_N*4; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tfast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n//\tvector<int> seg;\n\tint *seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = (int*)malloc(sizeof(int) * (nodeSize+segSize));\n\t\tfill(&seg[0], &seg[0]+nodeSize+segSize, INF);\n//\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\treturn seg[n];\n//\t\tif (n < (int)seg.size()) return seg[n];\n//\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tseg[n] = v;\n//\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\tfree(seg);\n\t\t//seg.clear();\n\t\t//seg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tint *m = (int*)malloc(sizeof(int) * W*H);\n//\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y*W+x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y*W+x]);\n\t\t\t\telse seg[x].update(y, m[y*W+x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\nconst int INF = (1LL << 31) - 1;\nint h, w;\n// vector<vector<int> > g;\nvector<int> g[1024];\n\n// vector<vector<int> > data;\nvector<int> data[2 * 1024];\nint size(int n)\n{\n    int m = 1;\n    while (m < n)\n        m *= 2;\n    return m;\n}\nvoid build_segtree()\n{\n    for (int i = 0; i < 2 * h - 1; ++i)\n    {\n        data[i].clear();\n        data[i].resize(2 * w - 1, INF);\n    }\n\n    // x\n    for (int y = 0; y < h; ++y)\n    {\n        const int i = y + (h - 1);\n\n        for (int x = 0; x < w; ++x)\n            data[i][x + (w - 1)] = g[y][x];\n\n        for (int k = w - 2; k >= 0; --k)\n            data[i][k] = min(data[i][2 * k + 1], data[i][2 * k + 2]);\n    }\n\n    // y\n    for (int i = h - 2; i >= 0; --i)\n        for (int j = 0; j < 2 * w - 1; ++j)\n            data[i][j] = min(data[2 * i + 1][j], data[2 * i + 2][j]);\n}\nint x_query(int y_k, int x1, int x2, int k, int l, int r)\n{\n    if (x2 <= l || r <= x1)\n        return INF;\n    else if (x1 <= l && r <= x2)\n        return data[y_k][k];\n\n    int mid = (l + r) / 2;\n    int lv = x_query(y_k, x1, x2, 2 * k + 1, l, mid);\n    int rv = x_query(y_k, x1, x2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint y_query(int x1, int x2, int y1, int y2, int k, int l, int r)\n{\n    if (y2 <= l || r <= y1)\n        return INF;\n    else if (y1 <= l && r <= y2)\n        return x_query(k, x1, x2, 0, 0, w);\n\n    int mid = (l + r) / 2;\n    int lv = y_query(x1, x2, y1, y2, 2 * k + 1, l, mid);\n    int rv = y_query(x1, x2, y1, y2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint main()\n{\n    fast_io();\n\n    int _h, _w, q;\n    while (cin >> _h >> _w >> q, _h)\n    {\n        h = size(_h), w = size(_w);\n        bool swawa = false;\n        if (_h > _w)\n        {\n            swawa = true;\n            swap(w, h);\n        }\n        for (int i = 0; i < h; ++i)\n        {\n            g[i].clear();\n            g[i].resize(w, INF);\n        }\n        for (int y = 0; y < _h; ++y)\n        {\n            for (int x = 0; x < _w; ++x)\n            {\n                if (!swawa)\n                    cin >> g[y][x];\n                else\n                    cin >> g[x][y];\n            }\n        }\n\n        build_segtree();\n\n        while (q--)\n        {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            ++x2, ++y2;\n            if (swawa)\n            {\n                swap(x1, y1);\n                swap(x2, y2);\n            }\n            cout << y_query(x1, x2, y1, y2, 0, 0, h) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\n\n\n\nclass MinSegmentTree {\n\tstd::vector<std::vector<int>> vec;\n\tint inner_min(int depth, int from, int until) const {\n\t\tif (from == until) return INT_MAX;\n\t\tint length = 1 << depth;\n\t\tint mid = (from + length - 1) / length * length;\n\t\tif (mid + length <= until) {\n\t\t\treturn std::min({ inner_min(depth, from, mid), inner_min(depth, mid + length, until), vec[depth][mid / length] });\n\t\t}\n\t\telse if (mid < until) {\n\t\t\treturn std::min({ inner_min(depth - 1, from, mid), inner_min(depth - 1, mid, until) });\n\t\t}\n\t\telse {\n\t\t\treturn inner_min(depth - 1, from, until);\n\t\t}\n\t}\npublic:\n\tMinSegmentTree(const std::vector<int>& initial) : vec{ initial } {\n\t\twhile (vec.back().size() > 1) {\n\t\t\tvec.emplace_back(vec.back().size() / 2);\n\t\t}\n\t\tfor (auto i = 1; i < vec.size(); ++i) {\n\t\t\tfor (auto j = 0; j < vec[i].size(); ++j) {\n\t\t\t\tvec[i][j] = std::min(vec[i - 1][j * 2], vec[i - 1][j * 2 + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tint min_of(int from, int until) const {\n\t\treturn inner_min(vec.size() - 1, from, until);\n\t}\n};\nint main() {\n\twhile (true) {\n\t\tint r, c, q; std::cin >> r >> c >> q; if (r == 0 && c == 0 && q == 0) return 0;\n\t\tstd::vector<std::vector<int>> grid(std::min(r, c), std::vector<int>(std::max(r, c)));\n\t\tfor (auto i = 0; i < r; ++i) for (auto j = 0; j < c; ++j) {\n\t\t\tif (r <= c) std::cin >> grid[i][j];\n\t\t\telse std::cin >> grid[j][i];\n\t\t}\n\t\tstd::vector<MinSegmentTree> seg; for (const auto& g : grid) seg.emplace_back(g);\n\t\tfor (auto i = 0; i < q; ++i) {\n\t\t\tint left, right, top, bottom;\n\t\t\tif (r <= c) std::cin >> top >> left >> bottom >> right;\n\t\t\telse std::cin >> left >> top >> right >> bottom;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (auto i = top; i <= bottom; ++i) {\n\t\t\t\tmin = std::min(seg[i].min_of(left, right + 1), min);\n\t\t\t}\n\t\t\tstd::cout << min << std::endl;\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\n\t\tbool is_reverse = r > c;\n\t\tvector<seg_tree<ll>> segs(min(r,c), seg_tree<ll>(max(r,c)));\n\t\tREP(i, r) REP(j, c) {\n\t\t\tll x = i, y = j;\n\t\t\tif (is_reverse) swap(x, y);\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tif (is_reverse) swap(x_1, y_1), swap(x_2, y_2);\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INT_MAX;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return min(vl,vr);\n}\nint r,cc,q,t;\n\nint main(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        int a,b,c,d;\n        init(r,cc);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct Pool {\n    static dat_t dat[250000*3];\n    static int size;\n    static dat_t * fetch(int len){\n        dat_t * res = dat + size;\n        size+=len;\n        return res;\n    }\n    static void reset(){\n        size = 0;\n    }\n};\n\nint Pool::size = 0;\ndat_t Pool::dat[250000*3];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, vector<int> a){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n, INT_MAX);\n            for(int i = n; i < n + n_; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w) f = true;\n        if(f) swap(h, w);\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j + 1, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            a.second++; b.second++;\n            if(f){\n                swap(a.first, a.second);\n                swap(b.first, b.second);\n            }\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 20;\nconst int INF = INT_MAX;\n\nint r, c;\nint w, h;\nint seg[8 * MAX_N];\n\nvoid init()\n{\n\tfor (w = 1; w < r; w <<= 1);\n\tfor (h = 1; h < c; h <<= 1);\n\tfill_n(seg, 8 * MAX_N, INF);\n}\n\nvoid update(int x, int y, int v, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (x < ax || bx <= x) return;\n\tif (y < ay || by <= y) return;\n\t\n\tif (bx - ax == 1 && by - ay == 1){\n\t\tseg[k] = v;\n\t\treturn;\n\t}\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\tseg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\n\t//printf(\"seg[%d] = %d\\n\", k, seg[k]);\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n}\n\nint getMin(int lx, int ly, int rx, int ry, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (rx <= ax || bx <= lx) return INF;\n\tif (ry <= ay || by <= ly) return INF;\n\tif (lx <= ax && bx <= rx && ly <= ay && by <= ry) return seg[k];\n\t\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tint vl, vr;\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\treturn min(vl, vr);\n}\n\nint main()\n{\n\tint q;\n\twhile (scanf(\"%d %d %d\", &r, &c, &q), r|c|q){\n\t\tinit();\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tint v;\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\tupdate(i, j, v);\n\t\t\t}\n\t\t}\n\t\twhile (q--){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", getMin(r1, c1, ++r2, ++c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 2\n\nstruct SegTree {\nint segSize, realSegSize, nodeSize;\n int sz;\n int *seg;\nvoid init(int n) {\nrealSegSize = n;\n\nnodeSize = 0;\nfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n  sz = nodeSize+n;\n  seg = new int[sz];\n  for(int i = 0 ; i < sz ; i++) seg[i] = INF;\n}\n\nint get(int n) {\nif (n < sz) return seg[n];\nelse return INF;\n}\nvoid set(int n, int v) {\nif (n < sz) seg[n] = v;\n}\n\nvoid update(int pos, int val) {\nint n = nodeSize + pos;\nset(n, val);\nwhile (n) {\nn = (n-1)/D;\n\nint r = INF;\nfor (int i = 0; i < D; ++i) {\nr = min(r, seg[n*D+i+1]);\n}\nset(n, r);\n}\n}\nint get(int n, int l, int r, int L, int R) {\n// cout << n << \" \" << l << \" \" << r << endl;\nif (L <= l && r <= R) return get(n);\nelse if (R <= l || r <= L) return INF;\nelse {\nint ret = INF;\nint prev = l;\nfor (int i = 0; i < D; ++i) {\nint next = i == D-1 ? r : prev + (r-l)/D;\nret = min(ret, get(n*D+i+1, prev, next, L, R));\nprev = next;\n}\nreturn ret;\n}\n}\nint get(int L, int R) {\nreturn get(0, 0, segSize, L, R);\n}\n\n~SegTree() {\n  \t\tdelete seg;\n}\n};\n\nstruct Query {\nint y1, x1, y2, x2;\n};\n\nint main() {\nint H, W, Q;\nwhile ( cin >> H >> W >> Q, H || W || Q ) {\nvector< vector<int> > m(H, vector<int>(W, 0));\n\nfor (int y = 0; y < H; ++y) {\nfor (int x = 0; x < W; ++x) {\ncin >> m[y][x];\n}\n}\n\nbool isSegRow = H < W;\nvector<SegTree*> seg;\n\nif (isSegRow) {\nseg.resize(H);\nfor (int y = 0; y < H; ++y) {\nseg[y] = new SegTree();\n    seg[y]->init(W);\n}\n}\nelse {\nseg.resize(W);\nfor (int x = 0; x < W; ++x) {\nseg[x] = new SegTree();\n    seg[x]->init(H);\n}\n}\n\nfor (int y = 0; y < H; ++y) {\nfor (int x = 0; x < W; ++x) {\nif (isSegRow) seg[y]->update(x, m[y][x]);\nelse seg[x]->update(y, m[y][x]);\n}\n}\n\nfor (int t = 0; t < Q; ++t) {\nint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\nint ans = INF;\nif (isSegRow) {\nfor (int y = y1; y <= y2; ++y) {\nans = min(ans, seg[y]->get(x1, x2+1));\n}\n}\nelse {\nfor (int x = x1; x <= x2; ++x) {\nans = min(ans, seg[x]->get(y1, y2+1));\n}\n}\ncout << ans << endl;\n}\n  for(int i = 0 ; i < seg.size() ; i++) delete seg[i];\n\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define la (rt*4)\n#define lb (rt*4+1)\n#define lc (rt*4+2)\n#define ld (rt*4+3)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\n\nint r, c, q;\n\nstruct seg\n{\n    int x1,y1,x2,y2;\n    int v;\n    int midx()\n    {\n        return (x1+x2)>>1;\n    }\n    int midy()\n    {\n        return (y1+y2)>>1;\n    }\n}tr[1000010*5];\nint map[1000010];\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1==x2 && y1==y2)\n    {\n        tr[rt].v = map[x1*c + y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n    }\n    else if(y1 == y2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n    }\n    else\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n    }\n    return;\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1)\n    {\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx)\n    {\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my)\n    {\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx)\n    {\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my)\n    {\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q)\n    {\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                scanf(\"%d\",&map[i*c + j]);\n\n   /*     build(1,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i)\n        {\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(1,a,b,c,d));\n        }\n    } */\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : School.cpp\n// Author      : alpc92\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define REP(i,n) for(int i(0);i<((int)n);++i)\n#define FOR(i,l,h) for(int i((int)l);i<=((int)h);++i)\n#define FORD(i,h,l) for(int i((int)h);i>=((int)l);--i)\n#define CLEAR(arr,k) memset(arr,k,sizeof(arr))\n#define SZ (STL) (int)STL.size();\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nvector<vector<vector<int> > >f;\nint n, m, q;\nint ch(int rr, int cc) {\n\treturn rr * m + cc;\n}\nint shl(int a) {\n\treturn 1 << a;\n}\nint mylog(int a) {\n\treturn floor(log(double(a)) / log(2.0));\n}\nvoid rmq(void) {\n\tint w = mylog(m), h = mylog(n);\n\tfor (int i = 0; i <= w; i++)//width\n\t{\n\t\tfor (int j = 0; j <= h; j++)//height\n\t\t{\n\t\t\tif (i == 0 && j == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int ii = 0; (ii + shl(j)) <= n; ii++) {\n\t\t\t\tfor (int jj = 0; (jj + shl(i)) <= m; jj++) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\tf[ch(ii, jj)][i][j] = min(f[ch(ii, jj)][i][j - 1],\n\t\t\t\t\t\t\t\tf[ch(ii + shl(j - 1), jj)][i][j - 1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[ch(ii, jj)][i][j] = min(f[ch(ii, jj)][i - 1][j],\n\t\t\t\t\t\t\t\tf[ch(ii, jj + shl(i - 1))][i - 1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint x1, y1, x2, y2;\n\twhile (scanf(\"%d %d %d\", &n, &m, &q), n || m || q) {\n\t\tint hh(mylog(n)), ww(mylog(m));\n\t\tf.clear();\n\t\tf.resize((m+1)*(n+1));\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint loc = ch(i, j);\n\t\t\t\tf[loc].resize(ww + 1);\n\t\t\t\tREP(k,f[loc].size())\n\t\t\t\t\tf[loc][k].resize(hh + 1);\n\t\t\t\tscanf(\"%d\", &f[loc][0][0]);\n\t\t\t}\n\t\t}\n\t\trmq();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tint h, w;\n\t\t\th = mylog(x2 - x1 + 1);\n\t\t\tw = mylog(y2 - y1 + 1);\n\t\t\t//printf(\"%d %d\\n\",h,w);\n\t\t\tint ans = min(\n\t\t\t\t\tmin(f[ch(x1, y1)][w][h], f[ch(x1, y2 - shl(w) + 1)][w][h]),\n\t\t\t\t\tmin(f[ch(x2 - shl(h) + 1, y1)][w][h],\n\t\t\t\t\t\t\tf[ch(x2 - shl(h) + 1, y2 - shl(w) + 1)][w][h]));\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nvector<vi> seg;\nint n;\nvoid init(int y, int x)\n{\n\tn = 1;\n\twhile (n < x)n *= 2;\n\n\tvi a(2*n-1, INT_MAX);\n\tFOR(i, y)seg.push_back(a);\n}\n\nvoid update(int y, int k, int a)\n{\n\tk += n - 1;\n\tseg[y][k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tseg[y][k] = min(seg[y][k * 2 + 1], seg[y][k * 2 + 2]);\n\t}\n}\n\nint getMin(int y, int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return INT_MAX;\n\tif (a <= l&&r <= b)return seg[y][k];\n\treturn min(getMin(y, a, b, k * 2 + 1, l, (l + r) / 2), getMin(y, a, b, k * 2 + 2, (l + r) / 2, r));\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tseg.clear();\n\t\tint y, x, q;\n\t\tbool swp = false;\n\t\tcin >> y >> x >> q;\n\t\tif (!y)break;\n\t\tif (y > x)swp = true;\n\n\t\tif (swp)init(x, y);\n\t\telse init(y, x);\n\t\tFOR(i, y)\n\t\t{\n\t\t\tFOR(j, x)\n\t\t\t{\n\t\t\t\tINT(v);\n\t\t\t\tif (swp)update(j,i,v);\n\t\t\t\telse update(i, j, v);\n\t\t\t}\n\t\t}\n\t\tFOR(i, q)\n\t\t{\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = INT_MAX;\n\t\t\tif (swp)\n\t\t\t{\n\t\t\t\tfor (int j = c1; j <= c2; j++)\n\t\t\t\t{\n\t\t\t\t\tans = min(ans, getMin(j, r1, r2 + 1, 0, 0, n));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j = r1; j <= r2; j++)\n\t\t\t\t{\n\t\t\t\t\tans = min(ans, getMin(j, c1, c2 + 1, 0, 0, n));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tint dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INT_MAX;\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INT_MAX;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tst.Update(serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tint ans=INF;\n\t\tREP(y,r[0],r[1]+1) ans=min(ans,st.Query(serialize(y,c[0],C),serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : School.cpp\n// Author      : alpc92\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define REP(i,n) for(int i(0);i<((int)n);++i)\n#define FOR(i,l,h) for(int i((int)l);i<=((int)h);++i)\n#define FORD(i,h,l) for(int i((int)h);i>=((int)l);--i)\n#define CLEAR(arr,k) memset(arr,k,sizeof(arr))\n#define SZ (STL) (int)STL.size();\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nint ***f;\nint n, m, q;\nint ch(int rr, int cc) {\n\treturn rr * m + cc;\n}\nint shl(int a) {\n\treturn 1 << a;\n}\nint mylog(int a) {\n\treturn floor(log(double(a)) / log(2.0));\n}\nvoid rmq(void) {\n\tint w = mylog(m), h = mylog(n);\n\tfor (int i = 0; i <= w; i++)//width\n\t{\n\t\tfor (int j = 0; j <= h; j++)//height\n\t\t{\n\t\t\tif (i == 0 && j == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int ii = 0; (ii + shl(j)) <= n; ii++) {\n\t\t\t\tfor (int jj = 0; (jj + shl(i)) <= m; jj++) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\tf[ch(ii, jj)][i][j] = min(f[ch(ii, jj)][i][j - 1],\n\t\t\t\t\t\t\t\tf[ch(ii + shl(j - 1), jj)][i][j - 1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[ch(ii, jj)][i][j] = min(f[ch(ii, jj)][i - 1][j],\n\t\t\t\t\t\t\t\tf[ch(ii, jj + shl(i - 1))][i - 1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint x1, y1, x2, y2;\n\twhile (scanf(\"%d %d %d\", &n, &m, &q), n || m || q) {\n\t\tint hh(mylog(n)), ww(mylog(m));\n\t\tf = new int **[(m+1)*(n+1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint loc = ch(i, j);\n\t\t\t\tf[loc] = new int *[ww+1];\n\t\t\t\tREP(k,ww+1)\n\t\t\t\t\tf[loc][k] = new int [hh+1];\n\t\t\t\tscanf(\"%d\", &f[loc][0][0]);\n\t\t\t}\n\t\t}\n\t\trmq();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tint h, w;\n\t\t\th = mylog(x2 - x1 + 1);\n\t\t\tw = mylog(y2 - y1 + 1);\n\t\t\t//printf(\"%d %d\\n\",h,w);\n\t\t\tint ans = min(\n\t\t\t\t\tmin(f[ch(x1, y1)][w][h], f[ch(x1, y2 - shl(w) + 1)][w][h]),\n\t\t\t\t\tmin(f[ch(x2 - shl(h) + 1, y1)][w][h],\n\t\t\t\t\t\t\tf[ch(x2 - shl(h) + 1, y2 - shl(w) + 1)][w][h]));\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint segtree[12000000];\nint n,m;\nint H;\n/*int query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}*/\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[(i-1)*H+j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\n/*void update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}*/\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[(a-1)*H+d-1]=max(segtree[(a-1)*H+d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tH=m+b-1;\n\t/*\tif((n+a-1)*(b+m-1)>1200000){\n\t\t\t//segtree=new int*[a];\n\t\t\t//for(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{*/\n\t\t//\tsegtree=new int*[n+a-1];\n\t\t//\tfor(int i=0;i<n+a-1;i++){\n\t\t//\t\tsegtree[i]=new int[m+b-1];\n\t\t//\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t//\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<(n+a-1)*(m+b-1);i++)segtree[i]=0;\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t//\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t//\tdelete[] segtree;\n\t\t//}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W, W_;\nint y1, x1, y2, x2, g[2000000];\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y*W_ + x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tW_ = 2*W - 1;\n\t\trep(i, (2*H-1) * (2*W-1)) g[i] = inf;\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", g + (i+H-1) * W_ + j+W-1);\n\t\t\n\t\tfor(int i = 2*H - 2; i >= 0; i--){\n\t\t\tfor(int j = 2*W - 2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(min(g[(i*2+1) * W_ + j*2 + 1], g[(i*2+2) * W_ + j*2+2]),\n\t\t\t\t\t\tmin(g[(i*2+2) * W_ + j*2+1], g[(i*2+1) * W_ + j*2+2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[(i*2 + 1) * W_ + j], g[(i*2 + 2) * W_ + j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[i * W_ + j*2+1], g[i * W_ + j*2+2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nvector<vector<int>>vs;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 11>=r&&u + 11>= d) {\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (nl + 11 >= nr&&nu + 11 >= nd) {\n\t\t\tint ans = 2147483647;\n\t\t\tfor (int x = max(ql,nl); x < min(qr,nr); ++x) {\n\t\t\t\tfor (int y = max(qu,nu); y < min(qd,nd); ++y) {\n\t\t\t\t\tans = min(ans, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd) {\n\t\t\t\n\t\t\treturn minnum;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvs.clear();\n\t\tvs = vector<vector<int>>(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    // Å¬lðÔ·\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                //cin>>t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            //cin>>a>>b>>c>>d;\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",(int)res);\n            //cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<25;\n\tstatic lli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nlli SegmentTree::dat[2*MAX_N-1];\n\nclass SegmentTree_{\n\tprivate:\n\tstatic const int MAX_N=1<<25;\n\tstatic lli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nlli SegmentTree_::dat[2*MAX_N-1];\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint Serialize_(const int y,const int x,const int h){\n\treturn y+x*h;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tSegmentTree_ st_;\n\tst.Init(R*C);\n\tst_.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t\tst_.Update(Serialize_(y,x,R),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tif(r[1]-r[0]<c[1]-c[0]) REP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\telse REP(x,c[0],c[1]+1) ans=Cmin(ans,st_.Query(Serialize_(r[0],x,R),Serialize_(r[1]+1,x,R),0,0,st_.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 9876543210\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvector<vector<ll> > dat;\nint R, C;\n\nvoid update(int r, int c, ll x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(cc > 0){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nll query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tll v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tll v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tll v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tll v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tdat.clear();\n\t\tdat.resize(R * 2 - 1, vector<ll>(C * 2 - 1, INF));\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tll x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tll ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tvector<T> a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector<T> &v):n(1){\n\t\tint N=v.size();\n\t\twhile(n<N) n<<=1;\n\t\ta=vector<T>(2*n-1);\n\t\trep(i,N) a[n+i-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a1(h,vi(w)),a2(w,vi(h));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a1[i][j]), a2[j][i]=a1[i][j];\n\n\t\tvector< RMQ<int> > rmq1(h);\n\t\tvector< RMQ<int> > rmq2(w);\n\t\trep(i,h) rmq1[i]=RMQ<int>(a1[i]);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a2[j]);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\n\nint data[1 << 23];\nint v[1 << 20];\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT Find(int i, int lj, int rj) {\n\t\tlj += w, rj += w + 1;\n\t\tT res = id;\n\t\twhile (lj < rj) {\n\t\t\tif (lj & 1) res = merge(res, data[i * w * 2 + lj++]);\n\t\t\tif (rj & 1) res = merge(res, data[i * w * 2 + --rj]);\n\t\t\tlj >>= 1, rj >>= 1;\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), w(size(w_)), id(id_), merge(merge_) {\n\t\tfill(data, data + (1 << 23), id);\n\t\tfor (int i = 0; i < h_; i++)\n\t\t\tfor (int j = 0; j < w_; j++)\n\t\t\t\tdata[(h + i) * w * 2 + w + j] = v[i * w_ + j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n\t}\n\tvoid Update(int pi, int pj, T val) {\n\t\tpi += h;\n\t\tpj += w;\n\t\tdata[pi * w * 2 + pj] = val;\n\t\tint tj = pj;\n\t\twhile (tj >>= 1) {\n\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t}\n\t\twhile (pi >>= 1) {\n\t\t\tdata[pi * w * 2 + pj] = merge(data[(pi * 2) * w * 2 + pj], data[(pi * 2 + 1) * w * 2 + pj]);\n\t\t\ttj = pj;\n\t\t\twhile (tj >>= 1) {\n\t\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\tli += h, ri += h + 1;\n\t\tT res = id;\n\t\twhile (li < ri) {\n\t\t\tif (li & 1) res = merge(res, Find(li++, lj, rj));\n\t\t\tif (ri & 1) res = merge(res, Find(--ri, lj, rj));\n\t\t\tli >>= 1, ri >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i * c + j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//40\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF ((1<<31)^~0)\n#define N 1024\n\nint d[1000][2*N-1];\n\nint que(int *d,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return INF;\n  }else if(a<=l&&r<=b){\n    return d[k];\n  }else{\n    return min(que(d,a,b,k*2+1,l,(l+r)/2)\n\t       ,que(d,a,b,k*2+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > g;\n    bool w=r<c;\n    if(w){\n      g=vector<vector<int> >(r,vector<int>(c));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[i][j];\n\t}\n      }\n    }else{\n      g=vector<vector<int> >(c,vector<int>(r));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[j][i];\n\t}\n      }\n      swap(r,c);\n    }\n    int cc;\n    for(cc=1;cc<c;cc*=2);\n    fill(d[0],d[r+1],INF);\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tint k=j+cc-1;\n\td[i][k]=g[i][j];\n\twhile(k>0){\n\t  k=(k-1)/2;\n\t  d[i][k]=min(d[i][k*2+1],d[i][k*2+2]);\n\t}\n      }\n    }\n    while(q--){\n      int r1,c1,r2,c2;\n      if(w){\n\tcin>>r1>>c1>>r2>>c2;\n      }else{\n\tcin>>c1>>r1>>c2>>r2;\n      }\n      int m=INF;\n      for(int i=r1;i<=r2;i++){\n\tm=min(m,que(d[i],c1,c2+1,0,0,cc));\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<climits>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint rc[1000 * 1000];\nint w, h, q;\nint mm;\nbool sw;\n\nint buff[2 * 1024 * 1024 + 10];\n\nvoid gen(){\n  const int n = w * h;\n  int m = 1; while(m < n) m *= 2; mm = m;\n\n  REP(i, m + m) buff[i] = INT_MAX;\n  REP(i, n) buff[i + m - 1] = rc[i];\n\n  while(m - 1 >= 0){\n    m /= 2;\n    /*\n    for(int i = 1; i <= mm; i *= 2){\n      for(int j = i - 1; j < i - 1 + i; j++){\n     \tprintf(\"%d \", buff[j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    for(int i = m - 1; i < m - 1 + m; i++){\n      buff[i] = min(buff[i * 2 + 1], buff[i * 2 + 2]);\n    }\n  }\n}\n\nint iter(int l, int r, int pos, int width){\n  //printf(\"iter: %d %d %d %d\\n\", l, r, pos, width);\n  int w2 = width / 2;\n  if(l + width == r) return buff[pos];\n  if(w2 <= l) return iter(l - w2, r - w2, pos * 2 + 2, w2);\n  if(w2 >= r) return iter(l, r, pos * 2 + 1, w2);\n  return min(iter(l, w2, pos * 2 + 1, w2), iter(0, r - w2, pos * 2 + 2, w2));\n}\n\nint query(int l, int r){\n  return iter(l, r, 0, mm);\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h, &w, &q), w + h + q){\n    sw = h > w;\n    \n    REP(i, h) REP(j, w){\n      if(!sw){\n\tscanf(\"%d\", rc + i * w + j);\n      }else{\n\tscanf(\"%d\", rc + j * h + i);\n      }\n    }\n\n    if(sw) swap(h, w);\n\n    gen();\n\n    REP(qq, q){\n      int h1, h2, w1, w2;\n      int ans = INT_MAX;\n      scanf(\"%d%d%d%d\", &h1, &w1, &h2, &w2);\n\n      if(sw){ swap(h1, w1); swap(h2, w2); }\n\n      for(int hh = h1; hh < h2 + 1; hh++){\n\tint p1 = hh * w + w1;\n\tint p2 = hh * w + w2;\n\n\t//REP(i, h*w) printf(\"%d \", rc[i]); puts(\"\");\n\t//printf(\"query(%d, %d) = %d\\n\", p1, p2 + 1, query(p1, p2 + 1));\n\n\tans = min(ans, query(p1, p2 + 1));\n      }\n\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst int INF=2147483647;\nvector<vector<int> > dc,dr;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nint query(vector<int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tint vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tdr.resize(c);\n\t\tc2=init(c)*2;\n\t\tr2=init(r)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tdr[i].resize(r2);\n\t\t\tfill(dr[i].begin(),dr[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t\tupdate(dr[j],i,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tint res=INF;\n\t\t\tif(y2-y<=x2-x){\n\t\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x;i<=x2;i++){\n\t\t\t\t\tres=min(res,query(dr[i],y,y2+1,0,0,dr[i].size()/2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual T e()=0,c(T,T)=0;\n};\ntemplate<typename T> class MinMonoid:public Monoid<T>{\npublic:\n\tT e(){return INF<T>();}\n\tT c(T a,T b){return min(a,b);}\n\tstatic MinMonoid<T>& i(){static MinMonoid<T> i;return i;}\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tvoid update(int v){\n\t\tv+=n2;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\ntemplate<typename T> class SegmentTree2D{\npublic:\n\tconst int H,W,H2,W2;vector<SegmentTree<T>> dat;Monoid<T>& m;\n\tSegmentTree2D(int H,int W,Monoid<T>& m):H(H),W(W),H2(upper_pow2(H)),W2(upper_pow2(W)),m(m){\n\t\tdat=vector<SegmentTree<T>>(H2*2,SegmentTree<T>(W,m));\n\t}\n\tinline T get(int y,int x){return dat[y+H2].get(x);}\n\tvoid set(int y,int x,T a){\n\t\ty+=H2;dat[y].set(x,a);\n\t\twhile(y!=1){\n\t\t\tint parent=y/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[chl].update(x);dat[chr].update(x);dat[parent].update(x);\n\t\t\tdat[parent].set(x,m.c(dat[chl].get(x),dat[chr].get(x)));\n\t\t}\n\t}\n\tT query(int yl,int yr,int xl,int xr){return query(yl,yr,xl,xr,1,0,H2);} //[a,b)\nprivate:\n\tT query(int yl,int yr,int xl,int xr,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=yl || yr<=l)return m.e();//out of range\n\t\tif(yl<=l && r<=yr)return dat[v].query(xl,xr);\n\t\tT lv=query(yl,yr,xl,xr,v*2,l,(l+r)/2),rv=query(yl,yr,xl,xr,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint r,c,q;cin >>r >> c >> q;\n\t\t\tif(r==0)break;\n\t\t\tSegmentTree2D<int> seg(r,c,MinMonoid<int>::i());\n\t\t\tREP(y,r)REP(x,c){\n\t\t\t\tint v;cin >> v;\n\t\t\t\tseg.set(y,x,v);\n\t\t\t}\n\t\t\tREP(_q,q){\n\t\t\t\tint r1,c1,r2,c2;cin >> r1>> c1 >> r2>> c2;r2++;c2++;\n\t\t\t\tcout << seg.query(r1,r2,c1,c2) <<endl;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<vector<int> > dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\nif((r*2-1)*(c*2-1)>2048)throw 1;\n\t\tdat.assign(r * 2 - 1, vector<int>(c * 2 - 1, INT_MAX) );\n\t\tvector<int> datr = dat[0];\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1].begin());\n\t\t}\n\n\t\tfor(int j = 0; j < datr.size(); ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W, H_, W_;\n\tint dat[4000000];\n\tsegtree() {}\n\tsegtree(vector<vector<int>> &f) {\n\t\tinit(f);\n\t}\n\tint x(int i, int j) {\n\t\treturn i * W_ + j;\n\t}\n\n\tvoid init(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tH_ = 2 * H - 1, W_ = 2 * W - 1;\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[x(i + H - 1, j + W - 1)] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[x(i, j)] = min(dat[x(i, 2 * j + 1)], dat[x(i, 2 * j + 2)]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[x(i, j)] = min(dat[x(2 * i + 1, j)], dat[x(2 * i + 2, j)]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[x(i, k)];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nvector<vector<int>> f;\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tf.assign(r, vector<int>(c, 0));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual T e()=0,c(T,T)=0;\n};\ntemplate<typename T> class MinMonoid:public Monoid<T>{\npublic:\n\tT e(){return INF<T>();}\n\tT c(T a,T b){return min(a,b);}\n\tstatic MinMonoid<T>& i(){static MinMonoid<T> i;return i;}\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tvoid update(int v){\n\t\tv+=n2;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\ntemplate<typename T> class SegmentTree2D{\npublic:\n\tconst int H,W,H2,W2;vector<SegmentTree<T>> dat;Monoid<T>& m;\n\tSegmentTree2D(int H,int W,Monoid<T>& m):H(H),W(W),H2(upper_pow2(H)),W2(upper_pow2(W)),m(m){\n\t\tdat=vector<SegmentTree<T>>(H2*2,SegmentTree<T>(W,m));\n\t}\n\tinline T get(int y,int x){return dat[y+H2].get(x);}\n\tvoid set(int y,int x,T a){\n\t\ty+=H2;dat[y].set(x,a);\n\t\twhile(y!=1){\n\t\t\tint parent=y/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent].set(x,m.c(dat[chl].get(x),dat[chr].get(x)));\n\t\t}\n\t}\n\tT query(int yl,int yr,int xl,int xr){return query(yl,yr,xl,xr,1,0,H2);} //[a,b)\nprivate:\n\tT query(int yl,int yr,int xl,int xr,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=yl || yr<=l)return m.e();//out of range\n\t\tif(yl<=l && r<=yr)return dat[v].query(xl,xr);\n\t\tT lv=query(yl,yr,xl,xr,v*2,l,(l+r)/2),rv=query(yl,yr,xl,xr,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint r,c,q;cin >>r >> c >> q;\n\t\t\tif(r==0)break;\n\t\t\tSegmentTree2D<int> seg(r,c,MinMonoid<int>::i());\n\t\t\tREP(y,r)REP(x,c){\n\t\t\t\tint v;cin >> v;\n\t\t\t\tseg.set(y,x,v);\n\t\t\t}\n\t\t\tREP(_q,q){\n\t\t\t\tint r1,c1,r2,c2;cin >> r1>> c1 >> r2>> c2;r2++;c2++;\n\t\t\t\tcout << seg.query(r1,r2,c1,c2) <<endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//\n#include<vector>\n#include<climits>\n#include<algorithm>\n//\nconst int NIL = -1;\nconst int INF = INT_MAX;\n//\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int min_x, int min_y, int max_x, int max_y, int value);\n  int query(int min_x, int min_y, int max_x, int max_y) const;\nprivate:\n  void update(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int value);\n  int query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const;\n  int size_x_, size_y_;\n  std::vector<int> node_;\n};\n//\nSegmentTree::SegmentTree(int x, int y) : size_x_(x), size_y_(y) {\n  while(x & x - 1) x += x & -x;\n  while(y & y - 1) y += y & -y;\n  node_.assign(x * y << 8, INF);\n}\n//\nvoid SegmentTree::update(int min_x, int min_y, int max_x, int max_y, int value) {\n  update(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y, value);\n}\nvoid SegmentTree::update(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int value) {\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return;\n  node_[index] = std::min(node_[index], value);\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return;\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    update(low_x, low_y, high_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n    update(low_x, middle_y + 1, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n    return;\n  }\n  if(low_y == high_y) {\n    update(low_x, low_y, middle_x, high_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n    update(middle_x + 1, low_y, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n    return;\n  }\n  update(low_x, low_y, middle_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n  update(low_x, middle_y + 1, middle_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n  update(middle_x + 1, low_y, high_x, middle_y, (index << 2) + 3, min_x, min_y, max_x, max_y, value);\n  update(middle_x + 1, middle_y + 1, high_x, high_y, (index << 2) + 4, min_x, min_y, max_x, max_y, value);\n}\n//\nint SegmentTree::query(int min_x, int min_y, int max_x, int max_y) const {\n  query(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y);\n}\nint SegmentTree::query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const {\n//   cout << low_x << \",\" << low_y << \":\" << high_x << \",\" << high_y << \"        \" << index << \":\" << node_[index] << endl;\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return INF;\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return node_[index];\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    int l = query(low_x, low_y, high_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n    int h = query(low_x, middle_y + 1, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  }\n  if(low_y == high_y) {\n    int l = query(low_x, low_y, middle_x, high_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n    int h = query(middle_x + 1, low_y, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  }\n  int ll = query(low_x, low_y, middle_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n  int lh = query(low_x, middle_y + 1, middle_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n  int hl = query(middle_x + 1, low_y, high_x, middle_y, (index << 2) + 3, min_x, min_y, max_x, max_y);\n  int hh = query(middle_x + 1, middle_y + 1, high_x, high_y, (index << 2) + 4, min_x, min_y, max_x, max_y);\n  return std::min({ll, lh, hl, hh});\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, x, y, grid);\n    }\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ():n(0),dat(0){\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid build(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vint;\nclass segtree{\n\tpublic:\n\tint w,h;\n\tvector<vint> data;\n\tvoid set(int h_,int w_){\n\t\tdata.clear();\n\t\tw=h=1;\n\t\twhile(w<w_)\tw<<=1;\n\t\twhile(h<h_)\th<<=1;\n\t\tdata.assign(2*h-1,vint(2*w-1,INT_MAX));\n\t}\n\tvoid update(){\n\t\tfor(int i=2*h-2;i>h-2;i--){\n\t\t\tfor(int j=w-2;j>=0;j--){\n\t\t\t\tdata[i][j]=min(data[i][2*j+1],data[i][2*j+2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tdata[i][j]=min(data[2*i+1][j],data[2*i+2][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint minw(int sw,int tw,int hh,int l,int r,int k){\n\t\tif(sw<=l&&r<=tw)\treturn data[hh][k];\n\t\tif(r<=sw||tw<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minw(sw,tw,hh,l,mid,2*k+1),minw(sw,tw,hh,mid,r,2*k+2));\n\t}\n\tint minh(int sh,int sw,int th,int tw,int l,int r,int k){\n\t\tif(sh<=l&&r<=th)\treturn minw(sw,tw,k,0,w,0);\n\t\tif(r<=sh||th<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minh(sh,sw,th,tw,l,mid,2*k+1),minh(sh,sw,th,tw,mid,r,2*k+2));\n\t}\n\t~segtree(){}\n};\n\nint main(){\n\tsegtree seg;\n\twhile(true){\n\t\tint r,c,q;\tcin>>r>>c>>q;\n\t\tif(r+c+q==0)\treturn 0;\n\t\tseg.set(r,c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\tcin>>a;\n\t\t\t\tseg.data[i+seg.h-1][j+seg.w-1]=a;\n\t\t\t}\n\t\t}\n\t\tseg.update();\n\t\twhile(q--){\n\t\t\tint sh,sw,th,tw;\tcin>>sh>>sw>>th>>tw;\n\t\t\tcout<<seg.minh(sh,sw,th+1,tw+1,0,seg.h,0)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\treturn (min(_query(k * 2 + 1, l, (l + r) / 2), _query(k * 2 + 2, (l + r) / 2, r)));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\treturn (min(query(k * 2 + 1, l, (l + r) / 2), query(k * 2 + 2, (l + r) / 2, r)));\n}\n\nint main()\n{\n\tint w, h, q, a;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < seg.size(); i++) vector<int>().swap(seg[i]);\n\t\tvector<vector<int> >().swap(seg);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[y2/B]&&y2%B!=0)y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[x2/B]&&x2%B!=0)x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1;\n\nprivate:\n\tvector<T> dat;\tll n;\n\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid;\n\t\tif (a <= l && r <= b) return dat[k];\n\n\t\tll mid = (l + r) / 2;\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){\n\t\tk += n - 1;\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\n\t\tbool is_reverse = r > c;\n\t\tvector<seg_tree<ll>> segs(min(r,c), seg_tree<ll>(max(r,c)));\n\t\tREP(i, r) REP(j, c) {\n\t\t\tll x = i, y = j;\n\t\t\tif (is_reverse) swap(x, y);\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tif (is_reverse) swap(x_1, y_1), swap(x_2, y_2);\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h;\n\tconst T id;\n\tfunc_t merge;\n\tvector<SegmentTree<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int li, int lj, int ri, int rj, int node, int lb, int ub) {\n\t\tif (ub <= li || ri <= lb) return id;\n\t\tif (li <= lb && ub <= ri) return data[node].Find(lj, rj - 1);\n\t\treturn merge(sub(li, lj, ri, rj, node * 2, lb, (lb + ub) / 2), sub(li, lj, ri, rj, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), id(id_), merge(merge_), data(h * 2, SegmentTree<T>(w_, id, merge)) {}\n\tvoid Init(const vector<vector<T>> v) {\n\t\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\t\tdata[i + h].Init(v[i]);\n\t\t}\n\t\tint w = v.front().size();\n\t\tvector<T> tmp(w);\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ttmp[j] = merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j));\n\t\t\t}\n\t\t\tdata[i].Init(tmp);\n\t\t}\n\t}\n\tvoid Update(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Update(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j, j), data[i * 2 + 1].Find(j, j)));\n\t}\n\tT Find(int i, int j) {\n\t\treturn data[i + h].Find(j);\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub(li, lj, ri + 1, rj + 1, 1, 0, h);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> grid(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> grid[i][j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\tst.Init(grid);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : School.cpp\n// Author      : alpc92\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define REP(i,n) for(int i(0);i<((int)n);++i)\n#define FOR(i,l,h) for(int i((int)l);i<=((int)h);++i)\n#define FORD(i,h,l) for(int i((int)h);i>=((int)l);--i)\n#define CLEAR(arr,k) memset(arr,k,sizeof(arr))\n#define SZ (STL) (int)STL.size();\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nint n, m;\n//int dp_max[100005][20];\nvector<vector<vector<int> > > dp;\n\n\ninline int min(int x, int y) {\n\tif (x > y)\n\t\treturn y;\n\treturn x;\n}\ninline int max(int a,int b){\n\treturn a>b?a:b;\n}\nvoid makermq(int r) {\n\tint i, k;\n\tfor (k = 1; (1 << k) <= m; k++) {\n\t\tfor (i = 1; i + (1 << k) - 1 <= m; i++) {\n\t\t\t//\t\t\tdp_max[i][k]=max(dp_max[i][k-1],dp_max[i+(1<<(k-1))][k-1]);\n\t\t\tdp[r][i][k]\n\t\t\t\t\t= min(dp[r][i][k - 1], dp[r][i + (1 << (k - 1))][k - 1]);\n\t\t}\n\t}\n}\nint query(int r, int x, int y) {\n\tint k = (int) (log(1.0 * (y - x + 1.0)) / log(2.0));\n\treturn min(dp[r][x][k], dp[r][y - (1 << k) + 1][k]);\n}\n\nint main() {\n\tint q;\n\twhile (scanf(\"%d %d %d\", &n, &m, &q), n || m || q) {\n\t\t/*bool st;\n\t\tif (n < m)\n\t\t\tst = 0;\n\t\telse\n\t\t\tst = 1;\n\t\tif (st)\n\t\t\tswap(m, n);\n\t\t\t*/\n\t\tint upper(0);\n\t\tdp.clear();\n\t\tdp.resize(n);\n\t\tREP(i,n) {\n\t\t\tdp[i].resize(m + 1);\n\t\t\tdp[i][0].resize(25);\n\t\t\tfor (int j(1); j <= m; ++j) {\n\t\t\t\tdp[i][j].resize(25);\n\t\t\t\tscanf(\"%d\", &dp[i][j][0]);\n\t\t\t\t//cin>>dp[i][j][0];\n\t\t\t\tupper=max(upper,dp[i][j][0]);\n\t\t\t}\n\t\t\tmakermq(i);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\t//if (st)\n\t\t\t\t//swap(r1, c1), swap(r2, c2);\n\t\t\tint ans(upper);\n\t\t\t++c1, ++c2;\n\t\t\tFOR(j,r1,r2)\n\t\t\t\tans = min(ans, query(j, c1, c2));\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t//cout<<ans<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint r, c, q;\nint _r, _c;\nint g;\nint _seg[4 * SZ + 1];\nvi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vi[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 2147483647\n\n\nclass RMQ{\npublic:\n\tRMQ(int height,int first_N){\n\t\trmq_H = height;\n\t\tN = 1;\n\t\twhile(N < first_N)N *= 2;\n\t\ttable = new int*[height];\n\t\tfor(int row = 0; row < height; row++){\n\t\t\ttable[row] = new int[2*N-1];\n\t\t\tfor(int col = 0; col < 2*N-1; col++){\n\t\t\t\ttable[row][col] = NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid update(int row,int loc,int value){\n\t\tloc += N-1;\n\n\t\ttable[row][loc] = value;\n\n\t\tif(N == 1)return;\n\n\t\tint parent = (loc-1)/2;\n\n\t\twhile(true){\n\t\t\ttable[row][parent] = min(table[row][2*parent+1],table[row][2*parent+2]);\n\n\t\t\tif(parent == 0)break;\n\t\t\telse{\n\t\t\t\tparent = (parent-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tint getN(){\n\t\treturn N;\n\t}\n\n\tint query(int row,int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t\tif(search_left <= node_left && search_right >= node_right){\n\t\t\treturn table[row][node_id];\n\t\t}\n\n\t\tint left_min = query(row,search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right_min = query(row,search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\t\treturn min(left_min,right_min);\n\t}\n\n\tvoid FREE(){\n\t\tfor(int row = 0; row < rmq_H; row++){\n\t\t\tdelete[] table[row];\n\t\t}\n\t\tdelete[] table;\n\t}\n\n\tint** table;\n\tint N,rmq_H;\n};\n\n\nint H,W,Q;\n\nvoid func(){\n\n\tint** input = new int*[H];\n\tfor(int row = 0; row < H; row++){\n\t\tinput[row] = new int[W];\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)scanf(\"%d\",&input[row][col]);\n\t}\n\n\tRMQ YOKO(H,W);\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tYOKO.update(row,col,input[row][col]);\n\t\t}\n\t}\n\n\tRMQ TATE(W,H);\n\tfor(int col = 0; col < W; col++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tTATE.update(col,row,input[row][col]);\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tdelete[] input[row];\n\t}\n\tdelete[] input;\n\n\tint row1,col1,row2,col2;\n\tint ans;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%d %d %d %d\",&row1,&col1,&row2,&col2);\n\n\t\tans = NUM;\n\n\t\tif(row2-row1 >= col2-col1){\n\t\t\tfor(int col = col1; col <= col2; col++){\n\t\t\t\tans = min(ans,TATE.query(col,row1,row2,0,0,TATE.getN()-1));\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int row = row1; row <= row2; row++){\n\t\t\t\tans = min(ans,YOKO.query(row,col1,col2,0,0,YOKO.getN()-1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\tYOKO.FREE();\n\tTATE.FREE();\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&Q);\n\t\tif(H == 0 && W == 0 && Q == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ2D{\n\tint h,w;\n\tS *datrmq;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tvoid xbuild(int y,int n,const S a[]){\n\t\tS *dat=datrmq+y*(2*w-1);\n\t\tfor(int i=0;i<n;i++)dat[w-1+i]=a[i];\n\t\tfor(int i=n;i<w;i++)dat[w-1+i]=nil;\n\t\tfor(int i=w-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid xupdate(S *dat,int x,int a){\n\t\tx+=w-1;\n\t\tdat[x]=a;\n\t\twhile(x>0){\n\t\t\tx=(x-1)/2;\n\t\t\tdat[x]=std::min(dat[x*2+1],dat[x*2+2],T());\n\t\t}\n\t}\n\tvoid yupdate(int y,int x,int a){\n\t\ty+=h-1;\n\t\twhile(y>0){\n\t\t\ty=(y-1)/2;\n\t\t\txupdate(datrmq+y*(2*w-1),x,a);\n\t\t}\n\t}\n\tS xquery(const S *dat,int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=xquery(dat,a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=xquery(dat,a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tS yquery(int ys,int ye,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=ys||ye<=l)return nil;\n\t\tif(ys<=l&&r<=ye)return xquery(datrmq+k*(2*w-1),xs,xe, 0,0,w);\n\t\telse{\n\t\t\tS vl=yquery(ys,ye,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=yquery(ys,ye,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=calcsize(h);\n\t\tw=this->w=calcsize(w);\n\t\tdatrmq=new S[(2*h-1)*(2*w-1)];\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\tfor(int i=0;i<n;i++)xbuild(h-1+i,m,a+i*m);\n\t\tfor(int i=n;i<h;i++)xbuild(h-1+i,m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tconst S *a=datrmq+(i*2+1)*(2*w-1);\n\t\t\tconst S *b=datrmq+(i*2+2)*(2*w-1);\n\t\t\tS *c=datrmq+i*(2*w-1);\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tc[j]=std::min(a[j],b[j],T());\n\t\t\t}\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] datrmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\tyupdate(y,x,a);\n\t}\n\tS query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn yquery(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\n\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D<unsigned int,std::less<unsigned int>,~0u> rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = (1 << 23);\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int dat[MAX];    \n\n    int c(int i, int j)\n    {\n        return i * (2 * W - 1) + j;\n    }\n    \n    void init(int h, int w, vector<vector<int>>& grid)\n    {        \n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        \n        for (int i = 0; i < 2 * H - 1; i++) {        \n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[c(i, j)] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[c(i + H - 1, j + W - 1)] = grid[i][j];\n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[c(i, j)] = min(dat[c(i, j * 2 + 1)],\n                                   dat[c(i, j * 2 + 2)]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[c(j, i)] = min(dat[c(j * 2 + 1, i)],\n                                   dat[c(j * 2 + 2, i)]);\n            }\n        }\n    }\n\n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[c(j, k)];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nRMQ2D r;\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        r.init(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << r.query(y1, x1, y2, x2) << endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define INF 0x7fffffff\n#define MAX 1048576\n#define MAXN 65535\n#define MAXLg 16\n#define MAXQ 20000\n\nint A[MAX],Log[MAXN + 1],tableMin[MAXN][MAXLg];\n\nvoid makeRMinQ(int *a,int s,int t){\n\tint n = t - s;\n\tfor (int i = s; i < t; ++i) tableMin[i - s][0] = a[i];\n\tfor (int j = 1; (1 << j) <= n; ++j)\n\t\tfor (int i = s; i + (1 << j) <= t; ++i)\n\t\t\ttableMin[i - s][j] = min(tableMin[i - s][j - 1], tableMin[i - s + (1 << (j - 1))][j - 1]);\n}\n\nint QueryMin(int x,int y){\n\tint p = Log[y - x + 1];\n\treturn min(tableMin[x][p],tableMin[y - (1 << p) + 1][p]);\n}\n\nstruct query{\n    int x1, y1;\n    int x2, y2;\n}fQ[MAXQ];\n\nint Res[MAXQ];\n\nint main() {\n\tfor (int i = 0, x = 0, cd = 2; i <= MAXN; ++x, cd <<= 1)\n\t\twhile (i <= MAXN && i < cd)\n\t\t    Log[++i] = x;\n\tint R, C, Q;\n\twhile(scanf(\"%d%d%d\",&R,&C,&Q), R){\n        if (R <= C){\n            for (int i = 0; i < R; ++i)\n                for (int j = 0; j < C; ++j)\n                    scanf(\"%d\", &A[i * C + j]);\n            for (int q = 0; q < Q; ++q)\n                scanf(\"%d%d%d%d\", &fQ[q].x1, &fQ[q].y1, &fQ[q].x2, &fQ[q].y2);\n        }else{\n            for (int i = 0; i < R; ++i)\n                for (int j = 0; j < C; ++j)\n                    scanf(\"%d\", &A[j * R + i]);\n            swap(R, C);\n            for (int q = 0; q < Q; ++q){\n                scanf(\"%d%d%d%d\", &fQ[q].x1, &fQ[q].y1, &fQ[q].x2, &fQ[q].y2);\n                swap(fQ[q].x1, fQ[q].y1);\n                swap(fQ[q].x2, fQ[q].y2);\n            }\n        }\n        for (int q = 0;q < Q; ++q)\n            Res[q] = INF;\n        int fC = (C-1) / MAXN+1;\n        for (int i = 0; i < R; ++i){\n            for (int j = 0, k = 0; j < fC; ++j){\n                int nk = min(C, k + MAXN);\n                makeRMinQ(A, i * C + k, i * C + nk);\n                for (int q = 0; q < Q; ++q){\n                    if (i < fQ[q].x1 || fQ[q].x2 < i)\n                        continue;\n                    int cs = max(fQ[q].y1,k);\n                    int ct = min(fQ[q].y2,nk - 1);\n                    if (cs > ct) continue;\n                    Res[q] = min(Res[q],QueryMin(cs - k,ct - k));\n                }\n                k = nk;\n            }\n        }\n        for (int q = 0; q < Q; ++q)\n            printf(\"%d\\n\", Res[q]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nint const MAX_SIZE = 250000*40;\nstruct Pool {\n    static dat_t dat[MAX_SIZE];\n    static int size;\n    static dat_t * fetch(int len){\n        dat_t * res = dat + size;\n        size+=len;\n        return res;\n    }\n    static void reset(){\n        size = 0;\n    }\n};\n\nint Pool::size = 0;\ndat_t Pool::dat[MAX_SIZE];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(scanf(\"%d%d%d\",&r,&c,&q) , r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            int x;\n            scanf(\"%d\",&x);\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            scanf(\"%d%d%d%d\", &y1,&x1,&y2,&x2);\n            y2++; x2++;\n            printf(\"%d\\n\", tree.get(x1,x2,y1,y2));\n        }\n        pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = (long long)1e18;\nint H, W, Q;\n\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 800;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][10][10];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\n\nclass Seg2d {\npublic:\n    vector<unsigned int> grid;\n    int width;\n    int height;\n\n    Seg2d (int sizex, int sizey) : width(sizex), height(sizey) {\n        long long int len = max(width, height);\n        long long int sq = len*len;\n        long long int ration = max(width, height) / min(width, height);\n        long long int size = (sq*4-1)/3/ration + 1;\n\n        grid.resize(10000000, INF);\n    }\n\n    ~Seg2d() {grid.clear();}\n\n    void _update(int wishl, int wishr, int wishu, int wishd, int k, int watchl, int watchr, int watchu, int watchd, unsigned int x) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n\n        if (wishl == wishr || wishu == wishd) return;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            grid[k] = x;\n            return;\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        _update(wishl, wishr, wishu, wishd, k*4+1, watchl, midx, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, k*4+2, midx, watchr, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, k*4+3, watchl, midx, midy, watchd, x);\n        _update(wishl, wishr, wishu, wishd, k*4+4, midx, watchr, midy, watchd, x);\n        grid[k] = min(min(grid[k*4+1], grid[k*4+2]), min(grid[k*4+3], grid[k*4+4]));\n    }\n\n    void update(int x, int y, unsigned int t) {\n        _update(x, x+1, y, y+1, 0, 0, width, 0, height, t);\n    }\n\n    unsigned int _getMin(int wishl, int wishr, int wishu, int wishd, int k, int watchl, int watchr, int watchu, int watchd) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n\n        if (wishl == wishr || wishu == wishd) return INF;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return INF;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            return grid[k];\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        val1 = _getMin(wishl, wishr, wishu, wishd, k*4+1, watchl, midx, watchu, midy);\n        val2 = _getMin(wishl, wishr, wishu, wishd, k*4+2, midx, watchr, watchu, midy);\n        val3 = _getMin(wishl, wishr, wishu, wishd, k*4+3, watchl, midx, midy, watchd);\n        val4 = _getMin(wishl, wishr, wishu, wishd, k*4+4, midx, watchr, midy, watchd);\n        return min(min(val1, val2), min(val3, val4));\n    }\n\n    unsigned int getMin(int x1, int x2, int y1, int y2) { // [x1, x2) [y1, y2)\n        return _getMin(x1, x2, y1, y2, 0, 0, width, 0, height);\n    }\n};\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n    \n        Seg2d seg(sizex, sizey);\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                seg.update(j, i, g);\n            }\n        }\n    \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", seg.getMin(c1, c2+1, r1, r2+1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=50;\nconst int MH=1000000,MW=1000000;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y1][j]);\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y2][j]);\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i)mi=min(mi,fld[i][x1]);\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i)min(mi,fld[i][x2]);\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            for(int j=bx1;j<bx2;++j)\n                mi=min(mi,bucket[by1][j]);\n\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define N 1000000\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint grid[N];\nvector<int> seg[1000];\n\nvoid init(int num,int n_){\n  for(int i=0;i<2*n_-1;i++)seg[num].push_back( (1<<31)-1 );\n}\n\nvoid update(int x,int k, int a){\n  k += n-1;\n  seg[x][k] = a;\n  while(k>0){\n    k = (k-1) / 2;\n    seg[x][k] = min(seg[x][k*2+1], seg[x][k*2+2]);\n  }\n}\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> grid[i*c+j];\n    }\n\n    if(r>=c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++)init(i,n);\n      for(int i=0;i<c;i++){\n\tfor(int j=0;j<r;j++)update(i,j,grid[j*c+i]);\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++)update(i,j,grid[i*c+j]);\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000000000\n#define N 1000000\nlong long r,c,q;\nlong long input;\nvector<long long> zu[1000];\nlong long aaa,bbb,aa,bb;\nlong long ans;\nlong long n;\nlong long ima;\nlong long dat[1000][4*N];\nvoid init(long long n_)\n{\n\tn=1;\n\twhile(n<n_)n*=2;\n\trep(i,2*n-1)rep(j,1000)dat[j][i]=INF;\n}\nvoid update(long long k,long long a)\n{\n\tk+=n-1;\n\tdat[ima][k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tdat[ima][k]=min(dat[ima][k*2+1],dat[ima][k*2+2]);\n\t}\n}\nlong long query(long long a,long long b,long long k,long long l,long long r)\n{\n\tif(r<=a||b<=l)return INF;\n\tif(a<=l&&r<=b)return dat[ima][k];\n\telse\n\t{\n\t\tlong long v1=query(a,b,k*2+1,l,(l+r)/2);\n\t\tlong long v2=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(v1,v2);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,1000)zu[i].clear();\n\t\tcin>>r>>c>>q;\n\t\tif(r==0)break;\n\t\tif(r<=c)\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[i].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[j].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t}\n\t\t/*rep(i,r)\n\t\t{\n\t\t\trep(j,c)cout<<zu[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tinit(c);\n\t\t//cout<<\"n:\"<<n<<endl;\n\t\trep(i,r)\n\t\t{\n\t\t\tima=i;\n\t\t\trep(j,c)\n\t\t\t{\n\t\t\t\tupdate(j,zu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(kkk,q)\n\t\t{\n\t\t\tcin>>aaa>>bbb>>aa>>bb;\n\t\t\tans=INF;\n\t\t\trep2(i,aaa,aa+1)\n\t\t\t{\n\t\t\t\tima=i;\n\t\t\t\t//cout<<query(bbb,bb+1,0,0,n)<<endl;\n\t\t\t\tans=min(ans,query(bbb,bb+1,0,0,n));\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=pow(r,1./3);\n    int cs=pow(c,1./3);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<min(rt+1,(l+cs-1)/cs*cs);j++){\n\t  m=min(m,v[i][j]);\n\t}\n\tfor(int j=max(rt/cs*cs,l);j<=rt;j++){\n\t  m=min(m,v[i][j]);\n\t}\n      }\n      for(int i=l;i<=rt;i++){\n\tfor(int j=t;j<min(b+1,(t+rs-1)/rs*rs);j++){\n\t  m=min(m,v[j][i]);\n\t}\n\tfor(int j=max(b/rs*rs,t);j<=b;j++){\n\t  m=min(m,v[j][i]);\n\t}\n      }\n      for(int i=(t+rs-1)/rs;i*rs+rs<=b+1;i++){\n\tfor(int j=(l+cs-1)/cs;j*cs+cs<=rt+1;j++){\n\t  m=min(m,vs[i][j]);\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a-1)*(b+m-1)>6800000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Max=1000010;\n#define inf 0x7fffffff\nint ma[Max];\nint Log[Max];\nint rmq[Max*22];\nint K,r,c,q;\n\nvoid preRMQ(){\n\tK=Log[c]+1;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int k=0;(1<<k)-1<c;k++){\n\t\t\tfor(int j=0;j + (1<<k) - 1<c;j++){\n\t\t\t\tif(k==0)\n\t\t\t\t\trmq[(i*K+k)*c+j]=ma[i*c+j];\n\t\t\t\telse\n\t\t\t\t\trmq[(i*K+k)*c+j]=min(rmq[(i*K+k-1)*c+j],rmq[(i*K+k-1)*c+j+(1<<k-1)]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint RMQ(int R,int i,int j){\n\tint k=Log[j-i+1];\n\treturn min(rmq[(R*K+k)*c+i],rmq[(R*K+k)*c+j-(1<<k)+1]);\n}\n\nint main()\n{\n\tLog[1]=0;\n\tfor(int i=2,x=1;i<1000000;i++){\n\t\tif(i>=(1<<x+1))\n\t\t\tx++;\n\t\tLog[i]=x;\n\t}\n\twhile(scanf(\"%d %d %d\",&r,&c,&q) == 3){\n\t\tif(r==0 && c==0 && q==0)\n\t\t\tbreak;\n\t\tint rr=r,cc=c;\n\t\tbool flag=false;\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tflag=true;\n\t\t}\n\t\tfor(int i=0;i<rr;i++){\n\t\t\tfor(int j=0;j<cc;j++){\n\t\t\t\tif(flag)\n\t\t\t\t\tscanf(\"%d\",&ma[j*c+i]);\n\t\t\t\telse\n\t\t\t\t\tscanf(\"%d\",&ma[i*c+j]);\n\t\t\t}\n\t\t}\n\t\tpreRMQ();\n\t\tint a1,a2,b1,b2;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tscanf(\"%d %d %d %d\",&a1,&a2,&b1,&b2);\n\t\t\tif(flag){\n\t\t\t\tswap(a1,a2);\n\t\t\t\tswap(b1,b2);\n\t\t\t}\n\t\t\tint ans=inf;\n\t\t\tfor(int j=a1;j<=b1;j++){\n\t\t\t\tans=min(ans,RMQ(j,a2,b2));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = INT_MAX;\n\nint data[1<<23];\nint H, W;\nint wid;\n\nvoid init(const int f[], int h, int w)\n{\n  H = W = 1;\n  while(H < h) H <<= 1;\n  while(W < w) W <<= 1;\n  wid = 2*W-1;\n  fill(begin(data), end(data), inf);\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++)\n      data[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n  for(int i = 2*H-2; i > H-2; i--)\n    for(int j = W-2; j >= 0; j--)\n      data[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n  for(int i = H-2; i >= 0; i--)\n    for(int j = 0; j < 2*W-1; j++)\n      data[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n}\nint query_w(int lj, int rj, int aj, int bj, int i, int k)\n{\n  if(rj <= aj || bj <= lj) return inf;\n  if(lj <= aj && bj <= rj) return data[i*wid+k];\n  return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t     query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n}\nint query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n{\n  if(ri <= ai || bi <= li) return inf;\n  if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n  return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t     query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n}\nint query(int li, int lj, int ri, int rj)\n{\n  return query_h(li, lj, ri, rj, 0, H, 0);\n}\n\nint r, c, q;\nint grid[1000100];\nint lr, lc, rr, rc;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    init(grid, r, c);\n\n    while(q--) {\n      cin >> lr >> lc >> rr >> rc;\n      cout << query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        //if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        //if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a)*(b+m)>12000000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof (c.begin()) i=c.begin(); i!=c.end(); i++)\n#define all(c) (c).begin(), (c).end()\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x<<\" = \"<<x<<endl\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint h, w, q, H, W;\nvector<vi> g;\n\nint rec(int y1, int x1, int y2, int x2,\n int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X1 <= x2) return g[y][x];\n\tint res = inf;\n\t\n\tif(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\tmin(\n\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h ,&w, &q), w){\n  \tfor(H = 1; H < h; H *= 2);\n  \tfor(W = 1; W < w; W *= 2);\n  \tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n  \trep(i,h) rep(j,w){\n  \t\tscanf(\"%d\", &g[i+H-1][j+W-1]);\n  \t}\n  \tfor(int i = H-1; ; i--){\n  \t\tfor(int j = W-1; ;j--){\n  \t\t\tif(i < H-1 && j < W-1)\n  \t\t\tg[i][j] = min(min(g[i*2+1][j*2+1], g[i*2+2][j*2+2]),\n  \t\t\t\tmin(g[i*2+2][j*2+1], g[i*2+1][j*2+2]));\n\t\t\t\tif(i < H-1) \n  \t\t\t\tg[i][j] = min(g[i][j], min(g[i*2+1][j], g[i*2+2][j]));\n\t\t\t\tif(j < W-1)\n  \t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2+1], g[i][j*2+2]));\n\t\t\t\tif(j == 0) break;\n  \t\t}\n  \t\tif(i == 0) break;\n  \t}\n  \trep(i, q){\n  \t\tint y1, y2, x1, x2;\n  \t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n  \t\tprintf(\"%d\\n\", rec(y1, x1, y2+1, x2+1, 0, 0, H, W, 0, 0));\n  \t}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tS *dat;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ():dat(0){\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid build(int n,const S a[]){\n\t\tint m=n;\n\t\tn=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid update(int k,int a,int k,int l,int r){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b,int k,int l,int r)const{//[a,b)の最小(大)値\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n};\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(xs,xe, 0,0,w);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 6000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return LLONG_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint len[1001000];\n\nint min(const int &a,const int &b)\n{\n    if (a<b) return a;else return b;\n}\n\n\nint mi[1001000][21];\n\nstruct RMQ\n{\n    void rmq(int * d, int N)\n    {\n        int M=len[N];\n        for (int i=0;i<N;i++) mi[i][0]=d[i];\n        for (int g=1;g<=M;g++)\n        {\n            int L=N-(1<<g);\n            for (int i=0;i<=L;i++)\n                mi[i][g]=min( mi[i][g-1] , mi[i+(1<<(g-1))][g-1] );\n        }\n    }\n    int query(int &a, int &b)\n    {\n        int g=len[b-a+1];\n        return min(mi[a][g],mi[b-(1<<(g))+1][g]);\n    }\n}aa;\n\nint a[1100000];\nint r1[11000],r2[11000],c1[11000],c2[11000];\nint ans[11000];\nlong long numinf;\nint inf;\nint m,n,q;\nint main()\n{\n    for (int L=1;L<=1000000;L++) len[L]=int (log(L*1.0)/log(2.0));\n    numinf=1;\n    for (int k=1;k<=31;k++) numinf*=2LL;\n    numinf=numinf-1;\n    inf=numinf;\n\n   \n    scanf(\"%d%d%d\",&n,&m,&q);\n    while (n+m+q!=0)\n    {\n        int rv=0;\n        if (n>m) rv=1;\n        if (n>m) swap(n,m);\n        if (rv==0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                scanf(\"%d\",a+i*m+j);\n        if (rv!=0)\n        for (int j=0;j<n;j++)\n            for (int i=0;i<m;j++)\n                scanf(\"%d\",a+j*m+i);\n\n\n        for (int k=1;k<=q;k++)\n            scanf(\"%d%d%d%d\",&r1[k],&c1[k],&r2[k],&c2[k]);\n        for (int k=1;k<=q;k++) ans[k]=inf;\n        for (int k=1;k<=q;k++)\n           if (rv)\n           {\n               swap(r1[k],c1[k]);\n               swap(r2[k],c2[k]);\n           }\n        int temp;\n        for (int i=0;i<n;i++)\n        {\n            aa.rmq(a+i*m,m);\n            for (int k=1;k<=q;k++)\n                if (r1[k]<=i&&i<=r2[k])\n                {\n                    temp=aa.query(c1[k],c2[k]);\n                    if (temp<ans[k]) ans[k]=temp;\n                }\n        }\n        for (int k=1;k<=q;k++)\n            printf(\"%d\\n\",ans[k]);\n        scanf(\"%d%d%d\",&n,&m,&q);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n#include <array>\n\ntypedef long long TYPE;\nTYPE inf = 10000000000000000;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d();\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid init(const int h, const int w);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\tTYPE _get(const int i, const int j);\n\tvoid _set(const int i, const int j, const TYPE val);\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n\n\tint height;\n\tint width;\n\n\tint height2;\n\tint width2;\n\tint logwidth;\n\tvector<TYPE> array;\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << _get(i, j) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nTYPE Segment2d::_get(const int i, const int j)\n{\n\treturn array[(i << logwidth) + j];\n}\nvoid Segment2d::_set(const int i, const int j, const TYPE val)\n{\n\tarray[(i << logwidth) + j] = val;\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nvoid Segment2d::init(const int h, const int w)\n{\n\theight = h;\n\twidth = w;\n\twidth2 = 1;\n\tlogwidth = 0;\n\twhile(width2 < width)\n\t{\n\t\twidth2 *= 2;\n\t\tlogwidth++;\n\t} \n\tlogwidth++;\n\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfill(array.begin(), array.end(), inf);\n}\n\nSegment2d::Segment2d()\n{\n\tarray.resize(1 << 23);\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\t_set(y, x, val);\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tconst TYPE val = min(_get(left(ys[i]), xs[0]), _get(right(ys[i]), xs[0]));\n\t\t_set(ys[i], xs[0], val);\n\t}\n\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tconst TYPE val = min(_get(ys[i], left(xs[j])), _get(ys[i], right(xs[j])));\n\t\t\t_set(ys[i], xs[j], val);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn _get(ky, kx);\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg;\n\tseg.init(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tSegment2d seg;\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tseg.init(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n#include<iostream>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\nstruct SegTree{\n    struct st{\n        int W;\n        vi dat;\n        void init(int _W){\n            W=1;while(W<_W)W*=2;\n            dat=vi(W*2-1,INT_MAX);\n        }\n        void build(vi &V){\n            for(int i=0;i<V.size();i++)dat[i+W-1]=V[i];\n            for(int i=W-2;i>=0;i--){\n                dat[i]=min(dat[i*2+1],dat[i*2+2]);\n            }\n        }\n        int getMin(int a,int b,int k=0,int l=0,int r=-1){\n            if(r==-1)r=W;\n            if(a<=l&&b>=r)return dat[k];\n            if(r<=a||b<=l)return INT_MAX;\n            int val1=getMin(a,b,k*2+1,l,(l+r)/2);\n            int val2=getMin(a,b,k*2+2,(l+r)/2,r);\n            return min(val1,val2);\n        }\n    };\n\n    int H,W;\n    vector<st>dat;\n    void init(int _H,int _W){\n        H=1;W=1;\n        while(H<_H)H*=2;\n        while(W<_W)W*=2;\n        dat=vector<st>(H*2-1);\n        for(int i=0;i<dat.size();i++)dat[i].init(W);\n    }\n\n    void unite(int x,int y,vi &ret){\n        for(int i=0;i<W;i++)ret[i]=min(dat[x].dat[i+W-1],dat[y].dat[i+W-1]);\n    }\n\n    void build(vvi &fld){\n        for(int i=0;i<fld.size();i++)dat[i+H-1].build(fld[i]);\n\n        for(int i=H-2;i>=0;i--){\n            vi V(W,INT_MAX);\n            unite(i*2+1,i*2+2,V);\n            dat[i].build(V);\n        }\n    }\n\n    int getMin(int ha,int hb,int wa,int wb,int k=0,int l=0,int r=-1){\n        if(r==-1)r=H;\n        if(ha<=l&&hb>=r)return dat[k].getMin(wa,wb);\n        if(r<=ha||hb<=l)return INT_MAX;\n        int val1=getMin(ha,hb,wa,wb,k*2+1,l,(l+r)/2);\n        int val2=getMin(ha,hb,wa,wb,k*2+2,(l+r)/2,r);\n        return min(val1,val2);\n    }\n};\n\nint main(){\n    int H,W,Q;\n    while(scanf(\"%d%d%d\",&H,&W,&Q),H||W||Q){\n        vvi fld(H,vi(W));\n        for(int i=0;i<H;i++)\n            for(int j=0;j<W;j++)\n                scanf(\"%d\",&fld[i][j]);\n\n        SegTree seg;\n        seg.init(H,W);\n        seg.build(fld);\n\n        while(Q--){\n            int x1,y1,x2,y2;\n            scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n            x2++;y2++;\n            printf(\"%d\\n\",seg.getMin(y1,y2,x1,x2));\n\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0x7fffffff;\n\nint W, H, WW, HH, seg_H, seg_W;\nvector< vector<int> > data;\nvector< vector<int> > seg_tree;\n\n//y in [0, H)\nvoid initialize_W(int y, int cur_node, int lx, int rx){\n\tif(rx - lx <= 1){\n\t\tif(y < H){\n\t\t\tseg_tree[y + HH - 1][cur_node] = data[y][lx];\n\t\t}\n\t\treturn ;\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\n\tinitialize_W(y, 2*cur_node + 1, lx, mid);\n\tinitialize_W(y, 2*cur_node + 2, mid, rx);\n\n\tseg_tree[y + HH - 1][cur_node] = min(seg_tree[y + HH - 1][2*cur_node + 1], seg_tree[y + HH - 1][2*cur_node + 2]);\n}\n\nint query_W(int node_y, int fx, int tx, int cur_node, int lx, int rx){\n\tif( rx <= fx || tx <= lx ){\n\t\treturn INF;\n\t}\n\n\tif( fx <= lx && rx <= tx ){\n\t\treturn seg_tree[node_y][cur_node];\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\treturn min(query_W(node_y, fx, tx, cur_node*2 + 1, lx, mid),\n\t\t\tquery_W(node_y, fx, tx, cur_node*2 + 2, mid, rx));\n}\n\nvoid initialize_H(int cur_node, int ly, int ry){\n\tif(ry - ly <= 1){\n\t\tinitialize_W(ly, 0, 0, WW);\n\t\treturn ;\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\n\tinitialize_H(2*cur_node + 1, ly, mid);\n\tinitialize_H(2*cur_node + 2, mid, ry);\n\n\tfor(int j=0; j<seg_W; j++){\n\t\tseg_tree[cur_node][j] = min(seg_tree[2*cur_node + 1][j], seg_tree[2*cur_node + 2][j]);\n\t}\n}\n\nint query_H(int fy, int ty, int fx, int tx, int cur_node, int ly, int ry){\n\tif( ry <= fy || ty <= ly ){\n\t\treturn INF;\n\t}\n\n\tif( fy <= ly && ry <= ty ){\n\t\treturn query_W(cur_node, fx, tx, 0, 0, WW);\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\treturn min(query_H(fy, ty, fx, tx, cur_node*2 + 1, ly, mid),\n\t\t\tquery_H(fy, ty, fx, tx, cur_node*2 + 2, mid, ry));\n}\n\n// [y1, y2) * [x1, x2)\nint query_segtree(int y1, int x1, int y2, int x2){\n\treturn query_H(y1, y2, x1, x2, 0, 0, HH);\n}\n\nvoid build_segtree(){\n\tconst int log_H = H == 1 ? 0 : 31 - __builtin_clz(H-1), log_W = W == 1 ? 0 :31 - __builtin_clz(W-1);\n\tHH = 1<<(log_H+1);\n\tWW = 1<<(log_W+1);\n\tseg_H = 2*HH - 1;\n\tseg_W = 2*WW - 1;\n\n\tseg_tree.clear();\n\tseg_tree = vector< vector<int> >(seg_H, vector<int>(seg_W, INF));\n\n\tinitialize_H(0, 0, HH);\n}\n\nint main(){\n\tint Q;\n\twhile(scanf(\"%d%d%d\",&H,&W,&Q), H){\n\t\tconst int log_H = 31 - __builtin_clz(H), log_W = 31 - __builtin_clz(W);\n\t\tdata.clear();\n\t\tseg_tree.clear();\n\n\t\tdata = vector< vector<int> >(H, vector<int>(W));\n\n\t\tfor(int i=0; i<H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tscanf(\"%d\", &data[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tbuild_segtree();\n\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d%d%d%d\",&y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query_segtree(y1, x1, y2+1, x2+1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\nint data[1 << 23];\nint v[1 << 20];\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif (ri <= si || ti <= li) return id;\n\t\tif (li <= si && ti <= ri) return sub_w(lj, rj, 0, w, k, 1);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn merge(sub_h(li, lj, ri, rj, si, mi, k * 2), sub_h(li, lj, ri, rj, mi, ti, k * 2 + 1));\n\t}\n\tT sub_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif (rj <= sj || tj <= lj) return id;\n\t\tif (lj <= sj && tj <= rj) return data[i * w * 2 + k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn merge(sub_w(lj, rj, sj, mj, i, k * 2), sub_w(lj, rj, mj, tj, i, k * 2 + 1));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), w(size(w_)), id(id_), merge(merge_) {\n\t\tfill(data, data + (1 << 23), id);\n\t\tfor (int i = 0; i < h_; i++)\n\t\t\tfor (int j = 0; j < w_; j++)\n\t\t\t\tdata[(h + i) * w * 2 + w + j] = v[i * w_ + j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n\t}\n\tvoid Update(int pi, int pj, T val) {\n\t\tpi += h;\n\t\tpj += w;\n\t\tdata[pi * w * 2 + pj] = val;\n\t\tint tj = pj;\n\t\twhile (tj >>= 1) {\n\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t}\n\t\twhile (pi >>= 1) {\n\t\t\tdata[pi * w * 2 + pj] = merge(data[(pi * 2) * w * 2 + pj], data[(pi * 2 + 1) * w * 2 + pj]);\n\t\t\ttj = pj;\n\t\t\twhile (tj >>= 1) {\n\t\t\t\tdata[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n\t\t\t}\n\t\t}\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub_h(li, lj, ri + 1, rj + 1, 0, h, 1);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i * c + j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\tif(vl<vr)return vl;\n\treturn vr;\n\t//return min(vl,vr);\n}\n\nint main(){\n\twhile(scanf(\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\t//while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\t//cin>>t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\t//cin>>r1>>c1>>r2>>c2;\n\t\t\tscanf(\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\t//cout<<res<<endl;\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 8000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return INT_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%d\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%d%d%d\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        if (h >= w){\n\t        for (i = 0; i < h; i++){\n    \t        for (j = 0; j < w; j++){\n        \t        scanf(\"%d\", &t);\n            \t    update(i * w + j, t);\n            \t}\n        \t}\n        }\n        else {\n        \tfor (i = 0; i < h; i++){\n        \t\tfor (j = 0; j < w; j++){\n        \t\t\tscanf(\"%d\", &t);\n        \t\t\tupdate(i + j * h, t);\n        \t\t}\n        \t}\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            /*if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {*/\n            \tif (h >= w){\n\t\t            for (int k = y1; k <= y2; k++){\n    \t\t        \tans = min(ans, query(k * w + x1, k * w + x2 + 1, 0, 0, n));\n        \t\t    }\n        \t\t}\n        \t\telse {\n        \t\t\tfor (int k = x1; k <= x2; k++){\n        \t\t\t\tans = min(ans, query(k * h + y1, k * h + y2 + 1, 0, 0, n));\n        \t\t\t}\n        \t\t}\n            \tprintf(\"%d\\n\", ans);\n    //}\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W;\n\tvector<vector<int>> dat;\n\tsegtree(){}\n\tsegtree(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tdat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));\n\t\tinit(f);\n\t}\n\tvoid init(vector<vector<int>> &f) {\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[i + H - 1][j + W - 1] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> f(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=min(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[n+a-1];\n\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=2147483647;\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 16\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvector<vector<int> > dat;\nint R, C;\n\nvoid update(int r, int c, int x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(true){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tif (cc == 0) break;\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tint v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tint v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tint v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tint v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tdat.clear();\n\t\tdat.assign(R * 2 - 1, vector<int>(C * 2 - 1, INF));\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tint x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int N;\n  vector<int> data;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n  void clear() {\n    data.clear();\n  }\n};\nstruct Grid {\n  int K;\n  int SQRT_N;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    SQRT_N = 0;\n    while(SQRT_N*SQRT_N < H) SQRT_N++;\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    bool doswap = false;\n    if(H > W) {\n      doswap = true;\n      swap(H, W);\n    }\n    Grid g;\n    if(doswap) {\n      REP(y,W) REP(x,H) {\n        int v; cin >> v;\n        g.update(x, y, v);\n      }\n    }\n    else {\n      REP(y,H) REP(x,W) {\n        int v; cin >> v;\n        g.update(y, x, v);\n      }\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      if(doswap) {\n        swap(x1, y1);\n        swap(x2, y2);\n      }\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <list>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m,Q;\nint inf=2147483647;\n#define maxn 1400000\ninline void zy(int &a,int b)\n{\n\tif(b<a)a=b;\n}\nstruct Node{\n\tint mn;\n\tint x1,x2,y1,y2;\n\tNode *lu,*ld,*ru,*rd;\n\tvoid init(int _x1,int _x2,int _y1,int _y2){\n\t\tx1=_x1,x2=_x2;\n\t\ty1=_y1,y2=_y2;\n\t\tlu=ld=ru=rd=NULL;\n\t\tmn=inf;\n\t}\n\tinline void update(){\n\t\tmn=inf;\n\t\tif( lu ) zy(mn,lu->mn);\n\t\tif( ld ) zy(mn,ld->mn);\n\t\tif( ru ) zy(mn,ru->mn);\n\t\tif( rd ) zy(mn,rd->mn);\n\t}\n}dd[maxn],*root;\nint e; \nNode* _alloc(int x1,int x2,int y1,int y2){\n\t//if(e>maxn-10)exit(1);\n\tdd[e].init(x1,x2,y1,y2); return &dd[e++];\n}\nvoid insert(Node *p,int x,int y,int g){\n\tif( p->x1==p->x2 && p->y1==p->y2 ) {\n\t\tp->mn=g;\n\t\treturn;\n\t}\n\tint midx=(p->x1+p->x2)/2;\n\tint midy=(p->y1+p->y2)/2;\n\tif( x<=midx && y>midy ) {\n\t\tif( p->lu==NULL ) p->lu=_alloc(p->x1,midx,midy+1,p->y2);\n\t\tinsert(p->lu,x,y,g);\n\t}else if( x<=midx && y<=midy ){\n\t\tif( p->ld==NULL ) p->ld=_alloc(p->x1,midx,p->y1,midy);\n\t\tinsert(p->ld,x,y,g);\n\t}else if( x>midx && y>midy ){\n\t\tif( p->ru==NULL ) p->ru=_alloc(midx+1,p->x2,midy+1,p->y2);\n\t\tinsert(p->ru,x,y,g);\n\t}else{\n\t\tif( p->rd==NULL ) p->rd=_alloc(midx+1,p->x2,p->y1,midy);\n\t\tinsert(p->rd,x,y,g);\n\t}\n\tp->update();\n}\nint query(Node *p,int x1,int x2,int y1,int y2){\n\tif( p==NULL ) return inf;\n\tx1=max(x1,p->x1);\n\ty1=max(y1,p->y1);\n\tx2=min(x2,p->x2);\n\ty2=min(y2,p->y2);\n\tif( x1>x2 || y1>y2 ) return inf;\n\n\tif( x1==p->x1 && x2==p->x2 && y1==p->y1 && y2==p->y2 ) return p->mn;\n\treturn min(query(p->lu,x1,x2,y1,y2) ,min( query(p->ld,x1,x2,y1,y2),(min(\n\t\tquery(p->ru,x1,x2,y1,y2) , query(p->rd,x1,x2,y1,y2)))));\n}\n\nint main()\n{\n\twhile(cin>>n>>m>>Q&&n)\n\t{\n\t\te=0;\n\t\tdd[e].init(0,n-1,0,m-1); //32768=2^31\n\t\troot=&dd[e++];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int q=0;q<m;q++)\n\t\t\t{\n\t\t\t\tint z;\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\tinsert(root,i,q,z);\n\t\t\t}\n\t\twhile(Q--)\n\t\t{\n\t\t\tint x1,x2,y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",query(root,x1,x2,y1,y2));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(n * 2, id) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\tl += n; r += n + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) res1 = merge(res1, data[l++]);\n\t\t\tif (r & 1) res2 = merge(data[--r], res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h;\n\tconst T id;\n\tfunc_t merge;\n\tvector<SegmentTree<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), id(id_), merge(merge_), data(h * 2, SegmentTree<T>(w_, id, merge)) {}\n\tvoid Init(const vector<vector<T>>& v) {\n\t\tfor (int i = 0; i < (int)v.size(); i++) data[i + h].Init(v[i]);\n\t\tint w = v.front().size();\n\t\tvector<T> tmp(w);\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ttmp[j] = merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j));\n\t\t\t}\n\t\t\tdata[i].Init(tmp);\n\t\t}\n\t}\n\tvoid Update(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Update(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j)));\n\t}\n\tvoid Add(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Add(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j)));\n\t}\n\tT Find(int i, int j) {\n\t\treturn data[i + h].Find(j);\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\tli += h; ri += h + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (li < ri) {\n\t\t\tif (li & 1) res1 = merge(res1, data[li++].Find(lj, rj));\n\t\t\tif (ri & 1) res2 = merge(data[--ri].Find(lj, rj), res2);\n\t\t\tli >>= 1; ri >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\tvector<vector<int>> v; v.reserve(1e6);\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tv.assign(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\tst.Init(v);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 650;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][9][9];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint tmp;\nvector<int> seg[1000];\n\nvoid init(int num,int n_){\n  seg[num].clear();\n  for(int i=0;i<2*n_-1;i++)seg[num].push_back( (1<<31)-1 );\n}\n\nvoid update(int x,int k, int a){\n  k += n-1;\n  seg[x][k] = a;\n  while(k>0){\n    k = (k-1) / 2;\n    seg[x][k] = min(seg[x][k*2+1], seg[x][k*2+2]);\n  }\n}\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(r>=c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(j,i,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(i,j,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint vlog[1000010];\nint R, C, Q;\nvector<vector<vector<int> > > rmq;\nint grid[1000010];\n\ninline void setvalue(int r, int c, int v){ grid[r*C+c] = v; }\ninline int getvalue(int r, int c){ return grid[r*C+c]; }\n\nvoid rmq_build()\n{\n    rmq.clear();\n    for(int i = 0; i < R; i++){\n        rmq.push_back(vector<vector<int> >());\n        for(int k = 0; (1<<k)-1 < C; k++){\n            rmq[i].push_back(vector<int>());\n            for(int j = 0; j + (1<<k)-1 < C; j++){\n                rmq[i][k].push_back(k==0 ? getvalue(i, j) : min(rmq[i][k-1][j], rmq[i][k-1][j+(1<<k-1)]));\n            }\n        }\n    } \n}\n\ninline int rmq_query(int r, int c1, int c2)\n{\n    int k = vlog[c2-c1+1];\n    return min(rmq[r][k][c1], rmq[r][k][c2-(1<<k)+1]);\n}\n\nint main()\n{\n//    freopen(\"SchoolOfKillifish.in\",\"r\",stdin);\n    int r1, c1, r2, c2, v;\n    for(int i = 1; i <= 1000000; i++) vlog[i] = (int)log2((double)i);\n    while(~scanf(\"%d%d%d\", &R, &C, &Q)) {\n        bool rot = (R > C);\n        int rr = R, cc = C;\n        if(rot) swap(R, C);\n        for(int i = 0; i < rr; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\", &v);\n                if(rot) setvalue(j, i, v);\n                else setvalue(i, j, v);\n            }\n        }\n        rmq_build();\n        for(int i = 0; i < Q; i++) {\n            scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n            if(rot) swap(r1, c1), swap(r2, c2);\n            int v = 0x7fffffff;\n            for(int j = r1; j <= r2; j++)\n                v = min(v, rmq_query(j, c1, c2));\n            printf(\"%d\\n\", v);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int size){\n\tsize--;\n\trep(i,5) size|=size>>(1<<i);\n\treturn size+1;\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegTree2D{\n\tint size;\n\tvector<SegTree> data;\n\tSegTree2D(int h,int w):size(Need(h)),data(size*2,SegTree(w)){}\n\tvoid Update(int i,int j,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i].Update(j,x);\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\tint res=INFTY,m=(to+bo)/2;\n\t\tif(a<m) res=min(res,Query(a,b,c,d,i*2+0,to,m));\n\t\tif(m<c) res=min(res,Query(a,b,c,d,i*2+1,m,bo));\n\t\treturn res;\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(r,vi(c));\n\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tSegTree2D st(r,c);\n\t\trep(i,r) rep(j,c) st.Update(i,j,grid[i][j]);\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tprintf(\"%d\\n\",st.Query(r1,c1,r2+1,c2+1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\n// #define DEBUG\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\n\n\nuint field[sz];\nuint dat[sz * 20];\nint R, C, Q;\n\n#define FIELD(r, c) field[(r) * C + (c)]\n#define DAT(kr, kc) dat[(kr) * (C) * 4 + (kc)]\n\nvoid build(int lr = 0, int rr = R,\n           int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr - lr == 0 || rc - lc == 0){\n    DAT(kr, kc) = INF;\n  }else if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = FIELD(lr, lc);\n  }else{\n    if(r_axis){\n      int mr = (lr + rr) / 2;\n      build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n      build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n      DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    }else{\n      int mc = (lc + rc) / 2;\n      build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n      build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n      DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n    }\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n           int lr = 0, int rr = R, int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc) return INF;\n  if(rr - lr == 0 || rc - lc == 0) return INF;\n  \n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc) return DAT(kr, kc);\n  \n  if(r_axis){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\nuint naive(int ar, int br, int ac, int bc){\n  uint ans = INF;\n  REP2(i, ar, br)REP2(j, ac, bc) ans = min(ans, FIELD(i, j));\n  return ans;\n}\n\nint main(){\n  int r1, r2, c1, c2;\n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    cerr << R << \" \" << C << \" \" << Q << endl;\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &FIELD(r, c));\n    build();\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      cerr << r1 << \" \"<< c1 << \" \" << r2 << \" \"<< c2 << endl;\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n\n\n#ifdef DEBUG\n    REP(r2, R)REP(r1, r2 + 1)REP(c2, C)REP(c1, c2 + 1){\n      cout <<naive(r1, r2 + 1, c1, c2 + 1) << endl;\n      assert(naive(r1, r2 + 1, c1, c2 + 1) == query(r1, r2 + 1, c1, c2 + 1));\n    }\n#endif\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = max(0, h1 / Hs); j < min(h2 / Hs + 1, Hs); j++){\n\t\t\t\tfor (int k = max(0, w1 / Ws); k < min(w2 / Ws + 1, Ws); k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t&& w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (h1 <= j * Hs || (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t|| w1 <= k * Ws || (k + 1) * Ws < w2){\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint init(int k)\n{\n\tint sz;\n\tsz = 1;\n\twhile (sz < k){\n\t\tsz *= 2;\n\t}\n\t\n\treturn (sz);\n}\n\nvoid update(vector<int> &seg, int pos, int val)\n{\n\tpos += (seg.size() / 2) - 1;\n\tseg[pos] = val;\n\t\n\twhile (pos){\n\t\tpos = (pos - 1) / 2;\n\t\tseg[pos] = min(seg[2 * pos + 1], seg[2 * pos + 2]);\n\t};\n}\n\nint getMin(vector<int> &seg, int a, int b, int k, int l, int r)\n{\n\tint vl, vr;\n\t\n\tif (b <= l || r <= a){\n\t\treturn (INT_MAX);\n\t}\n\t\n\tif (a <= l && r <= b){\n\t\treturn (seg[k]);\n\t}\n\telse {\n\t\tvl = getMin(seg, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tvr = getMin(seg, a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\t\n\treturn (min(vl, vr));\n}\n\nint main()\n{\n\tint H, W, Q;\n\t\n\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvector<vector<int> > Hs(H, vector<int>(2 * init(W)));\n\t\tvector<vector<int> > Ws(W, vector<int>(2 * init(H)));\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfill(Hs[i].begin(), Hs[i].end(), INT_MAX);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < W; i++){\n\t\t\tfill(Ws[i].begin(), Ws[i].end(), INT_MAX);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tupdate(Hs[i], j, t);\n\t\t\t\tupdate(Ws[j], i, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tif (h2 - h1 <= w2 - w1){\n\t\t\t\tfor (int j = h1; j <= h2; j++){\n\t\t\t\t\tres = min(res, getMin(Hs[j], w1, w2 + 1, 0, 0, Hs[j].size() / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = w1; j <= w2; j++){\n\t\t\t\t\tres = min(res, getMin(Ws[j], h1, h2 + 1, 0, 0, Ws[j].size() / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ():n(0),dat(0){\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid build(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\t//RMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\t//cout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t\tcout<<0<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nconst int oo = 0x7FFFFFFF;\nconst int MaxN = 1000005;\nconst int MaxM = 65535;\nconst int MaxQ = 10005;\nconst int MaxL = 16;\nint A[MaxN], to[MaxN + 1], dp[MaxN][MaxL];\nint Q[MaxQ][4], ret[MaxQ];\nint r, c, q;\n\nvoid init() {\n\tto[0] = to[1] = 0;\n\tfor (int i = 1; i <= MaxN; i++) {\n\t\tif (i * 2 <= MaxN)\n\t\t\tto[i * 2] = to[i] + 1;\n\t\telse\n\t\t\tbreak;\n\t\tif (i * 2 + 1 <= MaxN)\n\t\t\tto[i * 2 + 1] = to[i] + 1;\n\t}\n}\n\nvoid init(int* A, int s, int t) {\n\tint n = t - s, len, pre;\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i][0] = A[s + i];\n\tfor (int k = 1; k < MaxL; k++) {\n\t\tif ((len = (1 << k)) > n)\n\t\t\tbreak;\n\t\tpre = len / 2;\n\t\tfor (int i = 0; i + len <= n; i++) {\n\t\t\tdp[i][k] = min(dp[i][k - 1], dp[i + pre][k - 1]);\n\t\t}\n\t}\n}\n\nint doit(int l, int r) {\n\tint k = to[r - l + 1];\n\tif (l > r)\n\t\treturn oo;\n\treturn min(dp[l][k], dp[r - (1 << k) + 1][k]);\n}\n\nint main() {\n#ifdef __FISH__\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\n\tinit();\n\twhile (scanf(\"%d%d%d\", &r, &c, &q) == 3 && r) {\n\t\tfor (int i = 0; i < r; i++)\n\t\t\tfor (int j = 0; j < c; j++)\n\t\t\t\tif (r <= c)\n\t\t\t\t\tscanf(\"%d\", &A[i * c + j]);\n\t\t\t\telse\n\t\t\t\t\tscanf(\"%d\", &A[j * r + i]);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tret[i] = oo;\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tscanf(\"%d\", &Q[i][j]);\n\t\t\tif (r > c) {\n\t\t\t\tswap(Q[i][0], Q[i][1]);\n\t\t\t\tswap(Q[i][2], Q[i][3]);\n\t\t\t}\n\t\t}\n\n\t\tif (r > c)\n\t\t\tswap(r, c);\n\n\t\tint cnt = (c - 1) / MaxM + 1;\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int k = 0; k < cnt; k++) {\n\t\t\t\tint lb = k * MaxM, rb = min(c, (k + 1) * MaxM);\n\t\t\t\tinit(A, i * c + lb, i * c + rb);\n\t\t\t\tfor (int j = 0; j < q; j++) {\n\t\t\t\t\tif (i >= Q[j][0] && i <= Q[j][2]) {\n\t\t\t\t\t\tret[j] = min(ret[j], doit(max(lb, Q[j][1]), min(rb - 1, Q[j][3])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tprintf(\"%d\\n\", ret[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n// library\n#include<vector>\n#include<algorithm>\n// constant\nconst int INF = 1e9;\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int find(int x1, int y1, int x2, int y2) const;\n  void print();\nprivate:\n  void update(int index, int a1, int b1, int a2, int b2, int x, int y, int value);\n  int find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const;\n  int parent(int index) const;\n  int upper_left(int index) const;\n  int upper_right(int index) const;\n  int lower_left(int index) const;\n  int lower_right(int index) const;\n  std::vector<int> node_;\n  int height_;\n  int width_;\n  int size_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) : width_(x), height_(y) {\n  size_ = 1;\n  for(int i = 1; i <= std::max(x, y); i <<= 1) size_ <<= 2;\n  node_.assign(size_, INF);\n}\n// set value on (x, y)\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, 0, width_ - 1, height_ - 1, x, y, value);\n}\nvoid SegmentTree::update(int index, int a1, int b1, int a2, int b2, int x, int y, int value) {\n  if(size_ <= index) return;\n  if(x < a1 || a2 < x) return;\n  if(y < b1 || b2 < y) return;\n  if(a1 == x && x == a2 && b1 == y && y == b2) {\n    node_[index] = value;\n    while(index) {\n      node_[parent(index)] = std::min(node_[parent(index)], node_[index]);\n      index = parent(index);\n    }\n  } else {\n    int a = (a1 + a2) >> 1;\n    int b = (b1 + b2) >> 1;\n    update(upper_left(index), a1, b1, a, b, x, y, value);\n    update(upper_right(index), a + 1, b1, a2, b, x, y, value);\n    update(lower_left(index), a1, b + 1, a, b2, x, y, value);\n    update(lower_right(index), a + 1, b + 1, a2, b2, x, y, value);\n  }\n}\n// find the minimum value in (x1, y1)-(x2, y2)\nint SegmentTree::find(int x1, int y1, int x2, int y2) const {\n  return find(0, 0, 0, width_ - 1, height_ - 1, x1, y1, x2, y2);\n}\nint SegmentTree::find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const {\n//   for(int i=0;i<(index-1)>>2;++i)cout<<\" \";\n//   cout<<\"*\"<<index<<\"* \"<<a1<<\" \"<<b1<<\" \"<<a2<<\" \"<<b2<<endl;\n  if(size_ <= index) return INF;\n  if(x2 < a1 || a2 < x1) return INF;\n  if(y2 < b1 || b2 < y1) return INF;\n  if(x1 <= a1 && a2 <= x2 && y1 <= b1 && b2 <= y2) return node_[index];\n  int a = (a1 + a2) >> 1;\n  int b = (b1 + b2) >> 1;\n  int ul = find(upper_left(index), a1, b1, a, b, x1, y1, x2, y2);\n  int ur = find(upper_right(index), a + 1, b1, a2, b, x1, y1, x2, y2);\n  int ll = find(lower_left(index), a1, b + 1, a, b2, x1, y1, x2, y2);\n  int lr = find(lower_right(index), a + 1, b + 1, a2, b2, x1, y1, x2, y2);\n  return std::min({ul, ur, ll, lr});\n}\n// debug\nvoid SegmentTree::print() {\n  for(auto i: node_) cout<<\" \"<<i;cout<<endl;\n}\n// position\nint SegmentTree::parent(int index) const {return (index - 1) >> 2;}\nint SegmentTree::upper_left(int index) const {return (index << 2) + 1;}\nint SegmentTree::upper_right(int index) const {return (index << 2) + 2;}\nint SegmentTree::lower_left(int index) const {return (index << 2) + 3;}\nint SegmentTree::lower_right(int index) const {return (index << 2) + 4;}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n//     tree.print();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.find(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ninline int MIN(int a,int b){\n\treturn a<b?a:b;\n}\nint st[17][101000];\nshort tlog[101000];\nint p[1010000],r,c,q;\nvoid ST(int fg,int s){\n\t//st[0][i]=num[i];\n\tint sz;\n\tif(fg) {\n\t\tsz=c;\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tst[0][j]=p[(s-1)*c+j];\n\t\t}\n\t} else {\n\t\tsz=r;\n\t\tfor(int j=1;j<=r;j++){\n\t\t\tst[0][j]=p[(j-1)*c+s];\n\t\t}\n\t}\n\tfor(int j=1;j<=tlog[sz];j++){\n\t\tfor(int i=0;j<=tlog[sz+1-i];i++){\n\t\t\tif(j>16) while(1);\n\t\t\tst[j][i]=MIN(st[j-1][i],st[j-1][i+(1<<j>>1)]);\n\t\t}\n\t}\n}\nint RMQ(int l,int r){\n    int tmp=tlog[r-l+1];\n    return MIN(st[tmp][l],st[tmp][r-(1<<tmp)+1]);\n}\nvoid scanf_(int &num){\n\tchar in;\n\tbool neg=false;\n\twhile(((in=getchar())>'9'||in<'0')&&in!='-');\n\tif(in=='-'){\n\t\tneg=true;\n\t\twhile((in=getchar())>'9'||in<'0');\n\t}\n\tnum=in-'0';\n\twhile(in=getchar(),in>='0'&&in<='9')\n\t\tnum*=10,num+=in-'0';\n\tif(neg)\n\tnum=0-num;\n}\nstruct node{\n\tint r1,r2,c1,c2;\n\tnode(){}\n\tnode(int a,int b,int c,int d):r1(a),c1(b),r2(c),c2(d){}\n}f[11000];\nint res[11000];\nint r1,r2,c1,c2;\nint main(){\n\ttlog[0]=-1;\n\tfor(int i=1;i<101000;i++){\n\t\ttlog[i]=tlog[i-1]+((i&(i-1))?0:1);\n\t}\n\twhile(scanf(\"%d%d%d\",&r,&c,&q),(r||c||q)) {\n\t\tfor(int i=1;i<=r;i++) {\n\t\t\tfor(int j=1;j<=c;j++) scanf_(p[(i-1)*c+j]);\n\t\t}\n\t\tfor(int i=0;i<=q;i++) res[i]=2147483647;\n\t\tif(r<=c) {\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tf[i]=node(r1,c1,r2,c2);\n\t\t\t}\n\t\t\tfor(int i=1;i<=r;i++){\n\t\t\t\tST(1,i);\n\t\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\t\tif(f[j].r1<=i&&f[j].r2>=i)\n\t\t\t\t\tres[j]=min(res[j],RMQ(f[j].c1,f[j].c2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++) printf(\"%d\\n\",res[i]);\n\t\t} else {\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tf[i]=node(r1,c1,r2,c2);\n\t\t\t}\n\t\t\tfor(int i=1;i<=c;i++){\n\t\t\t\tST(0,i);\n\t\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\t\tif(f[j].c1<=i&&f[j].c2>=i)\n\t\t\t\t\tres[j]=min(res[j],RMQ(f[j].r1,f[j].r2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++) printf(\"%d\\n\",res[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(rs);\n    int cs=sqrt(cs);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 0x7fffffff;\nconst double EPS = 1e-10;\n\n\nconst int sz = 1000010;\n\nint field[sz];\nint dat[sz * 20];\nint R, C, Q;\n#define DAT(kr, kc) dat[(kr) * C * 4 + (kc)]\n\nvoid build(int lr = 0, int rr = R,\n           int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr - lr == 0 || rc - lc == 0){\n    DAT(kr, kc) = INF;\n  }else if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = field[lr * C + lc];\n  }else{\n    if(r_axis){\n      int mr = (lr + rr) / 2;\n      build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n      build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n      DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    }else{\n      int mc = (lc + rc) / 2;\n      build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n      build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n      DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n    }\n  }\n}\n\nint query(int ar, int br, int ac, int bc,\n          int lr = 0, int rr = R, int lc = 0, int rc = C,\n          int kr = 0, int kc = 0, bool r_axis = true){\n  \n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc) return INF;\n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc) return DAT(kr, kc);\n  \n  if(r_axis){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\n\nint main(){\n  int r1, r2, c1, c2;\n\n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &field[r * C + c]);\n\n    build();\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%d\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&mi<latte[(y2-1)/B])y2=(y2%B?y2/B*B:y2-1);\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&mi<malta[x1/B])x1=(x1/B+1)*B;\n\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&mi<malta[(x2-1)/B])x2=(x2%B?x2/B*B:x2-1);\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nstruct segtree {\n\tbool isgrid;\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\tint l, r, u, d;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l_, const int r_, const int u_, const int d_) :l(l_), r(r_), u(u_), d(d_) {\n\t\tif (l + 1 == r&&u + 1 == d) {\n\t\t\tisgrid = true;\n\t\t\tminnum = vs[u][l];\n\t\t}\n\t\telse {\n\t\t\tisgrid = false;\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int ql,const int qr,const int qu,const int qd) {\n\t\tif (r<=ql||qr <= l)return 1e9;\n\t\telse if (d<= qu|| qd <= u)return 1e9;\n\t\tif (ql <= l&&r <= qr&&qu <= u&&d <= qd)return minnum;\n\t\tint aa = a->query(ql, qr, qu, qd);\n\t\tint ab = b->query(ql, qr, qu, qd);\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint r, c, q; cin >> r >> c >> q;\n\t\tif (!r)break;\n\t\tvector<vector<int>>vs(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; ++i) {\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, c, 0, r);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct treetype{\n\tlong l,r,ll,rr,min;\n}treetype;\ntreetype tree[3000005];\nlong r,c,q,i,j,c1,c2,r1,r2,ans,top,dd;\nbool ok;\nlong a[1000005];\nlong start[1000005];\nlong min(long a,long b){\n\treturn a<b?a:b;\n}\nvoid maketree(long i,long l,long r)\n{\n  long mid,lson,rson;\n  tree[i].l=l;tree[i].r=r;\n  tree[i].min=0;\n  if (l==r){\n  \t  tree[i].min=a[dd];\n  \t  dd++;\n\t\treturn;\n  }\n  mid=(l+r)/2;\n  top++;\n  tree[i].ll=lson=top;\n  maketree(top,l,mid);\n  top++;\n  tree[i].rr=rson=top;\n  maketree(top,mid+1,r);\n\ttree[i].min=min(tree[lson].min,tree[rson].min);  \n}\nlong count(long i,long a,long b){\n\tlong lson,rson,l,r,mid;\n\tlson=tree[i].ll;rson=tree[i].rr;l=tree[i].l;r=tree[i].r;\n\tif (l==a && r==b)\n\t  return tree[i].min;\n  mid=(l+r)/2;\n  if (a>mid)\n    return count(rson,a,b);\n  else if (b<=mid)\n    return count(lson,a,b);\n  else\n    return min(count(lson,a,mid),count(rson,mid+1,b));\n}\nint main(){\n\t//freopen(\"data.in\",\"r\",stdin);\n\t//freopen(\"data.out\",\"w\",stdout);\n\twhile (scanf(\"%ld %ld %ld\",&r,&c,&q)==3){\n\t\tif (r==0)\n\t\t  return 0;\n\t\tmemset(tree,0,sizeof(tree));\n\t\tmemset(start,0,sizeof(start));\n\t\tmemset(a,0,sizeof(a));\n\t\tif (r<=c){\n\t\t  for (i=0;i<r;i++)\n\t\t    for (j=0;j<c;j++)\n\t\t      scanf(\"%ld\",&a[i*c+j]);\n\t\t}\n\t\telse if (r>c){\n\t\t\tfor (i=0;i<r;i++)\n\t\t\t  for (j=0;j<c;j++)\n\t\t\t    scanf(\"%ld\",&a[j*r+i]);\n\t\t}\n\t\ttop=0;ok=false;\n\t\tif (r>c){\n\t\t\tint temp=r;r=c;c=temp;\n\t\t\tok=true;\n\t\t}\n\t\tdd=0;\n\t\tfor (i=0;i<r;i++){\n\t\t\ttop++;\n \t    start[i]=top;\n\t\t  maketree(top,0,c-1);\n\t\t}\n\t\tfor (i=0;i<q;i++){\n\t\t\tscanf(\"%ld %ld %ld %ld\",&r1,&c1,&r2,&c2);\n\t\t\tif (ok){\n\t\t\t\tint temp=r1;\n\t\t\t\tr1=c1;\n\t\t\t\tc1=temp;\n\t\t\t\ttemp=r2;\n\t\t\t\tr2=c2;\n\t\t\t\tc2=temp;\n\t\t\t}\n\t\t\tans=2147483647;\n\t\t\tfor (j=r1;j<=r2;j++)\n\t\t    ans=min(ans,count(start[j],c1,c2));\n      printf(\"%ld\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = INT_MAX;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nint data[2 * 2 * 2 * 1000100];\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[1000100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    bool doswap = false;\n    if(H > W) {\n      doswap = true;\n      swap(H, W);\n    }\n    Grid g;\n    if(doswap) {\n      REP(y,W) REP(x,H) {\n        int v; cin >> v;\n        g.update(x, y, v);\n      }\n    }\n    else {\n      REP(y,H) REP(x,W) {\n        int v; cin >> v;\n        g.update(y, x, v);\n      }\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      if(doswap) {\n        swap(x1, y1);\n        swap(x2, y2);\n      }\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n??\nusing namespace std;\n??\n#define INF ((1LL<<31)-1)\n#define D 10\n??\nstruct SegTree {\n????????int segSize, realSegSize, nodeSize;\n int sz;\n int *seg;\n????????void init(int n) {\n????????????????realSegSize = n;\n??\n????????????????nodeSize = 0;\n????????????????for (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n??\n  sz = nodeSize+n;\n  seg = new int[sz];\n  for(int i = 0 ; i < sz ; i++) seg[i] = INF;\n????????}\n??\n????????int get(int n) {\n????????????????if (n < sz) return seg[n];\n????????????????else return INF;\n????????}\n????????void set(int n, int v) {\n????????????????if (n < sz) seg[n] = v;\n????????}\n??\n????????void update(int pos, int val) {\n????????????????int n = nodeSize + pos;\n????????????????set(n, val);\n????????????????while (n) {\n????????????????????????n = (n-1)/D;\n??\n????????????????????????int r = INF;\n????????????????????????for (int i = 0; i < D; ++i) {\n????????????????????????????????r = min(r, seg[n*D+i+1]);\n????????????????????????}\n????????????????????????set(n, r);\n????????????????}\n????????}\n????????int get(int n, int l, int r, int L, int R) {\n//?????????? cout << n << \" \" << l << \" \" << r << endl;\n????????????????if (L <= l && r <= R) return get(n);\n????????????????else if (R <= l || r <= L) return INF;\n????????????????else {\n????????????????????????int ret = INF;\n????????????????????????int prev = l;\n????????????????????????for (int i = 0; i < D; ++i) {\n????????????????????????????????int next = i == D-1 ? r : prev + (r-l)/D;\n????????????????????????????????ret = min(ret, get(n*D+i+1, prev, next, L, R));\n????????????????????????????????prev = next;\n????????????????????????}\n????????????????????????return ret;\n????????????????}\n????????}\n????????int get(int L, int R) {\n????????????????return get(0, 0, segSize, L, R);\n????????}\n??\n????????~SegTree() {\n  \t\tdelete seg;\n????????}\n};\n??\nstruct Query {\n????????int y1, x1, y2, x2;\n};\n??\nint main() {\n????????int H, W, Q;\n????????while ( cin >> H >> W >> Q, H || W || Q ) {\n????????????????vector< vector<int> > m(H, vector<int>(W, 0));\n??\n????????????????for (int y = 0; y < H; ++y) {\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????cin >> m[y][x];\n????????????????????????}\n????????????????}\n??\n????????????????bool isSegRow = H < W;\n????????????????vector<SegTree*> seg;\n??\n????????????????if (isSegRow) {\n????????????????????????seg.resize(H);\n????????????????????????for (int y = 0; y < H; ++y) {\n????????????????????????????????seg[y] = new SegTree();\n    seg[y]->init(W);\n????????????????????????}\n????????????????}\n????????????????else {\n????????????????????????seg.resize(W);\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????seg[x] = new SegTree();\n    seg[x]->init(H);\n????????????????????????}\n????????????????}\n??\n????????????????for (int y = 0; y < H; ++y) {\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????if (isSegRow) seg[y]->update(x, m[y][x]);\n????????????????????????????????else seg[x]->update(y, m[y][x]);\n????????????????????????}\n????????????????}\n??\n????????????????for (int t = 0; t < Q; ++t) {\n????????????????????????int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n??\n????????????????????????int ans = INF;\n????????????????????????if (isSegRow) {\n????????????????????????????????for (int y = y1; y <= y2; ++y) {\n????????????????????????????????????????ans = min(ans, seg[y]->get(x1, x2+1));\n????????????????????????????????}\n????????????????????????}\n????????????????????????else {\n????????????????????????????????for (int x = x1; x <= x2; ++x) {\n????????????????????????????????????????ans = min(ans, seg[x]->get(y1, y2+1));\n????????????????????????????????}\n????????????????????????}\n????????????????????????cout << ans << endl;\n????????????????}\n  for(int i = 0 ; i < seg.size() ; i++) delete seg[i];\n\n????????}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint len[1001000];\n\nint min(const int &a,const int &b)\n{\n    if (a<b) return a;else return b;\n}\n\n\nint mi[1001000][21];\n\nstruct RMQ\n{\n    void rmq(int * d, int N)\n    {\n        int M=len[N];\n        for (int i=0;i<N;i++) mi[i][0]=d[i];\n        for (int g=1;g<=M;g++)\n        {\n            int L=N-(1<<g);\n            for (int i=0;i<=L;i++)\n                mi[i][g]=min( mi[i][g-1] , mi[i+(1<<(g-1))][g-1] );\n        }\n    }\n    int query(int &a, int &b)\n    {\n        int g=len[b-a+1];\n        return min(mi[a][g],mi[b-(1<<(g))+1][g]);\n    }\n}aa;\n\nint a[1100000];\nint r1[11000],r2[11000],c1[11000],c2[11000];\nint ans[11000];\nlong long numinf;\nint inf;\nint m,n,q;\nvector <vector <int> > c;\nvector <int > wh0;\n\nint main()\n{\n    for (int L=1;L<=1000000;L++) len[L]=int (log(L*1.0)/log(2.0));\n    numinf=1;\n    for (int k=1;k<=31;k++) numinf*=2LL;\n    numinf=numinf-1;\n    inf=numinf;\n\n   // freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&m,&q);\n    while (n+m+q!=0)\n    {\n        c.clear();\n        int wh;\n        for (int i=0;i<n;i++)\n        {\n            c.push_back(wh0);\n            c[i].clear();\n            for (int j=0;j<m;j++)\n            {\n                scanf(\"%d\",&wh);\n                c[i].push_back(wh);\n            }\n        }\n        int rv=0;\n        if (n>m) rv=1;\n        if (n>m) swap(n,m);\n        if (rv==0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                a[i*m+j]=c[i][j];\n        if (rv!=0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                a[i*m+j]=c[j][i];\n\n\n        for (int k=1;k<=q;k++)\n            scanf(\"%d%d%d%d\",&r1[k],&c1[k],&r2[k],&c2[k]);\n        for (int k=1;k<=q;k++) ans[k]=inf;\n        for (int k=1;k<=q;k++)\n        if (rv)\n        {\n               swap(r1[k],c1[k]);\n               swap(r2[k],c2[k]);\n        }\n        int temp;\n        for (int i=0;i<n;i++)\n        {\n            aa.rmq(a+i*m,m);\n            for (int k=1;k<=q;k++)\n                if (r1[k]<=i&&i<=r2[k])\n                {\n                    temp=aa.query(c1[k],c2[k]);\n                    if (temp<ans[k]) ans[k]=temp;\n                }\n        }\n        for (int k=1;k<=q;k++)\n            printf(\"%d\\n\",ans[k]);\n        scanf(\"%d%d%d\",&n,&m,&q);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int map[1000000];\n  int rmq[2000];\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int rr,rc;\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    rr = (int)sqrt(r);\n    rc = (int)sqrt(c);\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> map[i*c+j];\n    }\n\n    for(int i=0;i<=rr;i++){\n      for(int j=0;j<=rc;j++){\n\trmq[i*(rc+1)+j] = 1<<31 - 1;\n\tint ur = min( (i+1)*rr, r);\n\tfor(int k=i*rr;k<ur;k++){\n\t  int uc = min( (j+1)*rc, c);\n\t  for(int l=j*rc;l<uc;l++){\n\t    rmq[i*(rc+1)+j] = min(rmq[i*(rc+1)+j],map[k*c+l]);\n\t  }\n\t}\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int tr1,tc1,tr2,tc2;\n      tr1 = r1/rr;\n      if(r1%rr)tr1++;\n      tc1 = c1/rc;\n      if(c1%rc)tc1++;\n      tr2 = r2/rr;\n      if(r2%rr)tr2--;\n      tc2 = c2/rc;\n      if(c2%rc)tc2--;\n\n      int m = 1<<31 - 1;\n      for(int i=r1;i<tr1*rr;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n      for(int i=tr2*rr;i<=r2;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n      for(int i=tr1*rr;i<tr2;i++){\n\tfor(int j=c1;j<tc1*rc;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n\tfor(int j=tc2*rc;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n\n      for(int i=tr1;i<tr2;i++){\n\tfor(int j=tc1;j<tc2;j++){\n\t  m = min(m,rmq[i*(rc+1)+j]);\n\t}\n      }\n      cout << m << endl;\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    if(h>w)w=h;\n    if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        if(dat[k*2+1]!=-1&&dat[k*2+1]<dat[k*2+2])dat[k]=dat[k*2+1];\n        else dat[k]=dat[k*2+2];\n        //        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr!=-1&&vl>vr)\n        return vr;\n    return vl;\n    // Å¬lðÔ·\n    //return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",(int)res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W;\n\tvector<vector<int>> dat;\n\tsegtree() {}\n\tsegtree(vector<vector<int>> &f) {\n\t\tinit(f);\n\t}\n\tvoid init(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tdat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[i + H - 1][j + W - 1] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> f(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        if(dat[k*2+1]<dat[k*2+2])dat[k]=dat[k*2+1];\n        else dat[k]=dat[k*2+2];\n        //        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vl>vr)\n        return vr;\n    return vl;\n    // Å¬lðÔ·\n    //return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",(int)res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    // Å¬lðÔ·\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n//\nconst int INF = INT_MAX;\nconst int NIL = -1;\n//\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int query(int min_x, int min_y, int max_x, int max_y) const;\nprivate:\n  int update(int low_x, int low_y, int high_x, int high_y, int index, int x, int y, int value);\n  int query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const;\n  int size_x_, size_y_;\n  std::vector<int> node_;\n};\n//\nSegmentTree::SegmentTree(int x, int y) : size_x_(x), size_y_(y) {\n  while(x & x - 1) x += x & -x;\n  while(y & y - 1) y += y & -y;\n  node_.assign(x * y << 2, INF);\n}\n//\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, size_x_ - 1, size_y_ - 1, 0, x, y, value);\n}\nint SegmentTree::update(int low_x, int low_y, int high_x, int high_y, int index, int x, int y, int value) {\n  if(x < low_x || high_x < x || y < low_y || high_y < y) return node_[index];\n  if(low_x == high_x && low_y == high_y) return node_[index] = value;\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x != high_x) {\n    int l = update(low_x, low_y, middle_x, high_y, (index << 1) + 1, x, y, value);\n    int h = update(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, x, y, value);\n    return node_[index] = std::min(l, h);\n  } else {\n    int l = update(low_x, low_y, high_x, middle_y, (index << 1) + 1, x, y, value);\n    int h = update(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, x, y, value);\n    return node_[index] = std::min(l, h);\n  }\n}\n//\nint SegmentTree::query(int min_x, int min_y, int max_x, int max_y) const {\n  query(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y);\n}\nint SegmentTree::query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const {\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return INF;\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return node_[index];\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x != high_x) {\n    int l = query(low_x, low_y, middle_x, high_y, (index << 1) + 1, min_x, min_y, max_x, max_y);\n    int h = query(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  } else {\n    int l = query(low_x, low_y, high_x, middle_y, (index << 1) + 1, min_x, min_y, max_x, max_y);\n    int h = query(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  }\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*4; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tfast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//import java.util.Scanner;\nimport java.io.*;\n\nclass Rmq{\n    int segt[] = new int[(1<<21)*2];\n    public int inp[] =new int[(1<<21)];\n    int MAX_VALUE=2147483647;\n    int min(int a,int b){return a<b?a:b;}\n    int max(int a,int b){return a>b?a:b;}\n    void update(int value,int pos,int n){\n\tint index=n-1+pos;\n\tsegt[index]=value;//[pos,pos]\n\twhile(index>0){\n\t    index=(index-1)/2;\n\t    segt[index]=min(segt[index*2+1],segt[index*2+2]);\n\t}\n    }\n    int query(int l,int r,int now,int ql,int qr){\n\tif (l == ql && r == qr){\n\t    return segt[now];\n\t}\n\tint midr=(l+r)/2,midl=midr+1;\n\tint ret=MAX_VALUE;\n\tif (ql <= midr)ret=min(ret,query(l,midr,now*2+1,ql,min(qr,midr)));\n\tif (midl <= qr)ret=min(ret,query(midl,r,now*2+2,max(midl,ql),qr));\n\treturn ret;\n    }\n\n    public void init(int r,int c,int lim){\n\tboolean isrowmajor=r<=c;\n\tfor(int i=0;i<lim;i++){\n\t    segt[i]=MAX_VALUE;\n\t}\n\tif (isrowmajor){\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i*c+j],i*c+j,lim);\n\t\t}\n\t    }\n\t}else {\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i+j*r],i+j*r,lim);\n\t\t}\n\t    }\n\t}\n    }\n    int searchmin(int r1,int c1,int r2,int c2,int r,int c,int lim){\n\tboolean isrowmajor = r<=c;  \n\tint ret=MAX_VALUE;\n\tlim--;\n\tif (isrowmajor){\n\t    for(int i=r1;i<=r2;i++){\n\t\tret=min(ret,query(0,lim,0,i*c+c1,i*c+c2));\n\t    }\n\t}else {\n\t    for(int j=c1;j<=c2;j++){\n\t\tret=min(ret,query(0,lim,0,j*r+r1,j*r+r2));\n\t    }\n\t}\n\treturn ret;\n    }    \n\n}\n\nclass Main{\n    void run(){\n\tScanner in = new Scanner();\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint r,c,q;\n\tRmq rmq=new Rmq();\n\twhile(true){\n\t    r=in.nextInt();\n\t    c=in.nextInt();\n\t    q=in.nextInt();\n\t    if (r == 0)break;\n\t    int lim=1;\n\t    boolean isrowmajor = r<=c;\n\t    while(true){\n\t\tif (lim >= r*c)break;\n\t\tlim*=2;\n\t    }\n\t    if (isrowmajor){\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i*c+j]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }else {\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i+j*r]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }\n\t    rmq.init(r,c,lim);\n\t    for(int i=0;i<q;i++){\n\t\tint r1,r2,c1,c2;\n\t\tr1=in.nextInt();\n\t\tc1=in.nextInt();\n\t\tr2=in.nextInt();\n\t\tc2=in.nextInt();\n\t\tSystem.out.println(rmq.searchmin(r1,c1,r2,c2,r,c,lim));\n\t    }\n\t}\n    }\n    public static void main(String args[]){\n\tMain a = new Main();\n\ta.run();\n    }\n}\n\n\nclass Scanner {\n    int nextInt() {\n        try {\n            int c = System.in.read();\n            if (c == -1)\n                return c;\n            while (c != '-' && (c < '0' || '9' < c)) {\n                c = System.in.read();\n                if (c == -1)\n                    return c;\n            }\n            if (c == '-')\n                return -nextInt();\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    long nextLong() {\n        try {\n            int c = System.in.read();\n            if(c==-1)return -1;\n            while (c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c==-1)return -1;\n            }\n            if (c == '-')\n                return -nextLong();\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n    String next() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (Character.isWhitespace(c))\n                c = System.in.read();\n            do {\n                res.append((char) c);\n            } while (!Character.isWhitespace(c = System.in.read()));\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n \n    String nextLine() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (c == '\\r' || c == '\\n')\n                c = System.in.read();\n            do {\n                res.append((char) c);\n                c = System.in.read();\n            } while (c != '\\r' && c != '\\n');\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\nint r,cc,q,t;\nint a,b,c,d;\nint main(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        init(r,cc);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint _query(int G, int &x1, int &x2, int k = 0, int l = 0, int r = wbin)\n{\n\tif (x2 <= l || r <= x1) return (INT_MAX);\n\tif (x1 <= l && r <= x2) return (seg[G][k]);\n\t\n\tint lval = _query(G, x1, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(G, x1, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int &y1, int &x1, int &y2, int &x2, int k = 0, int l = 0, int r = hbin)\n{\n\tif (y2 <= l || r <= y1) return (INT_MAX);\n\tif (y1 <= l && r <= y2) return (_query(k, x1, x2));\n\t\n\tint lval = query(y1, x1, y2, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(y1, x1, y2, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query(y1, x1, ++y2, ++x2));\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct SegTree {\n\tint segSize;\n\tint seg[1 << 11];\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tfill(&seg[0], &seg[0]+segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tSegTree s;\n\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=50;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y1][j]);\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j)mi=min(mi,fld[y2][j]);\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i)mi=min(mi,fld[i][x1]);\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i)mi=min(mi,fld[i][x2]);\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            for(int j=bx1;j<bx2;++j)\n                mi=min(mi,bucket[by1][j]);\n\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W;\n\tvector<vector<int>> dat;\n\tsegtree(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tdat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));\n\t\tinit(f);\n\t}\n\tvoid init(vector<vector<int>> &f) {\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[i + H - 1][j + W - 1] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> f(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = (1 << 23);\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int dat[MAX];    \n\n    int c(int i, int j)\n    {\n        return i * (2 * W - 1) + j;\n    }\n    \n    void init(int h, int w, vector<int>& grid)\n    {        \n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        \n        for (int i = 0; i < 2 * H - 1; i++) {        \n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[c(i, j)] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[c(i + H - 1, j + W - 1)] = grid[i * w + j];\n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[c(i, j)] = min(dat[c(i, j * 2 + 1)],\n                                   dat[c(i, j * 2 + 2)]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[c(j, i)] = min(dat[c(j * 2 + 1, i)],\n                                   dat[c(j * 2 + 2, i)]);\n            }\n        }\n    }\n\n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[c(j, k)];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nRMQ2D r;\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        vector<int> grid(H * W);\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i * W + j];\n            }\n        }\n        r.init(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << r.query(y1, x1, y2, x2) << endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1000000;\n\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n,dat[2*MAX_N-1];\nint h,w;\nconst int INF=100000000;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    w=h;\n    while(w<w_)w*=2;\n    h=w;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy,bool isHor){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx)return INF;\n    else if(qmaxy<miny||maxy<qminy)return INF;\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ¡ñ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY,!isHor);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy,!isHor);\n    }\n    // c\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy,!isHor);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy,!isHor);\n    }\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*c+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1,true);\n            cout<<res<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nbool swaped;\n\nstruct Pool {\n    static dat_t dat[250000*3];\n    static int end;\n    static dat_t * fetch(int size){\n        dat_t * res = dat + end;\n        end+=size;\n        return res;\n    }\n    static void reset(){\n        end = 0;\n    }\n};\n\nint Pool::end = 0;\ndat_t Pool::dat[250000*3];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        if(swaped) swap(x,y);\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        if(r>c) swaped = true;\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=(1<<31)-1;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvector< vector<int> > a(h,vector<int>(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tint h2=(int)(sqrt(h)+1),w2=(int)(sqrt(w)+1);\n\t\tvector< vector<int> > a2(h2,vector<int>(w2,INF));\n\t\trep(i,h2) rep(j,w2) {\n\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\tfor(int y=t2;y<b2;y++) for(int x=l2;x<r2;x++) {\n\t\t\t\ta2[i][j]=MIN(a2[i][j],a[y][x]);\n\t\t\t}\n\t\t}\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\trep(i,h2) rep(j,w2) {\n\t\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\t\tif(t<=t2 && b2<b && l<=l2 && r2<r){\n\t\t\t\t\tans=MIN(ans,a2[i][j]);\n\t\t\t\t}\n\t\t\t\telse if(b<=t2 || b2<=t || r<=l2 || r2<=l);\n\t\t\t\telse{\n\t\t\t\t\tfor(int y=MAX(t,t2);y<MIN(b,b2);y++){\n\t\t\t\t\t\tfor(int x=MAX(l,l2);x<MIN(r,r2);x++){\n\t\t\t\t\t\t\tans=MIN(ans,a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    fill_n(*bucket,(H/B+1)*(W/B+1),INT_MAX);\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        //if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        //if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst int INF = INT_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 8000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return INT_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint _query(int &G, int &x1, int &x2, int k = 0, int l = 0, int r = wbin)\n{\n\tif (x2 <= l || r <= x1) return (INT_MAX);\n\tif (x1 <= l && r <= x2) return (seg[G][k]);\n\t\n\tint lval = _query(G, x1, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(G, x1, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int &y1, int &x1, int &y2, int &x2, int k = 0, int l = 0, int r = hbin)\n{\n\tif (y2 <= l || r <= y1) return (INT_MAX);\n\tif (y1 <= l && r <= y2) return (_query(k, x1, x2));\n\t\n\tint lval = query(y1, x1, y2, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(y1, x1, y2, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query(y1, x1, ++y2, ++x2));\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\ntypedef long long LL;\nconst int oo = 0x7fffffff;\nconst int Max = 1048576;\nconst int MaxN = 15;\nconst int MaxLg = 16;\nint A[Max],Log[MaxN+1],tableMin[MaxN][MaxLg];\nvoid makeRMinQ(int *a,int s,int t){\n\tint i,j,n = t-s;\n\tfor (i = s;i < t;i++) tableMin[i-s][0] = a[i];\n\t//for (i = s;i < t;i++)printf(\"%d \",a[i]);puts(\"\");\n\tfor (j = 1;(1 << j) <= n;j++)\n\t\tfor (i = s;i+(1 << j) <= t;i++)\n\t\t\ttableMin[i-s][j] = min(tableMin[i-s][j-1],tableMin[i-s+(1 << (j-1))][j-1]);\n}\nint QueryMin(int x,int y){\n\tint p = Log[y-x+1];//calLog2(y-x+1);\n    //printf(\"%d %d=> %d %d\\n\",x,y,y-x+1,p);\n\treturn min(tableMin[x][p],tableMin[y-(1 << p)+1][p]);\n}\nconst int MaxQ = 10010;\nstruct query{\n    int x1,y1,x2,y2;\n};\nquery fQ[MaxQ];\nint Res[MaxQ];\nint main(){\n\tfor (int i = 0,x = 0,cd = 2;i <= MaxN;x++,cd<<=1)\n\t\twhile (i <= MaxN && i < cd)\n\t\t    Log[i++] = x;\n    for (int R,C,Q;scanf(\"%d%d%d\",&R,&C,&Q) && R;){\n        if (R <= C){\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[i*C+j]);\n            for (int q = 0;q < Q;q++)\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n        }else{\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[j*R+i]);\n            swap(R,C);\n            for (int q = 0;q < Q;q++){\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n                swap(fQ[q].x1,fQ[q].y1);\n                swap(fQ[q].x2,fQ[q].y2);\n            }\n        }\n//        for (int i = 0;i < R;i++)\n//            for (int j = 0;j < C;j++)\n//                A[i*C+j] = rand();\n//        for (int q = 0;q < Q;q++){\n//            int x1 = rand() % R;\n//            int x2 = rand() % R;\n//            int y1 = rand() % C;\n//            int y2 = rand() % C;\n//            if (x1 > x2) swap(x1,x2);\n//            if (y1 > y2) swap(y1,y2);\n//            fQ[q].x1 = x1;\n//            fQ[q].y1 = y1;\n//            fQ[q].x2 = x2;\n//            fQ[q].y2 = y2;\n//        }\n        for (int q = 0;q < Q;q++)\n            Res[q] = oo;\n        //for (int q = 0;q < Q;q++)printf(\"(%d,%d)-(%d,%d)\\n\",fQ[q].x1,fQ[q].y1,fQ[q].x2,fQ[q].y2);\n        int fC = (C-1) / MaxN+1;\n        for (int i = 0;i < R;i++){\n            for (int j = 0,k = 0;j < fC;j++){\n                int nk = min(C,k+MaxN);\n                //printf(\"add %d [%d,%d): \",i,k,nk);\n                makeRMinQ(A,i*C+k,i*C+nk);\n                for (int q = 0;q < Q;q++){\n                    if (i < fQ[q].x1 || fQ[q].x2 < i)\n                        continue;\n                    int cs = max(fQ[q].y1,k);\n                    int ct = min(fQ[q].y2,nk-1);\n                    if (cs > ct) continue;\n                    //printf(\"%d : (%d,%d) %d\\n\",q,cs,ct,QueryMin(cs-k,ct-k));\n                    Res[q] = min(Res[q],QueryMin(cs-k,ct-k));\n                }\n                k = nk;\n            }\n        }\n//        for (int q = 0;q < Q;q++){\n//            int x1 = fQ[q].x1;\n//            int y1 = fQ[q].y1;\n//            int x2 = fQ[q].x2;\n//            int y2 = fQ[q].y2;\n//            int cr = oo;\n//            for (int i = x1;i <= x2;i++)\n//                for (int j = y1;j <= y2;j++)\n//                    cr = min(cr,A[i*C+j]);\n//            if (cr != Res[q]){\n//                printf(\"Fail!!\\n\");\n////                for (int i = 0;i < R;i++){\n////                    for (int j = 0;j < C;j++)\n////                        printf(\"%d \",A[i*C+j]);\n////                    puts(\"\");\n////                }\n//                printf(\"%d %d %d %d\\n\",x1,y1,x2,y2);\n//                printf(\"=> %d %d\\n\",cr,Res[q]);\n//                while (1);\n//            }\n//        }\n//        puts(\"ok\");\n//        for (int i = 0;i < R;i++){\n//            for (int j = 0;j < C;j++)\n//                printf(\"%d \",A[i*C+j]);\n//            puts(\"\");\n//        }\n        for (int q = 0;q < Q;q++)\n            printf(\"%d\\n\",Res[q]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W;\nvector<vi> g;\n \nint rec(int y1, int x1, int y2, int x2,\n int Y1, int X1, int Y2, int X2, int y, int x){\n\t\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\t\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X1 <= x2) return g[y][x];\n\t\tint res = inf;\n\t\t \n\t\tif(y < 0 || x < 0) assert(0);\n\t\tif(Y1+1 == Y2)\n\t\t\t\tres = min(res,\n\t\t\t\t\t\tmin(\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t\t\t\t));\n\t\telse if(X1+1 == X2)\n\t\t\t\tres = min(res,\n\t\t\t\tmin(\n\t\t\t\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t\t));\n\t\telse{\n\t\t\t\tres = min(res,\n\t\t\t\t\t\tmin(\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t\t\t\t));\n\t\t\t\tres = min(res,\n\t\t\t\t\t\tmin(\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\t\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t\t\t\t));\n\t\t}\n\t\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", &g[i+H-1][j+W-1]);\n\t\t\n\t\tfor(int i = H-1; ; i--){\n\t\t\t\tfor(int j = W-1; ;j--){\n\t\t\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\t\tg[i][j] = min(min(g[i*2+1][j*2+1], g[i*2+2][j*2+2]),\n\t\t\t\t\t\t\t\tmin(g[i*2+2][j*2+1], g[i*2+1][j*2+2]));\n\t\t\t\t\t\tif(i < H-1) \n\t\t\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i*2+1][j], g[i*2+2][j]));\n\t\t\t\t\t\tif(j < W-1)\n\t\t\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2+1], g[i][j*2+2]));\n\t\t\t\t\t\tif(j == 0) break;\n\t\t\t\t}\n\t\t\t\tif(i == 0) break;\n\t}\n\t\trep(i, q){\n\t\t\t\tint y1, y2, x1, x2;\n\t\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\t\tprintf(\"%d\\n\", rec(y1, x1, y2+1, x2+1, 0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int maxn=1500032;\n\nint mm[maxn*4];\nint aa[maxn];\nint S, inf, L, r1, c1, r2, c2;\nvoid init(int s, int x, int l, int r)\n{\n\tif (s==0) if (s+x>S) S=s+x;\n\tif (l==r) { mm[s+x]=aa[l]; //printf(\"ll %d %d \\n\", l, aa[l]); \n\treturn ; }\n    int m=(l+r)>>1;\n\tinit(s, x*2, l, m); init(s, x*2+1, m+1, r);\n\tmm[s+x]=min(mm[s+x*2], mm[s+x*2+1]);\n    //printf(\"nb %d %d\\n\", s+x, mm[s+x]);\n}\n\nint query(int s, int x, int l, int r, int L, int R)\n{\n\tif (L<=l && r<=R) return  mm[s+x];\n\tint m=(l+r)>>1;\n\tint ans=inf;\n\tif (L<=m) ans=min(ans, query(s, 2*x, l, m, L, R));\n\tif (R>=m+1) ans=min(ans, query(s, 2*x+1, m+1, r, L, R)); \n    return ans;\n}\n\nint r, c, q;\nint main() \n{\n    while (scanf(\"%d %d %d\", &r, &c, &q)!=-1)\n\t{\n\t\tif (r==0 && c==0 && q==0) break;\n\t    for (int i=0; i<r; i++) \n\t\t\tfor (int j=0; j<c; j++)\n\t\tif (r<=c) scanf(\"%d\", &aa[i*c+j+1]); else scanf(\"%d\", &aa[j*r+i+1]); \n\t\t//puts(\"aa\");\n        inf=0;\n\t\tfor (int i=1; i<=r*c; i++) \n\t\t{\n\t\t\tinf=max(inf, aa[i]);\n\t\t    //printf(\"list %d %d\\n\", i, aa[i]);\n\t\t}\n\t\tif (r<=c)\n\t\t{\n\t\t\tS=0;\n\t\t\tL=c;\n\t\t\tinit(0, 1, 1, c);\n\t\t\t//printf(\"%d %d\\n\", mm[1], S);\n            for (int i=2; i<=r; i++)\n\t\t\t{\n\t\t\t\tinit(S*(i-1), 1, 1+(i-1)*L, i*L);\n\t\t        //printf(\"%d\\n\", mm[S*(i-1)+1]);\n            }\n\t\t} else\n\t\t{\n\t\t\tS=0;\n\t\t\tL=r;\n\t\t\tinit(0, 1, 1, r);\n\t\t\tfor (int i=2; i<=c; i++)\n\t\t\t{\n\t\t\t\tinit(S*(i-1), 1, 1+(i-1)*L, i*L);\n\t\t\t}\n\t\t}\n        //puts(\"bb\");\n\t    while (q--)\n\t\t{\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            r1++; r2++; c1++; c2++;\n\t\t\t//printf(\"%d %d %d %d\\n\", r1, c1, r2, c2);\n\t\t\tint ans=inf;\n\t\t\tif (r<=c)\n\t\t\t{\n\t\t\t\tfor (int i=r1; i<=r2; i++)\n\t\t\t\t{\n\t\t\t\t\tans=min(ans, query(S*(i-1), 1, 1+(i-1)*L, i*L, c1+(i-1)*L, c2+(i-1)*L));  \n\t\t\t\t//    printf(\"%d\\n\", ans);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tfor (int i=c1; i<=c2; i++)\n\t\t\t\t{\n\t\t\t\t\t//for (int j=r1+(i-1)*L; j<=r2+(i-1)*L; j++)\n\t\t\t\t\t//\tprintf(\"%d %d\\n\", j, aa[j]); \n\t\t\t\t\tans=min(ans, query(S*(i-1), 1, 1+(i-1)*L, i*L, r1+(i-1)*L, r2+(i-1)*L));  \n\t\t\t\t    //printf(\"eee %d\\n\", query(S*(i-1), 1, 1+(i-1)*L, i*L, r1+(i-1)*L, r2+(i-1)*L));  \n\t\t\t\t    //printf(\"%d\\n\", ans);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n4 2 10\n1 2\n2 1\n0 7\n1 2\n1 0 2 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tvector<T> a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector< vector<T> > &v,int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=v[0].size();\n\t\telse   N=v.size();\n\n\t\twhile(n<N) n<<=1;\n\t\ta=vector<T>(2*n-1);\n\n\t\tif(!b) rep(i,N) a[n+i-1]=v[k][i];\n\t\telse   rep(i,N) a[n+i-1]=v[i][k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tvector< RMQ<int> > rmq1(h);\n\t\tvector< RMQ<int> > rmq2(w);\n\t\trep(i,h) rmq1[i]=RMQ<int>(a,i,0);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a,j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint r, c, q;\nint _r, _c;\nint g;\nvi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vi[2 * _r + 1];\n  rep(i, 2 * _r + 1) seg[i].resize(2 * _c + 1);\n  rep(i, 2 * _r + 1) rep(j, 2 * _c + 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int x)\n{\n\tx--;\n\trep(i,5) x|=x>>(1<<i);\n\treturn x+1;\n}\n\nstruct SegmentTree{\n\tint size;\n\tvi data;\n\tSegmentTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tSegmentTree(const vi& a):size(Need(a.size())),data(size*2,INFTY){\n\t\tcopy(all(a),data.begin()+size);\n\t\tfor(int i=size;--i;)\n\t\t\tdata[i]=min(data[i*2],data[i*2+1]);\n\t}\n\tint Get(int i){\n\t\treturn data[size+i];\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[size+i]=x;\n\t\tfor(i=(i+size)>>1;i;i>>=1)\n\t\t\tdata[i]=min(data[i*2],data[i*2+1]);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegmentTree2D{\n\tint size;\n\tvector<SegmentTree> data;\n\tSegmentTree2D(int h,int w):size(Need(h)),data(size*2,SegmentTree(w)){}\n\tSegmentTree2D(const vvi& a):size(Need(a.size())),data(size*2,SegmentTree(a[0].size())){\n\t\trep(i,a.size()) data[size+i]=SegmentTree(a[i]);\n\t\tfor(int i=size;--i;)\n\t\t\trepi(j,1,data[i].data.size())\n\t\t\t\tdata[i].data[j]=min(data[i*2].data[j],data[i*2+1].data[j]);\n\t}\n\tint Get(int i,int j){\n\t\treturn data[size+i].Get(j);\n\t}\n\tvoid Update(int i,int j,int x){\n\t\tdata[size+i].Update(j,x);\n\t\tfor(i=(i+size)>>1;i;i>>=1)\n\t\t\tdata[i].Update(j,min(data[i*2].Get(j),data[i*2+1].Get(j)));\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\tint res=INFTY,m=(to+bo)/2;\n\t\tif(a<m) res=min(res,Query(a,b,c,d,i*2+0,to,m));\n\t\tif(m<c) res=min(res,Query(a,b,c,d,i*2+1,m,bo));\n\t\treturn res;\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(min(r,c),vi(max(r,c)));\n\t\tif(r<=c) rep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\telse     rep(j,r) rep(i,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q) scanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\t\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tSegmentTree2D st(grid);\n\t\t\n\t\trep(i,q)\n\t\t\tprintf(\"%d\\n\",st.Query(r1[i],c1[i],r2[i]+1,c2[i]+1));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tfor(int i=0;i<2*h-1&&rmq[i]!=emp;i++)\n\t\t\tdelete rmq[i];\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[10000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(r);\n    int cs=sqrt(c);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n//\nconst int INF = INT_MAX;\nconst int NIL = -1;\n//\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int query(int min_x, int min_y, int max_x, int max_y) const;\nprivate:\n  int update(int low_x, int low_y, int high_x, int high_y, int index, int x, int y, int value, int depth);\n  int query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int depth) const;\n  int size_x_, size_y_;\n  std::vector<int> node_;\n};\n//\nSegmentTree::SegmentTree(int x, int y) : size_x_(x), size_y_(y) {\n  while(x & x - 1) x += x & -x;\n  while(y & y - 1) y += y & -y;\n  node_.assign(x * y << 2, INF);\n}\n//\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, size_x_ - 1, size_y_ - 1, 0, x, y, value, 0);\n}\nint SegmentTree::update(int low_x, int low_y, int high_x, int high_y, int index, int x, int y, int value, int depth) {\n  if(x < low_x || high_x < x || y < low_y || high_y < y) return node_[index];\n  if(low_x == high_x && low_y == high_y) return node_[index] = value;\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    int l = update(low_x, low_y, high_x, middle_y, (index << 1) + 1, x, y, value, depth ^ 1);\n    int h = update(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, x, y, value, depth ^ 1);\n    return node_[index] = std::min(l, h);\n  }\n  if(low_y == high_y) {\n    int l = update(low_x, low_y, middle_x, high_y, (index << 1) + 1, x, y, value, depth ^ 1);\n    int h = update(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, x, y, value, depth ^ 1);\n    return node_[index] = std::min(l, h);\n  }\n  if(depth) {\n    int l = update(low_x, low_y, high_x, middle_y, (index << 1) + 1, x, y, value, depth ^ 1);\n    int h = update(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, x, y, value, depth ^ 1);\n    return node_[index] = std::min(l, h);\n  } else {\n    int l = update(low_x, low_y, middle_x, high_y, (index << 1) + 1, x, y, value, depth ^ 1);\n    int h = update(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, x, y, value, depth ^ 1);\n    return node_[index] = std::min(l, h);\n  }\n}\n//\nint SegmentTree::query(int min_x, int min_y, int max_x, int max_y) const {\n  query(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y, 0);\n}\nint SegmentTree::query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int depth) const {\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return INF;\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return node_[index];\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    int l = query(low_x, low_y, high_x, middle_y, (index << 1) + 1, min_x, min_y, max_x, max_y, depth ^ 1);\n    int h = query(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y, depth ^ 1);\n    return std::min(l, h);\n  }\n  if(low_y == high_y) {\n    int l = query(low_x, low_y, middle_x, high_y, (index << 1) + 1, min_x, min_y, max_x, max_y, depth ^ 1);\n    int h = query(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y, depth ^ 1);\n    return std::min(l, h);\n  }\n  if(depth) {\n    int l = query(low_x, low_y, high_x, middle_y, (index << 1) + 1, min_x, min_y, max_x, max_y, depth ^ 1);\n    int h = query(low_x, middle_y + 1, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y, depth ^ 1);\n    return std::min(l, h);\n  } else {\n    int l = query(low_x, low_y, middle_x, high_y, (index << 1) + 1, min_x, min_y, max_x, max_y, depth ^ 1);\n    int h = query(middle_x + 1, low_y, high_x, high_y, (index << 1) + 2, min_x, min_y, max_x, max_y, depth ^ 1);\n    return std::min(l, h);\n  }\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a)*(b+m)>6000000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint tree[16300000];\n\nvoid build(int x,int y,int num,int lx,int rx,int ly,int ry,int pos)\n{\n    if(lx==rx&&ly==ry)\n    {\n        tree[pos]=num;\n        return;\n    }\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    if(x<=midx&&y<=midy)\n    {\n        build(x,y,num,lx,midx,ly,midy,pos*4-2);\n        if(tree[pos]==-1||tree[pos*4-2]<tree[pos])\n            tree[pos]=tree[pos*4-2];\n    }\n    if(x<=midx&&y>midy&&ly!=ry)\n    {\n        build(x,y,num,lx,midx,midy+1,ry,pos*4-1);\n        if(tree[pos]==-1||tree[pos*4-1]<tree[pos])\n            tree[pos]=tree[pos*4-1];\n    }\n    if(x>midx&&y<=midy&&lx!=rx)\n    {\n        build(x,y,num,midx+1,rx,ly,midy,pos*4);\n        if(tree[pos]==-1||tree[pos*4]<tree[pos])\n            tree[pos]=tree[pos*4];\n    }\n    if(x>midx&&y>midy&&lx!=rx&&ly!=ry)\n    {\n        build(x,y,num,midx+1,rx,midy+1,ry,pos*4+1);\n        if(tree[pos]==-1||tree[pos*4+1]<tree[pos])\n            tree[pos]=tree[pos*4+1];\n    }\n //   printf(\"%d %d %d %d %d\\n\",lx,rx,ly,ry,tree[pos]);\n    return;\n}\n\nint query(int x,int y,int xx,int yy,int lx,int rx,int ly,int ry,int pos)\n{\n   // printf(\"%d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry);\n    if(x<=lx&&xx>=rx&&y<=ly&&yy>=ry)\n    {\n     //   printf(\"%d %d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry,tree[pos]);\n        return tree[pos];\n    }\n    if(lx==rx&&ly==ry)\n    {\n   //     printf(\"%d %d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry,tree[pos]);\n        return tree[pos];\n    }\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    int now=-1,temp;\n    if(x<=midx&&y<=midy)\n    {\n        temp=query(x,y,xx,yy,lx,midx,ly,midy,pos*4-2);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    if(x<=midx&&yy>midy&&ly!=ry)\n    {\n        temp=query(x,y,xx,yy,lx,midx,midy+1,ry,pos*4-1);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    if(xx>midx&&y<=midy&&lx!=rx)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,ly,midy,pos*4);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n     //   printf(\"   %d %d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry,temp,now);\n    }\n    if(xx>midx&&yy>midy&&lx!=rx&&ly!=ry)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,midy+1,ry,pos*4+1);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n  //  printf(\"%d %d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry,now);\n    return now;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out1.txt\",\"w\",stdout);\n    int n,m,q,i,j,x,y,xx,yy;\n    while(scanf(\"%d%d%d\",&n,&m,&q)==3)\n    {\n        if(!n&&!m&&!q)\n            break;\n        memset(tree,-1,sizeof(tree));\n        for(i=1;i<=n;i++)\n            for(j=1;j<=m;j++)\n            {\n                scanf(\"%d\",&x);\n                build(i,j,x,1,n,1,m,1);\n            }\n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x,&y,&xx,&yy);\n            printf(\"%d\\n\",query(x+1,y+1,xx+1,yy+1,1,n,1,m,1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#define INF INT_MAX/2\n#define def INF\nusing V = int;\nV comp(V& l, V& r) { return min(l,r); };\nstruct SegTree { //[l,r)\n    int NV;\n    vector<V> val;\n    void init(int n) {\n        NV = 1;\n        while (NV < n) NV *= 2;\n        val = vector<V>(NV * 2, def);\n    }\n    V get(int x, int y, int l, int r, int k) {\n        if (r <= x || y <= l) return def; if (x <= l&&r <= y)return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2); auto b = get(x, y, (l + r) / 2, r, k * 2 + 1); return comp(a, b);\n    }\n    V get(int x, int y) { return get(x, y, 0, NV, 1); }\n    void update(int i, V v) { i += NV; val[i] = v; while (i>1)i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]); }\n    void compupdate(int i, V v) { update(i, comp(v, val[i + NV])); }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\nstruct StaticHealthy2DSegTree {\n    int NV;\n    vector<SegTree> st;\n    vector<vector<int>> index;\n    \n    void init(vector<vector<pair<int,V>>> &v) {\n        int n = v.size();\n        NV = 1; while (NV < n) NV *= 2;\n        index.resize(2 * NV);\n        rep(i, 0, n) fore(p, v[i]) index[i + NV].push_back(p.first);\n        rrep(i, NV * 2 - 1, 1) {\n            sort(index[i].begin(), index[i].end());\n            index[i].erase(unique(index[i].begin(), index[i].end()), index[i].end());\n            fore(j, index[i]) index[i / 2].push_back(j);\n        }\n        st.resize(2 * NV);\n        rep(i, 1, NV * 2) st[i].init(index[i].size());\n        \n        rep(i, 0, n) fore(p, v[i]) {\n            int j = lower_bound(index[i + NV].begin(), index[i + NV].end(), p.first) - index[i + NV].begin();\n            st[i + NV].update(j, p.second);\n        }\n\n        rrep(i, NV * 2 - 1, 2) {\n            rep(j, 0, index[i].size()) {\n                V v = st[i][j];\n                \n                int k = lower_bound(index[i / 2].begin(), index[i / 2].end(), index[i][j]) - index[i / 2].begin();\n                st[i / 2].compupdate(k, v);\n            }\n        }\n    }\n    V get(int sx, int tx, int sy, int ty, int k, int l, int r) {\n        assert(k < NV * 2);\n        assert(l < r);\n        if (r <= sx or tx <= l) return def;\n        if (sx <= l and r <= tx) {\n            int syy = lower_bound(index[k].begin(), index[k].end(), sy) - index[k].begin();\n            int tyy = lower_bound(index[k].begin(), index[k].end(), ty) - index[k].begin();\n            return st[k].get(syy, tyy);\n        }\n        int md = (l + r) / 2;\n        V le = get(sx, tx, sy, ty, k * 2, l, md);\n        V ri = get(sx, tx, sy, ty, k * 2 + 1, md, r);\n        return comp(le, ri);\n    }\n    V get(int sx, int tx, int sy, int ty) {\n        return get(sx, tx, sy, ty, 1, 0, NV);\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint R, C, Q;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> R >> C >> Q) {\n        if (R == 0) return;\n        StaticHealthy2DSegTree st;\n        vector<vector<pair<int, int>>> v(C);\n        rep(r, 0, R) rep(c, 0, C) {\n            int x; cin >> x;\n            v[c].push_back({ r, x });\n        }\n        st.init(v);\n\n        rep(i, 0, Q) {\n            int a, b, c, d; cin >> a >> b >> c >> d;\n            int ans = st.get(b, d + 1, a, c + 1);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<climits>\n#include<complex>\n#define sz(x) (int)((x).size())\n#define rep(i,n) for (int i=0;i<n;i++)\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nstruct Seg\n{\n    int s[4];\n    int val;\n}seg[10000*20];\nint tot=0,root=-1;\nvoid insert(int x,int y,int val,int minx,int maxx,int miny,int maxy,int &v)\n{\n    if (x<minx||x>=maxx||y<miny||y>=maxy)\n    {\n        return;\n    }\n    if (v==-1)\n    {\n        v=tot++;\n        memset(seg[v].s,-1,sizeof(seg[v].s));\n        seg[v].val=INT_MAX;\n    }\n    if (minx+1==maxx&&miny+1==maxy)\n    {\n        seg[v].val=min(seg[v].val,val);\n        return;\n    }\n    int midx=(minx+maxx)>>1;\n    int midy=(miny+maxy)>>1;\n    insert(x,y,val,minx,midx,miny,midy,seg[v].s[0]);\n    insert(x,y,val,minx,midx,midy,maxy,seg[v].s[1]);\n    insert(x,y,val,midx,maxx,miny,midy,seg[v].s[2]);\n    insert(x,y,val,midx,maxx,midy,maxy,seg[v].s[3]);\n    seg[v].val=INT_MAX;\n    int i;\n    for (i=0;i<4;i++)\n    {\n        if (seg[v].s[i]!=-1)\n        {\n            seg[v].val=min(seg[v].val,seg[seg[v].s[i]].val);\n        }\n    }\n}\nint find(int ax,int bx,int ay,int by,int minx,int maxx,int miny,int maxy,int v)\n{\n    if (v==-1)return INT_MAX;\n    if (ax>=maxx||bx<=minx||ay>=maxy||by<=miny)\n    {\n        return INT_MAX;\n    }\n    if (ax<=minx&&bx>=maxx&&ay<=miny&&by>=maxy)\n    {\n        return seg[v].val;\n    }\n    int midx=(minx+maxx)>>1;\n    int midy=(miny+maxy)>>1;\n    int tmp=find(ax,bx,ay,by,minx,midx,miny,midy,seg[v].s[0]);\n    tmp=min(tmp,find(ax,bx,ay,by,minx,midx,midy,maxy,seg[v].s[1]));\n    tmp=min(tmp,find(ax,bx,ay,by,midx,maxx,miny,midy,seg[v].s[2]));\n    tmp=min(tmp,find(ax,bx,ay,by,midx,maxx,midy,maxy,seg[v].s[3]));\n    return tmp;\n}\nchar buf[100];\nint main()\n{\n    int stt;\n    int r,c,q,i,j,k;\n    while (scanf(\"%d%d%d\",&r,&c,&q)!=EOF)\n    {\n    \tif (r==0&&c==0&&q==0)break;\n    \troot = -1;\n    \ttot= 0;\n    \tfor (i=1;i<=r;i++)\n    \t{\n    \t\tfor (j=1;j<=c;j++)\n    \t\t{\n    \t\t\tscanf(\"%d\",&k);\n    \t\t\tinsert(i, j, k, -1, 1111111, -1, 1111111, root);\n    \t\t}\n    \t}\n        while (q--)\n        {\n           // else\n            {\n                int minx, maxx, miny, maxy;\n                scanf(\"%d %d %d %d\", &minx, &miny, &maxx, &maxy);\n                printf(\"%d\\n\", find(minx+1, maxx + 2, miny+1, maxy + 2, -1, 1111111, -1, 1111111,\n                                    root));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W, W_;\nint y1, x1, y2, x2, *g, sz;\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y*W_ + x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\tg = NULL;\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tW_ = 2*W - 1;\n\t\tif(sz < (2*H-1) * (2*W-1)){\n\t\t\tsz = (2*H-1) * (2*W-1);\n\t\t\tg = (int*) realloc(g, sizeof(int) * sz);\n\t\t}\n\t\trep(i, (2*H-1) * (2*W-1)) g[i] = inf;\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", g + (i+H-1) * W_ + j+W-1);\n\t\tfor(int i = 2*H - 2; i >= 0; i--){\n\t\t\tfor(int j = 2*W - 2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(min(g[(i*2+1) * W_ + j*2 + 1], g[(i*2+2) * W_ + j*2+2]),\n\t\t\t\t\t\tmin(g[(i*2+2) * W_ + j*2+1], g[(i*2+1) * W_ + j*2+2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[(i*2+1) * W_ + j], g[(i*2+2) * W_ + j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[i*W_ + j*2+1], g[i*W_ + j*2+2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\tif(g) free(g);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nconst ll inf = 1LL << 60;\nclass SegmentTree {\n    vector<ll> data;\n    int N;\npublic:\n    SegmentTree(int n) {\n        N = 1;\n        while (N < n) N *= 2;\n        data.resize(2 * N - 1, inf);\n    }\n    void update(int pos, ll val) {\n        pos += N - 1;\n        data[pos] = val;\n        while (pos > 0) {\n            pos = (pos - 1) / 2;\n            data[pos] = min(data[2 * pos + 1], data[2 * pos + 2]);\n        }\n    }\n    ll query(int l, int r) {\n        return query(l, r, 0, N, 0);\n    }\n    ll query(int l, int r, int a, int b, int x) {\n        if (b <= l || r <= a) {\n            return inf;\n        }\n        if (l <= a && b <= r) {\n            return data[x];\n        }\n        int mid = (a + b) / 2;\n        return min(query(l, r, a, mid, 2 * x + 1), query(l, r, mid, b, 2 * x + 2));\n    }\n};\n\ntemplate<typename T>\nvoid chmin(T &a, T b) {\n    a = min(a, b);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int r, c, q;\n    while (cin >> r >> c >> q, r + c + q) {\n        bool swapflag = false;\n        int rr = r, cc = c;\n        if (r > c) {\n            swapflag = true;\n            swap(r, c);\n        }\n        vector<SegmentTree> vec(r, SegmentTree(c));\n        {\n            auto grid = make_v(r, c, 0LL);\n            REP(i, 0, rr) {\n                REP(j, 0, cc) {\n                    if (swapflag) {\n                        cin >> grid[j][i];\n                    } else {\n                        cin >> grid[i][j];\n                    }\n                }\n            }\n            REP(i, 0, r) {\n                REP(j, 0, c) {\n                    vec[i].update(j, grid[i][j]);\n                }\n            }\n        }\n        REP(i, 0, q) {\n            int r1, c1, r2, c2;\n            cin >> r1 >> c1 >> r2 >> c2;\n            if (swapflag) {\n                swap(r1, c1);\n                swap(r2, c2);\n            }\n            ll ans = inf;\n            REP (j, r1, r2 + 1) {\n                chmin(ans, vec[j].query(c1, c2 + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n// AOJ 1068 - School of Killifish\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector<value_type> m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size = 0, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n\tvalue_type operator[](size_t i) const {\n\t\treturn m_data[m_size - 1 + i];\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree2D {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< SegmentTree<Traits> > m_data;\n\tsize_t m_width, m_height;\n\n\tvoid initialize(){\n\t\tvector<value_type> work(m_width);\n\t\tfor(int i = static_cast<int>(m_height) - 2; i >= 0; --i){\n\t\t\tfor(size_t j = 0; j < m_width; ++j){\n\t\t\t\twork[j] =\n\t\t\t\t\tm_traits(m_data[i * 2 + 1][j], m_data[i * 2 + 2][j]);\n\t\t\t}\n\t\t\tm_data[i] = SegmentTree<Traits>(work.begin(), work.end());\n\t\t}\n\t}\n\n\tvalue_type query(\n\t\tint x0, int y0, int x1, int y1, int k, int l, int r) const\n\t{\n\t\tif(r <= y0 || y1 <= l){ return m_traits.default_value(); }\n\t\tif(y0 <= l && r <= y1){ return m_data[k].query(x0, x1); }\n\t\tconst value_type vl = query(x0, y0, x1, y1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(x0, y0, x1, y1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tsize_t height = 0, size_t width = 0, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(width)\n\t{\n\t\twhile(m_height < height){ m_height *= 2; }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(width, traits));\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree2D(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(0)\n\t{\n\t\tconst size_t h = distance(first, last);\n\t\twhile(m_height < h){ m_height *= 2; }\n\t\tif(h > 0){ m_width = distance(first->begin(), first->end()); }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(m_width, traits));\n\t\tsize_t row = m_height - 1;\n\t\tfor(Iterator it = first; it != last; ++it, ++row){\n\t\t\tm_data[row] = SegmentTree<Traits>(it->begin(), it->end());\n\t\t}\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, size_t j, const value_type &val){\n\t\ti += m_height - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_traits(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(size_t x0, size_t y0, size_t x1, size_t y1) const {\n\t\treturn query(x0, y0, x1, y1, 0, 0, m_height);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct MinSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT operator()(const T &a, const T &b) const { return min(a, b); }\n};\n\n\n}\n}\n\n\nusing libcomp::structure::SegmentTree2D;\nusing libcomp::structure::MinSegmentTreeTraits;\ntypedef SegmentTree2D< MinSegmentTreeTraits<int> > MinSegmentTree2D;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tvector< vector<int> > grid(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){ cin >> grid[i][j]; }\n\t\t}\n\t\tMinSegmentTree2D st(grid.begin(), grid.end());\n\t\twhile(q--){\n\t\t\tint y0, x0, y1, x1;\n\t\t\tcin >> y0 >> x0 >> y1 >> x1;\n\t\t\tcout << st.query(x0, y0, x1 + 1, y1 + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<vector<int> > segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i][j];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d]=min(segtree[a][d],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree.clear();\n\t\tsegtree=vector<vector<int> >(n+a+10,vector<int>(m+b+10,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = pow(2,31) - 1;\n\nstruct RMQ{\n  int n;\n  vector< int > seg;\n  void update( int i, int x){\n    i += n - 1;\n    seg[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      seg[i] = min( seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n  }\n  int query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) return seg[k];\n    int vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return min( vl, vr);\n  }\n  int query( int a, int b){\n    return query( a, b, 0, 0, n);\n  }\n  RMQ(int size){\n    n = 1;\n    while( n < size ) n *= 2;\n    seg.assign( n * 2 - 1, INF);\n  }\n};\n\nint main(){\n  int R, C, Q;\n  while(cin >> R >> C >> Q, R){\n    vector< RMQ > rmq( R, RMQ(C));\n    for(int i = 0; i < R; i++){\n      for(int j = 0; j < C; j++){\n        int grid;\n        cin >> grid;\n        rmq[i].update(j,grid);\n      }\n    }\n    while(Q--){\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ret = INF;\n      for(int i = r1; i <= r2; i++){\n        ret = min( ret, rmq[i].query( c1, c2 + 1));\n      }\n      cout << ret << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint tmp;\nvector<int> seg[1000];\n\nvoid init(int num,int n_){\n  seq[num].clear();\n  for(int i=0;i<2*n_-1;i++)seg[num].push_back( (1<<31)-1 );\n}\n\nvoid update(int x,int k, int a){\n  k += n-1;\n  seg[x][k] = a;\n  while(k>0){\n    k = (k-1) / 2;\n    seg[x][k] = min(seg[x][k*2+1], seg[x][k*2+2]);\n  }\n}\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(r>=c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(j,i,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(i,j,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.clear();\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tprintf(\"%d%c\", cmp[i][j], j == Ws - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = 0; j < Hs; j++){\n\t\t\t\tfor (int k = 0; k < Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t&& w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); k <= min((k + 1) * Ws, w2); k++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\tif(vl<vr)return vl;\n\treturn vr;\n\t//return min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n//// ZOgØðàÂzñ\n//int dat[2*MAX_N];\n//int n;\n//\n//void init(int n_){\n//\tn=1;\n//\twhile(n<n_)n*=2;\n//\tfor(int i = 0; i < 2*n; i++)\n//\t\tdat[i]=INF;\n//}\n//void update(int k,int a){\n//\tk+=n-1;\n//\tdat[k]=a;\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\n//// [a,b)ÌÅ¬lðßé\n//int query(int a,int b,int k,int l,int r){\n//\tif(r<=a||b<=l)return INF;\n//\tif(a<=l&&r<=b)return dat[k];\n//\telse{\n//\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n//\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n//\t\treturn min(vl,vr);\n//\t}\n//}\nuint dat[2*MAX_N];\nint n;\nint h,w;\nint r,c,q;\nvector<vector<uint> > grid;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tvector<uint> v;\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t\tgrid.push_back(v);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        if (h >= w){\n\t        for (i = 0; i < h; i++){\n    \t        for (j = 0; j < w; j++){\n        \t        scanf(\"%d\", &t);\n            \t    update(i * w + j, t);\n            \t}\n        \t}\n        }\n        else {\n        \tfor (i = 0; i < h; i++){\n        \t\tfor (j = 0; j < w; j++){\n        \t\t\tscanf(\"%d\", &t);\n        \t\t\tupdate(i + j * h, t);\n        \t\t}\n        \t}\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {\n            \tif (h >= w){\n\t\t            for (int k = y1; k <= y2; k++){\n    \t\t        \tans = min(ans, query(k * w + x1, k * w + x2 + 1, 0, 0, n));\n        \t\t    }\n        \t\t}\n        \t\telse {\n        \t\t\tfor (int k = x1; k <= x2; k++){\n        \t\t\t\tans = min(ans, query(k * h + y1, k * h + y2 + 1, 0, 0, n));\n        \t\t\t}\n        \t\t}\n            \tprintf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a)*(b+m)>7000000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define M 1000000\n#define D 10000\n#define QN 10000\n#define inf 0x7FFFFFFF\nusing namespace std;\n\nint p[20],LOG[M+10],dp[D+10][15];\nvoid init_rmq(int dt[],int l,int r){\n\tfor(int i=l;i<=r;i++)\n\t\tdp[i-l][0]=dt[i];\n\tint k=LOG[(r-l+1)]/LOG[2];\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=l;j<=r;j++)\n\t\t\tif(j+p[i-1]<=r)\n\t\t\t\tdp[j-l][i]=min(dp[j-l][i-1],dp[j-l+p[i-1]][i-1]);\n\t\t\telse dp[j-l][i]=dp[j-l][i-1];\n}\nint query_rmq(int a,int b,int delta){\n\tint x=a,y=b;\n\tif(x>y) swap(x,y);\n\tint k=LOG[y-x+1]/LOG[2];\n\treturn min(dp[x-delta][k],dp[y-p[k]+1-delta][k]);\n}\n\nint data[M+10];\nint l[QN+10],r[QN+10],u[QN+10],d[QN+10],ans[QN+10];\nint main(){\n\tp[0]=1;\n\tfor(int i=1;i<19;i++) p[i]=p[i-1]*2;\n\tLOG[0]=-1;\n\tfor(int i=1;i<=M;i++) LOG[i]=(i&(i-1))?LOG[i-1]:LOG[i-1] + 1 ;\n\t\n\tint n,m,q;\n\twhile(scanf(\"%d%d%d\",&n,&m,&q),n||m||q){\n\t\tif(n<=m){\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\t\tscanf(\"%d\",&data[i*m+j]);\n\t\t\tfor(int i=1;i<=q;i++) scanf(\"%d%d%d%d\",&u[i],&l[i],&d[i],&r[i]);\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\t\tscanf(\"%d\",&data[j*n+i]);\n\t\t\tswap(n,m);\n\t\t\tfor(int i=1;i<=q;i++) scanf(\"%d%d%d%d\",&l[i],&u[i],&r[i],&d[i]);\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=q;i++) ans[i]=inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j+=D){\n\t\t\t\tint ed=(j+D-1<m)?j+D-1:m;\n\t\t\t\tinit_rmq(data+i*m,j,ed);\n\t\t\t\tfor(int k=1;k<=q;k++){\n\t\t\t\t\tif(i<u[k]||i>d[k]||j>r[k]||ed<l[k]) continue;\n\t\t\t\t\tans[k]=min(ans[k],query_rmq(max(j,l[k]),min(ed,r[k]),j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=q;i++) printf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int SQRT_N = 1000;\nconst int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(int x, int value) {\n    data[x] = value;\n    int k = x / SQRT_N;\n    stat[k] = min(stat[k], data[x]);\n  }\n  int query(int a, int b) {\n    int ret = INF;\n    for(int k = a / SQRT_N; k < (b + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(int y, int x, int value) {\n    data[y].update(x, value);\n    int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(int y1, int x1, int y2, int x2) {\n    int ret = INF;\n    for(int k = y1 / SQRT_N; k < (y2 + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = new dat_t[k*2];\n        fill(dat, dat+k*2, inf);\n    }\n    ~SegTree(){\n        delete [] dat;\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        this->dat = new dat_t[s.n*2];\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        bool swaped = false;\n        if(r>c){\n            swap(r,c);\n            swaped = true;\n        }\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            // dump(tree.dat[i].dat);\n            dump(vector<dat_t>(tree.dat[i].dat, tree.dat[i].dat+tree.dat[i].n*2));\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            if(swaped){\n                swap(x1,y1); swap(x2,y2);\n            }\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<int*> dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\tint *buf = new int[8388608];\n\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\n\t\tdat.resize(r * 2 - 1);\n\t\tfor(int i = r * 2 - 2; i >= 0; --i){\n\t\t\tdat[i] = buf + i * (c + 2 - 1);\n\t\t\tfor(int j = c * 2 - 2; j >= 0; --j) dat[i][j] = INT_MAX;\n\t\t}\n\n\t\tint *datr = new int[c * 2 - 1];\n\t\tfor(int i = c * 2 - 2; i >= 0; --i) datr[i] = INT_MAX;\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr, datr + (c * 2 - 1), dat[i + r - 1]);\n\t\t}\n\t\t\n\t\tdelete[] datr;\n\n\t\tfor(int j = 0; j < c * 2 - 1; ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n\t\n\tdelete[] buf;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  int top(){\n    return data[0];\n  }\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  void update(int k, int x){\n    k += N - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b){\n    return query(a, b, 0, 0, N);\n  }\n  int query(int a, int b, int k, int l, int r){\n    if(b <= l || r <= a) return INF;\n    else if(a <= l && r <= b){\n      return data[k];\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          if(res > rmq[y].top()) res = min(res, rmq[y].query(x1, x2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int x = x1; x <= x2; x++){\n          if(res > rmq[x].top()) res = min(res, rmq[x].query(y1, y2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(r);\n    int cs=sqrt(c);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&i/rs*rs+rs<=b+1&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXN = 1000000 + 10;\n\nint n, m, num1[MAXN], num2[MAXN], st1[MAXN][20], st2[MAXN][20];\n\nint min(int num[], int p1, int p2) {\n    return num[p1] < num[p2] ? p1 : p2;\n}\n\nvoid init(int num[], int st[][20], int n) {\n    REP(i, n)\n        st[i][0] = i;\n    for (int j = 1; (1 << j) <= n; ++j)\n        for (int i = 0; i + (1 << j) - 1 < n; ++i)\n            st[i][j] = min(num, st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n}\n\nint rmq(int num[], int st[][20], int i, int j) {\n    int k = (int)log2(j - i + 1);\n    return num[min(num, st[i][k], st[j - (1 << k) + 1][k])];\n}\n\nint main() {\n    int q;\n    while (scanf(\"%d%d%d\", &n, &m, &q) == 3 && n + m + q) {\n        REP(i, n) {\n            REP(j, m) {\n                int pos1 = i * m + j,\n                    pos2 = j * n + i;\n                //out(pos1);\n                scanf(\"%d\", num1 + pos1);\n                num2[pos2] = num1[pos1];\n            }\n        }\n        if (q < 10) {\n            REP(qq, q) {\n                //out(i);\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                for (int i = l1; i <= r1; ++i) {\n                    for (int j = l2; j <= r2; ++j) {\n                        int pos = i * m + j;\n                        //out(pos);\n                        checkmin(ans, num1[pos]);\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        } else {\n            init(num1, st1, n * m);\n            init(num2, st2, n * m);\n            REP(qq, q) {\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                if (r2 - l2 > r1 - l1) {\n                    for (int i = l1; i <= r1; ++i) {\n                        int pos1 = i * m + l2, pos2 = i * m + r2;\n                        checkmin(ans, rmq(num1, st1, pos1, pos2));\n                    }\n                } else {\n                    for (int i = l2; i <= r2; ++i) {\n                        int pos1 = i * n + l1, pos2 = i * n + r1;\n                        checkmin(ans, rmq(num2, st2, pos1, pos2));\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n     DoS\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nlong long int sizex;\nlong long int sizey;\nlong long int const2d;\nunsigned int grid[10000000];\n\nvoid update(long long int x, long long int y, unsigned int t) {\n    x += sizex-1;\n    y += sizey-1;\n\n    grid[const2d*y+x] = t;\n    while (y >= 0) {\n        long long int x_ = x;\n\n        while (x_ > 0) {\n            x_ = (x_-1)/2;\n            grid[const2d*y+x_] = min(grid[const2d*y+x_*2+1], grid[const2d*y+x_*2+2]);\n        }\n        if (y == 0) break;\n\n        y = (y-1)/2;\n        grid[const2d*y+x] = min(grid[const2d*(y*2+1)+x], grid[const2d*(y*2+2)+x]);\n    }\n}\n\nunsigned int _get_min(unsigned int *vec, int wishl, int wishr, long long int k, int watchl, int watchr) {\n    int mid;\n    unsigned int lval, rval;\n\n    if (wishr <= watchl || watchr <= wishl) return INF;\n    if (wishl <= watchl && watchr <= wishr) {\n        return vec[k];\n    }\n\n    mid = (watchl+watchr)/2;\n    lval = _get_min(vec, wishl, wishr, k*2+1, watchl, mid);\n    rval = _get_min(vec, wishl, wishr, k*2+2, mid, watchr);\n    return min(lval, rval);\n}\n\nunsigned int get_min(int wishl, int wishr, int wishu, int wishd, long long int k, int watchu, int watchd) {\n    int mid;\n    unsigned int uval, dval;\n\n    if (wishd <= watchu || watchd <= wishu) return INF;\n    if (wishu <= watchu && watchd <= wishd) {\n        return _get_min(&grid[const2d*k], wishl, wishr, 0, 0, sizex);\n    }\n\n    mid = (watchu+watchd)/2;\n    uval = get_min(wishl, wishr, wishu, wishd, k*2+1, watchu, mid);\n    dval = get_min(wishl, wishr, wishu, wishd, k*2+2, mid, watchd);\n    return min(uval, dval);\n}\n    \nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n        const2d = sizex*2-1;\n\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", get_min(c1, c2+1, r1, r2+1, 0, 0, sizey));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<25;\n\tstatic lli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nlli SegmentTree::dat[2*MAX_N-1];\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Max=1000010;\n#define inf 0x7fffffff\nint ma[Max];\nint Log[Max];\nint rmq[Max*22];\nint K,r,c,q;\n\nvoid preRMQ(){\n\tK=Log[c]+2;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int k=0;(1<<k)-1<c;k++){\n\t\t\tfor(int j=0;j + (1<<k) - 1<c;j++){\n\t\t\t\tif(k==0)\n\t\t\t\t\trmq[(i*K+k)*c+j]=ma[i*c+j];\n\t\t\t\telse\n\t\t\t\t\trmq[(i*K+k)*c+j]=min(rmq[(i*K+k-1)*c+j],rmq[(i*K+k-1)*c+j+(1<<k-1)]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint RMQ(int R,int i,int j){\n\tint k=Log[j-i+1];\n\treturn min(rmq[(R*K+k)*c+i],rmq[(R*K+k)*c+j-(1<<k)+1]);\n}\n\nint main()\n{\n\tLog[1]=0;\n\tfor(int i=2,x=1;i<1000000;i++){\n\t\tif(i>=(1<<x+1))\n\t\t\tx++;\n\t\tLog[i]=x;\n\t}\n\twhile(scanf(\"%d %d %d\",&r,&c,&q) == 3){\n\t\tif(r==0 && c==0 && q==0)\n\t\t\tbreak;\n\t\tint rr=r,cc=c;\n\t\tbool flag=false;\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tflag=true;\n\t\t}\n\t\tfor(int i=0;i<rr;i++){\n\t\t\tfor(int j=0;j<cc;j++){\n\t\t\t\tif(flag)\n\t\t\t\t\tscanf(\"%d\",&ma[j*c+i]);\n\t\t\t\telse\n\t\t\t\t\tscanf(\"%d\",&ma[i*c+j]);\n\t\t\t}\n\t\t}\n\t\tpreRMQ();\n\t\tint a1,a2,b1,b2;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tscanf(\"%d %d %d %d\",&a1,&a2,&b1,&b2);\n\t\t\tif(flag){\n\t\t\t\tswap(a1,a2);\n\t\t\t\tswap(b1,b2);\n\t\t\t}\n\t\t\tint ans=inf;\n\t\t\tfor(int j=a1;j<=b1;j++){\n\t\t\t\tans=min(ans,RMQ(j,a2,b2));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4] = {nullptr, nullptr, nullptr, nullptr};\n  Node(int v) : value(v) {}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  int count() {return count(root_);}\n  int count(Node* node) {\n    if(!node) return 0;\n    int result = 1;\n    for(const auto& i: node->child) result += count(i);\n    return result;\n  }\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    cout<<tree.count()<<endl;\n    return 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=100;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[y2/B]&&y2%B!=0)y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[x2/B]&&x2%B!=0)x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nclass RMQ2D {\n  public:\n    int H, W;\n    std::vector<std::vector<int>> dat;    \n\n    RMQ2D(int h, int w, std::vector<std::vector<int>>& grid)\n    {\n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        dat.resize(2 * H - 1);\n        for (int i = 0; i < 2 * H - 1; i++) {\n            dat[i].resize(2 * W - 1);\n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[i][j] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[i + H - 1][j + W - 1] = grid[i][j]; \n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[i][j] = std::min(dat[i][j * 2 + 1], dat[i][j * 2 + 2]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[j][i] = std::min(dat[j * 2 + 1][i], dat[j * 2 + 2][i]);\n            }\n        }\n    }\n   \n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[j][k];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        std::vector<std::vector<int>> grid(H, std::vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n        RMQ2D r(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            std::cout << r.query(y1, x1, y2, x2) << std::endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 9000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return INT_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%d\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%d%d%d\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = new dat_t[k*2];\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        this->dat = new dat_t[s.n*2];\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        dump(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            // dump(tree.dat[i].dat);\n            dump(vector<dat_t>(tree.dat[i].dat, tree.dat[i].dat+tree.dat[i].n*2));\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint a[1000000];\nint r,c,q;\n\ninline int readint()\n{\n    char ch;\n    bool ng;\n\n    ch = getchar();\n    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n    if (ch == '-')\n    {\n        ng = true;\n        ch = getchar();\n    }\n    else\n        ng = false;\n\n    int wg = ch-'0';\n    ch = getchar();\n    while (ch >= '0' && ch <= '9')\n    {\n        wg = wg*10+ch-'0';\n        ch = getchar();\n    }\n    if (ng == true) wg = -wg;\n    return wg;\n}\nvector<int> tree[1000];\nbool flag=0;\nvoid build(int pos,int x,int l,int r)\n{\n    if (l<r)\n    {\n        int mid=l+r>>1;\n        build(pos,x*2,l,mid);\n        build(pos,x*2+1,mid+1,r);\n        tree[pos][x]=min(tree[pos][x*2],tree[pos][x*2+1]);\n    }\n    else if (!flag)\n        tree[pos][x]=a[pos*c+l];\n    else\n        tree[pos][x]=a[l*c+pos];\n}\nint query(int pos,int x,int l,int r,int s,int t)\n{\n    if (s<=l && r<=t)\n        return tree[pos][x];\n    int mid=l+r>>1,res=0x7fffffff;\n    if (s<=mid)\n        res=query(pos,x*2,l,mid,s,t);\n    else\n        res=min(res,query(pos,x*2+1,mid+1,r,s,t));\n    return res;\n}\nint main()\n{\n    while (true)\n    {\n        scanf(\"%d%d%d\",&r,&c,&q);\n        if (r == 0 && c == 0 && q == 0) break;\n        if (r>c)\n            flag=1;\n        int spos = 0;\n        for (int i = 0; i < r; i++)\n            for (int j = 0; j < c; j++)\n                a[spos++] = readint();\n        if (!flag)\n            for (int i=0; i<r; i++)\n            {\n                tree[i].resize(c*4);\n                build(i,1,0,c-1);\n            }\n        else\n            for (int i=0; i<c; i++)\n            {\n                tree[i].resize(r*4);\n                build(i,1,0,r-1);\n            }\n        for (int i = 0; i < q; i++)\n        {\n            int xa,xb,ya,yb;\n            scanf(\"%d%d%d%d\",&xa,&ya,&xb,&yb);\n            if (!flag)\n            {\n                int res = 0x7fffffff;\n                for (int x = xa; x <= xb; x++)\n                    res=min(res,query(x,1,0,c-1,ya,yb));\n                printf(\"%d\\n\",res);\n            }\n            else\n            {\n                int res = 0x7fffffff;\n                for (int y = ya; y <= yb; y++)\n                    res=min(res,query(y,1,0,r-1,xa,xb));\n                printf(\"%d\\n\",res);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nconst int N = 1000010;\nconst int inf = 0x7fffffff;\nstruct Tree\n{\n\tint x[2];\n\tint y[2];\n\tint val;\n\tint son[4];\n}tt[N*2];\nint a[N];\nint n,m;\nint loc;\nvoid build(int x0,int x1,int y0,int y1,int idx)\n{\n\ttt[idx].x[0]=x0;\n\ttt[idx].x[1]=x1;\n\ttt[idx].y[0]=y0;\n\ttt[idx].y[1]=y1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttt[idx].son[i]=0;\n\t}\n\tif(x0==x1&&y0==y1)\n\t{\n\t\ttt[idx].val=a[(x0-1)*m+y0];\n\t\treturn ;\n\t}\n\tint mx=(x0+x1)>>1;\n\tint my=(y0+y1)>>1;\n\tif(x0==x1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\tbuild(x0,x0,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,x0,my+1,y1,tt[idx].son[1]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t}\n\telse if(y0==y1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[2]=++loc;\n\t\tbuild(x0,mx,y0,y0,tt[idx].son[0]);\n\t\tbuild(mx+1,x1,y0,y0,tt[idx].son[2]);\t\t\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[2]].val);\n\t}\n\telse\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\ttt[idx].son[2]=++loc;\t\t\n\t\ttt[idx].son[3]=++loc;\n\t\tbuild(x0,mx,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,mx,my+1,y1,tt[idx].son[1]);\n\t\tbuild(mx+1,x1,y0,my,tt[idx].son[2]);\n\t\tbuild(mx+1,x1,my+1,y1,tt[idx].son[3]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[2]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[3]].val);\n\t}\n}\nint query(int x0,int x1,int y0,int y1,int idx)\n{\n\tif(tt[idx].x[0]>=x0&&tt[idx].x[1]<=x1&&tt[idx].y[0]>=y0&&tt[idx].y[1]<=y1)\n\t{\n\t\treturn tt[idx].val;\n\t}\n\tif(tt[idx].x[0]>x1||tt[idx].x[1]<x0||tt[idx].y[0]>y1||tt[idx].y[1]<y0)\n\t{\n\t\treturn inf;\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(tt[idx].son[i]!=0)\n\t\t{\n\t\t\tans = min(query(x0,x1,y0,y1,tt[idx].son[i]),ans);\n\t\t}\n\t}\n\treturn ans;\n}\nint main(void)\n{\n\tint q,x0,x1,y0,y1;\n\twhile(scanf(\"%d%d%d\",&n,&m,&q)&&(n||m||q))\n\t{\n\t\tfor(int i=1;i<=n*m;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t}\n\t\tloc=1;\n\t\tbuild(1,n,1,m,1);\n\t\tfor(int i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x0,&y0,&x1,&y1);\n\t\t\tx0++;y0++;x1++;y1++;\n\t\t\tprintf(\"%d\\n\",query(x0,x1,y0,y1,1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    つらい \n  */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\n\n\nclass Seg2d {\npublic:\n    vector<unsigned int> grid;\n    int width;\n    int height;\n\n    inline int get_idx(int watchl, int watchr, int watchu, int watchd) {\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        if (hori == 0 || vert == 0) return -1;\n        return (watchu/vert) * width/hori + watchl/hori;\n    }\n\n    Seg2d (int sizex, int sizey) : width(sizex), height(sizey) {\n        long long int a = min(width, height);\n        long long int b = max(width, height);\n        long long int size = (4*a*a-1)/3 + 2*a*(b-a);\n\n        grid.resize(/*size*/10000000, INF);\n    }\n    ~Seg2d() {grid.clear();}\n\n    void _update(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd, unsigned int x) {\n        int midx, midy;\n        unsigned int idx, idx1, idx2, idx3, idx4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (wishl == wishr || wishu == wishd) return;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            grid[base+get_idx(watchl, watchr, watchu, watchd)] = x;\n            return;\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd, x);\n        idx  = get_idx(watchl, watchr, watchu, watchd);\n        idx1 = get_idx(watchl, midx, watchu, midy);\n        idx2 = get_idx(midx, watchr, watchu, midy);\n        idx3 = get_idx(watchl, midx, midy, watchd);\n        idx4 = get_idx(midx, watchr, midy, watchd);\n        if (idx != -1) {\n            grid[base+idx] = INF;\n            if (idx1 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx1]);\n            if (idx2 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx2]);\n            if (idx3 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx3]);\n            if (idx4 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx4]);\n        }\n    }\n\n    void update(int x, int y, unsigned int t) {\n        _update(x, x+1, y, y+1, 0, 0, width, 0, height, t);\n    }\n\n    unsigned int _getMin(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (wishl == wishr || wishu == wishd) return INF;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return INF;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            return grid[base+get_idx(watchl, watchr, watchu, watchd)];\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        val1 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy);\n        val2 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy);\n        val3 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd);\n        val4 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd);\n        return min(min(val1, val2), min(val3, val4));\n    }\n\n    unsigned int getMin(int x1, int x2, int y1, int y2) { // [x1, x2) [y1, y2)\n        return _getMin(x1, x2, y1, y2, 0, 0, width, 0, height);\n    }\n};\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n    \n        Seg2d seg(sizex, sizey);\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                seg.update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", seg.getMin(c1, c2+1, r1, r2+1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\nint R, C;\n\nll dat[20000000];\n\nint hash1(int x, int y){\n\treturn y * C + x;\n}\n\nvoid init(int r, int c){\n\tR = 1, C = 1;\n\twhile(R < r) R *= 2;\n\twhile(C < c) C *= 2;\n\tfor(int i = 0; i < R * 2 - 1; i++)\n\t\tfor(int j = 0; j < C * 2 - 1; j++) dat[hash1(j,i)] = INF;\n}\n\nvoid update(int x, int y, ll a){\n\tx += C - 1;\n\ty += R - 1;\n\tdat[hash1(x, y)] = a;\n\twhile(y){\n\t\ty = (y - 1) / 2;\n\t\tdat[hash1(x, y)] = min(dat[hash1(x, y*2+1)], dat[hash1(x, y*2+2)]);\n\t}\n\twhile(x){\n\t\tx = (x - 1) / 2;\n\t\tdat[hash1(x, y)] = min(dat[hash1(x*2+1, y)], dat[hash1(x*2+2, y)]);\n\t}\n}\n\nll queryY(int kx, int ya, int yb, int ky, int yl, int yr){\n\tif(yb <= yl || yr <= ya) return INF;\n\telse if(ya <= yl && yr <= yb) return dat[hash1(kx, ky)];\n\telse{\n\t\tint chl = ky * 2 + 1;\n\t\tint chr = ky * 2 + 2;\n\t\tint ym = (yl + yr) / 2;\n\t\treturn min(queryY(kx, ya, yb, chl, yl, ym), queryY(kx, ya, yb, chr, ym, yr));\n\t}\n}\n\nll queryX(int xa, int xb, int ya, int yb, int k, int xl, int xr){\n\tif(xb <= xl || xr <= xa) return INF;\n\telse if(xa <= xl && xr <= xb) return queryY(k, ya, yb, 0, 0, R);\n\telse{\n\t\tint chl = 2 * k + 1;\n\t\tint chr = 2 * k + 2;\n\t\tint xm = (xl + xr) / 2;\n\t\treturn min(queryX(xa, xb, ya, yb, chl, xl, xm),\n\t\t\t\t\tqueryX(xa, xb, ya, yb, chr, xm, xr));\n\t}\n}\n\nint main(){\n\tint r, c, q;\n\tint r1, c1, r2, c2;\n\tll num;\n\twhile(cin >> r >> c >> q && (r || c || q)){\n\t\tinit(r, c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tcin >> num;\n\t\t\t\tupdate(j, i, num);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << queryX(c1, c2+1, r1, r2+1, 0, 0, C) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 9876543210\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvector<vector<ll> > dat;\nint R, C;\n\nvoid update(int r, int c, ll x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(true){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tif (cc == 0) break;\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nll query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tll v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tll v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tll v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tll v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tdat.clear();\n\t\tdat.resize(R * 2 - 1, vector<ll>(C * 2 - 1, INF));\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tll x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tll ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\nint merge(int l, int r) {\n\treturn min(l, r);\n}\n\ntemplate <typename T>\nclass SegmentTree {\n\tconst int n;\n\tconst T id;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_) :\n\t\tn(size(n_)), id(id_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tconst int h;\n\tconst T id;\n\tvector<SegmentTree<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int li, int lj, int ri, int rj, int node, int lb, int ub) {\n\t\tif (ub <= li || ri <= lb) return id;\n\t\tif (li <= lb && ub <= ri) return data[node].Find(lj, rj - 1);\n\t\treturn merge(sub(li, lj, ri, rj, node * 2, lb, (lb + ub) / 2), sub(li, lj, ri, rj, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_) :\n\t\th(size(h_)), id(id_), data(h * 2, SegmentTree<T>(w_, id)) {}\n\tvoid Init(const vector<vector<T>> v) {\n\t\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\t\tdata[i + h].Init(v[i]);\n\t\t}\n\t\tint w = v.front().size();\n\t\tvector<T> tmp(w);\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ttmp[j] = merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j));\n\t\t\t}\n\t\t\tdata[i].Init(tmp);\n\t\t}\n\t}\n\tvoid Update(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Update(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j, j), data[i * 2 + 1].Find(j, j)));\n\t}\n\tT Find(int i, int j) {\n\t\treturn data[i + h].Find(j);\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub(li, lj, ri + 1, rj + 1, 1, 0, h);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tSegmentTree2<int> st(r, c, INT_MAX);\n\t\t{\n\t\t\tvector<vector<int>> grid(r, vector<int>(c));\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tcin >> grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.Init(grid);\n\t\t}\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn=1e6+5;\n\nint tree[16*maxn],n,m,f[maxn],q;\nint r1,r2,c1,c2;\n\nvoid ini0(int pos1,int pos2,int begin,int end,int r)\n{\n    if(begin==end)tree[pos1*m*4+pos2]=f[r*m+begin];\n    else\n    {\n        int mid=(begin+end)>>1;\n        ini0(pos1,pos2<<1,begin,mid,r);\n        ini0(pos1,(pos2<<1)|1,mid+1,end,r);\n        if(tree[pos1*m*4+(pos2<<1)]<tree[pos1*m*4+((pos2<<1)|1)])tree[pos1*m*4+pos2]=tree[pos1*m*4+(pos2<<1)];\n        else tree[pos1*m*4+pos2]=tree[pos1*m*4+((pos2<<1)|1)];\n    }\n}\n\nvoid ini1(int pos1,int pos2,int begin,int end)\n{\n    if(tree[(pos1<<1)*m*4+pos2]<tree[((pos1<<1)|1)*m*4+pos2])tree[pos1*m*4+pos2]=tree[(pos1<<1)*m*4+pos2];\n    else tree[pos1*m*4+pos2]=tree[((pos1<<1)|1)*m*4+pos2];\n    if(begin!=end)\n    {\n        int mid=(begin+end)>>1;\n        ini1(pos1,pos2<<1,begin,mid);\n        ini1(pos1,(pos2<<1)|1,mid+1,end);\n    }\n}\n\nvoid ini(int pos,int begin,int end)\n{\n    if(begin==end)ini0(pos,1,0,m-1,begin);\n    else\n    {\n        int mid=(begin+end)>>1;\n        ini(pos<<1,begin,mid);\n        ini((pos<<1)|1,mid+1,end);\n        ini1(pos,1,0,m-1);\n    }\n}\n\nint find2(int pos1,int pos2,int begin,int end)\n{\n    if(c1<=begin && end<=c2)return tree[pos1*4*m+pos2];\n    else\n    {\n        int mid=(begin+end)>>1;\n        if(c2<=mid)return find2(pos1,pos2<<1,begin,mid);\n        else if(c1>mid)return find2(pos1,(pos2<<1)|1,mid+1,end);\n        else return min(find2(pos1,pos2<<1,begin,mid),find2(pos1,(pos2<<1)|1,mid+1,end));\n    }\n}\n\nint find(int pos,int begin,int end)\n{\n    if(r1<=begin && end<=r2)return find2(pos,1,0,m-1);\n    else\n    {\n        int mid=(begin+end)>>1;\n        if(r2<=mid)return find(pos<<1,begin,mid);\n        else if(r1>mid)return find((pos<<1)|1,mid+1,end);\n        else return min(find(pos<<1,begin,mid),find((pos<<1)|1,mid+1,end));\n    }\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&q)==3 && (n||m||q))\n    {\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                scanf(\"%d\",&f[i*m+j]);\n        ini(1,0,n-1);\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n            printf(\"%d\\n\",find(1,0,n-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<vector<int> > dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\t\t\n\t\tdat.assign(r * 2 - 1, vector<int>(c * 2 - 1, INT_MAX) );\n\t\tvector<int> datr = dat[0];\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1].begin());\n\t\t}\n\n\t\tfor(int j = 0; j < datr.size(); ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t\t\n\t\tvector<vector<int> >().swap(dat);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n\nconst int maxn = 1000000*2;\nint n;\nstruct node\n{\n    int x1,x2,y1,y2;\n    int min;\n    int ch[4];\n};\nnode tree[maxn];\n \nint tol;\n \nvoid maketree(int x1,int x2,int y1,int y2)\n{\n    int k = ++tol;\n    tree[k].x1 = x1;\n    tree[k].x2 = x2;\n    tree[k].y1 = y1;\n    tree[k].y2 = y2;\n    tree[k].min = 0;\n    if(x1 == x2 && y1==y2)\n    {\n        scanf(\"%d\",&tree[k].min);\n        memset(tree[k].ch,0,sizeof(tree[k].ch));\n        return ;\n    }\n    \n    int midx = (x1+x2)>>1;\n    int midy = (y1+y2)>>1;\n    \n    tree[k].ch[0] = tol+1;\n    maketree(x1,midx,y1,midy); \n    if(midy+1 <= y2)    \n    {\n        tree[k].ch[2] = tol+1;\n        maketree(x1,midx,midy+1,y2);\n    }\n    else\n        tree[k].ch[2] = 0;\n\n\n    if(midx+1 <= x2)\n    {\n        tree[k].ch[3] = tol+1;\n        maketree(midx+1,x2,y1,midy);\n    }\n    else\n        tree[k].ch[3] = 0;\n\n\n    if(midx+1 <= x2 && midy+1 <= y2) \n    {\n        tree[k].ch[1] = tol+1;\n        maketree(midx+1,x2,midy+1,y2);\n    }\n    else\n        tree[k].ch[1] = 0;\n        \n    tree[k].min =  tree[tree[k].ch[0]].min;\n    for(int i=1; i<4; i++)            \n        if(tree[k].ch[i])\n            tree[k].min = min(tree[k].min,tree[tree[k].ch[i]].min);\n}\n \ninline bool cross(int x1,int x2,int y1,int y2,int k)\n{\n    if(x2 < tree[k].x1 || tree[k].x2 < x1   ||  y2 < tree[k].y1 || tree[k].y2 < y1)\n        return false;\n    return true;\n}\n \nint Query(int x1,int x2,int y1,int y2,int k) \n{\n    if(cross(x1,x2,y1,y2,k) == 0)  \n        return INT_MAX;\n \n    if(x1 <= tree[k].x1 && tree[k].x2 <= x2 && y1<= tree[k].y1 && tree[k].y2 <= y2) \n        return tree[k].min;\n    int minx = Query(x1,x2,y1,y2,tree[k].ch[0]);\n \n    for(int i=1; i<4; i++)\n        minx = min(minx,Query(x1,x2,y1,y2,tree[k].ch[i]));\n    return minx;\n}\n\nint main()\n{\n    int r,c,q,temp;\n    int x1,y1,x2,y2;\n    while(( scanf( \"%d%d%d\",&r,&c,&q ),r ))\n    {\n        tol=0;\n        maketree(1,r,1,c);        \n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n            x1++,y1++,x2++,y2++;\n            printf(\"%d\\n\",Query(x1,x2,y1,y2,1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = ((long long)1 << 31) - 1;\n\nint n, m, q;\nint t[(int)16e6];\n\nint& acecss(int i, int j){\n\treturn t[(2 * m - 1) * i + j];\n}\n\nvoid init(){\n\tint p = 1;\n\twhile(p < n){\n\t\tp *= 2;\n\t}\n\tn = p;\n\tint q = 1;\n\twhile(q < m){\n\t\tq *= 2;\n\t}\n\tm = q;\n\tfill_n(t, (2 * n - 1) * (2 * m - 1), inf);\n}\n\nvoid update(int i, int j, int x){\n\tint k = i + n - 1;\n\tint l = j + m - 1;\n\tacecss(k, l) = x;\n\twhile(l > 0){\n\t\tl = (l - 1) / 2;\n\t\tacecss(k, l) = min(acecss(k, l * 2 + 1), acecss(k, l * 2 + 2));\n\t}\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tl = j + m - 1;\n\t\tacecss(k, l) = min(acecss(k * 2 + 1, l), acecss(k * 2 + 2, l));\n\t\twhile(l > 0){\n\t\t\tl = (l - 1) / 2;\n\t\t\tacecss(k, l) = min(acecss(k * 2 + 1, l), acecss(k * 2 + 2, l));\n\t\t}\n\t}\n}\n\nint query(int a, int b, int c, int d, int p, int q, int r, int s, int k, int l){\n\tif(b <= p || q <= a){\n\t\treturn inf;\n\t}\n\tif(a <= p && q <= b){\n\t\tif(d <= r || s <= c){\n\t\t\treturn inf;\n\t\t}\n\t\tif(c <= r && s <= d){\n\t\t\treturn acecss(k, l);\n\t\t}\n\t\tint f = query(a, b, c, d, p, q, r, (r + s) / 2, k, l * 2 + 1);\n\t\tint g = query(a, b, c, d, p, q, (r + s) / 2, s, k, l * 2 + 2);\n\t\treturn min(f, g);\n\t}\n\tint f = query(a, b, c, d, p, (p + q) / 2, r, s, k * 2 + 1, l);\n\tint g = query(a, b, c, d, (p + q) / 2, q, r, s, k * 2 + 2, l);\n\treturn min(f, g);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d%d\", &n, &m, &q);\n\t\tif(n == 0 && m == 0 && q == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tint r = n;\n\t\tint c = m;\n\n\t\tinit();\n\n\t\trep(i, r){\n\t\t\trep(j, c){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tupdate(i, j, x);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\trep(i, 2 * n - 1){\n\t\t\trep(j, 2 * m - 1){\n\t\t\t\tprintf(\"%d \", acecss(i, j));\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\n\t\trep(i, q){\n\t\t\tint a, b, c, d;\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\tprintf(\"%d\\n\", query(a, c + 1, b, d + 1, 0, n, 0, m, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<d||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif(n*m>12000000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint r, c, q;\nint _r, _c;\nint g;\nvi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vi[2 * _r + 1];\n  rep(i, 2 * _r + 1) seg[i].resize(2 * _c + 1);\n  rep(i, 2 * _r + 1) rep(j, 2 * _c + 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  a = 2 * a + 1;\n  while(a > 0){\n    int ta = (a - 1) / 2;\n    int tb = b;\n    while(tb > 0){\n      tb = (tb - 1) / 2;\n      seg[ta][tb] = min(seg[ta][2 * tb + 1], seg[ta][2 * tb + 2]);\n    }\n    tb = b;\n    if(ta == 0) break;\n    a = ta;\n    ta = (a - 1) / 2;\n    seg[ta][tb] = min(seg[2 * ta + 1][tb], seg[2 * ta + 2][tb]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 100;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int N;\n  vector<int> data;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n  void clear() {\n    data.clear();\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    bool doswap = false;\n    if(H > W) {\n      doswap = true;\n      swap(H, W);\n    }\n    Grid g;\n    if(doswap) {\n      REP(y,W) REP(x,H) {\n        int v; cin >> v;\n        g.update(x, y, v);\n      }\n    }\n    else {\n      REP(y,H) REP(x,W) {\n        int v; cin >> v;\n        g.update(y, x, v);\n      }\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      if(doswap) {\n        swap(x1, y1);\n        swap(x2, y2);\n      }\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W;\n\tvector<vector<int>> dat;\n\tsegtree(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tdat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));\n\t\tinit(f);\n\t}\n\tvoid init(vector<vector<int>> &f) {\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[i + H - 1][j + W - 1] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> f(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tsegtree st(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = pow(2,31) - 1;\nint n;\nvoid powset(int size){\n  n = 1;\n  while( n < size ) n *= 2;\n}\n\nstruct RMQ{\n  vector< int > seg;\n  void update( int i, int x){\n    i += n - 1;\n    seg[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      seg[i] = min( seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n  }\n  int query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) return seg[k];\n    int vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return min( vl, vr);\n  }\n  int query( int a, int b){\n    return query( a, b, 0, 0, n);\n  }\n  RMQ(){\n    seg.assign( n * 2 - 1, INF);\n  }\n};\n\nint main(){\n  int R, C, Q;\n  while(scanf(\"%d %d %d\", &R, &C, &Q), R){\n    if(R < C){\n      powset(C);\n      vector< RMQ > rmq( R, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\", &grid);\n          rmq[i].update(j,grid);\n        }\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = r1; i <= r2; i++){\n          ret = min( ret, rmq[i].query( c1, c2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }else{\n      powset(R);\n      vector< RMQ > rmq( C, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\",&grid);\n          rmq[j].update(i,grid);\n        }\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = c1; i <= c2; i++){\n          ret = min( ret, rmq[i].query( r1, r2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct SegTree{\n\tvi data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,INT_MAX);\n\t}\n\tvoid Update(int i,int n){\n\t\tdata[size+i]=n;\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=min(data[j],n);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INT_MAX;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INT_MAX,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tbool flg=r>c; // グリッドが縦長\n\t\tif(r>c) swap(r,c);\n\t\tvvi grid(r,vi(c));\n\t\tif(flg)\n\t\t\trep(j,c) rep(i,r)\n\t\t\t\tscanf(\"%d\",&grid[i][j]);\n\t\telse\n\t\t\trep(i,r) rep(j,c)\n\t\t\t\tscanf(\"%d\",&grid[i][j]);\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q)\n\t\t\tscanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\tif(flg){\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tvector<SegTree> st(r,SegTree(c));\n\t\trep(i,r) rep(j,c)\n\t\t\tst[i].Update(j,grid[i][j]);\n\t\t\n\t\trep(i,q){\n\t\t\tint mn=INT_MAX;\n\t\t\trepi(j,r1[i],r2[i]+1)\n\t\t\t\tmn=min(mn,st[j].Query(c1[i],c2[i]+1));\n\t\t\tprintf(\"%d\\n\",mn);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nconst int MAX_N = 1 << 20;\nconst unsigned int INF = 4294967295U;\nunsigned int n, dat[2*MAX_N-1];\n\nvoid init(int n_)\n{\n  n = 1;\n  while (n < n_)\n    n*= 2;\n  for (int i = 0; i < 2*n-1; ++i)\n    dat[i] = INF;\n}\n\nvoid update(int k, int a)\n{\n  k += n-1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k-1)/2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\nunsigned int query(int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l)\n    return INF;\n\n  if (a <= l && r <= b) {\n    return dat[k];\n  } else {\n    unsigned int vl = query(a, b, k*2+1, l, (l+r)/2);\n    unsigned int vr = query(a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  int r, c, q;\n  while (scanf(\"%d %d %d\", &r, &c, &q) != EOF) {\n    init(r*c);\n\n    if (r < c) {\n      for (int i = 0; i < r*c; ++i) {\n\tint g;\n\tscanf(\"%d\", &g);\n\tupdate(i, g);\n      }\n\n      for (int i = 0; i < q; ++i) {\n\tint r1, c1, r2, c2;\n\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\tunsigned int ans = INF;\n\tfor (int j = r1; j < r2+1; ++j)\n\t  ans = min(ans, query(j*c+c1, j*c+c2+1, 0, 0, n));\n\tprintf(\"%d\\n\", ans);\n      }\n    } else {\n      for (int i = 0; i < r*c; ++i) {\n\tint g;\n\tscanf(\"%d\", &g);\n\tupdate(i/c+(i%c)*r, g);\n      }\n\n      for (int i = 0; i < q; ++i) {\n\tint r1, c1, r2, c2;\n\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\tunsigned int ans = INF;\n\tfor (int j = c1; j < c2+1; ++j)\n\t  ans = min(ans, query(j*r+r1, j*r+r2+1, 0, 0, n));\n\tprintf(\"%d\\n\", ans);\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build() {\n\t\tint h = sp[0].size()/2, w = sp[0][0][0].size()/2, ir, ic, jr, jc;\n\t\tfor (ir=0;ir<h;ir++)\n\t\t\tfor (jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor (ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor (jr=1;jr<=log2(h);jr++)\n\t\t\tfor (ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor (jc=0;jc<=log2(w);jc++)\n\t\t\t\t\tfor (ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n};\n\nint h, w, q, xa, ya, xb, yb;\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tSPA2<int> sp(h,w);\n\t\tint t;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build();\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    w=h;\n    while(w<w_)w*=2;\n    h=w;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx)return INF;\n    else if(qmaxy<miny||maxy<qminy)return INF;\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ¡ñ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // c\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 695;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][10][10];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = INT_MAX;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nint data[2 * 2 * 2 * 2 * 1000100];\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[1000100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint **dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\t\t\n\t\tdat = new int*[r * 2 - 1];\n\t\tfor(int i = r * 2 - 2; i >= 0; --i){\n\t\t\tdat[i] = new int[c * 2 - 1];\n\t\t\tfor(int j = c * 2 - 2; j >= 0; --j) dat[i][j] = INT_MAX;\n\t\t}\n\n\t\tint *datr = new int[c * 2 - 1];\n\t\tfor(int i = c * 2 - 2; i >= 0; --i) datr[i] = INT_MAX;\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr, datr + (c * 2 - 1), dat[i + r - 1]);\n\t\t}\n\t\t\n\t\tdelete[] datr;\n\n\t\tfor(int j = 0; j < c * 2 - 1; ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < r; ++i)\n\t\t\tdelete[] dat[i];\n\t\tdelete[] dat;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build() {\n\t\tint h = sp[0].size(), w = sp[0][0][0].size(), ir, ic, jr, jc;\n\t\tfor (ir=0;ir<h;ir++)\n\t\t\tfor (jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor (ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor (jr=1;jr<=log2(h);jr++)\n\t\t\tfor (ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor (jc=0;jc<=log2(w);jc++)\n\t\t\t\t\tfor (ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n\tvoid free() { vector<vector<vector<vector<V> > > >().swap(sp);}\n};\n\nint h, w, q, xa, ya, xb, yb;\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tSPA2<int> sp(h,w);\n\t\tint t;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build();\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t\tsp.free();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W;\nint y1, x1, y2, x2;\nvector<vi> g;\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y][x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", &g[i + H - 1][j + W - 1]);\n\t\t\n\t\tfor(int i = 2*H-2; i >= 0; i--){\n\t\t\tfor(int j = 2*W-2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i][j] = min(min(g[i*2 + 1][j*2 + 1], g[i*2 + 2][j*2 + 2]),\n\t\t\t\t\t\tmin(g[i*2 + 2][j*2 + 1], g[i*2 + 1][j*2 + 2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i*2 + 1][j], g[i*2 + 2][j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2 + 1], g[i][j*2 + 2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t\tg.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int grid[N];\n  int rmq[N];\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    int bs_r = (int)sqrt(r), bs_c = (int)sqrt(c);\n    int bn_r = r/bs_r, bn_c = c/bs_c;\n    if(r%bs_r)bn_r++;\n    if(c%bs_c)bn_c++;\n \n    for(int i=0;i<bn_r;i++){\n      for(int j=0;j<bn_c;j++)rmq[i*bn_c + j] = (1<<31) -1;\n    }\n    \n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c + j];\n\trmq[(i/bs_r) * bn_c + (j/bs_c)] = min(rmq[(i/bs_r) * bn_c + (j/bs_c)],grid[i*c + j]);\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ans = (1<<31) -1;\n\n\n      int sr = r1/bs_r;\n      int sc = c1/bs_c;\n      int gr = r2/bs_r;\n      int gc = c2/bs_c;\n\n      if(sr == gr || sc == gc){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n      }else{\n\tif(r1%bs_r){\n\t  sr++;\n\t  for(int i=r1;i<sr*bs_r;i++){\n\t    for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n\t\n\t\n\tif(c1%bs_c){\n\t  sc++;\n\t  for(int i=r1;i<=r2;i++){\n\t    for(int j=c1;j<sc*bs_c;j++)ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n\n\tif( (r2+1)%bs_r){\n\t  for(int i=gr*bs_r;i<=r2;i++){\n\t    for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t  }\n\t  gr--;\n\t}\n  \n\tif( (c2+1)%bs_c){\n\t  for(int i=r1;i<=r2;i++){\n\t    for(int j=gc*bs_c;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t  }\n\t  gc--;\n\t}\n\t\n\tfor(int i=sr;i<=gr;i++){\n\t  for(int j=sc;j<=gc;j++){\n\t    ans = min(ans,rmq[i*bn_c+j]);\n\t  }\n\t}\n      }\n      \n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\n\t\tbool is_reverse = r > c;\n\t\tvector<seg_tree<ll>> segs(max(r,c), seg_tree<ll>(max(r,c)));\n\t\tREP(i, r) REP(j, c) {\n\t\t\tll x = i, y = j;\n\t\t\tif (is_reverse) swap(x, y);\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tif (is_reverse) swap(x_1, y_1), swap(x_2, y_2);\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int** dat;\n    \n    RMQ2D(int h, int w, int** grid)\n    {\n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        dat = new int*[2 * H - 1];\n        for (int i = 0; i < 2 * H - 1; i++) {\n            dat[i] = new int[2 * W - 1];\n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[i][j] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[i + H - 1][j + W - 1] = grid[i][j]; \n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[i][j] = std::min(dat[i][j * 2 + 1], dat[i][j * 2 + 2]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[j][i] = std::min(dat[j * 2 + 1][i], dat[j * 2 + 2][i]);\n            }\n        }\n    }\n\n    ~RMQ2D() {\n        delete[] dat;\n    }\n    \n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[j][k];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n        \n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        int** grid;\n        grid = new int*[H];\n        \n        for (int i = 0; i < H; i++) {\n            grid[i] = new int[W];\n            for (int j = 0; j < W; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n        RMQ2D r(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            std::cout << r.query(y1, x1, y2, x2) << std::endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<cstring>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint node[9000000];\nint h, w;\n\nint enc(int i, int j){\n    return i*(2*w-1)+j;\n}\n\nvoid init(int hsiz, int wsiz, vector<vector<int>> &v){\n    for(int i = 0; i < hsiz; i++){\n        for(int j = 0; j < wsiz; j++){\n            node[enc(h-1+i,w-1+j)] = v[i][j];\n        }\n    }\n    for(int i = 2*h-2; i > h-2; i--){\n        for(int j = w-2; j >= 0; j--){\n            node[enc(i,j)] = min(node[enc(i,2*j+1)], node[enc(i,2*j+2)]);\n        }\n    }\n    for(int i = h-2; i >= 0; i--){\n        for(int j = 0; j < 2*w-1; j++){\n            node[enc(i,j)] = min(node[enc(2*i+1,j)], node[enc(2*i+2,j)]);\n        }\n    }\n}\n\nvoid seg2d(vector<vector<int>> &v){\n    int hsiz = v.size(), wsiz = v[0].size();\n    h = w = 1;\n    while(h < hsiz)    h *= 2;\n    while(w < wsiz)    w *= 2;\n    int lim = enc(2*h, 2*w);\n    for(int i = 0; i < lim; i++)    node[i] = INF;\n    init(hsiz, wsiz, v);\n}\n\nint query_w(int lj, int rj, int l, int r, int i, int k){\n    if(rj <= l || r <= lj)  return INF;\n    if(lj <= l && r <= rj)  return node[enc(i,k)];\n    int lx = query_w(lj,rj,l,(l+r)/2,i,2*k+1);\n    int rx = query_w(lj,rj,(l+r)/2,r,i,2*k+2);\n    return min(lx, rx);\n}\n\nint query_h(int li, int lj, int ri, int rj, int l, int r, int k){\n    if(ri <= l || r <= li)  return INF;\n    if(li <= l && r <= ri)  return query_w(lj, rj, 0, w, k, 0);\n    int lx = query_h(li,lj,ri,rj,l,(l+r)/2,2*k+1);\n    int rx = query_h(li,lj,ri,rj,(l+r)/2,r,2*k+2);\n    return min(lx, rx);\n}\n\nint query(int li, int lj, int ri, int rj){\n    return query_h(li, lj, ri, rj, 0, h, 0);\n}\n\nint main(){\n    int r, c, q;\n    while(cin >> r >> c >> q, r+c+q){\n        vector<vector<int>> v(r, vector<int>(c));\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                cin >> v[i][j];\n            }\n        }\n        seg2d(v);\n        while(q-- > 0){\n            int li, lj, ri, rj;\n            cin >> li >> lj >> ri >> rj;\n            cout << query(li,lj,ri+1,rj+1) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1LL<<31-1)\n\nstruct SegTree {\n\tint segSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<int>(segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=50;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&mi<latte[(y2-1)/B])y2=(y2%B?y2/B*B:y2-1);\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&mi<malta[x1/B])x1=(x1/B+1)*B;\n\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&mi<malta[(x2-1)/B])x2=(x2%B?x2/B*B:x2-1);\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst long long int INF=1000000000000000;\nvector<vector<long long int> > dc;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<long long int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nlong long int query(vector<long long int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tint vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tc2=init(c)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tlong long int res=INF;\n\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t}\n\t\t\tprintf(\"%dll\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i][j];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d]=min(segtree[a][d],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[n+a];\n\t\tfor(int i=0;i<n+a;i++){\n\t\t\tsegtree[i]=new int[m+b];\n\t\t\tfor(int j=0;j<m+b;j++)segtree[i][j]=2147483647;\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t\tfor(int i=0;i<n+a;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define la (rt*4)\n#define lb (rt*4+1)\n#define lc (rt*4+2)\n#define ld (rt*4+3)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\n\nstruct seg\n{\n    int x1,y1,x2,y2;\n    int v;\n    int midx()\n    {\n        return (x1+x2)>>1;\n    }\n    int midy()\n    {\n        return (y1+y2)>>1;\n    }\n}tr[1000010*5];\nvector<int>matrix[1000010];\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1==x2&&y1==y2)\n    {\n        tr[rt].v = matrix[x1][y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n    }\n    else if(y1 == y2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n    }\n    else\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n    }\n    return;\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1)\n    {\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx)\n    {\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my)\n    {\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx)\n    {\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my)\n    {\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    int r,c,q;\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q)\n    {\n        for(int i = 0; i < r; ++i)\n        {\n            matrix[i].clear();\n            for(int j = 0; j < c; ++j)\n            {\n                int x;\n                scanf(\"%d\",&x);\n                matrix[i].push_back(x);\n            }\n        }\n        build(1,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i)\n        {\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            if (a > c) swap(a, c);\n            if (b > d) swap(b, d);\n            printf(\"%d\\n\",query(1,a,b,c,d));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const lli MAX_N=1<<28;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint **dat;\nint R, C;\n\nvoid update(int r, int c, int x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(true){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tif (cc == 0) break;\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tint v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tint v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tint v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tint v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\t\n\t\tdat = new int*[R * 2 - 1];\n\t\tfor(int i = 0; i < R * 2 - 1; ++i){\n\t\t\tdat[i] = new int[C * 2 - 1];\n\t\t} // end for\n\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tint x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\n\t\tfor(int i = 0; i < R * 2 - 1; ++i){\n\t\t\tdelete[] dat[i];\n\t\t\tdat[i] = 0;\n\t\t} // end for\n\t\tdelete[] dat;\n\t\tdat = 0;\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <cstdlib>\n// AOJ 1068 - School of Killifish\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntemplate <class T>\nclass malloc_allocator {\npublic:\n\ttypedef size_t size_type;\n\ttypedef ptrdiff_t difference_type;\n\ttypedef T *pointer;\n\ttypedef const T *const_pointer;\n\ttypedef T &reference;\n\ttypedef const T &const_reference;\n\ttypedef T value_type;\n\t\n\ttemplate <class U>\n\tstruct rebind {\n\t\ttypedef malloc_allocator<U> other;\n\t};\n\t\n\tmalloc_allocator() throw() { }\n\tmalloc_allocator(const malloc_allocator &) throw() { }\n\ttemplate <class U> malloc_allocator(const malloc_allocator<U>&) throw() { }\n\t~malloc_allocator() throw(){}\n\t\n\tpointer allocate(size_type num, const void *hint = 0){\n\t\treturn reinterpret_cast<pointer>(malloc(sizeof(T) * num));\n\t}\n\tvoid construct(pointer p, const T& value){\n\t\tnew( (void*)p ) T(value);\n\t}\n\t\n\tvoid deallocate(pointer p, size_type num){\n\t\tfree(p);\n\t}\n\tvoid destroy(pointer p){\n\t\tp->~T();\n\t}\n\t\n\tpointer address(reference value) const { return &value; }\n\tconst_pointer address(const_reference value) const { return &value; }\n\t\n\tsize_type max_size() const throw(){\n\t\treturn numeric_limits<size_t>::max() / sizeof(T);\n\t}\n};\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< value_type, malloc_allocator<value_type> > m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size = 0, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.assign(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n\tvalue_type operator[](size_t i) const {\n\t\treturn m_data[m_size - 1 + i];\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree2D {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< SegmentTree<Traits> > m_data;\n\tsize_t m_width, m_height;\n\n\tvoid initialize(){\n\t\tvector<value_type> work(m_width);\n\t\tfor(int i = static_cast<int>(m_height) - 2; i >= 0; --i){\n\t\t\tfor(size_t j = 0; j < m_width; ++j){\n\t\t\t\twork[j] =\n\t\t\t\t\tm_traits(m_data[i * 2 + 1][j], m_data[i * 2 + 2][j]);\n\t\t\t}\n\t\t\tm_data[i] = SegmentTree<Traits>(work.begin(), work.end());\n\t\t}\n\t}\n\n\tvalue_type query(\n\t\tint x0, int y0, int x1, int y1, int k, int l, int r) const\n\t{\n\t\tif(r <= y0 || y1 <= l){ return m_traits.default_value(); }\n\t\tif(y0 <= l && r <= y1){ return m_data[k].query(x0, x1); }\n\t\tconst value_type vl = query(x0, y0, x1, y1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(x0, y0, x1, y1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tsize_t height = 0, size_t width = 0, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(width)\n\t{\n\t\twhile(m_height < height){ m_height *= 2; }\n\t\tm_data.assign(m_height * 2 - 1, SegmentTree<Traits>(width, traits));\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree2D(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(0)\n\t{\n\t\tconst size_t h = distance(first, last);\n\t\twhile(m_height < h){ m_height *= 2; }\n\t\tif(h > 0){ m_width = distance(first->begin(), first->end()); }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(m_width, traits));\n\t\tsize_t row = m_height - 1;\n\t\tfor(Iterator it = first; it != last; ++it, ++row){\n\t\t\tm_data[row] = SegmentTree<Traits>(it->begin(), it->end());\n\t\t}\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, size_t j, const value_type &val){\n\t\ti += m_height - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_traits(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(size_t x0, size_t y0, size_t x1, size_t y1) const {\n\t\treturn query(x0, y0, x1, y1, 0, 0, m_height);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct MinSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT operator()(const T &a, const T &b) const { return min(a, b); }\n};\n\n\n}\n}\n\n\nusing libcomp::structure::SegmentTree2D;\nusing libcomp::structure::MinSegmentTreeTraits;\ntypedef SegmentTree2D< MinSegmentTreeTraits<int> > MinSegmentTree2D;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tsize_t r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tMinSegmentTree2D st(r, c);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){\n\t\t\t\tint aij;\n\t\t\t\tcin >> aij;\n\t\t\t\tst.update(i, j, aij);\n\t\t\t}\n\t\t}\n\t\twhile(q--){\n\t\t\tint y0, x0, y1, x1;\n\t\t\tcin >> y0 >> x0 >> y1 >> x1;\n\t\t\tcout << st.query(x0, y0, x1 + 1, y1 + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a)*(b+m)>7500000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 5000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return LLONG_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\ninline int MIN(int a,int b){\n\treturn a<b?a:b;\n}\nstruct SSS{\n\tint p[16];\n}st[1010000];\nSSS *top,*at[1100];\nint tlog[1010000];\nSSS *getptr(int len) {\n\tSSS *p=top;\n\ttop+=(len+1);\n\treturn p;\n}\nint p[1010000],r,c,q;\nvoid ST(SSS st[],int sz,int fg,int s){\n\tif(fg) {\n\t\tfor(int i=1;i<=sz;i++) st[i].p[0]=p[(s-1)*c+i];\n\t} else {\n\t\tfor(int i=1;i<=sz;i++) st[i].p[0]=p[(i-1)*c+s];\n\t}\n\tfor(int j=1;j<=tlog[sz];j++){\n          for(int i=0;j<=tlog[sz+1-i];i++){\n               st[i].p[j]=MIN(st[i].p[j-1],st[i+(1<<j>>1)].p[j-1]);\n          }\n    }\n}\nint RMQ(SSS st[],int l,int r){\n    int tmp=tlog[r-l+1];\n    return MIN(st[l].p[tmp],st[r-(1<<tmp)+1].p[tmp]);\n}\nvoid scanf_(int &num){\n\tchar in;\n\tbool neg=false;\n\twhile(((in=getchar())>'9'||in<'0')&&in!='-');\n\tif(in=='-'){\n\t\tneg=true;\n\t\twhile((in=getchar())>'9'||in<'0');\n\t}\n\tnum=in-'0';\n\twhile(in=getchar(),in>='0'&&in<='9')\n\t\tnum*=10,num+=in-'0';\n\tif(neg)\n\tnum=0-num;\n}\nint main(){\n\ttlog[0]=-1;\n\tfor(int i=1;i<1010000;i++){\n\t\ttlog[i]=tlog[i-1]+((i&(i-1))?0:1);\n\t}\n\twhile(scanf(\"%d%d%d\",&r,&c,&q),(r||c||q)) {\n\t\ttop=st;\n\t\tfor(int i=1;i<=r;i++) {\n\t\t\tfor(int j=1;j<=c;j++) scanf_(p[(i-1)*c+j]);\n\t\t}\n\t\tif(r<=c) {\n\t\t\tfor(int i=1;i<=r;i++) {\n\t\t\t\tat[i]=getptr(c);\n\t\t\t\tST(at[i],c,1,i);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=r1;j<=r2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],c1,c2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i=1;i<=c;i++) {\n\t\t\t\tat[i]=getptr(r);\n\t\t\t\tST(at[i],r,0,i);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=c1;j<=c2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],r1,r2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, vector<int> a){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n, INT_MAX);\n            for(int i = n; i < n + n_; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j + 1, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            a.second++; b.second++;\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=50;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[y2/B]&&y2%B!=0)y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[x2/B]&&x2%B!=0)x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\n#define DEBUG\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\nuint field[sz];\nuint dat[sz * 20];\nint R, C, Q;\n\n#define FIELD(r, c) (field[(r) * C + (c)])\n#define DAT(kr, kc) (dat[(kr) * (C) * 4 + (kc)])\n\nvoid build(int lr, int rr, int lc, int rc, int kr, int kc, bool r_axis = true){\n  if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = FIELD(lr, lc);\n  }else if((r_axis && rr - lr > 1) || rc - lc == 1){\n    assert(rr - lr != 1);\n    int mr = (lr + rr) / 2;\n    build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n    build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n    DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    \n  }else{\n    int mc = (lc + rc) / 2;\n    build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n    build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n    DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n           int lr = 0, int rr = R, int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc || rr <= lr || rc <= lc)return INF;\n  \n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc){\n    return DAT(kr, kc);\n  }else if((r_axis && rr - lr > 1) || rc - lc == 1){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\nuint naive(int ar, int br, int ac, int bc){\n  uint ans = INF;\n  REP2(i, ar, br)REP2(j, ac, bc) ans = min(ans, FIELD(i, j));\n  return ans;\n}\n\nint main(){\n  int r1, r2, c1, c2;\n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &FIELD(r, c));\n    if(R > 0 && C > 0) build(0, R, 0, C, 0, 0);\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n\n\n#ifdef DEBUG\n    REP(r2, R)REP(r1, r2 + 1)REP(c2, C)REP(c1, c2 + 1){\n      // cout << naive(r1, r2 + 1, c1, c2 + 1) << \" \" << query(r1, r2 + 1, c1, c2 + 1) << endl;\n      assert(naive(r1, r2 + 1, c1, c2 + 1) == query(r1, r2 + 1, c1, c2 + 1));\n    }\n#endif\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n// AOJ 1068 - School of Killifish\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector<value_type> m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size = 0, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n\tvalue_type operator[](size_t i) const {\n\t\treturn m_data[m_size - 1 + i];\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree2D {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< SegmentTree<Traits> > m_data;\n\tsize_t m_width, m_height;\n\n\tvoid initialize(){\n\t\tvector<value_type> work(m_width);\n\t\tfor(int i = static_cast<int>(m_height) - 2; i >= 0; --i){\n\t\t\tfor(size_t j = 0; j < m_width; ++j){\n\t\t\t\twork[j] =\n\t\t\t\t\tm_traits(m_data[i * 2 + 1][j], m_data[i * 2 + 2][j]);\n\t\t\t}\n\t\t\tm_data[i] = SegmentTree<Traits>(work.begin(), work.end());\n\t\t}\n\t}\n\n\tvalue_type query(\n\t\tint x0, int y0, int x1, int y1, int k, int l, int r) const\n\t{\n\t\tif(r <= y0 || y1 <= l){ return m_traits.default_value(); }\n\t\tif(y0 <= l && r <= y1){ return m_data[k].query(x0, x1); }\n\t\tconst value_type vl = query(x0, y0, x1, y1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(x0, y0, x1, y1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tsize_t height = 0, size_t width = 0, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(width)\n\t{\n\t\twhile(m_height < height){ m_height *= 2; }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(width, traits));\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree2D(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(0)\n\t{\n\t\tconst size_t h = distance(first, last);\n\t\twhile(m_height < h){ m_height *= 2; }\n\t\tif(h > 0){ m_width = distance(first->begin(), first->end()); }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(m_width, traits));\n\t\tsize_t row = m_height - 1;\n\t\tfor(Iterator it = first; it != last; ++it, ++row){\n\t\t\tm_data[row] = SegmentTree<Traits>(it->begin(), it->end());\n\t\t}\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, size_t j, const value_type &val){\n\t\ti += m_height - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_traits(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(size_t x0, size_t y0, size_t x1, size_t y1) const {\n\t\treturn query(x0, y0, x1, y1, 0, 0, m_height);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct MinSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT operator()(const T &a, const T &b) const { return min(a, b); }\n};\n\n\n}\n}\n\n\nusing libcomp::structure::SegmentTree2D;\nusing libcomp::structure::MinSegmentTreeTraits;\ntypedef SegmentTree2D< MinSegmentTreeTraits<int> > MinSegmentTree2D;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tsize_t r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tMinSegmentTree2D st(r, c);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){\n\t\t\t\tint aij;\n\t\t\t\tcin >> aij;\n\t\t\t\tst.update(i, j, aij);\n\t\t\t}\n\t\t}\n\t\twhile(q--){\n\t\t\tint y0, x0, y1, x1;\n\t\t\tcin >> y0 >> x0 >> y1 >> x1;\n\t\t\tcout << st.query(x0, y0, x1 + 1, y1 + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 0))));}\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build(int h, int w) {\n\t\tint ir, ic, jr, jc;\n\t\tfor(ir=0;ir<h;ir++)\n\t\t\tfor(jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor(ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor(jr=1;jr<=log(h);jr++)\n\t\t\tfor(ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor(jc=0;jc<=log(w);jc++)\n\t\t\t\t\tfor(ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n};\n\nint h, w, q, xa, ya, xb, yb;\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tSPA2<int> sp(h,w);\n\t\tint t;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build(h,w);\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\nunsigned int _seg[11111111];\nvector<unsigned int*> seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ???????????????\n#include<vector>\n#include<algorithm>\nstd::vector<int> answer;\n// ?????°\nconst int MAX_N = 500000;\nconst int NIL = -1;\n// ???\nstruct Vertex {int label, x, y;};\nstruct Node {int left_child, right_child;};\n// ?????°\nint root;\nNode node[MAX_N];\nVertex vertex[MAX_N];\n// ?????????\nclass Compare {\npublic:\n  Compare(int d) : d(d) {}\n  bool operator()(const Vertex& lhs, const Vertex& rhs) const {return d & 1 ? lhs.y < rhs.y : lhs.x < rhs.x;}\nprivate:\n  int d;\n};\n// ?§????\nint build(int low, int high, int depth) {\n  if(!(low < high)) return NIL;\n  std::sort(vertex + low, vertex + high, Compare(depth));\n  int middle = (low + high) / 2;\n  node[middle].left_child = build(low, middle, depth ^ 1);\n  node[middle].right_child = build(middle + 1, high, depth ^ 1);\n  return middle;\n}\n// ?????¢?????????????????°?????????????????°??¨???????????¢???????????§?¨????????????§?¨??????????\nvoid search(int index, int sx, int sy, int tx, int ty, int depth) {\n  if(index == NIL) return;\n  if(sx <= vertex[index].x && vertex[index].x <= tx && sy <= vertex[index].y && vertex[index].y <= ty) answer.push_back(vertex[index].label);\n  if(depth & 1) {\n    if(sy <= vertex[index].y) search(node[index].left_child, sx, sy, tx, ty, depth ^ 1);\n    if(vertex[index].y <= ty) search(node[index].right_child, sx, sy, tx, ty, depth ^ 1);\n  } else {\n    if(sx <= vertex[index].x) search(node[index].left_child, sx, sy, tx, ty, depth ^ 1);\n    if(vertex[index].x <= tx) search(node[index].right_child, sx, sy, tx, ty, depth ^ 1);\n  }\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    int size = 0;\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      vertex[size++] = {grid, x, y};\n    }\n    root = build(0, size, 0);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      answer.clear();\n      search(root, c1, r1, c2, r2, 0);\n      cout << *min_element(begin(answer), end(answer)) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define M 1000000\n#define inf 0x7FFFFFFF\nusing namespace std;\n\nint arr[M+10],dat[M+10],p[M+10],LOG[M+10];\nint dp[250010][19];\nvoid init_rmq(int n,int dp[][19],int dt[]){\n\tfor(int i=0;i<n;i++)\n\t\tdp[i][0]=dt[i];\n\tint k=LOG[n]/LOG[2];\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(j+p[i-1]<n)\n\t\t\t\tdp[j][i]=min(dp[j][i-1],dp[j+p[i-1]][i-1]);\n\t\t\telse dp[j][i]=dp[j][i-1];\n}\nint query_rmq(int a,int b,int dp[][19]){\n\tint x=a,y=b;\n\tif(x>y) swap(x,y);\n\tint k=LOG[y-x+1]/LOG[2];\n\treturn min(dp[x][k],dp[y-p[k]+1][k]);\n}\n\nint main(){\n\tp[0]=1;\n\tfor(int i=1;i<19;i++) p[i]=p[i-1]*2;\n\tLOG[0]=-1;\n\tfor(int i=1;i<=M;i++)\n\tLOG[i]=(i&(i-1))?LOG[i-1]:LOG[i-1] + 1 ;\n\t\n\tint n,m,q;\n\twhile(scanf(\"%d%d%d\",&n,&m,&q),n||m||q){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tscanf(\"%d\",&arr[i*m+j]);\n\t\t\t\t\n\t\tif(n*m>250000){\n\t\t\twhile(q--){\n\t\t\t\tint l1,l2,r1,r2;\n\t\t\t\tscanf(\"%d%d%d%d\",&l1,&r1,&l2,&r2);\n\t\t\t\tint ans=inf;\n\t\t\t\tfor(int i=l1;i<=l2;i++)\n\t\t\t\t\tfor(int j=r1;j<=r2;j++)\n\t\t\t\t\t\tans=min(ans,arr[i*m+j]);\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n<m){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++) dat[j]=arr[i*m+j];\n\t\t\t\tinit_rmq(m,dp+i*m,dat);\n\t\t\t}\n\t\t\twhile(q--){\n\t\t\t\tint l1,l2,r1,r2;\n\t\t\t\tscanf(\"%d%d%d%d\",&l1,&r1,&l2,&r2);\n\t\t\t\tint ans=inf;\n\t\t\t\tfor(int i=l1;i<=l2;i++)\n\t\t\t\t\tans=min(ans,query_rmq(r1,r2,dp+i*m));\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++) dat[j]=arr[j*m+i];\n\t\t\t\tinit_rmq(n,dp+i*n,dat);\n\t\t\t}\n\t\t\twhile(q--){\n\t\t\t\tint l1,l2,r1,r2;\n\t\t\t\tscanf(\"%d%d%d%d\",&l1,&r1,&l2,&r2);\n\t\t\t\tint ans=inf;\n\t\t\t\tfor(int i=r1;i<=r2;i++)\n\t\t\t\t\tans=min(ans,query_rmq(l1,l2,dp+i*n));\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#define INF INT_MAX\n#define def INF\nusing V = int;\nV comp(V& l, V& r) { return min(l,r); };\nstruct SegTree { //[l,r)\n    int NV;\n    vector<V> val;\n    void init(int n) {\n        NV = 1;\n        while (NV < n) NV *= 2;\n        val = vector<V>(NV * 2, def);\n    }\n    V get(int x, int y, int l, int r, int k) {\n        if (r <= x || y <= l) return def; if (x <= l&&r <= y)return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2); auto b = get(x, y, (l + r) / 2, r, k * 2 + 1); return comp(a, b);\n    }\n    V get(int x, int y) { return get(x, y, 0, NV, 1); }\n    void update(int i, V v) { i += NV; val[i] = v; while (i>1)i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]); }\n    void compupdate(int i, V v) { update(i, comp(v, val[i + NV])); }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\nstruct StaticHealthy2DSegTree {\n    int NV;\n    vector<SegTree> st;\n    vector<vector<int>> index;\n    \n    void init(vector<vector<pair<int,V>>> &v) {\n        int n = v.size();\n        NV = 1; while (NV < n) NV *= 2;\n        index.resize(2 * NV);\n        rep(i, 0, n) fore(p, v[i]) index[i + NV].push_back(p.first);\n        rrep(i, NV * 2 - 1, 1) {\n            sort(index[i].begin(), index[i].end());\n            index[i].erase(unique(index[i].begin(), index[i].end()), index[i].end());\n            fore(j, index[i]) index[i / 2].push_back(j);\n        }\n        st.resize(2 * NV);\n        rep(i, 1, NV * 2) st[i].init(index[i].size());\n        \n        rep(i, 0, n) fore(p, v[i]) {\n            int j = lower_bound(index[i + NV].begin(), index[i + NV].end(), p.first) - index[i + NV].begin();\n            st[i + NV].update(j, p.second);\n        }\n\n        rrep(i, NV * 2 - 1, 2) {\n            rep(j, 0, index[i].size()) {\n                V v = st[i][j];\n                \n                int k = lower_bound(index[i / 2].begin(), index[i / 2].end(), index[i][j]) - index[i / 2].begin();\n                st[i / 2].compupdate(k, v);\n            }\n        }\n    }\n    V get(int sx, int tx, int sy, int ty, int k, int l, int r) {\n        assert(k < NV * 2);\n        assert(l < r);\n        if (r <= sx or tx <= l) return def;\n        if (sx <= l and r <= tx) {\n            int syy = lower_bound(index[k].begin(), index[k].end(), sy) - index[k].begin();\n            int tyy = lower_bound(index[k].begin(), index[k].end(), ty) - index[k].begin();\n            return st[k].get(syy, tyy);\n        }\n        int md = (l + r) / 2;\n        V le = get(sx, tx, sy, ty, k * 2, l, md);\n        V ri = get(sx, tx, sy, ty, k * 2 + 1, md, r);\n        return comp(le, ri);\n    }\n    V get(int sx, int tx, int sy, int ty) {\n        return get(sx, tx, sy, ty, 1, 0, NV);\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\nint R, C, Q;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> R >> C >> Q) {\n        if (R == 0) return;\n        StaticHealthy2DSegTree st;\n        vector<vector<pair<int, int>>> v(C);\n        rep(r, 0, R) rep(c, 0, C) {\n            int x; cin >> x;\n            v[c].push_back({ r, x });\n        }\n        st.init(v);\n\n        rep(i, 0, Q) {\n            int a, b, c, d; cin >> a >> b >> c >> d;\n            int ans = st.get(b, d + 1, a, c + 1);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tassert((wbin * 2 - 1) * (hbin * 2 - 1) <= 10000000);\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<vector<int> > dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\n\t\tdat.assign(r * 2 - 1, vector<int>(c * 2 - 1, INT_MAX) );\n\t\tvector<int> datr = dat[0];\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1].begin());\n\t\t}\n\n\t\tfor(int j = 0; j < datr.size(); ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\n/*int query(int a,int b,int e,int f,int g,int h,int i,int j){\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}*/\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[a];\n\t\tfor(int i=0;i<a;i++){\n\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,2147483647-d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tint ret=0;\n\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t}\n\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    if(h>w)w=h;\n    if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        //if(dat[k*2+1]!=-1&&dat[k*2+1]<dat[k*2+2])dat[k]=dat[k*2+1];\n        //else dat[k]=dat[k*2+2];\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",(int)res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nint const MAX_SIZE = 250000*40;\nstruct Pool {\n    static dat_t dat[MAX_SIZE];\n    static int size;\n    static dat_t * fetch(int len){\n        dat_t * res = dat + size;\n        size+=len;\n        return res;\n    }\n    static void reset(){\n        size = 0;\n    }\n};\n\nint Pool::size = 0;\ndat_t Pool::dat[MAX_SIZE];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_ = 0){\n        int k = 1;\n        while(k < n_) k<<=1;\n        n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        n = k;\n        dat.assign(n*2, SegTree(0));\n        rep(i,n*2) dat[i] = SegTree(w);\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n//\tvector<int> seg;\n\tint seg[1 << 11];\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tfill(&seg[0], &seg[0]+nodeSize+segSize, INF);\n//\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\treturn seg[n];\n//\t\tif (n < (int)seg.size()) return seg[n];\n//\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tseg[n] = v;\n//\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\t//seg.clear();\n\t\t//seg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tvector<T> a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector<T> &v):n(1){\n\t\tint N=v.size();\n\t\twhile(n<N) n<<=1;\n\t\ta=vector<T>(2*n-1);\n\t\trep(i,N) a[n+i-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a1(h,vi(w)),a2(w,vi(h));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a1[i][j]), a2[j][i]=a1[i][j];\n\n\t\tstatic RMQ<int> rmq1[1000000],rmq2[1000000];\n\t\trep(i,h) rmq1[i]=RMQ<int>(a1[i]);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a2[j]);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\n//unsigned int _seg[11111111];\n//vector<unsigned int*> seg;\nunsigned int** seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg = (unsigned int**)malloc(sizeof(unsigned int*) * (2 * _r - 1));\n  rep(i, 2 * _r - 1) seg[i] = (unsigned int*)malloc(sizeof(unsigned int) * (2 * _c - 1));\n  /*\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n  */\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n    free(seg);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(n * 2, id) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\tl += n; r += n + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) res1 = merge(res1, data[l++]);\n\t\t\tif (r & 1) res2 = merge(data[--r], res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h;\n\tconst T id;\n\tfunc_t merge;\n\tvector<SegmentTree<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), id(id_), merge(merge_), data(h * 2, SegmentTree<T>(w_, id, merge)) {}\n\tvoid Init(const vector<vector<T>>& v) {\n\t\tfor (int i = 0; i < (int)v.size(); i++) data[i + h].Init(v[i]);\n\t\tint w = v.front().size();\n\t\tvector<T> tmp(w);\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ttmp[j] = merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j));\n\t\t\t}\n\t\t\tdata[i].Init(tmp);\n\t\t}\n\t}\n\tvoid Update(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Update(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j)));\n\t}\n\tvoid Add(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Add(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j)));\n\t}\n\tT Find(int i, int j) {\n\t\treturn data[i + h].Find(j);\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\tli += h; ri += h + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (li < ri) {\n\t\t\tif (li & 1) res1 = merge(res1, data[li++].Find(lj, rj));\n\t\t\tif (ri & 1) res2 = merge(data[--ri].Find(lj, rj), res2);\n\t\t\tli >>= 1; ri >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> v(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\tst.Init(v);\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<vector<int> > segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i][j];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d]=min(segtree[a][d],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree.clear();\n\t\tsegtree=vector<vector<int> >(n*2,vector<int>(m*2,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nclass RMQ{\npublic:\n  RMQ(){}\n  RMQ(int n_){\n    init(n_);\n  }\n  void init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    dat.resize(2*n - 1);\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = INT_MAX;\n  }\n  void update(int k,int a){\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1)/2;\n      dat[k] = min(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  void print(){\n    for (int i = n - 1; i < 2*n - 1; i++) {\n      std::cout << dat[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  lli query(int a,int b,int k = 0,int l = 0,int r = 0){\n    if(r <= l) r = n;\n    if(r <= a || b <= l) return 1e11;\n    if(a <= l && r <= b) return dat[k];\n    int vl = query(a, b, k*2 + 1, l, (r + l)/2);\n    int vr = query(a, b, k*2 + 2, (r + l)/2, r);\n    return min(vl,vr);\n  }\nprivate:\n  int n;\n  vector<int>dat;\n};\n\nvector<RMQ> makeSegTree(bool f, int mini,\n                        vector<vector<int > >& grid){\n  vector<RMQ> res(mini);\n  int maxi = max(grid.size(), grid[0].size());\n  for (int i = 0; i < mini; i++) {\n    res[i].init(maxi);\n  }\n  for (int i = 0; i < mini; i++) {\n    for (int j = 0; j < maxi; j++) {\n      if(f) res[i].update(j, grid[j][i]);\n      else res[i].update(j, grid[i][j]);\n    }\n  }\n  return res;\n}\nvoid printGrid(vector<vector<int> >& grid){\n  for (int i = 0; i < grid.size(); i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n      std::cout << grid[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\nint main(){\n  int r, c, q;\n  while(std::cin >> r >> c >> q){\n    if(r == 0 && c == 0)break;\n    int mini = min(r, c);\n    vector<vector<int> > grid(r, vector<int>(c));\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j < c; j++) {\n        std::cin >> grid[i][j];\n      }\n    }\n    vector<RMQ> t = makeSegTree(r > c, mini, grid);\n    //std::cout << \"ho\" << std::endl;\n    for (int i = 0; i < t.size(); i++) {\n      //t[i].print();\n    }\n    int x = 0, y, xx, yy;\n    for (int i = 0; i < q; i++) {\n      lli ans = 1e11;\n      std::cin >> y >> x >> yy >> xx;\n      if(r <= c)swap(x, y),swap(xx, yy);\n      //std::cout << x << \" \" << y << \" \" << xx << \" \" << yy << std::endl;\n      for (int j = x; j <= xx; j++) {\n        ans = min(ans, t[j].query(y, yy + 1));\n      }\n      std::cout << ans << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 1 == r&&u + 1 == d) {\n\t\t\tminnum = vs[u][l];\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int ql,const int qr,const int qu,const int qd,const int nl,const int nr,const int nu,const int nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd)return minnum;\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvector<vector<int>>vs(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000000\nusing namespace std;\ntypedef long long ll;\n\nint r, c, q, S;\nvector<ll> v[1000];\n\nvoid init(int x, int y){\n\trep(i,x){\n\t\trep(j,y*2){\n\t\t\tv[i][j] = INF;\n\t\t}\n\t}\n\tS = 1;\n\twhile(S <= y) S *= 2;\n}\n\nvoid update(int y, int x, ll t){\n\tx += S-1;\n\tv[y][x] = t;\n\twhile(x > 0){\n\t\tx = (x-1)/2;\n\t\tv[y][x] = min(v[y][2*x+1],v[y][2*x+2]);\n\t}\n}\n\nll get(int z, int a, int b, int t, int r, int l){\n\tif(a >= l || b <= r) return INF;\n\tif(a <= r && l <= b) return v[z][t];\n\treturn min(get(z,a,b,t*2+1,r,(r+l)/2),get(z,a,b,t*2+2,(r+l)/2,l));\n}\n\nint main(){\n\trep(i,1000){\n\t\trep(j,1000000/(i+1)*2){\n\t\t\tv[i].push_back(0);\n\t\t}\n\t}\n\twhile(scanf(\"%d%d%d\", &r, &c, &q), r||c||q){\n\t\tinit(min(r,c), max(r,c));\n\t\tif(r < c){\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(i,j,tmp);\n\t\t\t}\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t} else{\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(j,i,tmp);\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\n\n\nuint field[sz];\nuint dat[sz * 20];\n\nint R, C, Q;\n#define DAT(kr, kc) dat[(kr) * C * 4 + (kc)]\n\nvoid build(int lr = 0, int rr = R,\n           int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr - lr == 0 || rc - lc == 0){\n    DAT(kr, kc) = INF;\n  }else if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = field[lr * C + lc];\n  }else{\n    if(r_axis){\n      int mr = (lr + rr) / 2;\n      build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n      build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n      DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    }else{\n      int mc = (lc + rc) / 2;\n      build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n      build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n      DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n    }\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n          int lr = 0, int rr = R, int lc = 0, int rc = C,\n          int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc) return INF;\n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc) return DAT(kr, kc);\n  \n  if(r_axis){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\n\nint main(){\n  int r1, r2, c1, c2;\n  \n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &field[r * C + c]);\n\n    build();\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < MAX_N*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#define INF INT_MAX/2\n#define def INF\nusing V = int;\nV comp(V& l, V& r) { return min(l,r); };\nstruct SegTree { //[l,r)\n    int NV;\n    vector<V> val;\n    void init(int n) {\n        NV = 1;\n        while (NV < n) NV *= 2;\n        val = vector<V>(NV * 2, def);\n    }\n    V get(int x, int y, int l, int r, int k) {\n        if (r <= x || y <= l) return def; if (x <= l&&r <= y)return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2); auto b = get(x, y, (l + r) / 2, r, k * 2 + 1); return comp(a, b);\n    }\n    V get(int x, int y) { return get(x, y, 0, NV, 1); }\n    void update(int i, V v) { i += NV; val[i] = v; while (i>1)i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]); }\n    void compupdate(int i, V v) { update(i, comp(v, val[i + NV])); }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\nstruct StaticHealthy2DSegTree {\n    int NV;\n    vector<SegTree> st;\n    vector<vector<int>> index;\n    \n    void init(vector<vector<pair<int,V>>> &v) {\n        int n = v.size();\n        NV = 1; while (NV < n) NV *= 2;\n        index.resize(2 * NV);\n        rep(i, 0, n) fore(p, v[i]) index[i + NV].push_back(p.first);\n        rrep(i, NV * 2 - 1, 1) {\n            sort(index[i].begin(), index[i].end());\n            index[i].erase(unique(index[i].begin(), index[i].end()), index[i].end());\n            fore(j, index[i]) index[i / 2].push_back(j);\n        }\n        st.resize(2 * NV);\n        rep(i, 1, NV * 2) st[i].init(index[i].size());\n        \n        rep(i, 0, n) fore(p, v[i]) {\n            int j = lower_bound(index[i + NV].begin(), index[i + NV].end(), p.first) - index[i + NV].begin();\n            st[i + NV].update(j, p.second);\n        }\n\n        rrep(i, NV * 2 - 1, 2) {\n            rep(j, 0, index[i].size()) {\n                V v = st[i][j];\n                \n                int k = lower_bound(index[i / 2].begin(), index[i / 2].end(), index[i][j]) - index[i / 2].begin();\n                st[i / 2].compupdate(k, v);\n            }\n        }\n    }\n    V get(int sx, int tx, int sy, int ty, int k, int l, int r) {\n        assert(k < NV * 2);\n        assert(l < r);\n        if (r <= sx or tx <= l) return def;\n        if (sx <= l and r <= tx) {\n            int syy = lower_bound(index[k].begin(), index[k].end(), sy) - index[k].begin();\n            int tyy = lower_bound(index[k].begin(), index[k].end(), ty) - index[k].begin();\n            return st[k].get(syy, tyy);\n        }\n        int md = (l + r) / 2;\n        V le = get(sx, tx, sy, ty, k * 2, l, md);\n        V ri = get(sx, tx, sy, ty, k * 2 + 1, md, r);\n        return comp(le, ri);\n    }\n    V get(int sx, int tx, int sy, int ty) {\n        return get(sx, tx, sy, ty, 1, 0, NV);\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nint H, W, Q;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> H >> W >> Q) {\n        if (H == 0) return;\n\n        StaticHealthy2DSegTree st;\n\n        vector<vector<pair<int,int>>> index(W);\n        rep(y, 0, H) rep(x, 0, W) {\n            int v; cin >> v;\n            index[x].push_back({ y, v });\n        }\n        st.init(index);\n\n        rep(i, 0, Q) {\n            int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n            y2++, x2++;\n            int ans = st.get(x1, x2, y1, y2);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\nint h,w,a[1000000];\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tT *a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=w;\n\t\telse   N=h;\n\n\t\twhile(n<N) n<<=1;\n\t\ta=(T *)malloc((2*n-1)*sizeof(T));\n\t\trep(i,2*n-1) a[i]=0;\n\n\t\tif(!b) rep(i,N) a[n+i-1]=::a[k*w+i];\n\t\telse   rep(i,N) a[n+i-1]=::a[i*w+k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\trep(i,h) rep(j,w) scanf(\"%d\",a+(i*w+j));\n\n\t\tRMQ<int> *rmq1=(RMQ<int> *)malloc(h*sizeof(RMQ<int>));\n\t\tRMQ<int> *rmq2=(RMQ<int> *)malloc(w*sizeof(RMQ<int>));\n\t\trep(i,h) rmq1[i]=RMQ<int>(i,0);\n\t\trep(j,w) rmq2[j]=RMQ<int>(j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\n\t\tfree(rmq1);\n\t\tfree(rmq2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint tmp;\nvector<int> seg[1000];\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(r>=c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++){\n\tseg[i].clear();\n\tfor(int j=0;j<2*n-1;j++)seg[i].push_back( (1<<31)-1 );\n      }\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  int k = i;\n\t  k += n-1;\n\t  seg[j][k] = tmp;\n\t  while(k>0){\n\t    k = (k-1) / 2;\n\t    seg[j][k] = min(seg[j][k*2+1], seg[j][k*2+2]);\n\t  }\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++){\n\tseg[i].clear();\n\tfor(int j=0;j<2*n-1;j++)seg[i].push_back( (1<<31)-1 );\n      }\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  int k = j;\n\t  k += n-1;\n\t  seg[i][k] = tmp;\n\t  while(k>0){\n\t    k = (k-1) / 2;\n\t    seg[i][k] = min(seg[i][k*2+1], seg[i][k*2+2]);\n\t  }\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int size){\n\tsize--;\n\trep(i,5) size|=size>>(1<<i);\n\treturn size+1;\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegTree2D{\n\tint size;\n\tvector<SegTree> data;\n\tSegTree2D(int h,int w):size(Need(h)),data(size*2,SegTree(w)){}\n\tvoid Update(int i,int j,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i].Update(j,x);\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\tint res=INFTY,m=(to+bo)/2;\n\t\tif(a<m) res=min(res,Query(a,b,c,d,i*2+0,to,m));\n\t\tif(m<c) res=min(res,Query(a,b,c,d,i*2+1,m,bo));\n\t\treturn res;\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(min(r,c),vi(max(r,c)));\n\t\tif(r<=c) rep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\telse     rep(j,r) rep(i,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q) scanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\t\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tSegTree2D st(r,c);\n\t\trep(i,r) rep(j,c)\n\t\t\tst.Update(i,j,grid[i][j]);\n\t\t\n\t\trep(i,q)\n\t\t\tprintf(\"%d\\n\",st.Query(r1[i],c1[i],r2[i]+1,c2[i]+1));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<vector>\nusing namespace std;\n#define INT_MAX (((long long)1)<<35)-1\n\nconst int maxn = 1000000*3;\n\nvector<long long> A[ 1000009 ];\nint n;\nstruct node\n{\n    int x1,x2,y1,y2;\n    long long min;\n    int ch[4];\n};\nnode tree[maxn];\nint tol;\n \nvoid maketree(int x1,int x2,int y1,int y2)\n{\n    int k = ++tol;\n    tree[k].x1 = x1;\n    tree[k].x2 = x2;\n    tree[k].y1 = y1;\n    tree[k].y2 = y2;\n    tree[k].min = 0;\n    if(x1 == x2 && y1==y2)\n    {\n        tree[k].min = A[x1][y1];\n        memset(tree[k].ch,0,sizeof(tree[k].ch));\n        return ;\n    }\n    \n    int midx = (x1+x2)>>1;\n    int midy = (y1+y2)>>1;\n    \n    tree[k].ch[0] = tol+1;\n    maketree(x1,midx,y1,midy); \n    \n    if(midx+1 <= x2 && midy+1 <= y2) \n    {\n        tree[k].ch[1] = tol+1;\n        maketree(midx+1,x2,midy+1,y2);\n    }\n    else\n        tree[k].ch[1] = 0;\n    \n    if(midy+1 <= y2)    \n    {\n        tree[k].ch[2] = tol+1;\n        maketree(x1,midx,midy+1,y2);\n    }\n    else\n        tree[k].ch[2] = 0;\n    \n \n    if(midx+1 <= x2)\n    {\n        tree[k].ch[3] = tol+1;\n        maketree(midx+1,x2,y1,midy);\n    }\n    else\n        tree[k].ch[3] = 0;\n        \n    tree[k].min =  tree[tree[k].ch[0]].min;\n    for(int i=1; i<4; i++)            \n        if(tree[k].ch[i])\n            tree[k].min = min(tree[k].min,tree[tree[k].ch[i]].min);\n}\n \ninline bool cross(int x1,int x2,int y1,int y2,int k)\n{\n    if(x2 < tree[k].x1 || tree[k].x2 < x1   ||  y2 < tree[k].y1 || tree[k].y2 < y1)\n        return false;\n    return true;\n}\n \nlong long Query(int x1,int x2,int y1,int y2,int k) \n{\n    if(cross(x1,x2,y1,y2,k) == 0)  \n        return INT_MAX;\n \n    if(x1 <= tree[k].x1 && tree[k].x2 <= x2 && y1<= tree[k].y1 && tree[k].y2 <= y2) \n        return tree[k].min;\n    long long minx = Query(x1,x2,y1,y2,tree[k].ch[0]);\n \n    for(int i=1; i<4; i++)\n        minx = min(minx,Query(x1,x2,y1,y2,tree[k].ch[i]));\n    return minx;\n}\n\nint main()\n{\n    int r,c,q;\n    long long temp;\n    int x1,y1,x2,y2;\n   \n    while(( scanf( \"%d%d%d\",&r,&c,&q ),r ))\n    {\n        for( int i=1;i<=r;i++ ){\n            A[ i ].clear(  );\n            A[ i ].push_back( 0 );\n            for( int j=1;j<=c;j++ ){\n                scanf( \"%lld\",&temp );\n                    A[ i ].push_back( temp );\n\n            }\n        }\n        tol=0;\n        maketree(1,r,1,c);        \n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n            x1++,y1++,x2++,y2++;\n            printf(\"%lld\\n\",Query(x1,x2,y1,y2,1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n/// {{{ DEBUG --- ///\n#ifdef DEBUG\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << \"{\"; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \", \" : \"\"); o << \"}\"; return o; }\n#ifdef USE_COUT\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<__debug_tap<<\"\\n\";}()\n#else\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<__debug_tap<<\"\\n\";}()\n#endif\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate<class T> inline void dump2D(T &d, size_t sizey, size_t sizex) { ostream&o=\n#ifdef USE_COUT\n  cout;\n#else\n  cerr;\n#endif\n  for(size_t i = 0; i < sizey; i++) { for(size_t j = 0; j < sizex; j++) o << d[i][j] << \" \"; o << endl; } }\n#else\n  template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \" \" : \"\"); return o; }\n#define dump(...) (42)\n#define dump2D(...) (42)\n#endif\n  /// }}}--- ///\n  \n\nconst int inf = numeric_limits<int>::max();\n\n// constructor(int sizex, int sizey, T identity)\n/// --- 2D SegmentTree Library {{{ ///\n\ntemplate<class T>\nstruct SegTree2D {\n  vector<T> dat;\n  int sizex, sizey;\n  T identity;\n  function<T(T, T)> merge;\n  SegTree2D(int tx, int ty, T identity, function<T(T, T)> merge)\n    :identity(identity), merge(merge) {\n      sizex = sizey = 1;\n      while(tx > sizex) sizex <<= 1;\n      while(ty > sizey) sizey <<= 1;\n      dat = vector<T>(sizex * sizey * 4, identity);\n    }\n  void set(int x, int y, T const &val) {\n    int kx = x + sizex - 1, ky = y + sizey - 1;\n    dat[kx * sizey * 2 + ky] = val;\n    while(ky > 0) {\n      ky = (ky - 1) / 2;\n      dat[kx * sizey * 2 + ky] = merge(\n          dat[kx * sizey * 2 + ky * 2 + 1],\n          dat[kx * sizey * 2 + ky * 2 + 2]\n          );\n    }\n    while(kx > 0) {\n      kx = (kx - 1) / 2;\n      ky = y + sizey - 1;\n      dat[kx * sizey * 2 + ky] = merge(\n          dat[(kx * 2 + 1) * sizey * 2 + ky],\n          dat[(kx * 2 + 2) * sizey * 2 + ky]\n          );\n      while(ky > 0) {\n        ky = (ky - 1) / 2;\n        dat[kx * sizey * 2 + ky] = merge(\n            dat[kx * sizey * 2 + ky * 2 + 1],\n            dat[kx * sizey * 2 + ky * 2 + 2]\n            );\n      }\n    }\n  }\n  void act(int x, int y, T const &val) {\n    int kx = x + sizex - 1, ky = y + sizey - 1;\n    set(x, y, merge(dat[kx * sizey * 2 + ky], val));\n  }\nprivate:\n  // void setx(int x, int y, T const &val,\n  //     int sxl, int sxr, int k, int set) {\n  //   if(x+1 <= sxl || sxr <= x) return;\n  //   if(x <= sxl && sxr <= x+1) {\n  //     sety(k, y, val, 0, sizey, 0, set);\n  //     return;\n  //   }\n  //   setx(x, y, val, sxl, (sxl + sxr) / 2, k * 2 + 1, set);\n  //   setx(x, y, val, (sxl + sxr) / 2, sxr, k * 2 + 2, set);\n  // }\n  // void setx(int kx, int y, T const &val,\n  //     int syl, int syr, int k, int set) {\n  //   if(y+1 <= syl || syr <= y) return;\n  //   if(y <= syl && syr <= y+1) {\n  //     if(set) dat[kx * sizey * 2 + k] = val;\n  //     else dat[kx * sizey * 2 + k] = merge(dat[k * ], val);\n  //     return;\n  //   }\n  //   if(sxr - sxl < syr - syl) {\n  //     // devide y\n  //     setx(x, y, val, sxl, sxr, syl, (syl + syr) / 2, k * 2 + 1, set);\n  //     goone(x, y, val, sxl, sxr, (syl + syr) / 2, syr, k * 2 + 2, set);\n  //   } else {\n  //     // devide x\n  //     goone(x, y, val, sxl, (sxl + sxr) / 2, syl, syr, k * 2 + 1, set);\n  //     goone(x, y, val, (sxl + sxr) / 2, sxr, syl, syr, k * 2 + 2, set);\n  //   }\n  //   dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);\n  // }\npublic:\n  T query(int xl, int xr, int yl, int yr) {\n    return queryx(xl, xr, yl, yr, 0, sizex, 0);\n  }\nprivate:\n  T queryx(int xl, int xr, int yl, int yr,\n      int sxl, int sxr, int k) {\n    if(xr <= sxl || sxr <= xl) return identity;\n    if(xl <= sxl && sxr <= xr) return queryy(k, yl, yr, 0, sizey, 0);\n    return merge(\n        queryx(xl, xr, yl, yr, sxl, (sxl + sxr) / 2, k * 2 + 1),\n        queryx(xl, xr, yl, yr, (sxl + sxr) / 2, sxr, k * 2 + 2)\n        );\n  }\n  T queryy(int kx, int yl, int yr,\n      int syl, int syr, int k) {\n    if(yr <= syl || syr <= yl) return identity;\n    if(yl <= syl && syr <= yr) return dat[kx * sizey * 2 + k];\n    return merge(\n        queryy(kx, yl, yr, syl, (syl + syr) / 2, k * 2 + 1),\n        queryy(kx, yl, yr, (syl + syr) / 2, syr, k * 2 + 2)\n        );\n  }\n};\n\n/// }}}--- ///\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  while(1) {\n    int h,w,q;\n    cin>>h>>w>>q;\n    if(h==0) break;\n\n    SegTree2D<int> ecasdqina(h, w, inf, [&](int a, int b){return a < b ? a : b;});\n    for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) {\n      int x;\n      cin >> x;\n      ecasdqina.set(i, j, x);\n    }\n    for(int i = 0; i < q; i++) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n      cout << ecasdqina.query(x1, x2 + 1, y1, y2 + 1) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\n#define def INT_MAX\nusing V = int;\nV comp(V& l, V& r) { return min(l,r); };\nstruct SegTree { //[l,r)\n    int NV;\n    vector<V> val;\n    void init(int n) {\n        NV = 1;\n        while (NV < n) NV *= 2;\n        val = vector<V>(NV * 2, def);\n    }\n    V get(int x, int y, int l, int r, int k) {\n        if (r <= x || y <= l) return def; if (x <= l&&r <= y)return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2); auto b = get(x, y, (l + r) / 2, r, k * 2 + 1); return comp(a, b);\n    }\n    V get(int x, int y) { return get(x, y, 0, NV, 1); }\n    void update(int i, V v) { i += NV; val[i] = v; while (i>1)i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]); }\n    void compupdate(int i, V v) { update(i, comp(v, val[i + NV])); }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\nstruct StaticHealthy2DSegTree {\n    int NV;\n    vector<SegTree> st;\n    vector<vector<int>> index;\n    \n    void init(vector<vector<pair<int,V>>> &v) {\n        int n = v.size();\n        NV = 1; while (NV < n) NV *= 2;\n        index.resize(2 * NV);\n        rep(i, 0, n) fore(p, v[i]) index[i + NV].push_back(p.first);\n        rrep(i, NV * 2 - 1, 1) {\n            sort(index[i].begin(), index[i].end());\n            index[i].erase(unique(index[i].begin(), index[i].end()), index[i].end());\n            fore(j, index[i]) index[i / 2].push_back(j);\n        }\n        st.resize(2 * NV);\n        rep(i, 1, NV * 2) st[i].init(index[i].size());\n        \n        rep(i, 0, n) fore(p, v[i]) {\n            int j = lower_bound(index[i + NV].begin(), index[i + NV].end(), p.first) - index[i + NV].begin();\n            st[i + NV].update(j, p.second);\n        }\n\n        rrep(i, NV * 2 - 1, 2) {\n            rep(j, 0, index[i].size()) {\n                V v = st[i][j];\n                \n                int k = lower_bound(index[i / 2].begin(), index[i / 2].end(), index[i][j]) - index[i / 2].begin();\n                st[i / 2].compupdate(k, v);\n            }\n        }\n    }\n    V get(int sx, int tx, int sy, int ty, int k, int l, int r) {\n        assert(k < NV * 2);\n        assert(l < r);\n        if (r <= sx or tx <= l) return def;\n        if (sx <= l and r <= tx) {\n            int syy = lower_bound(index[k].begin(), index[k].end(), sy) - index[k].begin();\n            int tyy = lower_bound(index[k].begin(), index[k].end(), ty) - index[k].begin();\n            return st[k].get(syy, tyy);\n        }\n        int md = (l + r) / 2;\n        V le = get(sx, tx, sy, ty, k * 2, l, md);\n        V ri = get(sx, tx, sy, ty, k * 2 + 1, md, r);\n        return comp(le, ri);\n    }\n    V get(int sx, int tx, int sy, int ty) {\n        return get(sx, tx, sy, ty, 1, 0, NV);\n    }\n};\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\nint H, W, Q;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> H >> W >> Q) {\n        if (H == 0) return;\n\n        StaticHealthy2DSegTree st;\n\n        vector<vector<pair<int,int>>> index(W);\n        rep(y, 0, H) rep(x, 0, W) {\n            int v; cin >> v;\n            index[x].push_back({ y, v });\n        }\n        st.init(index);\n\n        rep(i, 0, Q) {\n            int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n            y2++, x2++;\n            int ans = st.get(x1, x2, y1, y2);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n#include <array>\n\ntypedef int TYPE;\nTYPE inf = -1;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d();\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid init(const int h, const int w);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\tTYPE _get(const int i, const int j);\n\tvoid _set(const int i, const int j, const TYPE val);\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n\tTYPE eval(const TYPE t1, const TYPE t2);\n\n\tint height;\n\tint width;\n\n\tint height2;\n\tint width2;\n\tint logwidth;\n\tvector<TYPE> array;\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << _get(i, j) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nTYPE Segment2d::eval(const TYPE t1, const TYPE t2)\n{\n\tif(t1 == inf) return t2;\n\telse if(t2 == inf) return t1;\n\telse return min(t1, t2);\n}\n\nTYPE Segment2d::_get(const int i, const int j)\n{\n\treturn array[(i << logwidth) + j];\n}\nvoid Segment2d::_set(const int i, const int j, const TYPE val)\n{\n\tarray[(i << logwidth) + j] = val;\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nvoid Segment2d::init(const int h, const int w)\n{\n\theight = h;\n\twidth = w;\n\twidth2 = 1;\n\tlogwidth = 0;\n\twhile(width2 < width)\n\t{\n\t\twidth2 *= 2;\n\t\tlogwidth++;\n\t} \n\tlogwidth++;\n\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfill(array.begin(), array.end(), inf);\n}\n\nSegment2d::Segment2d()\n{\n\tarray.resize(1 << 23);\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\t_set(y, x, val);\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tconst TYPE val = eval(_get(left(ys[i]), xs[0]), _get(right(ys[i]), xs[0]));\n\t\t_set(ys[i], xs[0], val);\n\t}\n\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tconst TYPE val = eval(_get(ys[i], left(xs[j])), _get(ys[i], right(xs[j])));\n\t\t\t_set(ys[i], xs[j], val);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn eval(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn _get(ky, kx);\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn eval(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg;\n\tseg.init(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tSegment2d seg;\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tseg.init(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint NextPow2(int x)\n{\n\tx--;\n\tfor(int i=1;i<32;i*=2) x|=x>>i;\n\treturn x+1;\n}\nconst int I=numeric_limits<int>::max();\nint F(int a,int b){return min(a,b);}\n\nstruct SegmentTree{\n\tint size;\n\tvi data;\n\tSegmentTree(int n):size(NextPow2(n)),data(size*2,I){}\n\tSegmentTree(const vi& a):size(NextPow2(a.size())),data(size*2,I){\n\t\tcopy(all(a),begin(data)+size);\n\t\tperi(i,1,size) data[i]=F(data[i*2],data[i*2+1]);\n\t}\n\tint Get(int i){\n\t\treturn data[size+i];\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[size+i]=x;\n\t\tfor(i+=size;i/=2;) data[i]=F(data[i*2],data[i*2+1]);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return I;\n\t\tif(a<=l && r<=b) return data[i];\n\t\treturn F(Query(a,b,i*2,l,(l+r)/2),Query(a,b,i*2+1,(l+r)/2,r));\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegmentTree2D{\n\tint size;\n\tvector<SegmentTree> data;\n\tSegmentTree2D(int h,int w):size(NextPow2(h)),data(size*2,SegmentTree(w)){}\n\tSegmentTree2D(const vvi& a):size(NextPow2(a.size())),data(size*2,SegmentTree(a[0].size())){\n\t\tcopy(all(a),begin(data)+size);\n\t\tperi(i,1,size) repi(j,1,data[i].data.size())\n\t\t\tdata[i].data[j]=F(data[i*2].data[j],data[i*2+1].data[j]);\n\t}\n\tint Get(int i,int j){\n\t\treturn data[size+i].Get(j);\n\t}\n\tvoid Update(int i,int j,int x){\n\t\tdata[size+i].Update(j,x);\n\t\tfor(i+=size;i/=2;)\n\t\t\tdata[i].Update(j,F(data[i*2].Get(j),data[i*2+1].Get(j)));\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return I;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\treturn F(Query(a,b,c,d,i*2,to,(to+bo)/2),Query(a,b,c,d,i*2+1,(to+bo)/2,bo));\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(min(r,c),vi(max(r,c)));\n\t\tif(r<=c) rep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\telse     rep(j,r) rep(i,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q) scanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\t\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tSegmentTree2D st(grid);\n\t\trep(i,q)\n\t\t\tprintf(\"%d\\n\",st.Query(r1[i],c1[i],r2[i]+1,c2[i]+1));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\tstatic int cmp[1024][1024];\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = ((int)sqrt(H)) + 1;\n\t\tint Ws = ((int)sqrt(W)) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = h1 / Hs; j <= h2 / Hs; j++){\n\t\t\t\tfor (int k = w1 / Ws; k <= w2 / Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2 && w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\treturn (1);\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n\nstruct SegTree {\n\tint segSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<int>(segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvector<vector<int> > dat;\nint R, C;\n\nvoid update(int r, int c, int x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(true){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tif (cc == 0) break;\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tint v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tint v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tint v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tint v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tdat.clear();\n\t\tdat.resize(R * 2 - 1, vector<int>(C * 2 - 1, INF));\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tint x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-5;\nstatic const int INFTY = (1<<21);\nstatic const ll LLINFTY = (1LL<<53);\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) REP(i,0,n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nint r,c,rr,cc;\nvoid update(int x,int y,int k,VVI& xd,VVI& yd)\n{\n  int l;\n  l=x+cc-1;\n  xd[y][l]=k;\n  while(l>0){\n    l=(l-1)/2;\n    xd[y][l]=min(xd[y][l*2+1],xd[y][l*2+2]);\n  }\n  l=y+rr-1;\n  //cout<<l<<endl;\n  yd[x][l]=k;\n  while(l>0){\n    l=(l-1)/2;\n    yd[x][l]=min(yd[x][l*2+1],yd[x][l*2+2]);\n  }\n}\nint get(int i)\n{\n  int ret=1;\n  while(ret<i)ret*=2;\n  return ret;\n}\nint query(int a,int b,int k,int l,int r,const VI& d)\n{\n  if( r<=a || b<=l ) return INT_MAX;\n  //cout<<\"k:\"<<k<<\" a:\"<<a<<\" b:\"<<b<<\" l:\"<<l<<\" r:\"<<r<<\" d[\"<<k<<\"]=\"<<d[k]<<endl;\n  if( a<=l && r<=b ){\n    //cout<<\"query:\"<<k<<\" \"<<d[k]<<endl;\n    return d[k];\n  }\n  int s=query(a,b,k*2+1,l,(l+r)/2,d);\n  int t=query(a,b,k*2+2,(l+r)/2,r,d);\n  return min(s,t);\n}\nint main(void)\n{\n  int q;\n  for(;;){\n    scanf(\"%d%d%d\",&r,&c,&q); if(!r)break;\n    VVI x(r,vector<int>((cc=get(c))*2-1,INT_MAX));\n    VVI y(c,vector<int>((rr=get(r))*2-1,INT_MAX));\n    rep(i,r)rep(j,c){\n      int n; scanf(\"%d\",&n);\n      update(j,i,n,x,y);\n    }\n    if(0){\n      puts(\"debug\");\n      cout<<\"x.size()\"<<x.size()<<endl;\n      cout<<\"x[0].size()\"<<x[0].size()<<endl;\n      cout<<\"y.size()\"<<y.size()<<endl;\n      cout<<\"y[0].size()\"<<y[0].size()<<endl;\n      if(0) rep(i,r) cout << query(0,c,0,0,x[i].size(),x[i]) << endl;\n      if(0) rep(i,c) cout << query(0,r,0,0,y[i].size(),y[i]) << endl;\n      puts(\"test\");\n      rep(i,r) cout << query(0,1,0,0,x[i].size(),x[i]) << endl;\n      puts(\"end\");\n    }\n    rep(i,q){\n      int x1,y1,x2,y2;\n      scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n      int a=abs(x1-x2);\n      int b=abs(y1-y2);\n      int res=INFTY;\n      //cout<<\"a:\"<<a<<\" b:\"<<b<<endl;\n      if( a<b ){\n        //puts(\"for y\");\n        rep(j,a+1){\n          //cout<<\"query:\"<<query(y1,y2+1,0,0,y[x1+j].size(),y[x1+j])<<endl;\n          res=min(res,query(y1,y2+1,0,0,rr,y[x1+j]));\n        }\n      } else {\n        //puts(\"for x\");\n        rep(j,b+1){\n          //cout<<\"query:\"<<query(x1,x2+1,0,0,x[y1+j].size(),x[y1+j])<<endl;\n          res=min(res,query(x1,x2+1,0,0,cc,x[y1+j]));\n        }\n      }\n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *       Author:  8mao\n * Created Time:  2014/3/16 15:59:04\n *    File Name:  1559.cpp\n */\n# include<map>\n# include<set>\n# include<cmath>\n# include<queue>\n# include<stack>\n# include<vector>\n# include<string>\n# include<cstdio>\n# include<cstring>\n# include<iostream>\n# include<algorithm>\n# include<functional>\nusing namespace std;\n\ntypedef pair<int,int> PII;\n# define INF 1<<30\n# define LL long long\n# define MOD 1000000007\n# define VI vector<int>\n# define VLL vector<LL>\n# define VS vector<string>\n# define PII pair<int,int>\n\n# define F first\n# define S second\n# define mp make_pair\n# define pb push_back\n# define lb lower_bound\n# define up upper_bound\n# define lowbit(x)(x&-x)\n# define lson l,m,rt<<1\n# define rson m+1,r,rt<<1|1\n# define clr(x) (x).clear()\n# define sz(x) ((int)(x).size())\n# define all(x) (x).begin(),(x).end()\n# define mem(x,y) memset(x,y,sizeof(x))\n# define forall(it,c) for(typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\nint readint()  \n{  \n    int res=0,ch;  \n    while(!((ch=getchar())>='0'&&ch<='9'))  \n    {  \n       if(ch==EOF)  return 1<<30;  \n    }  \n    res=ch-'0';  \n    while((ch=getchar())>='0'&&ch<='9')  \n        res=res*10+(ch-'0');  \n    return res ;  \n}  \n\n# define N 1000005\nint Log2[N];\nVI a;\nvector< vector<int> > st;\n\nvoid initRMQ(int n)\n{\n    int i, j;\n    for (i = 0; i <= n; i++)\n    {\n        st.pb(vector<int>());\n        for (j = 0; (1 << j) <= n; j++)\n            st[i].pb(0);\n    }\n    for (i = 0; i < n; i++)\n        st[i][0] = a[i];\n    for (j = 1; (1 << j) <= n; j++)\n        for (i = 0; i + (1 << j) - 1 < n; i++)\n            st[i][j] = min (st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n}\n\nint calc(int l, int r)\n{\n    int d = Log2[r - l + 1];\n    return min (st[l][d], st[r - (1 << d) + 1][d]);\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\",stdin);\n    int i, j, n, m, q, x1, y1, x2, y2, l, r, x;\n    LL ans;\n    Log2[0] = -1;\n    for (i = 1; i <= 1000000; i++)\n        Log2[i]= Log2[i - 1] + !(i & (i - 1));\n    while (scanf (\"%d %d %d\", &n, &m, &q) != EOF && (n + m + q))\n    {\n        clr (a); \n        for (i = 0; i < n; i++)\n            for (j = 0; j  < m; j++)\n            {\n                x = readint();\n                a.pb(x);\n            }\n        initRMQ(n * m);\n        for (i = 1; i <= q; i++)\n        {\n            ans = 1LL << 60;\n            x1 = readint();\n            y1 = readint();\n            x2 = readint();\n            y2 = readint();\n            for (j = x1; j <= x2; j++)\n            {\n                l = j *  m + y1, r= j * m + y2;\n                //printf (\"%d %d\\n\", l, r);\n                ans = min (ans, (LL)calc(l, r));\n            }\n            printf (\"%lld\\n\", ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint grid[1 << 22];\nint dat[1 << 23];\n\ntemplate<typename Monoid>\nclass segment_tree2d {\n    using T = typename Monoid::type;\n\npublic:\n    segment_tree2d(int h, int w/*std::vector<std::vector<T>> const& init*/)\n        : H(expand(h /*init.size()*/)),\n          W(expand(w /*init[0].size()*/))\n    {\n        int const H2 = H * 2, W2 = W * 2;\n        //dat.assign(H2 * W2, Monoid::id());\n        for(int i = 0; i < 1 << 23; ++i) {\n            dat[i] = Monoid::id();\n        }\n        for(int i = 0; i < h /*(int)init.size()*/; ++i) {\n            for(int j = 0; j < w /*(int)init[0].size()*/; ++j) {\n                dat[(i + H) * W2 + j + W] = grid[i * w + j]/*init[i][j]*/;\n            }\n        }\n        for(int i = H2 - 1; i >= H; --i) {\n            for(int j = W - 1; j > 0; --j) {\n                dat[i * W2 + j] = Monoid::op(dat[i * W2 + 2 * j], dat[i * W2 + 2 * j + 1]);\n            }\n        }\n        for(int i = H - 1; i > 0; --i) {\n            for(int j = 1; j < W2; ++j) {\n                dat[i * W2 + j] = Monoid::op(dat[2 * i * W2 + j], dat[(2 * i + 1) * W2 + j]);\n            }\n        }\n    }\n\n    //segment_tree2d(int const H, int const W, T const& init = Monoid::id())\n    //    : segment_tree2d(std::vector<std::vector<T>>(H, std::vector<T>(W, init)))\n    //{}\n\n    void update(int i, int j, T val) {\n        i += H;\n        j += W;\n        int tj = j;\n        while(tj >>= 1) {\n            dat[i * W * 2 + tj] = Monoid::op(dat[i * W * 2 + tj * 2], dat[i * W * 2 + tj * 2 + 1]);\n        }\n        while(i >>= 1) {\n            dat[i * W * 2 + j] = Monoid::op(dat[i * 2 * W * 2 + j], dat[(i * 2 + 1) * W * 2 + j]);\n            tj = j;\n            while(tj >>= 1) {\n                dat[i * W * 2 + tj] = Monoid::op(dat[i * W * 2 + tj * 2], dat[i * W * 2 + tj * 2 + 1]);\n            }\n        }\n    }\n\n    // [li, ri) * [lj, rj)\n    T query(int li, int lj, int ri, int rj) const {\n        return query_h(li, lj, ri, rj, 0, H, 1);\n    }\n    T query_h(int li, int lj, int ri, int rj, int si, int ti, int k) const {\n        if(ri <= si || ti <= li) {\n            return Monoid::id();\n        }\n        if(li <= si && ti <= ri) {\n            return query_w(lj, rj, 0, W, k, 1);\n        }\n        int const mi = (si + ti) / 2;\n        return Monoid::op(query_h(li, lj, ri, rj, si, mi, 2 * k), query_h(li, lj, ri, rj, mi, ti, 2 * k + 1));\n    }\n    T query_w(int lj, int rj, int sj, int tj, int i, int k) const {\n        if(rj <= sj || tj <= lj) {\n            return Monoid::id();\n        }\n        if(lj <= sj && tj <= rj) {\n            return dat[i * (W * 2) + k];\n        }\n        int const mj = (sj + tj) / 2;\n        return Monoid::op(query_w(lj, rj, sj, mj, i, 2 * k), query_w(lj, rj, mj, tj, i, 2 * k + 1));\n    }\n\nprivate:\n    int expand(int n) const {\n        assert(n >= 1);\n        return n == 1 ? n : expand((n + 1) / 2) * 2;\n    }\n\nprivate:\n    int const H, W;\n    //std::vector<T> dat;\n};\n\nstruct rmq {\n    using type = int;\n    static type id() {\n        return std::numeric_limits<type>::max();\n    }\n    static type op(type const& l, type const& r) {\n        return std::min(l, r);\n    }\n};\n\nint main() {\n    int r, c, q;\n    while(cin >> r >> c >> q, r) {\n        for(int i = 0; i < r; ++i) {\n            for(int j = 0; j < c; ++j) {\n                cin >> grid[i * c + j];\n            }\n        }\n        segment_tree2d<rmq> seg(r, c);\n        while(q--) {\n            int li, lj, ri, rj;\n            cin >> li >> lj >> ri >> rj;\n            cout << seg.query(li, lj, ri + 1, rj + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint abs(int a,int b){\n\n  int result;\n\n  if(a<b)\n    result=b-a;\n  else\n    result=a-b;\n  return result;\n};\n\nint main(void){\n\n  int n;\n  int min=1000000;\n  int  temp;\n  \n  while(cin >> n,n!=0){\n\n      vector <int> student(n);\n    \n    for(int i=0;i<n;i++){\n      cin >> student[i];\n    }\n\n    sort(student.begin(),student.end(),greater<int>());\n\n    for(int i=0;i<n;i++){\n      \n      temp=abs(student[i],student[i+1]);\n      //cout << temp <<endl;\n\n      if(min>temp)\n\tmin=temp;\n    }\n\n    cout << min <<endl;\n\n    student.clear();\n    min=1000000;\n\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\n//const ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    w=h=max(w,h);\n    //if(h>w)w=h;\n    //if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = INT_MAX;\nint r,c,q;\n\nstruct SegTree {\n    vector<int> dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat.assign(k*2, inf);\n    }\n    void set(int x, int val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    int get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            // dump(l,r);\n            return dat[k];\n        }\n        int v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        int v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, int val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(0,r), dat[i^1].get(0,r)));\n            i>>=1;\n        }\n    }\n    int get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            // dump(l,r);\n            return dat[k].get(x1,x2);\n        }\n        int v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        int v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        dump(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            int x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            dump(tree.dat[i].dat);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            // dump(y1,y2,x1,x2);\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tRMQ(){}\n\t~RMQ(){\n\t\t\n\t}\n\tvoid build(int n,const S a[],S *dat){\n\t\tint m=n;\n\t\tn=calcsize(n);\n\t\t//dat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t/*void update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}*/\n\tS query(const S *dat,int a,int b,int k,int l,int r)const{//[a,b)の最小(大)値\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(dat,a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(dat,a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n};\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tS *datrmq;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(datrmq+k*(2*w-1),xs,xe, 0,0,w);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdatrmq=new S[(2*h-1)*(2*w-1)];\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m,datrmq+(h-1+i)*(2*w-1));\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat,datrmq+(h-1+i)*(2*w-1));\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat,datrmq+i*(2*w-1));\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tS *a=datrmq+(i*2+1)*(2*w-1);\n\t\t\t\tS *b=datrmq+(i*2+2)*(2*w-1);\n\t\t\t\tdatrmq[i*(2*w-1)+j]=std::min(a[j],b[j]);\n\t\t\t\t//rmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t\t}\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t\tdelete[] datrmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\n\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  void update(int k, int a) {\n    k += N - 1; // 葉に移動\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = y1 / SQRT_N; k < (y2 + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(rs);\n    int cs=sqrt(cs);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i+k<r&&j+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\tif(vl<vr)return vl;\n\treturn vr;\n\t//return min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const ll     INF = 1000000000000000LL;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 22;\nint r, c, q;\nint _r, _c;\nint g;\nvector<ll>* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vector<ll>[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, ll x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nll _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nll query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int h,w,n;\n  while(scanf(\"%d%d%d\",&h,&w,&n),h||w||n){\n    vector<vector<vector<int> > > a(h);\n    for(i=0;i<h;++i){\n      a[i].push_back(vector<int>(w));\n      for(j=0;j<w;++j)\n      \tscanf(\"%d\",&a[i][0][j]);\n    }\n    if(w>h){\n      for(;(int)a.back().back().size()>1;){\n\tfor(i=0;i<h;++i){\n\t  a[i].push_back(vector<int>(a[i].back().size()/2));\n\t  for(j=0;j<(int)a[i].back().size();++j)\n\t    a[i].back()[j]=min(a[i][a[i].size()-2][j*2],a[i][a[i].size()-2][j*2+1]);\n\t}\n      }\n      for(i=0;i<n;++i){\n\tint y0,x0,y1,x1;\n\tscanf(\"%d%d%d%d\",&y0,&x0,&y1,&x1);\n\tint mn=(1ll<<31)-1;\n\tfor(j=x0;j<=x1;j+=(1<<k)){\n\t  for(k=0;j%(1<<(k+1))==0&&j+(1<<(k+1))-1<=x1;++k);\n\t  for(l=y0;l<=y1;++l)\n\t    mn=min(mn,a[l][k][j/(1<<k)]);\n\t}\n\tprintf(\"%d\\n\",mn);\n      }\n    }else{\n      vector<vector<vector<int> > > b(w);\n      for(i=0;i<w;++i){\n\tb[i].push_back(vector<int>(h));\n\tfor(j=0;j<h;++j)\n\t  b[i][0][j]=a[j][0][i];\n      }\n      for(;(int)b.back().back().size()>1;){\n\tfor(i=0;i<w;++i){\n\t  b[i].push_back(vector<int>(b[i].back().size()/2));\n\t  for(j=0;j<(int)b[i].back().size();++j)\n\t    b[i].back()[j]=min(b[i][b[i].size()-2][j*2],b[i][b[i].size()-2][j*2+1]);\n\t}\n      }\n      for(i=0;i<n;++i){\n\tint y0,x0,y1,x1;\n\tscanf(\"%d%d%d%d\",&y0,&x0,&y1,&x1);\n\tint mn=(1ll<<31)-1;\n\tfor(j=y0;j<=y1;j+=(1<<k)){\n\t  for(k=0;j%(1<<(k+1))==0&&j+(1<<(k+1))-1<=y1;++k);\n\t  for(l=x0;l<=x1;++l)\n\t    mn=min(mn,b[l][k][j/(1<<k)]);\n\t}\n\tprintf(\"%d\\n\",mn);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(r);\n    int cs=sqrt(c);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tT *a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector< vector<T> > &v,int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=v[0].size();\n\t\telse   N=v.size();\n\n\t\twhile(n<N) n<<=1;\n\t\ta=(T *)malloc((2*n-1)*sizeof(T));\n\t\trep(i,2*n-1) a[i]=0;\n\n\t\tif(!b) rep(i,N) a[n+i-1]=v[k][i];\n\t\telse   rep(i,N) a[n+i-1]=v[i][k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tRMQ<int> *rmq1=(RMQ<int> *)malloc(h*sizeof(RMQ<int>));\n\t\tRMQ<int> *rmq2=(RMQ<int> *)malloc(w*sizeof(RMQ<int>));\n\t\trep(i,h) rmq1[i]=RMQ<int>(a,i,0);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a,j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\n\t\tfree(rmq1);\n\t\tfree(rmq2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tS *dat;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ():dat(0){\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid build(int n,const S a[]){\n\t\tint m=n;\n\t\tn=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b,int k,int l,int r)const{//[a,b)の最小(大)値\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n};\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> *rmq;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k].query(xs,xe, 0,0,w);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\trmq=new RMQ<S,T,nil>[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i].build(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i].build(m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i].build(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i].dat[j]=std::min(rmq[i*2+1].dat[j],rmq[i*2+2].dat[j],T());\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] rmq;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint const N=250005;\nint const oo=2147483647;\nstruct node\n{\n    int x1,y1,x2,y2;\n    int ch[4];\n    int Min;\n \tvoid read(int x1,int y1,int x2,int y2)\n \t{\n\t     this->x1=x1;\n\t     this->x2=x2;\n\t     this->y1=y1;\n\t     this->y2=y2;\n\t     memset(ch,0,sizeof(ch));\n\t} \n}p[N*8];\nint data[N];\nint Node;\nint n,m;\nvoid makeTree(int x1,int y1,int x2,int y2)\n{\n\t int k=++Node;\n\t p[k].read(x1,y1,x2,y2);\n\t if(x1==x2&&y1==y2)\n\t {\n        p[k].Min=data[x1*m+y1];          \t                    \t\t\n\t    return;\t\t\n\t }\n \t int midx=(x1+x2)>>1;\n\t int midy=(y1+y2)>>1; \n\t \n\t  p[k].ch[0]=Node+1; makeTree(x1,y1,midx,midy);\n \t \n\t  if(y1!=y2)\n\t  {\n\t     p[k].ch[1]=Node+1; makeTree(x1,midy+1,midx,y2);\t\t\n\t  }\n\t  if(x1!=x2)\n\t  {\n\t \t p[k].ch[2]=Node+1; makeTree(midx+1,y1,x2,midy);\n\t\t if(y1!=y2)\n\t\t {p[k].ch[3]=Node+1; makeTree(midx+1,midy+1,x2,y2);}\t\n\t  }\n\t  p[k].Min=oo;\n\t  for(int t=0;t<4;t++)\n\t  if(p[k].ch[t]!=0)\n\t  p[k].Min=min(p[k].Min,p[p[k].ch[t]].Min);\n}\nint query(int x1,int y1,int x2,int y2,int k)\n{\n\t  if(p[k].x1>=x1&&p[k].x2<=x2&&p[k].y1>=y1&&p[k].y2<=y2) \n      return p[k].Min;\n \t\n\t  int midx=(p[k].x1+p[k].x2)>>1;\n\t  int midy=(p[k].y1+p[k].y2)>>1;\t\n\t  \n\t  int res=oo;\n\t  \n\t  if(p[k].ch[0]&&x1<=midx&&y1<=midy)res=min(query(x1,y1,x2,y2,p[k].ch[0]),res);\n\t  if(p[k].ch[1]&&x1<=midx&&y2>midy)res=min(query(x1,y1,x2,y2,p[k].ch[1]),res);\n\t  if(p[k].ch[2]&&x2>midx&&y1<=midy)res=min(query(x1,y1,x2,y2,p[k].ch[2]),res);\n\t  if(p[k].ch[3]&&x2>midx&&y2>midy)res=min(query(x1,y1,x2,y2,p[k].ch[3]),res);\n\t  return res;\n}\nint main()\n{\n\n\t\n    int q,c,x1,x2,y1,y2;\n    while(scanf(\"%d%d%d\",&n,&m,&q)&&n)\n    {\n\t\t c=-1;\n\t\t for(int i=0;i<n;i++)\n\t\t for(int j=0;j<m;j++)\n\t\t {\n\t\t\t++c;\n\t\t\tscanf(\"%d\",&data[c]);\n\t\t }\n\t\t Node=0;makeTree(0,0,n-1,m-1);\n\t\t while(q--)\n\t\t {\n\t\t\t  scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\t\n\t\t \t  printf(\"%d\\n\",query(x1,y1,x2,y2,1));\t\n\t\t }\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint vlog[1000010];\nint R, C, Q;\nint ***rmq;\nint grid[1000010];\n\ninline void setvalue(int r, int c, int v){ grid[r*C+c] = v; }\ninline int getvalue(int r, int c){ return grid[r*C+c]; }\n\nvoid rmq_build()\n{\n    try{\n        rmq = new int**[R];\n        for(int i = 0; i < R; i++){\n            rmq[i] = new int*[11];\n            for(int k = 0; (1<<k)-1 < C; k++){\n                rmq[i][k] = new int[C];\n                for(int j = 0; j + (1<<k)-1 < C; j++){\n                    rmq[i][k][j] = k==0 ? getvalue(i, j) : min(rmq[i][k-1][j], rmq[i][k-1][j+(1<<k-1)]);\n                }\n            }\n        } \n    } catch (bad_alloc& ba) {\n        while(true);\n    }\n}\n\nvoid rmq_destory()\n{\n    for(int i = 0; i < R; i++){\n        for(int k = 0; (1<<k)-1 < C; k++){\n            delete[] rmq[i][k];\n        }\n        delete[] rmq[i];\n    }\n    delete[] rmq;\n}\n\ninline int rmq_query(int r, int c1, int c2)\n{\n    int k = vlog[c2-c1+1];\n    return min(rmq[r][k][c1], rmq[r][k][c2-(1<<k)+1]);\n}\n\nint main()\n{\n//    freopen(\"SchoolOfKillifish.in\",\"r\",stdin);\n    int r1, c1, r2, c2, v;\n    for(int i = 1; i <= 1000000; i++) vlog[i] = (int)log2((double)i);\n    while(~scanf(\"%d%d%d\", &R, &C, &Q)) {\n        bool rot = (R > C);\n        int rr = R, cc = C;\n        if(rot) swap(R, C);\n        for(int i = 0; i < rr; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\", &v);\n                if(rot) setvalue(j, i, v);\n                else setvalue(i, j, v);\n            }\n        }\n        rmq_build();\n        for(int i = 0; i < Q; i++) {\n            scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n            if(rot) swap(r1, c1), swap(r2, c2);\n            int v = 0x7fffffff;\n            for(int j = r1; j <= r2; j++)\n                v = min(v, rmq_query(j, c1, c2));\n            printf(\"%d\\n\", v);\n        }\n        rmq_destory();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconst type INIT = 0xfffffff;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tconst vector<type>& data() const {\n\t\treturn dat;\n\t}\n\n\tvoid merge(const segment_tree& s) {\n\t\tconst vector<type>& tmp = s.data();\n\t\tif(dat.size() != tmp.size()) return;\n\t\tfor(int i = 0; i < (int)dat.size(); ++i) {\n\t\t\tdat[i] = function(dat[i], tmp[i]);\n\t\t}\n\t}\n};\n\nclass segment_tree_2d {\nprivate:\n\tint n;\n\tvector<segment_tree> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int r1, int r2, int c1, int c2, int k, int l, int r) const {\n\t\tif(r <= r1 || r2 <= l)\n\t\t\treturn INIT;\n\n\t\tif(r1 <= l && r <= r2) {\n\t\t\treturn dat[k].query(c1, c2);\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(r1, r2, c1, c2, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(r1, r2, c1, c2, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree_2d(int r, int c) {\n\t\tn = 1;\n\t\twhile(n < r) n *= 2;\n\t\tdat.resize(2 * n - 1, segment_tree(c));\n\t}\n\n\tinline void update(int y, int x, type a) {\n\t\ty += n - 1;\n\t\tdat[y].update(x, a);\n\n\t\twhile(y > 0) {\n\t\t\tconst int child = y;\n\t\t\ty = (y - 1) / 2;\n\t\t\tdat[y].merge(dat[child]);\n\t\t}\n\t}\n\n\tinline type query(int r1, int r2, int c1, int c2) const {\n\t\treturn query(r1, r2, c1, c2, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q;) {\n\t\tsegment_tree_2d seg(r, c);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tseg.update(i, j, in);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<vector<int> > segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i][j];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d]=min(segtree[a][d],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree.clear();\n\t\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t\t\n\t\tvector<vector<int> >().swap(seg);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nbool swaped;\n\nstruct Pool {\n    static dat_t dat[250000*3];\n    static int end;\n    static dat_t * fetch(int size){\n        dat_t * res = dat+end;\n        end+=size;\n        return res;\n    }\n    static void reset(){\n        end = 0;\n    }\n};\n\nint Pool::end = 0;\ndat_t Pool::dat[250000*3];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = pool.fetch(sizeof(dat_t)*n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = pool.fetch(sizeof(dat_t)*n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        if(swaped) swap(x,y);\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        if(r>c) swaped = true;\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1068\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n#define all(a) (a).begin(), (a).end()\n\nconst int INF = (1<<31)-1;\n\nint r, c, q;\nstd::vector<std::vector<int> > segR, segC;\n\nvoid init( std::vector<std::vector<int> > &seg, int n )\n{\n\tint sz = 1;\n\twhile( sz < c )\n\t\tsz <<= 1;\n\n\trep( i, seg.size() )\n\t{\n\t\tseg[i].resize( 2*sz );\n\t\tstd::fill( all( seg[i] ), INF );\n\t}\n\n\treturn;\n}\n\nvoid update( std::vector<int> &seg, int k, int x )\n{\n\tk += (seg.size()>>1)-1;\n\tseg[k] = x;\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tseg[k] = std::min( seg[(k<<1)+1], seg[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nint query( const std::vector<int> &seg, int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn INF;\n\telse if( a <= l && r <= b )\n\t\treturn seg[k];\n\t\n\treturn std::min( query( seg, a, b, (k<<1)+1, l, (l+r)>>1 ), query( seg, a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d%d\", &r, &c, &q ), r|c|q )\n\t{\n\t\tsegR.resize( r );\n\t\tsegC.resize( c );\n\t\tinit( segR, c );\n\t\tinit( segC, r );\n\n\t\trep( i, r )\n\t\t{\n\t\t\trep( j, c )\n\t\t\t{\n\t\t\t\tint grid;\n\t\t\t\tscanf( \"%d\", &grid );\n\n\t\t\t\tupdate( segR[i], j, grid );\n\t\t\t\tupdate( segC[j], i, grid );\n\t\t\t}\n\t\t}\n\n\t\trep( i, q )\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf( \"%d%d%d%d\", &r1, &c1, &r2, &c2 );\n\n\t\t\tint ans = INF;\n\n\t\t\tif( r2-r1 <= c2-c1 )\n\t\t\t\trepi( j, r1, r2+1 )\n\t\t\t\t\tans = std::min( ans, query( segR[j], c1, c2+1, 0, 0, segR[j].size()>>1 ) );\n\t\t\telse\n\t\t\t\trepi( j, c1, c2+1 )\n\t\t\t\t\tans = std::min( ans, query( segC[j], r1, r2+1, 0, 0, segC[j].size()>>1 ) );\n\n\t\t\tprintf( \"%d\\n\", ans );\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 1000;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][9][9];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[y2/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[x2/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    w=h;\n    while(w<w_)w*=2;\n    h=w;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx)return INF;\n    else if(qmaxy<miny||maxy<qminy)return INF;\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ¡ñ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // c\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nvector<vector<int>>vs;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 11>=r&&u + 11>= d) {\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (nl + 11 >= nr&&nu + 11 >= nd) {\n\t\t\tint ans = 2147483647;\n\t\t\tfor (int x = max(ql,nl); x < min(qr,nr); ++x) {\n\t\t\t\tfor (int y = max(qu,nu); y < min(qd,nd); ++y) {\n\t\t\t\t\tans = min(ans, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd) {\n\t\t\t\n\t\t\treturn minnum;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvs.clear();\n\t\tvs = vector<vector<int>>(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nint const MAX_SIZE = 250000*40;\nstruct Pool {\n    static dat_t dat[MAX_SIZE];\n    static int size;\n    static dat_t * fetch(int len){\n        dat_t * res = dat + size;\n        size+=len;\n        return res;\n    }\n    static void reset(){\n        size = 0;\n    }\n};\n\nint Pool::size = 0;\ndat_t Pool::dat[MAX_SIZE];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n#include <array>\n\ntypedef long long TYPE;\nTYPE inf = 10000000000000000;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d();\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid init(const int h, const int w);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\tTYPE _get(const int i, const int j);\n\tvoid _set(const int i, const int j, const TYPE val);\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n\n\tint height;\n\tint width;\n\n\tint height2;\n\tint width2;\n\tint logwidth;\n\tvector<TYPE> array;\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << _get(i, j) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nTYPE Segment2d::_get(const int i, const int j)\n{\n\treturn array[(i << logwidth) + j];\n}\nvoid Segment2d::_set(const int i, const int j, const TYPE val)\n{\n\tarray[(i << logwidth) + j] = val;\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nvoid Segment2d::init(const int h, const int w)\n{\n\theight = h;\n\twidth = w;\n\twidth2 = 1;\n\tlogwidth = 0;\n\twhile(width2 < width)\n\t{\n\t\twidth2 *= 2;\n\t\tlogwidth++;\n\t} \n\tlogwidth++;\n\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfill(array.begin(), array.end(), inf);\n}\n\nSegment2d::Segment2d()\n{\n\tarray.resize(1 << 24);\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\t_set(y, x, val);\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tconst TYPE val = min(_get(left(ys[i]), xs[0]), _get(right(ys[i]), xs[0]));\n\t\t_set(ys[i], xs[0], val);\n\t}\n\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tconst TYPE val = min(_get(ys[i], left(xs[j])), _get(ys[i], right(xs[j])));\n\t\t\t_set(ys[i], xs[j], val);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn _get(ky, kx);\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg;\n\tseg.init(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tSegment2d seg;\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tseg.init(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[8*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < 8*MAX_N; i++)\n\t\tdat[i]=INF;\n}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\n//uint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n//\t// dÈèªªÈ¢\n//\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n//\t// ®SÉÜÜêé\n//\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n//\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n//\tuint vl,vr;\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n//\t//if(vl<vr)return vl;\n//\t//return vr;\n//\treturn min(vl,vr);\n//}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\nvoid update(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,uint a,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return;\n\t// ®SÉÜÜêé\n\tdat[k]=min(dat[k],a);\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy){\n\t\t// ¡ñÌêðXVµ½çI¹\n\t\treturn;\n\t}\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\t// x©yÌª1ÉÈÁ½çAÐûÌÝ©Ä¢­\n\tif(sminy==smaxy){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t\treturn;\n\t}\n\telse if(sminx==smaxx){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t\treturn;\n\t}\n\tif(isHor){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n\telse{\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n}\n\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\t// x©yÌª1ÉÈÁ½çAÐûÌÝ©Ä¢­\n\tif(sminy==smaxy){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\treturn min(vl,vr);\n\t}\n\telse if(sminx==smaxx){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\treturn min(vl,vr);\n\t}\n\tif(isHor){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\telse\n\t\t\tvr=INF;\n\t}\n\telse{\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\telse vr=INF;\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\tFILE *fp=stdin;\n\t//fp=fopen(\"input.txt\",\"r\");\n\twhile(fscanf(fp,\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\t//while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\t//cin>>t;\n\t\t\t\tfscanf(fp,\"%d\",&t);\n\t\t\t\t//pdate(i*w+j,t);\n\t\t\t\tupdate(j,i,j,i,0,0,w-1,h-1,t,0,true);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\t//cin>>r1>>c1>>r2>>c2;\n\t\t\tfscanf(fp,\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0,true);\n\t\t\t//cout<<res<<endl;\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = INT_MAX;\ntypedef pair<int,int> pii;\n\nstruct P {\n  int x, y, v;\n  bool operator<(const P &rhs) const {\n    return x!=rhs.x ? x<rhs.x : y<rhs.y;\n  }\n};\nstruct RangeTree {\n  struct SegTree {\n    vector<int> pos;\n    vector<int> dat;\n    int n;\n    SegTree() : n(0) {}\n    SegTree(int y, int v) : pos(1,y), dat(1,v), n(1) { }\n    SegTree(const SegTree &a, const SegTree &b) {\n      int n1 = a.pos.size(), n2 = b.pos.size();\n      for (n=1;n<n1+n2; n*=2);\n      pos.resize(n1+n2);\n      dat.assign(2*n-1,INF);\n      int c1=0,c2=0;\n      for (int i=0;i<n1+n2;++i) {\n        if (c1<n1&&c2<n2&&a.pos[c1]<b.pos[c2] || c2==n2) {\n          dat[i+n-1] = a.dat[c1+a.n-1];\n          pos[i] = a.pos[c1++];          \n        } else {\n          dat[i+n-1] = b.dat[c2+b.n-1];\n          pos[i] = b.pos[c2++];\n        }\n      }\n      for (int i=n-2; i>=0; --i)\n        dat[i] = min(dat[i*2+1], dat[i*2+2]);\n    }\n    int change(int y, int a) {\n      int k = lower_bound(ALL(pos),y)-pos.begin();\n      k += n - 1;\n      dat[k] = a;\n      while(k>0) {\n        k = k-1>>1;\n        dat[k] = min(dat[k*2+1], dat[k*2+2]);\n      }\n    }\n    int query() {\n      return query(0,pos.size(),0,0,n);\n    }\n    int query(int yl, int yr) {\n      int a = lower_bound(ALL(pos), yl) - pos.begin();\n      int b = upper_bound(ALL(pos), yr) - pos.begin();\n      return query(a,b,0,0,n);\n    }\n    int query(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return INF;\n      if (a <= l && r <= b) return dat[k];\n      return min(query(a, b, k*2+1, l, (l+r)/2),\n                 query(a, b, k*2+2, (l+r)/2, r));      \n    }\n  };\n  vector<SegTree> segs;\n  int n;\n  vector<pii> pos;\n  RangeTree(vector<P> v) {\n    sort(ALL(v));\n    pos.resize(v.size());\n    REP(i,v.size()) pos[i] = pii(v[i].x,v[i].y); \n    for (n=1; n<v.size(); n*=2);\n    segs.assign(2*n-1,SegTree());\n    REP(i,v.size()) segs[i+n-1] = SegTree(v[i].y,v[i].v);\n    for (int i=n-2; i>=0; --i)\n      segs[i] = SegTree(segs[i*2+1], segs[i*2+2]);\n  }\n  void change(int x, int y, int a) {\n    int k = lower_bound(ALL(pos),pii(x,y)) - pos.begin();\n    k += n - 1;\n    segs[k].change(y,a);\n    while(k>0) {\n      k = k-1>>1;\n      segs[k].change(y, min(segs[k*2+1].query(), segs[k*2+2].query()));\n    }\n  }\n  int query(int xl, int yl, int xr, int yr) {\n    int a = lower_bound(ALL(pos), pii(xl,-INF)) - pos.begin();\n    int b = upper_bound(ALL(pos), pii(xr,INF)) - pos.begin();\n    return query(a,b,0,0,n,yl,yr);\n  }\n  int query(int a, int b, int k, int l, int r, int yl, int yr) {\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return segs[k].query(yl,yr);\n    return min(query(a, b, k*2+1, l, (l+r)/2, yl, yr),\n               query(a, b, k*2+2, (l+r)/2, r, yl, yr));\n  }\n};\n\nint main() {\n  int q;\n  int R,C;\n  while(cin >>R>>C>>q, R||C||q) {\n    vector<P> v;\n    REP(i,R) REP(j,C) {\n      int a;\n      cin >> a;\n      v.push_back(P{i,j,a});\n    }\n    RangeTree tree(v);\n    REP(i,q) {\n      int r1,c1,r2,c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(r1,c1,r2,c2) << endl;\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=pow(r,1./3);\n    int cs=pow(c,1./3);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<min(rt+1,(l+cs-1)/cs*cs);j++){\n\t  m=min(m,v[i][j]);\n\t}\n\tfor(int j=min(rt/cs*cs,l);j<=rt;j++){\n\t  m=min(m,v[i][j]);\n\t}\n      }\n      for(int i=l;i<=rt;i++){\n\tfor(int j=t;j<min(b+1,(t+rs-1)/rs*rs);j++){\n\t  m=min(m,v[j][i]);\n\t}\n\tfor(int j=min(b/rs*rs,t);j<=b;j++){\n\t  m=min(m,v[j][i]);\n\t}\n      }\n      for(int i=(t+rs-1)/rs;i*rs+rs<=b+1;i++){\n\tfor(int j=(l+cs-1)/cs;j*cs+cs<=rt+1;j++){\n\t  m=min(m,vs[i][j]);\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<int*> dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\tvector<int> buf(8388608);\n\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\n\t\tdat.resize(r * 2 - 1);\n\t\tfor(int i = r * 2 - 2; i >= 0; --i){\n\t\t\tdat[i] = &buf[i * (c * 2 - 1)];\n\t\t\tfill(dat[i], dat[i] + (c * 2 - 1), INT_MAX);\n\t\t}\n\n\t\tvector<int> datr(c * 2 - 1, INT_MAX);\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1]);\n\t\t}\n\n\t\tfor(int j = 0; j < c * 2 - 1; ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\n// #define DEBUG\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\n\n\nuint field[sz];\nuint dat[sz * 20];\nint R, C, Q;\n\n#define FIELD(r, c) field[(r) * C + (c)]\n#define DAT(kr, kc) dat[(kr) * (C) * 4 + (kc)]\n\nvoid build(int lr = 0, int rr = R,\n           int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr - lr == 0 || rc - lc == 0){\n    DAT(kr, kc) = INF;\n  }else if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = FIELD(lr, lc);\n  }else{\n    if(r_axis){\n      int mr = (lr + rr) / 2;\n      build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n      build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n      DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    }else{\n      int mc = (lc + rc) / 2;\n      build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n      build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n      DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n    }\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n           int lr = 0, int rr = R, int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc) return INF;\n  if(rr - lr == 0 || rc - lc == 0) return INF;\n  \n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc) return DAT(kr, kc);\n  \n  if(r_axis){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\nuint naive(int ar, int br, int ac, int bc){\n  uint ans = INF;\n  REP2(i, ar, br)REP2(j, ac, bc) ans = min(ans, FIELD(i, j));\n  return ans;\n}\n\nint main(){\n  int r1, r2, c1, c2;\n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    REP(r, R)REP(c, C) scanf(\"%d\", &FIELD(r, c));\n    build();\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n\n\n#ifdef DEBUG\n    REP(r2, R)REP(r1, r2 + 1)REP(c2, C)REP(c1, c2 + 1){\n      cout <<naive(r1, r2 + 1, c1, c2 + 1) << endl;\n      assert(naive(r1, r2 + 1, c1, c2 + 1) == query(r1, r2 + 1, c1, c2 + 1));\n    }\n#endif\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INT_MAX);\n  }\n  void update(int k, int x){\n    k += N - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b){\n    return query(a, b, 0, 0, N);\n  }\n  int query(int a, int b, int k, int l, int r){\n    if(b <= l || r <= a) return INT_MAX;\n    if(a <= l && r <= b){\n      return data[k];\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INT_MAX;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INT_MAX;\n        for(int x = x1; x <= x2; x++){\n          res = min(res, rmq[x].query(y1, y2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nbool swaped;\n\nstruct pool {\n    void * dat;\n    int end;\n    pool(int size){\n        dat = malloc(size);\n        end = 0;\n    }\n    ~pool(){\n        free(dat);\n    }\n    void * fetch(int size){\n        void * res = (char*)dat + end;\n        end+=size;\n        return res;\n    }\n    void reset(){\n        end = 0;\n    }\n};\n\npool mem_pool(sizeof(char)*1024*50);\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        if(swaped) swap(x,y);\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        if(r>c) swaped = true;\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        mem_pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nint W, H, WW, HH, seg_H, seg_W;\nvector< vector<int> > data;\nvector< vector<int> > seg_tree;\n\n//y in [0, H)\nvoid initialize_W(int y, int cur_node, int lx, int rx){\n\tif(rx - lx <= 1){\n\t\tif(y < H){\n\t\t\tseg_tree[y + HH - 1][cur_node] = data[y][lx];\n\t\t}\n\t\treturn ;\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\n\tinitialize_W(y, 2*cur_node + 1, lx, mid);\n\tinitialize_W(y, 2*cur_node + 2, mid, rx);\n\n\tseg_tree[y + HH - 1][cur_node] = min(seg_tree[y + HH - 1][2*cur_node + 1], seg_tree[y + HH - 1][2*cur_node + 2]);\n}\n\nint query_W(int node_y, int fx, int tx, int cur_node, int lx, int rx){\n\tif( rx <= fx || tx <= lx ){\n\t\treturn INF;\n\t}\n\n\tif( fx <= lx && rx <= tx ){\n\t\treturn seg_tree[node_y][cur_node];\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\treturn min(query_W(node_y, fx, tx, cur_node*2 + 1, lx, mid),\n\t\t\tquery_W(node_y, fx, tx, cur_node*2 + 2, mid, rx));\n}\n\nvoid initialize_H(int cur_node, int ly, int ry){\n\tif(ry - ly <= 1){\n\t\tinitialize_W(ly, 0, 0, WW);\n\t\treturn ;\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\n\tinitialize_H(2*cur_node + 1, ly, mid);\n\tinitialize_H(2*cur_node + 2, mid, ry);\n\n\tfor(int j=0; j<seg_W; j++){\n\t\tseg_tree[cur_node][j] = min(seg_tree[2*cur_node + 1][j], seg_tree[2*cur_node + 2][j]);\n\t}\n}\n\nint query_H(int fy, int ty, int fx, int tx, int cur_node, int ly, int ry){\n\tif( ry <= fy || ty <= ly ){\n\t\treturn INF;\n\t}\n\n\tif( fy <= ly && ry <= ty ){\n\t\treturn query_W(cur_node, fx, tx, 0, 0, WW);\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\treturn min(query_H(fy, ty, fx, tx, cur_node*2 + 1, ly, mid),\n\t\t\tquery_H(fy, ty, fx, tx, cur_node*2 + 2, mid, ry));\n}\n\n// [y1, y2) * [x1, x2)\nint query_segtree(int y1, int x1, int y2, int x2){\n\treturn query_H(y1, y2, x1, x2, 0, 0, HH);\n}\n\nvoid build_segtree(){\n\tconst int log_H = H == 1 ? 0 : 31 - __builtin_clz(H-1), log_W = W == 1 ? 0 :31 - __builtin_clz(W-1);\n\tHH = 1<<(log_H+1);\n\tWW = 1<<(log_W+1);\n\tseg_H = 2*HH - 1;\n\tseg_W = 2*WW - 1;\n\n\tseg_tree.clear();\n\tseg_tree = vector< vector<int> >(seg_H, vector<int>(seg_W, INF));\n\n\tinitialize_H(0, 0, HH);\n}\n\nint main(){\n\tint Q;\n\twhile(scanf(\"%d%d%d\",&H,&W,&Q), H){\n\t\tconst int log_H = 31 - __builtin_clz(H), log_W = 31 - __builtin_clz(W);\n\t\tdata.clear();\n\t\tseg_tree.clear();\n\n\t\tdata = vector< vector<int> >(H, vector<int>(W));\n\n\t\tfor(int i=0; i<H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tscanf(\"%d\", &data[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tbuild_segtree();\n\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d%d%d%d\",&y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query_segtree(y1, x1, y2+1, x2+1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nvector<vector<int>>vs;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum= 2147483647;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 11>=r&&u +11>= d) {\n\t\t\tfor (int x = l; x <r; ++x) {\n\t\t\t\tfor (int y = u; y <d; ++y) {\n\t\t\t\t\tminnum = min(minnum, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (nl + 11 >= nr&&nu +11 >= nd) {\n\t\t\tint ans = 2147483647;\n\t\t\tfor (int x = max(ql,nl); x < min(qr,nr); ++x) {\n\t\t\t\tfor (int y = max(qu,nu); y < min(qd,nd); ++y) {\n\t\t\t\t\tans = min(ans, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd) {\n\t\t\t\n\t\t\treturn minnum;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvs.clear();\n\t\tvs = vector<vector<int>>(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <limits>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MaxN = 1000005;\nconst int MaxM = 1005;\nconst int MaxS = MaxN << 2;\nconst int oo = (int)((1LL << 31) - 1);\n\nint mn[MaxN];\nint r, c;\nbool rev;\n\nint* getA(int i, int j) {\n    if (rev) return mn + j * r * 4;\n    else return mn + i * c * 4;\n}\n\nvoid init(int* tr, int k, int l, int r) {\n    tr[k] = oo;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    init(tr, k << 1, l, mid);\n    init(tr, k << 1 | 1, mid + 1, r);\n}\n\nvoid add(int* tr, int k, int l, int r, int idx, int v) {\n    if (l > idx || r < idx) return;\n    if (l == r) {\n        tr[k] = v;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    add(tr, k << 1, l, mid, idx, v);\n    add(tr, k << 1 | 1, mid + 1, r, idx, v);\n    tr[k] = min(tr[k], tr[k << 1]);\n}\n\nint dfs(int* tr, int k, int l, int r, int lb, int rb) {\n    if (l > rb || r < lb) return oo;\n    if (l >= lb && r <= rb) return tr[k];\n    int mid = (l + r) >> 1;\n    return min(dfs(tr, k << 1, l, mid, lb, rb), dfs(tr, k << 1 | 1, mid + 1, r, lb, rb));\n}\n\nint doit(int x1, int y1, int x2, int y2) {\n    int ret = oo;\n    for (int i = x1; i <= x2; i++) {\n        ret = min(ret, dfs(getA(i, i), 1, 0, (rev ? r : c) - 1, y1, y2));\n    }\n    return ret;\n}\n\nint main() {\n    int q, v;\n    \n#ifdef __FISH__\n    freopen(\"in.txt\", \"r\", stdin);\n#endif\n    \n    while (scanf(\"%d%d%d\", &r, &c, &q) == 3 && r) {\n        if (r > c) rev = true;\n        else rev = false;\n        for (int i = 0; i < r && i < c; i++) {\n            init(getA(i, i), 1, 0, max(r, c) - 1);\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                scanf(\"%d\", &v);\n                if (rev) add(getA(i, j), 1, 0, r - 1, i, v);\n                else add(getA(i, j), 1, 0, c - 1, j, v);\n            }\n        }\n        \n        while (q--) {\n            int x[2], y[2];\n            scanf(\"%d%d%d%d\", &x[0], &y[0], &x[1], &y[1]);\n            if (rev) {\n                swap(x[0], x[1]);\n                swap(y[0], y[1]);\n            }\n            printf(\"%d\\n\", doit(x[0], y[0], x[1], y[1]));\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    生まれ変わって出直します\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nlong long int sizex;\nlong long int sizey;\nlong long int const2d;\nunsigned int grid[4194304];\n\nvoid update(long long int x, long long int y, unsigned int t) {\n    x += sizex-1;\n    y += sizey-1;\n\n    grid[const2d*y+x] = t;\n    while (y >= 0) {\n        long long int x_ = x;\n\n        while (x_ > 0) {\n            x_ = (x_-1)/2;\n            grid[const2d*y+x_] = min(grid[const2d*y+x_*2+1], grid[const2d*y+x_*2+2]);\n        }\n        if (y == 0) break;\n\n        y = (y-1)/2;\n        grid[const2d*y+x] = min(grid[const2d*(y*2+1)+x], grid[const2d*(y*2+2)+x]);\n    }\n}\n\nunsigned int _get_min(unsigned int *vec, int wishl, int wishr, long long int k, int watchl, int watchr) {\n    int mid;\n    unsigned int lval, rval;\n\n    if (wishr <= watchl || watchr <= wishl) return INF;\n    if (wishl <= watchl && watchr <= wishr) {\n        return vec[k];\n    }\n\n    mid = (watchl+watchr)/2;\n    lval = _get_min(vec, wishl, wishr, k*2+1, watchl, mid);\n    rval = _get_min(vec, wishl, wishr, k*2+2, mid, watchr);\n    return min(lval, rval);\n}\n\nunsigned int get_min(int wishl, int wishr, int wishu, int wishd, long long int k, int watchu, int watchd) {\n    int mid;\n    unsigned int uval, dval;\n\n    if (wishd <= watchu || watchd <= wishu) return INF;\n    if (wishu <= watchu && watchd <= wishd) {\n        return _get_min(&grid[const2d*k], wishl, wishr, 0, 0, sizex);\n    }\n\n    mid = (watchu+watchd)/2;\n    uval = get_min(wishl, wishr, wishu, wishd, k*2+1, watchu, mid);\n    dval = get_min(wishl, wishr, wishu, wishd, k*2+2, mid, watchd);\n    return min(uval, dval);\n}\n    \nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n        const2d = sizex*2-1;\n\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", get_min(c1, c2+1, r1, r2+1, 0, 0, sizey));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int x)\n{\n\tx--;\n\trep(i,5) x|=x>>(1<<i);\n\treturn x+1;\n}\n\nstruct SegmentTree{\n\tint size;\n\tvi data;\n\tSegmentTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tSegmentTree(const vi& a):size(Need(a.size())),data(size*2,INFTY){\n\t\tcopy(all(a),data.begin()+size);\n\t\tfor(int i=size;--i;)\n\t\t\tdata[i]=min(data[i*2],data[i*2+1]);\n\t}\n\tint Get(int i){\n\t\treturn data[size+i];\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[size+i]=x;\n\t\tfor(i=(i+size)/2;i;i/=2)\n\t\t\tdata[i]=min(data[i*2],data[i*2+1]);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\treturn min(Query(a,b,i*2,l,(l+r)/2),Query(a,b,i*2+1,(l+r)/2,r));\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegmentTree2D{\n\tint size;\n\tvector<SegmentTree> data;\n\tSegmentTree2D(int h,int w):size(Need(h)),data(size*2,SegmentTree(w)){}\n\tSegmentTree2D(const vvi& a):size(Need(a.size())),data(size*2,SegmentTree(a[0].size())){\n\t\tcopy(all(a),data.begin()+size);\n\t\tfor(int i=size;--i;)\n\t\t\trepi(j,1,data[i].data.size())\n\t\t\t\tdata[i].data[j]=min(data[i*2].data[j],data[i*2+1].data[j]);\n\t}\n\tint Get(int i,int j){\n\t\treturn data[size+i].Get(j);\n\t}\n\tvoid Update(int i,int j,int x){\n\t\tdata[size+i].Update(j,x);\n\t\tfor(i=(i+size)/2;i;i/=2)\n\t\t\tdata[i].Update(j,min(data[i*2].Get(j),data[i*2+1].Get(j)));\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\treturn min(Query(a,b,c,d,i*2,to,(to+bo)/2),Query(a,b,c,d,i*2+1,(to+bo)/2,bo));\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(min(r,c),vi(max(r,c)));\n\t\tif(r<=c) rep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\telse     rep(j,r) rep(i,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q) scanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\t\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tSegmentTree2D st(grid);\n\t\trep(i,q)\n\t\t\tprintf(\"%d\\n\",st.Query(r1[i],c1[i],r2[i]+1,c2[i]+1));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nconst int N = 1000010;\nconst int inf = 10000000;\nstruct Tree\n{\n\tint x[2];\n\tint y[2];\n\tint val;\n\tint son[4];\n}tt[N<<2];\nint a[N];\nint n,m;\nint loc;\nvoid build(int x0,int x1,int y0,int y1,int idx)\n{\n\ttt[idx].x[0]=x0;\n\ttt[idx].x[1]=x1;\n\ttt[idx].y[0]=y0;\n\ttt[idx].y[1]=y1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttt[idx].son[i]=0;\n\t}\n\tif(x0==x1&&y0==y1)\n\t{\n\t\ttt[idx].val=a[(x0-1)*m+y0];\n\t\treturn ;\n\t}\n\tint mx=(x0+x1)>>1;\n\tint my=(y0+y1)>>1;\n\tif(x0==x1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\tbuild(x0,x0,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,x0,my+1,y1,tt[idx].son[1]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t}\n\telse if(y0==y1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[2]=++loc;\n\t\tbuild(x0,mx,y0,y0,tt[idx].son[0]);\n\t\tbuild(mx+1,x1,y0,y0,tt[idx].son[2]);\t\t\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[2]].val);\n\t}\n\telse\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\ttt[idx].son[2]=++loc;\t\t\n\t\ttt[idx].son[3]=++loc;\n\t\tbuild(x0,mx,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,mx,my+1,y1,tt[idx].son[1]);\n\t\tbuild(mx+1,x1,y0,my,tt[idx].son[2]);\n\t\tbuild(mx+1,x1,my+1,y1,tt[idx].son[3]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[2]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[3]].val);\n\t}\n}\nint query(int x0,int x1,int y0,int y1,int idx)\n{\n\tif(tt[idx].x[0]>=x0&&tt[idx].x[1]<=x1&&tt[idx].y[0]>=y0&&tt[idx].y[1]<=y1)\n\t{\n\t\treturn tt[idx].val;\n\t}\n\tif(tt[idx].x[0]>x1||tt[idx].x[1]<x0||tt[idx].y[0]>y1||tt[idx].y[1]<y0)\n\t{\n\t\treturn inf;\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(tt[idx].son[i]!=0)\n\t\t{\n\t\t\tans = min(query(x0,x1,y0,y1,tt[idx].son[i]),ans);\n\t\t}\n\t}\n\treturn ans;\n}\nint main(void)\n{\n\tint q,x0,x1,y0,y1;\n\twhile(scanf(\"%d%d%d\",&n,&m,&q)&&(n||m||q))\n\t{\n\t\tfor(int i=1;i<=n*m;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t}\n\t\tloc=1;\n\t\tbuild(1,n,1,m,1);\n\t\tfor(int i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x0,&y0,&x1,&y1);\n\t\t\tx0++;y0++;x1++;y1++;\n\t\t\tprintf(\"%d\\n\",query(x0,x1,y0,y1,1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n\ntypedef long long TYPE;\nTYPE inf = 100;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d(const int h, const int w);\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\n\tconst int width;\n\tconst int height;\n\n\tint width2;\n\tint height2;\n\tvector<vector<TYPE>> data;\n\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << data[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nSegment2d::Segment2d(const int h, const int w)\n: height(h)\n, width(w)\n{\n\twidth2 = 1;\n\twhile(width2 < width) width2 *= 2;\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfor(int i = 0; i < height2 * 2 - 1; i++)\n\t{\n\t\tdata.push_back(vector<TYPE>(width2 * 2 - 1));\n\t\tfill(data[i].begin(), data[i].end(), inf);\n\t}\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\tdata[y][x] = val;\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tdata[ys[i]][xs[0]] = \n\t\tmin(data[left(ys[i])][xs[0]], \n\t\t\tdata[right(ys[i])][xs[0]]);\n\t}\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tdata[ys[i]][xs[j]] = \n\t\t\tmin(data[ys[i]][left(xs[j])], \n\t\t\t\tdata[ys[i]][right(xs[j])]);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn data[ky][kx];\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tSegment2d seg(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\n//unsigned int _seg[11111111];\n//vector<unsigned int*> seg;\nint** seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg = (int**)malloc(sizeof(int*) * (2 * _r - 1));\n  rep(i, 2 * _r - 1) seg[i] = (int*)malloc(sizeof(int) * (2 * _c - 1));\n  /*\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n  */\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n    free(seg);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vint;\nclass segtree{\n\tpublic:\n\tint w,h;\n\tvector<vint> data;\n\tvoid set(int h_,int w_){\n\t\tdata.clear();\n\t\tw=h=1;\n\t\twhile(w<w_)\tw<<=1;\n\t\twhile(h<h_)\th<<=1;\n\t\tdata.assign(2*h-1,vint(2*w-1,INT_MAX));\n\t}\n\tvoid update(){\n\t\tfor(int i=2*h-2;i>h-2;i--){\n\t\t\tfor(int j=w-2;j>=0;j--){\n\t\t\t\tdata[i][j]=min(data[i][2*j+1],data[i][2*j+2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tdata[i][j]=min(data[2*i+1][j],data[2*i+2][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint minw(int sw,int tw,int hh,int l,int r,int k){\n\t\tif(sw<=l&&r<=tw)\treturn data[hh][k];\n\t\tif(r<=sw||tw<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minw(sw,tw,hh,l,mid,2*k+1),minw(sw,tw,hh,mid,r,2*k+2));\n\t}\n\tint minh(int sh,int sw,int th,int tw,int l,int r,int k){\n\t\tif(sh<=l&&r<=th)\treturn minw(sw,tw,k,0,w,0);\n\t\tif(r<=sh||th<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minh(sh,sw,th,tw,l,mid,2*k+1),minh(sh,sw,th,tw,mid,r,2*k+2));\n\t}\n\t~segtree(){}\n};\n\nint main(){\n\tsegtree seg;\n\twhile(true){\n\t\tint r,c,q;\tcin>>r>>c>>q;\n\t\tif(r+c+q==0)\treturn 0;\n\t\tif(r*c>250000){\n\t\t\tvector<vint> grd(r,vint(c));\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++)\tcin>>grd[i][j];\n\t\t\t}\n\t\t\tint q;\tcin>>q;\n\t\t\twhile(q--){\n\t\t\t\tint sh,sw,th,tw;\tcin>>sh>>sw>>th>>tw;\n\t\t\t\tint ans=INT_MAX;\n\t\t\t\tfor(int i=sh;i<=th;i++){\n\t\t\t\t\tfor(int j=sw;j<=tw;j++)\tans=min(ans,grd[i][j]);\n\t\t\t\t}\n\t\t\t\tcout<<ans<<endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tseg.set(r,c);\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tint a;\tcin>>a;\n\t\t\t\t\tseg.data[i+seg.h-1][j+seg.w-1]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tseg.update();\n\t\t\twhile(q--){\n\t\t\t\tint sh,sw,th,tw;\tcin>>sh>>sw>>th>>tw;\n\t\t\t\tcout<<seg.minh(sh,sw,th+1,tw+1,0,seg.h,0)<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ2D{\n\tint h,w;\n\tS *datrmq;\n\tmutable int xs,xe;\n\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\n\tvoid xbuild(int y,int n,const S a[]){\n\t\tS *dat=datrmq+y*(2*w-1);\n\t\tfor(int i=0;i<n;i++)dat[w-1+i]=a[i];\n\t\tfor(int i=n;i<w;i++)dat[w-1+i]=nil;\n\t\tfor(int i=w-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\tvoid xupdate(S *dat,int x,int a){\n\t\tx+=w-1;\n\t\tdat[x]=a;\n\t\twhile(x>0){\n\t\t\tx=(x-1)/2;\n\t\t\tdat[x]=std::min(dat[x*2+1],dat[x*2+2],T());\n\t\t}\n\t}\n\tvoid yupdate(int y,int x,int a){\n\t\ty+=h-1;\n\t\twhile(y>0){\n\t\t\ty=(y-1)/2;\n\t\t\txupdate(datrmq+y*(2*w-1),x,a);\n\t\t}\n\t}\n\tS xquery(const S *dat,int k,int l,int r)const{\n\t\tif(r<=xs||xe<=l)return nil;\n\t\tif(xs<=l&&r<=xe)return dat[k];\n\t\telse{\n\t\t\tS vl=xquery(dat,k*2+1,l,(l+r)/2);\n\t\t\tS vr=xquery(dat,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tS yquery(int ys,int ye,int k,int l,int r)const{\n\t\tif(r<=ys||ye<=l)return nil;\n\t\tif(ys<=l&&r<=ye)return xquery(datrmq+k*(2*w-1), 0,0,w);\n\t\telse{\n\t\t\tS vl=yquery(ys,ye,k*2+1,l,(l+r)/2);\n\t\t\tS vr=yquery(ys,ye,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=calcsize(h);\n\t\tw=this->w=calcsize(w);\n\t\tdatrmq=new S[(2*h-1)*(2*w-1)];\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\tfor(int i=0;i<n;i++)xbuild(h-1+i,m,a+i*m);\n\t\tfor(int i=n;i<h;i++)xbuild(h-1+i,m,dat);\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tconst S *a=datrmq+(i*2+1)*(2*w-1);\n\t\t\tconst S *b=datrmq+(i*2+2)*(2*w-1);\n\t\t\tS *c=datrmq+i*(2*w-1);\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tc[j]=std::min(a[j],b[j],T());\n\t\t\t}\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tdelete[] datrmq;\n\t}\n\tvoid update(int y,int x,int a){//(y,x)をaに変更\n\t\tyupdate(y,x,a);\n\t}\n\tS query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\tthis->xs=xs;\n\t\tthis->xe=xe;\n\t\treturn yquery(ys,ye,0,0,h);\n\t}\n};\n\n\n\nunsigned int g[1000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D<unsigned int,std::less<unsigned int>,~0u> rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[(x1-1)/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[x2/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct pool {\n    void * dat;\n    int end;\n    pool(int size){\n        dat = malloc(size);\n        end = 0;\n    }\n    ~pool(){\n        free(dat);\n    }\n    void * fetch(int size){\n        void * res = (char*)dat + end;\n        end+=size;\n        return res;\n    }\n    void reset(){\n        end = 0;\n    }\n};\n\npool mem_pool(sizeof(char)*1024*50);\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*k*2);\n        dat = new dat_t[k*2];\n        fill(dat, dat+k*2, inf);\n    }\n    ~SegTree(){\n        delete [] dat;\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        this->dat = new dat_t[s.n*2];\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            // dump(tree.dat[i].dat);\n            dump(vector<dat_t>(tree.dat[i].dat, tree.dat[i].dat+tree.dat[i].n*2));\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        mem_pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1000000;\n\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n,dat[2*MAX_N-1];\nint h,w;\nconst int INF=100000000;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    w=h;\n    while(w<w_)w*=2;\n    h=w;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx)return INF;\n    else if(qmaxy<miny||maxy<qminy)return INF;\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ¡ñ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // c\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1068\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n#define all(a) (a).begin(), (a).end()\n\nconst int INF = (1<<31)-1;\n\nint r, c, q;\nstd::vector<std::vector<int> > segR, segC;\n\nvoid init( std::vector<std::vector<int> > &seg, int n )\n{\n\tint sz = 1;\n\twhile( sz < n )\n\t\tsz <<= 1;\n\n\trep( i, seg.size() )\n\t{\n\t\tseg[i].resize( 2*sz );\n\t\tstd::fill( all( seg[i] ), INF );\n\t}\n\n\treturn;\n}\n\nvoid update( std::vector<int> &seg, int k, int x )\n{\n\tk += (seg.size()>>1)-1;\n\tseg[k] = x;\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tseg[k] = std::min( seg[(k<<1)+1], seg[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nint query( const std::vector<int> &seg, int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn INF;\n\telse if( a <= l && r <= b )\n\t\treturn seg[k];\n\t\n\treturn std::min( query( seg, a, b, (k<<1)+1, l, (l+r)>>1 ), query( seg, a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d%d\", &r, &c, &q ), r|c|q )\n\t{\n\t\tsegR.resize( r );\n\t\tsegC.resize( c );\n\t\tinit( segR, c );\n\t\tinit( segC, r );\n\n\t\trep( i, r )\n\t\t{\n\t\t\trep( j, c )\n\t\t\t{\n\t\t\t\tint grid;\n\t\t\t\tscanf( \"%d\", &grid );\n\n\t\t\t\tupdate( segR[i], j, grid );\n\t\t\t\tupdate( segC[j], i, grid );\n\t\t\t}\n\t\t}\n\n\t\trep( i, q )\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf( \"%d%d%d%d\", &r1, &c1, &r2, &c2 );\n\n\t\t\tint ans = INF;\n\n\t\t\tif( r2-r1 <= c2-c1 )\n\t\t\t\trepi( j, r1, r2+1 )\n\t\t\t\t\tans = std::min( ans, query( segR[j], c1, c2+1, 0, 0, segR[j].size()>>1 ) );\n\t\t\telse\n\t\t\t\trepi( j, c1, c2+1 )\n\t\t\t\t\tans = std::min( ans, query( segC[j], r1, r2+1, 0, 0, segC[j].size()>>1 ) );\n\n\t\t\tprintf( \"%d\\n\", ans );\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    w=h;\n    while(w<w_)w*=2;\n    h=w;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx)return INF;\n    else if(qmaxy<miny||maxy<qminy)return INF;\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ¡ñ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // c\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n\nstruct SegTree {\n\tint segSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<int>(segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=(1<<31)-1;\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvector< vector<int> > a(h,vector<int>(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tint h2=(int)(sqrt(h)+1),w2=(int)(sqrt(w)+1);\n\t\tvector< vector<int> > a2(h2,vector<int>(w2,INF));\n\t\trep(i,h2) rep(j,w2) {\n\t\t\tint t2=i*h2,b2=min((i+1)*h2,h),l2=j*w2,r2=min((j+1)*w2,w);\n\t\t\tfor(int y=t2;y<b2;y++) for(int x=l2;x<r2;x++) {\n\t\t\t\ta2[i][j]=min(a2[i][j],a[y][x]);\n\t\t\t}\n\t\t}\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\trep(i,h2) rep(j,w2) {\n\t\t\t\tint t2=i*h2,b2=min((i+1)*h2,h),l2=j*w2,r2=min((j+1)*w2,w);\n\t\t\t\tif(t2<=t && b<b2 && l2<=l && r<r2){\n\t\t\t\t\tans=min(ans,a2[i][j]);\n\t\t\t\t}\n\t\t\t\telse if(b<=t2 || b2<=t || r<=l2 || r2<=l);\n\t\t\t\telse{\n\t\t\t\t\tfor(int y=max(t,t2);y<min(b,b2);y++){\n\t\t\t\t\t\tfor(int x=max(l,l2);x<min(r,r2);x++){\n\t\t\t\t\t\t\tans=min(ans,a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\n\t\tbool is_reverse = r > c;\n\t\tvector<seg_tree<ll>> segs(max(r,c), seg_tree<ll>(min(r,c)));\n\t\tREP(i, r) REP(j, c) {\n\t\t\tll x = i, y = j;\n\t\t\tif (is_reverse) swap(x, y);\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tif (is_reverse) swap(x_1, y_1), swap(x_2, y_2);\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\ninline int MIN(int a,int b){\n\treturn a<b?a:b;\n}\nstruct SSS{\n\tint p[21];\n}st[1010000];\nSSS *top,*at[1010000];\nint tlog[1010000];\nSSS *getptr(int len) {\n\tSSS *p=top;\n\ttop+=(len+1);\n\treturn p;\n}\nvoid ST(SSS st[],int num[],int sz){\n     for(int i=1;i<=sz;i++) st[i].p[0]=num[i];\n     for(int j=1;j<=tlog[sz];j++){\n           for(int i=0;j<=tlog[sz+1-i];i++){\n                st[i].p[j]=MIN(st[i].p[j-1],st[i+(1<<j>>1)].p[j-1]);\n           }\n     }\n}\nint RMQ(SSS st[],int l,int r){\n     int tmp=tlog[r-l+1];\n     return MIN(st[l].p[tmp],st[r-(1<<tmp)+1].p[tmp]);\n}\nint p[1100000],tp[1100000];\nvoid scanf_(int &num){\n\tchar in;\n\tbool neg=false;\n\twhile(((in=getchar())>'9'||in<'0')&&in!='-');\n\tif(in=='-'){\n\t\tneg=true;\n\t\twhile((in=getchar())>'9'||in<'0');\n\t}\n\tnum=in-'0';\n\twhile(in=getchar(),in>='0'&&in<='9')\n\t\tnum*=10,num+=in-'0';\n\tif(neg)\n\tnum=0-num;\n}\nint main(){\n\ttlog[0]=-1;\n\tfor(int i=1;i<1010000;i++){\n\t\ttlog[i]=tlog[i-1]+((i&(i-1))?0:1);\n\t}\n\tint r,c,q,fg;\n\twhile(scanf(\"%d%d%d\",&r,&c,&q),(r||c||q)) {\n\t\ttop=st;\n\t\tif(r<=c) {\n\t\t\tfor(int i=1;i<=r;i++) {\n\t\t\t\tat[i]=getptr(c);\n\t\t\t\tfor(int j=1;j<=c;j++) scanf_(p[j]);\n\t\t\t\tST(at[i],p,c);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=r1;j<=r2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],c1,c2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i=1;i<=r;i++) {\n\t\t\t\tfor(int j=1;j<=c;j++) scanf_(tp[(i-1)*c+j]);\n\t\t\t}\n\t\t\tfor(int i=1;i<=c;i++) {\n\t\t\t\tat[i]=getptr(r);\n\t\t\t\tfor(int j=1;j<=r;j++) p[j]=tp[(j-1)*c+i];\n\t\t\t\tST(at[i],p,r);\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tint r1,c1,r2,c2;\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tint mi=2147483647;\n\t\t\t\tfor(int j=c1;j<=c2;j++) {\n\t\t\t\t\tmi=min(mi,RMQ(at[j],r1,r2));\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",mi);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int inf = (1 << 31) - 1;\n\nstruct segtree1 {\n\n\tvector<int> dat;\n\tint s;\n\t\n\tvoid init(int size)\n\t{\n\t\ts = 1;\n\t\twhile(s < size) s *= 2;\n\t\t\n\t\tdat.resize(s * 2, inf);\n\t}\n\t\n\tvoid set(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\t\n\t\tdat[pos] = v;\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos] = min(dat[pos * 2 + 0], dat[pos * 2 + 1]);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tvoid setmin(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\tif(dat[pos] > v)\n\t\t\tset(x, v);\n\t}\n\t\n\tint getmin(int a, int b, int l, int r, int idx)\n\t{\n\t\tif(b <= l || r <= a) return inf;\n\t\t\n\t\tif(a <= l && r <= b) {\n\t\t\n\t\t\treturn dat[idx];\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(a, b, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(a, b, m, r, idx * 2 + 1));\n\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int a, int b)\n\t{\n\t\treturn getmin(a, b, 0, s, 1);\n\t}\n};\n\nstruct segtree2 {\n\t\n\tvector<segtree1> dat;\n\tint w, h;\n\t\n\tvoid init(int width, int height)\n\t{\n\t\tw = 1;\n\t\twhile(w < width) w *= 2;\n\t\t\n\t\th = 1;\n\t\twhile(h < height) h *= 2;\n\t\t\n\t\tdat.resize(h * 2);\n\t\tfor(int i = 0; i < h * 2; ++i)\n\t\t\tdat[i].init(w);\n\t}\n\t\n\tvoid set(int x, int y, int v)\n\t{\n\t\tint pos = h + y;\n\t\t\n\t\tdat[pos].set(x, v);\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos].setmin(x, v);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by, int l, int r, int idx)\n\t{\n\t\tif(by <= l || r <= ay) return inf;\n\t\t\n\t\tif(ay <= l && r <= by) {\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, dat[idx].getmin(ax, bx));\n\t\t\treturn dat[idx].getmin(ax, bx);\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, m, r, idx * 2 + 1));\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by)\n\t{\n\t\treturn getmin(ax, ay, bx, by, 0, h, 1);\n\t}\n};\n\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint r, c, q;\n\t\tsegtree2 st;\n\t\t\n\t\tscanf(\"%d%d%d\", &r, &c, &q);\n\t\t\n\t\tif(r == 0 && c == 0 && q == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tst.init(r, c);\n\t\t\n\t\tfor(int x = 0; x < r; ++x) {\n\t\t\tfor(int y = 0; y < c; ++y) {\n\t\t\t\n\t\t\t\tint v;\n\t\t\t\t\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\t\n\t\t\t\tst.set(x, y, v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\n\t\t\tint r1, c1, r2, c2;\n\t\t\t\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\t\n\t\t\tint ans = st.getmin(r1, c1, r2 + 1, c2 + 1);\n\t\t\t\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W;\n\tvector<vector<int>> dat;\n\tsegtree() {}\n\tsegtree(vector<vector<int>> &f) {\n\t\tinit(f);\n\t}\n\tvoid init(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tdat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[i + H - 1][j + W - 1] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nvector<vector<int>> f;\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tf.assign(r, vector<int>(c, 0));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 24;\nconst int INF = 1 << 28;\n\nint r, c;\nint w, h;\nint seg[8 * MAX_N];\n\nvoid init()\n{\n\tfor (w = 1; w < r; w <<= 1);\n\tfor (h = 1; h < c; h <<= 1);\n\tfill_n(seg, 8 * MAX_N, INF);\n}\n\nvoid update(int x, int y, int v, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (x < ax || bx <= x) return;\n\tif (y < ay || by <= y) return;\n\t\n\tif (bx - ax == 1 && by - ay == 1){\n\t\tseg[k] = v;\n\t\treturn;\n\t}\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\tseg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\n\t//printf(\"seg[%d] = %d\\n\", k, seg[k]);\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n}\n\nint getMin(int lx, int ly, int rx, int ry, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (rx <= ax || bx <= lx) return INF;\n\tif (ry <= ay || by <= ly) return INF;\n\tif (lx <= ax && bx <= rx && ly <= ay && by <= ry) return seg[k];\n\t\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tint vl, vr;\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\treturn min(vl, vr);\n}\n\nint main()\n{\n\tint q;\n\twhile (scanf(\"%d %d %d\", &r, &c, &q), r|c|q){\n\t\tinit();\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tint v;\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\tupdate(i, j, v);\n\t\t\t}\n\t\t}\n\t\twhile (q--){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", getMin(r1, c1, ++r2, ++c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n// AOJ 1068 - School of Killfish\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector<value_type> m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size = 0, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n\tvalue_type operator[](size_t i) const {\n\t\treturn m_data[m_size - 1 + i];\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree2D {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< SegmentTree<Traits> > m_data;\n\tsize_t m_width, m_height;\n\n\tvoid initialize(){\n\t\tvector<value_type> work(m_width);\n\t\tfor(int i = static_cast<int>(m_height) - 2; i >= 0; --i){\n\t\t\tfor(size_t j = 0; j < m_width; ++j){\n\t\t\t\twork[j] =\n\t\t\t\t\tm_traits(m_data[i * 2 + 1][j], m_data[i * 2 + 2][j]);\n\t\t\t}\n\t\t\tm_data[i] = SegmentTree<Traits>(work.begin(), work.end());\n\t\t}\n\t}\n\n\tvalue_type query(\n\t\tint x0, int y0, int x1, int y1, int k, int l, int r) const\n\t{\n\t\tif(r <= y0 || y1 <= l){ return m_traits.default_value(); }\n\t\tif(y0 <= l && r <= y1){ return m_data[k].query(x0, x1); }\n\t\tconst value_type vl = query(x0, y0, x1, y1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(x0, y0, x1, y1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tsize_t height = 0, size_t width = 0, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(width)\n\t{\n\t\twhile(m_height < height){ m_height *= 2; }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(width, traits));\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree2D(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(0)\n\t{\n\t\tconst size_t h = distance(first, last);\n\t\twhile(m_height < h){ m_height *= 2; }\n\t\tif(h > 0){ m_width = distance(first->begin(), first->end()); }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(m_width, traits));\n\t\tsize_t row = m_height - 1;\n\t\tfor(Iterator it = first; it != last; ++it, ++row){\n\t\t\tm_data[row] = SegmentTree<Traits>(it->begin(), it->end());\n\t\t}\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, size_t j, const value_type &val){\n\t\ti += m_height - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_traits(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(size_t x0, size_t y0, size_t x1, size_t y1) const {\n\t\treturn query(x0, y0, x1, y1, 0, 0, m_height);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct MinSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT operator()(const T &a, const T &b) const { return min(a, b); }\n};\n\n\n}\n}\n\n\nusing libcomp::structure::SegmentTree2D;\nusing libcomp::structure::MinSegmentTreeTraits;\ntypedef SegmentTree2D< MinSegmentTreeTraits<int> > MinSegmentTree2D;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tvector< vector<int> > grid(r, vector<int>(c));\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){ cin >> grid[i][j]; }\n\t\t}\n\t\tMinSegmentTree2D st(grid.begin(), grid.end());\n\t\twhile(q--){\n\t\t\tint y0, x0, y1, x1;\n\t\t\tcin >> y0 >> x0 >> y1 >> x1;\n\t\t\tcout << st.query(x0, y0, x1 + 1, y1 + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&mi<malta[x1/B])x1=(x1/B+1)*B;\n\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void destroy();\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void destroy(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Free.\nvoid SegmentTree::destroy() {destroy(root_);}\nvoid SegmentTree::destroy(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) destroy(node->child[i]);\n  delete node;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.destroy();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=pow(r,1./3);\n    int cs=pow(c,1./3);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&i/rs*rs+rs<=b+1&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst long long int INF=1000000000000;\nvector<vector<long long int> > dc,dr;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<long long int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nlong long int query(vector<long long int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tlong long int vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tlong long int vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tdr.resize(c);\n\t\tc2=init(c)*2;\n\t\tr2=init(r)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tdr[i].resize(r2);\n\t\t\tfill(dr[i].begin(),dr[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t\tupdate(dr[j],i,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tlong long int res=INF;\n\t\t\tif(y2-y<=x2-x){\n\t\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x;i<=x2;i++){\n\t\t\t\t\tres=min(res,query(dr[i],y,y2+1,0,0,dr[i].size()/2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a)*(b+m)>8000000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, vector<int> a){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n, INT_MAX);\n            for(int i = n; i < n + n_; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w){\n            swap(h, w);\n            f = true;\n        }\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j + 1, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            if(f){\n                swap(a.first, a.second);\n                swap(b.first, b.second);\n            }\n            a.second++; b.second++;\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int map[1000000];\n  int rmq[2000];\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int rr,rc;\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    rr = (int)sqrt(r);\n    rc = (int)sqrt(c);\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> map[i*c+j];\n    }\n\n    for(int i=0;i<r/rr;i++){\n      for(int j=0;j<c/rc;j++){\n\trmq[i*(c/rc)+j] = 1<<31 - 1;\n\tint ur = min( (i+1)*rr, r);\n\tfor(int k=i*rr;k<ur;k++){\n\t  int uc = min( (j+1)*rc, c);\n\t  for(int l=j*rc;l<uc;l++){\n\t    rmq[i*(c/rc)+j] = min(rmq[i*(c/rc)+j],map[k*c+l]);\n\t  }\n\t}\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int tr1,tc1,tr2,tc2;\n      tr1 = r1/rr;\n      if(r1%rr)tr1++;\n      tc1 = c1/rc;\n      if(c1%rc)tc1++;\n      tr2 = r2/rr;\n      if( !((r2+1)%rr) )tr2++;\n      tc2 = c2/rc;\n      if( !((c2+1)%rc) )tc2++;\n\n      int m = 1<<31 - 1;\n      for(int i=r1;i<tr1*rr;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n      //if(r2%rr && tr1!=tr2+1){\n\tfor(int i=tr2*rr;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    m = min(m,map[i*c+j]);\n\t  }\n\t}\n\t//}\n      \n      for(int i=r1;i<=r2;i++){\n\tfor(int j=c1;j<tc1*rc;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n\t//if(c2%rc && tc1!=tc2+1){\n\t  for(int j=tc2*rc;j<=c2;j++){\n\t    m = min(m,map[i*c+j]);\n\t  }\n\t  //}\n      }\n\n      for(int i=tr1;i<tr2;i++){\n\tfor(int j=tc1;j<tc2;j++){\n\t  m = min(m,rmq[i*(c/rc)+j]);\n\t}\n      }\n      cout << m << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[8*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < 8*MAX_N; i++)\n\t\tdat[i]=INF;\n}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\n//uint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n//\t// dÈèªªÈ¢\n//\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n//\t// ®SÉÜÜêé\n//\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n//\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n//\tuint vl,vr;\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n//\t//if(vl<vr)return vl;\n//\t//return vr;\n//\treturn min(vl,vr);\n//}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\nvoid update(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,uint a,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return;\n\t// ®SÉÜÜêé\n\tdat[k]=min(dat[k],a);\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy){\n\t\t// ¡ñÌêðXVµ½çI¹\n\t\treturn;\n\t}\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\tif(isHor){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n\telse{\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n\t//if(vl<vr)return vl;\n\t//return vr;\n}\n\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\tif(isHor){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\telse\n\t\t\tvr=INF;\n\t}\n\telse{\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\telse vr=INF;\n\t}\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n\t//if(vl<vr)return vl;\n\t//return vr;\n\treturn min(vl,vr);\n}\n\nint main(){\n\tFILE *fp=stdin;\n\t//fp=fopen(\"input.txt\",\"r\");\n\twhile(fscanf(fp,\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\t//while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\t//cin>>t;\n\t\t\t\tfscanf(fp,\"%d\",&t);\n\t\t\t\t//pdate(i*w+j,t);\n\t\t\t\tupdate(j,i,j,i,0,0,w-1,h-1,t,0,true);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\t//cin>>r1>>c1>>r2>>c2;\n\t\t\tfscanf(fp,\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0,true);\n\t\t\t//cout<<res<<endl;\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n//\tvector<int> seg;\n\tint *seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = (int*)malloc(sizeof(int) * (nodeSize+segSize));\n\t\tfill(&seg[0], &seg[0]+nodeSize+segSize, INF);\n//\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\treturn seg[n];\n//\t\tif (n < (int)seg.size()) return seg[n];\n//\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tseg[n] = v;\n//\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\tfree(seg);\n\t\t//seg.clear();\n\t\t//seg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tint *m = (int*)malloc(sizeof(int) * W*H);\n//\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y*W+x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y*W+x]);\n\t\t\t\telse seg[x].update(y, m[y*W+x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<vector>\n#include<algorithm>\n// constant\nconst int INF = 1e9;\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int find(int x1, int y1, int x2, int y2) const;\n//   void print();\nprivate:\n  void update(int index, int a1, int b1, int a2, int b2, int x, int y, int value);\n  int find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const;\n  int parent(int index) const;\n  int upper_left(int index) const;\n  int upper_right(int index) const;\n  int lower_left(int index) const;\n  int lower_right(int index) const;\n  std::vector<int> node_;\n  int height_;\n  int width_;\n  int size_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) : width_(x), height_(y) {\n  size_ = 1;\n  for(int i = 1; i < std::max(x, y); i <<= 1) size_ <<= 2;\n  node_.assign(size_, INF);\n}\n// set value on (x, y)\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, 0, width_ - 1, height_ - 1, x, y, value);\n}\nvoid SegmentTree::update(int index, int a1, int b1, int a2, int b2, int x, int y, int value) {\n  if(size_ <= index) return;\n  if(x < a1 || a2 < x) return;\n  if(y < b1 || b2 < y) return;\n  if(a1 == x && x == a2 && b1 == y && y == b2) {\n    node_[index] = value;\n    while(index) {\n      node_[parent(index)] = std::min(node_[parent(index)], node_[index]);\n      index = parent(index);\n    }\n  } else {\n    int a = (a1 + a2) >> 1;\n    int b = (b1 + b2) >> 1;\n    update(upper_left(index), a1, b1, a, b, x, y, value);\n    update(upper_right(index), a + 1, b1, a2, b, x, y, value);\n    update(lower_left(index), a1, b + 1, a, b2, x, y, value);\n    update(lower_right(index), a + 1, b + 1, a2, b2, x, y, value);\n  }\n}\n// find the minimum value in (x1, y1)-(x2, y2)\nint SegmentTree::find(int x1, int y1, int x2, int y2) const {\n  return find(0, 0, 0, width_ - 1, height_ - 1, x1, y1, x2, y2);\n}\nint SegmentTree::find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const {\n//   for(int i=0;i<(index-1)>>2;++i)cout<<\" \";\n//   cout<<\"*\"<<index<<\"* \"<<a1<<\" \"<<b1<<\" \"<<a2<<\" \"<<b2<<endl;\n  if(size_ <= index) return INF;\n  if(x2 < a1 || a2 < x1) return INF;\n  if(y2 < b1 || b2 < y1) return INF;\n  if(x1 <= a1 && a2 <= x2 && y1 <= b1 && b2 <= y2) return node_[index];\n  int a = (a1 + a2) >> 1;\n  int b = (b1 + b2) >> 1;\n  int ul = find(upper_left(index), a1, b1, a, b, x1, y1, x2, y2);\n  int ur = find(upper_right(index), a + 1, b1, a2, b, x1, y1, x2, y2);\n  int ll = find(lower_left(index), a1, b + 1, a, b2, x1, y1, x2, y2);\n  int lr = find(lower_right(index), a + 1, b + 1, a2, b2, x1, y1, x2, y2);\n  return std::min({ul, ur, ll, lr});\n}\n// // debug\n// void SegmentTree::print() {\n//   for(auto i: node_) cout<<\" \"<<i;cout<<endl;\n// }\n// position\nint SegmentTree::parent(int index) const {return (index - 1) >> 2;}\nint SegmentTree::upper_left(int index) const {return (index << 2) + 1;}\nint SegmentTree::upper_right(int index) const {return (index << 2) + 2;}\nint SegmentTree::lower_left(int index) const {return (index << 2) + 3;}\nint SegmentTree::lower_right(int index) const {return (index << 2) + 4;}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n//     tree.print();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.find(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//40\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF ((1<<31)^~0)\n#define N 1000\n\nint d[1000][2*N-1];\n\nint que(int *d,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return INF;\n  }else if(a<=l&&r<=b){\n    return d[k];\n  }else{\n    return min(que(d,a,b,k*2+1,l,(l+r)/2)\n\t       ,que(d,a,b,k*2+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > g;\n    bool w=r<c;\n    if(w){\n      g=vector<vector<int> >(r,vector<int>(c));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[i][j];\n\t}\n      }\n    }else{\n      g=vector<vector<int> >(c,vector<int>(r));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[j][i];\n\t}\n      }\n      swap(r,c);\n    }\n    int cc;\n    for(cc=1;cc<c;cc*=2);\n    fill(d[0],d[r+1],INF);\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tint k=j+cc-1;\n\td[i][k]=g[i][j];\n\twhile(k>0){\n\t  k=(k-1)/2;\n\t  d[i][k]=min(d[i][k*2+1],d[i][k*2+2]);\n\t}\n      }\n    }\n    while(q--){\n      int r1,c1,r2,c2;\n      if(w){\n\tcin>>r1>>c1>>r2>>c2;\n      }else{\n\tcin>>c1>>r1>>c2>>r2;\n      }\n      int m=INF;\n      for(int i=r1;i<=r2;i++){\n\tm=min(m,que(d[i],c1,c2+1,0,0,cc));\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Max=1000010;\n#define inf 0x7fffffff\nint ma[Max];\nint Log[Max];\nint rmq[Max*23];\nint K,r,c,q;\n\nvoid preRMQ(){\n\tK=Log[c]+2;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int k=0;(1<<k)-1<c;k++){\n\t\t\tfor(int j=0;j+(1<<k) - 1<c;j++){\n\t\t\t\tif(k==0)\n\t\t\t\t\trmq[(i*K+k)*c+j]=ma[i*c+j];\n\t\t\t\telse\n\t\t\t\t\trmq[(i*K+k)*c+j]=min(rmq[(i*K+k-1)*c+j],rmq[(i*K+k-1)*c+j+(1<<k-1)]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint RMQ(int R,int i,int j){\n\tint k=Log[j-i+1];\n\treturn min(rmq[(R*K+k)*c+i],rmq[(R*K+k)*r+j-(1<<k)+1]);\n}\n\nint main()\n{\n\tLog[1]=0;\n\tfor(int i=2,x=1;i<Max;i++){\n\t\tif(i>=(1<<x+1))\n\t\t\tx++;\n\t\tLog[i]=x;\n\t}\n\twhile(scanf(\"%d %d %d\",&r,&c,&q) == 3){\n\t\tif(r==0 && c==0 && q==0)\n\t\t\tbreak;\n\t\tint rr=r,cc=c;\n\t\tbool flag=false;\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tflag=true;\n\t\t}\n\t\tfor(int i=0;i<rr;i++){\n\t\t\tfor(int j=0;j<cc;j++){\n\t\t\t\tscanf(\"%d\",&ma[i*c+j]);\n\t\t\t}\n\t\t}\n\t\tpreRMQ();\n\t\tint a1,a2,b1,b2;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tscanf(\"%d %d %d %d\",&a1,&a2,&b1,&b2);\n\t\t\tif(flag){\n\t\t\t\tswap(a1,a2);\n\t\t\t\tswap(b1,b2);\n\t\t\t}\n\t\t\tint ans=inf;\n\t\t\tfor(int j=a1;j<=b1;j++){\n\t\t\t\tans=min(ans,RMQ(j,a2,b2));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\t\tvector<seg_tree<ll>> segs(r, seg_tree<ll>(c));\n\t\tREP(x, r) REP(y, c) {\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tprintf(\"%d%c\", cmp[i][j], j == Ws - 1 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = 0; j < Hs; j++){\n\t\t\t\tfor (int k = 0; k < Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t&& w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); k <= min((k + 1) * Ws, w2); k++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    2次元segtree、モートン順序でメモリ節約する方法を教えて下さい...\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\n\nclass Seg2d {\npublic:\n    vector<unsigned int> grid;\n    int width;\n    int height;\n\n    Seg2d (int sizex, int sizey) : width(sizex), height(sizey) {\n        long long int len = max(width, height);\n        long long int sq = len*len;\n        long long int ration = max(width, height) / min(width, height);\n        long long int size = (sq*4-1)/3/ration + 1;\n\n        grid.resize(20000000, INF);\n    }\n\n    void _update(int wishl, int wishr, int wishu, int wishd, int k, int watchl, int watchr, int watchu, int watchd, unsigned int x) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n\n        if (wishl == wishr || wishu == wishd) return;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            grid[k] = x;\n            return;\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        _update(wishl, wishr, wishu, wishd, k*4+1, watchl, midx, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, k*4+2, midx, watchr, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, k*4+3, watchl, midx, midy, watchd, x);\n        _update(wishl, wishr, wishu, wishd, k*4+4, midx, watchr, midy, watchd, x);\n        grid[k] = min(min(grid[k*4+1], grid[k*4+2]), min(grid[k*4+3], grid[k*4+4]));\n    }\n\n    void update(int x, int y, unsigned int t) {\n        _update(x, x+1, y, y+1, 0, 0, width, 0, height, t);\n    }\n\n    unsigned int _getMin(int wishl, int wishr, int wishu, int wishd, int k, int watchl, int watchr, int watchu, int watchd) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n\n        if (wishl == wishr || wishu == wishd) return INF;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return INF;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            return grid[k];\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        val1 = _getMin(wishl, wishr, wishu, wishd, k*4+1, watchl, midx, watchu, midy);\n        val2 = _getMin(wishl, wishr, wishu, wishd, k*4+2, midx, watchr, watchu, midy);\n        val3 = _getMin(wishl, wishr, wishu, wishd, k*4+3, watchl, midx, midy, watchd);\n        val4 = _getMin(wishl, wishr, wishu, wishd, k*4+4, midx, watchr, midy, watchd);\n        return min(min(val1, val2), min(val3, val4));\n    }\n\n    unsigned int getMin(int x1, int x2, int y1, int y2) { // [x1, x2) [y1, y2)\n        return _getMin(x1, x2, y1, y2, 0, 0, width, 0, height);\n    }\n};\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n    \n        Seg2d seg(sizex, sizey);\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                seg.update(j, i, g);\n            }\n        }\n    \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", seg.getMin(c1, c2+1, r1, r2+1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct Sparse2DSegmentTree {\n  using T = int;\n  static T op(const T& a, const T& b) { return min(a, b); }\n  static constexpr T e() { return ~(~0 << 31); }\n\n  struct SegmentTree {\n    const int n;\n    V<T> t;\n    SegmentTree(int n) : n(n), t(2 * n, e()) {}\n    T& operator[](int i) { return t[i + n]; }\n    void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n    T acc(int l, int r) const {\n      T res = e();\n      for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n        if (l & 1) res = op(res, t[l++]);\n        if (r & 1) res = op(res, t[--r]);\n      }\n      return res;\n    }\n    void set(int i, const T& a) {\n      t[i += n] = a;\n      while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n  };\n  const int n;\n  V<SegmentTree> st;\n  VV<> ys;\n  Sparse2DSegmentTree(int n) : n(n), ys(2 * n) {}\n  void preset(int x, int y) {\n    for (x += n; x; x >>= 1) ys[x].push_back(y);\n  }\n  void build() {\n    for (auto&& v : ys) {\n      sort(begin(v), end(v));\n      v.erase(unique(begin(v), end(v)), end(v));\n      st.emplace_back(v.size());\n    }\n  }\n  int zip(int x, int y) const { return lower_bound(begin(ys[x]), end(ys[x]), y) - begin(ys[x]); }\n  T acc(int x0, int x1, int y0, int y1) const {\n    T res = e();\n    for (x0 += n, x1 += n; x0 < x1; x0 >>= 1, x1 >>= 1) {\n      if (x0 & 1) res = op(res, st[x0].acc(zip(x0, y0), zip(x0, y1))), ++x0;\n      if (x1 & 1) --x1, res = op(res, st[x1].acc(zip(x1, y0), zip(x1, y1)));\n    }\n    return res;\n  }\n  void set(int x, int y, const T& a) {\n    for (x += n; x; x >>= 1) st[x].set(zip(x, y), op(st[x][zip(x, y)], a));\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int r, c, q; cin >> r >> c >> q;\n    if (!r) break;\n    Sparse2DSegmentTree st(r);\n    for (int i = 0; i < r; ++i) for (int j = 0; j < c; ++j) {\n      st.preset(i, j);\n    }\n    st.build();\n    for (int i = 0; i < r; ++i) for (int j = 0; j < c; ++j) {\n      int x; cin >> x;\n      st.set(i, j, x);\n    }\n    while (q--) {\n      int r0, c0, r1, c1; cin >> r0 >> c0 >> r1 >> c1, ++r1, ++c1;\n      cout << st.acc(r0, r1, c0, c1) << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nint const MAX_SIZE = 250000*30;\nstruct Pool {\n    static dat_t dat[MAX_SIZE];\n    static int size;\n    static dat_t * fetch(int len){\n        dat_t * res = dat + size;\n        size+=len;\n        return res;\n    }\n    static void reset(){\n        size = 0;\n    }\n};\n\nint Pool::size = 0;\ndat_t Pool::dat[MAX_SIZE];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nclass RMQ2D {\n  public:\n    int H, W;\n    std::vector<std::vector<int>> dat;    \n\n    RMQ2D(int h, int w, std::vector<std::vector<int>>& grid)\n    {\n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        dat.resize(2 * H - 1);\n        for (int i = 0; i < 2 * H - 1; i++) {\n            dat[i].resize(2 * W - 1);\n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[i][j] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[i + H - 1][j + W - 1] = grid[i][j]; \n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[i][j] = std::min(dat[i][j * 2 + 1], dat[i][j * 2 + 2]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[j][i] = std::min(dat[j * 2 + 1][i], dat[j * 2 + 2][i]);\n            }\n        }\n    }\n   \n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[j][k];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        std::vector<std::vector<int>> grid(H, std::vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n        RMQ2D r(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            std::cout << r.query(y1, x1, y2, x2) << std::endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nclass RMQ{\npublic:\n  RMQ(){}\n  RMQ(int n_){\n    init(n_);\n  }\n  void init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    dat.resize(2*n - 1);\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = INT_MAX;\n  }\n  void update(int k,int a){\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1)/2;\n      dat[k] = min(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  void print(){\n    for (int i = n - 1; i < 2*n - 1; i++) {\n      std::cout << dat[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  lli query(int a,int b,int k = 0,int l = 0,int r = 0){\n    if(r <= l) r = n;\n    if(r <= a || b <= l) return 1e11;\n    if(r <= b && a <= l) return dat[k];\n    lli vl = query(a, b, k*2 + 1, l, (r + l)/2);\n    lli vr = query(a, b, k*2 + 2, (r + l)/2, r);\n    return min(vl,vr);\n  }\nprivate:\n  int n;\n  vector<int>dat;\n};\n\nvector<RMQ> makeSegTree(bool f, int mini,\n                        vector<vector<int > >& grid){\n  vector<RMQ> res(mini);\n  int maxi = max(grid.size(), grid[0].size());\n  for (int i = 0; i < mini; i++) {\n    res[i].init(maxi);\n  }\n  for (int i = 0; i < mini; i++) {\n    for (int j = 0; j < maxi; j++) {\n      if(f) res[i].update(j, grid[j][i]);\n      else res[i].update(j, grid[i][j]);\n    }\n  }\n  return res;\n}\nvoid printGrid(vector<vector<int> >& grid){\n  for (int i = 0; i < grid.size(); i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n      std::cout << grid[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\nint main(){\n  int r, c, q;\n  while(std::cin >> r >> c >> q){\n    if(r == 0 && c == 0)break;\n    int mini = min(r, c);\n    vector<vector<int> > grid(r, vector<int>(c));\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j < c; j++) {\n        std::cin >> grid[i][j];\n      }\n    }\n    vector<RMQ> t = makeSegTree(r > c, mini, grid);\n    //for (int i = 0; i < t.size(); i++) {\n      //t[i].print();\n    //}\n    int row, col, rowrow, colcol;\n    for (int i = 0; i < q; i++) {\n      lli ans = 1e11;\n      std::cin >> row >> col >> rowrow >> colcol;\n      if(r <= c)swap(col, row),swap(colcol, rowrow);\n      //std::cout << col << \" \" << row << \" \" << colcol << \" \" << yy << std::endl;\n      for (int j = col; j <= colcol; j++) {\n        ans = min(ans, t[j].query(row, rowrow + 1));\n      }\n      std::cout << ans << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=(1<<31)-1;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvector< vector<int> > a(h,vector<int>(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tint h2=(int)(sqrt(h)+1),w2=(int)(sqrt(w)+1);\n\t\tvector< vector<int> > a2(h2,vector<int>(w2,INF));\n\t\trep(i,h2) rep(j,w2) {\n\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\tfor(int y=t2;y<b2;y++) for(int x=l2;x<r2;x++) {\n\t\t\t\ta2[i][j]=MIN(a2[i][j],a[y][x]);\n\t\t\t}\n\t\t}\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\trep(i,h2) rep(j,w2) {\n\t\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\t\tif(t<=t2 && b2<b && l<=l2 && r2<r){\n\t\t\t\t\tans=MIN(ans,a2[i][j]);\n\t\t\t\t}\n\t\t\t\telse if(b<=t2 || b2<=t || r<=l2 || r2<=l);\n\t\t\t\telse{\n\t\t\t\t\tfor(int y=MAX(t,t2);y<MIN(b,b2);y++){\n\t\t\t\t\t\tfor(int x=MAX(l,l2);x<MIN(r,r2);x++){\n\t\t\t\t\t\t\tans=MIN(ans,a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = INT_MAX;\n\nstruct SegTree {\n    vector<int> dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat.assign(k*2, inf);\n    }\n    void set(int x, int val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    int get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            // dump(l,r);\n            return dat[k];\n        }\n        int v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        int v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, int val){\n        int i = n + y; // leaf\n        dat[i].set(x,val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x,val);\n            i>>=1;\n        }\n    }\n    int get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            // dump(l,r);\n            return dat[k].get(x1,x2);\n        }\n        int v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        int v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int r,c,q;\n    while(cin>>r>>c>>q && r){\n        dump(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            int x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        // rep(i,tree.dat.size()){\n        //     dump(tree.dat[i].dat);\n        // }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            // dump(y1,y2,x1,x2);\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = 0; j < Hs; j++){\n\t\t\t\tfor (int k = 0; k < Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t&& w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include\"iostream\"\n#include\"cstring\"\n#include\"string\"\n#include\"cstdio\"\n#include\"algorithm\"\n#include\"cmath\"\n#include\"stack\"\n#include\"queue\"\n#include\"vector\"\n#include\"memory.h\"\n#include\"map\"\n#include\"ctime\"\n#include\"set\"\n#define int_max 0x7fffffff\n#define ll_max 0x7fffffffffffffffLL\n#define fr first \n#define se second\ntypedef long long ll;\ntypedef unsigned long long llu;\nusing namespace std;\nint mp[2000003];\nint rmq_r[2100][1100];\nint rmq_c[2100][1100];\nint N,M,n,m,q;\nint tot,tp;\n/*void rmq_r_init(int row,int l,int r)\n{\n\trmq_r[row][0][1]=rmq_r[row][0][0];\n\tfor(int i=1;i<N;i++)\n\trmq_r[row][i][1]=min(rmq_r[row][i][0],rmq_r[row][i-1][1]);\n\trmq_r[row][N-1][2]=rmq_r[row][N-1][2];\n\tfor(int i=N-2;i>=0;i--)\n\trmq_r[row][i][2]=min(rmq_r[row][i][0],rmq_r[row][i+1][0]);\n}\nvoid rmq_c_init(int row,int l,int r)\n{\n\trmq_c[row][0][1]=rmq_c[row][0][0];\n\tfor(int i=1;i<N;i++)\n\trmq_c[row][i][1]=min(rmq_c[row][i][0],rmq_r[row][i-1][1]);\n\tfor(int i=N-2;i>=0;i--)\n\trmq_c[row][i][0]=min(rmq_c[row][i][0],rmq_r[row][i+1][0]);\n}*/\nint rmq_findr(int row,int l,int r)\n{\n\tint ans=int_max;\n\tfor(int i=l;i<=r;i++)\n\tans=min(ans,rmq_r[row][i]);\n\treturn ans;\n}\nint rmq_findc(int row,int l,int r)\n{\n\tint ans=int_max;\n\tfor(int i=l;i<=r;i++)\n\tans=min(ans,rmq_c[row][i]);\n\t\n\treturn ans;\n}\nint gaor(int x_1,int y_1,int x_2,int y_2)\n{\n\t   \n\t\tint ans=int_max;\n\t\tif(x_1>x_2||y_1>y_2)return ans;\n\t\n\t\tint sx_1=x_1/N,sx_2=x_2/N;\n\t\tint sy_1=y_1/M,sy_2=y_2/M;\n\t\tint x1=x_1%N,x2=x_2%N; \n\t\t//\n\t\tfor(int k=sy_1+1;k<sy_2;k++)\n\t\t{\n\t\t\tans=min(ans,rmq_findr(sx_1*M+k,x1,x2));\n\t\t}\n\t\t//printf(\"%d\\n\",ans);\n\t\tint yy=(sy_1+1)*M;\n\t\t\n\t\tfor(int i=x_1;i<=x_2;i++)\n\t\tfor(int j=y_1;j<yy;j++)\n\t\t{\n\t\t    ans=min(ans,mp[i*tp+j]);\t\n\t\t    ///printf(\"-->%d\\n\",mp[i][j]);\n\t\t}\n\t\tyy=(sy_2)*M;//printf(\"%d\\n\",yy);\n\t\tfor(int i=x_1;i<=x_2;i++)\n\t\tfor(int j=yy;j<=y_2;j++)\n\t\t{\n\t\t    ans=min(ans,mp[i*tp+j]);\t\n\t\t     //printf(\"-->%d\\n\",mp[i][j]);\n\t\t}\n\t\treturn ans;\n}\nint gaoc(int x_1,int y_1,int x_2,int y_2)\n{\n\t    \n\t    int ans=int_max;\n\t    if(x_1>x_2||y_1>y_2)return ans;\n\t\tint sx_1=x_1/N,sx_2=x_2/N;\n\t\tint sy_1=y_1/M,sy_2=y_2/M;\n\t\tint x1=y_1%M,x2=y_2%M;\n\t//\tprintf(\"%d %d %d %d %d %d %d %d\\n\",x_1,y_1,x_2,y_2,x1,x2,N,M);\n\t\tfor(int k=sx_1+1;k<sx_2;k++)\n\t\t{\n\t\t\tfor(int i=0;i<M;i++)\n\t\t//\tprintf(\"%d\\n\",rmq_c[k*M+sy_1][i][0]);\n\t\t\tans=min(ans,rmq_findc(k*M+sy_1,x1,x2));\n\t\t}\n\t//\tprintf(\"%d\\n\",ans);\n\t\tint xx=(sx_1+1)*N;\n\t\tfor(int j=y_1;j<=y_2;j++)\n\t\tfor(int x=x_1;x<xx;x++)\n\t\t{\n\t\t    ans=min(ans,mp[x*tp+j]);\n\t\t//\tprintf(\"-->%d\\n\",mp[x][j]);\t\n\t\t}\n\t\t\n\t\txx=sx_2*N;\n\t\t\n\t\tfor(int j=y_1;j<=y_2;j++)\n\t\tfor(int x=xx;x<=x_2;x++)\n\t\t{\n\t\t    ans=min(ans,mp[x*tp+j]);\n\t\t//\t\tprintf(\"-->%d\\n\",mp[x][j]);\t\n\t\t}\n\t\treturn ans;\n}\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"2.out\",\"w\",stdout);\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d %d\",&n,&m,&q);\n\t\tif(n==0&&m==0&&q==0)break;\n\t\t N=sqrt(n);\n\t\t M=sqrt(m);\n\t\t if(N*N<n)N++;\n\t\t if(M*M<m)M++;\n\t\tint x;\n\t tot=N*N;tp=M*M;\n\t\tfor(int i=0;i<tot*tp;i++)\n\t\tmp[i]=int_max;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\t\t\t    \n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{ \n\t\t\t\tscanf(\"%d\",&mp[i*tp+j]);\t\t\n\t\t\t}\t\t\n\t\t}\t\t\t\t\n\t\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<M;j++)\n\t\t{\t    \n\t\t\tint va=i*M+j,x=i*N,y=j*M;\n\t\t\tfor(int k=0;k<N;k++)rmq_r[va][k]=int_max;\n\t\t\tfor(int k=0;k<M;k++)rmq_c[va][k]=int_max;\t\t\t\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\tfor(int p=0;p<M;p++)\n\t\t\t{\n\t\t\t\trmq_r[va][k]=min(rmq_r[va][k],mp[(x+k)*tp+y+p]);\n\t\t\t\trmq_c[va][p]=min(rmq_c[va][p],mp[(x+k)*tp+y+p]);\n\t\t\t}\n\t\t}\n\n\t\tint x_1,y_1,x_2,y_2;\n\t//\tprintf(\"%d %d\\n\",N,M);\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tscanf(\"%d %d %d %d\",&x_1,&y_1,&x_2,&y_2);\n\t\t\tint ans=int_max;\n\t\t\t\n\t\t\tint sx_1=x_1/N,sx_2=x_2/N;\n\t\t\tint sy_1=y_1/M,sy_2=y_2/M;\n\t\t\t\n\t\t\t\n\t\t\tif(sx_1==sx_2&&sy_1==sy_2)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tfor(int k=x_1;k<=x_2;k++)\n\t\t\t\tfor(int p=y_1;p<=y_2;p++)\n\t\t\t\t{\n\t\t\t\t\tans=min(ans,mp[k*tp+p]);\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t\telse if(sx_1==sx_2)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tprintf(\"%d\\n\",gaor(x_1,y_1,x_2,y_2));\n\t\t\t}\n\t\t\telse if(sy_1==sy_2)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tprintf(\"%d\\n\",gaoc(x_1,y_1,x_2,y_2));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//puts(\"a\");\n\t\t\t\tfor(int i=sx_1+1;i<sx_2;i++)\n\t\t\t\tfor(int j=sy_1+1;j<sy_2;j++)\n\t\t\t\t{\n\t\t\t\t   ans=min(ans,rmq_findr(i*M+j,0,N-1));\n\t\t\t\t}\n\t\t\t\t//puts(\"a\");\n\t\t\t\t//printf(\"%d\\n\",ans);\n\t\t\t\tans=min(ans,gaor(x_1,y_1,(sx_1+1)*N-1,y_2));\n\t\t\t\t\n\t\t\t\tans=min(ans,gaor(sx_2*N,y_1,x_2,y_2));//printf(\"%d\\n\",ans);\n\t\t\t\tans=min(ans,gaoc((sx_1+1)*N,y_1,sx_2*N-1,(sy_1+1)*M-1));\n\t\t\t\tans=min(ans,gaoc((sx_1+1)*N,sy_2*M,sx_2*N-1,y_2));\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t    \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ???????????????\n#include<vector>\n#include<algorithm>\nstd::vector<int> answer;\n// ?????°\nconst int MAX_N = 1000001;\nconst int NIL = -1;\n// ???\nstruct Vertex {int label, x, y;};\nstruct Node {int left_child, right_child;};\n// ?????°\nint root;\nNode node[MAX_N];\nVertex vertex[MAX_N];\n// ?????????\nclass Compare {\npublic:\n  Compare(int d) : d(d) {}\n  bool operator()(const Vertex& lhs, const Vertex& rhs) const {return d & 1 ? lhs.y < rhs.y : lhs.x < rhs.x;}\nprivate:\n  int d;\n};\n// ?§????\nint build(int low, int high, int depth) {\n  if(!(low < high)) return NIL;\n  std::sort(vertex + low, vertex + high, Compare(depth));\n  int middle = (low + high) / 2;\n  node[middle].left_child = build(low, middle, depth ^ 1);\n  node[middle].right_child = build(middle + 1, high, depth ^ 1);\n  return middle;\n}\n// ?????¢?????????????????°?????????????????°??¨???????????¢???????????§?¨????????????§?¨??????????\nvoid search(int index, int sx, int sy, int tx, int ty, int depth) {\n  if(index == NIL) return;\n  if(sx <= vertex[index].x && vertex[index].x <= tx && sy <= vertex[index].y && vertex[index].y <= ty) answer.push_back(vertex[index].label);\n  if(depth & 1) {\n    if(sy <= vertex[index].y) search(node[index].left_child, sx, sy, tx, ty, depth ^ 1);\n    if(vertex[index].y <= ty) search(node[index].right_child, sx, sy, tx, ty, depth ^ 1);\n  } else {\n    if(sx <= vertex[index].x) search(node[index].left_child, sx, sy, tx, ty, depth ^ 1);\n    if(vertex[index].x <= tx) search(node[index].right_child, sx, sy, tx, ty, depth ^ 1);\n  }\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    int size = 0;\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      vertex[size++] = {grid, x, y};\n    }\n    root = build(0, size, 0);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      answer.clear();\n      search(root, c1, r1, c2, r2, 0);\n      cout << *min_element(begin(answer), end(answer)) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(sqrt(r));\n    int cs=sqrt(sqrt(c));\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&i/rs*rs+rs<=b+1&&j%cs==0&&j+cs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int grid[N];\n  int rmq[N];\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    int bs_r = (int)sqrt(r), bs_c = (int)sqrt(c);\n    int bn_r = r/bs_r, bn_c = c/bs_c;\n    if(r%bs_r)bn_r++;\n    if(c%bs_c)bn_c++;\n \n    for(int i=0;i<bn_r;i++){\n      for(int j=0;j<bn_c;j++)rmq[i*bn_c + j] = (1<<31) -1;\n    }\n    \n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c + j];\n\tif(rmq[(i/bs_r) * bn_c + (j/bs_c)] > grid[i*c + j])rmq[(i/bs_r) * bn_c + (j/bs_c)] = grid[i*c + j];\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ans = (1<<31) -1;\n\n      int sr = r1/bs_r;\n      int sc = c1/bs_c;\n      int gr = r2/bs_r;\n      int gc = c2/bs_c;\n\n      if(sr == gr || sc == gc){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    if(ans > grid[i*c+j])ans = grid[i*c+j];\n\t  }\n\t}\n      }else{\n\tif(r1%bs_r){\n\t  sr++;\n\t  for(int i=r1;i<sr*bs_r;i++){\n\t    for(int j=c1;j<=c2;j++){\n\t      if(ans > grid[i*c+j])ans = grid[i*c+j];\n\t    }\n\t  }\n\t}\n\t\n\t\n\tif(c1%bs_c){\n\t  sc++;\n\t  for(int i=r1;i<=r2;i++){\n\t    for(int j=c1;j<sc*bs_c;j++){\n\t      if(ans > grid[i*c+j])ans = grid[i*c+j];\n\t    }\n\t  }\n\t}\n\n\tif( (r2+1)%bs_r){\n\t  for(int i=gr*bs_r;i<=r2;i++){\n\t    for(int j=c1;j<=c2;j++){\n\t      if(ans > grid[i*c+j])ans = grid[i*c+j];\n\t    }\n\t  }\n\t  gr--;\n\t}\n  \n\tif( (c2+1)%bs_c){\n\t  for(int i=r1;i<=r2;i++){\n\t    for(int j=gc*bs_c;j<=c2;j++){\n\t      if(ans > grid[i*c+j])ans = grid[i*c+j];\n\t    }\n\t  }\n\t  gc--;\n\t}\n\t\n\tfor(int i=sr;i<=gr;i++){\n\t  for(int j=sc;j<=gc;j++){\n\t    if(ans > rmq[i*bn_c+j])ans = rmq[i*bn_c+j];\n\t  }\n\t}\n      }\n      \n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define ALL(c) c.begin(),c.end()\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n// #define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range{\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//input\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,pair<T1,T2>& p){return is>>p.first>>p.second;}\ntemplate<typename T1> istream& operator >> (istream& is,tuple<T1>& t){return is >> get<0>(t);}\ntemplate<typename T1,typename T2> istream& operator >> (istream& is,tuple<T1,T2>& t){return is >> get<0>(t) >> get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> istream& operator >> (istream& is,tuple<T1,T2,T3>& t){return is >>get<0>(t)>>get<1>(t)>>get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> istream& operator >> (istream& is,tuple<T1,T2,T3,T4>& t){return is >> get<0>(t)>>get<1>(t)>>get<2>(t)>>get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> istream& operator >> (istream& is, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return is >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t) >> get<5>(t) >> get<6>(t);}\ntemplate<typename T> istream& operator >> (istream& is,vector<T>& as){for(int i:range(as.size()))is >>as[i];return is;}\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){return os<<p.first<<\" \"<<p.second;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){return os << get<0>(t);}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){return os << get<0>(t)<<\" \"<<get<1>(t);}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){return os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){for(int i:range(as.size())){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){for(int i:range(as.size())){if(i!=0)os<<endl; os<<as[i];}return os;}\n\n// values\ntemplate<typename T> inline T INF(){assert(false);};\ntemplate<> inline int INF<int>(){return 1<<28;};\ntemplate<> inline ll INF<ll>(){return 1LL<<58;};\ntemplate<> inline double INF<double>(){return 1e16;};\ntemplate<> inline long double INF<long double>(){return 1e16;};\n\ntemplate<class T> inline T EPS(){assert(false);};\ntemplate<> inline int EPS<int>(){return 1;};\ntemplate<> inline ll EPS<ll>(){return 1LL;};\ntemplate<> inline double EPS<double>(){return 1e-8;};\ntemplate<> inline long double EPS<long double>(){return 1e-8;};\n\n// min{2^r | n < 2^r}\ntemplate<typename T> T upper_pow2(T n){\n\tT res=1;while(res<n)res<<=1;return res;\n}\n// max{d | 2^d  <= n}\ntemplate<typename T> T msb(T n){\n\tint d=30;while((1<<d)>n)d--;return d;\n}\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntemplate<typename T> class Monoid{\npublic:\n\tvirtual T e()=0,c(T,T)=0;\n};\ntemplate<typename T> class MinMonoid:public Monoid<T>{\npublic:\n\tT e(){return INF<T>();}\n\tT c(T a,T b){return min(a,b);}\n\tstatic MinMonoid<T>& i(){static MinMonoid<T> i;return i;}\n};\n\ntemplate<typename T> class SegmentTree{\npublic:\n\tconst int size,n2;vector<T> dat;Monoid<T>& m;\n\tSegmentTree(int n,Monoid<T>& m):size(n),n2(upper_pow2(size)),m(m){\n\t\tdat=vector<T>(n2*2,m.e());\n\t}\n\tinline T get(int v){return dat[v+n2];}\n\tvoid set(int v,T a){\n\t\tv+=n2;dat[v]=a;\n\t\twhile(v!=1){\n\t\t\tint parent=v/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent]=m.c(dat[chl],dat[chr]);\n\t\t}\n\t}\n\tT query(int a,int b){return query(a,b,1,0,n2);} //[a,b)\nprivate:\n\tT query(int a,int b,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=a || b<=l)return m.e();//out of range\n\t\tif(a<=l && r<=b)return dat[v];\n\t\tT lv=query(a,b,v*2,l,(l+r)/2),rv=query(a,b,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\ntemplate<typename T> class SegmentTree2D{\npublic:\n\tconst int H,W,H2,W2;vector<SegmentTree<T>> dat;Monoid<T>& m;\n\tSegmentTree2D(int H,int W,Monoid<T>& m):H(H),W(W),H2(upper_pow2(H)),W2(upper_pow2(W)),m(m){\n\t\tdat=vector<SegmentTree<T>>(H2*2,SegmentTree<T>(W,m));\n\t}\n\tinline T get(int y,int x){return dat[y+H2].get(x);}\n\tvoid set(int y,int x,T a){\n\t\ty+=H2;dat[y].set(x,a);\n\t\twhile(y!=1){\n\t\t\tint parent=y/=2,chl=parent*2,chr=parent*2+1;\n\t\t\tdat[parent].set(x,m.c(dat[chl].get(x),dat[chr].get(x)));\n\t\t}\n\t}\n\tT query(int yl,int yr,int xl,int xr){return query(yl,yr,xl,xr,1,0,H2);} //[a,b)\nprivate:\n\tT query(int yl,int yr,int xl,int xr,int v,int l,int r){ //[a,b) on v:[l,r)\n\t\tif(r<=yl || yr<=l)return m.e();//out of range\n\t\tif(yl<=l && r<=yr)return dat[v].query(xl,xr);\n\t\tT lv=query(yl,yr,xl,xr,v*2,l,(l+r)/2),rv=query(yl,yr,xl,xr,v*2+1,(l+r)/2,r);\n\t\treturn m.c(lv,rv);\n\t}\n};\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\twhile(true){\n\t\t\tint r,c,q;cin >>r >> c >> q;\n\t\t\tif(r==0 && c ==0 && q == 0)break;\n\t\t\tSegmentTree2D<int> seg(r,c,MinMonoid<int>::i());\n\t\t\tvector<vector<int>> board(r,vector<int>(c));\n\t\t\tREP(y,r)REP(x,c){\n\t\t\t\tint v;cin >> v;\n\t\t\t\tseg.set(y,x,v);\n\t\t\t\tboard[y][x]=v;\n\t\t\t}\n\t\t\tREP(_q,q){\n\t\t\t\tint r1,c1,r2,c2;cin >> r1>> c1 >> r2>> c2;r2++;c2++;\n\t\t\t\tcout << seg.query(r1,r2,c1,c2) <<endl;\n\t\t\t}\n\t\t\t// REP(r1,r)for(int r2:range(r1+1,r+1))REP(c1,c)for(int c2:range(c1+1,c+1)){\n\t\t\t// \tint v=seg.query(r1,r2,c1, c2);\n\n\t\t\t// \tint mv=MinMonoid<int>::i().e();\n\t\t\t// \tfor(int y:range(r1,r2))for(int x:range(c1,c2))mv=min(mv,board[y][x]);\n\t\t\t// \tif(mv!=v){\n\t\t\t// \t\tcerr << make_tuple(r1,r2,c1,c2)<<endl;\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct Pool {\n    static dat_t dat[250000*3];\n    static int end;\n    static dat_t * fetch(int size){\n        dat_t * res = dat + end;\n        end+=size;\n        return res;\n    }\n    static void reset(){\n        end = 0;\n    }\n};\n\nint Pool::end = 0;\ndat_t Pool::dat[250000*3];\n\nPool pool;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = pool.fetch(n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = pool.fetch(n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXN = 1000000 + 10;\n\nint n, m, num1[MAXN], num2[MAXN], st1[MAXN][20], st2[MAXN][20];\n\nint min(int num[], int p1, int p2) {\n    return num[p1] < num[p2] ? p1 : p2;\n}\n\nvoid init(int num[], int st[][20], int n) {\n    REP(i, n)\n        st[i][0] = i;\n    for (int j = 1; (1 << j) <= n; ++j)\n        for (int i = 0; i + (1 << j) - 1 < n; ++i)\n            st[i][j] = min(num, st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n}\n\nint rmq(int num[], int st[][20], int i, int j) {\n    int k = (int)log2(j - i + 1);\n    return num[min(num, st[i][k], st[j - (1 << k) + 1][k])];\n}\n\nint main() {\n    int q;\n    while (scanf(\"%d%d%d\", &n, &m, &q) == 3 && n + m + q) {\n        REP(i, n) {\n            REP(j, m) {\n                int pos1 = i * m + j,\n                    pos2 = j * n + i;\n                //out(pos1);\n                scanf(\"%d\", num1 + pos1);\n                num2[pos2] = num1[pos1];\n            }\n        }\n        if (q < 10) {\n            REP(qq, q) {\n                //out(i);\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                for (int i = l1; i <= r1; ++i) {\n                    for (int j = l2; j <= r2; ++j) {\n                        int pos = i * m + j;\n                        //out(pos);\n                        checkmin(ans, num1[pos]);\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        } else {\n            init(num1, st1, n * m);\n            init(num2, st2, n * m);\n            REP(qq, q) {\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                if (r2 - l2 > r1 - l1) {\n                    for (int i = l1; i <= r1; ++i) {\n                        int pos1 = i * m + l2, pos2 = i * m + r2;\n                        checkmin(ans, rmq(num1, st1, pos1, pos2));\n                    }\n                } else {\n                    for (int i = l2; i <= r2; ++i) {\n                        int pos1 = i * n + l1, pos2 = i * n + r1;\n                        checkmin(ans, rmq(num2, st2, pos1, pos2));\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = INT_MAX;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nint data[2 * 2 * 2 * 1010000];\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[1000100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return 0;\n\tif(c<=a&&b<=d)return segtree[f][e-1];\n\treturn max(query(a,(a+b)/2,c,d,e*2,f),query((a+b)/2+1,b,c,d,e*2+1,f));\n}\nint query2(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query2(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query2(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query2(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query2((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\tb+=m;\n\t//while(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d-1]=max(segtree[a][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t//\ta/=2;\n\t//}\n}\nvoid update2(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tif((n+a-1)*(b+m-1)>6500000){\n\t\t\tsegtree=new int*[a];\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tint ret=0;\n\t\t\t\tfor(int j=p;j<=r;j++)ret=max(ret,query(0,m-1,q,s,1,j));\n\t\t\t\tprintf(\"%d\\n\",2147483647-ret);\n\t\t\t}\n\t\t\tfor(int i=0;i<a;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}else{\n\t\t\tsegtree=new int*[n+a-1];\n\t\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t\t}\n\t\t//  segtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\t\tint d;scanf(\"%d\",&d);\n\t\t\t\tupdate2(i,j,2147483647-d);\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint p,q,r,s;\n\t\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\t\tprintf(\"%d\\n\",2147483647-query2(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t\t}\n\t\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\t\tdelete[] segtree;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q, a;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < seg.size(); i++) vector<int>().swap(seg[i]);\n\t\tvector<vector<int> >().swap(seg);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int inf = (((1 << 30) - 1) << 1) + 1;\n\nstruct segtree1 {\n\n\tint *dat;\n\t\n\tvoid init(int *raw, int s)\n\t{\n\t\tdat = raw;\n\t\n\t\tfor(int i = 0; i < s * 2; ++i)\n\t\t\tdat[i] = inf;\n\t}\n\t\n\tvoid set(int x, int v, int s)\n\t{\n\t\tint pos = s + x;\n\t\t\n\t\tdat[pos] = v;\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos] = min(dat[pos * 2 + 0], dat[pos * 2 + 1]);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tvoid setmin(int x, int v, int s)\n\t{\n\t\tint pos = s + x;\n\t\tif(dat[pos] > v)\n\t\t\tset(x, v, s);\n\t}\n\t\n\tint getmin(int a, int b, int l, int r, int idx)\n\t{\n\t\tif(b <= l || r <= a) return inf;\n\t\t\n\t\tif(a <= l && r <= b) {\n\t\t\n\t\t\treturn dat[idx];\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(a, b, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(a, b, m, r, idx * 2 + 1));\n\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int a, int b, int s)\n\t{\n\t\treturn getmin(a, b, 0, s, 1);\n\t}\n};\n\nstruct segtree2 {\n\t\n\tvector<segtree1> dat;\n\tvector<int> raw;\n\tint w, h;\n\t\n\tvoid init(int width, int height)\n\t{\n\t\tw = 1;\n\t\twhile(w < width) w *= 2;\n\t\t\n\t\th = 1;\n\t\twhile(h < height) h *= 2;\n\t\t\n\t\tdat.resize(h * 2);\n\t\traw.resize((h * 2) * (w * 2));\n\t\tfor(int i = 0; i < h * 2; ++i)\n\t\t\tdat[i].init(&raw[i * (w * 2)], w);\n\t}\n\t\n\tvoid set(int x, int y, int v)\n\t{\n\t\tint pos = h + y;\n\t\t\n\t\tdat[pos].set(x, v, w);\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos].setmin(x, v, w);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by, int l, int r, int idx)\n\t{\n\t\tif(by <= l || r <= ay) return inf;\n\t\t\n\t\tif(ay <= l && r <= by) {\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, dat[idx].getmin(ax, bx));\n\t\t\treturn dat[idx].getmin(ax, bx, w);\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, m, r, idx * 2 + 1));\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by)\n\t{\n\t\treturn getmin(ax, ay, bx, by, 0, h, 1);\n\t}\n};\n\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint r, c, q;\n\t\tsegtree2 st;\n\t\t\n\t\tscanf(\"%d%d%d\", &r, &c, &q);\n\t\t\n\t\tif(r == 0 && c == 0 && q == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tst.init(r, c);\n\t\t\n\t\tfor(int x = 0; x < r; ++x) {\n\t\t\tfor(int y = 0; y < c; ++y) {\n\t\t\t\n\t\t\t\tint v;\n\t\t\t\t\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\t\n\t\t\t\tst.set(x, y, v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\n\t\t\tint r1, c1, r2, c2;\n\t\t\t\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\t\n\t\t\tint ans = st.getmin(r1, c1, r2 + 1, c2 + 1);\n\t\t\t\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n\tint Need(int size){\n\t\tsize--;\n\t\trep(i,5) size|=size>>(1<<i);\n\t\treturn size+1;\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid;\n\t\tif(r<=c){\n\t\t\tgrid.assign(r,vi(c));\n\t\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t}\n\t\telse{\n\t\t\tgrid.assign(c,vi(r));\n\t\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[j][i]);\n\t\t}\n\t\t\n\t\tvector<SegTree> sts;\n\t\tif(r<=c){\n\t\t\tsts.assign(r,SegTree(c));\n\t\t\trep(i,r) rep(j,c) sts[i].Update(j,grid[i][j]);\n\t\t}\n\t\telse{\n\t\t\tsts.assign(c,SegTree(r));\n\t\t\trep(i,c) rep(j,r) sts[i].Update(j,grid[i][j]);\n\t\t}\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tint res=INFTY;\n\t\t\tif(r<=c)\n\t\t\t\trepi(i,r1,r2+1) res=min(res,sts[i].Query(c1,c2+1));\n\t\t\telse\n\t\t\t\trepi(i,c1,c2+1) res=min(res,sts[i].Query(r1,r2+1));\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = new dat_t[k*2];\n        fill(dat, dat+k*2, inf);\n    }\n    ~SegTree(){\n        delete [] dat;\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        this->dat = new dat_t[s.n*2];\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        bool swaped = false;\n        if(r>c){\n            swap(r,c);\n            swaped = true;\n        }\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            if(swaped) tree.set(i,j,x);\n            else tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            // dump(tree.dat[i].dat);\n            dump(vector<dat_t>(tree.dat[i].dat, tree.dat[i].dat+tree.dat[i].n*2));\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            if(swaped){\n                swap(x1,y1); swap(x2,y2);\n            }\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nint dat[2*MAX_N-1];\nint h,w;\nconst int INF=INT_MAX;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    // Å¬lðÔ·\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst long long int INF=1000000000000;\nvector<vector<long long int> > dc;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<long long int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nlong long int query(vector<long long int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tlong long int vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tlong long int vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tc2=init(c)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tlong long int res=INF;\n\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n        \n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        int** grid;\n        grid = new int*[H];\n        \n        for (int i = 0; i < H; i++) {\n            grid[i] = new int[W];\n            for (int j = 0; j < W; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            int res = INT_MAX;\n            for (int j = x1; j <= x2; j++) {\n                for (int k = y1; k <= y2; k++) {\n                    res = std::min(res, grid[k][j]);\n                }\n            }\n            std::cout << res << std::endl;\n        }\n\n        delete[] grid;\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst long long int INF=1000000000000;\nvector<vector<long long int> > dc,dr;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<long long int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nlong long int query(vector<long long int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tlong long int vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tlong long int vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tdr.resize(c);\n\t\tc2=init(c)*2;\n\t\tr2=init(r)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tdr[i].resize(r2);\n\t\t\tfill(dr[i].begin(),dr[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t\tupdate(dr[j],i,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tlong long int res=INF;\n\t\t\tif(y2-y<=x2-x){\n\t\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x;i<=x2;i++){\n\t\t\t\t\tres=min(res,query(dr[i],x,x2+1,0,0,dr[i].size()/2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = ((int)sqrt(H)) + 1;\n\t\tint Ws = ((int)sqrt(W)) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = h1 / Hs; j <= h2 / Hs; j++){\n\t\t\t\tfor (int k = w1 / Ws; k <= w2 / Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2 && w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct SegTree {\n\tint segSize;\n\tint seg[1 << 11];\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tfill(&seg[0], &seg[0]+segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (1) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t\tif (!n) break;\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntypedef int type;\nconst type INIT = INT_MAX;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q, r;) {\n\t\tbool is_row = (r <= c);\n\t\tvector<segment_tree> seg(min(r, c), segment_tree(max(r, c)));\n\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\ttype in;\n\t\t\t\tcin >> in;\n\n\t\t\t\tif(is_row) seg[i].update(j, in);\n\t\t\t\telse seg[j].update(i, in);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint start, end, a, b;\n\t\t\tif(is_row) cin >> start >> a >> end >> b;\n\t\t\telse cin >> a >> start >> b >> end;\n\t\t\t++b;\n\n\t\t\ttype ans = INIT;\n\t\t\tfor(int j = start; j <= end; ++j) {\n\t\t\t\tchmin(ans, seg[j].query(a, b));\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint abs(int a,int b){\n\n  int result;\n\n  if(a<b)\n    result=b-a;\n  else\n    result=a-b;\n  return result;\n};\n\nint main(void){\n\n  int n;\n  int min=1000000;\n  int  temp;\n  \n  while(cin >> n,n!=0){\n\n      vector <int> student(n);\n    \n    for(int i=0;i<n;i++){\n      cin >> student[i];\n    }\n\n    sort(student.begin(),student.end(),greater<int>());\n\n    for(int i=0;i<n;i++){\n      \n      temp=abs(student[i],student[i+1]);\n      //cout << temp <<endl;\n\n      if(min>temp)\n\tmin=temp;\n    }\n\n    cout << min <<endl;\n\n    student.clear();\n    min=1000000;\n\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = INT_MAX;\n\ntypedef vector<vector<int> > matrix;\nmatrix dat;\nint R, C;\n\nvoid update(int r, int c, int a) {\n  bool f = 0;\n  if (r==0&&c==1) f = 1;\n  r += R - 1;\n  c += C - 1;\n  dat[r][c] = a;\n  int cc = c;\n  while(cc > 0) {\n    cc = (cc-1) / 2;\n    dat[r][cc] = min(dat[r][cc*2+1], dat[r][cc*2+2]);\n    if (f) {\n//      printf(\"(%d,%d) %d\\n\", r,cc,dat[r][cc]);\n    }\n  }\n  while(r > 0) {\n    r = (r-1) / 2;\n    cc = c;\n    while(1) {\n      dat[r][cc] = min(dat[r*2+1][cc], dat[r*2+2][cc]);\n      if (cc == 0) break;\n      cc = (cc-1) / 2;\n      if (f) {\n//        printf(\"(%d,%d) %d\\n\", r,cc,dat[r][cc]);\n      }\n\n    }\n  }\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr) {\n  if (rr<=r1 || r2<=rl || cr<=c1 || c2<=cl) return INF;\n//  printf(\"(%d,%d)(%d,%d)  (%d,%d)\\n\", rl,cl,rr,cr,r,c);\n  if (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) {\n//    cout << \"HOGE\" << \" \" << dat[r][c]<< endl;\n    return dat[r][c];\n  }\n  if (r1 <= rl && rr <= r2) {   // cðª\n    int v1 = query(r1,c1,r2,c2,r,rl,rr,c*2+1,cl,(cl+cr)/2);\n    int v2 = query(r1,c1,r2,c2,r,rl,rr,c*2+2,(cl+cr)/2, cr);\n    return min(v1,v2);\n  } else {                      // ¡ðª\n    int v1 = query(r1,c1,r2,c2,r*2+1,rl,(rl+rr)/2,c,cl,cr);\n    int v2 = query(r1,c1,r2,c2,r*2+2,(rl+rr)/2,rr,c,cl,cr);\n    return min(v1,v2);\n  }\n}\nint main() {\n  int q;\n  while(cin >>R>>C>>q, R||C||q) {\n    int RR = R, CC = C;\n    R = 1; C = 1;\n    while(R < RR) R *= 2;\n    while(C < CC) C *= 2;\n    dat.assign(2*R-1, vector<int>(2*C-1, INF));\n    REP(i,RR) REP(j,CC) {\n      int a;\n      cin >> a;\n      update(i,j,a);\n    }\n    REP(i,q) {\n      int r1,c1,r2,c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << query(r1,c1,r2+1,c2+1,0,0,R,0,0,C) << endl;\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int** dat;\n    \n    RMQ2D(int h, int w, std::vector<std::vector<int>>& grid)\n    {\n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        dat = new int*[2 * H - 1];\n        for (int i = 0; i < 2 * H - 1; i++) {\n            dat[i] = new int[2 * W - 1];\n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[i][j] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[i + H - 1][j + W - 1] = grid[i][j]; \n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[i][j] = std::min(dat[i][j * 2 + 1], dat[i][j * 2 + 2]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[j][i] = std::min(dat[j * 2 + 1][i], dat[j * 2 + 2][i]);\n            }\n        }\n    }\n\n    ~RMQ2D() {\n        delete[] dat;\n    }\n    \n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[j][k];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return std::min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        std::vector<std::vector<int>> grid(H, std::vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n        RMQ2D r(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            std::cout << r.query(y1, x1, y2, x2) << std::endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<climits>\n#include<algorithm>\n//\nconst int NIL = -1;\nconst int INF = INT_MAX;\n// const int INF = 9;\n//\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int query(int x1, int y1, int x2, int y2) const;\nprivate:\n  int parent(int index) const;\n  int lower(int index) const;\n  int higher(int index) const;\n  int query(int x1, int y1, int x2, int y2, int x, int y, int low_x, int low_y, int high_x, int high_y) const;\n  int x_, y_;\n  int x_size_, y_size_;\n  std::vector<std::vector<int>> node_;\n};\n//\nSegmentTree::SegmentTree(int x, int y) : x_(x), y_(y) {\n  x_size_ = y_size_ = 1;\n  while(x_size_ < x_) x_size_ <<= 1;\n  while(y_size_ < y_) y_size_ <<= 1;\n  node_.assign((x_size_ << 1) - 1, std::vector<int>((y_size_ << 1) - 1, INF));\n}\nvoid SegmentTree::update(int x, int y, int value) {\n  x = x_size_ + x - 1;\n  y = y_size_ + y - 1;\n  node_[x][y] = value;\n  while((x = parent(x)) != NIL && (y = parent(y)) != NIL) {\n    node_[x][y] = std::min({node_[x][y], node_[lower(x)][lower(y)], node_[lower(x)][higher(y)], node_[higher(x)][lower(y)], node_[higher(x)][higher(y)]});\n  }\n//   for(int px = parent(x); px != NIL; px = parent(px)) {\n//     for(int py = parent(y); py != NIL; py = parent(py)) {\n//       node_[px][py] = std::min({node_[lower(px)][lower(py)], node_[lower(px)][higher(py)], node_[higher(px)][lower(py)], node_[higher(px)][higher(py)]});\n//     }\n//   }\n}\nint SegmentTree::parent(int index) const {return index == 0 ? NIL : (index - 1) >> 1;}\nint SegmentTree::lower(int index) const {return (index << 1) + 1;}\nint SegmentTree::higher(int index) const {return (index << 1) + 2;}\n\nint SegmentTree::query(int x1, int y1, int x2, int y2) const {\n//   for(auto n: node_) {\n//     for(auto i: n) cout<<\" \"<<i;\n//     cout<<endl;\n//   }\n  return query(x1, y1, x2, y2, 0, 0, 0, 0, x_size_ - 1, y_size_ - 1);\n}\nint SegmentTree::query(int x1, int y1, int x2, int y2, int x, int y, int low_x, int low_y, int high_x, int high_y) const {\n  if(high_x < x1 || x2 < low_x || high_y < y1 || y2 < low_y) return INF;\n  if(x1 <= low_x && high_x <= x2 && y1 <= low_y && high_y <= y2) return node_[x][y];\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  int ll = query(x1, y1, x2, y2, lower(x), lower(y), low_x, low_y, middle_x, middle_y);\n  int lh = query(x1, y1, x2, y2, lower(x), higher(y), low_x, middle_y + 1, middle_x, high_y);\n  int hl = query(x1, y1, x2, y2, higher(x), lower(y), middle_x + 1, low_y, high_x, middle_y);\n  int hh = query(x1, y1, x2, y2, higher(x), higher(y), middle_x + 1, middle_y + 1, high_x, high_y);\n  return std::min({ll, lh, hl, hh});\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n//     SegmentTree tree(c, r);\n    SegmentTree tree(max(c, r), max(c, r));\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(const int x, const int value) {\n    data[x] = value;\n    const int k = x / SQRT_N;\n    stat[k] = min(stat[k], data[x]);\n  }\n  int query(const int a, const int b) {\n    int ret = INF;\n    for(int k = a / SQRT_N; k < (b + SQRT_N - 1) / SQRT_N; ++k) {\n      const int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = y1 / SQRT_N; k < (y2 + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define N 1000000\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint grid[N];\nvector<int> seg[1000];\n\nvoid init(int num,int n_){\n  for(int i=0;i<2*n_-1;i++)seg[num].push_back( (1<<31)-1 );\n}\n\nvoid update(int x,int k, int a){\n  k += n-1;\n  seg[x][k] = a;\n\n  while(k>0){\n    k = (k-1) / 2;\n    seg[x][k] = min(seg[x][k*2+1], seg[x][k*2+2]);\n  }\n}\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c+j];\n\t\n      }\n    }\n\n    if(r>c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++)init(i,n);\n      for(int i=0;i<c;i++){\n\tfor(int j=0;j<r;j++){\n\t  update(i,j,grid[j*c+i]);\n\t}\n      }\n\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\n\tfor(int i=c1;i<=c2;i++){\n\t  ans = min(ans,query(i,r1,r2+1,0,0,n+1));\n\t}\n\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  update(i,j,grid[i*c+j]);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\n\tfor(int i=r1;i<=r2;i++){\n\t  ans = min(ans,query(i,c1,c2+1,0,0,n+1));\n\t}\n\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n;\nint r,c,q;\nint r1,c1,r2,c2;\nint tmp;\nvector<int> seg[1000];\n\nvoid init(int num,int n_){\n  for(int i=0;i<2*n_-1;i++)seg[num].push_back( (1<<31)-1 );\n}\n\nvoid update(int x,int k, int a){\n  k += n-1;\n  seg[x][k] = a;\n  while(k>0){\n    k = (k-1) / 2;\n    seg[x][k] = min(seg[x][k*2+1], seg[x][k*2+2]);\n  }\n}\n\nint query(int x, int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return (1<<31) - 1;\n  if(a<=l && r<=b)return seg[x][k];\n  else{\n    return min(query(x,a,b,2*k+1,l,(l+r)/2),query(x,a,b,2*k+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(r>=c){\n      n = 1;\n      while(n<r)n *= 2;\n      for(int i=0;i<c;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(j,i,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=c1;i<=c2;i++)ans = min(ans,query(i,r1,r2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }else{\n      n = 1;\n      while(n<c)n *= 2;\n      for(int i=0;i<r;i++)init(i,n);\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> tmp;\n\t  update(i,j,tmp);\n\t}\n      }\n      while(q--){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tint ans = (1<<31) - 1;\n\tfor(int i=r1;i<=r2;i++)ans = min(ans,query(i,c1,c2+1,0,0,n));\n\tcout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0x7ffffff;\n\nint W, H, WW, HH, seg_H, seg_W;\nvector< vector<int> > data;\nvector< vector<int> > seg_tree;\n\n//y in [0, H)\nvoid initialize_W(int y, int cur_node, int lx, int rx){\n\tif(rx - lx <= 1){\n\t\tif(y < H){\n\t\t\tseg_tree[y + HH - 1][cur_node] = data[y][lx];\n\t\t}\n\t\treturn ;\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\n\tinitialize_W(y, 2*cur_node + 1, lx, mid);\n\tinitialize_W(y, 2*cur_node + 2, mid, rx);\n\n\tseg_tree[y + HH - 1][cur_node] = min(seg_tree[y + HH - 1][2*cur_node + 1], seg_tree[y + HH - 1][2*cur_node + 2]);\n}\n\nint query_W(int node_y, int fx, int tx, int cur_node, int lx, int rx){\n\tif( rx <= fx || tx <= lx ){\n\t\treturn INF;\n\t}\n\n\tif( fx <= lx && rx <= tx ){\n\t\treturn seg_tree[node_y][cur_node];\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\treturn min(query_W(node_y, fx, tx, cur_node*2 + 1, lx, mid),\n\t\t\tquery_W(node_y, fx, tx, cur_node*2 + 2, mid, rx));\n}\n\nvoid initialize_H(int cur_node, int ly, int ry){\n\tif(ry - ly <= 1){\n\t\tinitialize_W(ly, 0, 0, WW);\n\t\treturn ;\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\n\tinitialize_H(2*cur_node + 1, ly, mid);\n\tinitialize_H(2*cur_node + 2, mid, ry);\n\n\tfor(int j=0; j<seg_W; j++){\n\t\tseg_tree[cur_node][j] = min(seg_tree[2*cur_node + 1][j], seg_tree[2*cur_node + 2][j]);\n\t}\n}\n\nint query_H(int fy, int ty, int fx, int tx, int cur_node, int ly, int ry){\n\tif( ry <= fy || ty <= ly ){\n\t\treturn INF;\n\t}\n\n\tif( fy <= ly && ry <= ty ){\n\t\treturn query_W(cur_node, fx, tx, 0, 0, WW);\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\treturn min(query_H(fy, ty, fx, tx, cur_node*2 + 1, ly, mid),\n\t\t\tquery_H(fy, ty, fx, tx, cur_node*2 + 2, mid, ry));\n}\n\n// [y1, y2) * [x1, x2)\nint query_segtree(int y1, int x1, int y2, int x2){\n\treturn query_H(y1, y2, x1, x2, 0, 0, HH);\n}\n\nvoid build_segtree(){\n\tconst int log_H = H == 1 ? 0 : 31 - __builtin_clz(H-1), log_W = W == 1 ? 0 :31 - __builtin_clz(W-1);\n\tHH = 1<<(log_H+1);\n\tWW = 1<<(log_W+1);\n\tseg_H = 2*HH - 1;\n\tseg_W = 2*WW - 1;\n\n\tseg_tree.clear();\n\tseg_tree = vector< vector<int> >(seg_H, vector<int>(seg_W, INF));\n\n\tinitialize_H(0, 0, HH);\n}\n\nint main(){\n\tint Q;\n\twhile(scanf(\"%d%d%d\",&H,&W,&Q), H){\n\t\tconst int log_H = 31 - __builtin_clz(H), log_W = 31 - __builtin_clz(W);\n\t\tdata.clear();\n\t\tseg_tree.clear();\n\n\t\tdata = vector< vector<int> >(H, vector<int>(W));\n\n\t\tfor(int i=0; i<H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tscanf(\"%d\", &data[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tbuild_segtree();\n\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d%d%d%d\",&y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query_segtree(y1, x1, y2+1, x2+1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF ((int)1e9 + 9)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct segtree{\n\tint SIZE;\n\tvector<int> minimum, lazy;\n\n\tsegtree(int n){\n\t\tSIZE = 1;\n\t\twhile(SIZE < n) SIZE *= 2;\n\n\t\tminimum.clear();\n\t\tminimum.resize(SIZE * 2, 0);\n\t\tlazy.clear();\n\t\tlazy.resize(SIZE * 2, 0);\n\t};\n\n\tvoid lazy_evaluate(int k){\n\t\tminimum[k] += lazy[k];\n\n\t\tif (k < SIZE - 1){ // k isn't leaf of SegmentTree\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t} // end if\n\t\tlazy[k] = 0;\n\t} // end function\n\n\tvoid update(int a, int b, int k, int l, int r, int x){\n\t\tif (r <= a || b <= l) return;\n\n\t\tif (a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazy_evaluate(k);\n\t\t}else{\n\t\t\tlazy_evaluate(k);\n\t\t\tupdate(a, b, k * 2 + 1, l, (l + r) / 2, x);\n\t\t\tupdate(a, b, k * 2 + 2, (l + r) / 2, r, x);\n\t\t\tminimum[k] = min(minimum[k * 2 + 1], minimum[k * 2 + 2]);\n\t\t\treturn;\n\t\t} // end if\n\t} // end function \n\n\tint query2D(int r1, int c1, int r2, int c2, int C){\n\t\tint res = INF;\n\t\tfor (int r = r1; r <= r2; ++r){\n\t\t\tint curr = query(r * C + c1, r * C + c2 + 1, 0, 0, SIZE);\n\t\t\tres = min(res, curr);\n\t\t} // end for\n\t\treturn res;\n\t} // end function \n\n\tint query(int a, int b, int k, int l, int r){\n\t\tlazy_evaluate(k);\n\t\tif (r <= a || b <= l) return INF;\n\t\tif (a <= l && r <= b) return minimum[k];\n\t\telse{\n\t\t\tint lch = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint rch = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\t\treturn min(lch, rch);\n\t\t} // end if\n\t} // end function\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint R, C, Q;\n\twhile(cin >> R >> C >> Q){\n\t\tsegtree seg(R*C);\n\n\t\tfor (int i = 0; i < R*C; ++i){\n\t\t\tint grid; cin >> grid;\n\t\t\tseg.update(i, i+1, 0, 0, seg.SIZE, grid);\n\t\t} // end for\n\n\t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2; cin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = seg.query2D(r1, c1, r2, c2, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n\tint Need(int size){\n\t\tsize--;\n\t\trep(i,5) size|=size>>(1<<i);\n\t\treturn size+1;\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(r,vi(c));\n\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvector<SegTree> sts(r,SegTree(c));\n\t\trep(i,r) rep(j,c) sts[i].Update(j,grid[i][j]);\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tint res=INFTY;\n\t\t\trepi(i,r1,r2+1) res=min(res,sts[i].Query(c1,c2+1));\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<memory>\n#include<algorithm>\n// constant\nconst int INF = 1e9;\n// type\nstruct Node {\n  enum POSITION {LOWER_LOWER, LOWER_HIGHER, HIGHER_LOWER, HIGHER_HIGHER};\n  int value;\n  std::vector<std::unique_ptr<Node>> child;\n  Node(int v) : value(v), child(4) {}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\nprivate:\n  std::unique_ptr<Node> build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(const std::unique_ptr<Node>& node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  int size_x_;\n  int size_y_;\n  std::unique_ptr<Node> root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nstd::unique_ptr<Node> SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  std::unique_ptr<Node> result(new Node(INF));\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(const std::unique_ptr<Node>& node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  unique_ptr<Node>(nullptr);\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 10000000000\n#define N 1000000000\nint r,c,q;\nint input;\nvector<int> zu[1000];\nint aaa,bbb,aa,bb;\nint ans;\nint n;\nint ima;\nint dat[1000][4*N];\nvoid init(int n_)\n{\n\tn=1;\n\twhile(n<n_)n*=2;\n\trep(i,2*n-1)rep(j,1000)dat[j][i]=INF;\n}\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[ima][k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tdat[ima][k]=min(dat[ima][k*2+1],dat[ima][k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r)\n{\n\tif(r<=a||b<=l)return INF;\n\tif(a<=l&&r<=b)return dat[ima][k];\n\telse\n\t{\n\t\tint v1=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint v2=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(v1,v2);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,1000)zu[i].clear();\n\t\tcin>>r>>c>>q;\n\t\tif(r==0)break;\n\t\tif(r<=c)\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[i].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[j].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t}\n\t\t/*rep(i,r)\n\t\t{\n\t\t\trep(j,c)cout<<zu[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tinit(c);\n\t\t//cout<<\"n:\"<<n<<endl;\n\t\trep(i,r)\n\t\t{\n\t\t\tima=i;\n\t\t\trep(j,c)\n\t\t\t{\n\t\t\t\tupdate(j,zu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(kkk,q)\n\t\t{\n\t\t\tcin>>aaa>>bbb>>aa>>bb;\n\t\t\tans=INF;\n\t\t\trep2(i,aaa,aa+1)\n\t\t\t{\n\t\t\t\tima=i;\n\t\t\t\tcout<<query(bbb,bb+1,0,0,n)<<endl;\n\t\t\t\tans=min(ans,query(bbb,bb+1,0,0,n));\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n\ntypedef long long TYPE;\nTYPE inf = 10000000000000000;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d(const int h, const int w);\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\n\tconst int height;\n\tconst int width;\n\n\tint height2;\n\tint width2;\n\tvector<vector<TYPE>> data;\n\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << data[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nSegment2d::Segment2d(const int h, const int w)\n: height(h)\n, width(w)\n{\n\twidth2 = 1;\n\twhile(width2 < width) width2 *= 2;\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tdata.resize(height2 * 2 - 1);\n\n\tfor(int i = 0; i < height2 * 2 - 1; i++)\n\t{\n\t\tdata[i] = vector<TYPE>(width2 * 2 - 1);\n\t\tfill(data[i].begin(), data[i].end(), inf);\n\t}\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\tdata[y][x] = val;\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tdata[ys[i]][xs[0]] = \n\t\tmin(data[left(ys[i])][xs[0]], \n\t\t\tdata[right(ys[i])][xs[0]]);\n\t}\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tdata[ys[i]][xs[j]] = \n\t\t\tmin(data[ys[i]][left(xs[j])], \n\t\t\t\tdata[ys[i]][right(xs[j])]);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn data[ky][kx];\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tSegment2d seg(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, vector<int> a){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n, INT_MAX);\n            for(int i = n; i < n + n_; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w){\n            swap(h, w);\n            f = true;\n        }\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j + 1, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            a.second++; b.second++;\n            if(f){\n                swap(a.first, a.second);\n                swap(b.first, b.second);\n            }\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 8000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return LLONG_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int> > Hs, Ws;\n\nint init(int k)\n{\n\tint sz;\n\tsz = 1;\n\twhile (sz < k){\n\t\tsz *= 2;\n\t}\n\t\n\treturn (sz);\n}\n\nvoid update(vector<int> &seg, int pos, int val)\n{\n\tpos += (seg.size() / 2) - 1;\n\tseg[pos] = val;\n\t\n\twhile (pos){\n\t\tpos = (pos - 1) / 2;\n\t\tseg[pos] = min(seg[2 * pos + 1], seg[2 * pos + 2]);\n\t};\n}\n\nint getMin(vector<int> &seg, int a, int b, int k, int l, int r)\n{\n\tint vl, vr;\n\t\n\tif (b <= l || r <= a){\n\t\treturn (INT_MAX);\n\t}\n\t\n\tif (a <= l && r <= b){\n\t\treturn (seg[k]);\n\t}\n\telse {\n\t\tvl = getMin(seg, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tvr = getMin(seg, a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\t\n\treturn (min(vl, vr));\n}\n\nint main()\n{\n\tint H, W, Q;\n\t\n\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tHs.resize(H);\n\t\tWs.resize(W);\n\t\t\n\t\tint Hsz = 2 * init(W);\n\t\tint Wsz = 2 * init(H);\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tHs[i].resize(Hsz);\n\t\t\tfill(Hs[i].begin(), Hs[i].end(), INT_MAX);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < W; i++){\n\t\t\tWs[i].resize(Wsz);\n\t\t\tfill(Ws[i].begin(), Ws[i].end(), INT_MAX);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tupdate(Hs[i], j, t);\n\t\t\t\tupdate(Ws[j], i, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tif (h2 - h1 <= w2 - w1){\n\t\t\t\tfor (int j = h1; j <= h2; j++){\n\t\t\t\t\tres = min(res, getMin(Hs[j], w1, w2 + 1, 0, 0, Hs[j].size() / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = w1; j <= w2; j++){\n\t\t\t\t\tres = min(res, getMin(Ws[j], h1, h2 + 1, 0, 0, Ws[j].size() / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nconst int MAX_N = 1 << 20;\nconst unsigned int INF = 4294967295U;\nunsigned int n;\n\nvoid init(unsigned int* dat, int n_)\n{\n  n = 1;\n  while (n < n_)\n    n*= 2;\n  for (int i = 0; i < 2*n-1; ++i)\n    dat[i] =INF;\n}\n\nvoid update(unsigned int* dat, int k, int a)\n{\n  k += n-1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k-1)/2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\nunsigned int query(unsigned int* dat, int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l)\n    return INF;\n\n  if (a <= l && r <= b) {\n    return dat[k];\n  } else {\n    unsigned int vl = query(dat, a, b, k*2+1, l, (l+r)/2);\n    unsigned int vr = query(dat, a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  static unsigned int dat_r[2*MAX_N-1], dat_c[2*MAX_N-1];\n\n  int r, c, q, g, r1, c1, r2, c2;\n  unsigned int ans = INF;\n  while (scanf(\"%d %d %d\", &r, &c, &q) != EOF) {\n    const int rc = r*c;\n    init(dat_r, rc);\n    init(dat_c, rc);\n\n    for (int i = 0; i < rc; ++i) {\n      scanf(\"%d\", &g);\n      update(dat_r, i, g);\n      update(dat_c, i/c+(i%c)*r, g);\n    }\n\n    for (int i = 0; i < q; ++i) {\n      scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n      ans = INF;\n\n      if (r2-r1 <= c2-c2) {\n\tfor (int j = r1; j <= r2; ++j)\n\t  ans = min(ans, query(dat_r, j*c+c1, j*c+c2+1, 0, 0, n));\n      } else {\n\tfor (int j = c1; j <= c2; ++j)\n\t  ans = min(ans, query(dat_c, j*r+r1, j*r+r2+1, 0, 0, n));\n      }\n      printf(\"%d\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\tll r,c,q;\n\tcin >> r >> c >> q;\n\t\n\tvector<seg_tree<ll>> segs(r, seg_tree<ll>(c));\n\tREP(x, r) REP(y, c) {\n\t\tll grid; cin >> grid;\n\t\tsegs[x].update(y, grid);\n\t}\n\t\n\n\tREP(i, q) {\n\t\tll minimum = seg_tree<ll>::invalid;\n\t\tll x_1, y_1, x_2, y_2;\n\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\tcout << minimum << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nvector<vector<int>>vs;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum= 2147483647;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 8>=r&&u + 8>= d) {\n\t\t\tfor (int x = l; x <r; ++x) {\n\t\t\t\tfor (int y = u; y <d; ++y) {\n\t\t\t\t\tminnum = min(minnum, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (nl + 8 >= nr&&nu +8 >= nd) {\n\t\t\tint ans = 2147483647;\n\t\t\tfor (int x = max(ql,nl); x < min(qr,nr); ++x) {\n\t\t\t\tfor (int y = max(qu,nu); y < min(qd,nd); ++y) {\n\t\t\t\t\tans = min(ans, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd) {\n\t\t\t\n\t\t\treturn minnum;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvs.clear();\n\t\tvs = vector<vector<int>>(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\ninline void update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\nint Log2[1000010];\nint R, C, Q;\nvector<vector<vector<int> > > dp;\nint A[1000010];\n\nvoid RMQ()\n{\n    int i,j,k;\n    dp.clear();\n    for(i=0;i<R;i++)\n    {\n        dp.push_back(vector<vector<int> >());\n        for(k=0;(1<<k)-1<C;k++)\n        {\n            dp[i].push_back(vector<int>());\n            for(j=0;j+(1<<k)-1<C;j++)\n            {\n                dp[i][k].push_back(k==0 ? A[i*C+j]: min(dp[i][k-1][j],dp[i][k-1][j+(1<<k-1)]));\n            }\n        }\n    }\n}\n\ninline int get(int r,int c1,int c2)\n{\n    int k=Log2[c2-c1+1];\n    return min(dp[r][k][c1], dp[r][k][c2-(1<<k)+1]);\n}\n\nint main()\n{\n   // freopen(\"G:\\\\in.txt\",\"r\",stdin);\n    int r1,c1,r2,c2,x;\n    for(int i=1;i<=1000000;i++)Log2[i]=(int)log2((double)i);\n\n    while(~scanf(\"%d%d%d\",&R,&C,&Q),R+C+Q)\n    {\n        bool flag=(R>C);\n        int r=R,c=C;\n        if(flag)swap(R,C);\n        for(int i=0;i<r;i++)\n        {\n            for(int j=0;j<c;j++)\n            scanf(\"%d\",&A[i*C+j]);\n        }\n        RMQ();\n        while(Q--)\n        {\n            scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n            if(flag) swap(r1,c1),swap(r2,c2);\n\n            int ans= 1999999999;\n            for(int j=r1;j<=r2;j++)\n                ans=min(ans,get(j,c1,c2));\n            printf(\"%d\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(n);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(n);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tfor(int i=0;i<2*h-1&&rmq[i]!=emp;i++)\n\t\t\tdelete rmq[i];\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[10000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\t//cout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t\tcout<<1<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n//===\n// memory: O(HW)\n// time: O(logH * logW)\ntemplate<class T, class OP = function<T(T, T)> >\nstruct SegmentTree2D {\n    const OP mergef;\n    const size_t H, W;\n    const T e;\n    vector<vector<T> > tree;\n\n    SegmentTree2D(size_t H, size_t W, const T &e, const OP &f):\n        H(H), W(W), e(e), mergef(f)\n    {\n        tree.assign(H << 1, vector<T>(W << 1, e));\n    };\n\n    void update(int sy, int sx, T dat) {\n        sy += H;\n        sx += W;\n        \n        int ty, tx;\n        tree[sy][sx] = dat;\n        tx = sx;\n        while (tx > 1) {\n            tx >>= 1;\n            tree[sy][tx] = mergef(tree[sy][(tx << 1)],\n                                  tree[sy][(tx << 1) | 1]);\n        }\n\n        ty = sy;\n        while (ty > 1) {\n            ty >>= 1;\n            tx = sx;\n            tree[ty][tx] = mergef(tree[(ty << 1)][tx],\n                                  tree[(ty << 1) | 1][tx]);\n            while (tx > 1) {\n                tx >>= 1;\n                tree[ty][tx] = mergef(tree[(ty << 1)][tx],\n                                      tree[(ty << 1) | 1][tx]);\n            }\n        }\n    };\n\n    T fold(int sy, int sx, int ty, int tx) {\n        sy += H;\n        ty += H;\n\n        T ret = e;\n        while (sy < ty) {\n            if (sy & 1) ret = mergef(ret, fold_x(sy++, sx, tx));\n            if (ty & 1) ret = mergef(fold_x(--ty, sx, tx), ret);\n\n            sy >>= 1;\n            ty >>= 1;\n        }\n        return ret;\n    };\n    T fold_x(int y, int l, int r) {\n        l += W;\n        r += W;\n\n        T ret = e;\n        while (l < r) {\n            if (l & 1) ret = mergef(ret, tree[y][l++]);\n            if (r & 1) ret = mergef(tree[y][--r], ret);\n\n            l >>= 1;\n            r >>= 1;\n        }\n        return ret;\n    };\n\n    T at(int sy, int sx) const {\n        return tree[sy + H][sx + W];\n    };\n};\n//===\n\nusing llong = long long;\n\nint AOJ1068() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    llong r, c, q;\n    llong gr;\n    llong sy, sx, ty, tx;\n\n    cin >> r >> c >> q;\n    while (r != 0 && c != 0 && q != 0) {\n        auto f = [](llong l, llong r){return min(l, r);};\n        SegmentTree2D<llong, decltype(f)> seg(r, c, 1ll << 60ll, f);\n        \n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                cin >> gr;\n                seg.update(i, j, gr);\n            }\n        }\n\n        for (int i = 0; i < q; i++) {\n            cin >> sy >> sx >> ty >> tx;\n\n            cout << seg.fold(sy, sx, ty + 1,  tx + 1) << '\\n';\n        }\n\n        /*\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                cout << seg.at(i, j) << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cin >> r >> c >> q;\n    }\n\n    return 0;\n}\n\nint main() {\n    return AOJ1068();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\ntypedef long long LL;\nconst int oo = 0x7fffffff;\nconst int Max = 1048576;\nconst int MaxN = 4;\nconst int MaxLg = 16;\nint A[Max],Log[MaxN],tableMin[MaxN][MaxLg];\nvoid makeRMinQ(int *a,int s,int t){\n\tint i,j,n = t-s;\n\tfor (i = s;i < t;i++) tableMin[i-s][0] = a[i];\n\t//for (i = s;i < t;i++)printf(\"%d \",a[i]);puts(\"\");\n\tfor (j = 1;(1 << j) <= n;j++)\n\t\tfor (i = s;i+(1 << j) <= t;i++)\n\t\t\ttableMin[i-s][j] = min(tableMin[i-s][j-1],tableMin[i-s+(1 << (j-1))][j-1]);\n}\nint QueryMin(int x,int y){\n\tint p = Log[y-x+1];//calLog2(y-x+1);\n\treturn min(tableMin[x][p],tableMin[y-(1 << p)+1][p]);\n}\nconst int MaxQ = 10010;\nstruct query{\n    int x1,y1,x2,y2;\n};\nquery fQ[MaxQ];\nint Res[MaxQ];\nint main(){\n\tfor (int i = 0,x = 0,cd = 2;i < MaxN;x++,cd<<=1)\n\t\twhile (i < MaxN && i < cd)\n\t\t    Log[i++] = x;\n    for (int R,C,Q;scanf(\"%d%d%d\",&R,&C,&Q) && R;){\n        if (R <= C){\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[i*C+j]);\n            for (int q = 0;q < Q;q++)\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n        }else{\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[j*R+i]);\n            swap(R,C);\n            for (int q = 0;q < Q;q++){\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n                swap(fQ[q].x1,fQ[q].y1);\n                swap(fQ[q].x2,fQ[q].y2);\n            }\n        }\n        for (int q = 0;q < Q;q++)\n            Res[q] = oo;\n        int fC = (C-1) / MaxN+1;\n        for (int i = 0;i < R;i++){\n            for (int j = 0,k = 0;j < fC;j++){\n                int nk = min(C,k+MaxN);\n                makeRMinQ(A,i*C+k,i*C+nk);\n                for (int q = 0;q < Q;q++){\n                    if (i < fQ[q].x1 || fQ[q].x2 < i)\n                        continue;\n                    if (nk <= fQ[q].y1 || fQ[q].y2 < k)\n                        continue;\n                    int cs = max(fQ[q].y1,k);\n                    int ct = min(fQ[q].y2,nk-1);\n                    //printf(\"%d : %d\\n\",q,QueryMin(cs-k,ct-k));\n                    Res[q] = min(Res[q],QueryMin(cs-k,ct-k));\n                }\n                k = nk;\n            }\n        }\n        for (int q = 0;q < Q;q++)\n            printf(\"%d\\n\",Res[q]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(){}\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\t// vector<T> a;\n\tT *a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ():a(NULL){}\n\n\tRMQ(const vector< vector<T> > &v,int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=v[0].size();\n\t\telse   N=v.size();\n\n\t\twhile(n<N) n<<=1;\n\t\t// a=vector<T>(2*n-1);\n\t\ta=(T *)malloc((2*n-1)*sizeof(T));\n\t\trep(i,2*n-1) a[i]=0;\n\n\t\tif(!b) rep(i,N) a[n+i-1]=v[k][i];\n\t\telse   rep(i,N) a[n+i-1]=v[i][k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\t// ~RMQ(){ if(a){ free(a); printf(\"> hoge\\n\");} else puts(\"hogehoge\"); }\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tvector< RMQ<int> > rmq1(h);\n\t\tvector< RMQ<int> > rmq2(w);\n\t\trep(i,h) rmq1[i]=RMQ<int>(a,i,0);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a,j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<memory>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  enum POSITION {LOWER_LOWER, LOWER_HIGHER, HIGHER_LOWER, HIGHER_HIGHER};\n  int value;\n  std::vector<std::unique_ptr<Node>> child;\n  Node(int v) : value(v), child(4) {}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\nprivate:\n  std::unique_ptr<Node> build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(const std::unique_ptr<Node>& node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  int size_x_;\n  int size_y_;\n  std::unique_ptr<Node> root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nstd::unique_ptr<Node> SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  std::unique_ptr<Node> result(new Node(INF));\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(const std::unique_ptr<Node>& node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  unique_ptr<Node>(nullptr);\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void insert(int x, int y, int value);\n  void update();\n  void destroy();\nprivate:\n  Node* build(int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void insert(Node* node, int low_x, int low_y, int high_x, int high_y, int _x, int _y, int value);\n  void update(Node* node, int low_x, int low_y, int high_x, int high_y);\n  void destroy(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) {\n  size_x_ = x;\n  size_y_ = y;\n  root_ = build(0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) return result;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(x[i], y[j], x[i + 1], y[j + 1]);\n  }\n  return result;\n}\nvoid SegmentTree::insert(int x, int y, int value) {\n  insert(root_, 0, 0, size_x_, size_y_, x, y, value);\n}\nvoid SegmentTree::insert(Node* node, int low_x, int low_y, int high_x, int high_y, int _x, int _y, int value) {\n  if(_x < low_x || high_x <= _x || _y < low_y || high_y <= _y) return;\n  if(low_x == high_x - 1 && low_y == high_y - 1 && low_x == _x && low_y == _y) {\n    node->value = value;\n  } else {\n    int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n    int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n    for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n      insert(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], _x, _y, value);\n    }\n  }\n}\nvoid SegmentTree::update() {\n  update(root_, 0, 0, size_x_, size_y_);\n}\nvoid SegmentTree::update(Node* node, int low_x, int low_y, int high_x, int high_y) {\n  if(low_x == high_x - 1 && low_y == high_y - 1) return;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    update(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1]);\n    node->value = std::min(node->value, node->child[i + j * 2]->value);\n  }\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Delte nodes.\nvoid SegmentTree::destroy() {destroy(root_);}\nvoid SegmentTree::destroy(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) destroy(node->child[i]);\n  delete node;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.insert(x, y, grid);\n    }\n    tree.update();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.destroy();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\n//const ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = (1 << 21);\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int dat[MAX];    \n\n    int c(int i, int j)\n    {\n        return i * (2 * W - 1) + j;\n    }\n    \n    void init(int h, int w, vector<vector<int>>& grid)\n    {        \n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        \n        for (int i = 0; i < 2 * H - 1; i++) {        \n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[c(i, j)] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[c(i + H - 1, j + W - 1)] = grid[i][j];\n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[c(i, j)] = min(dat[c(i, j * 2 + 1)],\n                                   dat[c(i, j * 2 + 2)]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[c(j, i)] = min(dat[c(j * 2 + 1, i)],\n                                   dat[c(j * 2 + 2, i)]);\n            }\n        }\n    }\n\n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[c(j, k)];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nRMQ2D r;\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        r.init(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << r.query(y1, x1, y2, x2) << endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[n+a-1];\n\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\tsegtree[i]=new int[m+b-1];\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,2147483647-d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",2147483647-query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct SegTree {\n    vector<dat_t> dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat.assign(k*2, inf);\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        dump(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            dump(tree.dat[i].dat);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 20;\nconst int INF = 1 << 28;\n\nint r, c;\nint w, h;\nint seg[8 * MAX_N];\n\nvoid init()\n{\n\tfor (w = 1; w < r; w <<= 1);\n\tfor (h = 1; h < c; h <<= 1);\n\tfill_n(seg, 8 * MAX_N, INF);\n}\n\nvoid update(int x, int y, int v, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (x < ax || bx <= x) return;\n\tif (y < ay || by <= y) return;\n\t\n\tif (bx - ax == 1 && by - ay == 1){\n\t\tseg[k] = v;\n\t\treturn;\n\t}\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tupdate(x, y, v, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tupdate(x, y, v, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\tseg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\n\t//printf(\"seg[%d] = %d\\n\", k, seg[k]);\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n}\n\nint getMin(int lx, int ly, int rx, int ry, int k = 0, int ax = 0, int ay = 0, int bx = w, int by = h, int nxt = 0)\n{\n\tif (rx <= ax || bx <= lx) return INF;\n\tif (ry <= ay || by <= ly) return INF;\n\tif (lx <= ax && bx <= rx && ly <= ay && by <= ry) return seg[k];\n\t\n\t//printf(\"%d %d %d %d %d\\n\", k, ax, ay, bx, by);\n\t\n\tif (nxt == 0 && bx - ax == 1) nxt = 1;\n\telse if (nxt == 1 && by - ay == 1) nxt = 0;\n\t\n\tint vl, vr;\n\tif (nxt == 0){\n\t\tint m = (ax + bx) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, m, by, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, m, ay, bx, by, nxt ^ 1);\n\t}\n\telse if (nxt == 1){\n\t\tint m = (ay + by) / 2;\n\t\tvl = getMin(lx, ly, rx, ry, k * 2 + 1, ax, ay, bx, m, nxt ^ 1);\n\t\tvr = getMin(lx, ly, rx, ry, k * 2 + 2, ax, m, bx, by, nxt ^ 1);\n\t}\n\t\n\treturn min(vl, vr);\n}\n\nint main()\n{\n\tint q;\n\twhile (scanf(\"%d %d %d\", &r, &c, &q), r|c|q){\n\t\tinit();\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tfor (int j = 0; j < c; j++){\n\t\t\t\tint v;\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\tupdate(i, j, v);\n\t\t\t}\n\t\t}\n\t\twhile (q--){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", getMin(r1, c1, ++r2, ++c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\n// ツ禿アツ篠淞個ウseg treeツづ個デツーツタツづーツ格ツ納\nuint dat[8*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < 8*MAX_N; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,uint a,int k,bool isHor){\n\t// ツ重ツづ按づィツ閉板閉ェツつェツづ按つ「\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return;\n\tdat[k]=min(dat[k],a);\n\t// ツ債。ツ嘉アツづ個湘ェツ渉環づーツ更ツ新ツつオツつスツづァツ終ツ猟ケ\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)\n\t\treturn;\n\t// ツ債。ツ嘉アツづつソツづァツづ静伉づゥツつゥ\n\tbool nxt=!isHor;\n\t// xツつゥyツづ個閉敖つェ1ツづ可づ按づつスツづァツ、ツ陛青陛サツづ個づ敖個ゥツづつ「ツつュ\n\tif(sminy==smaxy){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t\treturn;\n\t}\n\telse if(sminx==smaxx){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t\treturn;\n\t}\n\tif(isHor){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n\telse{\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n}\n\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k,bool isHor){\n\t// ツ重ツづ按づィツ閉板閉ェツつェツづ按つ「\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ツ環ョツ全ツづ可甘慊づ慊づェツづゥ\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// ツ個サツ催捶ツづーツ閉ェツ環つオツづつ「ツづゥツつゥツ、yツづ閉ェツ環つオツづつ「ツづゥツつゥツづ湘ェツ債づュツつッ\n\tuint vl,vr;\n\t// ツ債。ツ嘉アツづつソツづァツづ静伉づゥツつゥ\n\tbool nxt=!isHor;\n\t// xツつゥyツづ個閉敖つェ1ツづ可づ按づつスツづァツ、ツ陛青陛サツづ個づ敖個ゥツづつ「ツつュ\n\tif(sminy==smaxy){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\treturn min(vl,vr);\n\t}\n\telse if(sminx==smaxx){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\treturn min(vl,vr);\n\t}\n\tif(isHor){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\telse\n\t\t\tvr=INF;\n\t}\n\telse{\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\telse vr=INF;\n\t}\n\treturn min(vl,vr);\n}\n\n// school of killifishツづーツ嘉ーツつ「ツつスツコツーツド\nvoid run_test(){\n\tFILE *fp=stdin;\n\t//fp=fopen(\"input.txt\",\"r\");\n\twhile(fscanf(fp,\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tfscanf(fp,\"%d\",&t);\n\t\t\t\tupdate(j,i,j,i,0,0,w-1,h-1,t,0,true);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tfscanf(fp,\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0,true);\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n}\n\nint main(){\n\trun_test();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 0;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn max(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn max(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=max(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[n+a-1];\n\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=0;\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,2147483647-d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",2147483647-query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nint H, W;\nint** dat;\n    \nvoid init(int h, int w, int** grid)\n{\n    H = 1;\n    while (H < h) H *= 2;\n    W = 1;\n    while (W < w) W *= 2;\n    dat = new int*[2 * H - 1];\n    for (int i = 0; i < 2 * H - 1; i++) {\n        dat[i] = new int[2 * W - 1];\n        for (int j = 0; j < 2 * W - 1; j++) {\n            dat[i][j] = INT_MAX;\n        }\n    }\n\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            dat[i + H - 1][j + W - 1] = grid[i][j]; \n        }\n    }\n        \n    for (int i = 2 * H - 2; i >= 0; i--) {\n        for (int j = W - 2; j >= 0; j--) {\n            dat[i][j] = std::min(dat[i][j * 2 + 1], dat[i][j * 2 + 2]);\n        }\n    }\n\n    for (int i = 2 * W - 2; i >= 0; i--) {\n        for (int j = H - 2; j >= 0; j--) {\n            dat[j][i] = std::min(dat[j * 2 + 1][i], dat[j * 2 + 2][i]);\n        }\n    }\n}\n\nint query_w(int, int, int, int, int, int);\n\nint query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n{\n    if (r <= h1 || h2 <= l) return INT_MAX;\n    if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n    int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n    int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n    return std::min(vl, vr);\n}\n\nint query_w(int w1, int w2, int j, int k, int l, int r)\n{\n    if (r <= w1 || w2 <= l) return INT_MAX;\n    if (w1 <= l && r <= w2) return dat[j][k];\n    int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n    int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n    return std::min(vl, vr);\n}\n\nint query(int h1, int w1, int h2, int w2)\n{\n    return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n        \n    int h, w, Q;\n    while (std::cin >> h >> w >> Q, h) {\n        int** grid;\n        grid = new int*[h];\n        \n        for (int i = 0; i < h; i++) {\n            grid[i] = new int[w];\n            for (int j = 0; j < w; j++) {\n                std::cin >> grid[i][j];\n            }\n        }\n        \n        init(h, w, grid);\n\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            std::cin >> y1 >> x1 >> y2 >> x2;\n            std::cout << query(y1, x1, y2, x2) << std::endl;\n        }\n        \n        delete[] dat;\n        delete[] grid;\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\nvi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vi[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  //  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=0x7f7f7f7f7f7f7f7f;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    memset(dat,0x7f,sizeof(dat));\n   // fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint pool[9000000]; //9 MB\nint header;\n\nint *assign(int block)\n{\n\tint *ret = &pool[header];\n\theader += block;\n\treturn (ret);\n}\n\nvector<int *> seg;\nint wbin, hbin;\n \nvoid update(int y, int x, int v)\n{\n    y += hbin - 1;\n    x += wbin - 1;\n     \n    seg[y][x] = v;\n     \n    while (y >= 0){\n        int _x = x;\n        while (_x){\n            _x = (_x - 1) / 2;\n            seg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n        }\n        if (y == 0) break;\n        y = (y - 1) / 2;\n        seg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n    }\n}\n \nint r1, c1, r2, c2, G;\n \nint _query(int k = 0, int l = 0, int r = wbin)\n{\n    if (c2 <= l || r <= c1) return (INT_MAX);\n    if (c1 <= l && r <= c2) return (seg[G][k]);\n     \n    int lval = _query(k * 2 + 1, l, (l + r) / 2);\n    int rval = _query(k * 2 + 2, (l + r) / 2, r);\n     \n    return (min(lval, rval));\n}\n \nint query(int k = 0, int l = 0, int r = hbin)\n{\n    if (r2 <= l || r <= r1) return (INT_MAX);\n    if (r1 <= l && r <= r2){\n        G = k;\n        return (_query());\n    }\n     \n    int lval = query(k * 2 + 1, l, (l + r) / 2);\n    int rval = query(k * 2 + 2, (l + r) / 2, r);\n     \n    return (min(lval, rval));\n}\n \nint main()\n{\n    int w, h, q;\n     \n    while (scanf(\"%d %d %d\", &h, &w, &q) && w){\n        wbin = hbin = 1;\n        while (wbin < w) wbin *= 2;\n        while (hbin < h) hbin *= 2;\n\t\t\n\t\theader = 0;\n        seg.resize(hbin * 2 - 1);\n        for (int i = 0; i < seg.size(); i++) seg[i] = assign(wbin * 2 - 1);\n        \n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                int a;\n                scanf(\"%d\", &a);\n                update(i, j, a);\n            }\n        }\n        \n        for (int i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            ++r2; ++c2;\n            printf(\"%d\\n\", query());\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\nuint field[sz];\nuint dat[sz * 20];\nint R, C, Q;\n\n#define FIELD(r, c) (field[(r) * C + (c)])\n#define DAT(kr, kc) (dat[(kr) * (C) * 4 + (kc)])\n\nvoid build(int lr, int rr, int lc, int rc, int kr, int kc, bool r_axis = true){\n  if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = FIELD(lr, lc);\n  }else if((r_axis && rr - lr > 1) || rc - lc == 1){\n    assert(rr - lr != 1);\n    int mr = (lr + rr) / 2;\n    build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n    build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n    DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    \n  }else{\n    int mc = (lc + rc) / 2;\n    build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n    build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n    DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n           int lr = 0, int rr = R, int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc || rr <= lr || rc <= lc)return INF;\n  \n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc){\n    return DAT(kr, kc);\n  }else if((r_axis && rr - lr > 1) || rc - lc == 1){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\nuint naive(int ar, int br, int ac, int bc){\n  uint ans = INF;\n  REP2(i, ar, br)REP2(j, ac, bc) ans = min(ans, FIELD(i, j));\n  return ans;\n}\n\nint main(){\n  int r1, r2, c1, c2;\n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &FIELD(r, c));\n    if(R > 0 && C > 0) build(0, R, 0, C, 0, 0);\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  int top(){\n    return data[0];\n  }\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  inline void update(int k, int x){\n    data[k + N - 1] = x;\n  }\n  void build(){\n    for(int k = N - 2; k >= 0; k--){\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b, int MIN){\n    return query(a, b, 0, 0, N, MIN);\n  }\n  int query(int a, int b, int k, int l, int r, int MIN){\n    if(b <= l || r <= a) return INF;\n    else if(a <= l && r <= b){\n      return data[k];\n    }else if(MIN <= data[k]){\n      return MIN;\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2, MIN), query(a, b, 2 * k + 2, (l + r) / 2, r, MIN));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n        rmq[y].build();\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1, res));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(x, W) rmq[x].build();\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int x = x1; x <= x2; x++){\n          res = min(res, rmq[x].query(y1, y2 + 1, res));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int grid[N];\n  int rmq[N];\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    int bs_r = (int)sqrt(r), bs_c = (int)sqrt(c);\n    int bn_r = r/bs_r, bn_c = c/bs_c;\n    if(r%bs_r)bn_r++;\n    if(c%bs_c)bn_c++;\n \n    for(int i=0;i<bn_r;i++){\n      for(int j=0;j<bn_c;j++)rmq[i*bn_c + j] = (1<<31) -1;\n    }\n    \n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c + j];\n\trmq[(i/bs_r) * bn_c + (j/bs_c)] = min(rmq[(i/bs_r) * bn_c + (j/bs_c)],grid[i*c + j]);\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ans = (1<<31) -1;\n\n      int sr = r1/bs_r;\n      if(r1%bs_r){\n\tsr++;\n\tfor(int i=r1;i<sr*bs_r;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int sc = c1/bs_c;\n      if(c1%bs_c){\n\tsc++;\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<sc*bs_c;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gr = r2/bs_r;\n      if( (r2+1)%bs_r){\n\tfor(int i=gr*bs_r;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gc = c2/bs_c;\n      if( (c2+1)%bs_c){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=gc*bs_c;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      if(sr == gr || sc == gc){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n      }\n\n\n      for(int i=sr;i<gr;i++){\n\tfor(int j=sc;j<gc;j++){\n\t  ans = min(ans,rmq[i*bn_c+j]);\n\t}\n      }\n\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\tstatic int cmp[1024][1024];\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = ((int)sqrt(H)) + 1;\n\t\tint Ws = ((int)sqrt(W)) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = h1 / Hs; j <= h2 / Hs; j++){\n\t\t\t\tfor (int k = w1 / Ws; k <= w2 / Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2 && w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = max(0, h1 / Hs); j < min(h2 / Hs + 1, Hs); j++){\n\t\t\t\tfor (int k = max(0, w1 / Ws); k < min(w2 / Ws + 1, Ws); k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2\n\t\t\t\t\t\t\t\t&& w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= min((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int SQRT_N = 1000;\nconst int INF = (int)1e9;\nint H, W, Q;\nstruct Row {\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(int x, int value) {\n    data[x] = value;\n    int k = x / SQRT_N;\n    stat[k] = INF;\n    for(int i = k*SQRT_N; i < (k+1)*SQRT_N; ++i) {\n      stat[k] = min(stat[k], data[i]);\n    }\n  }\n  int query(int a, int b) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(int y, int x, int value) {\n    data[y].update(x, value);\n    int k = y / SQRT_N;\n    int s = INF;\n    for(int i = k*SQRT_N; i < (k+1)*SQRT_N; ++i) {\n      s = min(s, data[i].data[x]);\n    }\n    stat[k].update(x, s);\n  }\n  int query(int y1, int x1, int y2, int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int MAX_N = 1000100;\n\nclass segTree{\n    public:\n        int n;\n        vector<int> dat;\n        void init(int n_, int value, int dat_b[4 * MAX_N] = NULL){\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n);\n            rep(i,2 * n){\n                dat[i] = value;\n                if(dat_b != NULL) dat_b[i] = value;\n            }\n        }\n        void initArray(int n_, vector<int> a){ //??????a??§????????????\n            n = 1;\n            while(n <= n_) n *= 2;\n\n            dat = vector<int>(4 * n, INT_MAX);\n            for(int i = n; i < n + n_; i++){\n                dat[i] = a[i - n];\n            }\n            for(int i = n - 1; i >= 1; i--){\n                dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n                //dat[i] = dat[i * 2] + dat[i * 2 + 1];\n            }\n        }\n        void output(vector<int> a){\n            show(\"print\");\n            range(i,1,n * 2) cout << (a[i] == INT_MAX ? -1 : a[i]) << ' ';\n            cout << endl;\n        }\n};\n\nclass rangeAddQuery : public segTree{\n    //dat : ???????????????????§???????????????????????????????\n    //dat_add : ????§???§?????????????????????????????????\n    private:\n        int dat_add[4 * MAX_N];\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] * (r - l) + dat_add[k];\n\n            int res = (min(b, r) - max(a, l)) * dat[k];\n            res += query(a, b, k * 2, l, (l + r) / 2);\n            res += query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return res;\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(a <= l && r <= b){\n                dat[k] += x;\n            }else if(l < b && a < r){\n                dat_add[k] += (min(b, r) - max(a, l)) * x;\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0, dat_add); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeSumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(r <= a || b <= l) return 0;\n            if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return vl + vr;\n        }\n    public:\n        void init(int n_){ segTree::init(n_, 0); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] += x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = dat[i] + dat[i^1];\n                i = i / 2;\n            }\n        }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        int get(int a){ return query(a, a + 1); }\n};\n\nclass rangeMinimumQuery : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            //[a, b) ??¨[l, r)???????????????????????°???INT_MAX\n            if(r <= a || b <= l) return INT_MAX;\n            //[a,b)???[l,r)????????¨???????????§????????°?????????????????????\n            if(a <= l && r <= b) return dat[k];\n\n            //????????§???????????°??????????????????????°????\n            int vl = query(a, b, k * 2, l, ( l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX); }\n        void update(int i, int x){\n            i += n; //????????????\n            dat[i] = x;\n            while(i > 0){ //?????????????????´??°\n                dat[i / 2] = min(dat[i], dat[i^1]);\n                i = i / 2;\n            }\n        }\n        //[a, b)???????°????????±???????\n        int query(int a, int b){ return query(a,b,1,0,n); }\n};\n\nclass rangeUpdateQuery : public segTree{ //??????????????????update??§?????????min??¨???sum???????????????\n    private:\n        int dat_lazy[4 * MAX_N]; //?????¶???????????????????????????\n        int query(int a, int b, int k, int l, int r){\n            //???????£?\n            evaluate(k);\n\n            if(b <= l || r <= a) return INT_MAX;\n            else if(a <= l && r <= b) return dat[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n        inline void evaluate(int k){\n            if(dat_lazy[k] == INT_MAX) return;\n            dat[k] = dat_lazy[k];\n            if(k < n){\n                dat_lazy[2 * k] = dat_lazy[k]; //?????¶????????¬????????¨???\n                dat_lazy[2 * k + 1] = dat_lazy[k];\n            }\n            dat_lazy[k] = INT_MAX;\n        }\n        void update(int a, int b, int k, int l, int r, int x){\n            evaluate(k);\n\n            if(b <= l || r <= a ) return;\n\n            if(a <= l && r <= b){\n                dat_lazy[k] = x;\n            }else{\n                evaluate(k);\n                update(a, b, k * 2, l, (l + r) / 2, x);\n                update(a, b, k * 2 + 1, (l + r) / 2, r, x);\n            }\n        }\n    public:\n        void init(int n_){ segTree::init(n_,INT_MAX,dat_lazy); }\n        int query(int a, int b){ return query(a,b,1,0,n); }\n        void update(int s, int t, int x){ update(s, t, 1, 0, n, x); }\n        void update(int i, int x){ update(i, i + 1, 1, 0, n, x); }\n        int get(int a){ return query(a, a + 1); };\n};\n\nclass starrySky : public segTree{\n    private:\n        int query(int a, int b, int k, int l, int r){\n            if(b <= l || r <= a) return 0;\n            if(a <= l && r <= b) return dat[k] + dat_add[k];\n\n            int vl = query(a, b, k * 2, l, (l + r) / 2);\n            int vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return max(vl, vr) + dat_add[k];\n        }\n        void add(int a, int b, int k, int l, int r, int x){\n            if(b <= l || r <= a) return;\n            if(a <= l && r <= b){\n                dat_add[k] += x;\n            }else{\n                add(a, b, k * 2, l, (l + r) / 2, x);\n                add(a, b, k * 2 + 1, (l + r) / 2, r, x);\n                dat[k] = max(dat[k * 2] + dat_add[k * 2], dat[k * 2 + 1] + dat_add[k * 2 + 1]);\n            }\n        }\n        void init(int n_){ segTree::init(n_,0,dat_add); }\n    public:\n        int dat_add[4 * MAX_N];\n        starrySky(int n){ init(n); }\n        int query(int a, int b){ return query(a, b, 1, 0, n); }\n        void add(int s, int t, int x){ add(s, t, 1, 0, n, x); }\n        void add(int i, int x){ add(i, i + 1, 1, 0, n, x); }\n};\n\n//P is structure of coodinate.\nvoid rotationMatrix(pair<int, int> &p, double angle = M_PI / 2){\n    int x, y;\n    x = p.first * cos(angle) - p.second * sin(angle);\n    y = p.first * sin(angle) + p.second * cos(angle);\n    p.first = x;\n    p.second = y;\n}\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h){\n        bool f = false;\n        if(h > w) f = true;\n        if(f) swap(h, w);\n        vector<rangeMinimumQuery> seg(h);\n        rep(i,h){\n            seg[i].init(w);\n            rep(j,w){\n                int x;\n                cin >> x;\n                seg[i].update(j + 1, x);\n            }\n        }\n        rep(i,q){\n            pair<int, int> a, b;\n            cin >> a.first >> a.second >> b.first >> b.second;\n            a.second++; b.second++;\n            if(f){\n                rotationMatrix(a);\n                rotationMatrix(b);\n            }\n            //cout << a.first << ' ' << a.second << endl;\n            //cout << b.first << ' ' << b.second << endl;\n            //show(seg[0].query(1,9));\n\n            int ans = INT_MAX;\n            for(int i = a.first; i <= b.first; i++){\n                //show(i)\n                //show(seg[i].query(a.second, b.second + 1));\n                ans = min(ans, seg[i].query(a.second, b.second + 1));\n            }\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<climits>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint rc[1000 * 1000];\nint w, h, q;\nint mm;\nbool sw;\n\nint buff[1024 * 1024];\n\nvoid gen(){\n  const int n = w * h;\n  int m = 1; while(m < n) m *= 2; mm = m;\n\n  REP(i, m + m) buff[i] = INT_MAX;\n  REP(i, n) buff[i + m - 1] = rc[i];\n\n  while(m - 1 >= 0){\n    m /= 2;\n    /*\n    for(int i = 1; i <= mm; i *= 2){\n      for(int j = i - 1; j < i - 1 + i; j++){\n     \tprintf(\"%d \", buff[j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    for(int i = m - 1; i < m - 1 + m; i++){\n      buff[i] = min(buff[i * 2 + 1], buff[i * 2 + 2]);\n    }\n  }\n}\n\nint iter(int l, int r, int pos, int width){\n  //printf(\"iter: %d %d %d %d\\n\", l, r, pos, width);\n  int w2 = width / 2;\n  if(l + width == r) return buff[pos];\n  if(w2 <= l) return iter(l - w2, r - w2, pos * 2 + 2, w2);\n  if(w2 >= r) return iter(l, r, pos * 2 + 1, w2);\n  return min(iter(l, w2, pos * 2 + 1, w2), iter(0, r - w2, pos * 2 + 2, w2));\n}\n\nint query(int l, int r){\n  return iter(l, r, 0, mm);\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h, &w, &q), w + h + q){\n    sw = h > w;\n    \n    REP(i, h) REP(j, w){\n      if(!sw){\n\tscanf(\"%d\", rc + i * w + j);\n      }else{\n\tscanf(\"%d\", rc + j * h + i);\n      }\n    }\n\n    if(sw) swap(h, w);\n\n    gen();\n\n    REP(qq, q){\n      int h1, h2, w1, w2;\n      int ans = INT_MAX;\n      scanf(\"%d%d%d%d\", &h1, &w1, &h2, &w2);\n\n      if(sw){ swap(h1, w1); swap(h2, w2); }\n\n      for(int hh = h1; hh < h2 + 1; hh++){\n\tint p1 = hh * w + w1;\n\tint p2 = hh * w + w2;\n\n\t//REP(i, h*w) printf(\"%d \", rc[i]); puts(\"\");\n\t//printf(\"query(%d, %d) = %d\\n\", p1, p2 + 1, query(p1, p2 + 1));\n\n\tans = min(ans, query(p1, p2 + 1));\n      }\n\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\n//unsigned int _seg[11111111];\n//vector<unsigned int*> seg;\nunsigned int** seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg = (unsigned int**)malloc(sizeof(unsigned int*) * (2 * _r - 1));\n  rep(i, 2 * _r - 1) seg[i] = (unsigned int*)malloc(sizeof(unsigned int) * (2 * _c - 1));\n  /*\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n  */\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n    rep(i, 2 * _r - 1) free(seg[i]);\n    free(seg);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W, W_;\nint y1, x1, y2, x2, g[8000000];\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y*W_ + x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tW_ = 2*W - 1;\n\t\trep(i, (2*H-1) * (2*W-1)) g[i] = inf;\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", g + (i+H-1) * W_ + j+W-1);\n\t\t\n\t\tfor(int i = 2*H - 2; i >= 0; i--){\n\t\t\tfor(int j = 2*W - 2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(min(g[(i*2+1) * W_ + j*2 + 1], g[(i*2+2) * W_ + j*2+2]),\n\t\t\t\t\t\tmin(g[(i*2+2) * W_ + j*2+1], g[(i*2+1) * W_ + j*2+2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[(i*2 + 1) * W_ + j], g[(i*2 + 2) * W_ + j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[i * W_ + j*2+1], g[i * W_ + j*2+2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint INF = pow(2,31) - 1;\nint n;\nvoid powset(int size){\n  n = 1;\n  while( n < size ) n *= 2;\n}\n\nstruct RMQ{\n  vector< int > seg;\n  void update( int i, int x){\n    i += n - 1;\n    seg[i] = x;\n  }\n  void build(){\n    for(int i = n - 2; i >= 0; i--){\n      seg[i] = min( seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n  }\n  int query( int a, int b, int k, int l, int r){\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) return seg[k];\n    int vl = query( a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query( a, b, k * 2 + 2, (l + r) / 2, r);\n    return min( vl, vr);\n  }\n  int query( int a, int b){\n    return query( a, b, 0, 0, n);\n  }\n  RMQ(){\n    seg.assign( n * 2 - 1, INF);\n  }\n};\n\nint main(){\n  int R, C, Q;\n  while(scanf(\"%d %d %d\", &R, &C, &Q), R){\n    if(R < C){\n      powset(C);\n      vector< RMQ > rmq( R, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\", &grid);\n          rmq[i].update(j,grid);\n        }\n        rmq[i].build();\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = r1; i <= r2; i++){\n          ret = min( ret, rmq[i].query( c1, c2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }else{\n      powset(R);\n      vector< RMQ > rmq( C, RMQ());\n      for(int i = 0; i < R; i++){\n        for(int j = 0; j < C; j++){\n          int grid;\n          scanf(\"%d\",&grid);\n          rmq[j].update(i,grid);\n        }\n        rmq[i].build();\n      }\n      while(Q--){\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        int ret = INF;\n        for(int i = c1; i <= c2; i++){\n          ret = min( ret, rmq[i].query( r1, r2 + 1));\n        }\n        printf(\"%d\\n\", ret);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INT_MAX);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INT_MAX;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\nint r,cc,q,t;\n\nint main(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        int a,b,c,d;\n        init(r,cc);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(h);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(w);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tif(rmq[i*2+1]==emp && rmq[i*2+2]==emp){\n\t\t\t\trmq[i]=emp;\n\t\t\t}else{\n\t\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tfor(int i=0;i<2*h-1;i++)\n\t\t\tif(rmq[i]!=emp)delete rmq[i];\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[10000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//40\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF ((1<<31)^~0)\n\nvector<vector<int> > d;\n\nint que(const vector<int> &d,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return INF;\n  }else if(a<=l&&r<=b){\n    return d[k];\n  }else{\n    return min(que(d,a,b,k*2+1,l,(l+r)/2)\n\t       ,que(d,a,b,k*2+2,(l+r)/2,r));\n  }\n}\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > g;\n    bool w=r<c;\n    if(w){\n      g=vector<vector<int> >(r,vector<int>(c));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[i][j];\n\t}\n      }\n    }else{\n      g=vector<vector<int> >(c,vector<int>(r));\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin>>g[j][i];\n\t}\n      }\n      swap(r,c);\n    }\n    int cc;\n    for(cc=1;cc<c;cc*=2);\n    d=vector<vector<int> >(r,vector<int>(cc*2-1,INF));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tint k=j+cc-1;\n\td[i][k]=g[i][j];\n\twhile(k>0){\n\t  k=(k-1)/2;\n\t  d[i][k]=min(d[i][k*2+1],d[i][k*2+2]);\n\t}\n      }\n    }\n    while(q--){\n      int r1,c1,r2,c2;\n      if(w){\n\tcin>>r1>>c1>>r2>>c2;\n      }else{\n\tcin>>c1>>r1>>c2>>r2;\n      }\n      int m=INF;\n      for(int i=r1;i<=r2;i++){\n\tm=min(m,que(d[i],c1,c2+1,0,0,cc));\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 2147483647\n\n\nclass RMQ{\npublic:\n\tRMQ(int height,int first_N){\n\t\trmq_H = height;\n\t\tN = 1;\n\t\twhile(N < first_N)N *= 2;\n\t\ttable = new int*[height];\n\t\tfor(int row = 0; row < height; row++){\n\t\t\ttable[row] = new int[2*N-1];\n\t\t\tfor(int col = 0; col < 2*N-1; col++){\n\t\t\t\ttable[row][col] = NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid update(int row,int loc,int value){\n\t\tloc += N-1;\n\n\t\ttable[row][loc] = value;\n\n\t\tif(N == 1)return;\n\n\t\tint parent = (loc-1)/2;\n\n\t\twhile(true){\n\t\t\ttable[row][parent] = min(table[row][2*parent+1],table[row][2*parent+2]);\n\n\t\t\tif(parent == 0)break;\n\t\t\telse{\n\t\t\t\tparent = (parent-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tint getN(){\n\t\treturn N;\n\t}\n\n\tint query(int row,int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t\tif(search_left <= node_left && search_right >= node_right){\n\t\t\treturn table[row][node_id];\n\t\t}\n\n\t\tint left_min = query(row,search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right_min = query(row,search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\t\treturn min(left_min,right_min);\n\t}\n\n\tint** table;\n\tint N,rmq_H;\n};\n\n\nint H,W,Q;\n\nvoid func(){\n\n\tint** input = new int*[H];\n\tfor(int row = 0; row < H; row++){\n\t\tinput[row] = new int[W];\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)scanf(\"%d\",&input[row][col]);\n\t}\n\n\tif(W >= H){\n\t\tRMQ YOKO(H,W);\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tYOKO.update(row,col,input[row][col]);\n\t\t\t}\n\t\t}\n\n\t\tint row1,col1,row2,col2;\n\t\tint ans;\n\n\t\tfor(int loop = 0; loop < Q; loop++){\n\t\t\tscanf(\"%d %d %d %d\",&row1,&col1,&row2,&col2);\n\n\t\t\tans = NUM;\n\n\t\t\tfor(int row = row1; row <= row2; row++){\n\t\t\t\tans = min(ans,YOKO.query(row,col1,col2,0,0,YOKO.getN()-1));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}else{\n\n\t\tRMQ TATE(W,H);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int row = 0; row < H; row++){\n\t\t\t\tTATE.update(col,row,input[row][col]);\n\t\t\t}\n\t\t}\n\n\t\tint row1,col1,row2,col2;\n\t\tint ans;\n\n\t\tfor(int loop = 0; loop < Q; loop++){\n\t\t\tscanf(\"%d %d %d %d\",&row1,&col1,&row2,&col2);\n\n\t\t\tans = NUM;\n\n\t\t\tfor(int col = col1; col <= col2; col++){\n\t\t\t\tans = min(ans,TATE.query(col,row1,row2,0,0,TATE.getN()-1));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&Q);\n\t\tif(H == 0 && W == 0 && Q == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=(1<<31)-1;\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvector< vector<int> > a(h,vector<int>(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tint h2=(int)(sqrt(h)+1),w2=(int)(sqrt(w)+1);\n\t\tvector< vector<int> > a2(h2,vector<int>(w2,INF));\n\t\trep(i,h2) rep(j,w2) {\n\t\t\tint t2=i*h2,b2=min((i+1)*h2,h),l2=j*w2,r2=min((j+1)*w2,w);\n\t\t\tfor(int y=t2;y<b2;y++) for(int x=l2;x<r2;x++) {\n\t\t\t\ta2[i][j]=min(a2[i][j],a[y][x]);\n\t\t\t}\n\t\t}\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\trep(i,h2) rep(j,w2) {\n\t\t\t\tint t2=i*h2,b2=min((i+1)*h2,h),l2=j*w2,r2=min((j+1)*w2,w);\n\t\t\t\tif(t<=t2 && b2<b && l<=l2 && r2<r){\n\t\t\t\t\tans=min(ans,a2[i][j]);\n\t\t\t\t}\n\t\t\t\telse if(b<=t2 || b2<=t || r<=l2 || r2<=l);\n\t\t\t\telse{\n\t\t\t\t\tfor(int y=max(t,t2);y<min(b,b2);y++){\n\t\t\t\t\t\tfor(int x=max(l,l2);x<min(r,r2);x++){\n\t\t\t\t\t\t\tans=min(ans,a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\n\t\t\t// int c=INF;\n\t\t\t// for(int y=t;y<b;y++) for(int x=l;x<r;x++) c=min(c,a[y][x]);\n\t\t\t// printf(\"> %d\\n\",c);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define TWO(x) (1ULL << x)\n\ntemplate<class T>\nclass seg_tree{\npublic:\n\tstatic const T invalid = TWO(31) - 1; // ?????¨??????????????????\n\nprivate:\n\tvector<T> dat;\tll n;\n\t\n\t// [a,b)????????????????°?????????????\n\t// k     : ?????¨??????????????\\????????????\n\t// [l,r) : k?????????????????????\n\tT query(ll a, ll b, ll k, ll l, ll r){\n\t\tif (r <= a || b <= l) return invalid; //?????????\n\t\tif (a <= l && r <= b) return dat[k]; //[l,r) ??? [a,b)\n\n\t\t//[l,r)????????¨???[a,b)???????????????\n\t\tll mid = (l + r) / 2; //[l,mid),[mid,r)\n\t\tT lval = query(a, b, k * 2 + 1, l, mid);\n\t\tT rval = query(a, b, k * 2 + 2, mid, r);\n\t\treturn min(lval, rval);\n\t}\n\t\n\tvoid propagate(ll i){ dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]); }\n\npublic:\n\tseg_tree(ll size){\n\t\tn = 1; while(n < size) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t}\n\n\tseg_tree(const vector<T> & v){\n\t\tn = 1; while(n < v.size()) n <<= 1;\n\t\tdat = vector<T>(2 * n - 1, invalid);\n\t\t\n\t\tREP(i, v.size()) dat[n - 1 + i] = v[i];\n\t\tREP(i, n-2) propagate((n-2) - i);\n\t}\n\t\n\tvoid update(ll k, T val){ // ??????????????£???`dat[k] = val`??¨????????????????????´\n\t\tk += n - 1; // seg_tree??????index?????????\n\t\tdat[k] = val;\n\t\twhile(k > 0) propagate(k = (k-1)/2);\n\t}\n\tT query(ll a, ll b) { return query(a, b, 0, 0, n); }\n};\n\n\n\nint main(){\n\twhile (true) {\n\t\tll r,c,q;\n\t\tcin >> r >> c >> q;\n\t\tif (q == 0) break;\n\n\t\tbool is_reverse = r > c;\n\t\tvector<seg_tree<ll>> segs(max(r,c), seg_tree<ll>(max(r,c)));\n\t\tREP(x, r) REP(y, c) {\n\t\t\tif (is_reverse) swap(x, y);\n\t\t\tll grid; cin >> grid;\n\t\t\tsegs[x].update(y, grid);\n\t\t}\n\n\n\t\tREP(i, q) {\n\t\t\tll minimum = seg_tree<ll>::invalid;\n\t\t\tll x_1, y_1, x_2, y_2;\n\t\t\tcin >> x_1 >> y_1 >> x_2 >> y_2;\n\t\t\tif (is_reverse) swap(x_1, y_1), swap(x_2, y_2);\n\t\t\tREP(i, x_2 + 1 - x_1) minimum = min(minimum, segs[x_1 + i].query(y_1, y_2 + 1));\n\t\t\tcout << minimum << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconst type INIT = INT_MAX;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tconst vector<type>& data() const {\n\t\treturn dat;\n\t}\n\n\tvoid merge(const segment_tree& s) {\n\t\tconst vector<type>& tmp = s.data();\n\t\tif(dat.size() != tmp.size()) return;\n\t\tfor(int i = 0; i < (int)dat.size(); ++i) {\n\t\t\tdat[i] = function(dat[i], tmp[i]);\n\t\t}\n\t}\n};\n\nclass segment_tree_2d {\nprivate:\n\tint n;\n\tvector<segment_tree> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int r1, int r2, int c1, int c2, int k, int l, int r) const {\n\t\tif(r <= r1 || r2 <= l)\n\t\t\treturn INIT;\n\n\t\tif(r1 <= l && r <= r2) {\n\t\t\treturn dat[k].query(c1, c2);\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(r1, r2, c1, c2, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(r1, r2, c1, c2, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree_2d(int r, int c) {\n\t\tn = 1;\n\t\twhile(n < r) n *= 2;\n\t\tdat.resize(2 * n - 1, segment_tree(c));\n\t}\n\n\tinline void update(int y, int x, type a) {\n\t\ty += n - 1;\n\t\tdat[y].update(x, a);\n\t}\n\n\tinline void revise() {\n\t\tfor(int i = n - 2; i >= 0; --i) {\n\t\t\tdat[i].merge(dat[i * 2 + 1]);\n\t\t\tdat[i].merge(dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int r1, int r2, int c1, int c2) const {\n\t\treturn query(r1, r2, c1, c2, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q, r;) {\n\t\tsegment_tree_2d seg(r, c);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tseg.update(i, j, in);\n\t\t\t}\n\t\t}\n\t\tseg.revise();\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vint;\nclass segtree{\n\tpublic:\n\tint w,h;\n\tvector<vint> data;\n\tsegtree(int h_,int w_){\n\t\tw=h=1;\n\t\twhile(w<w_)\tw<<=1;\n\t\twhile(h<h_)\th<<=1;\n\t\tdata.assign(2*h-1,vint(2*w-1,INT_MAX));\n\t}\n\tvoid update(){\n\t\tfor(int i=2*h-2;i>h-2;i--){\n\t\t\tfor(int j=w-2;j>=0;j--){\n\t\t\t\tdata[i][j]=min(data[i][2*j+1],data[i][2*j+2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tfor(int j=0;j<2*w-1;j++){\n\t\t\t\tdata[i][j]=min(data[2*i+1][j],data[2*i+2][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint minw(int sw,int tw,int hh,int l,int r,int k){\n\t\tif(sw<=l&&r<=tw)\treturn data[hh][k];\n\t\tif(r<=sw||tw<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minw(sw,tw,hh,l,mid,2*k+1),minw(sw,tw,hh,mid,r,2*k+2));\n\t}\n\tint minh(int sh,int sw,int th,int tw,int l,int r,int k){\n\t\tif(sh<=l&&r<=th)\treturn minw(sw,tw,k,0,w,0);\n\t\tif(r<=sh||th<=l)\treturn INT_MAX;\n\t\tint mid=(l+r)/2;\n\t\treturn min(minh(sh,sw,th,tw,l,mid,2*k+1),minh(sh,sw,th,tw,mid,r,2*k+2));\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint r,c,q;\tcin>>r>>c>>q;\n\t\tif(r+c+q==0)\treturn 0;\n\t\tsegtree seg(r,c);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\tcin>>a;\n\t\t\t\tseg.data[i+seg.h-1][j+seg.w-1]=a;\n\t\t\t}\n\t\t}\n\t\tseg.update();\n\t\twhile(q--){\n\t\t\tint sh,sw,th,tw;\tcin>>sh>>sw>>th>>tw;\n\t\t\tcout<<seg.minh(sh,sw,th+1,tw+1,0,seg.h,0)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Max=1000010;\n#define inf 0x7fffffff\nint ma[Max];\nint Log[Max];\nint rmq[Max*10];\nint K,r,c,q;\n\nvoid preRMQ(){\n\tK=Log[c]+2;\n\tfor(int i=0;i<r;i++){\n\t\tfor(int k=0;(1<<k)-1<c;k++){\n\t\t\tfor(int j=0;j + (1<<k) - 1<c;j++){\n\t\t\t\tif(k==0)\n\t\t\t\t\trmq[(i*K+k)*c+j]=ma[i*c+j];\n\t\t\t\telse\n\t\t\t\t\trmq[(i*K+k)*c+j]=min(rmq[(i*K+k-1)*c+j],rmq[(i*K+k-1)*c+j+(1<<k-1)]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint RMQ(int R,int i,int j){\n\tint k=Log[j-i+1];\n\treturn min(rmq[(R*K+k)*c+i],rmq[(R*K+k)*c+j-(1<<k)+1]);\n}\n\nint main()\n{\n\tLog[1]=0;\n\tfor(int i=2,x=1;i<1000000;i++){\n\t\tif(i>=(1<<x+1))\n\t\t\tx++;\n\t\tLog[i]=x;\n\t}\n\twhile(scanf(\"%d %d %d\",&r,&c,&q) == 3){\n\t\tif(r==0 && c==0 && q==0)\n\t\t\tbreak;\n\t\tint rr=r,cc=c;\n\t\tbool flag=false;\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tflag=true;\n\t\t}\n\t\tfor(int i=0;i<rr;i++){\n\t\t\tfor(int j=0;j<cc;j++){\n\t\t\t\tif(flag)\n\t\t\t\t\tscanf(\"%d\",&ma[j*c+i]);\n\t\t\t\telse\n\t\t\t\t\tscanf(\"%d\",&ma[i*c+j]);\n\t\t\t}\n\t\t}\n\t\tpreRMQ();\n\t\tint a1,a2,b1,b2;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tscanf(\"%d %d %d %d\",&a1,&a2,&b1,&b2);\n\t\t\tif(flag){\n\t\t\t\tswap(a1,a2);\n\t\t\t\tswap(b1,b2);\n\t\t\t}\n\t\t\tint ans=inf;\n\t\t\tfor(int j=a1;j<=b1;j++){\n\t\t\t\tans=min(ans,RMQ(j,a2,b2));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define la (rt*4)\n#define lb (rt*4+1)\n#define lc (rt*4+2)\n#define ld (rt*4+3)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\n\nint r, c, q;\n\nstruct seg\n{\n    int x1,y1,x2,y2;\n    int v;\n    int midx()\n    {\n        return (x1+x2)>>1;\n    }\n    int midy()\n    {\n        return (y1+y2)>>1;\n    }\n}tr[4000010];\nint map[1000010];\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1==x2 && y1==y2)\n    {\n        tr[rt].v = map[x1*c + y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n    }\n    else if(y1 == y2)\n    {\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n    }\n    else\n    {\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n    }\n    return;\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1)\n    {\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx)\n    {\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my)\n    {\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx)\n    {\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my)\n    {\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q)\n    {\n        for(int i = 0; i < r; ++i)\n            for(int j = 0; j < c; ++j)\n                scanf(\"%d\",&map[i*c + j]);\n\n        build(1,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i)\n        {\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(0,a,b,c,d));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint abs(int a,int b){\n\n  int result;\n\n  if(a<b)\n    result=b-a;\n  else\n    result=a-b;\n  return result;\n};\n\nint main(void){\n\n  int n;\n  int min=1000000;\n  int  temp;\n  \n  while(cin >> n,n!=0){\n\n    vector <int> student(n);\n    \n    for(int i=0;i<n;i++){\n      cin >> student[i];\n    }\n\n    sort(student.begin(),student.end());\n\n    for(int i=0;i<n-1;i++){\n      \n      temp=abs(student[i],student[i+1]);\n\n      if(min>temp)\n\tmin=temp;\n    }\n\n    cout << min <<endl;\n\n  }\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    // Å¬lðÔ·\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct Dense2DSegmentTree {\n  using T = int;\n  static T op(const T& a, const T& b) { return min(a, b); }\n  static constexpr T e() { return ~(~0 << 31); }\n\n  struct SegmentTree {\n    const int n;\n    V<T> t;\n    SegmentTree(int n) : n(n), t(2 * n, e()) {}\n    T& operator[](int i) { return t[i + n]; }\n    void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n    T acc(int l, int r) const {\n      T res = e();\n      for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n        if (l & 1) res = op(res, t[l++]);\n        if (r & 1) res = op(res, t[--r]);\n      }\n      return res;\n    }\n    void set(int i, const T& a) {\n      t[i += n] = a;\n      while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n  };\n  const int n;\n  V<SegmentTree> st;\n  Dense2DSegmentTree(int n, int m) : n(n), st(2 * n, SegmentTree(m)) {}\n  T acc(int x0, int x1, int y0, int y1) const {\n    T res = e();\n    for (x0 += n, x1 += n; x0 < x1; x0 >>= 1, x1 >>= 1) {\n      if (x0 & 1) res = op(res, st[x0++].acc(y0, y1));\n      if (x1 & 1) res = op(res, st[--x1].acc(y0, y1));\n    }\n    return res;\n  }\n  void set(int x, int y, const T& a) {\n    for (x += n; x; x >>= 1) st[x].set(y, op(st[x][y], a));\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int r, c, q; cin >> r >> c >> q;\n    if (!r) break;\n    Dense2DSegmentTree st(r, c);\n    for (int i = 0; i < r; ++i) for (int j = 0; j < c; ++j) {\n      int x; cin >> x;\n      st.set(i, j, x);\n    }\n    while (q--) {\n      int r0, c0, r1, c1; cin >> r0 >> c0 >> r1 >> c1, ++r1, ++c1;\n      cout << st.acc(r0, r1, c0, c1) << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int SQRT_N;\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    SQRT_N = 0;\n    while(SQRT_N*SQRT_N < W) SQRT_N++;\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(const int x, const int value) {\n    data[x] = value;\n    const int k = x / SQRT_N;\n    stat[k] = min(stat[k], data[x]);\n  }\n  int query(const int a, const int b) {\n    int ret = INF;\n    for(int k = a / SQRT_N; k < (b + SQRT_N - 1) / SQRT_N; ++k) {\n      const int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  int SQRT_N;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    SQRT_N = 0;\n    while(SQRT_N*SQRT_N < H) SQRT_N++;\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = y1 / SQRT_N; k < (y2 + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nint r, c, q;\nint _r, _c;\nint g;\nunsigned int _seg[11111111];\nvector<unsigned int*> seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg.resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        if(vl==0)\n            return 0;\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n        if(vr==0)\n            return 0;\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        if(vl==0)return 0;\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n        if(vr==0)return 0;\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tvector<vector<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif (ri <= si || ti <= li) return id;\n\t\tif (li <= si && ti <= ri) return sub_w(lj, rj, 0, w, k, 1);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn merge(sub_h(li, lj, ri, rj, si, mi, k * 2), sub_h(li, lj, ri, rj, mi, ti, k * 2 + 1));\n\t}\n\tT sub_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif (rj <= sj || tj <= lj) return id;\n\t\tif (lj <= sj && tj <= rj) return data[i][k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn merge(sub_w(lj, rj, sj, mj, i, k * 2), sub_w(lj, rj, mj, tj, i, k * 2 + 1));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), w(size(w_)), id(id_), merge(merge_), data(size(w_) * 2, vector<T>(size(h_) * 2, id_)) {}\n\tSegmentTree2(vector<vector<T>> data_, T id_, func_t merge_) :\n\t\th(size(data_.size())), w(size(data_.front().size())), id(id_), merge(merge_), data(h * 2, vector<T>(w * 2, id_)) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tfor (int j = 0; j < (int)data_.front().size(); j++)\n\t\t\t\tdata[h + i][w + j] = data_[i][j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i][j] = merge(data[i][j * 2], data[i][j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i][j] = merge(data[i * 2][j], data[i * 2 + 1][j]);\n\t}\n\t//void Update(int pi, int pj, T val) { }\n\t//void Add(int pi, int pj, T val) { }\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub_h(li, lj, ri + 1, rj + 1, 0, h, 1);\n\t}\n};\n\nint main()\n{\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> v(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st2(v, INT_MAX, [](int l, int r) { return min(l, r); });\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st2.Find(r1, c1, r2, c2) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconst type INIT = INT_MAX;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tconst vector<type>& data() const {\n\t\treturn dat;\n\t}\n\n\tvoid merge(const segment_tree& s) {\n\t\tconst vector<type>& tmp = s.data();\n\t\tif(dat.size() != tmp.size()) return;\n\t\tfor(int i = 0; i < (int)dat.size(); ++i) {\n\t\t\tdat[i] = function(dat[i], tmp[i]);\n\t\t}\n\t}\n};\n\nclass segment_tree_2d {\nprivate:\n\tint n;\n\tvector<segment_tree> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int r1, int r2, int c1, int c2, int k, int l, int r) const {\n\t\tif(r <= r1 || r2 <= l)\n\t\t\treturn INIT;\n\n\t\tif(r1 <= l && r <= r2) {\n\t\t\treturn dat[k].query(c1, c2);\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(r1, r2, c1, c2, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(r1, r2, c1, c2, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree_2d(int r, int c) {\n\t\tn = 1;\n\t\twhile(n < r) n *= 2;\n\t\tdat.resize(2 * n - 1, segment_tree(c));\n\t}\n\n\tinline void update(int y, int x, type a) {\n\t\ty += n - 1;\n\t\tdat[y].update(x, a);\n\n\t\twhile(y > 0) {\n\t\t\tconst int child = y;\n\t\t\ty = (y - 1) / 2;\n\t\t\tdat[y].merge(dat[child]);\n\t\t}\n\t}\n\n\tinline type query(int r1, int r2, int c1, int c2) const {\n\t\treturn query(r1, r2, c1, c2, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q, r;) {\n\t\tsegment_tree_2d seg(r, c);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tseg.update(i, j, in);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    モートン順序優秀だし、こんな意味不明な制約でなければもっと綺麗に書けていた...\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\n\n\nclass Seg2d {\npublic:\n    vector<unsigned int> grid;\n    int width;\n    int height;\n\n    inline int get_idx(int watchl, int watchr, int watchu, int watchd) {\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        if (hori == 0 || vert == 0) return -1;\n        return (watchu/vert) * width/hori + watchl/hori;\n    }\n\n    Seg2d (int sizex, int sizey) : width(sizex), height(sizey) {\n        long long int a = min(width, height);\n        long long int b = max(width, height);\n        long long int size = (4*a*a-1)/3 + 2*a*(b-a);\n\n        grid.resize(size, INF);\n    }\n    ~Seg2d() {grid.clear();}\n\n    void _update(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd, unsigned int x) {\n        int midx, midy;\n        unsigned int idx, idx1, idx2, idx3, idx4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (wishl == wishr || wishu == wishd) return;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            grid[base+get_idx(watchl, watchr, watchu, watchd)] = x;\n            return;\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd, x);\n        idx  = get_idx(watchl, watchr, watchu, watchd);\n        idx1 = get_idx(watchl, midx, watchu, midy);\n        idx2 = get_idx(midx, watchr, watchu, midy);\n        idx3 = get_idx(watchl, midx, midy, watchd);\n        idx4 = get_idx(midx, watchr, midy, watchd);\n        if (idx != -1) {\n            grid[base+idx] = INF;\n            if (idx1 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx1]);\n            if (idx2 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx2]);\n            if (idx3 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx3]);\n            if (idx4 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx4]);\n        }\n    }\n\n    void update(int x, int y, unsigned int t) {\n        _update(x, x+1, y, y+1, 0, 0, width, 0, height, t);\n    }\n\n    unsigned int _getMin(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (wishl == wishr || wishu == wishd) return INF;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return INF;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            return grid[base+get_idx(watchl, watchr, watchu, watchd)];\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        val1 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy);\n        val2 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy);\n        val3 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd);\n        val4 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd);\n        return min(min(val1, val2), min(val3, val4));\n    }\n\n    unsigned int getMin(int x1, int x2, int y1, int y2) { // [x1, x2) [y1, y2)\n        return _getMin(x1, x2, y1, y2, 0, 0, width, 0, height);\n    }\n};\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n    \n        Seg2d seg(sizex, sizey);\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                seg.update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", seg.getMin(c1, c2+1, r1, r2+1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 22;\nint r, c, q;\nint _r, _c;\nint g;\nint _seg[4 * SZ + 1];\nvector<int*> seg;\n//vi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n\n  /*\n  //delete[] seg;\n   //seg = new vi[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n  */\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst int INF=1000000000;\nvector<vector<int> > dc,dr;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nint query(vector<int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tint vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tdr.resize(c);\n\t\tc2=init(c)*2;\n\t\tr2=init(r)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tdr[i].resize(r2);\n\t\t\tfill(dr[i].begin(),dr[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t\tupdate(dr[j],i,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tint res=INF;\n\t\t\tif(y2-y<=x2-x){\n\t\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x;i<=x2;i++){\n\t\t\t\t\tres=min(res,query(dr[i],y,y2+1,0,0,dr[i].size()/2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tint dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INT_MAX;\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\t\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INT_MAX;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tst.Update(serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tint ans=INF;\n\t\tREP(y,r[0],r[1]+1) ans=min(ans,st.Query(serialize(y,c[0],C),serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = (long long)1e18;\nint H, W, Q;\n\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = y1 / SQRT_N; k < (y2 + SQRT_N - 1) / SQRT_N; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  int data[2 * 2 * 2 * 1000100];\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[1000100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\n\nint r,c,q;\nint r2,c2;\nconst int INF=100000000;\nvector<vector<int> > dc;\n\nint init(int k){\n\tint sz=1;\n\twhile(sz<k)sz*=2;\n\treturn sz;\n}\n\nvoid update(vector<int> &seg,int k,int a){\n\tk+=(seg.size()/2)-1;\n\tseg[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tseg[k]=min(seg[k*2+1],seg[k*2+2]);\n\t}\n}\n\nint query(vector<int> &seg,int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return INF;\n\tif(a<=l && r<=b)return seg[k];\n\telse{\n\t\tint vl=query(seg,a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(seg,a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(vl,vr);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&r,&c,&q);\n\t\tif(r==0 && c==0 && q==0)break;\n\t\tdc.resize(r);\n\t\tc2=init(c)*2;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tdc[i].resize(c2);\n\t\t\tfill(dc[i].begin(),dc[i].end(),INF);\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\tupdate(dc[i],j,a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint x,x2,y,y2;\n\t\t\tscanf(\"%d%d%d%d\",&y,&x,&y2,&x2);\n\t\t\tint res=INF;\n\t\t\tfor(int i=y;i<=y2;i++){\n\t\t\t\tres=min(res,query(dc[i],x,x2+1,0,0,dc[i].size()/2));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define N 10000\nint r,c,q;\nint input;\nvector<int> zu[1000];\nint aaa,bbb,aa,bb;\nint ans;\nint n;\nint ima;\nint dat[1000][4*N];\nvoid init(int n_)\n{\n\tn=1;\n\twhile(n<n_)n*=2;\n\trep(i,2*n-1)rep(j,1000)dat[j][i]=INF;\n}\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[ima][k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tdat[ima][k]=min(dat[ima][k*2+1],dat[ima][k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r)\n{\n\tif(r<=a||b<=l)return INF;\n\tif(a<=l&&r<=b)return dat[ima][k];\n\telse\n\t{\n\t\tint v1=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint v2=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(v1,v2);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,1000)zu[i].clear();\n\t\tcin>>r>>c>>q;\n\t\tif(r==0)break;\n\t\tif(r<=c)\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[i].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[j].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t}\n\t\t/*rep(i,r)\n\t\t{\n\t\t\trep(j,c)cout<<zu[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tinit(c);\n\t\t//cout<<\"n:\"<<n<<endl;\n\t\trep(i,r)\n\t\t{\n\t\t\tima=i;\n\t\t\trep(j,c)\n\t\t\t{\n\t\t\t\tupdate(j,zu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(kkk,q)\n\t\t{\n\t\t\tcin>>aaa>>bbb>>aa>>bb;\n\t\t\tans=INF;\n\t\t\trep2(i,aaa,aa+1)\n\t\t\t{\n\t\t\t\tima=i;\n\t\t\t\tcout<<query(bbb,bb+1,0,0,n)<<endl;\n\t\t\t\tans=min(ans,query(bbb,bb+1,0,0,n));\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        //dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000000;\n\nstruct segtree1 {\n\n\tvector<int> dat;\n\tint s;\n\t\n\tvoid init(int size)\n\t{\n\t\ts = 1;\n\t\twhile(s < size) s *= 2;\n\t\t\n\t\tdat.resize(s * 2, inf);\n\t}\n\t\n\tvoid set(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\t\n\t\tdat[pos] = v;\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos] = min(dat[pos * 2 + 0], dat[pos * 2 + 1]);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tvoid setmin(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\tif(dat[pos] > v)\n\t\t\tset(x, v);\n\t}\n\t\n\tint getmin(int a, int b, int l, int r, int idx)\n\t{\n\t\tif(b <= l || r <= a) return inf;\n\t\t\n\t\tif(a <= l && r <= b) {\n\t\t\n\t\t\treturn dat[idx];\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(a, b, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(a, b, m, r, idx * 2 + 1));\n\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int a, int b)\n\t{\n\t\treturn getmin(a, b, 0, s, 1);\n\t}\n};\n\nstruct segtree2 {\n\t\n\tvector<segtree1> dat;\n\tint w, h;\n\t\n\tvoid init(int width, int height)\n\t{\n\t\tw = 1;\n\t\twhile(w < width) w *= 2;\n\t\t\n\t\th = 1;\n\t\twhile(h < height) h *= 2;\n\t\t\n\t\tdat.resize(h * 2);\n\t\tfor(int i = 0; i < h * 2; ++i)\n\t\t\tdat[i].init(w);\n\t}\n\t\n\tvoid set(int x, int y, int v)\n\t{\n\t\tint pos = h + y;\n\t\t\n\t\tdat[pos].set(x, v);\n\t\tpos = pos / 2;\n\t\t\n\t\twhile(pos > 0) {\n\t\t\n\t\t\tdat[pos].setmin(x, v);\n\t\t\tpos = pos / 2;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by, int l, int r, int idx)\n\t{\n\t\tif(by <= l || r <= ay) return inf;\n\t\t\n\t\tif(ay <= l && r <= by) {\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, dat[idx].getmin(ax, bx));\n\t\t\treturn dat[idx].getmin(ax, bx);\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, m, r, idx * 2 + 1));\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by)\n\t{\n\t\treturn getmin(ax, ay, bx, by, 0, h, 1);\n\t}\n};\n\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint r, c, q;\n\t\tsegtree2 st;\n\t\t\n\t\tscanf(\"%d%d%d\", &r, &c, &q);\n\t\t\n\t\tif(r == 0 && c == 0 && q == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tst.init(r, c);\n\t\t\n\t\tfor(int x = 0; x < r; ++x) {\n\t\t\tfor(int y = 0; y < c; ++y) {\n\t\t\t\n\t\t\t\tint v;\n\t\t\t\t\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\t\n\t\t\t\tst.set(x, y, v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\n\t\t\tint r1, c1, r2, c2;\n\t\t\t\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\t\n\t\t\tint ans = st.getmin(r1, c1, r2 + 1, c2 + 1);\n\t\t\t\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nbool swaped;\n\nstruct pool {\n    void * dat;\n    int end;\n    pool(int size){\n        dat = malloc(size);\n        end = 0;\n    }\n    ~pool(){\n        free(dat);\n    }\n    void * fetch(int size){\n        void * res = (char*)dat + end;\n        end+=size;\n        return res;\n    }\n    void reset(){\n        end = 0;\n    }\n};\n\npool mem_pool(sizeof(char)*1024*1024*50);\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        if(swaped) swap(x,y);\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        if(r>c) swaped = true;\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        mem_pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n//\tvector<int> seg;\n\tint *seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = (int*)malloc(sizeof(int) * (nodeSize+segSize));\n\t\tfill(&seg[0], &seg[0]+nodeSize+segSize, INF);\n//\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\treturn seg[n];\n//\t\tif (n < (int)seg.size()) return seg[n];\n//\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tseg[n] = v;\n//\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n\n\t~SegTree() {\n\t\tfree(seg);\n\t\t//seg.clear();\n\t\t//seg.shrink_to_fit();\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tseg.clear();\n\t\tseg.shrink_to_fit();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    頭が悪いので頭悪夫です\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\nvector<vector<unsigned int> > grid;\n\nvoid update(int x, int y, int t) {\n    x += sizex-1;\n    y += sizey-1;\n\n    grid[y][x] = t;\n    while (y >= 0) {\n        int x_ = x;\n\n        while (x_ > 0) {\n            x_ = (x_-1)/2;\n            grid[y][x_] = min(grid[y][x_*2+1], grid[y][x_*2+2]);\n        }\n        if (y == 0) break;\n\n        y = (y-1)/2;\n        grid[y][x] = min(grid[y*2+1][x], grid[y*2+2][x]);\n    }\n}\n\nunsigned int _get_min(vector<unsigned int> &vec, int wishl, int wishr, int k, int watchl, int watchr) {\n    int mid;\n    unsigned int lval, rval;\n\n    if (wishr <= watchl || watchr <= wishl) return INF;\n    if (wishl <= watchl && watchr <= wishr) return vec[k];\n\n    mid = (watchl+watchr)/2;\n    lval = _get_min(vec, wishl, wishr, k*2+1, watchl, mid);\n    rval = _get_min(vec, wishl, wishr, k*2+2, mid, watchr);\n    return min(lval, rval);\n}\n\nunsigned int get_min(int wishl, int wishr, int wishu, int wishd, int k, int watchu, int watchd) {\n    int mid;\n    unsigned int uval, dval;\n\n    if (wishd <= watchu || watchd <= wishu) return INF;\n    if (wishu <= watchu && watchd <= wishd) return _get_min(grid[k], wishl, wishr, 0, 0, sizex);\n\n    mid = (watchu+watchd)/2;\n    uval = get_min(wishl, wishr, wishu, wishd, k*2+1, watchu, mid);\n    dval = get_min(wishl, wishr, wishu, wishd, k*2+2, mid, watchd);\n    return min(uval, dval);\n}\n    \nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n        grid.resize(sizey*2-1);\n        for (int i=0; i<sizey*2-1; i++) grid[i].resize(sizex*2-1);\n    \n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", get_min(c1, c2+1, r1, r2+1, 0, 0, sizey));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <list>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m,Q;\n#define maxn 2100000\ninline void zy(int &a,int b)\n{\n\tif(b<a)a=b;\n}\nstruct Node{\n\tint mn;\n\tint x1,x2,y1,y2;\n\tNode *lu,*ld,*ru,*rd;\n\tvoid init(int _x1,int _x2,int _y1,int _y2){\n\t\tx1=_x1,x2=_x2;\n\t\ty1=_y1,y2=_y2;\n\t\tlu=ld=ru=rd=NULL;\n\t\tmn=1e9;\n\t}\n\tinline void update(){\n\t\tmn=1e9;\n\t\tif( lu ) zy(mn,lu->mn);\n\t\tif( ld ) zy(mn,ld->mn);\n\t\tif( ru ) zy(mn,ru->mn);\n\t\tif( rd ) zy(mn,rd->mn);\n\t}\n}dd[maxn],*root;\nint e; \nNode* _alloc(int x1,int x2,int y1,int y2){\n\tif(e>maxn-10)exit(1);\n\tdd[e].init(x1,x2,y1,y2); return &dd[e++];\n}\nvoid insert(Node *p,int x,int y,int g){\n\tif( p->x1==p->x2 && p->y1==p->y2 ) {\n\t\tp->mn=g;\n\t\treturn;\n\t}\n\tint midx=(p->x1+p->x2)/2;\n\tint midy=(p->y1+p->y2)/2;\n\tif( x<=midx && y>midy ) {\n\t\tif( p->lu==NULL ) p->lu=_alloc(p->x1,midx,midy+1,p->y2);\n\t\tinsert(p->lu,x,y,g);\n\t}else if( x<=midx && y<=midy ){\n\t\tif( p->ld==NULL ) p->ld=_alloc(p->x1,midx,p->y1,midy);\n\t\tinsert(p->ld,x,y,g);\n\t}else if( x>midx && y>midy ){\n\t\tif( p->ru==NULL ) p->ru=_alloc(midx+1,p->x2,midy+1,p->y2);\n\t\tinsert(p->ru,x,y,g);\n\t}else{\n\t\tif( p->rd==NULL ) p->rd=_alloc(midx+1,p->x2,p->y1,midy);\n\t\tinsert(p->rd,x,y,g);\n\t}\n\tp->update();\n}\nint query(Node *p,int x1,int x2,int y1,int y2){\n\tif( p==NULL ) return 1e9;\n\tx1=max(x1,p->x1);\n\ty1=max(y1,p->y1);\n\tx2=min(x2,p->x2);\n\ty2=min(y2,p->y2);\n\tif( x1>x2 || y1>y2 ) return 1e9;\n\n\tif( x1==p->x1 && x2==p->x2 && y1==p->y1 && y2==p->y2 ) return p->mn;\n\treturn min(query(p->lu,x1,x2,y1,y2) ,min( query(p->ld,x1,x2,y1,y2),(min(\n\t\tquery(p->ru,x1,x2,y1,y2) , query(p->rd,x1,x2,y1,y2)))));\n}\n\nint main()\n{\n\twhile(cin>>n>>m>>Q&&n)\n\t{\n\t\te=0;\n\t\tdd[e].init(0,n-1,0,m-1); //32768=2^31\n\t\troot=&dd[e++];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int q=0;q<m;q++)\n\t\t\t{\n\t\t\t\tint z;\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\tinsert(root,i,q,z);\n\t\t\t}\n\t\twhile(Q--)\n\t\t{\n\t\t\tint x1,x2,y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",query(root,x1,x2,y1,y2));\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W, H_, W_;\n\tint dat[9000000];\n\tsegtree() {}\n\tsegtree(vector<vector<int>> &f) {\n\t\tinit(f);\n\t}\n\tint x(int i, int j) {\n\t\treturn i * W_ + j;\n\t}\n\n\tvoid init(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tH_ = 2 * H - 1, W_ = 2 * W - 1;\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[x(i + H - 1, j + W - 1)] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[x(i, j)] = min(dat[x(i, 2 * j + 1)], dat[x(i, 2 * j + 2)]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[x(i, j)] = min(dat[x(2 * i + 1, j)], dat[x(2 * i + 2, j)]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[x(i, k)];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nvector<vector<int>> f;\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tf.assign(r, vector<int>(c, 0));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<vector<int> > dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\nif((r*2-1)*(c*2-1)>8388608)throw 1;\n\t\tdat.assign(r * 2 - 1, vector<int>(c * 2 - 1, INT_MAX) );\n\t\tvector<int> datr = dat[0];\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1].begin());\n\t\t}\n\n\t\tfor(int j = 0; j < datr.size(); ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\tbool sw = (w < h);\n\t\tif (sw) swap(w, h);\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tif (sw){\n\t\t\t\tswap(r1, c1);\n\t\t\t\tswap(r2, c2);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1LL<<31)-1;\n\nclass KDRMQ{\nprivate:\n    int H, W;\n    vector<vector<int>> data;\npublic:\n    KDRMQ(int _H, int _W){\n        H = 1, W = 1;\n        while(H<_H) H <<= 1;\n        while(W<_W) W <<=1;\n        data.assign(2*H-1, vector<int>(2*W-1, INF));\n    }\n    void update(int h, int w, int x){\n        h += H-1;\n        w += W-1;\n        data[h][w] = x;\n        \n        for(int th=h; th>=0; th=(th-1)/2){\n            for(int tw=w; tw>0; tw=(tw-1)/2){\n                int pw = (tw-1)/2;\n                data[th][pw] = min(data[th][pw*2+1], data[th][pw*2+2]);\n            }\n            if(th == 0)\n                break;\n            int ph = (th-1)/2;\n            data[ph][w] = min(data[ph*2+1][w], data[ph*2+2][w]);\n        }\n    }\n    int find_w(int a, int b, int k, int l, int r, int kh){\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return data[kh][k];\n        return min(find_w(a, b, 2*k+1, l, (l+r)/2, kh), find_w(a, b, 2*k+2, (l+r)/2, r, kh));\n    }\n    int find_h(int a, int b, int k, int l, int r, int w1, int w2){\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return find_w(w1, w2, 0, 0, W, k);\n        return min(find_h(a, b, 2*k+1, l, (l+r)/2, w1, w2), find_h(a, b, 2*k+2, (l+r)/2, r, w1, w2));\n    }\n    int find(int h1, int w1, int h2, int w2){\n        return find_h(h1, h2, 0, 0, H, w1, w2);\n    }\n};\n\nint main(){\n    int h, w, q;\n    while(cin >> h >> w >> q, h|w|q){\n        KDRMQ kdrmq(h, w);\n        \n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                int x; cin >> x;\n                kdrmq.update(i, j, x);\n            }\n        }\n        for(int i=0; i<q; i++){\n            int h1, w1, h2, w2;\n            cin >> h1 >> w1 >> h2 >> w2; h2++; w2++;\n            cout << kdrmq.find(h1, w1, h2, w2) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint** segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i-1][j-1];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a-1][d-1]=min(segtree[a-1][d-1],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=new int*[n+a-1];\n\t\tfor(int i=0;i<n+a-1;i++){\n\t\t\tsegtree[i]=new int[m+b-1];\n\t\t\tfor(int j=0;j<m+b-1;j++)segtree[i][j]=2147483647;\n\t\t}\n\t//\tsegtree=vector<vector<int> >(n+a,vector<int>(m+b,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t\tfor(int i=0;i<n+a-1;i++)delete[] segtree[i];\n\t\tdelete[] segtree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nstruct SegTree {\n\tint segSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<int>(segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tSegTree s;\n\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate<class T>\nclass RMQ {\nprivate:\n\tvector<T> dat;\n\tT inf;\n\tint n;\npublic:\n\tRMQ(int n_, T inf_){\n\t\tn = 1;\n\t\tinf = inf_;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, inf);\t\n\t}\n\tvoid update(int k, T a){\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b){\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\tT at(int k){\n\t\treturn dat[k + n - 1];\n\t}\nprivate:\n\tT query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l)return inf;\n\t\tif(a <= l && r <= b)return dat[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n};\n\ntemplate<class T>\nclass RMQ2D {\nprivate:\n\tvector<RMQ<T>> dat;\n\tT inf;\n\tint h;\npublic:\n\tRMQ2D(int h_, int w, T inf_){\n\t\th = 1;\n\t\tinf = inf_;\n\t\twhile(h < h_) h *= 2;\n\t\tdat.resize(2 * h - 1, RMQ<T>(w, inf));\n\t}\n\tvoid update(int y, int x, T a){\n\t\ty += h - 1;\n\t\tdat[y].update(x, a);\n\t\twhile(y > 0){\n\t\t\ty = (y - 1) / 2;\n\t\t\tdat[y].update(x, min(dat[2 * y + 1].at(x), dat[2 * y + 2].at(x)));\n\t\t}\n\t}\n\t// [y1, y2) * [x1, x2)\n\tT query(int y1, int y2, int x1, int x2){\n\t\treturn query(y1, y2, x1, x2, 0, 0, h);\n\t}\n\tT at(int y, int x){\n\t\treturn dat[y + h - 1].at(x);\n\t}\nprivate:\n\tT query(int y1, int y2, int x1, int x2, int k, int ys, int yt){\n\t\tif(yt <= y1 || y2 <= ys)return inf;\n\t\tif(y1 <= ys && yt <= y2)return dat[k].query(x1, x2);\n\t\tT v1 = query(y1, y2, x1, x2, k * 2 + 1, ys, (ys + yt) / 2);\n\t\tT v2 = query(y1, y2, x1, x2, k * 2 + 2, (ys + yt) / 2, yt);\n\t\treturn min(v1, v2);\n\t}\n};\n\nint main(){\n\tint h, w, q;\n\tfor(;;){\n\t\tscanf(\"%d %d %d\", &h, &w, &q);\n\t\tif(h == 0)break;\n\n\t\tRMQ2D<int> rmq2d(h, w, (1ll << 31) - 1);\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tint v;\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\trmq2d.update(y, x, v);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", rmq2d.query(y1, y2 + 1, x1, x2 + 1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        if(dat[k*2+1]>dat[k*2+2])dat[k]=dat[k*2+2];\n        else dat[k]=dat[k*2+1];\n        //dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    //return min(vl,vr);\n    if(vl>vr)return vr;\n    return vl;\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n\nstruct SegTree {\n\tint segSize, realSegSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<int>(segSize-1+realSegSize, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tset(n, min(seg[n*2+1], seg[n*2+2]));\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <climits>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define INF INT_MAX\ntypedef unsigned int uint;\nint in() {\n    int x = 0, c;\n    for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; }\n    do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10);\n    return x;\n}\n \nvector< vector<int> > one , two;\n \nvoid put(vector<int> &s,int x,int v){\n    x += s.size()/2-1;\n    while(x){\n        s[x] = min(v,s[x]);\n        x /= 2;\n    }\n}\nint get(vector<int> &s,int l,int r,int k,int a,int b){\n    //cout << a << \" \" << b << \" \" << s.size() << \" \" << endl;\n    if(l==a && r==b) return s[k];\n    if(b < l || r < a) return INF;\n    return min(get(s,l,min((a+b)/2,r),k*2,a,(a+b)/2),get(s,max((a+b+1)/2,l),r,k*2+1,(a+b+1)/2,b));\n}\n \nint gen(int n){\n    int ans = 1;\n    while(ans < n) ans *= 2;\n    return ans;\n}\n \nint main(){\n    int H,W,Q;\n    while(H = in() , W = in() , Q = in() , H){\n        one.resize(H+1);\n        two.resize(W+1);\n        int hH = gen(H) , wW = gen(W);\n        for(int i = 1 ; i <= H ; i++){\n            one[i].resize(2*wW+1);\n            fill(one[i].begin(),one[i].end(),INF);\n        }\n        for(int i = 1 ; i <= W ; i++){\n            two[i].resize(2*hH+1);\n            fill(two[i].begin(),two[i].end(),INF);\n        }\n        for(int i = 1 ; i <= H ; i++)\n            for(int j = 1 ; j <= W ; j++){\n                int a; a = in();\n                put(one[i],j,a);\n                put(two[j],i,a);\n            }\n        for(int i = 0 ; i < Q ; i++){\n            int y1 = in() , x1 = in() , y2 = in() , x2 = in();\n            x1++,y1++,x2++,y2++;\n            if(x2-x1 >= y2-y1){\n                int ans = INT_MAX;\n                for(int j = y1 ; j <= y2 ; ++j) ans = min( ans , get(one[j],x1,x2,1,1,wW) );\n                printf(\"%d\\n\",ans);\n            }else{\n                int ans = INT_MAX;\n                for(int j = x1 ; j <= x2 ; ++j) ans = min( ans , get(two[j],y1,y2,1,1,hH) );\n                printf(\"%d\\n\",ans);\n            }\n        }\n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint tree[16450000];\n\nvoid build(int x,int y,int num,int lx,int rx,int ly,int ry,int pos)\n{\n    if(lx==rx&&ly==ry)\n    {\n        tree[pos]=num;\n        return;\n    }\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    if(x<=midx&&y<=midy)\n    {\n        build(x,y,num,lx,midx,ly,midy,pos*4);\n        if(tree[pos]==-1||tree[pos*4]<tree[pos])\n            tree[pos]=tree[pos*4];\n    }\n    if(x<=midx&&y>midy&&ly!=ry)\n    {\n        build(x,y,num,lx,midx,midy+1,ry,pos*4+1);\n        if(tree[pos]==-1||tree[pos*4+1]<tree[pos])\n            tree[pos]=tree[pos*4+1];\n    }\n    if(x>midx&&y<=midy&&lx!=rx)\n    {\n        build(x,y,num,midx+1,rx,ly,midy,pos*4+2);\n        if(tree[pos]==-1||tree[pos*4+2]<tree[pos])\n            tree[pos]=tree[pos*4+2];\n    }\n    if(x>midx&&y>midy&&lx!=rx&&ly!=ry)\n    {\n        build(x,y,num,midx+1,rx,midy+1,ry,pos*4+3);\n        if(tree[pos]==-1||tree[pos*4+3]<tree[pos])\n            tree[pos]=tree[pos*4+3];\n    }\n    return;\n}\n\nint query(int x,int y,int xx,int yy,int lx,int rx,int ly,int ry,int pos)\n{\n    if(x<=lx&&xx>=rx&&y<=ly&&yy>=ry)\n        return tree[pos];\n    if(lx==rx&&ly==ry)\n        return tree[pos];\n    int midx=(lx+rx)/2,midy=(ly+ry)/2;\n    int now=-1,temp;\n    if(x<=midx&&y<=midy)\n    {\n        temp=query(x,y,xx,yy,lx,midx,ly,midy,pos*4);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    if(x<=midx&&yy>midy&&ly!=ry)\n    {\n        temp=query(x,y,xx,yy,lx,midx,midy+1,ry,pos*4+1);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    if(xx>midx&&y<=midy&&lx!=rx)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,ly,midy,pos*4+2);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    if(xx>midx&&yy>midy&&lx!=rx&&ly!=ry)\n    {\n        temp=query(x,y,xx,yy,midx+1,rx,midy+1,ry,pos*4+3);\n        if((temp!=-1)&&(now==-1||temp<now))\n            now=temp;\n    }\n    printf(\"%d %d %d %d %d %d %d %d %d\\n\",x,y,xx,yy,lx,rx,ly,ry,now);\n    return now;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out1.txt\",\"w\",stdout);\n    int n,m,q,i,j,x,y,xx,yy;\n    while(scanf(\"%d%d%d\",&n,&m,&q)==3)\n    {\n        if(!n&&!m&&!q)\n            break;\n        memset(tree,-1,sizeof(tree));\n        for(i=1;i<=n;i++)\n            for(j=1;j<=m;j++)\n            {\n                scanf(\"%d\",&x);\n                build(i,j,x,1,n,1,m,1);\n            }\n        while(q--)\n        {\n            scanf(\"%d%d%d%d\",&x,&y,&xx,&yy);\n            printf(\"%d\\n\",query(x+1,y+1,xx+1,yy+1,1,n,1,m,1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {\n\t            for (int k = y1; k <= y2; k++){\n    \t        \tans = min(ans, query(k * w + x1, k * w + x2 + 1, 0, 0, n));\n        \t    }\n            \tprintf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 1000000 + 40;\n\nint r, c, q;\nint t[maxn * 4], a[maxn];\n\ninline int to(int x, int y, int c) {\n    return x * c + y;\n}\nint build(int x, int n, int lf, int rt) {\n    if (lf == rt) {\n        return t[to(x, n, c * 4)] = a[to(x, lf, c)];\n    }\n    int mid = (lf + rt) / 2;\n    return t[to(x, n, c * 4)] = min(build(x, n * 2, lf, mid), build(x, n * 2 + 1, mid + 1, rt));\n}\n\nint query(int x, int n, int lf, int rt, int x1, int x2) {\n    //printf(\"%d %d\\n\", x1, x2);\n    if (lf == x1 && rt == x2) {\n        //printf(\"%d %d %d: %d\\n\", x, n, c * 4, to(x, n, c * 4));\n        return t[to(x, n, c * 4)];\n    }\n    int mid = (lf + rt) / 2;\n    if (mid >= x2) {\n        return query(x, n * 2, lf, mid, x1, x2);\n    } else if (mid < x1) {\n        return query(x, n * 2 + 1, mid + 1, rt, x1, x2);\n    }\n    return min(query(x, n * 2, lf, mid, x1, mid), query(x, n * 2 + 1, mid + 1, rt, mid + 1, x2));\n}\n\nvoid gao() {\n    bool f = false;\n    if (r > c) {\n        swap(r, c);\n        f = true;\n        for (int i = 0; i < c; ++i) {\n            for (int j = 0; j < r; ++j) {\n                scanf (\"%d\", &a[to(j, i, c)]);\n            }\n        }\n    } else {\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                scanf (\"%d\", &a[to(i, j, c)]);\n            }\n        }\n    }\n    for (int i = 0; i < r; ++i) {\n        build(i, 1, 0, c - 1);\n    }\n    while (q--) {\n        int r1, c1, r2, c2;\n        scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n        if (f) swap(r1, c1), swap(r2, c2);\n        int ans = query(r1, 1, 0, c - 1, c1, c2);\n        for (int i = r1+1; i <= r2; ++i) {\n            ans = min(ans, query(i, 1, 0, c - 1, c1, c2));\n        }\n        printf (\"%d\\n\", ans);\n    }\n}\n\nint main() {\n    while (scanf (\"%d%d%d\", &r, &c, &q), r || c || q) {\n        gao();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <climits>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define INF INT_MAX\ntypedef unsigned int uint;\nint in() {\n    int x = 0, c;\n    for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; }\n    do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10);\n    return x;\n}\n\nvector< vector<int> > one , two;\n\nvoid put(vector<int> &s,int x,int v){\n\tx += s.size()/2-1;\n\twhile(x){\n\t\ts[x] = min(v,s[x]);\n\t\tx /= 2;\n\t}\n}\nint get(vector<int> &s,int l,int r,int k,int a,int b){\n\t//cout << a << \" \" << b << \" \" << s.size() << \" \" << endl;\n\tif(l==a && r==b) return s[k];\n\tif(b < l || r < a) return INF;\n\treturn min(get(s,l,min((a+b)/2,r),k*2,a,(a+b)/2),get(s,max((a+b+1)/2,l),r,k*2+1,(a+b+1)/2,b));\n}\n\nint gen(int n){\n\tint ans = 1;\n\twhile(ans < n) ans *= 2;\n\treturn ans;\n}\n\nint main(){\n\tint H,W,Q;\n\twhile(H = in() , W = in() , Q = in() , H){\n\t\tone.resize(H+1);\n\t\ttwo.resize(W+1);\n\t\tint hH = gen(H) , wW = gen(W);\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tone[i].resize(2*wW+1);\n\t\t\tfill(one[i].begin(),one[i].end(),INF);\n\t\t}\n\t\tfor(int i = 1 ; i <= W ; i++){\n\t\t\ttwo[i].resize(2*hH+1);\n\t\t\tfill(two[i].begin(),two[i].end(),INF);\n\t\t}\n\t\tfor(int i = 1 ; i <= H ; i++)\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tint a; a = in();\n\t\t\t\tput(one[i],j,a);\n\t\t\t\tput(two[j],i,a);\n\t\t\t}\n\t\tfor(int i = 0 ; i < Q ; i++){\n\t\t\tint y1 = in() , x1 = in() , y2 = in() , x2 = in();\n\t\t\tx1++,y1++,x2++,y2++;\n\t\t\tif(x2-x1 >= y2-y1){\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int j = y1 ; j <= y2 ; ++j) ans = min( ans , get(one[j],x1,x2,1,1,wW) );\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}else{\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tfor(int j = x1 ; j <= x2 ; ++j) ans = min( ans , get(two[j],y1,y2,1,1,hH) );\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint _query(int G, int x1, int x2, int k = 0, int l = 0, int r = wbin)\n{\n\tif (x2 <= l || r <= x1) return (INT_MAX);\n\tif (x1 <= l && r <= x2) return (seg[G][k]);\n\t\n\tint lval = _query(G, x1, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(G, x1, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int y1, int x1, int y2, int x2, int k = 0, int l = 0, int r = hbin)\n{\n\tif (y2 <= l || r <= y1) return (INT_MAX);\n\tif (y1 <= l && r <= y2) return (_query(k, x1, x2));\n\t\n\tint lval = query(y1, x1, y2, x2, k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(y1, x1, y2, x2, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query(y1, x1, y2 + 1, x2 + 1));\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//\n#include<vector>\n#include<climits>\n#include<algorithm>\n//\nconst int NIL = -1;\nconst int INF = INT_MAX;\n//\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int min_x, int min_y, int max_x, int max_y, int value);\n  int query(int min_x, int min_y, int max_x, int max_y) const;\nprivate:\n  void update(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int value);\n  int query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const;\n  int size_x_, size_y_;\n  std::vector<int> node_;\n};\n//\nSegmentTree::SegmentTree(int x, int y) : size_x_(x), size_y_(y) {\n  while(x & x - 1) x += x & -x;\n  while(y & y - 1) y += y & -y;\n  node_.assign(x * y << 4, INF);\n}\n//\nvoid SegmentTree::update(int min_x, int min_y, int max_x, int max_y, int value) {\n  update(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y, value);\n}\nvoid SegmentTree::update(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y, int value) {\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return;\n  node_[index] = std::min(node_[index], value);\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return;\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    update(low_x, low_y, high_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n    update(low_x, middle_y + 1, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n    return;\n  }\n  if(low_y == high_y) {\n    update(low_x, low_y, middle_x, high_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n    update(middle_x + 1, low_y, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n    return;\n  }\n  update(low_x, low_y, middle_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y, value);\n  update(low_x, middle_y + 1, middle_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y, value);\n  update(middle_x + 1, low_y, high_x, middle_y, (index << 2) + 3, min_x, min_y, max_x, max_y, value);\n  update(middle_x + 1, middle_y + 1, high_x, high_y, (index << 2) + 4, min_x, min_y, max_x, max_y, value);\n}\n//\nint SegmentTree::query(int min_x, int min_y, int max_x, int max_y) const {\n  query(0, 0, size_x_ - 1, size_y_ - 1, 0, min_x, min_y, max_x, max_y);\n}\nint SegmentTree::query(int low_x, int low_y, int high_x, int high_y, int index, int min_x, int min_y, int max_x, int max_y) const {\n//   cout << low_x << \",\" << low_y << \":\" << high_x << \",\" << high_y << \"        \" << index << \":\" << node_[index] << endl;\n  if(max_x < low_x || high_x < min_x || max_y < low_y || high_y < min_y) return INF;\n  if(min_x <= low_x && high_x <= max_x && min_y <= low_y && high_y <= max_y) return node_[index];\n  int middle_x = (low_x + high_x) >> 1;\n  int middle_y = (low_y + high_y) >> 1;\n  if(low_x == high_x) {\n    int l = query(low_x, low_y, high_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n    int h = query(low_x, middle_y + 1, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  }\n  if(low_y == high_y) {\n    int l = query(low_x, low_y, middle_x, high_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n    int h = query(middle_x + 1, low_y, high_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n    return std::min(l, h);\n  }\n  int ll = query(low_x, low_y, middle_x, middle_y, (index << 2) + 1, min_x, min_y, max_x, max_y);\n  int lh = query(low_x, middle_y + 1, middle_x, high_y, (index << 2) + 2, min_x, min_y, max_x, max_y);\n  int hl = query(middle_x + 1, low_y, high_x, middle_y, (index << 2) + 3, min_x, min_y, max_x, max_y);\n  int hh = query(middle_x + 1, middle_y + 1, high_x, high_y, (index << 2) + 4, min_x, min_y, max_x, max_y);\n  return std::min({ll, lh, hl, hh});\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, x, y, grid);\n    }\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.query(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    if(h>w)w=h;\n    if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        //if(dat[k*2+1]!=-1&&dat[k*2+1]<dat[k*2+2])dat[k]=dat[k*2+1];\n        //else dat[k]=dat[k*2+2];\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",(int)res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n\tint Need(int size){\n\t\tsize--;\n\t\trep(i,5) size|=size>>(1<<i);\n\t\treturn size+1;\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid;\n\t\tif(r<=c){\n\t\t\tgrid.assign(r,vi(c));\n\t\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t}\n\t\telse{\n\t\t\tgrid.assign(c,vi(r));\n\t\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[j][i]);\n\t\t}\n\t\t\n\t\tvector<SegTree> sts(r,SegTree(c));\n\t\trep(i,r) rep(j,c) sts[i].Update(j,grid[i][j]);\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tint res=INFTY;\n\t\t\tif(r<=c)\n\t\t\t\trepi(i,r1,r2+1) res=min(res,sts[i].Query(c1,c2+1));\n\t\t\telse\n\t\t\t\trepi(i,c1,c2+1) res=min(res,sts[i].Query(r1,r2+1));\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <stdio.h>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <map>\nusing namespace std;\n\n#define ll long long\n#define FOR(i,j,k) for(int i=j;i<=(k);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define base 10009\n#define maxn 10000009\n#define F(x,y) ((x)*m+y)\n\nint a[maxn],n,m,q,l[base],r[base],ans[base],b[maxn];\nvector <int> edge[maxn];\n\nstruct Node{\n    int l,r,ans;\n}tree[1000009];\nvoid Build(int u,int l,int r){\n    tree[u].l=l;\n    tree[u].r=r;\n    if(l==r){\n        tree[u].ans=b[l];\n        return ;\n    }\n    int mid=(l+r)/2;\n    Build(u*2,l,mid);\n    Build(u*2+1,mid+1,r);\n    tree[u].ans=min(tree[u*2].ans,tree[u*2+1].ans);\n}\nint Find(int u,int l,int r){\n    if(tree[u].l==l&&tree[u].r==r) return tree[u].ans;\n    int mid=(tree[u].l+tree[u].r)/2;\n    if(r<=mid) return Find(u*2,l,r);\n    else if(l>mid) return Find(u*2+1,l,r);\n    else return min(Find(u*2,l,mid),Find(u*2+1,mid+1,r));\n}\n\nint main(){\n    while(cin>>n>>m>>q){\n        if(!n&&!m&&!q) break;\n        bool flag=0;\n        if(n>m) flag=1;\n        REP(i,n)REP(j,m) {\n            int t;\n            scanf(\"%d\",&t);\n            if(!flag) a[F(i,j)]=t;\n            else a[F(j,i)]=t;\n        }\n        if(flag) swap(n,m);\n        REP(i,n) edge[i].clear();\n        REP(cas,q){\n            int x0,x1,y0,y1;\n            scanf(\"%d%d%d%d\",&x0,&y0,&x1,&y1);\n            if(flag) swap(x0,y0),swap(x1,y1);\n            l[cas]=y0;r[cas]=y1;\n            ans[cas]=-1;\n            FOR(i,x0,x1) edge[i].push_back(cas);\n        }\n\n        REP(i,n){\n            REP(j,m) b[j]=a[F(i,j)];\n            Build(1,0,m-1);\n            REP(j,edge[i].size()){\n                int v=edge[i][j];\n                int t=Find(1,l[v],r[v]);\n                if(ans[v]==-1||ans[v]>t) ans[v]=t;\n            }\n        }\n        REP(i,q) printf(\"%d\\n\",ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nvector<vector<int>>vs;\nstruct segtree {\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum= 2147483647;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 21>=r&&u +21>= d) {\n\t\t\tfor (int x = l; x <r; ++x) {\n\t\t\t\tfor (int y = u; y <d; ++y) {\n\t\t\t\t\tminnum = min(minnum, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int& ql,const int& qr,const int& qu,const int& qd,const int& nl,const int& nr,const int& nu,const int& nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (nl + 21 >= nr&&nu +21 >= nd) {\n\t\t\tint ans = 2147483647;\n\t\t\tfor (int x = max(ql,nl); x < min(qr,nr); ++x) {\n\t\t\t\tfor (int y = max(qu,nu); y < min(qd,nd); ++y) {\n\t\t\t\t\tans = min(ans, vs[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd) {\n\t\t\t\n\t\t\treturn minnum;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint aa, ab;\n\t\tif (nr - nl < nd - nu) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvs.clear();\n\t\tvs = vector<vector<int>>(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// library\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int find(int x1, int y1, int x2, int y2) const;\n  void print();\nprivate:\n  void update(int index, int a1, int b1, int a2, int b2, int x, int y, int value);\n  int find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const;\n  int parent(int index) const;\n  int upper_left(int index) const;\n  int upper_right(int index) const;\n  int lower_left(int index) const;\n  int lower_right(int index) const;\n  std::vector<int> node_;\n  int height_;\n  int width_;\n  int size_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) : width_(x), height_(y) {\n  size_ = 1;\n  for(int i = 1; i < std::max(x, y); i <<= 1) size_ <<= 2;\n  node_.assign(size_, INF);\n}\n// set value on (x, y)\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, 0, width_ - 1, height_ - 1, x, y, value);\n}\nvoid SegmentTree::update(int index, int a1, int b1, int a2, int b2, int x, int y, int value) {\n  if(size_ <= index) return;\n  if(x < a1 || a2 < x) return;\n  if(y < b1 || b2 < y) return;\n  if(a1 == x && x == a2 && b1 == y && y == b2) {\n    node_[index] = value;\n    while(index) {\n      node_[parent(index)] = std::min(node_[parent(index)], node_[index]);\n      index = parent(index);\n    }\n  } else {\n    int a = (a1 + a2) >> 1;\n    int b = (b1 + b2) >> 1;\n    update(upper_left(index), a1, b1, a, b, x, y, value);\n    update(upper_right(index), a + 1, b1, a2, b, x, y, value);\n    update(lower_left(index), a1, b + 1, a, b2, x, y, value);\n    update(lower_right(index), a + 1, b + 1, a2, b2, x, y, value);\n  }\n}\n// find the minimum value in (x1, y1)-(x2, y2)\nint SegmentTree::find(int x1, int y1, int x2, int y2) const {\n  return find(0, 0, 0, width_ - 1, height_ - 1, x1, y1, x2, y2);\n}\nint SegmentTree::find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const {\n//   for(int i=0;i<(index-1)>>2;++i)cout<<\" \";\n//   cout<<\"*\"<<index<<\"* \"<<a1<<\" \"<<b1<<\" \"<<a2<<\" \"<<b2<<endl;\n  if(size_ <= index) return INF;\n  if(x2 < a1 || a2 < x1) return INF;\n  if(y2 < b1 || b2 < y1) return INF;\n  if(x1 <= a1 && a2 <= x2 && y1 <= b1 && b2 <= y2) return node_[index];\n  int a = (a1 + a2) >> 1;\n  int b = (b1 + b2) >> 1;\n  int ul = find(upper_left(index), a1, b1, a, b, x1, y1, x2, y2);\n  int ur = find(upper_right(index), a + 1, b1, a2, b, x1, y1, x2, y2);\n  int ll = find(lower_left(index), a1, b + 1, a, b2, x1, y1, x2, y2);\n  int lr = find(lower_right(index), a + 1, b + 1, a2, b2, x1, y1, x2, y2);\n  return std::min({ul, ur, ll, lr});\n}\n// debug\nvoid SegmentTree::print() {\n  for(auto i: node_) cout<<\" \"<<i;cout<<endl;\n}\n// position\nint SegmentTree::parent(int index) const {return (index - 1) >> 2;}\nint SegmentTree::upper_left(int index) const {return (index << 2) + 1;}\nint SegmentTree::upper_right(int index) const {return (index << 2) + 2;}\nint SegmentTree::lower_left(int index) const {return (index << 2) + 3;}\nint SegmentTree::lower_right(int index) const {return (index << 2) + 4;}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n//     tree.print();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.find(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof (c.begin()) i=c.begin(); i!=c.end(); i++)\n#define all(c) (c).begin(), (c).end()\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x<<\" = \"<<x<<endl\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int inf = (1ll<<31)-1;\nconst double EPS=1e-9, INF=1e12;\n\nint h, w, q, H, W;\nvector<vi> g;\n\nint rec(int y1, int x1, int y2, int x2,\n int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X1 <= x2) return g[y][x];\n\tint res = inf;\n\t\n\tif(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\tmin(\n\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(y1, x1, y2, x2, Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec(y1, x1, y2, x2, (Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n\nint main(){\n  while(scanf(\"%d%d%d\", &h ,&w, &q), w){\n  \tfor(H = 1; H < h; H *= 2);\n  \tfor(W = 1; W < w; W *= 2);\n  \tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n  \trep(i,h) rep(j,w){\n  \t\tscanf(\"%d\", &g[i+H-1][j+W-1]);\n  \t}\n  \tfor(int i = H-1; ; i--){\n  \t\tfor(int j = W-1; ;j--){\n  \t\t\tif(i < H-1 && j < W-1)\n  \t\t\tg[i][j] = min(min(g[i*2+1][j*2+1], g[i*2+2][j*2+2]),\n  \t\t\t\tmin(g[i*2+2][j*2+1], g[i*2+1][j*2+2]));\n\t\t\t\tif(i < H-1) \n  \t\t\t\tg[i][j] = min(g[i][j], min(g[i*2+1][j], g[i*2+2][j]));\n\t\t\t\tif(j < W-1)\n  \t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2+1], g[i][j*2+2]));\n\t\t\t\tif(j == 0) break;\n  \t\t}\n  \t\tif(i == 0) break;\n  \t}\n  \trep(i, q){\n  \t\tint y1, y2, x1, x2;\n  \t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n  \t\tprintf(\"%d\\n\", rec(y1, x1, y2+1, x2+1, 0, 0, H, W, 0, 0));\n  \t}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++){\n        bucket[i]=new int[W/B+1];\n        fill_n(bucket[i],W/B+1,INT_MAX);\n    }\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&mi<latte[(y2-1)/B])y2-=B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&mi<malta[x1/B])x1=(x1/B+1)*B;\n\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&mi<malta[(x2-1)/B])x2-=B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int map[1000000];\n  int rmq[2000];\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int rr,rc;\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    rr = (int)sqrt(r);\n    rc = (int)sqrt(c);\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> map[i*c+j];\n    }\n\n    for(int i=0;i<=r/rr;i++){\n      for(int j=0;j<=c/rc;j++){\n\trmq[i*(c/rc+1)+j] = 1<<31 - 1;\n\tint ur = min( (i+1)*rr, r);\n\tfor(int k=i*rr;k<ur;k++){\n\t  int uc = min( (j+1)*rc, c);\n\t  for(int l=j*rc;l<uc;l++){\n\t    rmq[i*(c/rc+1)+j] = min(rmq[i*(c/rc+1)+j],map[k*c+l]);\n\t  }\n\t}\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int tr1,tc1,tr2,tc2;\n      tr1 = r1/rr;\n      if(r1%rr)tr1++;\n      tc1 = c1/rc;\n      if(c1%rc)tc1++;\n      tr2 = r2/rr;\n      if( !((r2+1)%rr) )tr2++;\n      tc2 = c2/rc;\n      if( !((c2+1)%rc) )tc2++;\n\n      int m = 1<<31 - 1;\n      for(int i=r1;i<tr1*rr;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n      //if(r2%rr && tr1!=tr2+1){\n\tfor(int i=tr2*rr;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    m = min(m,map[i*c+j]);\n\t  }\n\t}\n\t//}\n      \n      for(int i=r1;i<=r2;i++){\n\tfor(int j=c1;j<tc1*rc;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n\t//if(c2%rc && tc1!=tc2+1){\n\t  for(int j=tc2*rc;j<=c2;j++){\n\t    m = min(m,map[i*c+j]);\n\t  }\n\t  //}\n      }\n\n      for(int i=tr1;i<tr2;i++){\n\tfor(int j=tc1;j<tc2;j++){\n\t  m = min(m,rmq[i*(c/rc+1)+j]);\n\t}\n      }\n      cout << m << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        if(mi<latte[y2/B])y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        if(mi<malta[x2/B])x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n        \n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint r, c, q;\nint _r, _c;\nint g;\nint _seg[8 * SZ + 1];\nvector<int*> seg;\n//vi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  seg.resize(2 * _r - 1);\n  rep(i, 2 * _r - 1) seg[i] = _seg + i * (2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n\n  /*\n  //delete[] seg;\n  //seg = new vi[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n  */\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct SegmentTreeNodeMinimum {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT reduce(const T &a, const T &b) const { return min(a, b); }\n};\n\ntemplate <typename NodeType>\nclass SegmentTree {\n\nprivate:\n\ttypedef typename NodeType::value_type value_type;\n\tvector<value_type> m_data;\n\tsize_t m_internal_size;\n\tNodeType m_type;\n\n\tvoid initialize(){\n\t\tfor(int i = m_internal_size - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_type.reduce(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_type.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_type.reduce(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(int n = 0, const NodeType &type = NodeType()) :\n\t\tm_data(0), m_internal_size(1), m_type(type)\n\t{\n\t\twhile(m_internal_size < n){ m_internal_size *= 2; }\n\t\tm_data.resize(m_internal_size * 2 - 1, m_type.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator begin, Iterator end, const NodeType &type = NodeType()) :\n\t\tm_data(0), m_internal_size(1), m_type(type)\n\t{\n\t\tconst int n = distance(begin, end);\n\t\twhile(m_internal_size < n){ m_internal_size *= 2; }\n\t\tm_data.resize(m_internal_size * 2 - 1, m_type.default_value());\n\t\tcopy(begin, end, m_data.begin() + m_internal_size - 1);\n\t\tinitialize();\n\t}\n\n\tconst value_type &operator[](int i) const {\n\t\treturn m_data[m_internal_size - 1 + i];\n\t}\n\n\tvoid update(int i, const value_type &val){\n\t\ti += m_internal_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_type.reduce(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, m_internal_size);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename NodeType>\nclass SegmentTree2D {\n\nprivate:\n\ttypedef typename NodeType::value_type value_type;\n\tvector< SegmentTree<NodeType> > m_data;\n\tsize_t m_internal_rows;\n\tNodeType m_type;\n\n\tvalue_type query(\n\t\tint r0, int c0, int r1, int c1, int k, int l, int r) const\n\t{\n\t\tif(r <= r0 || r1 <= l){ return m_type.default_value(); }\n\t\tif(r0 <= l && r <= r1){ return m_data[k].query(c0, c1); }\n\t\tconst value_type vl = query(r0, c0, r1, c1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(r0, c0, r1, c1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_type.reduce(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tint n = 0, int m = 0, const NodeType &type = NodeType()) :\n\t\tm_data(0), m_internal_rows(1), m_type(type)\n\t{\n\t\twhile(m_internal_rows < n){ m_internal_rows *= 2; }\n\t\tm_data.resize(\n\t\t\tm_internal_rows * 2 - 1, SegmentTree<NodeType>(m, type));\n\t}\n\n\tconst value_type &operator()(int i, int j) const {\n\t\treturn m_data[m_internal_rows - 1 + i][j];\n\t}\n\n\tvoid update(int i, int j, const value_type &val){\n\t\ti += m_internal_rows - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_type.reduce(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(int r0, int c0, int r1, int c1) const {\n\t\treturn query(r0, c0, r1, c1, 0, 0, m_internal_rows);\n\t}\n\n};\n\n\n}\n}\n\n\nint main(){\n\tusing namespace libcomp::structure;\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tSegmentTree2D< SegmentTreeNodeMinimum<int> > st(r, c);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tst.update(i, j, x);\n\t\t\t}\n\t\t}\n\t\twhile(q--){\n\t\t\tint r0, c0, r1, c1;\n\t\t\tcin >> r0 >> c0 >> r1 >> c1;\n\t\t\tint answer = st.query(r0, c0, r1 + 1, c1 + 1);\n\t\t\tcout << answer << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst ll INF = 1LL << 50;\nconst double EPS = 1E-10;\n\nint R, C;\n\nll dat[10000000];\n\nint hash1(int x, int y){\n\treturn y * C + x;\n}\n\nvoid init(int r, int c){\n\tR = 1, C = 1;\n\twhile(R < r) R *= 2;\n\twhile(C < c) C *= 2;\n\tfor(int i = 0; i < R * 2 - 1; i++)\n\t\tfor(int j = 0; j < C * 2 - 1; j++) dat[hash1(j,i)] = INF;\n}\n\nvoid update(int x, int y, ll a){\n\tx += C - 1;\n\ty += R - 1;\n\tdat[hash1(x, y)] = a;\n\twhile(y){\n\t\ty = (y - 1) / 2;\n\t\tdat[hash1(x, y)] = min(dat[hash1(x, y*2+1)], dat[hash1(x, y*2+2)]);\n\t}\n\twhile(x){\n\t\tx = (x - 1) / 2;\n\t\tdat[hash1(x, y)] = min(dat[hash1(x*2+1, y)], dat[hash1(x*2+2, y)]);\n\t}\n}\n\nll queryY(int kx, int ya, int yb, int ky, int yl, int yr){\n\tif(yb <= yl || yr <= ya) return INF;\n\telse if(ya <= yl && yr <= yb) return dat[hash1(kx, ky)];\n\telse{\n\t\tint chl = ky * 2 + 1;\n\t\tint chr = ky * 2 + 2;\n\t\tint ym = (yl + yr) / 2;\n\t\treturn min(queryY(kx, ya, yb, chl, yl, ym), queryY(kx, ya, yb, chr, ym, yr));\n\t}\n}\n\nll queryX(int xa, int xb, int ya, int yb, int k, int xl, int xr){\n\tif(xb <= xl || xr <= xa) return INF;\n\telse if(xa <= xl && xr <= xb) return queryY(k, ya, yb, 0, 0, R);\n\telse{\n\t\tint chl = 2 * k + 1;\n\t\tint chr = 2 * k + 2;\n\t\tint xm = (xl + xr) / 2;\n\t\treturn min(queryX(xa, xb, ya, yb, chl, xl, xm),\n\t\t\t\t\tqueryX(xa, xb, ya, yb, chr, xm, xr));\n\t}\n}\n\nint main(){\n\tint r, c, q;\n\tint r1, c1, r2, c2;\n\tll num;\n\twhile(cin >> r >> c >> q && (r || c || q)){\n\t\tinit(r, c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tcin >> num;\n\t\t\t\tupdate(j, i, num);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << queryX(c1, c2+1, r1, r2+1, 0, 0, C) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint len[1001000];\n\nint min(const int &a,const int &b)\n{\n    if (a<b) return a;else return b;\n}\n\n\nint mi[1001000][21];\n\nstruct RMQ\n{\n    void rmq(int * d, int N)\n    {\n        int M=len[N];\n        for (int i=0;i<N;i++) mi[i][0]=d[i];\n        for (int g=1;g<=M;g++)\n        {\n            int L=N-(1<<g);\n            for (int i=0;i<=L;i++)\n                mi[i][g]=min( mi[i][g-1] , mi[i+(1<<(g-1))][g-1] );\n        }\n    }\n    int query(int &a, int &b)\n    {\n        int g=len[b-a+1];\n        return min(mi[a][g],mi[b-(1<<(g))+1][g]);\n    }\n}aa;\n\nint a[1100000];\nint r1[11000],r2[11000],c1[11000],c2[11000];\nint ans[11000];\nlong long numinf;\nint inf;\nint m,n,q;\nint main()\n{\n    for (int L=1;L<=1000000;L++) len[L]=int (log(L*1.0)/log(2.0));\n    numinf=1;\n    for (int k=1;k<=31;k++) numinf*=2LL;\n    numinf=numinf-1;\n    inf=numinf;\n\n  \n    scanf(\"%d%d%d\",&n,&m,&q);\n    while (n+m+q!=0)\n    {\n        int rv=0;\n        if (n>m) rv=1;\n        if (n>m) swap(n,m);\n        if (rv==0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                scanf(\"%d\",a+i*m+j);\n        if (rv!=0)\n        for (int i=0;i<m;i++)\n            for (int j=0;j<n;j++)\n                scanf(\"%d\",a+i*m+j);\n\n        for (int k=1;k<=q;k++)\n            scanf(\"%d%d%d%d\",&r1[k],&c1[k],&r2[k],&c2[k]);\n        for (int k=1;k<=q;k++) ans[k]=inf;\n        for (int k=1;k<=q;k++)\n           if (rv)\n           {\n               swap(r1[k],c1[k]);\n               swap(r2[k],c2[k]);\n           }\n        int temp;\n        for (int i=0;i<n;i++)\n        {\n            aa.rmq(a+i*m,m);\n            for (int k=1;k<=q;k++)\n                if (r1[k]<=i&&i<=r2[k])\n                {\n                    temp=aa.query(c1[k],c2[k]);\n                    if (temp<ans[k]) ans[k]=temp;\n                }\n        }\n        for (int k=1;k<=q;k++)\n            printf(\"%d\\n\",ans[k]);\n        scanf(\"%d%d%d\",&n,&m,&q);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n// BEGIN CUT HERE\nstruct Dense2DSegmentTree {\n  using T = int;\n  static T op(const T& a, const T& b) { return min(a, b); }\n  static constexpr T e() { return ~(~0 << 31); }\n\n  struct SegmentTree {\n    const int n;\n    V<T> t;\n    SegmentTree(int n) : n(n), t(2 * n, e()) {}\n    T& operator[](int i) { return t[i + n]; }\n    void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n    T acc(int l, int r) const {\n      T res = e();\n      for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n        if (l & 1) res = op(res, t[l++]);\n        if (r & 1) res = op(res, t[--r]);\n      }\n      return res;\n    }\n    void set(int i, const T& a) {\n      t[i += n] = a;\n      while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n    }\n  };\n  const int n, m;\n  V<SegmentTree> st;\n  Dense2DSegmentTree(int n, int m) : n(n), m(m), st(2 * n, SegmentTree(m)) {}\n  SegmentTree& operator[](int x) { return st[x + n]; }\n  void build() {\n    for (int x = 0; x < n; ++x) st[x + n].build();\n    for (int x = n - 1; x; --x) {\n      for (int y = 0; y < m; ++y) st[x][y] = op(st[2 * x][y], st[2 * x + 1][y]);\n      st[x].build();\n    }\n  }\n  T acc(int x0, int x1, int y0, int y1) const {\n    T res = e();\n    for (x0 += n, x1 += n; x0 < x1; x0 >>= 1, x1 >>= 1) {\n      if (x0 & 1) res = op(res, st[x0++].acc(y0, y1));\n      if (x1 & 1) res = op(res, st[--x1].acc(y0, y1));\n    }\n    return res;\n  }\n  void set(int x, int y, const T& a) {\n    st[x += n].set(y, a);\n    while (x >>= 1) st[x].set(y, op(st[2 * x][y], st[2 * x + 1][y]));\n  }\n};\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int r, c, q; cin >> r >> c >> q;\n    if (!r) break;\n    Dense2DSegmentTree st(r, c);\n    for (int i = 0; i < r; ++i) for (int j = 0; j < c; ++j) {\n      cin >> st[i][j];\n      // int x; cin >> x;\n      // st.set(i, j, x);\n    }\n    st.build();\n    while (q--) {\n      int r0, c0, r1, c1; cin >> r0 >> c0 >> r1 >> c1, ++r1, ++c1;\n      cout << st.acc(r0, r1, c0, c1) << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 10\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t\tstd::vector<SegTree>(seg).swap(seg);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 7000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return LLONG_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Rmq\n{\n    int n;\n    vector<int> data;\n    int query(int a, int b, int k, int l, int r){\n        if(r < a || b < l)\n            return INT_MAX;\n        if(a <= l && r <= b)\n            return data[k];\n        int x = query(a, b, k*2+1, l, (l+r)/2);\n        int y = query(a, b, k*2+2, (l+r+1)/2, r);\n        return min(x, y);\n    }\npublic:\n    Rmq(int n0){\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, INT_MAX);\n    }\n    Rmq(vector<int> vi){\n        int n0 = vi.size();\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, INT_MAX);\n        for(int i=0; i<n0; ++i)\n            data[i+n-1] = vi[i];\n        for(int i=n-2; i>=0; --i)\n            data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n    void update(int k, int a){\n        k += n - 1;\n        data[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            data[k] = min(data[k*2+1], data[k*2+2]);\n        }\n    }\n    int query(int a, int b){\n        return query(a, b, 0, 0, n-1);\n    }\n};\n\nint main(){\n    for(;;){\n        int r, c, q;\n        cin >> r >> c >> q;\n        if(r == 0)\n            return 0;\n\n        if(r < c){\n            vector<vector<int> > grid(r, vector<int>(c));\n            for(int i=0; i<r; ++i){\n                for(int j=0; j<c; ++j){\n                    cin >> grid[i][j];\n                }\n            }\n            vector<Rmq> rmq;\n            for(int i=0; i<r; ++i)\n                rmq.push_back(Rmq(grid[i]));\n\n            for(int i=0; i<q; ++i){\n                int r1, c1, r2, c2;\n                cin >> r1 >> c1 >> r2 >> c2;\n                int ret = INT_MAX;\n                for(int i=r1; i<=r2; ++i)\n                    ret = min(ret, rmq[i].query(c1, c2));\n                cout << ret << endl;\n            }\n        }else{\n            vector<vector<int> > grid(c, vector<int>(r));\n            for(int i=0; i<r; ++i){\n                for(int j=0; j<c; ++j){\n                    cin >> grid[j][i];\n                }\n            }\n            vector<Rmq> rmq;\n            for(int i=0; i<c; ++i)\n                rmq.push_back(Rmq(grid[i]));\n\n            for(int i=0; i<q; ++i){\n                int r1, c1, r2, c2;\n                cin >> r1 >> c1 >> r2 >> c2;\n                int ret = INT_MAX;\n                for(int i=c1; i<=c2; ++i)\n                    ret = min(ret, rmq[i].query(r1, r2));\n                cout << ret << endl;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define lowbit(x) ((x)&(-(x)))\n\nusing namespace std;\n\nconst int maxn = 1000000;\nint a[maxn], f[maxn], r, c, q;\nint fr[maxn], fc[maxn];\nint r1, r2, c1, c2;\n\nvoid init(){\n    int pos;\n    for (int i = 1; i <= r; i++)\n        for (int j = 1; j <= c; j++){\n            pos = (i - 1) * c + j;\n            fr[pos] = fc[pos] = a[pos];\n            for (int k = 1, l = lowbit(i); k < l; k <<= 1)\n                fc[pos] = min(fc[pos], fc[(i-1-k)*c+j]);\n            for (int k = 1, l = lowbit(j); k < l; k <<= 1)\n                fr[pos] = min(fr[pos], fr[(i-1)*c+j-k]);\n            f[pos] = fc[pos];\n            for (int k = 1, lk = lowbit(j); k < lk; k <<= 1){\n                f[pos] = min(f[pos], fr[(i-1)*c+j-k]);\n                for (int p = 1, lp = lowbit(i); p < lp; p <<= 1)\n                    f[pos] = min(f[pos], f[(i-p-1)*c+j-k]);\n            }\n        }\n}\n\nint query(){\n    int ans = 0x7fffffff, ll, rr;\n    while (1){\n        ll = r1, rr = r2;\n        while (1){\n            ans = min(ans, a[(rr-1)*c + c2]);\n            if (rr == ll) break;\n            for (rr--; rr - lowbit(rr) >= ll; rr -= lowbit(rr))\n                ans = min(ans, fc[(rr-1)*c + c2]);\n        }\n        if (c2 == c1) break;\n        for (c2--; c2 - lowbit(c2) >= c1; c2 -= lowbit(c2)){\n            ll = r1; rr = r2;\n            while (1){\n                ans = min(ans, fr[(rr-1)*c+c2]);\n                if (rr == ll) break;\n                for (rr--; rr - lowbit(rr) >= ll; rr -= lowbit(rr))\n                    ans = min(ans, f[(rr-1)*c+c2]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n      while (scanf(\"%d%d%d\", &r, &c, &q) && r + c + q){\n          int *p = a;\n          for (int i = 1; i <= r; i++)\n              for (int j = 1; j <= c; j++)\n                  scanf(\"%d\", ++p);\n          init();\n          while (q--){\n              scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n              r1++, c1++, r2++, c2++;              \n              printf(\"%d\\n\", query());\n          }\n      }\n\n      return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W;\nint y1, x1, y2, x2;\nvector<vi> g;\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y][x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", &g[i+H-1][j+W-1]);\n\t\t\n\t\tfor(int i = H-1; i >= 0; i--){\n\t\t\tfor(int j = W-1; j >= 0;j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i][j] = min(min(g[i*2 + 1][j*2 + 1], g[i*2 + 2][j*2 + 2]),\n\t\t\t\t\t\tmin(g[i*2 + 2][j*2 + 1], g[i*2 + 1][j*2 + 2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i*2 + 1][j], g[i*2 + 2][j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2 + 1], g[i][j*2 + 2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<climits>\n#include<complex>\n#define sz(x) (int)((x).size())\n#define rep(i,n) for (int i=0;i<n;i++)\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define clr(x) memset((x),0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpi;\nstruct Seg\n{\n    int s[4];\n    int val;\n}seg[120000*20];\nint tot=0,root=-1;\nvoid insert(int x,int y,int val,int minx,int maxx,int miny,int maxy,int &v)\n{\n    if (x<minx||x>=maxx||y<miny||y>=maxy)\n    {\n        return;\n    }\n    if (v==-1)\n    {\n        v=tot++;\n        memset(seg[v].s,-1,sizeof(seg[v].s));\n        seg[v].val=INT_MAX;\n    }\n    if (minx+1==maxx&&miny+1==maxy)\n    {\n        seg[v].val=min(seg[v].val,val);\n        return;\n    }\n    int midx=(minx+maxx)>>1;\n    int midy=(miny+maxy)>>1;\n    insert(x,y,val,minx,midx,miny,midy,seg[v].s[0]);\n    insert(x,y,val,minx,midx,midy,maxy,seg[v].s[1]);\n    insert(x,y,val,midx,maxx,miny,midy,seg[v].s[2]);\n    insert(x,y,val,midx,maxx,midy,maxy,seg[v].s[3]);\n    seg[v].val=INT_MAX;\n    int i;\n    for (i=0;i<4;i++)\n    {\n        if (seg[v].s[i]!=-1)\n        {\n            seg[v].val=min(seg[v].val,seg[seg[v].s[i]].val);\n        }\n    }\n}\nint find(int ax,int bx,int ay,int by,int minx,int maxx,int miny,int maxy,int v)\n{\n    if (v==-1)return INT_MAX;\n    if (ax>=maxx||bx<=minx||ay>=maxy||by<=miny)\n    {\n        return INT_MAX;\n    }\n    if (ax<=minx&&bx>=maxx&&ay<=miny&&by>=maxy)\n    {\n        return seg[v].val;\n    }\n    int midx=(minx+maxx)>>1;\n    int midy=(miny+maxy)>>1;\n    int tmp=find(ax,bx,ay,by,minx,midx,miny,midy,seg[v].s[0]);\n    tmp=min(tmp,find(ax,bx,ay,by,minx,midx,midy,maxy,seg[v].s[1]));\n    tmp=min(tmp,find(ax,bx,ay,by,midx,maxx,miny,midy,seg[v].s[2]));\n    tmp=min(tmp,find(ax,bx,ay,by,midx,maxx,midy,maxy,seg[v].s[3]));\n    return tmp;\n}\nchar buf[100];\nint main()\n{\n    int stt;\n    int r,c,q,i,j,k;\n    while (scanf(\"%d%d%d\",&r,&c,&q)!=EOF)\n    {\n    \tif (r==0&&c==0&&q==0)break;\n    \troot = -1;\n    \ttot= 0;\n    \tfor (i=1;i<=r;i++)\n    \t{\n    \t\tfor (j=1;j<=c;j++)\n    \t\t{\n    \t\t\tscanf(\"%d\",&k);\n    \t\t\tinsert(i, j, k, -1, r+10, -1, c+10, root);\n    \t\t}\n    \t}\n        while (q--)\n        {\n           // else\n            {\n                int minx, maxx, miny, maxy;\n                scanf(\"%d %d %d %d\", &minx, &miny, &maxx, &maxy);\n                printf(\"%d\\n\", find(minx+1, maxx + 2, miny+1, maxy + 2, -1, r+10, -1, c+10,\n                                    root));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<vector>\n#include<algorithm>\n// constant\nconst int INF = 1e9;\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int find(int x1, int y1, int x2, int y2) const;\n  void print();\nprivate:\n  void update(int index, int a1, int b1, int a2, int b2, int x, int y, int value);\n  int find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const;\n  int parent(int index) const;\n  int upper_left(int index) const;\n  int upper_right(int index) const;\n  int lower_left(int index) const;\n  int lower_right(int index) const;\n  std::vector<int> node_;\n  int height_;\n  int width_;\n  int size_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) : width_(x), height_(y) {\n  size_ = 1;\n  for(int i = 1; i <= std::max(x, y); i <<= 1) size_ <<= 2;\n  node_.assign(size_, INF);\n}\n// set value on (x, y)\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, 0, width_ - 1, height_ - 1, x, y, value);\n}\nvoid SegmentTree::update(int index, int a1, int b1, int a2, int b2, int x, int y, int value) {\n  if(size_ <= index) return;\n  if(x < a1 || a2 < x) return;\n  if(y < b1 || b2 < y) return;\n  if(a1 == x && x == a2 && b1 == y && y == b2) {\n    node_[index] = value;\n    while(index) {\n      node_[parent(index)] = std::min(node_[parent(index)], node_[index]);\n      index = parent(index);\n    }\n  } else {\n    int a = (a1 + a2) >> 1;\n    int b = (b1 + b2) >> 1;\n    update(upper_left(index), a1, b1, a, b, x, y, value);\n    update(upper_right(index), a + 1, b1, a2, b, x, y, value);\n    update(lower_left(index), a1, b + 1, a, b2, x, y, value);\n    update(lower_right(index), a + 1, b + 1, a2, b2, x, y, value);\n  }\n}\n// find the minimum value in (x1, y1)-(x2, y2)\nint SegmentTree::find(int x1, int y1, int x2, int y2) const {\n  return find(0, 0, 0, width_ - 1, height_ - 1, x1, y1, x2, y2);\n}\nint SegmentTree::find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const {\n//   for(int i=0;i<(index-1)>>2;++i)cout<<\" \";\n//   cout<<\"*\"<<index<<\"* \"<<a1<<\" \"<<b1<<\" \"<<a2<<\" \"<<b2<<endl;\n  if(size_ <= index) return INF;\n  if(x2 < a1 || a2 < x1) return INF;\n  if(y2 < b1 || b2 < y1) return INF;\n  if(x1 <= a1 && a2 <= x2 && y1 <= b1 && b2 <= y2) return node_[index];\n  int a = (a1 + a2) >> 1;\n  int b = (b1 + b2) >> 1;\n  int ul = find(upper_left(index), a1, b1, a, b, x1, y1, x2, y2);\n  int ur = find(upper_right(index), a + 1, b1, a2, b, x1, y1, x2, y2);\n  int ll = find(lower_left(index), a1, b + 1, a, b2, x1, y1, x2, y2);\n  int lr = find(lower_right(index), a + 1, b + 1, a2, b2, x1, y1, x2, y2);\n  return std::min({ul, ur, ll, lr});\n}\n// debug\nvoid SegmentTree::print() {\n  for(auto i: node_) cout<<\" \"<<i;cout<<endl;\n}\n// position\nint SegmentTree::parent(int index) const {return (index - 1) >> 2;}\nint SegmentTree::upper_left(int index) const {return (index << 2) + 1;}\nint SegmentTree::upper_right(int index) const {return (index << 2) + 2;}\nint SegmentTree::lower_left(int index) const {return (index << 2) + 3;}\nint SegmentTree::lower_right(int index) const {return (index << 2) + 4;}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n//     tree.print();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.find(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n\ntemplate<class S=int, class T=std::less<S>, S nil=INT_MAX>\nclass RMQ{\nfriend class RMQ2D;\n\tint n;\n\tS *dat;\n\tS query(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn std::min(vl,vr,T());\n\t\t}\n\t}\n\tstatic int calcsize(int n){\n\t\tint res=1;\n\t\twhile(res<n)res<<=1;\n\t\treturn res;\n\t}\npublic:\n\tRMQ(int n,const S a[]){\n\t\tint m=n;\n\t\tn=this->n=calcsize(n);\n\t\tdat=new S[2*n-1];\n\t\tfor(int i=0;i<m;i++)dat[n-1+i]=a[i];\n\t\tfor(int i=m;i<n;i++)dat[n-1+i]=nil;\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=std::min(dat[i*2+1],dat[i*2+2],T());\n\t\t}\n\t}\n\t~RMQ(){\n\t\tdelete[] dat;\n\t}\n\tvoid update(int k,int a){//k番目をaに変更\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=std::min(dat[k*2+1],dat[k*2+2],T());\n\t\t}\n\t}\n\tS query(int a,int b)const{//[a,b)の最小(大)値\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n\n\n\n\nclass RMQ2D{\n\ttypedef unsigned int S;\n\ttypedef std::less<S> T;\n\tstatic const S nil=~0u;\n\tint h,w;\n\tRMQ<S,T,nil> **rmq;\n\tRMQ<S,T,nil> *emp;\n\tint query(int a,int b,int k,int l,int r,int xs,int xe)const{\n\t\tif(r<=a||b<=l)return nil;\n\t\tif(a<=l&&r<=b)return rmq[k]->query(xs,xe);\n\t\telse{\n\t\t\tS vl=query(a,b,k*2+1,l,(l+r)/2,xs,xe);\n\t\t\tS vr=query(a,b,k*2+2,(l+r)/2,r,xs,xe);\n\t\t\treturn std::min(vl,vr);\n\t\t}\n\t}\npublic:\n\tRMQ2D(int h,int w,const S a[]){\n\t\tS *dat;\n\t\tint n=h,m=w;\n\t\th=this->h=RMQ<S,T,nil>::calcsize(n);\n\t\tw=this->w=RMQ<S,T,nil>::calcsize(n);\n\t\tdat=new S[2*w-1];\n\t\tfor(int i=0;i<w;i++)dat[i]=nil;\n\t\temp=new RMQ<S,T,nil>(m,dat);\n\t\trmq=new RMQ<S,T,nil>*[2*h-1];\n\t\tfor(int i=0;i<n;i++)rmq[h-1+i]=new RMQ<S,T,nil>(m,a+i*m);\n\t\tfor(int i=n;i<h;i++)rmq[h-1+i]=emp;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\trmq[i]=new RMQ<S,T,nil>(m,dat);\n\t\t\tfor(int j=0;j<2*w-1;j++)\n\t\t\t\trmq[i]->dat[j]=std::min(rmq[i*2+1]->dat[j],rmq[i*2+2]->dat[j],T());\n\t\t\t\n\t\t}\n\t\tdelete[] dat;\n\t}\n\t~RMQ2D(){\n\t\tfor(int i=0;i<2*h-1&&rmq[i]!=emp;i++)\n\t\t\tdelete rmq[i];\n\t\tdelete[] rmq;\n\t\tdelete emp;\n\t}\n\tvoid update(int y,int x,int a){\n\t\t//「あとで」\n\t}\n\tint query(int ys,int ye,int xs,int xe)const{//[ys,ye)+[xs,xe)の最小(大)値\n\t\treturn query(ys,ye,0,0,h,xs,xe);\n\t}\n};\n\nunsigned int g[10000000];\nint main(){\n\tint r,c,q;\n\twhile(cin>>r>>c>>q,r|c|q){\n\t\tfor(int i=0;i<r*c;i++)cin>>g[i];\n\t\tRMQ2D rmq(r,c,g);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint y1,x1,y2,x2;\n\t\t\tcin>>y1>>x1>>y2>>x2;\n\t\t\tcout<<rmq.query(y1,y2+1,x1,x2+1)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void destroy();\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void destroy(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Free.\nvoid SegmentTree::destroy() {free(root_);}\nvoid SegmentTree::destroy(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) destroy(node->child[i]);\n  delete node;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.destroy();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<vector<int> > segtree;\nint n,m;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j){\n\tif(d<a||b<c||h<e||f<g)return 2147483647;\n\tif(c<=a&&b<=d){\n\t\tif(g<=e&&f<=h)return segtree[i][j];\n\t\treturn min(query(a,b,c,d,e,(e+f)/2,g,h,i,j*2),query(a,b,c,d,(e+f)/2+1,f,g,h,i,j*2+1));\n\t}\n\treturn min(query(a,(a+b)/2,c,d,e,f,g,h,i*2,j),query((a+b)/2+1,b,c,d,e,f,g,h,i*2+1,j));\n}\nvoid update(int a,int b,int c){\n\ta+=n;b+=m;\n\twhile(a){\n\t\tint d=b;\n\t\twhile(d){\n\t\t\tsegtree[a][d]=min(segtree[a][d],c);\n\t\t\td/=2;\n\t\t}\n\t\ta/=2;\n\t}\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=1;\n\t\twhile(n<a)n*=2;\n\t\tm=1;\n\t\twhile(m<b)m*=2;\n\t\tsegtree=vector<vector<int> >(n*2,vector<int>(m*2,2147483647));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tupdate(i,j,d);\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tprintf(\"%d\\n\",query(0,n-1,p,r,0,m-1,q,s,1,1));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int SQRT_N = 1000;\nconst int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(int x, int value) {\n    data[x] = value;\n    int k = x / SQRT_N;\n    stat[k] = min(stat[k], data[x]);\n  }\n  int query(int a, int b) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(int y, int x, int value) {\n    data[y].update(x, value);\n    int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(int y1, int x1, int y2, int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\t\n\tvoid resize(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\t\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build() {\n\t\tint h = sp[0].size(), w = sp[0][0][0].size(), ir, ic, jr, jc;\n\t\tfor (ir=0;ir<h;ir++)\n\t\t\tfor (jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor (ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor (jr=1;jr<=log2(h);jr++)\n\t\t\tfor (ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor (jc=0;jc<=log2(w);jc++)\n\t\t\t\t\tfor (ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n};\n\nint h, w, q, t, xa, ya, xb, yb;\nSPA2<int> sp(1,1);\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tsp.resize(h,w);\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build();\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconst int SQRT_N = 1000;\nconst int INF = (int)1e9;\nint H, W, Q;\nstruct Row {\n  int K;\n  vector<int> data;\n  vector<int> stat;\n  Row() {\n    K = (W + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, INF);\n    stat.assign(K, INF);\n  }\n  void update(int x, int value) {\n    data[x] = value;\n    int k = x / SQRT_N;\n    stat[k] = min(stat[k], data[x]);\n  }\n  int query(int a, int b) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = min(ret, stat[k]);\n      }\n      else {\n        for(int i = max(a, l); i < min(b, r); ++i) {\n          ret = min(ret, data[i]);\n        }\n      }\n    }\n    return ret;\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(int y, int x, int value) {\n    data[y].update(x, value);\n    int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].data[x], data[y].data[x]));\n  }\n  int query(int y1, int x1, int y2, int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nint main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 1000;\nconstexpr int INF = (int)1e9;\nint H, W, Q;\nstruct Row {\n  vector<int> data;\n  int N;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    Grid g;\n    REP(y,H) REP(x,W) {\n      int v; cin >> v;\n      g.update(y, x, v);\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000000\nusing namespace std;\ntypedef long long ll;\n\nint r, c, q, S;\nvector<ll> v[1000];\n\nvoid init(int x, int y){\n\trep(i,x){\n\t\trep(j,y*4){\n\t\t\tv[i][j] = INF;\n\t\t}\n\t}\n\tS = 1;\n\twhile(S <= y) S *= 2;\n}\n\nvoid update(int y, int x, ll t){\n\tx += S-1;\n\tv[y][x] = t;\n\twhile(x > 0){\n\t\tx = (x-1)/2;\n\t\tv[y][x] = min(v[y][2*x+1],v[y][2*x+2]);\n\t}\n}\n\nll get(int z, int a, int b, int t, int r, int l){\n\tif(a >= l || b <= r) return INF;\n\tif(a <= r && l <= b) return v[z][t];\n\treturn min(get(z,a,b,t*2+1,r,(r+l)/2),get(z,a,b,t*2+2,(r+l)/2,l));\n}\n\nint main(){\n\twhile(scanf(\"%d%d%d\", &r, &c, &q), r||c||q){\n\t\tfor(int i = 0; i < min(r,c); i++){\n\t\t\twhile(v[i].size() < max(r,c)*4) v[i].push_back(0);\n\t\t}\n\t\tinit(min(r,c), max(r,c));\n\t\tif(r < c){\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(i,j,tmp);\n\t\t\t}\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t} else{\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(j,i,tmp);\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N=1500000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint n;\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    h=max(h,w);\n    w=max(h,w);\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        // lðCfbNXÉÁZµÄ¢­\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    // Å¬lðÔ·\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                cin>>t;\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            cout<<res<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=(uint)2147483647+(uint)1;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < 4*MAX_N; i++)\n\t\tdat[i]=INF;\n}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\n//uint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n//\t// dÈèªªÈ¢\n//\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n//\t// ®SÉÜÜêé\n//\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n//\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n//\tuint vl,vr;\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n//\t//if(vl<vr)return vl;\n//\t//return vr;\n//\treturn min(vl,vr);\n//}\n//void update(int k,int a){\n//\t// h*w-1©ç¦nßé\n//\tk+=h*w-1;\n//\tdat[k]=a;\n//\t// oèÈªçindexðXV\n//\twhile(k>0){\n//\t\tk=(k-1)/2;\n//\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n//\t}\n//}\nvoid update(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,uint a,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return;\n\t// ®SÉÜÜêé\n\tdat[k]=min(dat[k],a);\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy){\n\t\t// ¡ñÌêðXVµ½çI¹\n\t\treturn;\n\t}\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\tif(isHor){\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,a,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n\telse{\n\t\tupdate(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,a,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tupdate(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,a,2*k+2,nxt);\n\t}\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n\t//if(vl<vr)return vl;\n\t//return vr;\n}\n\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k,bool isHor){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\t// ¡ñÇ¿çÅØé©\n\tbool nxt=!isHor;\n\tif(isHor){\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1,nxt);\n\t\tif(sminy!=smaxy)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2,nxt);\n\t\telse\n\t\t\tvr=INF;\n\t}\n\telse{\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1,nxt);\n\t\tif(smaxx!=sminx)\n\t\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2,nxt);\n\t\telse vr=INF;\n\t}\n//\tif(sminy==smaxy){\n//\t\t// yðªµI¦Ä¢éê\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n//\t}\n//\telse{\n//\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n//\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n//\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n//\t}\n\t//if(vl<vr)return vl;\n\t//return vr;\n\treturn min(vl,vr);\n}\n\nint main(){\n\tFILE *fp=stdin;\n\t//fp=fopen(\"input.txt\",\"r\");\n\twhile(fscanf(fp,\"%d %d %d\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n\t\t//while(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\t//fast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\t//cin>>t;\n\t\t\t\tfscanf(fp,\"%d\",&t);\n\t\t\t\t//pdate(i*w+j,t);\n\t\t\t\tupdate(j,i,j,i,0,0,w-1,h-1,t,0,true);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\t//cin>>r1>>c1>>r2>>c2;\n\t\t\tfscanf(fp,\"%d %d %d %d\",&r1,&c1,&r2,&c2);\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0,true);\n\t\t\t//cout<<res<<endl;\n\t\t\tprintf(\"%d\\n\",(int)res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 9876543210\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nvector<vector<ll> > dat;\nint R, C;\n\nvoid update(int r, int c, int x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r][c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r][cc] = min(dat[r][cc * 2 + 1], dat[r][cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(cc > 0){\n\t\t\tdat[r][cc] = min(dat[r * 2 + 1][cc], dat[r * 2 + 2][cc]);\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nll query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r][c];\n\tif (r1 <= rl && rr <= r2){\n\t\tll v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tll v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tll v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tll v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tdat.clear();\n\t\tdat.resize(R * 2 - 1, vector<ll>(C * 2 - 1, INF));\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tint x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tll ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=(1<<31)-1;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tstatic int a[1000000];\n\t\trep(i,h) rep(j,w) scanf(\"%d\",a+i*w+j);\n\n\t\tint h2=(int)(sqrt(h)+1),w2=(int)(sqrt(w)+1);\n\t\tstatic int a2[3000];\n\t\trep(i,h2) rep(j,w2) {\n\t\t\ta2[i*w2+j]=INF;\n\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\tfor(int y=t2;y<b2;y++) for(int x=l2;x<r2;x++) {\n\t\t\t\ta2[i*w2+j]=MIN(a2[i*w2+j],a[y*w+x]);\n\t\t\t}\n\t\t}\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\trep(i,h2) rep(j,w2) {\n\t\t\t\tint t2=i*h2,b2=MIN((i+1)*h2,h),l2=j*w2,r2=MIN((j+1)*w2,w);\n\t\t\t\tif(t<=t2 && b2<b && l<=l2 && r2<r){\n\t\t\t\t\tans=MIN(ans,a2[i*w2+j]);\n\t\t\t\t}\n\t\t\t\telse if(b<=t2 || b2<=t || r<=l2 || r2<=l);\n\t\t\t\telse{\n\t\t\t\t\tfor(int y=MAX(t,t2);y<MIN(b,b2);y++){\n\t\t\t\t\t\tfor(int x=MAX(l,l2);x<MIN(r,r2);x++){\n\t\t\t\t\t\t\tans=MIN(ans,a[y*w+x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const lli MAX_N=1<<18;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  int data[2 * 2 * 100100];\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[100100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nclass SegmentTree{\n\tprivate:\n\tstatic const int MAX_N=1<<17;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INT_MAX;\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INT_MAX;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nlli Cmin(lli a,lli b){\n\tif(a>b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1LL << 40)\n\ntypedef long long ll;\n\nll min(ll a, ll b) { return a < b ? a : b; }\n\nstruct SegTree {\n\tint segSize;\n\tvector<ll> seg;\n\n\tvoid init(int n) {\n\t\tfor (segSize = 1; segSize < n; segSize <<= 1);\n\n\t\tseg = vector<ll>(segSize*2-1, INF);\n\t}\n\tvoid update(int pos, int val) {\n\t\tint n = segSize-1 + pos;\n\t\tseg[n] = val;\n\t\twhile (n) {\n\t\t\tn = (n-1)/2;\n\t\t\tseg[n] = min(seg[n*2+1], seg[n*2+2]);\n\t\t}\n\t}\n\tll get(int n, int l, int r, int L, int R) {\n\t\tint m = (l + r) / 2;\n\t\tif (L <= l && r <= R) return seg[n];\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse return min( get(n*2+1, l, m, L, R), get(n*2+2, m, r, L, R) );\n\t}\n\tll get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\t\tvector<SegTree> segRow(H), segCol(W);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tsegRow[y].init(W);\n\t\t}\n\t\tfor (int x = 0; x < W; ++x) {\n\t\t\tsegCol[x].init(H);\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tsegRow[y].update(x, m[y][x]);\n\t\t\t\tsegCol[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tll ans = INF;\n\t\t\tif (W < H) {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, segCol[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, segRow[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = (1LL << 31) - 1;\n\nstruct segtree {\n\tint H, W, H_, W_;\n\tint dat[1000000];\n\tsegtree() {}\n\tsegtree(vector<vector<int>> &f) {\n\t\tinit(f);\n\t}\n\tint x(int i, int j) {\n\t\treturn i * W_ + j;\n\t}\n\n\tvoid init(vector<vector<int>> &f) {\n\t\tH = W = 1;\n\t\twhile(H < (int)f.size()) H <<= 1;\n\t\twhile(W < (int)f[0].size()) W <<= 1;\n\t\tH_ = 2 * H - 1, W_ = 2 * W - 1;\n\t\tfor(int i = 0; i < (int)f.size(); i++)\n\t\t\tfor(int j = 0; j < (int)f[0].size(); j++)\n\t\t\t\tdat[x(i + H - 1, j + W - 1)] = f[i][j];\n\t\tfor(int i = 2 * H - 2; i > H - 2; i--)\n\t\t\tfor(int j = W - 2; j >= 0; j--)\n\t\t\t\tdat[x(i, j)] = min(dat[x(i, 2 * j + 1)], dat[x(i, 2 * j + 2)]);\n\t\tfor(int i = H - 2; i >= 0; i--)\n\t\t\tfor(int j = 0; j < 2 * W - 1; j++)\n\t\t\t\tdat[x(i, j)] = min(dat[x(2 * i + 1, j)], dat[x(2 * i + 2, j)]);\n\t}\n\tint query(int li, int lj, int ri, int rj) { return query_h(li, lj, ri, rj, 0, H, 0); }\n\tint query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif(ri <= si || ti <= li) return INF;\n\t\tif(li <= si && ti <= ri) return query_w(lj, rj, 0, W, k, 0);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn min(query_h(li, lj, ri, rj, si, mi, 2 * k + 1), query_h(li, lj, ri, rj, mi, ti, 2 * k + 2));\n\t}\n\tint query_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif(rj <= sj || tj <= lj) return INF;\n\t\tif(lj <= sj && tj <= rj) return dat[x(i, k)];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn min(query_w(lj, rj, sj, mj, i, 2 * k + 1), query_w(lj, rj, mj, tj, i, 2 * k + 2));\n\t}\n};\n\nvector<vector<int>> f;\nsegtree st;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint r, c, q;\n\twhile(cin >> r >> c >> q, r | c | q) {\n\t\tf.assign(r, vector<int>(c, 0));\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\tfor(int j = 0; j < c; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\n\t\tst.init(f);\n\t\twhile(q--) {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st.query(r1, c1, r2 + 1, c2 + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint *dat;\nint R, C, W;\n\nvoid update(int r, int c, int x){\n\tr += R - 1;\n\tc += C - 1;\n\tdat[r * W + c] = x;\n\tint cc = c;\n\twhile(cc > 0){\n\t\tcc = (cc - 1) / 2;\n\t\tdat[r * W + cc] = min(dat[r * W + cc * 2 + 1], dat[r * W + cc * 2 + 2]);\n\t} // end while\n\n\twhile(r > 0){\n\t\tr = (r - 1) / 2;\n\t\tcc = c;\n\t\twhile(true){\n\t\t\tdat[r * W + cc] = min(dat[(r * 2 + 1) * W + cc], dat[(r * 2 + 2) * W + cc]);\n\t\t\tif (cc == 0) break;\n\t\t\tcc = (cc - 1) / 2;\n\t\t} // end while\n\t} // end while\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr){\n\tif (rr <= r1 || r2 <= rl || cr <= c1 || c2 <= cl) return INF;\n\tif (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) return dat[r * W + c];\n\tif (r1 <= rl && rr <= r2){\n\t\tint v1 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 1, cl, (cl + cr) / 2);\n\t\tint v2 = query(r1, c1, r2, c2, r, rl, rr, c * 2 + 2, (cl + cr) / 2, cr);\n\t\treturn min(v1, v2);\n\t}else{\n\t\tint v1 = query(r1, c1, r2, c2, r * 2 + 1, rl, (rl + rr) / 2, c, cl, cr);\n\t\tint v2 = query(r1, c1, r2, c2, r * 2 + 2, (rl + rr) / 2, rr, c, cl, cr);\n\t\treturn min(v1, v2);\n\t} // end if\n}\n\nint main()\n{\n\tint RR, CC, Q;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(cin >> RR >> CC >> Q){\n\t\tR = 1, C = 1;\n\t\twhile(R < RR) R *= 2;\n\t\twhile(C < CC) C *= 2;\n\t\tW = C * 2 - 1;\n\n\t\tdat = new int[(R * 2 - 1)*(C * 2 - 1)];\n\n\t\trep (i, RR){\n\t\t\trep (j, CC){\n\t\t\t\tint x; cin >> x;\n\t\t\t\tupdate(i, j, x);\n\t\t\t} // end rep\n\t\t} // end rep\n \t\trep (i, Q){\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tint ans = query(r1, c1, r2 + 1, c2 + 1, 0, 0, R, 0, 0, C);\n\t\t\tcout << ans << endl;\n\t\t} // end rep\n\n\t\tdelete[] dat;\n\t\tdat = 0;\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  int top(){\n    return data[0];\n  }\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  inline void update(int k, int x){\n    data[k + N - 1] = x;\n  }\n  void build(){\n    for(int k = N - 2; k >= 0; k--){\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b, int MIN){\n    return query(a, b, 0, 0, N, MIN);\n  }\n  int query(int a, int b, int k, int l, int r, int MIN){\n    if(b <= l || r <= a) return INF;\n    else if(a <= l && r <= b){\n      return data[k];\n    }else if(MIN <= data[k]){\n      return MIN;\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2, MIN), query(a, b, 2 * k + 2, (l + r) / 2, r, MIN));\n    }\n  }\n};\n \nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    //if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n        rmq[y].build();\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1, res));\n        }\n        printf(\"%d\\n\", res);\n      }\n    //}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tint Q;\n\t\n\twhile (1){\n\t\tscanf(\"%d %d %d\", &H, &W, &Q);\n\t\t\n\t\tif (H + W + Q == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint Hs = (int)sqrt(H) + 1;\n\t\tint Ws = (int)sqrt(W) + 1;\n\t\t\n\t\tvector<vector<int> > grid(H, vector<int>(W));\n\t\tvector<vector<int> > cmp(Hs, vector<int>(Ws));\n\t\t\n\t\tfor (int i = 0; i < Hs; i++){\n\t\t\tfor (int j = 0; j < Ws; j++){\n\t\t\t\tcmp[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tcmp[i / Hs][j / Ws] = min(cmp[i / Hs][j / Ws], grid[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tint h1, w1, h2, w2;\n\t\t\tscanf(\"%d %d %d %d\", &h1, &w1, &h2, &w2);\n\t\t\tint res = INT_MAX;\n\t\t\t\n\t\t\tfor (int j = h1 / Hs; j <= h2 / Hs; j++){\n\t\t\t\tfor (int k = w1 / Ws; k <= w2 / Ws; k++){\n\t\t\t\t\tif (h1 <= j * Hs && (j + 1) * Hs < h2 && w1 <= k * Ws && (k + 1) * Ws < w2){\n\t\t\t\t\t\tres = min(res, cmp[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (int l = max(j * Hs, h1); l <= min((j + 1) * Hs, h2); l++){\n\t\t\t\t\t\t\tfor (int m = max(k * Ws, w1); m <= max((k + 1) * Ws, w2); m++){\n\t\t\t\t\t\t\t\tres = min(res, grid[l][m]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", res);\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint data[1 << 23];\nint v[1 << 20];\nint r, c, q, r1, r2, c1, c2;\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif (ri <= si || ti <= li) return id;\n\t\tif (li <= si && ti <= ri) return sub_w(lj, rj, 0, w, k, 1);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn merge(sub_h(li, lj, ri, rj, si, mi, k * 2), sub_h(li, lj, ri, rj, mi, ti, k * 2 + 1));\n\t}\n\tT sub_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif (rj <= sj || tj <= lj) return id;\n\t\tif (lj <= sj && tj <= rj) return data[i * w * 2 + k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn merge(sub_w(lj, rj, sj, mj, i, k * 2), sub_w(lj, rj, mj, tj, i, k * 2 + 1));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), w(size(w_)), id(id_), merge(merge_) {\n\t\tfill(data, data + (1 << 23), id);\n\t\tfor (int i = 0; i < h_; i++)\n\t\t\tfor (int j = 0; j < w_; j++)\n\t\t\t\tdata[(h + i) * w * 2 + w + j] = v[i * w_ + j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n\t}\n\t//void Update(int pi, int pj, T val) { }\n\t//void Add(int pi, int pj, T val) { }\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub_h(li, lj, ri + 1, rj + 1, 0, h, 1);\n\t}\n};\n\nint main()\n{\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i * c + j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st2(r, c, INT_MAX, [](int l, int r) { return min(l, r); });\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st2.Find(r1, c1, r2, c2) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\nconst int inf = INT_MAX;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nint data[2 * 2 * 1000100];\n\nstruct SegmentTree2D\n{\n  int H, W;\n  int wid;\n  //vector< vector<int> > data;\n  SegmentTree2D(){}\n  SegmentTree2D(const int f[], int h, int w)\n  {\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    //data.resize(2*H-1, vector<int>(2*W-1, inf));\n    wid = 2*W-1;\n    fill(begin(data), end(data), inf);\n    init(f, h, w);\n  }\n  void init(const int f[], int h, int w)\n  {\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tdata[(i+H-1)*wid+(j+W-1)] = f[i*w+j];\n\n    for(int i = 2*H-2; i > H-2; i--)\n      for(int j = W-2; j >= 0; j--)\n\tdata[i*wid+j] = min(data[i*wid+(2*j+1)], data[i*wid+(2*j+2)]);\n\n    for(int i = H-2; i >= 0; i--)\n      for(int j = 0; j < 2*W-1; j++)\n\tdata[i*wid+j] = min(data[(2*i+1)*wid+j], data[(2*i+2)*wid+j]);\n  }\n  int query(int li, int lj, int ri, int rj)\n  {\n    return query_h(li, lj, ri, rj, 0, H, 0);\n  }\n  int query_h(int li, int lj, int ri, int rj, int ai, int bi, int k)\n  {\n    if(ri <= ai || bi <= li) return inf;\n    if(li <= ai && bi <= ri) return query_w(lj, rj, 0, W, k, 0);\n    return min(query_h(li, lj, ri, rj, ai, (ai+bi)/2, 2*k+1),\n\t       query_h(li, lj, ri, rj, (ai+bi)/2, bi, 2*k+2));\n  }\n  int query_w(int lj, int rj, int aj, int bj, int i, int k)\n  {\n    if(rj <= aj || bj <= lj) return inf;\n    if(lj <= aj && bj <= rj) return data[i*wid+k];\n    return min(query_w(lj, rj, aj, (aj+bj)/2, i, 2*k+1),\n\t       query_w(lj, rj, (aj+bj)/2, bj, i, 2*k+2));\n  }\n};\n\nint r, c, q;\nint grid[1000100];\nSegmentTree2D segT;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> r >> c >> q, r) {\n    rep(i, r) rep(j, c) cin >> grid[i*c+j];\n\n    segT = SegmentTree2D(grid, r, c);\n\n    while(q--) {\n      int lr, lc, rr, rc;\n      cin >> lr >> lc >> rr >> rc;\n      cout << segT.query(lr, lc, rr+1, rc+1) << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nconst int MAX_N = 1 << 20;\nconst unsigned int INF = 4294967295U;\nunsigned int n, dat[2*MAX_N-1];\n\nvoid init(int n_)\n{\n  n = 1;\n  while (n < n_)\n    n*= 2;\n  for (int i = 0; i < 2*n-1; ++i)\n    dat[i] = INF;\n}\n\nvoid update(int k, int a)\n{\n  k += n-1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k-1)/2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\nunsigned int query(int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l)\n    return INF;\n\n  if (a <= l && r <= b) {\n    return dat[k];\n  } else {\n    unsigned int vl = query(a, b, k*2+1, l, (l+r)/2);\n    unsigned int vr = query(a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  int r, c, q, g, r1, c1, r2, c2;\n  unsigned int ans = INF;\n  while (scanf(\"%d %d %d\", &r, &c, &q) != EOF) {\n    const int rc = r*c;\n    init(rc);\n\n    if (r <= c) {\n      for (int i = 0; i < rc; ++i) {\n\tscanf(\"%d\", &g);\n\tupdate(i, g);\n      }\n\n      for (int i = 0; i < q; ++i) {\n\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\tans = INF;\n\tfor (int j = r1; j <= r2; ++j)\n\t  ans = min(ans, query(j*c+c1, j*c+c2+1, 0, 0, n));\n\tprintf(\"%d\\n\", ans);\n      }\n    } else {\n      for (int i = 0; i < rc; ++i) {\n\tscanf(\"%d\", &g);\n\tupdate(i/c+(i%c)*r, g);\n      }\n\n      for (int i = 0; i < q; ++i) {\n\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\tans = INF;\n\tfor (int j = c1; j <= c2; ++j)\n\t  ans = min(ans, query(j*r+r1, j*r+r2+1, 0, 0, n));\n\tprintf(\"%d\\n\", ans);\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#define N 2555555\n\nusing namespace std;\n\nstruct node {\n\tint lx, ly, rx, ry, mx, my, f;\n} tree[N * 100];\n\nvector<int> a[N];\n\nvoid build(int d, int lx, int ly, int rx, int ry) {\n\ttree[d].lx = lx;\n\ttree[d].rx = rx;\n\ttree[d].ly = ly;\n\ttree[d].ry = ry;\n\tif (lx == rx && ly == ry) {\n\t\ttree[d].f = a[lx][ly];\n\t\treturn;\n\t}\n\ttree[d].mx = (lx + rx) >> 1;\n\ttree[d].my = (ly + ry) >> 1;\n\tif (lx == rx) {\n\t\tbuild(d << 2, lx, ly, lx, tree[d].my);\n\t\tbuild(d << 2 | 1, lx, tree[d].my + 1, rx, ry);\n\t\ttree[d].f = min(tree[d << 2].f, tree[d << 2 | 1].f);\n\t} else if (ly == ry) {\n\t\tbuild(d << 2 | 2, lx, ly, tree[d].mx, ry);\n\t\tbuild(d << 2 | 3, tree[d].mx + 1, ry, rx, ry);\n\t\ttree[d].f = min(tree[d << 2 | 2].f, tree[d << 2 | 3].f);\n\t} else {\n\t\tbuild(d << 2, lx, ly, tree[d].mx, tree[d].my);\n\t\tbuild(d << 2 | 1, lx, tree[d].my + 1, tree[d].mx, ry);\n\t\tbuild(d << 2 | 2, tree[d].mx + 1, ly, rx, tree[d].my);\n\t\tbuild(d << 2 | 3, tree[d].mx + 1, tree[d].my + 1, rx, ry);\n\t\tint ll = min(tree[d << 2].f, tree[d << 2 | 1].f);\n\t\tint rr = min(tree[d << 2 | 2].f, tree[d << 2 | 3].f);\n\t\ttree[d].f = min(ll, rr);\n\t}\n}\n\nint find(int d, int lx, int ly, int rx, int ry) {\n\tif (lx == tree[d].lx && ly == tree[d].ly && rx == tree[d].rx && ry == tree[d].ry) return tree[d].f;\n\tif (rx <= tree[d].mx && ry <= tree[d].my) return find(d << 2, lx, ly, rx, ry);\n\tif (rx <= tree[d].mx && ly > tree[d].my) return find(d << 2 | 1, lx, ly, rx, ry);\n\tif (lx > tree[d].mx && ry <= tree[d].my) return find(d << 2 | 2, lx, ly, rx, ry);\n\tif (lx > tree[d].mx && ly > tree[d].my) return find(d << 2 | 3, lx, ly, rx, ry);\n\tif (rx <= tree[d].mx) return min(find(d << 2, lx, ly, rx, tree[d].my), find(d << 2 | 1, lx, tree[d].my + 1, rx, ry));\n\tif (lx > tree[d].mx) return min(find(d << 2 | 2, lx, ly, rx, tree[d].my), find(d << 2 | 3, lx, tree[d].my + 1, rx, ry));\n\tif (ry <= tree[d].my) return min(find(d << 2, lx, ly, tree[d].mx, ry), find(d << 2 | 2, tree[d].mx + 1, ly, rx, ry));\n\tif (ry > tree[d].my) return min(find(d << 2 | 1, lx, ly, tree[d].mx, ry), find(d << 2 | 3, tree[d].mx + 1, ly, rx, ry));\n\tint ll = min(find(d << 2, lx, ly, tree[d].mx, tree[d].my), find(d << 2 | 2, tree[d].mx + 1, ly, rx, tree[d].my));\n\tint rr = min(find(d << 2 | 1, lx, tree[d].my + 1, tree[d].mx, ry), find(d << 2 | 3, tree[d].mx + 1, tree[d].my + 1, rx, ry));\n\treturn min(ll, rr);\n}\n\nint main() {\n\tint n, m, T;\n\tscanf(\"%d%d%d\", &n, &m, &T);\n\twhile (m + n + T) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i].clear();\n\t\t\ta[i].push_back(0);\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\ta[i].push_back(x);\n\t\t\t}\n\t\t}\n\t\tbuild(1, 1, 1, n, m);\n\t\tfor (int i = 1; i <= T; i++) {\n\t\t\tint xl, xr, yl, yr;\n\t\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\t\tprintf(\"%d\\n\", find(1, xl + 1, yl + 1, xr + 1, yr + 1));\n\t\t}\n\t\tscanf(\"%d%d%d\", &n, &m, &T);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int size){\n\tsize--;\n\trep(i,5) size|=size>>(1<<i);\n\treturn size+1;\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegTree2D{\n\tint size;\n\tvector<SegTree> data;\n\tSegTree2D(int h,int w):size(Need(h)),data(size*2,SegTree(w)){}\n\tvoid Update(int i,int j,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i].Update(j,x);\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\tint res=INFTY,m=(to+bo)/2;\n\t\tif(a<m) res=min(res,Query(a,b,c,d,i*2+0,to,m));\n\t\tif(m<c) res=min(res,Query(a,b,c,d,i*2+1,m,bo));\n\t\treturn res;\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(min(r,c),vi(max(r,c)));\n\t\tif(r<=c) rep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\telse     rep(j,r) rep(i,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvi r1(q),c1(q),r2(q),c2(q);\n\t\trep(i,q) scanf(\"%d%d%d%d\",&r1[i],&c1[i],&r2[i],&c2[i]);\n\t\t\n\t\tif(r>c){\n\t\t\tswap(r,c);\n\t\t\tswap(r1,c1);\n\t\t\tswap(r2,c2);\n\t\t}\n\t\t\n\t\tSegTree2D st(r,c);\n\t\trep(i,r) rep(j,c)\n\t\t\tst.Update(i,j,grid[i][j]);\n\t\t\n\t\trep(i,q)\n\t\t\tprintf(\"%d\\n\",st.Query(r1[i],c1[i],r2[i]+1,c2[i]+1));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)>>1;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)>>1;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W;\nint y1, x1, y2, x2;\nvector<vi> g;\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y][x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tg = vector<vi>(2*H - 1, vi(2*W - 1, inf));\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", &g[i + H - 1][j + W - 1]);\n\t\t\n\t\tfor(int i = 2*H-2; i >= 0; i--){\n\t\t\tfor(int j = 2*W-2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i][j] = min(min(g[i*2 + 1][j*2 + 1], g[i*2 + 2][j*2 + 2]),\n\t\t\t\t\t\tmin(g[i*2 + 2][j*2 + 1], g[i*2 + 1][j*2 + 2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i*2 + 1][j], g[i*2 + 2][j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i][j] = min(g[i][j], min(g[i][j*2 + 1], g[i][j*2 + 2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef unsigned int uint;\n\nconst uint INF = (uint)1 << 31;\nconst int sz = 1000010;\n\n\nuint field[sz];\nuint dat[sz * 20];\nint R, C, Q;\n#define DAT(kr, kc) dat[(kr) * C * 4 + (kc)]\n\nvoid build(int lr = 0, int rr = R,\n           int lc = 0, int rc = C,\n           int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr - lr == 0 || rc - lc == 0){\n    DAT(kr, kc) = INF;\n  }else if(rr - lr == 1 && rc - lc == 1){\n    DAT(kr, kc) = field[lr * C + lc];\n  }else{\n    if(r_axis){\n      int mr = (lr + rr) / 2;\n      build(lr, mr, lc, rc, kr * 2 + 1, kc, false);\n      build(mr, rr, lc, rc, kr * 2 + 2, kc, false);\n      DAT(kr, kc) = min(DAT(kr * 2 + 1, kc), DAT(kr * 2 + 2, kc));\n    }else{\n      int mc = (lc + rc) / 2;\n      build(lr, rr, lc, mc, kr, kc * 2 + 1, true);\n      build(lr, rr, mc, rc, kr, kc * 2 + 2, true);\n      DAT(kr, kc) = min(DAT(kr, kc * 2 + 1), DAT(kr, kc * 2 + 2));\n    }\n  }\n}\n\nuint query(int ar, int br, int ac, int bc,\n          int lr = 0, int rr = R, int lc = 0, int rc = C,\n          int kr = 0, int kc = 0, bool r_axis = true){\n  if(rr <= ar || br <= lr || rc <= ac || bc <= lc) return INF;\n  if(rr - lr == 0 || rc - lc == 0) return INF;\n  if(ar <= lr && rr <= br && ac <= lc && rc <= bc) return DAT(kr, kc);\n  \n  if(r_axis){\n    int mr = (lr + rr) / 2;\n    return min(query(ar, br, ac, bc, lr, mr, lc, rc, kr * 2 + 1, kc, false),\n               query(ar, br, ac, bc, mr, rr, lc, rc, kr * 2 + 2, kc, false));\n  }else{\n    int mc = (lc + rc) / 2;\n    return min(query(ar, br, ac, bc, lr, rr, lc, mc, kr, kc * 2 + 1, true),\n               query(ar, br, ac, bc, lr, rr, mc, rc, kr, kc * 2 + 2, true));\n  }\n}\n\n\nint main(){\n  int r1, r2, c1, c2;\n  \n  while(scanf(\"%d%d%d\", &R, &C, &Q) != EOF){\n    \n    REP(r, R)REP(c, C) scanf(\"%d\", &field[r * C + c]);\n\n    build();\n    REP(q, Q){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%u\\n\", query(r1, r2 + 1, c1, c2 + 1));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconst type INIT = INT_MAX;\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l)\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) {\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tinline void update(int k, type a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = function(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tinline type query(int a, int b) const {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tconst vector<type>& data() const {\n\t\treturn dat;\n\t}\n\n\tvoid merge(const segment_tree& s) {\n\t\tconst vector<type>& tmp = s.data();\n\t\tif(dat.size() != tmp.size()) return;\n\t\tfor(int i = 0; i < (int)dat.size(); ++i) {\n\t\t\tdat[i] = function(dat[i], tmp[i]);\n\t\t}\n\t}\n};\n\nclass segment_tree_2d {\nprivate:\n\tint n;\n\tvector<segment_tree> dat;\n\n    inline type function(type a, type b) const {\n\t\treturn min(a, b);\n\t}\n\n\ttype query(int r1, int r2, int c1, int c2, int k, int l, int r) const {\n\t\tif(r <= r1 || r2 <= l)\n\t\t\treturn INIT;\n\n\t\tif(r1 <= l && r <= r2) {\n\t\t\treturn dat[k].query(c1, c2);\n\t\t}\n\t\telse {\n\t\t\tconst type vl = query(r1, r2, c1, c2, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst type vr = query(r1, r2, c1, c2, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn function(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree_2d(int r, int c) {\n\t\tn = 1;\n\t\twhile(n < r) n *= 2;\n\t\tdat.resize(2 * n - 1, segment_tree(c));\n\t}\n\n\tinline void update(int y, int x, type a) {\n\t\ty += n - 1;\n\t\tdat[y].update(x, a);\n\n\t\twhile(y > 0) {\n\t\t\tconst int child = y;\n\t\t\ty = (y - 1) / 2;\n\t\t\tdat[y].merge(dat[child]);\n\t\t}\n\t}\n\n\tinline type query(int r1, int r2, int c1, int c2) const {\n\t\treturn query(r1, r2, c1, c2, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r, c, q; cin >> r >> c >> q, r;) {\n\t\tsegment_tree_2d seg(r, c);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tfor(int j = 0; j < c; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\tseg.update(i, j, in);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tint r1, r2, c1, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nlli Cmin(const lli a,const lli b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nclass SegmentTree{\n\tprivate:\n\tstatic const lli MAX_N=1<<31;\n\tlli dat[2*MAX_N-1];\n\tpublic:\n\tint n;\n\tvoid Init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tfor(int i=0; i<2*n-1; ++i) dat[i]=INF_;\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=n-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=Cmin(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n\tint GetData(const int k){\n\t\treturn dat[k];\n\t}\n};\n\nint Serialize(const int y,const int x,const int w){\n\treturn x+y*w;\n}\n\nint solve(){\n\tint R,C,Q;\n\tcin >> R >> C >> Q;\n\tif(R==0&&C==0&&Q==0) return 0;\n\tSegmentTree st;\n\tst.Init(R*C);\n\tREP(y,0,R) REP(x,0,C){\n\t\tlli tmp;\n\t\tcin >> tmp;\n\t\tst.Update(Serialize(y,x,C),tmp);\n\t}\n\t/*\n\tREP(i,0,R*C+st.n-1) cout << st.GetData(i) << endl;\n\tcout << endl;\n\t*/\n\tREP(i,0,Q){\n\t\tint r[2],c[2];\n\t\tREP(j,0,2) cin >> r[j] >> c[j];\n\t\tlli ans=INF_;\n\t\tREP(y,r[0],r[1]+1) ans=Cmin(ans,st.Query(Serialize(y,c[0],C),Serialize(y,c[1]+1,C),0,0,st.n));\n\t\tcout << ans << endl;\n\t}\n\t//REP(i,0,R*C) cout << st.GetData(i) << endl;\n\t//REP(y,0,R) REP(x,0,C) cout << st.GetData(Serialize(y,x,C)) << endl;\n\treturn 1;\n}\n\nint main(){\n\twhile(solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Need(int size){\n\tsize--;\n\trep(i,5) size|=size>>(1<<i);\n\treturn size+1;\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nstruct SegTree2D{\n\tint size;\n\tvector<SegTree> data;\n\tSegTree2D(int h,int w):size(Need(h)),data(size*2,SegTree(w)){}\n\tvoid Update(int i,int j,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i].Update(j,x);\n\t}\n\tint Query(int a,int b,int c,int d,int i,int to,int bo){\n\t\tif(c<=to || bo<=a) return INFTY;\n\t\tif(a<=to && bo<=c) return data[i].Query(b,d);\n\t\tint res=INFTY,m=(to+bo)/2;\n\t\tif(a<m) res=min(res,Query(a,b,c,d,i*2+0,to,m));\n\t\tif(m<c) res=min(res,Query(a,b,c,d,i*2+0,m,bo));\n\t\treturn res;\n\t}\n\tint Query(int a,int b,int c,int d){\n\t\treturn Query(a,b,c,d,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(r,vi(c));\n\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tSegTree2D st(r,c);\n\t\trep(i,r) rep(j,c) st.Update(i,j,grid[i][j]);\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tprintf(\"%d\\n\",st.Query(r1,c1,r2+1,c2+1));\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nlong long a[100000];\nlong long gcd(long long a,long long b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nint cmp(const long long &a,const long long &b)\n{\n\tif (a%2==0 && b%2==1) return 1;\n\telse if (a%2==1 && b%2==0) return 0;\n\telse return a<b;\n}\nint main()\n{\n\tint N,n;\n\twhile(1)\n\t{\n\t\tlong long x,y,z,tmp,r1,r2,d2,m,p,q;\n\t\tscanf(\"%d\",&n);\n\t\tif (n==0) break;\n\t\tN=(n+1)*n/2;\n\t\tfor (int i=1;i<=N;i++) scanf(\"%lld\",a+i);\n\n\t\tsort(a+1,a+N+1,cmp);\n\t\tx=a[n+1]; y=a[1];\tz=a[2];\n\n\t\ttmp=gcd(y,z);\tr1=y/tmp;\tr2=z/tmp;\n\t\td2=x/r1/r2;\n\n\t\tp=1;q=d2*1000;\n\t\twhile (p<=q)\n\t\t{\n\t\t\tif ((p&1) && (q&1)) m=(p>>1)+(q>>1)+1;\n\t\t\telse m=(p>>1)+(q>>1);\n\t\t\tif (m*m==d2) break;\n\t\t\telse if (m*m<d2) p=m+1;\n\t\t\telse q=m-1;\n\t\t}\n\t\ttmp/=m;\n\n\t\tprintf(\"%lld\\n\",tmp);\n\t\tfor (int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif (i<n) printf(\"%lld \",a[i]/tmp);\n\t\t\t\telse printf(\"%lld\\n\",a[i]/tmp);\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int grid[N];\n  int rmq[N];\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    int bs_r = (int)sqrt(r), bs_c = (int)sqrt(c);\n    int bn_r = r/bs_r, bn_c = c/bs_c;\n    if(r%bs_r)bn_r++;\n    if(c%bs_c)bn_c++;\n \n    for(int i=0;i<bn_r;i++){\n      for(int j=0;j<bn_c;j++)rmq[i*bn_c + j] = (1<<31) -1;\n    }\n    \n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin >> grid[i*c + j];\n\trmq[(i/bs_r) * bn_c + (j/bs_c)] = min(rmq[(i/bs_r) * bn_c + (j/bs_c)],grid[i*c + j]);\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int ans = (1<<31) -1;\n\n      int sr = r1/bs_r;\n      if(r1%bs_r){\n\tsr++;\n\tfor(int i=r1;i<sr*bs_r;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int sc = c1/bs_c;\n      if(c1%bs_c){\n\tsc++;\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<sc*bs_c;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gr = r2/bs_r;\n      if( (r2+1)%bs_r){\n\tfor(int i=gr*bs_r;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      int gc = c2/bs_c;\n      if( (c2+1)%bs_c){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=gc*bs_c;j<=c2;j++)ans = min(ans,grid[i*c+j]);\n\t}\n      }\n\n      if(sr == gr || sc == gc){\n\tfor(int i=r1;i<=r2;i++){\n\t  for(int j=c1;j<=c2;j++){\n\t    ans = min(ans,grid[i*c+j]);\n\t  }\n\t}\n      }else{\n\n\tfor(int i=sr;i<gr;i++){\n\t  for(int j=sc;j<gc;j++){\n\t    ans = min(ans,rmq[i*bn_c+j]);\n\t  }\n\t}\n      }\n\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n \nint data[1 << 22];\nint v[1 << 20];\n \ntemplate <typename T>\nclass SegmentTree2 {\n    using func_t = function<T(T, T)>;\n    const int h, w;\n    const T id;\n    func_t merge;\n    int size(int n) {\n        int res;\n        for (res = 1; res < n; res <<= 1);\n        return res;\n    }\n    T sub_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if (ri <= si || ti <= li) return id;\n        if (li <= si && ti <= ri) return sub_w(lj, rj, 0, w, k, 1);\n        const int mi = (si + ti) / 2;\n        return merge(sub_h(li, lj, ri, rj, si, mi, k * 2), sub_h(li, lj, ri, rj, mi, ti, k * 2 + 1));\n    }\n    T sub_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if (rj <= sj || tj <= lj) return id;\n        if (lj <= sj && tj <= rj) return data[i * w * 2 + k];\n        const int mj = (sj + tj) / 2;\n        return merge(sub_w(lj, rj, sj, mj, i, k * 2), sub_w(lj, rj, mj, tj, i, k * 2 + 1));\n    }\npublic:\n    SegmentTree2(int h_, int w_, T id_, func_t merge_) :\n        h(size(h_)), w(size(w_)), id(id_), merge(merge_) {\n        fill(data, data + (1 << 23), id);\n        for (int i = 0; i < h_; i++)\n            for (int j = 0; j < w_; j++)\n                data[(h + i) * w * 2 + w + j] = v[i * w_ + j];\n        for (int i = h * 2 - 1; i >= h; i--)\n            for (int j = w - 1; j > 0; j--)\n                data[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n        for (int i = h - 1; i > 0; i--)\n            for (int j = 1; j < w * 2; j++)\n                data[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n    }\n    void Update(int pi, int pj, T val) {\n        pi += h;\n        pj += w;\n        data[pi * w * 2 + pj] = val;\n        int tj = pj;\n        while (tj >>= 1) {\n            data[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n        }\n        while (pi >>= 1) {\n            data[pi * w * 2 + pj] = merge(data[(pi * 2) * w * 2 + pj], data[(pi * 2 + 1) * w * 2 + pj]);\n            tj = pj;\n            while (tj >>= 1) {\n                data[pi * w * 2 + tj] = merge(data[pi * w * 2 + tj * 2], data[pi * w * 2 + tj * 2 + 1]);\n            }\n        }\n    }\n    T Find(int li, int lj, int ri, int rj) {\n        return sub_h(li, lj, ri + 1, rj + 1, 0, h, 1);\n    }\n};\n \nint main()\n{\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    int r, c, q, r1, r2, c1, c2;\n    while (cin >> r >> c >> q, r | c | q) {\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                cin >> v[i * c + j];\n            }\n        }\n        SegmentTree2<int> st(r, c, INT_MAX, minQ);\n        while (q--) {\n            cin >> r1 >> c1 >> r2 >> c2;\n            printf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<int,int> pi;\nconst int inf=(1ll<<31)-1;\nconst double INF=1e12,EPS=1e-9;\n\nint h, w, q, H, W, W_;\nint y1, x1, y2, x2, g[1000000];\n \nint rec(int Y1, int X1, int Y2, int X2, int y, int x){\n\tif(y2 <= Y1 || y1 >= Y2 || x2 <= X1 || x1 >= X2) return inf;\n\tif(y1 <= Y1 && Y2 <= y2 && x1 <= X1 && X2 <= x2) return g[y*W_ + x];\n\tint res = inf;\n\t \n\t//if(y < 0 || x < 0) assert(0);\n\tif(Y1+1 == Y2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, Y2, (X1+X2) / 2, y, x*2 + 1),\n\t\t\t\trec(Y1, (X1+X2) / 2, Y2, X2, y, x*2 + 2)\n\t\t\t));\n\telse if(X1+1 == X2)\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, X2, y*2 + 1, x),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, X2, y*2 + 2, x)\n\t\t\t));\n\telse{\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, X1, (Y1+Y2) / 2, (X1+X2) / 2, y*2 + 1, x*2 + 1),\n\t\t\t\trec((Y1+Y2) / 2, X1, Y2, (X1+X2) / 2, y*2 + 2, x*2 + 1)\n\t\t\t));\n\t\tres = min(res,\n\t\t\tmin(\n\t\t\t\trec(Y1, (X1+X2) / 2, (Y1+Y2) / 2, X2, y*2 + 1, x*2 + 2),\n\t\t\t\trec((Y1+Y2) / 2, (X1+X2) / 2, Y2, X2, y*2 + 2, x*2 + 2)\n\t\t\t));\n\t}\n\treturn res;\n}\n \nint main(){\n\twhile(scanf(\"%d%d%d\", &h ,&w, &q), w){\n\t\tfor(H = 1; H < h; H *= 2);\n\t\tfor(W = 1; W < w; W *= 2);\n\t\tW_ = 2*W - 1;\n\t\trep(i, (2*H-1) * (2*W-1)) g[i] = inf;\n\t\trep(i,h) rep(j,w)\n\t\t\tscanf(\"%d\", g + (i+H-1) * W_ + j+W-1);\n\t\t\n\t\tfor(int i = 2*H - 2; i >= 0; i--){\n\t\t\tfor(int j = 2*W - 2; j >= 0; j--){\n\t\t\t\tif(i < H-1 && j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(min(g[(i*2+1) * W_ + j*2 + 1], g[(i*2+2) * W_ + j*2+2]),\n\t\t\t\t\t\tmin(g[(i*2+2) * W_ + j*2+1], g[(i*2+1) * W_ + j*2+2]));\n\t\t\t\tif(i < H-1) \n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[(i*2 + 1) * W_ + j], g[(i*2 + 2) * W_ + j]));\n\t\t\t\tif(j < W-1)\n\t\t\t\t\tg[i*W_ + j] = min(g[i*W_ + j], min(g[i * W_ + j*2+1], g[i * W_ + j*2+2]));\n\t\t\t}\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n\t\t\ty2++; x2++;\n\t\t\tprintf(\"%d\\n\", rec(0, 0, H, W, 0, 0));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n#define Seg_Max_N (1<<18) \n\nusing Value =int;\nconst Value ini = 1e9;\nstruct segtree {\n\tint type = -1;\n\tsegtree* a;\n\tsegtree* b;\n\tint minnum;\n\n\tsegtree() {}\n\tsegtree(vector<vector<int>>&vs, const int l, const int r, const int u, const int d)  {\n\t\tif (l + 1 == r&&u + 1 == d) {\n\t\t\ttype = -1;\n\t\t\tminnum = vs[u][l];\n\t\t}\n\t\telse {\n\t\t\tif (r - l < d - u) {\n\t\t\t\t//tatenibunnkatu\n\t\t\t\ttype = 1;\n\t\t\t\ta = new segtree(vs, l, r, u, (u + d) / 2);\n\t\t\t\tb = new segtree(vs, l, r, (u + d) / 2, d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype = 2;\n\t\t\t\ta = new segtree(vs, l, (l + r) / 2 , u, d);\n\t\t\t\tb = new segtree(vs, (l+r)/2, r, u, d);\n\t\t\t}\n\t\t\tminnum = min(a->minnum, b->minnum);\n\t\t}\n\t}\n\t\n\t// min [a, b)\n\tint  query(const int ql,const int qr,const int qu,const int qd,const int nl,const int nr,const int nu,const int nd) {\n\t\tif (nr <= ql || qr <= nl)return 2147483647;\n\t\telse if (nd<= qu|| qd <= nu)return 2147483647;\n\t\tif (ql <= nl&&nr <= qr&&qu <= nu&&nd <= qd)return minnum;\n\t\tint aa, ab;\n\t\tif (type == 1) {\n\n\t\t\taa = a->query(ql, qr, qu, qd,nl,nr,nu,(nu+nd)/2);\n\t\t\tab = b->query(ql, qr, qu, qd,nl,nr,(nu+nd)/2,nd);\n\t\t}\n\t\telse {\n\n\t\t\taa = a->query(ql, qr, qu, qd, nl, (nl+nr)/2, nu,nd);\n\t\t\tab = b->query(ql, qr, qu, qd, (nl + nr) / 2, nr, nu, nd);\n\t\t}\n\t\tint ans = min(aa, ab);\n\t\treturn ans;\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint ar, ac, q; cin >> ar >> ac >> q;\n\t\tif (!ar)break;\n\t\tvector<vector<int>>vs(ar, vector<int>(ac));\n\t\tfor (int i = 0; i < ar; ++i) {\n\t\t\tfor (int j = 0; j < ac; ++j) {\n\t\t\t\tcin >> vs[i][j];\n\t\t\t}\n\t\t}\n\t\tsegtree seg(vs, 0, ac, 0, ar);\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tint u, l, d, r; cin >> u >> l >> d >> r; d++; r++;\n\t\t\tint ans = seg.query(l, r, u, d,0,ac,0,ar);\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nbool swaped;\n\nstruct pool {\n    void * dat;\n    int end;\n    pool(int size){\n        dat = malloc(size);\n        end = 0;\n    }\n    ~pool(){\n        free(dat);\n    }\n    void * fetch(int size){\n        void * res = (char*)dat + end;\n        end+=size;\n        return res;\n    }\n    void reset(){\n        end = 0;\n    }\n};\n\npool mem_pool(sizeof(dat_t[300000*2]));\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        fill(dat, dat+k*2, inf);\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        dat = (dat_t*)mem_pool.fetch(sizeof(dat_t)*n*2);\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        if(swaped) swap(x,y);\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        SegTree2D tree(r,c);\n        if(r>c) swaped = true;\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n        mem_pool.reset();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(r);\n    int cs=sqrt(c);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i*rs+k<r&&j*cs+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<min(rt+1,(l+cs-1)/cs*cs);j++){\n\t  m=min(m,v[i][j]);\n\t}\n\tfor(int j=max(rt/cs*cs,l);j<=rt;j++){\n\t  m=min(m,v[i][j]);\n\t}\n      }\n      for(int i=l;i<=rt;i++){\n\tfor(int j=t;j<min(b+1,(t+rs-1)/rs*rs);j++){\n\t  m=min(m,v[j][i]);\n\t}\n\tfor(int j=max(b/rs*rs,t);j<=b;j++){\n\t  m=min(m,v[j][i]);\n\t}\n      }\n      for(int i=(t+rs-1)/rs;i*rs+rs<=b+1;i++){\n\tfor(int j=(l+cs-1)/cs;j*cs+cs<=rt+1;j++){\n\t  m=min(m,vs[i][j]);\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\nclass RMQ{\npublic:\n  RMQ(){}\n  RMQ(int n_){\n    init(n_);\n  }\n  void init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    dat.resize(2*n - 1);\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = INT_MAX;\n  }\n  void update(int k,int a){\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1)/2;\n      dat[k] = min(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  void print(){\n    for (int i = n - 1; i < 2*n - 1; i++) {\n      std::cout << dat[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  lli query(int a,int b,int k = 0,int l = 0,int r = 0){\n    if(r <= l) r = n;\n    if(r <= a || b <= l) return 1e11;\n    if(a <= l && r <= b) return dat[k];\n    int vl = query(a, b, k*2 + 1, l, (r + l)/2);\n    int vr = query(a, b, k*2 + 2, (r + l)/2, r);\n    return min(vl,vr);\n  }\nprivate:\n  int n;\n  vector<int>dat;\n};\n\nvector<RMQ> makeSegTree(bool f, int mini,\n                        vector<vector<int > >& grid){\n  vector<RMQ> res(mini);\n  int maxi = max(grid.size(), grid[0].size());\n  for (int i = 0; i < mini; i++) {\n    res[i].init(maxi);\n  }\n  for (int i = 0; i < mini; i++) {\n    for (int j = 0; j < maxi; j++) {\n      if(f) res[i].update(j, grid[j][i]);\n      else res[i].update(j, grid[i][j]);\n    }\n  }\n  return res;\n}\nvoid printGrid(vector<vector<int> >& grid){\n  for (int i = 0; i < grid.size(); i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n      std::cout << grid[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n}\nint main(){\n  int r, c, q;\n  while(std::cin >> r >> c >> q){\n    if(r == 0 && c == 0)break;\n    int mini = min(r, c);\n    vector<vector<int> > grid(r, vector<int>(c));\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j < c; j++) {\n        std::cin >> grid[i][j];\n      }\n    }\n    vector<RMQ> t = makeSegTree(r > c, mini, grid);\n    //std::cout << \"ho\" << std::endl;\n    //for (int i = 0; i < t.size(); i++) {\n      //t[i].print();\n    //}\n    int x = 0, y, xx, yy;\n    for (int i = 0; i < q; i++) {\n      lli ans = 1e11;\n      std::cin >> x >> y >> xx >> yy;\n      if(r > c)swap(x, y),swap(xx, yy);\n      //std::cout << x << \" \" << y << \" \" << xx << \" \" << yy << std::endl;\n      for (int j = x; j <= xx; j++) {\n        ans = min(ans, t[j].query(y, yy + 1));\n      }\n      std::cout << ans << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\ntypedef long long LL;\nconst int oo = 0x7fffffff;\nconst int Max = 1048576;\nconst int MaxN = 4;\nconst int MaxLg = 16;\nint A[Max],Log[MaxN],tableMin[MaxN][MaxLg];\nvoid makeRMinQ(int *a,int s,int t){\n\tint i,j,n = t-s;\n\tfor (i = s;i < t;i++) tableMin[i-s][0] = a[i];\n\t//for (i = s;i < t;i++)printf(\"%d \",a[i]);puts(\"\");\n\tfor (j = 1;(1 << j) <= n;j++)\n\t\tfor (i = s;i+(1 << j) <= t;i++)\n\t\t\ttableMin[i-s][j] = min(tableMin[i-s][j-1],tableMin[i-s+(1 << (j-1))][j-1]);\n}\nint QueryMin(int x,int y){\n\tint p = Log[y-x+1];//calLog2(y-x+1);\n\treturn min(tableMin[x][p],tableMin[y-(1 << p)+1][p]);\n}\nconst int MaxQ = 10010;\nstruct query{\n    int x1,y1,x2,y2;\n};\nquery fQ[MaxQ];\nint Res[MaxQ];\nint main(){\n\tfor (int i = 0,x = 0,cd = 2;i < MaxN;x++,cd<<=1)\n\t\twhile (i < MaxN && i < cd)\n\t\t    Log[i++] = x;\n    for (int R,C,Q;scanf(\"%d%d%d\",&R,&C,&Q) && R;){\n        if (R <= C){\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[i*C+j]);\n            for (int q = 0;q < Q;q++)\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n        }else{\n            for (int i = 0;i < R;i++)\n                for (int j = 0;j < C;j++)\n                    scanf(\"%d\",&A[j*R+i]);\n            swap(R,C);\n            for (int q = 0;q < Q;q++){\n                scanf(\"%d%d%d%d\",&fQ[q].x1,&fQ[q].y1,&fQ[q].x2,&fQ[q].y2);\n                swap(fQ[q].x1,fQ[q].y1);\n                swap(fQ[q].x2,fQ[q].y2);\n            }\n        }\n        for (int q = 0;q < Q;q++)\n            Res[q] = oo;\n        //for (int q = 0;q < Q;q++)printf(\"(%d,%d)-(%d,%d)\\n\",fQ[q].x1,fQ[q].y1,fQ[q].x2,fQ[q].y2);\n        int fC = (C-1) / MaxN+1;\n        for (int i = 0;i < R;i++){\n            for (int j = 0,k = 0;j < fC;j++){\n                int nk = min(C,k+MaxN);\n                makeRMinQ(A,i*C+k,i*C+nk);\n                for (int q = 0;q < Q;q++){\n                    if (i < fQ[q].x1 || fQ[q].x2 < i)\n                        continue;\n                    int cs = max(fQ[q].y1,k);\n                    int ct = min(fQ[q].y2,nk-1);\n                    if (cs > ct) continue;\n                    //printf(\"%d : %d\\n\",q,QueryMin(cs-k,ct-k));\n                    Res[q] = min(Res[q],QueryMin(cs-k,ct-k));\n                }\n                k = nk;\n            }\n        }\n        for (int q = 0;q < Q;q++)if (Res[q] == oo) while(1);\n        for (int q = 0;q < Q;q++)\n            printf(\"%d\\n\",Res[q]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize <<= 2) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/4;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tr = min(r, seg[n*4+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint next = i == 3 ? r : prev + (r-l)/4;\n\t\t\t\tret = min(ret, get(n*4+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef vector<vector<int> > matrix;\nmatrix dat;\nint R, C;\n\nvoid update(int r, int c, int a) {\n  bool f = 0;\n  if (r==0&&c==1) f = 1;\n  r += R - 1;\n  c += C - 1;\n  dat[r][c] = a;\n  int cc = c;\n  while(cc > 0) {\n    cc = (cc-1) / 2;\n    dat[r][cc] = min(dat[r][cc*2+1], dat[r][cc*2+2]);\n    if (f) {\n//      printf(\"(%d,%d) %d\\n\", r,cc,dat[r][cc]);\n    }\n  }\n  while(r > 0) {\n    r = (r-1) / 2;\n    cc = c;\n    while(1) {\n      dat[r][cc] = min(dat[r*2+1][cc], dat[r*2+2][cc]);\n      if (cc == 0) break;\n      cc = (cc-1) / 2;\n      if (f) {\n//        printf(\"(%d,%d) %d\\n\", r,cc,dat[r][cc]);\n      }\n\n    }\n  }\n}\n\nint query(int r1, int c1, int r2, int c2, int r, int rl, int rr, int c, int cl, int cr) {\n  if (rr<=r1 || r2<=rl || cr<=c1 || c2<=cl) return INF;\n//  printf(\"(%d,%d)(%d,%d)  (%d,%d)\\n\", rl,cl,rr,cr,r,c);\n  if (r1 <= rl && rr <= r2 && c1 <= cl && cr <= c2) {\n//    cout << \"HOGE\" << \" \" << dat[r][c]<< endl;\n    return dat[r][c];\n  }\n  if (r1 <= rl && rr <= r2) {   // cðª\n    int v1 = query(r1,c1,r2,c2,r,rl,rr,c*2+1,cl,(cl+cr)/2);\n    int v2 = query(r1,c1,r2,c2,r,rl,rr,c*2+2,(cl+cr)/2, cr);\n    return min(v1,v2);\n  } else {                      // ¡ðª\n    int v1 = query(r1,c1,r2,c2,r*2+1,rl,(rl+rr)/2,c,cl,cr);\n    int v2 = query(r1,c1,r2,c2,r*2+2,(rl+rr)/2,rr,c,cl,cr);\n    return min(v1,v2);\n  }\n}\nint main() {\n  int q;\n  while(cin >>R>>C>>q, R||C||q) {\n    int RR = R, CC = C;\n    R = 1; C = 1;\n    while(R < RR) R *= 2;\n    while(C < CC) C *= 2;\n    dat.assign(2*R-1, vector<int>(2*C-1, INF));\n    REP(i,RR) REP(j,CC) {\n      int a;\n      cin >> a;\n      update(i,j,a);\n    }\n    REP(i,q) {\n      int r1,c1,r2,c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << query(r1,c1,r2+1,c2+1,0,0,R,0,0,C) << endl;\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define la (tr[rt].a)\n#define lb (tr[rt].b)\n#define lc (tr[rt].c)\n#define ld (tr[rt].d)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\nstruct seg{\n    int x1,y1,x2,y2;\n    int v;\n    int a,b,c,d;\n    int midx(){\n        return (x1+x2)>>1;\n    }\n    int midy(){\n        return (y1+y2)>>1;\n    }\n}tr[40000010];\nint matrix[10000010];\nint tot;\nint r,c,q;\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    //printf(\"%d %d %d %d %d\\n\",rt,x1,y1,x2,y2);\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1>=x2&&y1>=y2){\n        tr[rt].v = matrix[x1*c+y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2){\n        tr[rt].a = ++tot;\n        tr[rt].b = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        return;\n    }\n    else if(y1 == y2){\n        tr[rt].a = ++tot;\n        tr[rt].c = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n        return;\n    }\n    else{\n        tr[rt].a = ++tot;\n        tr[rt].b = ++tot;\n        tr[rt].c = ++tot;\n        tr[rt].d = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n        return;\n    }\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1){\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx){\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my){\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx){\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my){\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q){\n        tot = 0;\n        for(int i = 0; i < r; ++i){\n            for(int j = 0; j < c; ++j){\n                int x;\n                scanf(\"%d\",&x);\n                matrix[i*c+j] = x;\n            }\n        }\n        build(0,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i){\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(0,a,b,c,d));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=400000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\n//const ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    w=h=max(w,h);\n    //if(h>w)w=h;\n    //if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\nconst ll INF = LLONG_MAX;\n// const int MOD = (int)1e9 + 7;\n// const double EPS = 1e-10;\n#define PI acosl(-1)\n#define MAX_N 3000005\n    ll h, w, H, W, q;\n    ll dat[MAX_N];\n\nclass SegmentTree2D {\nprotected:\n\n  // ??¨????????????????????????????????¢??°\n    virtual ll _func(ll a, ll b) = 0;\n\n    ll query_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n        if(ri <= si or ti <= li) return _getDefaultValue();\n        if(li <= si and ti <= ri) return query_w(lj,rj,0,W,k,0);\n        const int mi = (si+ti)/2;\n        return _func(query_h(li,lj,ri,rj,si,mi,2*k+1), query_h(li,lj,ri,rj,mi,ti,2*k+2));\n    }\n    ll query_w(int lj, int rj, int sj, int tj, int i, int k) {\n        if(rj <= sj or tj <= lj) return _getDefaultValue();\n        if(lj <= sj and tj <= rj) return get(i, k);\n        const int mj = (sj+tj)/2;\n        return _func(query_w(lj,rj,sj,mj,i,2*k+1),query_w(lj,rj,mj,tj,i,2*k+2));\n    }\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n    virtual ll _getDefaultValue() = 0;\n\n    SegmentTree2D(){}\n\n    ll get(int hh, int ww){\n      // printf(\"get (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, dat[hh * W + ww]);\n      return dat[hh * 2*W + ww];\n    }\n\n    void set(int hh, int ww, ll v){\n      // printf(\"set (%d, %d)[%lld] = %lld\\n\", hh, ww, hh*W+ww, v);\n      dat[hh * 2*W + ww] = v;\n    }\n\n\n    void init() {\n        // H = W = 1;\n        // while(H < (int)f.size()) H <<= 1;\n        // while(W < (int)f[0].size()) W <<= 1;\n        // dat.assign(2*H-1,VL(2*W-1, _getDefaultValue()));\n        for (int i = 2*H-2; i > H-2; i--)\n            for (int j = W-2; j >= 0; j--){\n              set(i, j, _func(get(i, 2*j+1), get(i, 2*j+2)));\n\n            }\n        for (int i = H-2; i >= 0; i--)\n            for (int j = 0; j < 2*W-1; j++){\n                set(i, j,_func(get(2*i+1, j), get(2*i+2, j)));\n\n            }\n    }\n    // [(li, ri), (lj, rj)]??????????????¨???????±???????\n    ll query(int li, int lj, int ri, int rj) { return query_h(li,lj,ri + 1,rj + 1,0,H,0); }\n};\n\nclass SegmentTree2DMin : public SegmentTree2D {\n  using SegmentTree2D::SegmentTree2D;\nprotected:\n  // ??¨????????????????????????????????¢??°\n  ll _func(ll a, ll b){\n    return min(a, b);\n  }\n\npublic:\n  // ??¨???????????????????????????????????????????????????????????????\n  ll _getDefaultValue(){\n    return LLONG_MAX;\n  }\n};\n\nvoid exec(){\n\n  int tmp, r1, r2, c1, c2;\n    SegmentTree2DMin st2 = SegmentTree2DMin();\n    for (int i = 0; i < MAX_N; i++){\n      dat[i] = st2._getDefaultValue();\n    }\n    for (int i = 0; i < h; i++)\n    for (int j = 0; j < w; j++){\n      scanf(\"%d\", &tmp);\n      st2.set(i+H-1, j+W-1, tmp);\n\n    }\n    st2.init();\n\n    for (int i = 0; i < q; i++){\n      scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n      printf(\"%lld\\n\", st2.query(r1, c1, r2, c2));\n    }\n}\n\nvoid solve(){\n  while (scanf(\"%lld%lld%lld\", &h, &w, &q)!=EOF){\n    if (h + w + q <= 0){\n      break;\n    }\n    H = W = 1;\n    while(H < h) H <<= 1;\n    while(W < w) W <<= 1;\n    exec();\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint grid[1000000],pos[1000000];\n\nvoid qsort(int left, int right){\n  int l,r,p,ppos;\n\n    l = left;\n    r = right;\n    p = grid[left];\n    ppos = pos[left];\n    while(l < r){\n      while((grid[r] >= p) && (l < r))r--;\n      if(l!=r){\n\tgrid[l] = grid[r];\n\tpos[l] = pos[r];\n\tl++;\n      }\n      while((grid[l] <= p) && (l < r))l++;\n      if(l!=r){\n\tgrid[r] = grid[l];\n\tpos[r] = pos[l];\n\tr--;\n      }\n    }\n    grid[l] = p;\n    pos[l] = ppos;\n    p = l;\n    if (left < p)qsort(left, p-1);\n    if (right > p)qsort(p+1, right);\n}\n\nint main(){\n  int r,c,q;\n  int r1,r2,c1,c2;\n  int min;\n\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    if(0){//r*c <= 50000){\n      for(int i=0;i<r;i++){\n\tfor(int j=0;j<c;j++){\n\t  cin >> grid[i*c+j];\n\t}\n      }\n      \n      for(int i=0;i<q;i++){\n\tcin >> r1 >> c1 >> r2 >> c2;\n\tmin = 2147483647;\n\t\n\tfor(int j=r1;j<=r2;j++){\n\t  for(int k=c1;k<=c2;k++){\n\t    if(min > grid[j*c+k])min = grid[j*c+k];\n\t  }\n\t}\n\tcout << min << endl;\n      }\n    }else{\n      if(r<c){\n\tfor(int i=0;i<r;i++){\n\t  for(int j=0;j<c;j++){\n\t    cin >> grid[i*c+j];\n\t    pos[i*c+j] = j;\n\t  }\n\t  qsort(i*c,(i+1)*c-1);\n\t}\n\n\tfor(int i=0;i<q;i++){\n\t  cin >> r1 >> c1 >> r2 >> c2;\n\t  min = 2147483647;\n\t  for(int j=r1;j<=r2;j++){\n\t    for(int k=0;k<c;k++){\n\t      if(min <= grid[j*c+k])break;\n\t      else{\n\t\tif(pos[j*c+k] >= c1 && pos[j*c+k] <=c2){\n\t\t  min = grid[j*c+k];\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  cout << min << endl;\n\t}\n      }else{\n\tfor(int i=0;i<r;i++){\n\t  for(int j=0;j<c;j++){\n\t    cin >> grid[j*r+i];\n\t    pos[j*r+i] = i;\n\t  }\n\t}\n\n\tfor(int i=0;i<c;i++)qsort(i*r,(i+1)*r-1);\n\n\tfor(int i=0;i<q;i++){\n\t  cin >> r1 >> c1 >> r2 >> c2;\n    \t  min = 2147483647;\n\t  for(int j=c1;j<=c2;j++){\n\t    for(int k=0;k<r;k++){\n\t      if(min <= grid[j*r+k])break;\n\t      else{\n\t\tif(pos[j*r+k] >= r1 && pos[j*r+k] <= r2){\n\t\t  min = grid[j*r+k];\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  cout << min << endl;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0x7fffffff;\n\n#define GET(a,b) seg_tree[(a)*seg_W + (b)]\n\nint W, H, WW, HH, seg_H, seg_W;\nvector< vector<int> > data;\nint *seg_tree;\n\nint query_brute(int y1, int x1, int y2, int x2){\n\tint ret = data[y1][x1];\n\tfor(int i=y1; i<y2; i++){\n\t\tfor(int j=x1; j<x2; j++){\n\t\t\tret = min(ret, data[i][j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//y in [0, H)\nvoid initialize_W(int y, int cur_node, int lx, int rx){\n\tif(rx - lx <= 1){\n\t\tif(y < H){\n\t\t\tGET(y+HH-1, cur_node) = data[y][lx];\n\t\t}\n\t\treturn ;\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\n\tinitialize_W(y, 2*cur_node + 1, lx, mid);\n\tinitialize_W(y, 2*cur_node + 2, mid, rx);\n\n\tGET(y+HH-1, cur_node) = min(GET(y+HH-1, 2*cur_node+1), GET(y+HH-1, 2*cur_node+2));\n}\n\nint query_W(int node_y, int fx, int tx, int cur_node, int lx, int rx){\n\tif( rx <= fx || tx <= lx ){\n\t\treturn INF;\n\t}\n\n\tif( fx <= lx && rx <= tx ){\n\t\treturn GET(node_y, cur_node);\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\treturn min(query_W(node_y, fx, tx, cur_node*2 + 1, lx, mid),\n\t\t\tquery_W(node_y, fx, tx, cur_node*2 + 2, mid, rx));\n}\n\nvoid initialize_H(int cur_node, int ly, int ry){\n\tif(ry - ly <= 1){\n\t\tinitialize_W(ly, 0, 0, WW);\n\t\treturn ;\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\n\tinitialize_H(2*cur_node + 1, ly, mid);\n\tinitialize_H(2*cur_node + 2, mid, ry);\n\n\tfor(int j=0; j<seg_W; j++){\n\t\tGET(cur_node, j) = min(GET(2*cur_node+1,j), GET(2*cur_node+2, j));\n\t}\n}\n\nint query_H(int fy, int ty, int fx, int tx, int cur_node, int ly, int ry){\n\tif( ry <= fy || ty <= ly ){\n\t\treturn INF;\n\t}\n\n\tif( fy <= ly && ry <= ty ){\n\t\treturn query_W(cur_node, fx, tx, 0, 0, WW);\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\treturn min(query_H(fy, ty, fx, tx, cur_node*2 + 1, ly, mid),\n\t\t\tquery_H(fy, ty, fx, tx, cur_node*2 + 2, mid, ry));\n}\n\n// [y1, y2) * [x1, x2)\nint query_segtree(int y1, int x1, int y2, int x2){\n\treturn query_H(y1, y2, x1, x2, 0, 0, HH);\n}\n\nvoid build_segtree(){\n\tconst int log_H = H == 1 ? 0 : 31 - __builtin_clz(H-1), log_W = W == 1 ? 0 :31 - __builtin_clz(W-1);\n\tHH = 1<<(log_H+1);\n\tWW = 1<<(log_W+1);\n\tseg_H = 2*HH - 1;\n\tseg_W = 2*WW - 1;\n\n\tseg_tree = (int *)malloc(seg_H*seg_W*sizeof(int));\n\n\tfor(int i=0; i<seg_H; i++){\n\t\tfor(int j=0; j<seg_W; j++){\n\t\t\tGET(i,j) = INF;\n\t\t}\n\t}\n\n\tinitialize_H(0, 0, HH);\n}\n\nint main(){\n\tint Q;\n\twhile(scanf(\"%d%d%d\",&H,&W,&Q), H){\n\t\tconst int log_H = 31 - __builtin_clz(H), log_W = 31 - __builtin_clz(W);\n\t\tdata.clear();\n\t\tdata = vector< vector<int> >(H, vector<int>(W));\n\n\t\tfor(int i=0; i<H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tscanf(\"%d\", &data[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tbuild_segtree();\n\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d%d%d%d\",&y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", query_segtree(y1, x1, y2+1, x2+1));\n\t\t}\n\t\tfree(seg_tree);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int map[1000000];\n  int rmq[2000];\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int rr,rc;\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    rr = (int)sqrt(r);\n    rc = (int)sqrt(c);\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> map[i*c+j];\n    }\n\n    for(int i=0;i<r/rr;i++){\n      for(int j=0;j<c/rc;j++){\n\trmq[i*(c/rc)+j] = 1<<31 - 1;\n\tint ur = min( (i+1)*rr, r);\n\tfor(int k=i*rr;k<ur;k++){\n\t  int uc = min( (j+1)*rc, c);\n\t  for(int l=j*rc;l<uc;l++){\n\t    rmq[i*(c/rc)+j] = min(rmq[i*(c/rc)+j],map[k*c+l]);\n\t  }\n\t}\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int tr1,tc1,tr2,tc2;\n      tr1 = r1/rr;\n      if(r1%rr)tr1++;\n      tc1 = c1/rc;\n      if(c1%rc)tc1++;\n      tr2 = r2/rr;\n      if( !((r2+1)%rr) )tr2++;\n      tc2 = c2/rc;\n      if( !((c2+1)%rc) )tc2++;\n\n      int m = 1<<31 - 1;\n      for(int i=r1;i<tr1*rr;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n\n      for(int i=tr2*rr;i<=r2;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n      \n      for(int i=r1;i<=r2;i++){\n\tfor(int j=c1;j<tc1*rc;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n\tfor(int j=tc2*rc;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t}\n      }\n\n      for(int i=tr1;i<tr2;i++){\n\tfor(int j=tc1;j<tc2;j++){\n\t  m = min(m,rmq[i*(c/rc)+j]);\n\t}\n      }\n      cout << m << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000000\nusing namespace std;\ntypedef long long ll;\n\nint r, c, q, S;\nvector<ll> v[1000];\n\nvoid init(int x, int y){\n\trep(i,x){\n\t\trep(j,y*4){\n\t\t\tv[i][j] = INF;\n\t\t}\n\t}\n\tS = 1;\n\twhile(S <= y) S *= 2;\n}\n\nvoid update(int y, int x, ll t){\n\tx += S-1;\n\tv[y][x] = t;\n\twhile(x > 0){\n\t\tx = (x-1)/2;\n\t\tv[y][x] = min(v[y][2*x+1],v[y][2*x+2]);\n\t}\n}\n\nll get(int z, int a, int b, int t, int r, int l){\n\tif(a >= l || b <= r) return INF;\n\tif(a <= r && l <= b) return v[z][t];\n\treturn min(get(z,a,b,t*2+1,r,(r+l)/2),get(z,a,b,t*2+2,(r+l)/2,l));\n}\n\nint main(){\n\trep(i,1000){\n\t\trep(j,1000000/(i+1)*4){\n\t\t\tv[i].push_back(0);\n\t\t}\n\t}\n\twhile(scanf(\"%d%d%d\", &r, &c, &q), r||c||q){\n\t\tinit(min(r,c), max(r,c));\n\t\tif(r < c){\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(i,j,tmp);\n\t\t\t}\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t} else{\n\t\t\tll tmp;\n\t\t\trep(i,r) rep(j,c){\n\t\t\t\tscanf(\"%lld\",&tmp);\n\t\t\t\tupdate(j,i,tmp);\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t\trep(i,q){\n\t\t\t\tint y1, x1, y2, x2;\n\t\t\t\tll ans = INF;\n\t\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\t\tfor(int j = y1; j <= y2; j++){\n\t\t\t\t\tans = min(ans,get(j,x1,x2+1,0,0,S));\n\t\t\t\t}\n\t\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define la (rt*4)\n#define lb (rt*4+1)\n#define lc (rt*4+2)\n#define ld (rt*4+3)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\nstruct seg{\n    int x1,y1,x2,y2;\n    int v;\n    int midx(){\n        return (x1+x2)>>1;\n    }\n    int midy(){\n        return (y1+y2)>>1;\n    }\n}tr[10000010];\nvector<int>matrix[1000010];\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    //printf(\"%d %d %d %d %d\\n\",rt,x1,y1,x2,y2);\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1==x2&&y1==y2){\n        tr[rt].v = matrix[x1][y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2){\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n    }\n    else if(y1 == y2){\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n    }\n    else{\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n    }\n    return;\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1){\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx){\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my){\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx){\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my){\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    int r,c,q;\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q){\n        for(int i = 0; i < r; ++i){\n            matrix[i].clear();\n            for(int j = 0; j < c; ++j){\n                int x;\n                scanf(\"%d\",&x);\n                matrix[i].push_back(x);\n            }\n        }\n        build(1,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i){\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(1,a,b,c,d));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int map[1000000];\n  int rmq[2000];\n  int r,c,q;\n  int r1,c1,r2,c2;\n  int rr,rc;\n\n  while(1){\n    cin >> r >> c >> q;\n    if(!r && !c && !q)break;\n\n    rr = (int)sqrt(r);\n    rc = (int)sqrt(c);\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++)cin >> map[i*c+j];\n    }\n\n    for(int i=0;i<r/rr;i++){\n      for(int j=0;j<c/rc;j++){\n\trmq[i*(c/rc)+j] = 1<<31 - 1;\n\tint ur = min( (i+1)*rr, r);\n\tfor(int k=i*rr;k<ur;k++){\n\t  int uc = min( (j+1)*rc, c);\n\t  for(int l=j*rc;l<uc;l++){\n\t    rmq[i*(c/rc)+j] = min(rmq[i*(c/rc)+j],map[k*c+l]);\n\t  }\n\t}\n      }\n    }\n\n    while(q--){\n      cin >> r1 >> c1 >> r2 >> c2;\n      int tr1,tc1,tr2,tc2;\n      tr1 = r1/rr;\n      if(r1%rr)tr1++;\n      tc1 = c1/rc;\n      if(c1%rc)tc1++;\n      tr2 = r2/rr;\n      if( !((r2+1)%rr) )tr2++;\n      tc2 = c2/rc;\n      if( !((c2+1)%rc) )tc2++;\n\n      int m = 1<<31 - 1;\n      int ur = min(tr1*rr,r2);\n      for(int i=r1;i<ur;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t  //cout << \"1:{\" << i << \" \" << j << \"}\" << endl;\n\t}\n      }\n\n      int lr = max(tr2*rr,r1);\n      for(int i=lr;i<=r2;i++){\n\tfor(int j=c1;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t  //cout << \"2:{\" << i << \" \" << j << \"}\" << endl;\n\t}\n      }\n      \n      for(int i=r1;i<=r2;i++){\n\tint uc = min(tc1*rc,c2);\n\tfor(int j=c1;j<uc;j++){\n\t  m = min(m,map[i*c+j]);\n\t  //cout << \"3:{\" << i << \" \" << j << \"}\" << endl;\n\t}\n\tint lc = max(tc2*rc,c1);\n\tfor(int j=lc;j<=c2;j++){\n\t  m = min(m,map[i*c+j]);\n\t  //cout << \"4:{\" << i << \" \" << j << \"}\" << endl;\n\t}\n      }\n\n      for(int i=tr1;i<tr2;i++){\n\tfor(int j=tc1;j<tc2;j++){\n\t  m = min(m,rmq[i*(c/rc)+j]);\n\t  //cout << \"[\" << i << \" \" << j << \"]\" << endl;\n\t}\n      }\n      cout << m << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\n\nconst int INF=(1<<31)-1;\n\ntemplate<class T> struct Interval{\n\tT a,b;\n\tInterval(T A,T B):a(A),b(B){}\n};\n\ntemplate<class T>\nclass RMQ{\n\tint n;\n\tT *a;\n\n\tT query(const Interval<int> &I,const Interval<int> &J,int u){\n\t\tif(J.b<=I.a || I.b<=J.a) return INF;\n\t\tif(I.a<=J.a && J.b<=I.b) return a[u];\n\n\t\tint m=(J.a+J.b)/2;\n\t\tT tl=query(I,Interval<int>(J.a,m),2*u+1);\n\t\tT tr=query(I,Interval<int>(m,J.b),2*u+2);\n\t\treturn tl<tr?tl:tr;\n\t}\n\npublic:\n\tRMQ(){}\n\n\tRMQ(const vector< vector<T> > &v,int k,int b):n(1){\n\t\tint N;\n\t\tif(!b) N=v[0].size();\n\t\telse   N=v.size();\n\n\t\twhile(n<N) n<<=1;\n\t\ta=(T *)malloc((2*n-1)*sizeof(T));\n\t\trep(i,2*n-1) a[i]=0;\n\n\t\tif(!b) rep(i,N) a[n+i-1]=v[k][i];\n\t\telse   rep(i,N) a[n+i-1]=v[i][k];\n\n\t\tfor(int i=n-2;i>=0;i--) a[i]=min(a[2*i+1],a[2*i+2]);\n\t}\n\n\tT query(int a,int b){\n\t\treturn query(Interval<int>(a,b),Interval<int>(0,n),0);\n\t}\n};\n\nint main(){\n\tfor(int h,w,q;scanf(\"%d%d%d\",&h,&w,&q),h||w||q;){\n\t\tvvi a(h,vi(w));\n\t\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\t\tRMQ<int> *rmq1=(RMQ<int> *)malloc(h*sizeof(RMQ<int>));\n\t\tRMQ<int> *rmq2=(RMQ<int> *)malloc(w*sizeof(RMQ<int>));\n\t\trep(i,h) rmq1[i]=RMQ<int>(a,i,0);\n\t\trep(j,w) rmq2[j]=RMQ<int>(a,j,1);\n\n\t\trep(_,q){\n\t\t\tint t,l,b,r; scanf(\"%d%d%d%d\",&t,&l,&b,&r); b++; r++;\n\n\t\t\tint ans=INF;\n\t\t\tif(b-t<r-l) for(int i=t;i<b;i++) ans=min(ans,rmq1[i].query(l,r));\n\t\t\telse        for(int j=l;j<r;j++) ans=min(ans,rmq2[j].query(t,b));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <list>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m,Q;\nint inf=2147483647;\n#define maxn 1700000\ninline void zy(int &a,int b)\n{\n\tif(b<a)a=b;\n}\nstruct Node{\n\tint mn;\n\tint x1,x2,y1,y2;\n\tNode *lu,*ld,*ru,*rd;\n\tvoid init(int _x1,int _x2,int _y1,int _y2){\n\t\tx1=_x1,x2=_x2;\n\t\ty1=_y1,y2=_y2;\n\t\tlu=ld=ru=rd=NULL;\n\t\tmn=inf;\n\t}\n\tinline void update(){\n\t\tmn=inf;\n\t\tif( lu ) zy(mn,lu->mn);\n\t\tif( ld ) zy(mn,ld->mn);\n\t\tif( ru ) zy(mn,ru->mn);\n\t\tif( rd ) zy(mn,rd->mn);\n\t}\n}dd[maxn],*root;\nint e; \nNode* _alloc(int x1,int x2,int y1,int y2){\n\tif(e>maxn-10)exit(1);\n\tdd[e].init(x1,x2,y1,y2); return &dd[e++];\n}\nvoid insert(Node *p,int x,int y,int g){\n\tif( p->x1==p->x2 && p->y1==p->y2 ) {\n\t\tp->mn=g;\n\t\treturn;\n\t}\n\tint midx=(p->x1+p->x2)/2;\n\tint midy=(p->y1+p->y2)/2;\n\tif( x<=midx && y>midy ) {\n\t\tif( p->lu==NULL ) p->lu=_alloc(p->x1,midx,midy+1,p->y2);\n\t\tinsert(p->lu,x,y,g);\n\t}else if( x<=midx && y<=midy ){\n\t\tif( p->ld==NULL ) p->ld=_alloc(p->x1,midx,p->y1,midy);\n\t\tinsert(p->ld,x,y,g);\n\t}else if( x>midx && y>midy ){\n\t\tif( p->ru==NULL ) p->ru=_alloc(midx+1,p->x2,midy+1,p->y2);\n\t\tinsert(p->ru,x,y,g);\n\t}else{\n\t\tif( p->rd==NULL ) p->rd=_alloc(midx+1,p->x2,p->y1,midy);\n\t\tinsert(p->rd,x,y,g);\n\t}\n\tp->update();\n}\nint query(Node *p,int x1,int x2,int y1,int y2){\n\tif( p==NULL ) return inf;\n\tx1=max(x1,p->x1);\n\ty1=max(y1,p->y1);\n\tx2=min(x2,p->x2);\n\ty2=min(y2,p->y2);\n\tif( x1>x2 || y1>y2 ) return inf;\n\n\tif( x1==p->x1 && x2==p->x2 && y1==p->y1 && y2==p->y2 ) return p->mn;\n\treturn min(query(p->lu,x1,x2,y1,y2) ,min( query(p->ld,x1,x2,y1,y2),(min(\n\t\tquery(p->ru,x1,x2,y1,y2) , query(p->rd,x1,x2,y1,y2)))));\n}\n\nint main()\n{\n\twhile(cin>>n>>m>>Q&&n)\n\t{\n\t\te=0;\n\t\tdd[e].init(0,n-1,0,m-1); //32768=2^31\n\t\troot=&dd[e++];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int q=0;q<m;q++)\n\t\t\t{\n\t\t\t\tint z;\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\tinsert(root,i,q,z);\n\t\t\t}\n\t\twhile(Q--)\n\t\t{\n\t\t\tint x1,x2,y1,y2;\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",query(root,x1,x2,y1,y2));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <vector>\n\ntypedef long long TYPE;\nTYPE inf = 10000000000000000;\n\nusing namespace std;\n\nclass Segment2d\n{\npublic:\n\tSegment2d(const int h, const int w);\n\tvoid set(const int y, const int x, const TYPE val);\n\tTYPE query(const int ys, const int ye, const int xs, const int xe);\n\tvoid print();\nprivate:\n\tTYPE query(const int ys, const int ye, const int xs, const int xe, \n\t\tconst int qys, const int qye, const int qxs, const int qxe);\n\tTYPE queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k);\n\tTYPE queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx);\n\n\tconst int height;\n\tconst int width;\n\n\tint height2;\n\tint width2;\n\tvector<vector<TYPE>> data;\n\n\tint left(const int parent);\n\tint right(const int parent);\n\tint parent(const int child);\n};\n\nvoid Segment2d::print()\n{\n\tfor(int i = 0; i < 2 * height2 - 1; i++)\n\t{\n\t\tfor(int j = 0; j < 2 * width2 - 1; j++)\n\t\t{\n\t\t\tcerr << data[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint Segment2d::left(const int parent)\n{\n\treturn parent * 2 + 1;\n}\n\nint Segment2d::right(const int parent)\n{\n\treturn parent * 2 + 2;\n}\n\nint Segment2d::parent(const int child)\n{\n\treturn (child - 1) / 2;\n}\n\nSegment2d::Segment2d(const int h, const int w)\n: height(h)\n, width(w)\n{\n\twidth2 = 1;\n\twhile(width2 < width) width2 *= 2;\n\theight2 = 1;\n\twhile(height2 < height) height2 *= 2;\n\n\tfor(int i = 0; i < height2 * 2 - 1; i++)\n\t{\n\t\tdata.push_back(vector<TYPE>(width2 * 2 - 1));\n\t\tfill(data[i].begin(), data[i].end(), inf);\n\t}\n}\n\nvoid Segment2d::set(int y, int x, TYPE val)\n{\n\ty += height2 - 1;\n\tx += width2 - 1;\n\n\tdata[y][x] = val;\n\n\tvector<int> ys = {y};\n\twhile(y > 0)\n\t{\n\t\ty = parent(y);\n\t\tys.push_back(y);\n\t}\n\tvector<int> xs = {x};\n\twhile(x > 0)\n\t{\n\t\tx = parent(x);\n\t\txs.push_back(x);\n\t}\n\n\tfor(int i = 1; i < ys.size(); i++)\n\t{\n\t\tdata[ys[i]][xs[0]] = \n\t\tmin(data[left(ys[i])][xs[0]], \n\t\t\tdata[right(ys[i])][xs[0]]);\n\t}\n\tfor(int i = 0; i < ys.size(); i++)\n\t{\n\t\tfor(int j = 1; j < xs.size(); j++)\n\t\t{\n\t\t\tdata[ys[i]][xs[j]] = \n\t\t\tmin(data[ys[i]][left(xs[j])], \n\t\t\t\tdata[ys[i]][right(xs[j])]);\n\t\t}\n\t}\n}\n\nTYPE Segment2d::query(const int qys, const int qye, const int qxs, const int qxe)\n{\n\treturn queryY(0, height2, qys, qye, qxs, qxe, 0);\n}\n\nTYPE Segment2d::queryY(const int ys, const int ye, const int qys, \n\tconst int qye, const int qxs, const int qxe, const int k)\n{\n\tif(qye <= ys || ye <= qys)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qys <= ys && ye <= qye) \n\t{\n\t\treturn queryX(0, width2, qxs, qxe, k, 0);\n\t}\n\telse \n\t{\n\t\tconst int mid_y = (ys + ye) / 2;\n\t\treturn min(queryY(ys, mid_y, qys, qye, qxs, qxe, left(k)), \n\t\t\tqueryY(mid_y, ye, qys, qye, qxs, qxe, right(k)));\n\t}\n}\n\nTYPE Segment2d::queryX(const int xs, const int xe, const int qxs, \n\tconst int qxe, const int ky, const int kx)\n{\n\tif(qxe <= xs || xe <= qxs)\n\t{\n\t\treturn inf;\t\n\t}\n\telse if(qxs <= xs && xe <= qxe) \n\t{\n\t\treturn data[ky][kx];\n\t}\n\telse \n\t{\n\t\tconst int mid_x = (xs + xe) / 2;\n\t\treturn min(queryX(xs, mid_x, qxs, qxe, ky, left(kx)), \n\t\t\tqueryX(mid_x, xe, qxs, qxe, ky, right(kx)));\n\t}\n}\n\nvoid test()\n{\n\tconst int height = 3;\n\tconst int width = 3;\n\tSegment2d seg(height, width);\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tseg.set(i, j, i * 100 + j);\n\t\t}\n\t}\n\n\tseg.print();\n\n\tfor(int i = 0; i < height; i++)\n\t{\n\t\tfor(int j = 0; j < width; j++)\n\t\t{\n\t\t\tcerr << seg.query(i, i+1, j, j+1) << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true)\n\t{\n\t\tint r, c, q;\n\t\tcin >> r >> c >> q;\t\n\t\tif(r == 0 && c == 0 && q == 0) break;\n\n\t\tSegment2d seg(r, c);\n\n\t\tfor(int i = 0; i < r; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < c; j++)\n\t\t\t{\n\t\t\t\tTYPE v;\n\t\t\t\tcin >> v;\n\t\t\t\tseg.set(i, j, v);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << seg.query(r1, r2 + 1, c1, c2 + 1) << endl;\n\t\t}\t\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\nconst int INF = (1LL << 31) - 1;\nint h, w;\n// vector<vector<int> > g;\nvector<int> g[1024];\n\n// vector<vector<int> > data;\nvector<int> data[2 * 1024];\nint size(int n)\n{\n    int m = 1;\n    while (m < n)\n        m *= 2;\n    return m;\n}\nvoid build_segtree()\n{\n    for (int i = 0; i < 2 * h - 1; ++i)\n    {\n        data[i].clear();\n        data[i].resize(2 * w - 1, INF);\n    }\n\n    // x\n    for (int y = 0; y < h; ++y)\n    {\n        const int i = y + (h - 1);\n\n        for (int x = 0; x < w; ++x)\n            data[i][x + (w - 1)] = g[y][x];\n\n        for (int k = w - 2; k >= 0; --k)\n            data[i][k] = min(data[i][2 * k + 1], data[i][2 * k + 2]);\n    }\n\n    // y\n    for (int i = h - 2; i >= 0; --i)\n        for (int j = 0; j < 2 * w - 1; ++j)\n            data[i][j] = min(data[2 * i + 1][j], data[2 * i + 2][j]);\n}\nint x_query(int y_k, int x1, int x2, int k, int l, int r)\n{\n    if (x2 <= l || r <= x1)\n        return INF;\n    else if (x1 <= l && r <= x2)\n        return data[y_k][k];\n\n    int mid = (l + r) / 2;\n    int lv = x_query(y_k, x1, x2, 2 * k + 1, l, mid);\n    int rv = x_query(y_k, x1, x2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint y_query(int x1, int x2, int y1, int y2, int k, int l, int r)\n{\n    if (y2 <= l || r <= y1)\n        return INF;\n    else if (y1 <= l && r <= y2)\n        return x_query(k, x1, x2, 0, 0, w);\n\n    int mid = (l + r) / 2;\n    int lv = y_query(x1, x2, y1, y2, 2 * k + 1, l, mid);\n    int rv = y_query(x1, x2, y1, y2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint main()\n{\n    fast_io();\n\n    int _h, _w, q;\n    while (cin >> _h >> _w >> q, _h)\n    {\n        h = size(_h), w = size(_w);\n        bool swawa = false;\n        if (_h < _w)\n        {\n            swawa = true;\n            swap(w, h);\n        }\n        for (int i = 0; i < h; ++i)\n        {\n            g[i].clear();\n            g[i].resize(w, INF);\n        }\n        for (int y = 0; y < _h; ++y)\n        {\n            for (int x = 0; x < _w; ++x)\n            {\n                if (!swawa)\n                    cin >> g[y][x];\n                else\n                    cin >> g[x][y];\n            }\n        }\n\n        build_segtree();\n\n        while (q--)\n        {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            ++x2, ++y2;\n            if (swawa)\n            {\n                swap(x1, y1);\n                swap(x2, y2);\n            }\n            cout << y_query(x1, x2, y1, y2, 0, 0, h) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=0x7f7f7f7f7f7f7f7f;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    memset(dat,0x7f,sizeof(dat));\n   // fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n// AOJ 1068 - School of Killifish\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector<value_type> m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size = 0, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.assign(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n\tvalue_type operator[](size_t i) const {\n\t\treturn m_data[m_size - 1 + i];\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename Traits>\nclass SegmentTree2D {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector< SegmentTree<Traits> > m_data;\n\tsize_t m_width, m_height;\n\n\tvoid initialize(){\n\t\tvector<value_type> work(m_width);\n\t\tfor(int i = static_cast<int>(m_height) - 2; i >= 0; --i){\n\t\t\tfor(size_t j = 0; j < m_width; ++j){\n\t\t\t\twork[j] =\n\t\t\t\t\tm_traits(m_data[i * 2 + 1][j], m_data[i * 2 + 2][j]);\n\t\t\t}\n\t\t\tm_data[i] = SegmentTree<Traits>(work.begin(), work.end());\n\t\t}\n\t}\n\n\tvalue_type query(\n\t\tint x0, int y0, int x1, int y1, int k, int l, int r) const\n\t{\n\t\tif(r <= y0 || y1 <= l){ return m_traits.default_value(); }\n\t\tif(y0 <= l && r <= y1){ return m_data[k].query(x0, x1); }\n\t\tconst value_type vl = query(x0, y0, x1, y1, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(x0, y0, x1, y1, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree2D(\n\t\tsize_t height = 0, size_t width = 0, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(width)\n\t{\n\t\twhile(m_height < height){ m_height *= 2; }\n\t\tm_data.assign(m_height * 2 - 1, SegmentTree<Traits>(width, traits));\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree2D(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_traits(traits), m_height(1), m_width(0)\n\t{\n\t\tconst size_t h = distance(first, last);\n\t\twhile(m_height < h){ m_height *= 2; }\n\t\tif(h > 0){ m_width = distance(first->begin(), first->end()); }\n\t\tm_data.resize(m_height * 2 - 1, SegmentTree<Traits>(m_width, traits));\n\t\tsize_t row = m_height - 1;\n\t\tfor(Iterator it = first; it != last; ++it, ++row){\n\t\t\tm_data[row] = SegmentTree<Traits>(it->begin(), it->end());\n\t\t}\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, size_t j, const value_type &val){\n\t\ti += m_height - 1;\n\t\tm_data[i].update(j, val);\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i].update(j, m_traits(\n\t\t\t\tm_data[i * 2 + 1][j], m_data[i * 2 + 2][j]));\n\t\t}\n\t}\n\n\tvalue_type query(size_t x0, size_t y0, size_t x1, size_t y1) const {\n\t\treturn query(x0, y0, x1, y1, 0, 0, m_height);\n\t}\n\n};\n\n\n}\n}\n\n\nnamespace libcomp {\nnamespace structure {\n\n\ntemplate <typename T>\nstruct MinSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::max(); }\n\tT operator()(const T &a, const T &b) const { return min(a, b); }\n};\n\n\n}\n}\n\n\nusing libcomp::structure::SegmentTree2D;\nusing libcomp::structure::MinSegmentTreeTraits;\ntypedef SegmentTree2D< MinSegmentTreeTraits<int> > MinSegmentTree2D;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tsize_t r, c, q;\n\t\tcin >> r >> c >> q;\n\t\tif(r == 0 && c == 0 && q == 0){ break; }\n\t\tMinSegmentTree2D st(r, c);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tfor(int j = 0; j < c; ++j){\n\t\t\t\tint aij;\n\t\t\t\tcin >> aij;\n\t\t\t\tst.update(i, j, aij);\n\t\t\t}\n\t\t}\n\t\twhile(q--){\n\t\t\tint y0, x0, y1, x1;\n\t\t\tcin >> y0 >> x0 >> y1 >> x1;\n\t\t\tcout << st.query(x0, y0, x1 + 1, y1 + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=0x7f7f7f7f7f7f7f7fLL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    memset(dat,0x7f,sizeof(dat));\n   // fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        //if(dat[k*2+2]==-1)\n        //    dat[k]=dat[k*2+1];\n        //else if(dat[k*2+1]==-1)\n        //    dat[k]=dat[k*2+2];\n        //else\n        //    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    //if(vr==-1)\n    //    return vl;\n    //else if(vl==-1)\n    //    return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            ll res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0x7fffffff;\n\nint W, H, WW, HH, seg_H, seg_W;\nvector< vector<int> > data;\nvector< vector<int> > seg_tree;\n\nint query_brute(int y1, int x1, int y2, int x2){\n\tint ret = data[y1][x1];\n\tfor(int i=y1; i<y2; i++){\n\t\tfor(int j=x1; j<x2; j++){\n\t\t\tret = min(ret, data[i][j]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//y in [0, H)\nvoid initialize_W(int y, int cur_node, int lx, int rx){\n\tif(rx - lx <= 1){\n\t\tif(y < H){\n\t\t\tseg_tree[y + HH - 1][cur_node] = data[y][lx];\n\t\t}\n\t\treturn ;\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\n\tinitialize_W(y, 2*cur_node + 1, lx, mid);\n\tinitialize_W(y, 2*cur_node + 2, mid, rx);\n\n\tseg_tree[y + HH - 1][cur_node] = min(seg_tree[y + HH - 1][2*cur_node + 1], seg_tree[y + HH - 1][2*cur_node + 2]);\n}\n\nint query_W(int node_y, int fx, int tx, int cur_node, int lx, int rx){\n\tif( rx <= fx || tx <= lx ){\n\t\treturn INF;\n\t}\n\n\tif( fx <= lx && rx <= tx ){\n\t\treturn seg_tree[node_y][cur_node];\n\t}\n\n\tconst int mid = (lx + rx) / 2;\n\treturn min(query_W(node_y, fx, tx, cur_node*2 + 1, lx, mid),\n\t\t\tquery_W(node_y, fx, tx, cur_node*2 + 2, mid, rx));\n}\n\nvoid initialize_H(int cur_node, int ly, int ry){\n\tif(ry - ly <= 1){\n\t\tinitialize_W(ly, 0, 0, WW);\n\t\treturn ;\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\n\tinitialize_H(2*cur_node + 1, ly, mid);\n\tinitialize_H(2*cur_node + 2, mid, ry);\n\n\tfor(int j=0; j<seg_W; j++){\n\t\tseg_tree[cur_node][j] = min(seg_tree[2*cur_node + 1][j], seg_tree[2*cur_node + 2][j]);\n\t}\n}\n\nint query_H(int fy, int ty, int fx, int tx, int cur_node, int ly, int ry){\n\tif( ry <= fy || ty <= ly ){\n\t\treturn INF;\n\t}\n\n\tif( fy <= ly && ry <= ty ){\n\t\treturn query_W(cur_node, fx, tx, 0, 0, WW);\n\t}\n\n\tconst int mid = (ly + ry) / 2;\n\treturn min(query_H(fy, ty, fx, tx, cur_node*2 + 1, ly, mid),\n\t\t\tquery_H(fy, ty, fx, tx, cur_node*2 + 2, mid, ry));\n}\n\n// [y1, y2) * [x1, x2)\nint query_segtree(int y1, int x1, int y2, int x2){\n\treturn query_H(y1, y2, x1, x2, 0, 0, HH);\n}\n\nvoid build_segtree(){\n\tconst int log_H = H == 1 ? 0 : 31 - __builtin_clz(H-1), log_W = W == 1 ? 0 :31 - __builtin_clz(W-1);\n\tHH = 1<<(log_H+1);\n\tWW = 1<<(log_W+1);\n\tseg_H = 2*HH - 1;\n\tseg_W = 2*WW - 1;\n\n\tseg_tree.clear();\n\tseg_tree = vector< vector<int> >(seg_H, vector<int>(seg_W, INF));\n\n\tinitialize_H(0, 0, HH);\n}\n\nint main(){\n\tint Q;\n\twhile(scanf(\"%d%d%d\",&H,&W,&Q), H){\n\t\tconst int log_H = 31 - __builtin_clz(H), log_W = 31 - __builtin_clz(W);\n\t\tdata.clear();\n\t\tseg_tree.clear();\n\n\t\tdata = vector< vector<int> >(H, vector<int>(W));\n\n\t\tfor(int i=0; i<H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tscanf(\"%d\", &data[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tif(W*H > 250000){\n\t\t\tbuild_segtree();\n\t\t}\n\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tint y1, x1, y2, x2;\n\t\t\tscanf(\"%d%d%d%d\",&y1, &x1, &y2, &x2);\n\t\t\tprintf(\"%d\\n\", (W*H > 250000 ? query_segtree(y1, x1, y2+1, x2+1) : query_brute(y1, x1, y2+1, x2+1)));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  void update(int k, int x){\n    k += N - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b){\n    return query(a, b, 0, 0, N);\n  }\n  int query(int a, int b, int k, int l, int r){\n    if(b <= l || r <= a) return INF;\n    if(a <= l && r <= b){\n      return data[k];\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int x = x1; x <= x2; x++){\n          res = min(res, rmq[x].query(y1, y2 + 1));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename V> struct SPA2 {\n\tprivate:\n\tvector<vector<vector<vector<V> > > > sp;\n\tpublic:\n\tSPA2(int h, int w) { sp = vector<vector<vector<vector<V> > > >(log2(h)+1, vector<vector<vector<V> > >(h, vector<vector<V> >(log2(w)+1, vector<V>(w, 1<<30))));}\n\tvoid update(int i, int j, V a) { sp[0][i][0][j] = a;}\n\tvoid build() {\n\t\tint h = sp[0].size(), w = sp[0][0][0].size(), ir, ic, jr, jc;\n\t\tfor (ir=0;ir<h;ir++)\n\t\t\tfor (jc=1;jc<=log2(w);jc++)\n\t\t\t\tfor (ic=0;ic+(1<<(jc-1))<w;ic++)\n\t\t\t\t\tsp[0][ir][jc][ic] = min(sp[0][ir][jc-1][ic], sp[0][ir][jc-1][ic+(1<<(jc-1))]);\n\t\tfor (jr=1;jr<=log(h);jr++)\n\t\t\tfor (ir=0;ir+(1<<(jr-1))<h;ir++)\n\t\t\t\tfor (jc=0;jc<=log(w);jc++)\n\t\t\t\t\tfor (ic=0;ic<w;ic++)\n\t\t\t\t\t\tsp[jr][ir][jc][ic] = min(sp[jr-1][ir][jc][ic], sp[jr-1][ir+(1<<(jr-1))][jc][ic]);\n\t}\n\tV query(int xa, int ya, int xb, int yb) { // min\n\t\tint kx = log2(xb-xa+1), ky = log2(yb-ya+1);\n\t\tint min_R1 = min(sp[kx][xa][ky][ya], sp[kx][xa][ky][yb+1-(1<<ky)]);\n\t\tint min_R2 = min(sp[kx][xb+1-(1<<kx)][ky][ya], sp[kx][xb+1-(1<<kx)][ky][yb+1-(1<<ky)]);\n\t\treturn min(min_R1, min_R2);\n\t}\n};\n\nint h, w, q, xa, ya, xb, yb;\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> q;\n\t\tif (h==0) break;\n\t\tSPA2<int> sp(h,w);\n\t\tint t;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> t;\n\t\t\tsp.update(i,j,t);\n\t\t}\n\t\tsp.build();\n\t\twhile (q--) {\n\t\t\tcin >> xa >> ya >> xb >> yb;\n\t\t\tcout << sp.query(xa,ya,xb,yb) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint r, c, q;\nint _r, _c;\nint g;\nvi* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vi[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nint _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nint query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nint **fld,**bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new int*[H];\n    bucket=new int*[H/B+1];\n    for(int i=0;i<H;i++)fld[i]=new int[W];\n    for(int i=0;i<H/B+1;i++)bucket[i]=new int[W/B+1];\n    fill_n(*bucket,(H/B+1)*(W/B+1),INT_MAX);\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[(y2-1)/B])y2=y2/B*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[(x2-1)/B])x2=x2/B*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 2147483647;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct RMQ{\n  vector<int> data;\n  int N;\n  int top(){\n    return data[0];\n  }\n  RMQ(int n){\n    N = 1;\n    while(N < n) N *= 2;\n    data = vector<int>(2 * N, INF);\n  }\n  void update(int k, int x){\n    k += N - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = min(data[2 * k + 1], data[2 * k + 2]);\n    }\n  }\n  int query(int a, int b, int MIN){\n    return query(a, b, 0, 0, N, MIN);\n  }\n  int query(int a, int b, int k, int l, int r, int MIN){\n    if(b <= l || r <= a) return INF;\n    else if(a <= l && r <= b){\n      return data[k];\n    }else if(MIN <= data[k]){\n      return MIN;\n    }else{\n      return min(query(a, b, 2 * k + 1, l, (l + r) / 2, MIN), query(a, b, 2 * k + 2, (l + r) / 2, r, MIN));\n    }\n  }\n};\n\nint main(){\n  int H, W, Q;\n  while(cin>>H>>W>>Q && H){\n    if(H < W){\n      //HlogW * Q = 10^7log10^3\n      vector<RMQ> rmq(H, RMQ(W));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[y].update(x, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int y = y1; y <= y2; y++){\n          res = min(res, rmq[y].query(x1, x2 + 1, res));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }else{\n      //WlogH * Q\n      vector<RMQ> rmq(W, RMQ(H));\n      REP(y, H){\n        REP(x, W){\n          int t; scanf(\"%d\", &t);\n          rmq[x].update(y, t);\n        }\n      }\n      REP(i, Q){\n        int y1, x1, y2, x2;\n        scanf(\"%d %d %d %d\", &y1, &x1, &y2, &x2);\n        int res = INF;\n        for(int x = x1; x <= x2; x++){\n          res = min(res, rmq[x].query(y1, y2 + 1, res));\n        }\n        printf(\"%d\\n\", res);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        //dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\nint r,cc,q,t;\n\nint main(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        int a,b,c,d;\n        init(r,cc);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n??\nusing namespace std;\n??\n#define INF ((1LL<<31)-1)\n#define D 10\n??\nstruct SegTree {\n????????int segSize, realSegSize, nodeSize;\n\tint sz;\n\tint *seg;\n????????void init(int n) {\n????????????????realSegSize = n;\n??\n????????????????nodeSize = 0;\n????????????????for (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n??\n\t\tsz = nodeSize+n;\n\t\tseg = new int[sz];\n\t\tfor(int i = 0 ; i < sz ; i++) seg[i] = INF;\n????????}\n??\n????????int get(int n) {\n????????????????if (n < sz) return seg[n];\n????????????????else return INF;\n????????}\n????????void set(int n, int v) {\n????????????????if (n < sz) seg[n] = v;\n????????}\n??\n????????void update(int pos, int val) {\n????????????????int n = nodeSize + pos;\n????????????????set(n, val);\n????????????????while (n) {\n????????????????????????n = (n-1)/D;\n??\n????????????????????????int r = INF;\n????????????????????????for (int i = 0; i < D; ++i) {\n????????????????????????????????r = min(r, seg[n*D+i+1]);\n????????????????????????}\n????????????????????????set(n, r);\n????????????????}\n????????}\n????????int get(int n, int l, int r, int L, int R) {\n//?????????? cout << n << \" \" << l << \" \" << r << endl;\n????????????????if (L <= l && r <= R) return get(n);\n????????????????else if (R <= l || r <= L) return INF;\n????????????????else {\n????????????????????????int ret = INF;\n????????????????????????int prev = l;\n????????????????????????for (int i = 0; i < D; ++i) {\n????????????????????????????????int next = i == D-1 ? r : prev + (r-l)/D;\n????????????????????????????????ret = min(ret, get(n*D+i+1, prev, next, L, R));\n????????????????????????????????prev = next;\n????????????????????????}\n????????????????????????return ret;\n????????????????}\n????????}\n????????int get(int L, int R) {\n????????????????return get(0, 0, segSize, L, R);\n????????}\n??\n????????~SegTree() {\n\t\tdelete seg;\n????????}\n};\n??\nstruct Query {\n????????int y1, x1, y2, x2;\n};\n??\nint main() {\n????????int H, W, Q;\n????????while ( cin >> H >> W >> Q, H || W || Q ) {\n????????????????vector< vector<int> > m(H, vector<int>(W, 0));\n??\n????????????????for (int y = 0; y < H; ++y) {\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????cin >> m[y][x];\n????????????????????????}\n????????????????}\n??\n????????????????bool isSegRow = H < W;\n????????????????vector<SegTree*> seg;\n??\n????????????????if (isSegRow) {\n????????????????????????seg.resize(H);\n????????????????????????for (int y = 0; y < H; ++y) {\n????????????????????????????????seg[y] = new SegTree();\n\t\t\t\tseg[y]->init(W);\n????????????????????????}\n????????????????}\n????????????????else {\n????????????????????????seg.resize(W);\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????seg[x] = new SegTree();\n\t\t\t\tseg[x]->init(H);\n????????????????????????}\n????????????????}\n??\n????????????????for (int y = 0; y < H; ++y) {\n????????????????????????for (int x = 0; x < W; ++x) {\n????????????????????????????????if (isSegRow) seg[y]->update(x, m[y][x]);\n????????????????????????????????else seg[x]->update(y, m[y][x]);\n????????????????????????}\n????????????????}\n??\n????????????????for (int t = 0; t < Q; ++t) {\n????????????????????????int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n??\n????????????????????????int ans = INF;\n????????????????????????if (isSegRow) {\n????????????????????????????????for (int y = y1; y <= y2; ++y) {\n????????????????????????????????????????ans = min(ans, seg[y]->get(x1, x2+1));\n????????????????????????????????}\n????????????????????????}\n????????????????????????else {\n????????????????????????????????for (int x = x1; x <= x2; ++x) {\n????????????????????????????????????????ans = min(ans, seg[x]->get(y1, y2+1));\n????????????????????????????????}\n????????????????????????}\n????????????????????????cout << ans << endl;\n????????????????}\n\t\tfor(int i = 0 ; i < seg.size() ; i++) delete seg[i];\n\t\t\t\n????????}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// library\n#include<vector>\n#include<climitts>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(int x, int y);\n  void update(int x, int y, int value);\n  int find(int x1, int y1, int x2, int y2) const;\n  void print();\nprivate:\n  void update(int index, int a1, int b1, int a2, int b2, int x, int y, int value);\n  int find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const;\n  int parent(int index) const;\n  int upper_left(int index) const;\n  int upper_right(int index) const;\n  int lower_left(int index) const;\n  int lower_right(int index) const;\n  std::vector<int> node_;\n  int height_;\n  int width_;\n  int size_;\n};\n// constructor\nSegmentTree::SegmentTree(int x, int y) : width_(x), height_(y) {\n  size_ = 1;\n  for(int i = 1; i < std::max(x, y); i <<= 1) size_ <<= 2;\n  node_.assign(size_, INF);\n}\n// set value on (x, y)\nvoid SegmentTree::update(int x, int y, int value) {\n  update(0, 0, 0, width_ - 1, height_ - 1, x, y, value);\n}\nvoid SegmentTree::update(int index, int a1, int b1, int a2, int b2, int x, int y, int value) {\n  if(size_ <= index) return;\n  if(x < a1 || a2 < x) return;\n  if(y < b1 || b2 < y) return;\n  if(a1 == x && x == a2 && b1 == y && y == b2) {\n    node_[index] = value;\n    while(index) {\n      node_[parent(index)] = std::min(node_[parent(index)], node_[index]);\n      index = parent(index);\n    }\n  } else {\n    int a = (a1 + a2) >> 1;\n    int b = (b1 + b2) >> 1;\n    update(upper_left(index), a1, b1, a, b, x, y, value);\n    update(upper_right(index), a + 1, b1, a2, b, x, y, value);\n    update(lower_left(index), a1, b + 1, a, b2, x, y, value);\n    update(lower_right(index), a + 1, b + 1, a2, b2, x, y, value);\n  }\n}\n// find the minimum value in (x1, y1)-(x2, y2)\nint SegmentTree::find(int x1, int y1, int x2, int y2) const {\n  return find(0, 0, 0, width_ - 1, height_ - 1, x1, y1, x2, y2);\n}\nint SegmentTree::find(int index, int a1, int b1, int a2, int b2, int x1, int y1, int x2, int y2) const {\n//   for(int i=0;i<(index-1)>>2;++i)cout<<\" \";\n//   cout<<\"*\"<<index<<\"* \"<<a1<<\" \"<<b1<<\" \"<<a2<<\" \"<<b2<<endl;\n  if(size_ <= index) return INF;\n  if(x2 < a1 || a2 < x1) return INF;\n  if(y2 < b1 || b2 < y1) return INF;\n  if(x1 <= a1 && a2 <= x2 && y1 <= b1 && b2 <= y2) return node_[index];\n  int a = (a1 + a2) >> 1;\n  int b = (b1 + b2) >> 1;\n  int ul = find(upper_left(index), a1, b1, a, b, x1, y1, x2, y2);\n  int ur = find(upper_right(index), a + 1, b1, a2, b, x1, y1, x2, y2);\n  int ll = find(lower_left(index), a1, b + 1, a, b2, x1, y1, x2, y2);\n  int lr = find(lower_right(index), a + 1, b + 1, a2, b2, x1, y1, x2, y2);\n  return std::min({ul, ur, ll, lr});\n}\n// debug\nvoid SegmentTree::print() {\n  for(auto i: node_) cout<<\" \"<<i;cout<<endl;\n}\n// position\nint SegmentTree::parent(int index) const {return (index - 1) >> 2;}\nint SegmentTree::upper_left(int index) const {return (index << 2) + 1;}\nint SegmentTree::upper_right(int index) const {return (index << 2) + 2;}\nint SegmentTree::lower_left(int index) const {return (index << 2) + 3;}\nint SegmentTree::lower_right(int index) const {return (index << 2) + 4;}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    SegmentTree tree(c, r);\n    for(int y = 0; y < r; ++y) for(int x = 0; x < c; ++x) {\n      int grid;\n      cin >> grid;\n      tree.update(x, y, grid);\n    }\n//     tree.print();\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.find(c1, r1, c2, r2) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4000000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\n//const ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)h*=2;\n    while(w<w_)w*=2;\n    //if(h>w)w=h;\n    //if(w>h)h=w;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*h+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {\n\t            for (int k = y1; k <= y2; k++){\n    \t        \tans = min(ans, query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n        \t    }\n            \tprintf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 10000000000\n#define N 1000000\nint r,c,q;\nint input;\nvector<int> zu[1000];\nint aaa,bbb,aa,bb;\nint ans;\nint n;\nint ima;\nint dat[1000][4*N];\nvoid init(int n_)\n{\n\tn=1;\n\twhile(n<n_)n*=2;\n\trep(i,2*n-1)rep(j,1000)dat[j][i]=INF;\n}\nvoid update(int k,int a)\n{\n\tk+=n-1;\n\tdat[ima][k]=a;\n\twhile(k>0)\n\t{\n\t\tk=(k-1)/2;\n\t\tdat[ima][k]=min(dat[ima][k*2+1],dat[ima][k*2+2]);\n\t}\n}\nint query(int a,int b,int k,int l,int r)\n{\n\tif(r<=a||b<=l)return INF;\n\tif(a<=l&&r<=b)return dat[ima][k];\n\telse\n\t{\n\t\tint v1=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint v2=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn min(v1,v2);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,1000)zu[i].clear();\n\t\tcin>>r>>c>>q;\n\t\tif(r==0)break;\n\t\tif(r<=c)\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[i].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trep(i,r)\n\t\t\t{\n\t\t\t\trep(j,c)\n\t\t\t\t{\n\t\t\t\t\tcin>>input;\n\t\t\t\t\tzu[j].push_back(input);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(r,c);\n\t\t}\n\t\t/*rep(i,r)\n\t\t{\n\t\t\trep(j,c)cout<<zu[i][j]<<\" \";\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tinit(c);\n\t\t//cout<<\"n:\"<<n<<endl;\n\t\trep(i,r)\n\t\t{\n\t\t\tima=i;\n\t\t\trep(j,c)\n\t\t\t{\n\t\t\t\tupdate(j,zu[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(kkk,q)\n\t\t{\n\t\t\tcin>>aaa>>bbb>>aa>>bb;\n\t\t\tans=INF;\n\t\t\trep2(i,aaa,aa+1)\n\t\t\t{\n\t\t\t\tima=i;\n\t\t\t\tcout<<query(bbb,bb+1,0,0,n)<<endl;\n\t\t\t\tans=min(ans,query(bbb,bb+1,0,0,n));\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=30;\nint H,W,Q;\nvvi fld,bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=vvi(H,vi(W));\n    bucket=vvi(H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        while(y1<y2&&y1%B!=0){\n\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *       Author:  8mao\n * Created Time:  2014/3/16 15:59:04\n *    File Name:  1559.cpp\n */\n# include<map>\n# include<set>\n# include<cmath>\n# include<queue>\n# include<stack>\n# include<vector>\n# include<string>\n# include<cstdio>\n# include<cstring>\n# include<iostream>\n# include<algorithm>\n# include<functional>\nusing namespace std;\n\ntypedef pair<int,int> PII;\n# define INF 1<<30\n# define LL long long\n# define MOD 1000000007\n# define VI vector<int>\n# define VLL vector<LL>\n# define VS vector<string>\n# define PII pair<int,int>\n\n# define F first\n# define S second\n# define mp make_pair\n# define pb push_back\n# define lb lower_bound\n# define up upper_bound\n# define lowbit(x)(x&-x)\n# define lson l,m,rt<<1\n# define rson m+1,r,rt<<1|1\n# define clr(x) (x).clear()\n# define sz(x) ((int)(x).size())\n# define all(x) (x).begin(),(x).end()\n# define mem(x,y) memset(x,y,sizeof(x))\n# define forall(it,c) for(typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\n# define N 1000005\nint Log2[N];\nint a[N], st[N][21];\n\nvoid initRMQ(int n)\n{\n    int i, j;\n    for (i = 0; i < n; i++)\n        st[i][0] = a[i];\n    for (j = 1; (1 << j) <= n; j++)\n        for (i = 0; i + (1 << j) - 1 < n; i++)\n            st[i][j] = min (st[i][j - 1], st[i + (1 << j - 1)][j - 1]);\n}\n\nint calc(int l, int r)\n{\n    int d = Log2[r - l + 1];\n    return min (st[l][d], st[r - (1 << d) + 1][d]);\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int i, j, n, m, q, x1, y1, x2, y2, l, r;\n    LL ans;\n    Log2[0] = -1;\n    for (i = 1; i <= 1000000; i++)\n        Log2[i]= Log2[i - 1] + !(i & (i - 1));\n    while (scanf (\"%d %d %d\", &n, &m, &q) != EOF && (n + m + q))\n    {\n        for (i = 0; i < n; i++)\n            for (j = 0; j < m; j++)\n                scanf (\"%d\", &a[i * m + j]);\n        initRMQ(n * m);\n        for (i = 1; i <= q; i++)\n        {\n            ans = 1LL << 60;\n            scanf (\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            for (j = x1; j <= x2; j++)\n            {\n                l = j * m + y1, r= j * m + y2;\n                //printf (\"%d %d\\n\", l, r);\n                ans = min (ans, (LL)calc(l, r));\n            }\n            printf (\"%lld\\n\", ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef stderr_path\n    #define LOCAL\n    #define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n#include <chrono>\n\n#define debug_stream std::cerr\n#define iostream_untie true\n#define __precision__ 10\n\n#define rep(i, n) for(int i = 0; i < int(n); ++i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define __odd(n) ((n) & 1)\n#define __even(n) (__odd(n) ^ 1)\n#define __popcount(n) __builtin_popcountll(n)\n\nusing i64 = int_fast64_t;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> constexpr T inf = std::numeric_limits<T>::max() / (T)2 - (T)1123456;\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n        std::cerr << \" ms -----\\n\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n#ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n            else fclose(stderr);\n#endif\n#ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n#endif\n#ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n#endif\n#ifdef LOCAL\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n#endif\n        }\n    } __setupper;\n}\n\nstruct myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n    myclock_t() : is_built(false) {}\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built clock!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func) {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            int64_t diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" <<  last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built clock!)\\n\";\n        }\n    }\n};\n#ifdef LOCAL\n    myclock_t myclock;\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock() 42\n    #define set_clock() 42\n    #define get_clock() 42\n#endif\n\nnamespace std\n{\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) { sort(__first, __last, greater<>()); }\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T,U>> { size_t operator()(pair<T,U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class ...T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    template <class T, class U> istream &operator>> (std::istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<< (std::ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\n    template <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; } return s; }\n    template <class T> ostream &operator<< (ostream &s, const vector<T> &v) { for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; } return s; }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t,index - 1>::apply(s,t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0>\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            return s << get<0>(t);\n        }\n    };\n    template <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t)\n    {\n        return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n    }\n    template <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n}\n\n\n#ifdef LOCAL\n    #define dump(...) debug_stream << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...) 42\n#endif\ntemplate <class T> void dump_func(const T &x) { debug_stream << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(const T &x, Rest ... rest) { debug_stream << x << \", \"; dump_func(rest...); }\ntemplate <class T> void write(const T &x) { std::cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(const T &x, Rest ... rest) { std::cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(const T &x, Rest ... rest) { std::cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\n\ntemplate <class T> bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\ntemplate <class T> bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return std::min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return std::max(x,y); }\ntemplate <class int_t, class F>\nint_t bin(int_t ok, int_t ng, const F &f)\n{\n    while (std::abs(ok - ng) > 1)\n    {\n        int_t mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\ntemplate <class A, size_t N> void init(A (&array)[N]) { memset(array, 0, sizeof(array)); }\nvoid for_subset(int_fast64_t s, const std::function<void(int_fast64_t)> &fn) { int_fast64_t t = s; do { fn(t); } while((--t &= s) != s); }\n\nnamespace math\n{\n    template <class int_t>\n    constexpr int_t gcd(int_t x, int_t y)\n    {\n        x = x > 0 ? x : -x, y = y > 0 ? y : -y;\n        while(y) y ^= x ^= y ^= x %= y;\n        return x;\n    }\n    template <class int_t>\n    constexpr int_t lcm(int_t x, int_t y)\n    {\n        return x ? x / gcd(x, y) * y : 0;\n    }\n    template <class int_t>\n    constexpr std::tuple<int_t, int_t, int_t> ext_gcd(int_t a, int_t b)\n    {\n        int_t sgn_a = a >= 0 ? 1 : (a = -a, 0), sgn_b = b >= 0 ? 1 : (b = -b, 0);\n        int_t p = 1, q = 0, r = 0, s = 1;\n        while(b)\n        {\n            int_t t = a / b;\n            r ^= p ^= r ^= p -= t * r;\n            s ^= q ^= s ^= q -= t * s;\n            b ^= a ^= b ^= a %= b;\n        }\n        return std::tuple<int_t, int_t, int_t>(a, sgn_a ? p : -p, sgn_b ? q : -q);\n    }\n    template <class int_t>\n    constexpr std::pair<int_t, int_t> mod_comp(int_t k, int_t m, int_t l, int_t n)\n    {\n        assert(m > 0 and n > 0);\n        int_t g, x, y; std::tie(g, x, y) = ext_gcd(m, n);\n        k += ((k %= m) < 0) * m, l += ((l %= n) < 0) * n;\n        int_t s = k / g, t = l / g, r = k % g;\n        if(r != l % g) return std::pair<int_t, int_t>(-1, -1);\n        int_t lcm = m / g * n;\n        return std::pair<int_t, int_t>((m * x % lcm * t % lcm + n * y % lcm * s % lcm + r + lcm * 2) % lcm, lcm);\n    }\n}\n\n/* The main code follows. */\n\nsigned main()\n{\n    void solve();\n    void input();\n    void init();\n\n    int t = 1e9;\n\n    // cin >> t;\n\n    while(t--)\n    {\n        init();\n        input();\n        solve();\n    }\n}\n\n\nusing namespace std;\nusing namespace math;\n\nint h,w,qry;\nstd::vector<std::vector<int>> g;\nint p,q;\n\nstruct dat\n{\n    std::vector<int> r,c;\n    int _all;\n    dat(){}\n    dat(vector<int> _r, vector<int> _c, int __all)\n        : r(_r), c(_c), _all(__all)\n    {}\n};\n\nstd::vector<vector<dat>> bct;\nconst int inff=numeric_limits<int>::max();\n\nint get(int x,int y)\n{\n    if(x>=h or y>=w) return inff;\n    return g[x][y];\n}\n\nvoid init()\n{\n    g.clear();\n    bct.clear();\n}\n\nvoid input()\n{\n    std::cin >> h >> w >> qry;\n    if(not h and not w and not qry)\n    {\n        exit(0);\n    }\n    g.resize(h);\n    for(int i=0; i<h; ++i)\n    {\n        g[i].resize(w);\n        std::cin >> g[i];\n    }\n}\n\n// [a,c) * [b,d)\nint calc(int a,int c,int b,int d)\n{\n    int aa=a/p,bb=b/q,cc=c/p,dd=d/q;\n    int res=inff;\n\n    for(int i=aa+1; i<cc; ++i)\n    {\n        for(int j=bb+1; j<dd; ++j)\n        {\n            chmin(res,bct[i][j]._all);\n        }\n    }\n\n    // left\n    {\n        for(int i=aa+1; i<cc; ++i)\n        {\n            for(int j=b-bb*q; j<q and j+bb*q<d; ++j)\n            {\n                chmin(res,bct[i][bb].c[j]);\n            }\n        }\n    }\n\n    // right\n    {\n        for(int i=aa+1; i<cc; ++i)\n        {\n            for(int j=max(0,b-dd*q); j+dd*q<d; ++j)\n            {\n                chmin(res,bct[i][dd].c[j]);\n            }\n        }\n    }\n\n    // up\n    {\n        for(int i=bb+1; i<dd; ++i)\n        {\n            for(int j=a-aa*p; j<p and j+aa*p<c; ++j)\n            {\n                chmin(res,bct[aa][i].r[j]);\n            }\n        }\n    }\n\n    // down\n    {\n        for(int i=bb+1; i<dd; ++i)\n        {\n            for(int j=max(0,a-cc*p); j+cc*p<c; ++j)\n            {\n                chmin(res,bct[cc][i].r[j]);\n            }\n        }\n    }\n\n    // left-upper corner\n    {\n        for(int i=a; i<(aa+1)*p and i<c; ++i)\n        {\n            for(int j=b; j<(bb+1)*q and j<d; ++j)\n            {\n                chmin(res,get(i,j));\n            }\n        }\n    }\n\n    // left-lower corner\n    {\n        for(int i=max(a,cc*p); i<c; ++i)\n        {\n            for(int j=b; j<(bb+1)*q and j<d; ++j)\n            {\n                chmin(res,get(i,j));\n            }\n        }\n    }\n\n    // right-upper corner\n    {\n        for(int i=a; i<(aa+1)*p and i<c; ++i)\n        {\n            for(int j=max(dd*q,b); j<d; ++j)\n            {\n                chmin(res,get(i,j));\n            }\n        }\n    }\n\n    // right-lower corner\n    {\n        for(int i=max(cc*p,a); i<c; ++i)\n        {\n            for(int j=max(dd*q,b); j<d; ++j)\n            {\n                chmin(res,get(i,j));\n            }\n        }\n    }\n\n\n    return res;\n}\n\nvoid solve()\n{\n    p=round(sqrt(h));\n    q=round(sqrt(w));\n\n    // backet preparation\n    for(int i=0,ii=0; i<h; i+=p,ii++)\n    {\n        bct.emplace_back(vector<dat>((w-1+q)/q));\n        for(int j=0,jj=0; j<w; jj++,j+=q)\n        {\n            int _all=inff;\n            vector<int> r(p,inff),c(q,inff);\n            for(int x=0; x<p; ++x)\n            {\n                for(int y=0; y<q; ++y)\n                {\n                    chmin(r[x],get(i+x,j+y));\n                }\n                chmin(_all,r[x]);\n            }\n            for(int y=0; y<q; ++y)\n            {\n                for(int x=0; x<p; ++x)\n                {\n                    chmin(c[y],get(i+x,j+y));\n                }\n            }\n            bct[ii][jj]=dat(r,c,_all);\n        }\n    }\n\n    for(int a,b,c,d; qry--; )\n    {\n        std::cin >> a >> b >> c >> d;\n        std::cout << calc(a,c+1,b,d+1) << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\nconst int MAX_N = 1 << 20;\nconst unsigned int INF = 4294967295U;\nunsigned int n;\n\nvoid init(unsigned int* dat, int n_)\n{\n  n = 1;\n  while (n < n_)\n    n*= 2;\n  for (int i = 0; i < 2*n-1; ++i)\n    dat[i] =INF;\n}\n\nvoid update(unsigned int* dat, int k, int a)\n{\n  k += n-1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k-1)/2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\nunsigned int query(unsigned int* dat, int a, int b, int k, int l, int r)\n{\n  if (r <= a || b <= l)\n    return INF;\n\n  if (a <= l && r <= b) {\n    return dat[k];\n  } else {\n    unsigned int vl = query(dat, a, b, k*2+1, l, (l+r)/2);\n    unsigned int vr = query(dat, a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main()\n{\n  static unsigned int dat_r[2*MAX_N-1], dat_c[2*MAX_N-1];\n\n  int r, c, q, g, r1, c1, r2, c2;\n  unsigned int ans = INF;\n  while (scanf(\"%d %d %d\", &r, &c, &q) != EOF) {\n    const int rc = r*c;\n    init(dat_r, rc);\n    init(dat_c, rc);\n\n    for (int i = 0; i < rc; ++i) {\n      scanf(\"%d\", &g);\n      update(dat_r, i, g);\n      update(dat_c, i/c+(i%c)*r, g);\n    }\n\n    for (int i = 0; i < q; ++i) {\n      scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n      ans = INF;\n\n      if (r2-r1 <= c2-c1) {\n\tfor (int j = r1; j <= r2; ++j)\n\t  ans = min(ans, query(dat_r, j*c+c1, j*c+c2+1, 0, 0, n));\n      } else {\n\tfor (int j = c1; j <= c2; ++j)\n\t  ans = min(ans, query(dat_c, j*r+r1, j*r+r2+1, 0, 0, n));\n      }\n      printf(\"%d\\n\", ans);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX = (1 << 24);\n\nclass RMQ2D {\n  public:\n    int H, W;\n    int dat[MAX];    \n\n    int c(int i, int j)\n    {\n        return i * (2 * W - 1) + j;\n    }\n    \n    void init(int h, int w, vector<vector<int>>& grid)\n    {        \n        H = 1;\n        while (H < h) H *= 2;\n        W = 1;\n        while (W < w) W *= 2;\n        \n        for (int i = 0; i < 2 * H - 1; i++) {        \n            for (int j = 0; j < 2 * W - 1; j++) {\n                dat[c(i, j)] = INT_MAX;\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dat[c(i + H - 1, j + W - 1)] = grid[i][j];\n            }\n        }\n        \n        for (int i = 2 * H - 2; i >= 0; i--) {\n            for (int j = W - 2; j >= 0; j--) {\n                dat[c(i, j)] = min(dat[c(i, j * 2 + 1)],\n                                   dat[c(i, j * 2 + 2)]);\n            }\n        }\n\n        for (int i = 2 * W - 2; i >= 0; i--) {\n            for (int j = H - 2; j >= 0; j--) {\n                dat[c(j, i)] = min(dat[c(j * 2 + 1, i)],\n                                   dat[c(j * 2 + 2, i)]);\n            }\n        }\n    }\n\n    int query_h(int h1, int w1, int h2, int w2, int k, int l, int r)\n    {\n        if (r <= h1 || h2 <= l) return INT_MAX;\n        if (h1 <= l && r <= h2) return query_w(w1, w2, k, 0, 0, W);\n        int vl = query_h(h1, w1, h2, w2, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_h(h1, w1, h2, w2, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query_w(int w1, int w2, int j, int k, int l, int r)\n    {\n        if (r <= w1 || w2 <= l) return INT_MAX;\n        if (w1 <= l && r <= w2) return dat[c(j, k)];\n        int vl = query_w(w1, w2, j, k * 2 + 1, l, (l + r) / 2);\n        int vr = query_w(w1, w2, j, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int query(int h1, int w1, int h2, int w2)\n    {\n        return query_h(h1, w1, h2 + 1, w2 + 1, 0, 0, H);\n    }\n};\n\nRMQ2D r;\n\nint main()\n{\n    int H, W, Q;\n    while (std::cin >> H >> W >> Q, H) {\n        vector<vector<int>> grid(H, vector<int>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        r.init(H, W, grid);\n        for (int i = 0; i < Q; i++) {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            cout << r.query(y1, x1, y2, x2) << endl;\n        }\n    }       \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct SegTree{\n\tint size;\n\tvi data;\n\tSegTree(int s):size(Need(s)),data(size*2,INFTY){}\n\tvoid Update(int i,int x){\n\t\tfor(i+=size;i;i>>=1)\n\t\t\tdata[i]=min(data[i],x);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return INFTY;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=INFTY,m=(l+r)/2;\n\t\tif(a<m) res=min(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=min(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n\tint Need(int size){\n\t\tsize--;\n\t\trep(i,5) size|=size>>(1<<i);\n\t\treturn size+1;\n\t}\n};\n\nint main()\n{\n\tfor(int r,c,q;scanf(\"%d%d%d\",&r,&c,&q),r|c|q;){\n\t\tvvi grid(r,vi(c));\n\t\trep(i,r) rep(j,c) scanf(\"%d\",&grid[i][j]);\n\t\t\n\t\tvector<SegTree> sts(r,SegTree(c));\n\t\trep(i,r) rep(j,c) sts[i].Update(j,grid[i][j]);\n\t\t\n\t\twhile(q--){\n\t\t\tint r1,c1,r2,c2; scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tint res=INFTY;\n\t\t\trepi(i,r1,r2+1) res=min(res,sts[i].Query(c1,c2+1));\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\treturn (min(_query(k * 2 + 1, l, (l + r) / 2), _query(k * 2 + 2, (l + r) / 2, r)));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\treturn (min(query(k * 2 + 1, l, (l + r) / 2), query(k * 2 + 2, (l + r) / 2, r)));\n}\n\nint main()\n{\n\tint w, h, q, a;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tvector< vector<int> > local(hbin * 2 - 1, vector<int>(wbin * 2 - 1));\n\t\t\n\t\tseg = local;\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const unsigned INF = 0xFFFFFFFF;\nstatic const ll       MOD = 1000000007LL;\nstatic const double   EPS = 1E-10;\n\nconst int SZ = 1 << 22;\nint r, c, q;\nint _r, _c;\nint g;\nvector<unsigned int>* seg;\nint sx, sy, tx, ty;\n\nvoid init()\n{\n  _r = 1;\n  _c = 1;\n  while(_r < r) _r *= 2;\n  while(_c < c) _c *= 2;\n  delete[] seg;\n  seg = new vector<unsigned int>[2 * _r - 1];\n  rep(i, 2 * _r - 1) seg[i].resize(2 * _c - 1);\n  rep(i, 2 * _r - 1) rep(j, 2 * _c - 1) seg[i][j] = INF;\n}\n\nvoid update(int a, int b, unsigned int x)\n{\n  a += _r - 1;\n  b += _c - 1;\n  seg[a][b] = x;\n  while(a >= 0){\n    int tmp = b;\n    while(b > 0){\n      b = (b - 1) / 2;\n      seg[a][b] = min(seg[a][2 * b + 1], seg[a][2 * b + 2]);\n    }\n    b = tmp;\n    if(a == 0) break;\n    a = (a - 1) / 2;\n    seg[a][b] = min(seg[2 * a + 1][b], seg[2 * a + 2][b]);\n  }\n}\n\nunsigned int _query(int sy, int ty, int kk, int k = 0, int l = 0, int r = _c)\n{\n  if(r <= sy || ty <= l) return INF;\n  if(sy <= l && r <= ty) return seg[kk][k];\n  return min(_query(sy, ty, kk, 2 * k + 1, l, (l + r) / 2),\n             _query(sy, ty, kk, 2 * k + 2, (l + r) / 2, r));\n}\n\nunsigned int query(int sx, int sy, int tx, int ty, int k = 0, int l = 0, int r = _r)\n{\n  if(r <= sx || tx <= l) return INF;\n  if(sx <= l && r <= tx) return _query(sy, ty, k);\n  return min(query(sx, sy, tx, ty, 2 * k + 1, l, (l + r) / 2),\n             query(sx, sy, tx, ty, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> r >> c >> q, r){\n    init();\n    rep(i, r) rep(j, c){\n      cin >> g;\n      update(i, j, g);\n    }\n    rep(i, q){\n      cin >> sx >> sy >> tx >> ty;\n      cout << query(sx, sy, tx + 1, ty + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<algorithm>\n// constant\nconst int INF = INT_MAX;\n// type\nstruct Node {\n  int value;\n  Node* child[4];\n  Node(int v) : value(v) {for(int i = 0; i < 4; ++i) child[i] = nullptr;}\n};\n// class\nclass SegmentTree {\npublic:\n  SegmentTree(const std::vector<std::vector<int>>& grid);\n  int minimum(int x1, int y1, int x2, int y2) const;\n  void free();\nprivate:\n  Node* build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y);\n  int minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const;\n  void free(Node* node);\n  int size_x_;\n  int size_y_;\n  Node* root_;\n};\n// constructor\nSegmentTree::SegmentTree(const std::vector<std::vector<int>>& grid) {\n  size_y_ = grid.size();\n  size_x_ = grid.front().size();\n  root_ = build(grid, 0, 0, size_x_, size_y_);\n}\n// Return a node that has minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nNode* SegmentTree::build(const std::vector<std::vector<int>>& grid, int low_x, int low_y, int high_x, int high_y) {\n  Node* result = new Node(INF);\n  if(low_x == high_x - 1 && low_y == high_y - 1) {\n    result->value = grid[low_y][low_x];\n    return result;\n  }\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result->child[i + j * 2] = build(grid, x[i], y[j], x[i + 1], y[j + 1]);\n    result->value = std::min(result->value, result->child[i + j * 2]->value);\n  }\n  return result;\n}\n// Return the minimum value in (low_x, low_y)-(high_x - 1, high_y - 1).\nint SegmentTree::minimum(int x1, int y1, int x2, int y2) const {\n  return minimum(root_, 0, 0, size_x_, size_y_, x1, y1, x2, y2);\n}\nint SegmentTree::minimum(Node* node, int low_x, int low_y, int high_x, int high_y, int x1, int y1, int x2, int y2) const {\n  if(!node) return INF;\n  if(x1 <= low_x && high_x - 1 <= x2 && y1 <= low_y && high_y - 1 <= y2) return node->value;\n  int result = INF;\n  int x[3] = {low_x, (low_x + high_x) >> 1, high_x};\n  int y[3] = {low_y, (low_y + high_y) >> 1, high_y};\n  for(int i = 0; i < 2; ++i) for(int j = 0; j < 2; ++j) if(x[i] < x[i + 1] && y[j] < y[j + 1]) {\n    result = std::min(result, minimum(node->child[i + j * 2], x[i], y[j], x[i + 1], y[j + 1], x1, y1, x2, y2));\n  }\n  return result;\n}\n// Free.\nvoid SegmentTree::free() {free(root_);}\nvoid SegmentTree::free(Node* node) {\n  if(!node) return;\n  for(int i = 0; i < 4; ++i) free(node->child[i]);\n  std::free(node);\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  int r, c, q;\n  while(cin >> r >> c >> q, r | c | q) {\n    vector<vector<int>> grid(r, vector<int>(c));\n    for(auto& g: grid) for(auto& i: g) cin >> i;\n    SegmentTree tree(grid);\n    for(int i = 0; i < q; ++i) {\n      int r1, c1, r2, c2;\n      cin >> r1 >> c1 >> r2 >> c2;\n      cout << tree.minimum(c1, r1, c2, r2) << endl;\n    }\n    tree.free();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1068\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define repi(i,a,b) for( int i = (a); i != (b); ++i )\n\nconst int INF = 1 << 30;\n\nint r, c, q;\nstd::vector<std::vector<int> > segR;\nint sz;\n\nvoid init( int n )\n{\n\tsz = 1;\n\twhile( sz < c )\n\t\tsz <<= 1;\n\n\trep( i, r )\n\t\tsegR[i].resize( 2*sz-1, INF );\n\n\treturn;\n}\n\nvoid update( std::vector<int> &seg, int k, int x )\n{\n\tk += sz-1;\n\tseg[k] = x;\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tseg[k] = std::min( seg[(k<<1)+1], seg[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nint query( const std::vector<int> &seg, int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn INF;\n\telse if( a <= l && r <= b )\n\t\treturn seg[k];\n\t\n\treturn std::min( query( seg, a, b, (k<<1)+1, l, (l+r)>>1 ), query( seg, a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d%d\", &r, &c, &q ), r|c|q )\n\t{\n\t\tsegR.resize( r );\n\t\tinit( c );\n\n\t\trep( i, r )\n\t\t{\n\t\t\trep( j, c )\n\t\t\t{\n\t\t\t\tint grid;\n\t\t\t\tscanf( \"%d\", &grid );\n\n\t\t\t\tupdate( segR[i], j, grid );\n\t\t\t}\n\t\t}\n\n\t\trep( i, q )\n\t\t{\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf( \"%d%d%d%d\", &r1, &c1, &r2, &c2 );\n\n\t\t\tint ans = INF;\n\t\t\trepi( j, r1, r2+1 )\n\t\t\t\tans = std::min( ans, query( segR[j], c1, c2+1, 0, 0, sz ) );\n\t\t\n\t\t\tprintf( \"%d\\n\", ans );\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000000;\n\nstruct segtree1 {\n\n\tvector<int> dat;\n\tint s;\n\t\n\tvoid init(int size)\n\t{\n\t\ts = 1;\n\t\twhile(s < size) s *= 2;\n\t\t\n\t\tdat.resize(s * 2, inf);\n\t}\n\t\n\tvoid set(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\tint par = pos / 2;\n\t\t\n\t\tdat[pos] = v;\n\t\t\n\t\twhile(par > 0) {\n\t\t\n\t\t\tdat[par] = min(dat[par], dat[pos]);\n\t\t\t\n\t\t\tpos = par;\n\t\t\tpar = pos / 2;\n\t\t}\n\t}\n\t\n\tvoid setmin(int x, int v)\n\t{\n\t\tint pos = s + x;\n\t\tif(dat[pos] > v)\n\t\t\tset(x, v);\n\t}\n\t\n\tint getmin(int a, int b, int l, int r, int idx)\n\t{\n\t\tif(b <= l || r <= a) return inf;\n\t\t\n\t\tif(a <= l && r <= b) {\n\t\t\n\t\t\treturn dat[idx];\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(a, b, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(a, b, m, r, idx * 2 + 1));\n\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int a, int b)\n\t{\n\t\treturn getmin(a, b, 0, s, 1);\n\t}\n};\n\nstruct segtree2 {\n\t\n\tvector<segtree1> dat;\n\tint w, h;\n\t\n\tvoid init(int width, int height)\n\t{\n\t\tw = 1;\n\t\twhile(w < width) w *= 2;\n\t\t\n\t\th = 1;\n\t\twhile(h < height) h *= 2;\n\t\t\n\t\tdat.resize(h * 2);\n\t\tfor(int i = 0; i < h * 2; ++i)\n\t\t\tdat[i].init(w);\n\t}\n\t\n\tvoid set(int x, int y, int v)\n\t{\n\t\tint pos = h + y;\n\t\tint par = pos / 2;\n\t\t\n\t\tdat[pos].set(x, v);\n\t\t\n\t\twhile(par > 0) {\n\t\t\n\t\t\tdat[par].setmin(x, v);\n\t\t\t\n\t\t\tpos = par;\n\t\t\tpar = pos / 2;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by, int l, int r, int idx)\n\t{\n\t\tif(by <= l || r <= ay) return inf;\n\t\t\n\t\tif(ay <= l && r <= by) {\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, dat[idx].getmin(ax, bx));\n\t\t\treturn dat[idx].getmin(ax, bx);\n\t\t\n\t\t} else {\n\t\t\n\t\t\tint m = (l + r) / 2;\n\t\t\tint ret = inf;\n\t\t\t\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, l, m, idx * 2 + 0));\n\t\t\tret = min(ret, getmin(ax, ay, bx, by, m, r, idx * 2 + 1));\n\t\t\n\t\t\t//printf(\"[debug] getmin(%d, %d, %d, %d, %d, %d, %d) = %d\\n\", ax, ay, bx, by, l, r, idx, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tint getmin(int ax, int ay, int bx, int by)\n\t{\n\t\treturn getmin(ax, ay, bx, by, 0, h, 1);\n\t}\n};\n\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint r, c, q;\n\t\tsegtree2 st;\n\t\t\n\t\tscanf(\"%d%d%d\", &r, &c, &q);\n\t\t\n\t\tif(r == 0 && c == 0 && q == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tst.init(r, c);\n\t\t\n\t\tfor(int x = 0; x < r; ++x) {\n\t\t\tfor(int y = 0; y < c; ++y) {\n\t\t\t\n\t\t\t\tint v;\n\t\t\t\t\n\t\t\t\tscanf(\"%d\", &v);\n\t\t\t\t\n\t\t\t\tst.set(x, y, v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\n\t\t\tint r1, c1, r2, c2;\n\t\t\t\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\t\n\t\t\tint ans = st.getmin(r1, c1, r2 + 1, c2 + 1);\n\t\t\t\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint data[1 << 23];\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h, w;\n\tconst T id;\n\tfunc_t merge;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub_h(int li, int lj, int ri, int rj, int si, int ti, int k) {\n\t\tif (ri <= si || ti <= li) return id;\n\t\tif (li <= si && ti <= ri) return sub_w(lj, rj, 0, w, k, 1);\n\t\tconst int mi = (si + ti) / 2;\n\t\treturn merge(sub_h(li, lj, ri, rj, si, mi, k * 2), sub_h(li, lj, ri, rj, mi, ti, k * 2 + 1));\n\t}\n\tT sub_w(int lj, int rj, int sj, int tj, int i, int k) {\n\t\tif (rj <= sj || tj <= lj) return id;\n\t\tif (lj <= sj && tj <= rj) return data[i * w * 2 + k];\n\t\tconst int mj = (sj + tj) / 2;\n\t\treturn merge(sub_w(lj, rj, sj, mj, i, k * 2), sub_w(lj, rj, mj, tj, i, k * 2 + 1));\n\t}\npublic:\n\tSegmentTree2(vector<vector<T>> data_, T id_, func_t merge_) :\n\t\th(size(data_.size())), w(size(data_.front().size())), id(id_), merge(merge_) {\n\t\tfill(data, data + (1 << 23), id);\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tfor (int j = 0; j < (int)data_.front().size(); j++)\n\t\t\t\tdata[(h + i) * w * 2 + w + j] = data_[i][j];\n\t\tfor (int i = h * 2 - 1; i >= h; i--)\n\t\t\tfor (int j = w - 1; j > 0; j--)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * w * 2 + j * 2], data[i * w * 2 + j * 2 + 1]);\n\t\tfor (int i = h - 1; i > 0; i--)\n\t\t\tfor (int j = 1; j < w * 2; j++)\n\t\t\t\tdata[i * w * 2 + j] = merge(data[i * 2 * w * 2 + j], data[(i * 2 + 1) * w * 2 + j]);\n\t}\n\t//void Update(int pi, int pj, T val) { }\n\t//void Add(int pi, int pj, T val) { }\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub_h(li, lj, ri + 1, rj + 1, 0, h, 1);\n\t}\n};\n\nint main()\n{\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tvector<vector<int>> v(r, vector<int>(c));\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t}\n\t\t}\n\t\tSegmentTree2<int> st2(v, INT_MAX, [](int l, int r) { return min(l, r); });\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tcout << st2.Find(r1, c1, r2, c2) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  for(int r,c,q;cin>>r>>c>>q,r|c|q;){\n    vector<vector<int> > v(r,vector<int>(c));\n    for(int i=0;i<r;i++){\n      for(int j=0;j<c;j++){\n\tcin>>v[i][j];\n      }\n    }\n    int rs=sqrt(rs);\n    int cs=sqrt(cs);\n    vector<vector<int> > vs((r+rs-1)/rs,vector<int>((c+cs-1)/cs,(1u<<31)-1));\n    for(int i=0;i*rs<r;i++){\n      for(int j=0;j*cs<c;j++){\n\tfor(int k=0;k<rs;k++){\n\t  for(int l=0;l<cs;l++){\n\t    if(i+k<r&&j+l<c){\n\t      vs[i][j]=min(vs[i][j],v[i*rs+k][j*cs+l]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    while(q--){\n      int t,l,b,rt;\n      cin>>t>>l>>b>>rt;\n      int m=(1u<<31)-1;\n      for(int i=t;i<=b;i++){\n\tfor(int j=l;j<=rt;){\n\t  if((t-1)/rs!=i/rs&&j%cs==0&&j+rs<=rt+1){\n\t    m=min(m,vs[i/rs][j/cs]);\n\t    j+=cs;\n\t  }else{\n\t    m=min(m,v[i][j]);\n\t    j++;\n\t  }\n\t}\n      }\n      cout<<m<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N=4100000;\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst ll INF=100000000000LL;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    fill(dat,dat+2*h*w-1,-1);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        //dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)return -1;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)return dat[k];\n    int vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return min(vl,vr);\n}\n\nint main(){\n    int r,c,q;\n    while(scanf(\"%d %d %d\\n\",&r,&c,&q)&&!(r==0&&c==0&&q==0)){\n        init(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                int t;\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int a,b,c,d;\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            int res=query(b,a,d,c,0,0,0,w-1,h-1);\n            printf(\"%d\\n\",res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nconstexpr int SQRT_N = 50;\nconstexpr int INF = INT_MAX;\nint H, W, Q;\nstruct Row {\n  int N;\n  vector<int> data;\n  Row() {\n    N = 1;\n    while(N < W) N *= 2;\n    data.assign(2*N - 1, INF);\n  }\n  int get(int x) {\n    return data[x + N - 1];\n  }\n  void update(int k, int a) {\n    k += N - 1;\n    data[k] = a;\n    while(k > 0) {\n      k = (k - 1)/2;\n      data[k] = min(data[2*k + 1], data[2*k + 2]);\n    }\n  }\n  int query(int a, int b) {\n    return query2(a, b, 0, 0, N);\n  }\n  int query2(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return INF;\n    if(a <= l && r <= b) return data[k];\n\n    return min(query2(a, b, 2*k + 1, l, (l + r)/2),\n        query2(a, b, 2*k + 2, (l + r)/2, r));\n  }\n  void clear() {\n    data.clear();\n  }\n};\nstruct Grid {\n  int K;\n  vector<Row> data;\n  vector<Row> stat;\n  Grid() {\n    K = (H + SQRT_N - 1) / SQRT_N;\n    data.assign(SQRT_N * K, Row());\n    stat.assign(K, Row());\n  }\n  void update(const int y, const int x, const int value) {\n    data[y].update(x, value);\n    const int k = y / SQRT_N;\n    stat[k].update(x, min(stat[k].get(x), data[y].get(x)));\n  }\n  int query(const int y1, const int x1, const int y2, const int x2) {\n    int ret = INF;\n    for(int k = 0; k < K; ++k) {\n      int l = k * SQRT_N, r = (k + 1) * SQRT_N;\n      if(r <= y1 || y2 <= l) continue;\n      if(y1 <= l && r <= y2) {\n        ret = min(ret, stat[k].query(x1, x2));\n      }\n      else {\n        for(int i = max(y1, l); i < min(y2, r); ++i) {\n          ret = min(ret, data[i].query(x1, x2));\n        }\n      }\n    }\n    return ret;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  while(true) {\n    cin >> H >> W >> Q;\n    if(H == 0 && W == 0 && Q == 0) break;\n    bool doswap = false;\n    if(H > W) {\n      doswap = true;\n      swap(H, W);\n    }\n    Grid g;\n    if(doswap) {\n      REP(y,W) REP(x,H) {\n        int v; cin >> v;\n        g.update(x, y, v);\n      }\n    }\n    else {\n      REP(y,H) REP(x,W) {\n        int v; cin >> v;\n        g.update(y, x, v);\n      }\n    }\n    REP(q,Q) {\n      int y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n      if(doswap) {\n        swap(x1, y1);\n        swap(x2, y2);\n      }\n      cout << g.query(y1, x1, y2+1, x2+1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nconst int N = 1000010;\nconst int inf = 0x7fffffff;\nstruct Tree\n{\n\tint x[2];\n\tint y[2];\n\tint val;\n\tint son[4];\n}tt[N*2];\nint a[N];\nint n,m;\nint loc;\nvoid build(int x0,int x1,int y0,int y1,int idx)\n{\n\ttt[idx].x[0]=x0;\n\ttt[idx].x[1]=x1;\n\ttt[idx].y[0]=y0;\n\ttt[idx].y[1]=y1;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\ttt[idx].son[i]=0;\n\t}\n\tif(x0==x1&&y0==y1)\n\t{\n\t\ttt[idx].val=a[(x0-1)*m+y0];\n\t\treturn ;\n\t}\n\tint mx=(x0+x1)>>1;\n\tint my=(y0+y1)>>1;\n\tif(x0==x1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\tbuild(x0,x0,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,x0,my+1,y1,tt[idx].son[1]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t}\n\telse if(y0==y1)\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[2]=++loc;\n\t\tbuild(x0,mx,y0,y0,tt[idx].son[0]);\n\t\tbuild(mx+1,x1,y0,y0,tt[idx].son[2]);\t\t\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[2]].val);\n\t}\n\telse\n\t{\n\t\ttt[idx].son[0]=++loc;\t\t\n\t\ttt[idx].son[1]=++loc;\n\t\ttt[idx].son[2]=++loc;\t\t\n\t\ttt[idx].son[3]=++loc;\n\t\tbuild(x0,mx,y0,my,tt[idx].son[0]);\n\t\tbuild(x0,mx,my+1,y1,tt[idx].son[1]);\n\t\tbuild(mx+1,x1,y0,my,tt[idx].son[2]);\n\t\tbuild(mx+1,x1,my+1,y1,tt[idx].son[3]);\n\t\ttt[idx].val=min(tt[tt[idx].son[0]].val,tt[tt[idx].son[1]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[2]].val);\n\t\ttt[idx].val=min(tt[idx].val,tt[tt[idx].son[3]].val);\n\t}\n}\nint query(int x0,int x1,int y0,int y1,int idx)\n{\n\tif(tt[idx].x[0]>=x0&&tt[idx].x[1]<=x1&&tt[idx].y[0]>=y0&&tt[idx].y[1]<=y1)\n\t{\n\t\treturn tt[idx].val;\n\t}\n\tif(tt[idx].x[0]>x1||tt[idx].x[1]<x0||tt[idx].y[0]>y1||tt[idx].y[1]<y0)\n\t{\n\t\treturn inf;\n\t}\n\tint ans=inf;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(tt[idx].son[i]!=0)\n\t\t{\n\t\t\tans = min(query(x0,x1,y0,y1,tt[idx].son[i]),ans);\n\t\t}\n\t}\n\treturn ans;\n}\nint main(void)\n{\n\tint q,x0,x1,y0,y1;\n\twhile(scanf(\"%d%d%d\",&n,&m,&q)&&(n||m||q))\n\t{\n\t\tfor(int i=1;i<=n*m;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t}\n\t\tloc=1;\n\t\tbuild(1,n,1,m,1);\n\t\tfor(int i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&x0,&y0,&x1,&y1);\n\t\t\tx0++;y0++;x1++;y1++;\n\t\t\tprintf(\"%d\\n\",query(x0,x1,y0,y1,1));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define la (tr[rt].a)\n#define lb (tr[rt].b)\n#define lc (tr[rt].c)\n#define ld (tr[rt].d)\n#define MIN(A,B) ((A)>(B)?(B):(A))\nusing namespace std;\nstruct seg{\n    int x1,y1,x2,y2;\n    int v;\n    int a,b,c,d;\n    int midx(){\n        return (x1+x2)>>1;\n    }\n    int midy(){\n        return (y1+y2)>>1;\n    }\n}tr[20000010];\nint matrix[10000010];\nint tot;\nint r,c,q;\nvoid build(int rt,int x1,int y1,int x2,int y2)\n{\n    //printf(\"%d %d %d %d %d\\n\",rt,x1,y1,x2,y2);\n    tr[rt].x1 = x1;\n    tr[rt].y1 = y1;\n    tr[rt].x2 = x2;\n    tr[rt].y2 = y2;\n    if(x1>=x2&&y1>=y2){\n        tr[rt].v = matrix[x1*c+y1];\n        return;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    if(x1 == x2){\n        tr[rt].a = ++tot;\n        tr[rt].b = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        return;\n    }\n    else if(y1 == y2){\n        tr[rt].a = ++tot;\n        tr[rt].c = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lc,mx+1,y1,x2,my);\n        tr[rt].v = MIN(tr[la].v,tr[lc].v);\n        return;\n    }\n    else{\n        tr[rt].a = ++tot;\n        tr[rt].b = ++tot;\n        tr[rt].c = ++tot;\n        tr[rt].d = ++tot;\n        build(la,x1,y1,mx,my);\n        build(lb,x1,my+1,mx,y2);\n        build(lc,mx+1,y1,x2,my);\n        build(ld,mx+1,my+1,x2,y2);\n        tr[rt].v = MIN(tr[la].v,tr[lb].v);\n        tr[rt].v = MIN(tr[rt].v,tr[lc].v);\n        tr[rt].v = MIN(tr[rt].v,tr[ld].v);\n        return;\n    }\n}\nint query(int rt,int x1,int y1,int x2,int y2)\n{\n    if(x1==tr[rt].x1&&x2==tr[rt].x2&&y2==tr[rt].y2&&y1==tr[rt].y1){\n        return tr[rt].v;\n    }\n    int mx = tr[rt].midx();\n    int my = tr[rt].midy();\n    //1\n    if(x2<=mx&&y2<=my)\n        return query(la,x1,y1,x2,y2);\n    if(y1>my&&x2<=mx)\n        return query(lb,x1,y1,x2,y2);\n    if(x1>mx&&y2<=my)\n        return query(lc,x1,y1,x2,y2);\n    if(mx<x1&&my<y1)\n        return query(ld,x1,y1,x2,y2);\n    //2\n    if(x2<=mx){\n        int a = query(la,x1,y1,x2,my);\n        int b = query(lb,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y2<=my){\n        int a = query(la,x1,y1,mx,y2);\n        int b = query(lc,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    if(x1>mx){\n        int a = query(lc,x1,y1,x2,my);\n        int b = query(ld,x1,my+1,x2,y2);\n        return MIN(a,b);\n    }\n    if(y1>my){\n        int a = query(lb,x1,y1,mx,y2);\n        int b = query(ld,mx+1,y1,x2,y2);\n        return MIN(a,b);\n    }\n    //3\n    int a = query(la,x1,y1,mx,my);\n    int b = query(lb,x1,my+1,mx,y2);\n    int c = query(lc,mx+1,y1,x2,my);\n    int d = query(ld,mx+1,my+1,x2,y2);\n    int e = MIN(a,b);\n    e = MIN(e,c);\n    e = MIN(e,d);\n    return e;\n}\nint main()\n{\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&r,&c,&q),r||c||q){\n        tot = 0;\n        for(int i = 0; i < r; ++i){\n            for(int j = 0; j < c; ++j){\n                scanf(\"%d\",matrix+i*c+j);\n            }\n        }\n        //build(0,0,0,r-1,c-1);\n        for(int i = 0; i < q; ++i){\n            int a,b,c,d;\n            scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n            //printf(\"%d\\n\",query(0,a,b,c,d));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ninline int MIN(int a,int b){\n\treturn a<b?a:b;\n}\nint st[16][101000];\nshort tlog[101000];\nint p[1010000],r,c,q;\nvoid ST(int fg,int s){\n\t//st[0][i]=num[i];\n\tint sz;\n\tif(fg) {\n\t\tsz=c;\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tst[0][j]=p[(s-1)*c+j];\n\t\t}\n\t} else {\n\t\tsz=r;\n\t\tfor(int j=1;j<=r;j++){\n\t\t\tst[0][j]=p[(j-1)*c+s];\n\t\t}\n\t}\n\tif(sz>100000) while(1);\n\tfor(int j=1;j<=tlog[sz];j++){\n\t\tfor(int i=0;j<=tlog[sz+1-i];i++){\n\t\t\tst[j][i]=MIN(st[j-1][i],st[j-1][i+(1<<j>>1)]);\n\t\t}\n\t}\n}\nint RMQ(int l,int r){\n    int tmp=tlog[r-l+1];\n    return MIN(st[tmp][l],st[tmp][r-(1<<tmp)+1]);\n}\nvoid scanf_(int &num){\n\tchar in;\n\tbool neg=false;\n\twhile(((in=getchar())>'9'||in<'0')&&in!='-');\n\tif(in=='-'){\n\t\tneg=true;\n\t\twhile((in=getchar())>'9'||in<'0');\n\t}\n\tnum=in-'0';\n\twhile(in=getchar(),in>='0'&&in<='9')\n\t\tnum*=10,num+=in-'0';\n\tif(neg)\n\tnum=0-num;\n}\nstruct node{\n\tint r1,r2,c1,c2;\n\tnode(){}\n\tnode(int a,int b,int c,int d):r1(a),c1(b),r2(c),c2(d){}\n}f[11000];\nint res[11000];\nint r1,r2,c1,c2;\nint main(){\n\ttlog[0]=-1;\n\tfor(int i=1;i<101000;i++){\n\t\ttlog[i]=tlog[i-1]+((i&(i-1))?0:1);\n\t}\n\twhile(scanf(\"%d%d%d\",&r,&c,&q),(r||c||q)) {\n\t\tfor(int i=1;i<=r;i++) {\n\t\t\tfor(int j=1;j<=c;j++) scanf_(p[(i-1)*c+j]);\n\t\t}\n\t\tfor(int i=0;i<=q;i++) res[i]=2147483647;\n\t\tif(r<=c) {\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tf[i]=node(r1,c1,r2,c2);\n\t\t\t}\n\t\t\tfor(int i=1;i<=r;i++){\n\t\t\t\tST(1,i);\n\t\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\t\tif(f[j].r1<=i&&f[j].r2>=i)\n\t\t\t\t\tres[j]=min(res[j],RMQ(f[j].c1,f[j].c2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++) printf(\"%d\\n\",res[i]);\n\t\t} else {\n\t\t\tfor(int i=0;i<q;i++){\n\t\t\t\tscanf_(r1),scanf_(c1),scanf_(r2),scanf_(c2);\n\t\t\t\tr1++,r2++,c1++,c2++;\n\t\t\t\tf[i]=node(r1,c1,r2,c2);\n\t\t\t}\n\t\t\tfor(int i=1;i<=c;i++){\n\t\t\t\tST(0,i);\n\t\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\t\tif(f[j].c1<=i&&f[j].c2>=i)\n\t\t\t\t\tres[j]=min(res[j],RMQ(f[j].r1,f[j].r2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<q;i++) printf(\"%d\\n\",res[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nint len[1001000];\n\nint min(const int &a,const int &b)\n{\n    if (a<b) return a;else return b;\n}\n\n\nint mi[1001000][20];\n\nstruct RMQ\n{\n    void rmq(int * d, int N)\n    {\n        int M=len[N];\n        for (int i=0;i<N;i++) mi[i][0]=d[i];\n        for (int g=1;g<=M;g++)\n        {\n            int L=N-(1<<g);\n            for (int i=0;i<=L;i++)\n                mi[i][g]=min( mi[i][g-1] , mi[i+(1<<(g-1))][g-1] );\n        }\n    }\n    int query(int &a, int &b)\n    {\n        int g=len[b-a+1];\n        return min(mi[a][g],mi[b-(1<<(g))+1][g]);\n    }\n}aa;\n\nint a[1100000];\nint r1[11000],r2[11000],c1[11000],c2[11000];\nint ans[11000];\nlong long numinf;\nint inf;\nint m,n,q;\nvector <int> c[1100000];\n\n\nint main()\n{\n    for (int L=1;L<=1000000;L++) len[L]=int (log(L*1.0)/log(2.0));\n    numinf=1;\n    for (int k=1;k<=31;k++) numinf*=2LL;\n    numinf=numinf-1;\n    inf=numinf;\n\n   // freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&m,&q);\n    while (n+m+q!=0)\n    {\n        for (int i=0;i<n;i++)\n            c[i].clear();\n        int wh;\n        for (int i=0;i<n;i++)\n        {\n            for (int j=0;j<m;j++)\n            {\n                scanf(\"%d\",&wh);\n                c[i].push_back(wh);\n            }\n        }\n        int rv=0;\n        if (n>m) rv=1;\n        if (n>m) swap(n,m);\n        if (rv==0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                a[i*m+j]=c[i][j];\n        if (rv!=0)\n        for (int i=0;i<n;i++)\n            for (int j=0;j<m;j++)\n                a[i*m+j]=c[j][i];\n\n\n        for (int k=1;k<=q;k++)\n            scanf(\"%d%d%d%d\",&r1[k],&c1[k],&r2[k],&c2[k]);\n        for (int k=1;k<=q;k++) ans[k]=inf;\n        for (int k=1;k<=q;k++)\n        if (rv)\n        {\n               swap(r1[k],c1[k]);\n               swap(r2[k],c2[k]);\n        }\n        int temp;\n        for (int i=0;i<n;i++)\n        {\n            aa.rmq(a+i*m,m);\n            for (int k=1;k<=q;k++)\n                if (r1[k]<=i&&i<=r2[k])\n                {\n                    temp=aa.query(c1[k],c2[k]);\n                    if (temp<ans[k]) ans[k]=temp;\n                }\n        }\n        for (int k=1;k<=q;k++)\n            printf(\"%d\\n\",ans[k]);\n        scanf(\"%d%d%d\",&n,&m,&q);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXN = 1000000 + 10;\n\nint n, m, num1[MAXN], num2[MAXN], st1[MAXN][20], st2[MAXN][20];\n\nint min(int num[], int p1, int p2) {\n    return num[p1] < num[p2] ? p1 : p2;\n}\n\nvoid init(int num[], int st[][20], int n) {\n    REP(i, n)\n        st[i][0] = i;\n    for (int j = 1; (1 << j) <= n; ++j)\n        for (int i = 0; i + (1 << j) - 1 < n; ++i)\n            st[i][j] = min(num, st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n}\n\nint rmq(int num[], int st[][20], int i, int j) {\n    int k = (int)log2(j - i + 1);\n    return num[min(num, st[i][k], st[j - (1 << k) + 1][k])];\n}\n\nint main() {\n    int q;\n    while (scanf(\"%d%d%d\", &n, &m, &q) == 3 && n + m + q) {\n        REP(i, n) {\n            REP(j, m) {\n                int pos1 = i * m + j,\n                    pos2 = j * n + i;\n                //out(pos1);\n                scanf(\"%d\", num1 + pos1);\n                num2[pos2] = num1[pos1];\n            }\n        }\n        if (q < 10) {\n            REP(qq, q) {\n                //out(i);\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                for (int i = l1; i <= r1; ++i) {\n                    for (int j = l2; j <= r2; ++j) {\n                        int pos = i * m + j;\n                        //out(pos);\n                        checkmin(ans, num1[pos]);\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        } else {\n            init(num1, st1, n * m);\n            init(num2, st2, n * m);\n            REP(qq, q) {\n                int l1, r1, l2, r2, ans = INT_MAX;\n                scanf(\"%d%d%d%d\", &l1, &l2, &r1, &r2);\n                if (r2 - l2 > r1 - l1) {\n                    for (int i = l1; i <= r1; ++i) {\n                        int pos1 = i * m + l2, pos2 = i * m + r2;\n                        checkmin(ans, rmq(num1, st1, pos1, pos2));\n                    }\n                } else {\n                    for (int i = l2; i <= r2; ++i) {\n                        int pos1 = i * n + l1, pos2 = i * n + r1;\n                        checkmin(ans, rmq(num2, st2, pos1, pos2));\n                    }\n                }\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n\n\n#define min(x,y) (x)>(y)?(y):(x)\nconst int maxn = 700;\n\nint N,r,c;\nint val[maxn][maxn];\n\n//2D RMQ\n\nint dp[maxn][maxn][9][9];\nvoid RMQ_2D_PRE()\n{\n\tfor(int row = 0; row < r; row++) {\n\t\tfor(int col = 0; col<c; col++) {\t\t\t\n\t\t\tdp[row][col][0][0] = val[row][col];\n\t\t}\n\t}\n\t\n\tint m1 = log(double(r)) / log(2.0);\t\n    int m2 = log(double(c)) / log(2.0);\t\n\tfor(int i=0; i<=m1; i++) {\t\n\t\tfor(int j=0; j<=m2; j++) {\t\n\t\t\tif(i == 0 && j==0)\tcontinue;\t\t\n\t\t\tfor(int row = 0; row+(1<<i)-1 <= r; row++) {\n\t\t\t\tfor(int col = 0; col+(1<<j)-1 <= c; col++){\n\t\t\t\t\tif(i == 0) {\t\t\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i][j-1] , dp[row][col+(1<<(j-1))][i][j-1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[row][col][i][j] = min(dp[row][col][i-1][j] , dp[row+(1<<(i-1))][col][i-1][j]); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\n\nint RMQ_2D(int x1,int x2,int y1,int y2)\n{\n\tint kx = log(double(x2 - x1 +1)) / log(2.0);\n\tint ky = log(double(y2 - y1 +1)) / log(2.0);\n\tint m1 = dp[x1][y1][kx][ky];\n\tint m2 = dp[x2-(1<<kx)+1][y1][kx][ky];\n\tint m3 = dp[x1][y2-(1<<ky)+1][kx][ky];\n\tint m4 = dp[x2-(1<<kx)+1][y2-(1<<ky)+1][kx][ky];\n\treturn min( min(m1,m2), min(m3,m4) );\n}\n\n\nint main()\n{\n\tint T;\n\tint M;\n\tint x1,y1,x2,y2;\n\t//scanf(\"%d\",&T);\n\twhile(1)\t{\n\t\tscanf(\"%d%d%d\",&r,&c,&M);\n        if(r == 0 && c == 0 && M == 0) break;\n\t\tfor(int i=0; i<r; i++) { \t\t\t\n\t\t\tfor(int j=0; j<c; j++) {\n\t\t\t\tscanf(\"%d\",&val[i][j]);\n\t\t\t}\n\t\t}\t\t\n\t\tRMQ_2D_PRE();\t\t\n\t\twhile(M--)\t{\n\t\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\t\tprintf(\"%d\\n\",RMQ_2D(x1,x2,y1,y2));\t\t\n\t\t}\t\t\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint const inf = INT_MAX;\n\nstruct SegTree {\n    vector<int> dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat.assign(k*2, inf);\n    }\n    void set(int x, int val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    int get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            // dump(l,r);\n            return dat[k];\n        }\n        int v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        int v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, int val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,val), dat[i^1].get(x,val)));\n            i>>=1;\n        }\n    }\n    int get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            // dump(l,r);\n            return dat[k].get(x1,x2);\n        }\n        int v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        int v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int r,c,q;\n    while(cin>>r>>c>>q && r){\n        dump(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            int x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            dump(tree.dat[i].dat);\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            // dump(y1,y2,x1,x2);\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst function<int(int, int)> minQ = [](int l, int r) { return min(l, r); };\nconst function<int(int, int)> maxQ = [](int l, int r) { return max(l, r); };\n\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree2 {\n\tusing func_t = function<T(T, T)>;\n\tconst int h;\n\tconst T id;\n\tfunc_t merge;\n\tvector<SegmentTree<T>> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int li, int lj, int ri, int rj, int node, int lb, int ub) {\n\t\tif (ub <= li || ri <= lb) return id;\n\t\tif (li <= lb && ub <= ri) return data[node].Find(lj, rj - 1);\n\t\treturn merge(sub(li, lj, ri, rj, node * 2, lb, (lb + ub) / 2), sub(li, lj, ri, rj, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree2(int h_, int w_, T id_, func_t merge_) :\n\t\th(size(h_)), id(id_), merge(merge_), data(h * 2, SegmentTree<T>(w_, id, merge)) {}\n\tvoid Init(const vector<vector<T>> v) {\n\t\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\t\tdata[i + h].Init(v[i]);\n\t\t}\n\t\tint w = v.front().size();\n\t\tvector<T> tmp(w);\n\t\tfor (int i = h - 1; i > 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ttmp[j] = merge(data[i * 2].Find(j), data[i * 2 + 1].Find(j));\n\t\t\t}\n\t\t\tdata[i].Init(tmp);\n\t\t}\n\t}\n\tvoid Update(int i, int j, T val) {\n\t\ti += h;\n\t\tdata[i].Update(j, val);\n\t\twhile (i >>= 1) data[i].Update(j, merge(data[i * 2].Find(j, j), data[i * 2 + 1].Find(j, j)));\n\t}\n\tT Find(int i, int j) {\n\t\treturn data[i + h].Find(j);\n\t}\n\tT Find(int li, int lj, int ri, int rj) {\n\t\treturn sub(li, lj, ri + 1, rj + 1, 1, 0, h);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint r, c, q, r1, r2, c1, c2;\n\twhile (cin >> r >> c >> q, r | c | q) {\n\t\tSegmentTree2<int> st(r, c, INT_MAX, minQ);\n\t\t{\n\t\t\tvector<vector<int>> grid(r, vector<int>(c));\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tcin >> grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.Init(grid);\n\t\t}\n\t\twhile (q--) {\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tprintf(\"%d\\n\", st.Find(r1, c1, r2, c2));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n\nusing namespace std;\n\nconst int N = 40001000;\nconst int M = 1010;\nconst int inf = 0x7FFFFFFF;\n\n#define lowbit(x) ((x)&-(x))\n\nstruct POOL{\n\tint ar[N],p;\n\tvoid init(){\n\t\tp=0;\n\t}\n\tint* malloc(int size){\n\t\tp+=size;\n\t\treturn ar+p-size;\n\t}\n}pool;\n\nstruct TAR{\n\tint *f[M],*v[M],*g[M],*h[M];\n\tint flag;\n\tvoid init(int r,int c){\n\t\tif(r>c) flag=1,swap(r,c);\n\t\telse flag=0;\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tf[i]=pool.malloc(c);\n\t\t\tv[i]=pool.malloc(c);\n\t\t\tg[i]=pool.malloc(c);\n\t\t\th[i]=pool.malloc(c);\n\t\t}\n\t\tif(flag){\n\t\t\tfor(int i=1,a;i<=c;i++)\n\t\t\t\tfor(int j=1;j<=r;j++){\n\t\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\t\tv[j][i]=a;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=1,a;i<=r;i++)\n\t\t\t\tfor(int j=1;j<=c;j++){\n\t\t\t\t\tscanf(\"%d\",&a);\n\t\t\t\t\tv[i][j]=a;\n\t\t\t\t}\n\t\t}\n\t\tinit_g(r,c);\n\t\tinit_f(r,c);\n\t\tinit_h(r,c);\n\t}\n\tvoid init_g(int r,int c){\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tfor(int j=1;j<=c;j++)\n\t\t\t\tg[i][j]=v[i][j];\n\t\t\tfor(int j=1;j+lowbit(j)<=c;j+=lowbit(j))\n\t\t\t\tg[i][j+lowbit(j)]=min(g[i][j+lowbit(j)],g[i][j]);\n\t\t}\n\t}\n\tvoid init_f(int r,int c){\n\t\tfor(int i=1;i<=r;i++)\n\t\t\tfor(int j=1;j<=c;j++)\n\t\t\t\tf[i][j]=inf;\n\t\tfor(int i=1;i<=r;i++)\n\t\t\tfor(int j=1;j<=c;j++)\n\t\t\t\tfor(int p=i;p<=r;p+=lowbit(p))\n\t\t\t\t\tfor(int q=j;q<=c;q+=lowbit(q))\n\t\t\t\t\t\tf[p][q]=min(f[p][q],v[i][j]);\n\t}\n\tvoid init_h(int r,int c){\n\t\tfor(int i=1;i<=c;i++){\n\t\t\tfor(int j=1;j<=r;j++)\n\t\t\t\th[j][i]=inf;\n\t\t\tfor(int j=1;j<=r;j++)\n\t\t\t\tfor(int k=j;k<=r;k+=lowbit(k))\n\t\t\t\t\th[k][i]=min(h[k][i],v[j][i]);\n\t\t}\n\t}\n\tint query(int x1,int y1,int x2,int y2){\n\t\tint ans=inf;\n\t\twhile(x2>=x1){\n\t\t\tif(x2-lowbit(x2)>=x1-1)\n\t\t\t\tans=min(ans,query_f(x2,y1,y2)),x2-=lowbit(x2);\n\t\t\telse\n\t\t\t\tans=min(ans,query_g(x2,y1,y2)),x2--;\n\t\t}\n\t\treturn ans;\n\t}\n\tint query_g(int x2,int y1,int y2){\n\t\tint ans=inf;\n\t\twhile(y2>=y1){\n\t\t\tif(y2-lowbit(y2)>=y1-1)\n\t\t\t\tans=min(ans,g[x2][y2]),y2-=lowbit(y2);\n\t\t\telse \n\t\t\t\tans=min(ans,v[x2][y2]),y2--;\n\t\t}\n\t\treturn ans;\n\t}\n\tint query_f(int x2,int y1,int y2){\n\t\tint ans=inf;\n\t\twhile(y2>=y1){\n\t\t\tif(y2-lowbit(y2)>=y1-1)\n\t\t\t\tans=min(ans,f[x2][y2]),y2-=lowbit(y2);\n\t\t\telse \n\t\t\t\tans=min(ans,query_h(x2-lowbit(x2)+1,x2,y2)),y2--;\n\t\t}\n\t\treturn ans;\n\t}\n\tint query_h(int x1,int x2,int y){\n\t\tint ans=inf;\n\t\twhile(x2>=x1){\n\t\t\tif(x2-lowbit(x2)>=x1-1)\n\t\t\t\tans=min(ans,h[x2][y]),x2-=lowbit(x2);\n\t\t\telse\n\t\t\t\tans=min(ans,v[x2][y]),x2--;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tint r,c,m;\n\t\twhile(scanf(\"%d %d %d\",&r,&c,&m)==3&&(r||c||m)){\n\t\t\tinit(r,c);\n\t\t\tfor(int i=1,x1,x2,y2,y1;i<=m;i++){\n\t\t\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\t\t\tif(flag) swap(x1,y1),swap(x2,y2);\n\t\t\t\tprintf(\"%d\\n\",query(x1+1,y1+1,x2+1,y2+1));\n\t\t\t}\n\t\t}\n\t}\n}tar;\n\nint main()\n{\n\ttar.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvector<vector<int> > dat;\nint r, c;\n\nint topow2(int a){\n\twhile( a & (a - 1) ) {\n\t\ta += a & -a;\n\t}\n\treturn a;\n}\n\n\nint query2(int c1, int c2, int kr, int k = 0, int left = 0, int right = c){\n\tif( right <= c1 || c2 <= left ) return INT_MAX;\n\tif( c1 <= left && right <= c2 ){\n\t\treturn dat[kr][k];\n\t}\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query2(c1, c2, kr, k * 2 + 1, left, mid);\n\tint vr = query2(c1, c2, kr, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\nint query1(int r1, int r2, int c1, int c2, int k = 0, int left = 0, int right = r){\n\tif( right <= r1 || r2 <= left ) return INT_MAX;\n\tif( r1 <= left && right <= r2 ) return query2(c1, c2, k);\n\t\n\tint mid = (left + right) / 2;\n\tint vl = query1(r1, r2, c1, c2, k * 2 + 1, left, mid);\n\tint vr = query1(r1, r2, c1, c2, k * 2 + 2, mid, right);\n\treturn min(vl, vr);\n}\n\n\nint main(){\n\tint r0, c0, q;\n\tint r1, c1, r2, c2;\n\t\n\twhile( scanf(\"%d%d%d\", &r0, &c0, &q), r0 != 0 ){\n\t\tr = topow2(r0);\n\t\tc = topow2(c0);\n\t\t\n\t\tdat.assign(r * 2 - 1, vector<int>(c * 2 - 1, INT_MAX) );\n\t\tvector<int> datr = dat[0];\n\n\t\tfor(int i = 0; i < r0; ++i){\n\t\t\tfor(int j = 0; j < c0; ++j){\n\t\t\t\tscanf(\"%d\", &datr[j + c - 1]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = c - 2; j >= 0; --j){\n\t\t\t\tdatr[j] = min(datr[j * 2 + 1], datr[j * 2 + 2]);\n\t\t\t}\n\t\t\tcopy(datr.begin(), datr.end(), dat[i + r - 1].begin());\n\t\t}\n\n\t\tfor(int j = 0; j < datr.size(); ++j){\n\t\t\tfor(int i = r - 2; i >= 0; --i){\n\t\t\t\tdat[i][j] = min(dat[i * 2 + 1][j], dat[i * 2 + 2][j]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tprintf(\"%d\\n\", query1(r1, r2 + 1, c1, c2 + 1) );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF ((1LL<<31)-1)\n#define D 6\n\nstruct SegTree {\n\tint segSize, realSegSize, nodeSize;\n\tvector<int> seg;\n\n\tvoid init(int n) {\n\t\trealSegSize = n;\n\n\t\tnodeSize = 0;\n\t\tfor (segSize = 1; segSize < n; segSize *= D) nodeSize += segSize;\n\n\t\tseg = vector<int>(nodeSize+n, INF);\n\t}\n\n\tint get(int n) {\n\t\tif (n < (int)seg.size()) return seg[n];\n\t\telse return INF;\n\t}\n\tvoid set(int n, int v) {\n\t\tif (n < (int)seg.size()) seg[n] = v;\n\t}\n\n\tvoid update(int pos, int val) {\n\t\tint n = nodeSize + pos;\n\t\tset(n, val);\n\t\twhile (n) {\n\t\t\tn = (n-1)/D;\n\n\t\t\tint r = INF;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tr = min(r, seg[n*D+i+1]);\n\t\t\t}\n\t\t\tset(n, r);\n\t\t}\n\t}\n\tint get(int n, int l, int r, int L, int R) {\n//\t\tcout << n << \" \" << l << \" \" << r << endl;\n\t\tif (L <= l && r <= R) return get(n);\n\t\telse if (R <= l || r <= L) return INF;\n\t\telse {\n\t\t\tint ret = INF;\n\t\t\tint prev = l;\n\t\t\tfor (int i = 0; i < D; ++i) {\n\t\t\t\tint next = i == D-1 ? r : prev + (r-l)/D;\n\t\t\t\tret = min(ret, get(n*D+i+1, prev, next, L, R));\n\t\t\t\tprev = next;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\tint get(int L, int R) {\n\t\treturn get(0, 0, segSize, L, R);\n\t}\n};\n\nstruct Query {\n\tint y1, x1, y2, x2;\n};\n\nint main() {\n\tint H, W, Q;\n\twhile ( cin >> H >> W >> Q, H || W || Q ) {\n\t\tvector< vector<int> > m(H, vector<int>(W, 0));\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\n\t\tbool isSegRow = H < W;\n\t\tvector<SegTree> seg;\n\n\t\tif (isSegRow) {\n\t\t\tseg.resize(H);\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tseg[y].init(W);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tseg.resize(W);\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tseg[x].init(H);\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (isSegRow) seg[y].update(x, m[y][x]);\n\t\t\t\telse seg[x].update(y, m[y][x]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\n\t\t\tint ans = INF;\n\t\t\tif (isSegRow) {\n\t\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\t\tans = min(ans, seg[y].get(x1, x2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int x = x1; x <= x2; ++x) {\n\t\t\t\t\tans = min(ans, seg[x].get(y1, y2+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\n\nconst int B=80;\nint H,W,Q;\nvi *fld,*bucket;\n\nbool solve(){\n    scanf(\"%d%d%d\",&H,&W,&Q);\n    if(H==0&&W==0&&Q==0)return false;\n    fld=new vi[H];\n    bucket=new vi[H/B+1];\n    fill_n(fld,H,vi(W));\n    fill_n(bucket,H/B+1,vi(W/B+1,INT_MAX));\n    vi latte(H/B+1,INT_MAX);\n    vi malta(W/B+1,INT_MAX);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            int a;\n            scanf(\"%d\",&a);\n            fld[i][j]=a;\n            bucket[i/B][j/B]=min(bucket[i/B][j/B],a);\n            latte[i/B]=min(latte[i/B],a);\n            malta[j/B]=min(malta[j/B],a);\n        }\n    }\n\n\n    while(Q--){\n        int x1,y1,x2,y2;\n        scanf(\"%d%d%d%d\",&y1,&x1,&y2,&x2);\n        ++y2;++x2;\n\n        int mi=INT_MAX;\n        if(mi<latte[y1/B])y1=(y1/B+1)*B;\n        while(y1<y2&&y1%B!=0){\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y1/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y1][j]);\n            }\n            ++y1;\n        }\n        //if(mi<latte[y2/B]&&y2%B!=0)y2=(y2/B-1)*B;\n        while(y1<y2&&y2%B!=0){\n            --y2;\n            for(int j=x1;j<x2;++j){\n                if(mi<bucket[y2/B][j/B]){\n                    j=(j/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[y2][j]);\n            }\n        }\n        if(mi<malta[x1/B])x1=(x1/B+1)*B;\n        while(x1<x2&&x1%B!=0){\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x1/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x1]);\n            }\n            ++x1;\n        }\n        //if(mi<malta[x2/B]&&x2%B!=0)x2=(x2/B-1)*B;\n        while(x1<x2&&x2%B!=0){\n            --x2;\n            for(int i=y1;i<y2;++i){\n                if(mi<bucket[i/B][x2/B]){\n                    i=(i/B+1)*B-1;\n                    continue;\n                }\n                mi=min(mi,fld[i][x2]);\n            }\n        }\n        int bx1=x1/B,bx2=x2/B;\n\n        while(y1<y2){\n            int by1=y1/B;\n            if(latte[by1]<mi){\n                for(int j=bx1;j<bx2;++j)\n                    mi=min(mi,bucket[by1][j]);\n            }\n            y1+=B;\n        }\n\n        printf(\"%d\\n\",mi);\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\nconst int INF = (1LL << 31) - 1;\nint h, w;\nvector<int> g[1024];\n// vector<vector<int> > g;\n\n// vector<vector<int> > data;\nvector<int> data[1024];\nint size(int n)\n{\n    int m = 1;\n    while (m < n)\n        m *= 2;\n    return m;\n}\nvoid build_segtree()\n{\n    for (int i = 0; i < 2 * h - 1; ++i)\n    {\n        data[i].clear();\n        data[i].resize(2 * w - 1, INF);\n    }\n\n    // x\n    for (int y = 0; y < h; ++y)\n    {\n        const int i = y + (h - 1);\n\n        for (int x = 0; x < w; ++x)\n            data[i][x + (w - 1)] = g[y][x];\n\n        for (int k = w - 2; k >= 0; --k)\n            data[i][k] = min(data[i][2 * k + 1], data[i][2 * k + 2]);\n    }\n\n    // y\n    for (int i = h - 2; i >= 0; --i)\n        for (int j = 0; j < 2 * w - 1; ++j)\n            data[i][j] = min(data[2 * i + 1][j], data[2 * i + 2][j]);\n}\nint x_query(int y_k, int x1, int x2, int k, int l, int r)\n{\n    if (x2 <= l || r <= x1)\n        return INF;\n    else if (x1 <= l && r <= x2)\n        return data[y_k][k];\n\n    int mid = (l + r) / 2;\n    int lv = x_query(y_k, x1, x2, 2 * k + 1, l, mid);\n    int rv = x_query(y_k, x1, x2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint y_query(int x1, int x2, int y1, int y2, int k, int l, int r)\n{\n    if (y2 <= l || r <= y1)\n        return INF;\n    else if (y1 <= l && r <= y2)\n        return x_query(k, x1, x2, 0, 0, w);\n\n    int mid = (l + r) / 2;\n    int lv = y_query(x1, x2, y1, y2, 2 * k + 1, l, mid);\n    int rv = y_query(x1, x2, y1, y2, 2 * k + 2, mid, r);\n    return min(lv, rv);\n}\nint main()\n{\n    fast_io();\n\n    int _h, _w, q;\n    while (cin >> _h >> _w >> q, _h)\n    {\n        h = size(_h), w = size(_w);\n        bool swawa = false;\n        if (_h < _w)\n        {\n            swawa = true;\n            swap(w, h);\n        }\n        for (int i = 0; i < h; ++i)\n        {\n            g[i].clear();\n            g[i].resize(w, INF);\n        }\n        for (int y = 0; y < _h; ++y)\n        {\n            for (int x = 0; x < _w; ++x)\n            {\n                if (!swawa)\n                    cin >> g[y][x];\n                else\n                    cin >> g[x][y];\n            }\n        }\n\n        build_segtree();\n\n        while (q--)\n        {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            ++x2, ++y2;\n            if (swawa)\n            {\n                swap(x1, y1);\n                swap(x2, y2);\n            }\n            cout << y_query(x1, x2, y1, y2, 0, 0, h) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef unsigned int dat_t;\ndat_t const inf = (1LL<<32)-1;\n\nstruct SegTree {\n    dat_t * dat; int n;\n    explicit SegTree(int n_){\n        int k = 1;\n        while(k < n_) k<<=1;\n        this->n = k;\n        dat = new dat_t[k*2];\n        fill(dat, dat+k*2, inf);\n    }\n    ~SegTree(){\n        delete [] dat;\n    }\n    explicit SegTree(const SegTree& s){\n        this->n = s.n;\n        this->dat = new dat_t[s.n*2];\n        rep(i,n*2) dat[i] = s.dat[i];\n    }\n    void set(int x, dat_t val){\n        int i = n + x; // leaf\n        dat[i] = val;\n        while(i != 1){ // 1 is root\n            dat[i>>1] = min(dat[i],dat[i^1]);\n            i>>=1;\n        }\n    }\n    dat_t get(int a, int b, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return inf;\n        if(a <= l && r <= b){\n            auto res = dat[k];\n            dump(\"x\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(a, b, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(a, b, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nstruct SegTree2D {\n    vector<SegTree> dat; int n;\n    explicit SegTree2D(int h, int w){\n        int k = 1;\n        while(k < h) k<<=1;\n        this->n = k;\n        dat.assign(k*2, SegTree(w));\n    }\n    void set(int x, int y, dat_t val){\n        int i = n + y; // leaf\n        dat[i].set(x, val);\n        while(i != 1){ // 1 is root\n            dat[i>>1].set(x, min(dat[i].get(x,x+1), dat[i^1].get(x,x+1)));\n            i>>=1;\n        }\n    }\n    dat_t get(int x1, int x2, int y1, int y2, int k=1, int l=0, int r=-1) const {\n        if(r == -1) r = n;\n        if(r <= y1 || y2 <= l) return inf;\n        if(y1 <= l && r <= y2){\n            auto res = dat[k].get(x1,x2);\n            dump(\"y\",l,r,res);\n            return res;\n        }\n        dat_t v1 = get(x1, x2, y1, y2, k<<1,   l,       (l+r)/2 );\n        dat_t v2 = get(x1, x2, y1, y2, k<<1|1, (l+r)/2, r       );\n        return min(v1,v2);\n    }\n};\n\nint r,c,q;\n\nint main(){\n#ifdef LOCAL\n    freopen(\"in\",\"r\",stdin);\n#endif\n    while(cin>>r>>c>>q && r){\n        if(r>c) swap(r,c);\n        SegTree2D tree(r,c);\n        rep(i,r)rep(j,c){\n            dat_t x;\n            cin >> x;\n            tree.set(j,i,x);\n        }\n        rep(i,tree.dat.size()){\n            // dump(tree.dat[i].dat);\n            dump(vector<dat_t>(tree.dat[i].dat, tree.dat[i].dat+tree.dat[i].n*2));\n        }\n        rep(i,q){\n            int x1,x2,y1,y2;\n            cin >> y1>>x1>>y2>>x2;\n            y2++; x2++;\n            cout << tree.get(x1,x2,y1,y2) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int> > seg;\nint wbin, hbin;\n\nvoid update(int y, int x, int v)\n{\n\ty += hbin - 1;\n\tx += wbin - 1;\n\t\n\tseg[y][x] = v;\n\t\n\twhile (y >= 0){\n\t\tint _x = x;\n\t\twhile (_x){\n\t\t\t_x = (_x - 1) / 2;\n\t\t\tseg[y][_x] = min(seg[y][_x * 2 + 1], seg[y][_x * 2 + 2]);\n\t\t}\n\t\tif (y == 0) break;\n\t\ty = (y - 1) / 2;\n\t\tseg[y][x] = min(seg[y * 2 + 1][x], seg[y * 2 + 2][x]);\n\t}\n}\n\nint r1, c1, r2, c2, G;\n\nint _query(int k = 0, int l = 0, int r = wbin)\n{\n\tif (c2 <= l || r <= c1) return (INT_MAX);\n\tif (c1 <= l && r <= c2) return (seg[G][k]);\n\t\n\tint lval = _query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = _query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint query(int k = 0, int l = 0, int r = hbin)\n{\n\tif (r2 <= l || r <= r1) return (INT_MAX);\n\tif (r1 <= l && r <= r2){\n\t\tG = k;\n\t\treturn (_query());\n\t}\n\t\n\tint lval = query(k * 2 + 1, l, (l + r) / 2);\n\tint rval = query(k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (min(lval, rval));\n}\n\nint main()\n{\n\tint w, h, q;\n\t\n\twhile (scanf(\"%d %d %d\", &h, &w, &q) && w){\n\t\twbin = hbin = 1;\n\t\twhile (wbin < w) wbin *= 2;\n\t\twhile (hbin < h) hbin *= 2;\n\t\t\n\t\tseg.resize(hbin * 2 - 1);\n\t\tfor (int i = 0; i < seg.size(); i++) seg[i].resize(wbin * 2 - 1);\n\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tupdate(i, j, a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\t++r2; ++c2;\n\t\t\tprintf(\"%d\\n\", query());\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    2度あることはn回ある(帰納法)\n */\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 0xffffffff\n\nint r;\nint c;\nint q;\nint sizex;\nint sizey;\n\n\nclass Seg2d {\npublic:\n    vector<unsigned int> grid;\n    int width;\n    int height;\n\n    inline int get_idx(int watchl, int watchr, int watchu, int watchd) {\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        if (hori == 0 || vert == 0) return -1;\n        return (watchu/vert) * width/hori + watchl/hori;\n    }\n\n    Seg2d (int sizex, int sizey) : width(sizex), height(sizey) {\n        long long int a = min(width, height);\n        long long int b = max(width, height);\n        long long int size = (4*a*a-1)/3 + 2*a*(b-a);\n\n        grid.resize(size, INF);\n    }\n    ~Seg2d() {grid.clear();}\n\n    void _update(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd, unsigned int x) {\n        int midx, midy;\n        unsigned int idx, idx1, idx2, idx3, idx4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (hori == 0 || vert == 0) return;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            grid[base+get_idx(watchl, watchr, watchu, watchd)] = x;\n            return;\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy, x);\n        _update(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd, x);\n        _update(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd, x);\n        idx  = get_idx(watchl, watchr, watchu, watchd);\n        idx1 = get_idx(watchl, midx, watchu, midy);\n        idx2 = get_idx(midx, watchr, watchu, midy);\n        idx3 = get_idx(watchl, midx, midy, watchd);\n        idx4 = get_idx(midx, watchr, midy, watchd);\n        if (idx != -1) {\n            grid[base+idx] = INF;\n            if (idx1 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx1]);\n            if (idx2 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx2]);\n            if (idx3 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx3]);\n            if (idx4 != -1) grid[base+idx] = min(grid[base+idx], grid[newbase+idx4]);\n        }\n    }\n\n    void update(int x, int y, unsigned int t) {\n        _update(x, x+1, y, y+1, 0, 0, width, 0, height, t);\n    }\n\n    unsigned int _getMin(int wishl, int wishr, int wishu, int wishd, int base, int watchl, int watchr, int watchu, int watchd) {\n        int midx, midy;\n        unsigned int val1, val2, val3, val4;\n        int hori = watchr - watchl;\n        int vert = watchd - watchu;\n        int newbase;\n\n        if (hori == 0 || vert == 0) return INF;\n        if (wishr <= watchl || watchr <= wishl || wishd <= watchu || watchd <= wishu) return INF;\n        if (wishl <= watchl && watchr <= wishr && wishu <= watchu && watchd <= wishd) {\n            return grid[base+get_idx(watchl, watchr, watchu, watchd)];\n        }\n\n        midx = (watchl+watchr)/2;\n        midy = (watchu+watchd)/2;\n        newbase = base + width/hori * height/vert;\n        val1 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, watchu, midy);\n        val2 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, watchu, midy);\n        val3 = _getMin(wishl, wishr, wishu, wishd, newbase, watchl, midx, midy, watchd);\n        val4 = _getMin(wishl, wishr, wishu, wishd, newbase, midx, watchr, midy, watchd);\n        return min(min(val1, val2), min(val3, val4));\n    }\n\n    unsigned int getMin(int x1, int x2, int y1, int y2) { // [x1, x2) [y1, y2)\n        return _getMin(x1, x2, y1, y2, 0, 0, width, 0, height);\n    }\n};\n\nint main() {\n    while (1) {\n        scanf(\"%d %d %d\", &r, &c, &q);\n        if (r == 0 && c == 0 && q == 0) return 0;\n\n        sizex = 1;\n        while (sizex < c) sizex *= 2;\n        sizey = 1;\n        while (sizey < r) sizey *= 2;\n    \n        Seg2d seg(sizex, sizey);\n        for (int i=0; i<r; i++) {\n            for (int j=0; j<c; j++) {\n                unsigned int g;\n    \n                scanf(\"%u\", &g);\n                seg.update(j, i, g);\n            }\n        }\n \n        for (int i=0; i<q; i++) {\n            int r1, r2;\n            int c1, c2;\n    \n            scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n            printf(\"%u\\n\", seg.getMin(c1, c2+1, r1, r2+1));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*2; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tfast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 1000000 + 40;\n\nint r, c, q;\nint t[maxn * 4], a[maxn];\n\ninline int to(int x, int y, int c) {\n    return x * c + y;\n}\nint build(int x, int n, int lf, int rt) {\n    if (lf == rt) {\n        return t[to(x, n, c * 4)] = a[to(x, lf, c)];\n    }\n    int mid = (lf + rt) / 2;\n    return t[to(x, n, c * 4)] = min(build(x, n * 2, lf, mid), build(x, n * 2 + 1, mid + 1, rt));\n}\n\nint query(int x, int n, int lf, int rt, int x1, int x2) {\n    //printf(\"%d %d\\n\", x1, x2);\n    if (lf == x1 && rt == x2) {\n        //printf(\"%d %d %d: %d\\n\", x, n, c * 4, to(x, n, c * 4));\n        return t[to(x, n, c * 4)];\n    }\n    int mid = (lf + rt) / 2;\n    if (mid >= x2) {\n        return query(x, n * 2, lf, mid, x1, x2);\n    } else if (mid < x1) {\n        return query(x, n * 2 + 1, mid + 1, rt, x1, x2);\n    }\n    return min(query(x, n * 2, lf, mid, x1, mid), query(x, n * 2 + 1, mid + 1, rt, mid + 1, x2));\n}\n\nvoid gao() {\n    bool f = false;\n    if (r > c) {\n        swap(r, c);\n        f = true;\n        for (int i = 0; i < c; ++i) {\n            for (int j = 0; j < r; ++j) {\n                scanf (\"%d\", &a[to(j, i, c)]);\n            }\n        }\n    } else {\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                scanf (\"%d\", &a[to(i, j, c)]);\n            }\n        }\n    }\n    for (int i = 0; i < r; ++i) {\n        build(i, 1, 0, c - 1);\n    }\n    while (q--) {\n        int r1, c1, r2, c2;\n        scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n        if (f) swap(r1, c1), swap(r2, c2);\n        int ans = query(r1, 1, 0, c - 1, c1, c2);\n        for (int i = r1+1; i <= r2; ++i) {\n            ans = min(ans, query(i, 1, 0, c - 1, c1, c2));\n        }\n        printf (\"%d\\n\", ans);\n    }\n}\n\nint main() {\n    while (scanf (\"%d%d%d\", &r, &c, &q), r || c || q) {\n        gao();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 2147483647\n\n\nclass RMQ{\npublic:\n\tRMQ(int height,int first_N){\n\t\tN = 1;\n\t\twhile(N < first_N)N *= 2;\n\t\ttable = new int*[height];\n\t\tfor(int row = 0; row < height; row++){\n\t\t\ttable[row] = new int[2*N-1];\n\t\t\tfor(int col = 0; col < 2*N-1; col++){\n\t\t\t\ttable[row][col] = NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid update(int row,int loc,int value){\n\t\tloc += N-1;\n\n\t\ttable[row][loc] = value;\n\n\t\tif(N == 1)return;\n\n\t\tint parent = (loc-1)/2;\n\n\t\twhile(true){\n\t\t\ttable[row][parent] = min(table[row][2*parent+1],table[row][2*parent+2]);\n\n\t\t\tif(parent == 0)break;\n\t\t\telse{\n\t\t\t\tparent = (parent-1)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\tint getN(){\n\t\treturn N;\n\t}\n\n\tint query(int row,int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t\tif(search_left <= node_left && search_right >= node_right){\n\t\t\treturn table[row][node_id];\n\t\t}\n\n\t\tint left_min = query(row,search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tint right_min = query(row,search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\t\treturn min(left_min,right_min);\n\t}\n\tint** table;\n\tint N;\n};\n\n\nint H,W,Q;\n\nvoid func(){\n\n\tint** input = new int*[H];\n\tfor(int row = 0; row < H; row++){\n\t\tinput[row] = new int[W];\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)scanf(\"%d\",&input[row][col]);\n\t}\n\n\tRMQ YOKO(H,W);\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tYOKO.update(row,col,input[row][col]);\n\t\t}\n\t}\n\n\tRMQ TATE(W,H);\n\tfor(int col = 0; col < W; col++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tTATE.update(col,row,input[row][col]);\n\t\t}\n\t}\n\n\tint row1,col1,row2,col2;\n\tint ans;\n\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%d %d %d %d\",&row1,&col1,&row2,&col2);\n\n\t\tans = NUM;\n\n\t\tif(row2-row1 >= col2-col1){\n\t\t\tfor(int col = col1; col <= col2; col++){\n\t\t\t\tans = min(ans,TATE.query(col,row1,row2,0,0,TATE.getN()-1));\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int row = row1; row <= row2; row++){\n\t\t\t\tans = min(ans,YOKO.query(row,col1,col2,0,0,YOKO.getN()-1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&H,&W,&Q);\n\t\tif(H == 0 && W == 0 && Q == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\ntypedef unsigned int uint;\n\nconst uint INF=2147483648;\nconst int MAX_N=1<<20;\n\nuint dat[4*MAX_N];\nint n;\nint h,w;\nint r,c,q;\n\nvoid init(int h_,int w_){\n\th=w=1;\n\twhile(h<h_)h*=2;\n\twhile(w<w_)w*=2;\n\tfor(int i = 0; i < h*w*4; i++)\n\t\tdat[i]=INF;\n}\nvoid update(int k,int a){\n\t// h*w-1©ç¦nßé\n\tk+=h*w-1;\n\tdat[k]=a;\n\t// oèÈªçindexðXV\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=min(dat[k*2+1],dat[k*2+2]);\n\t}\n}\nuint query(int qminx,int qminy,int qmaxx,int qmaxy,int sminx,int sminy,int smaxx,int smaxy,int k){\n\t// dÈèªªÈ¢\n\tif(qmaxy<sminy||smaxy<qminy||qmaxx<sminx||smaxx<qminx)return INF;\n\t// ®SÉÜÜêé\n\tif(qminx<=sminx&&smaxx<=qmaxx&&qminy<=sminy&&smaxy<=qmaxy)return dat[k];\n\t// »ÝxðªµÄ¢é©AyÅªµÄ¢é©Åêí¯\n\tuint vl,vr;\n\tif(sminy==smaxy){\n\t\t// yðªµI¦Ä¢éê\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,(smaxx+sminx)/2,smaxy,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,(smaxx+sminx)/2+1,sminy,smaxx,smaxy,2*k+2);\n\t}\n\telse{\n\t\t// Ü¾yðªµI¦Ä¢È¢ê,yÅª\n\t\tvl=query(qminx,qminy,qmaxx,qmaxy,sminx,sminy,smaxx,(smaxy+sminy)/2,2*k+1);\n\t\tvr=query(qminx,qminy,qmaxx,qmaxy,sminx,(smaxy+sminy)/2+1,smaxx,smaxy,2*k+2);\n\t}\n\treturn min(vl,vr);\n}\n\nint main(){\n\twhile(cin>>r>>c>>q&&!(r==0&&c==0&&q==0)){\n\t\tfast_stream();\n\t\tinit(r,c);\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tupdate(i*w+j,t);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tuint res=query(c1,r1,c2,r2,0,0,w-1,h-1,0);\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    \n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int r, c, q;\n    int t;\n    int i, j;\n    int x1, x2, y1, y2, y;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &r, &c, &q);\n        \n        if (r + c + q == 0){\n            break;\n        }\n        \n        init(r * c);\n        for (i = 0; i < r; i++){\n            for (j = 0; j < c; j++){\n                scanf(\"%d\", &t);\n                update(i * c + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            for (y = y1; y <= y2; y++){\n                ans = _min(ans, query(y * c + x1, y * c + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 4100000\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nint dat[2*MAX_N-1];\nint h,w;\nconst int INF=INT_MAX;\n\n#define MIN(a,b) (a<b?a:b)\n\n// ú»\nvoid init(int h_,int w_){\n    int j;\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    memset(dat,-1,sizeof(dat));\n    //for(j = 0; j < 2*h*w-1; j++)\n    //    dat[j]=-1;\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        if(dat[k*2+2]==-1)\n            dat[k]=dat[k*2+1];\n        else if(dat[k*2+1]==-1)\n            dat[k]=dat[k*2+2];\n        else\n            dat[k]=MIN(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\nint query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    int vl,vr;\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    if(vr==-1)\n        return vl;\n    else if(vl==-1)\n        return vr;\n    return MIN(vl,vr);\n}\nint r,cc,q,t;\nint a,b,c,d;\n\nvoid solve(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        int i,j;\n        init(r,cc);\n        for(i = 0; i < r; i++){\n            for(j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%d\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n}\n\nint main(){\n\nsolve();\n\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_G\t(~(1 << 31))\n#define MAX_RC\t(1000000)\n\n/* global variables */\n\nstatic int grids[MAX_RC];\n\n/* main */\n\nint main(int argc, char **argv) {\n  int c, c1, c2, g, i, min_g, q, r, r1, r2, x, y;\n\n  for (;;) {\n    scanf(\"%d\", &r);\n    scanf(\"%d\", &c);\n    scanf(\"%d\", &q);\n    if ((r | c | q) == 0) break;\n\n    for (y = 0; y < r; y++)\n      for (x = 0; x < c; x++)\n\tscanf(\"%d\", &(grids[y * c + x]));\n\n    for (i = 0; i < q; i++) {\n      scanf(\"%d\", &r1);\n      scanf(\"%d\", &c1);\n      scanf(\"%d\", &r2);\n      scanf(\"%d\", &c2);\n\n      min_g = MAX_G;\n\n      for (y = r1; y <= r2; y++)\n\tfor (x = c1; x <= c2; x++) {\n\t  g = grids[y * c + x];\n\t  if (min_g > g) min_g = g;\n\t}\n\n      printf(\"%d\\n\", min_g);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        if (h >= w){\n\t        for (i = 0; i < h; i++){\n    \t        for (j = 0; j < w; j++){\n        \t        scanf(\"%d\", &t);\n            \t    update(i * w + j, t);\n            \t}\n        \t}\n        }\n        else {\n        \tfor (i = 0; i < h; i++){\n        \t\tfor (j = 0; j < w; j++){\n        \t\t\tscanf(\"%d\", &t);\n        \t\t\tupdate(i + j * h, t);\n        \t\t}\n        \t}\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {\n            \tif (h >= w){\n\t\t            for (int k = y1; k <= y2; k++){\n    \t\t        \tans = min(ans, query(k * w + x1, k * w + x2 + 1, 0, 0, n));\n        \t\t    }\n        \t\t}\n        \t\telse {\n        \t\t\tfor (int k = x1; k <= x2; k++){\n        \t\t\t\tans = min(ans, query(k * h + y1, k * h + y2 + 1, 0, 0, n));\n        \t\t\t}\n        \t\t}\n            \tprintf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    \n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int r, c, q;\n    int t;\n    int i, j;\n    int x1, x2, y1, y2, y;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &r, &c, &q);\n        \n        if (r + c + q == 0){\n            break;\n        }\n        \n        init(r * c);\n        for (i = 0; i < r; i++){\n            for (j = 0; j < c; j++){\n                scanf(\"%d\", &t);\n                update(i * r + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            for (y = y1; y <= y2; y++){\n                ans = _min(ans, query(y * r + x1, y * r + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    \n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int r, c, q;\n    int t;\n    int i, j;\n    int x1, x2, y1, y2, y;\n    int ans;\n    int node;\n    while (1){\n        scanf(\"%d%d%d\", &r, &c, &q);\n        \n        if (r + c + q == 0){\n            break;\n        }\n        \n        init(r * c);\n        node = 0;\n        for (i = 0; i < r; i++){\n            for (j = 0; j < c; j++){\n                scanf(\"%d\", &t);\n                update(node++, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            for (y = y1; y <= y2; y++){\n                ans = _min(ans, query(y * r + x1, y * r + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <math.h>\n\n\n#define MAX_N 4100000\n#define MIN(a,b) (a>b?b:a)\n\ntypedef long long ll;\n// ZOgØðÂO[ozñ\n// 0 <-> h*w-1ÌindexÉÀf[^ª¶Ý\nll dat[2*MAX_N-1];\nint h,w;\nconst ll INF=1LL<<40;\n// ú»\nvoid init(int h_,int w_){\n    h=1;\n    w=1;\n    while(h<h_)\n        h*=2;\n    while(w<w_)\n        w*=2;\n    int i;\n    for(i = 0; i<2*h*w-1; i++)\n      dat[i]=INF;\n    //fill(dat,dat+2*h*w-1,INF);\n}\n// kÔÚÌl(0-indexed)ðaÉÏX\nvoid update(int k,int a){\n    // tÌß_\n    k+=(h*w-1);\n    dat[k]=a;\n    // ÌÚèÈªçXV\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=MIN(dat[k*2+1],dat[k*2+2]);\n    }\n}\nll query(int qminx,int qminy,int qmaxx,int qmaxy,int k,int minx,int miny,int maxx,int maxy){\n    // dÈçÈ¢\n    if(qmaxx<minx||maxx<qminx||qmaxy<miny||maxy<qminy)\n        return INF;\n    // ¡ñÌÌæª®SÉÜÜêé\n    else if(minx>=qminx&&qmaxx>=maxx&&miny>=qminy&&qmaxy>=maxy)\n        return dat[k];\n    ll vl,vr;\n    // ÅÍ¡Éª\n    if(miny!=maxy){\n        int midY=(miny+maxy)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,maxx,midY);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,minx,midY+1,maxx,maxy);\n    }\n    // ªµ«Á½çc\n    else{\n        int midX=(minx+maxx)/2;\n        vl=query(qminx,qminy,qmaxx,qmaxy,k*2+1,minx,miny,midX,maxy);\n        vr=query(qminx,qminy,qmaxx,qmaxy,k*2+2,midX+1,miny,maxx,maxy);\n    }\n    return MIN(vl,vr);\n}\nint r,cc,q,t;\n\nint main(){\n    while(scanf(\"%d %d %d\\n\",&r,&cc,&q)&&!(r==0&&cc==0&&q==0)){\n        int a,b,c,d;\n        init(r,cc);\n\tint i,j;\n        for(i = 0; i < r; i++){\n            for(j = 0; j < cc; j++){\n                scanf(\"%d\",&t);\n                update(i*w+j,t);\n            }\n        }\n        for(i = 0; i < q; i++){\n            scanf(\"%d %d %d %d\\n\",&a,&b,&c,&d);\n            printf(\"%lld\\n\",query(b,a,d,c,0,0,0,w-1,h-1));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define INF (2000000000);\n\nint n, dat[(1 << 21) - 1];\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INF;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return INF;\n    }\n    \n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int r, c, q;\n    int t;\n    int i, j;\n    int x1, x2, y1, y2, y;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &r, &c, &q);\n        \n        if (r + c + q == 0){\n            break;\n        }\n        \n        init(r * c);\n        \n        for (i = 0; i < r; i++){\n            for (j = 0; j < c; j++){\n                scanf(\"%d\", &t);\n                update(i * r + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INF;\n            for (y = y1; y <= y2; y++){\n                ans = min(ans, query(y * r + x1, y * r + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[10000000];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (r = 0; r < h2; r++) seg[r] = pool + r*w2;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[11000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n     \n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = h << 1, w2 = w << 1;\n\t\tseg = calloc(h2, sizeof(int *));\n\t\tfor (r = 0; r < h2; r++) seg[r] = calloc(w2, sizeof(int));\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 11000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfor (r = 0; r < h2; r++) free(seg[r]);\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[6000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n//\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, v, i;\n     \n    while (scanf(\"%d%d%d\", &R, &C, &Q) && R > 0) {\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\t\tseg = calloc(h2, sizeof(int *));\n\t\tfor (r = 0; r < h2; r++) seg[r] = calloc(w2, sizeof(int));\n\n        for (r = 0; r < R; r++) for (c = 0; c < C; c++)\n\t\t\tscanf(\"%d\", &v), update(r, c, v);\n\n        for (i = 0; i < Q; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tr2++, c2++;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfor (r = 0; r < h2; r++) free(seg[r]);\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    \n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int r, c, q;\n    int t;\n    int i, j;\n    int x1, x2, y1, y2, y;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &r, &c, &q);\n        \n        if (r + c + q == 0){\n            break;\n        }\n        \n        init(r * c);\n        printf(\"n = %d\\n\", n);\n        for (i = 0; i < r; i++){\n            for (j = 0; j < c; j++){\n                scanf(\"%d\", &t);\n                update(i * r + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            for (y = y1; y <= y2; y++){\n                ans = _min(ans, query(y * r + x1, y * r + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\n#define M 1000\nint a[M][N];\nmain()\n{\n\tint i,j,k,r,c,q,r1,r2,c1,c2,t;\n\twhile(scanf(\"%d%d%d\",&r,&c,&q)&(r+c+q))\n\t{\n\t\tfor (i=0;i<r;i++)\n\t\t\tfor(j=0;j<c;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t\tfor(k=0;k<q;k++)\n\t\t\t{\n\t\t\t\tscanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\t\tif(a[r1][c1]>a[r2][c2])\n\t\t\t\t\tt=a[r2][c2];\n\t\t\t\telse\n\t\t\t\t\tt=a[r1][c1];\n\t\t\t\tprintf(\"%d\\n\",t);\n\t\t\t}\n\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b && l / w == (r - 1) / w && y1 <= l / w && l / w <= y2 && x1 <= l % w && l % w <= x2 && x1 <= (r - 1) % w && (r - 1) % w <= x2){\n        return (dat[k]);\n    }\n    else if (a <= l && r <= b && !(l / w == (r - 1) / w && y1 <= l / w && l / w <= y2 && x1 <= l % w && l % w <= x2 && x1 <= (r - 1) % w && (r - 1) % w <= x2)){\n        return (INT_MAX);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            printf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[4000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n//\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[9000000];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, v, i;\n\n    while (scanf(\"%d%d%d\", &R, &C, &Q) && R > 0) {\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (r = 0; r < h2; r++) seg[r] = pool + r*w2;\n\n        for (r = 0; r < R; r++) for (c = 0; c < C; c++)\n\t\t\tscanf(\"%d\", &v), update(r, c, v);\n\n        for (i = 0; i < Q; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n\t\t\tr2++, c2++;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[8000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, dat[(1 << 21) - 1];\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\n\nint x1, x2, y1, y2;\nint w, h, q;\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            if (x1 == 0 && x2 == w - 1){\n            \tprintf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n            }\n            else {\n\t            for (int k = y1; k <= y2; k++){\n    \t        \tans = min(ans, query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n        \t    }\n            \tprintf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[4000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\nint x1, x2, y1, y2;\nint w, h, q;\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    \n    if (a <= l && r <= b && x1 <= l % w && l % w <= x2 && x1 <= (r - 1) % w && (r - 1) % w <= x2){\n        return (dat[k]);\n    }\n    else if (a <= l && r <= b){\n        return (INT_MAX);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        \n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            printf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[7000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n//\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\nint x1, x2, y1, y2;\nint w, h, q;\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b && l / w == (r - 1) / w && y1 <= l / w && l / w <= y2 && x1 <= l % w && l % w <= x2 && x1 <= (r - 1) % w && (r - 1) % w <= x2){\n        return (dat[k]);\n    }\n    else if (a <= l && r <= b && l / w == (r - 1) / w){\n        return (INT_MAX);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            printf(\"%d\\n\", query(y1 * w + x1, y2 * w + x2 + 1, 0, 0, n));\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int x1, x2, y1, y2, y;\n    int w, h, q;\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            for (y = y1; y <= y2; y++){\n                printf(\"%d\\n\", query(y * w + x1, y * w + x2 + 1, 0, 0, n));\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\nint n, dat[(1 << 21) - 1];\n\nint _min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid init(int size)\n{\n    int i;\n    n = 1;\n    while (n < size){\n        n *= 2;\n    }\n    \n    for (i = 0; i < 2 * n - 1; i++){\n        dat[i] = INT_MAX;\n    }\n}\n\nvoid update(int k, int x)\n{\n    k += n - 1;\n    dat[k] = x;\n    while (k > 0){\n        k = (k - 1) / 2;\n        dat[k] = _min(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n\nint query(int a, int b, int k, int l, int r)\n{\n    int vl, vr;\n    \n    if (r <= a || b <= l){\n        return (INT_MAX);\n    }\n    if (a <= l && r <= b){\n        return (dat[k]);\n    }\n    else {\n        vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return (_min(vl, vr));\n    }\n}\n\nint main(void)\n{\n    int x1, x2, y1, y2, y;\n    int w, h, q;\n    int t;\n    int i, j;\n    int ans;\n    \n    while (1){\n        scanf(\"%d%d%d\", &h, &w, &q);\n        \n        if (w + h + q == 0){\n            break;\n        }\n        \n        init(w * h);\n        for (i = 0; i < h; i++){\n            for (j = 0; j < w; j++){\n                scanf(\"%d\", &t);\n                update(i * w + j, t);\n            }\n        }\n        \n        for (j = 0; j < q; j++){\n            scanf(\"%d%d%d%d\", &y1, &x1, &y2, &x2);\n            ans = INT_MAX;\n            for (y = y1; y <= y2; y++){\n                ans = _min(ans, query(y * w + x1, y * w + x2 + 1, 0, 0, n));\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1068: School of Killifish\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n\nint pool[8000002];\nint **seg;\nint h, w;\nint r1, c1, r2, c2, g;\nchar buf[10000000], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid update(int r, int c, int x)\n{\n\tint c2, t, a;\n\n\tr += h - 1;\n\tc += w - 1;\n\tseg[r][c] = x;\n\n\twhile (r >= 0) {\n\t\tc2 = c;\n\t\twhile (c2) {\n\t\t\tif (!(c2 & 1)) c2--;\n\t\t\tt = c2, c2 >>= 1;\n\t\t\ta = seg[r][t++]; if (a > seg[r][t]) a = seg[r][t];\n\t\t\tseg[r][c2] = a;\n\t\t}\n\t\tif (r == 0) break;\n\n\t\tif (!(r & 1)) r--;\n\t\tt = r, r >>= 1;\n\t\ta = seg[t++][c]; if (a > seg[t][c]) a = seg[t][c];\n\t\tseg[r][c] = a;\n\t}\n}\n \nint query2(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n\tif (c2 <= l || r <= c1) return INF;\n    if (c1 <= l && r <= c2) return seg[g][k];\n     \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query2(l, m, ++k);\n    rmin = query2(m, r, ++k);\n    if (lmin > rmin) lmin = rmin; \n    return lmin;\n}\n \nint query(int l, int r, int k)\n{\n\tint m, lmin, rmin;\n\n    if (r2 <= l || r <= r1) return INF;\n    if (r1 <= l && r <= r2) { g = k; return query2(0, w, 0); }\n    \n\tk <<= 1, m = (l + r) >> 1;\n    lmin = query(l, m, ++k);\n    rmin = query(m, r, ++k);\n    if (lmin > rmin) lmin = rmin;\n    return lmin;\n}\n \nint main()\n{\n\tint R, C, Q, h2, w2, r, c, i;\n\n    while (fgets(p=buf, 40, stdin) && *p != '0') {\n\t\tR = getint(), C = getint(), Q = getint();\n\n\t\th = w = 1;\n\t\twhile (h < R) h <<= 1;\n\t\twhile (w < C) w <<= 1;\n\n\t\th2 = (h << 1) - 1, w2 = (w << 1) - 1;\n\n//\t\tmemset(pool, 0, sizeof(pool));\n\t\tseg = malloc(h2 * sizeof(int *));\n\t\tfor (c = r = 0; r < h2; r++, c += w2) seg[r] = pool + c;\n\n        for (r = 0; r < R; r++) {\n\t\t\tfgets(p=buf, 10000000, stdin);\n\t\t\tfor (c = 0; c < C; c++)\tupdate(r, c, getint());\n        }\n\n        for (i = 0; i < Q; i++) {\n\t\t\tfgets(p=buf, 100, stdin);\n\t\t\tr1 = getint(), c1 = getint(), r2 = getint()+1, c2 = getint()+1;\n            printf(\"%d\\n\", query(0, h, 0));\n        }\n\n\t\tfree(seg);\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "//School of Killifish\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint INF = Integer.MAX_VALUE;\n\t\tint[][] min = new int[1000][1000];\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt(), C = sc.nextInt(), Q = sc.nextInt();\n\t\t\tif((R|C|Q)==0)break;\n\t\t\tint h = (int) Math.ceil(Math.sqrt(R)), w = (int) Math.ceil(Math.sqrt(C));\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)min[i][j]=INF;\n\t\t\tint[][] a = new int[R][C];\n\t\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tint I = i/h, J = j/w;\n\t\t\t\tmin[I][J] = Math.min(min[I][J], a[i][j]);\n\t\t\t}\n\t\t\twhile(Q--!=0){\n\t\t\t\tint r1 = sc.nextInt(), c1 = sc.nextInt(), r2 = sc.nextInt(), c2 = sc.nextInt(), res = INF;\n\t\t\t\tfor(int i=r1/h;i<=r2/h;i++){\n\t\t\t\t\tint y1 = Math.max(r1, i*h), y2 = Math.min(r2, i*h+h-1);\n\t\t\t\t\tfor(int j=c1/w;j<=c2/w;j++){\n\t\t\t\t\t\tint x1 = Math.max(c1, j*w), x2 = Math.min(c2, j*w+w-1);\n\t\t\t\t\t\tif(y1==i*h && y2==(i+1)*h-1 && x1 == j*w && x2 == (j+1)*w-1)res = Math.min(res, min[i][j]);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(int y=y1;y<=Math.min(y2, i*h+h-1);y++)for(int x=x1;x<=Math.min(x2, j*w+w-1);x++)\n\t\t\t\t\t\t\t\tres = Math.min(res, a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    System.out.println(ans);\n                }\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//School of Killifish\npublic class Main{\n\n\tint r, c, yn, xn;\n\tSegY[] segy;\n\n\tclass SegY{\n\t\tint id;\n\t\tint[] segx;\n\t\tpublic SegY(int id) {\n\t\t\tthis.id = id;\n\t\t\tsegx = new int[2*xn-1];\n\t\t\tArrays.fill(segx, Integer.MAX_VALUE);\n\t\t}\n\t\tvoid update(int[] x, int ID){\n\t\t\tint n = x.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint k = xn-1+i;\n\t\t\t\t//\t\t\t\tSystem.out.println(\"UPDATE: \" + k + \" value:\" + x[i]);\n\t\t\t\tsegx[k] = x[i];\n\t\t\t\twhile(k>0){\n\t\t\t\t\tk=(k-1)/2;\n\t\t\t\t\tsegx[k] = Math.min(segx[2*k+1], segx[2*k+2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint k = yn-1+ID;\n\t\t\twhile(k>0){\n\t\t\t\tk=(k-1)/2;\n\t\t\t\tfor(int i=0;i<segx.length;i++)segy[k].segx[i] = Math.min(segy[2*k+1].segx[i], segy[2*k+2].segx[i]);\n\t\t\t}\n\t\t}\n\t\tvoid dump(){\n\t\t\tint p2 = 1;\n\t\t\tint id = 0;\n\t\t\tfor(int i=0;i<segx.length;i++){\n\t\t\t\tSystem.out.print(segx[i]+\" \");\n\t\t\t\tif(i==id){\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tp2*=2;\n\t\t\t\t\tid+=p2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint xquery(int x1, int x2, int k, int l, int r){\n\t\t\tint res = 0;\n\t\t\tif(x2<=l||r<=x1)res = Integer.MAX_VALUE;\n\t\t\telse if(x1<=l&&r<=x2)res = segx[k];\n\t\t\telse{\n\t\t\t\tint vl = xquery(x1, x2, 2*k+1, l, (l+r)/2);\n\t\t\t\tint vr = xquery(x1, x2, 2*k+2, (l+r)/2, r);\n\t\t\t\tres = Math.min(vl, vr);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint query(int y1, int y2, int x1, int x2, int k, int l, int r){\n\t\tint res = 0;\n\t\tif(y2<=l||r<=y1)res = Integer.MAX_VALUE;\n\t\telse if(y1<=l&&r<=y2)res = segy[k].xquery(x1, x2, 0, 0, xn);\n\t\telse {\n\t\t\tint vl = query(y1, y2, x1, x2, 2*k+1, l, (l+r)/2);\n\t\t\tint vr = query(y1, y2, x1, x2, 2*k+2, (l+r)/2, r);\n\t\t\tres = Math.min(vl, vr);\n\t\t}\n//\t\tSystem.out.println(\"Y-Query: [\" + y1 + \",\" + y2+\") K:\" + k + \" L:\" + l  +\" R:\" + r + \" REST:\" + res);\n\t\treturn res;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tr = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tyn = 1;while(yn<r)yn*=2;\n\t\t\txn = 1;while(xn<c)xn*=2;\n\t\t\tsegy = new SegY[2*yn-1];\n\t\t\tfor(int i=0;i<segy.length;i++)segy[i]=new SegY(i);\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tsegy[yn-1+i].update(a[i], i);\n\t\t\t}\n\t\t\twhile(q--!=0){\n\t\t\t\t//\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\t//\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\t//\t\t\t\tsegy[0].dump();\n\t\t\t\t//\t\t\t\tSystem.out.println(segy[0].xquery(x1, x2, 0, 0, xn));\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tSystem.out.println(query(y1, y2+1, x1, x2+1, 0, 0, yn));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    System.out.println(ans);\n                }\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n    static class Scanner implements Closeable {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int cur;\n        private int num;\n\n        Scanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int nextInt() {\n            return (int) nextLong();\n        }\n\n        long nextLong() {\n            int c = read();\n            while (isdel(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long l = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                l *= 10;\n                l += c - '0';\n                c = read();\n            } while (!isdel(c));\n            return l * sgn;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            int c = read();\n            while (isdel(c))\n                c = read();\n            StringBuilder s = new StringBuilder();\n            do {\n                s.appendCodePoint(c);\n                c = read();\n            } while (!isdel(c));\n            return s.toString();\n        }\n\n        private int read() {\n            if (num == -1)\n                throw new InputMismatchException();\n            if (cur >= num) {\n                cur = 0;\n                try {\n                    num = stream.read(buf);\n                } catch (Exception e) {\n                    throw new InputMismatchException();\n                }\n                if (num <= 0)\n                    return -1;\n            }\n            return buf[cur++];\n        }\n\n        private boolean isdel(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        @Override\n        public void close() {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 100;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = 0;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry*divSize-1<=y2){\n\t\t\t\t\tif((ry+1)*divSize-1<y1){\n\t\t\t\t\t\try++;continue;\n\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\twhile(rx*divSize<=x1){\n\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\t\twhile(rx*divSize<=x1){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tPrintWriter writer = new PrintWriter(System.out);\n\t\twhile (true) {\n\t\t\tint R = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint C = sc.nextInt();\n\t\t\tint Q = sc.nextInt();\n\t\t\tint[][] G = new int[R][C];\n\t\t\tint[][] tr = new int[C][R];\n\t\t\tfor (int i = 0; i < R; ++i) {\n\t\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\t\ttr[j][i] = G[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ru = 1;\n\t\t\twhile (ru < C * 2) {\n\t\t\t\tru *= 2;\n\t\t\t}\n\t\t\tint[][] row = new int[R][ru];\n\t\t\tfor (int i = 0; i < R; ++i) {\n\t\t\t\tbuild(G[i], row[i]);\n\t\t\t}\n\t\t\tint cu = 1;\n\t\t\twhile (cu < R * 2) {\n\t\t\t\tcu *= 2;\n\t\t\t}\n\t\t\tint[][] col = new int[C][cu];\n\t\t\tfor (int i = 0; i < C; ++i) {\n\t\t\t\tbuild(tr[i], col[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint R1 = sc.nextInt();\n\t\t\t\tint C1 = sc.nextInt();\n\t\t\t\tint R2 = sc.nextInt();\n\t\t\t\tint C2 = sc.nextInt();\n\t\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\t\tif (R2 - R1 < C2 - C1) {\n\t\t\t\t\tfor (int j = R1; j <= R2; ++j) {\n\t\t\t\t\t\tans = Math.min(ans, get(row[j], 0, C1, C2 + 1, 0, ru / 2));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = C1; j <= C2; ++j) {\n\t\t\t\t\t\tans = Math.min(ans, get(col[j], 0, R1, R2 + 1, 0, cu / 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twriter.println(ans);\n\t\t\t}\n\t\t}\n\t\twriter.flush();\n\t}\n\n\tstatic void build(int[] in, int[] out) {\n\t\tfor (int i = 0; i < in.length; ++i) {\n\t\t\tout[out.length / 2 - 1 + i] = in[i];\n\t\t}\n\t\tfor (int i = in.length; i < out.length / 2; ++i) {\n\t\t\tout[out.length / 2 - 1 + i] = Integer.MAX_VALUE;\n\t\t}\n\t\tfor (int i = out.length / 2 - 2; i >= 0; --i) {\n\t\t\tout[i] = Math.min(out[i * 2 + 1], out[i * 2 + 2]);\n\t\t}\n\t}\n\n\tstatic int get(int[] tree, int cur, int f, int e, int left, int right) {\n\t\tif (right <= f || e <= left) return Integer.MAX_VALUE;\n\t\tif (f <= left && right <= e) return tree[cur];\n\t\tint mid = (left + right + 1) / 2;\n\t\treturn Math.min(get(tree, cur * 2 + 1, f, e, left, mid), get(tree, cur * 2 + 2, f, e, mid, right));\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    System.out.println(ans);\n                }\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 100;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = 0;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n\t\t\t\t\tif((ry+1)*divSize-1<y1){\n\t\t\t\t\t\try++;continue;\n\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 100;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt()+1;\n\t\t\t\tint x2 = sc.nextInt()+1;\n\t\t\t\tint ry = 0;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry*divSize<y2){\n\t\t\t\t\tif((ry+1)*divSize<=y1){\n\t\t\t\t\t\try++;continue;\n\t\t\t\t\t}\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize<=y2){\n\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\twhile(rx*divSize<=x1){\n\t\t\t\t\t\t\tif((rx+1)*divSize<x1){\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<(rx+1)*divSize;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<(ry+1)*divSize;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<y2))continue;\n\t\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\t\twhile(rx*divSize<=x1){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<(rx+1)*divSize;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic final int INF = Integer.MAX_VALUE;\n\t\n\tstatic int W, H, WW, HH, segH, segW;\n\tstatic int[][] data;\n\tstatic int[][] segTree;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tH = Integer.parseInt(in.next());\n\t\t\tW = Integer.parseInt(in.next());\n\t\t\tint Q = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif(H==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\t\n\t\t\tdata = new int[H][W];\n\t\t\t\n\t\t\tfor(int i=0; i<H; i++){\n\t\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t\tdata[i][j] = Integer.parseInt(in.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint logH = H == 1 ? 0 : 31 - Integer.numberOfLeadingZeros(H-1),\n\t\t\t\tlogW = W == 1 ? 0 : 31 - Integer.numberOfLeadingZeros(W-1);\n\t\t\tHH = 1<<(logH+1);\n\t\t\tWW = 1<<(logW+1);\n\t\t\tsegH = 2*HH-1;\n\t\t\tsegW = 2*WW-1;\n\t\t\t\n\t\t\tsegTree = new int[segH][segW];\n\t\t\t\n\t\t\tinitializeH(0,0,HH);\n\t\t\t\n\t\t\tfor(int i=0; i<Q; i++){\n\t\t\t\tint y1 = Integer.parseInt(in.next());\n\t\t\t\tint x1 = Integer.parseInt(in.next());\n\t\t\t\tint y2 = Integer.parseInt(in.next());\n\t\t\t\tint x2 = Integer.parseInt(in.next());\n\t\t\t\tSystem.out.println(query(y1, x1, y2+1, x2+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void initializeW(int y, int cur, int lx, int rx){\n\t\tif(rx - lx <= 1){\n\t\t\tif(y < H && lx < W){\n\t\t\t\tsegTree[y+HH-1][cur] = data[y][lx];\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tint mid = (lx + rx) / 2;\n\t\t\n\t\tinitializeW(y, 2*cur+1, lx, mid);\n\t\tinitializeW(y, cur*2+2, mid, rx);\n\t\t\n\t\tsegTree[y+HH-1][cur] = Math.min(segTree[y+HH-1][2*cur+1], segTree[y+HH-1][2*cur+2]);\n\t}\n\t\n\tstatic int queryW(int nodeY, int fx, int tx, int cur, int lx, int rx){\n\t\tif(rx <= fx || tx <= lx){\n\t\t\treturn INF;\n\t\t}\n\t\t\n\t\tif(fx<=lx&&rx<=tx){\n\t\t\treturn segTree[nodeY][cur];\n\t\t}\n\t\t\n\t\tint mid = (lx+rx)/2;\n\t\treturn Math.min(queryW(nodeY, fx, tx, cur*2+1, lx, mid), queryW(nodeY, fx, tx, cur*2+2, mid, rx));\n\t}\n\t\n\tstatic void initializeH(int cur, int ly, int ry){\n\t\tif(ry -ly <= 1){\n\t\t\tinitializeW(ly, 0, 0, WW);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tint mid = (ly+ry)/2;\n\t\t\n\t\tinitializeH(2*cur+1, ly, mid);\n\t\tinitializeH(2*cur+2, mid, ry);\n\t\t\n\t\tfor(int j=0; j<segW; j++){\n\t\t\tsegTree[cur][j] = Math.min(segTree[2*cur+1][j], segTree[2*cur+2][j]);\n\t\t}\n\t}\n\t\n\tstatic int queryH(int fy, int ty, int fx, int tx, int cur, int ly, int ry){\n\t\tif(ry<=fy || ty<=ly){\n\t\t\treturn INF;\n\t\t}\n\t\tif(fy <=ly && ry<=ty){\n\t\t\treturn queryW(cur, fx, tx, 0, 0, WW);\n\t\t}\n\t\t\n\t\tint mid = (ly+ry)/2;\n\t\treturn Math.min(queryH(fy, ty, fx, tx, cur*2+1, ly, mid), queryH(fy, ty, fx, tx, cur*2+2, mid, ry));\n\t}\n\t\n\tstatic int query(int y1, int x1, int y2, int x2){\n\t\treturn queryH(y1, y2, x1, x2, 0, 0, HH);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//School of Killifish\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint INF = Integer.MAX_VALUE;\n\t\tint[][] min = new int[1000][1000];\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt(), C = sc.nextInt(), Q = sc.nextInt(), MIN = INF;\n\t\t\tif((R|C|Q)==0)break;\n\t\t\tint h = (int) Math.ceil(Math.sqrt(R)), w = (int) Math.ceil(Math.sqrt(C));\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)min[i][j]=INF;\n\t\t\tint[][] a = new int[R][C];\n\t\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tint I = i/h, J = j/w;\n\t\t\t\tmin[I][J] = Math.min(min[I][J], a[i][j]);\n\t\t\t\tMIN = Math.min(MIN, INF);\n\t\t\t}\n\t\t\twhile(Q--!=0){\n\t\t\t\tint r1 = sc.nextInt(), c1 = sc.nextInt(), r2 = sc.nextInt(), c2 = sc.nextInt(), res = INF;\n\t\t\t\tfor(int i=r1/h;i<=r2/h;i++){\n\t\t\t\t\tint y1 = Math.max(r1, i*h), y2 = Math.min(r2, i*h+h-1);\n\t\t\t\t\tfor(int j=c1/w;j<=c2/w;j++){\n\t\t\t\t\t\tif(res <= min[i][j])continue;\n\t\t\t\t\t\tint x1 = Math.max(c1, j*w), x2 = Math.min(c2, j*w+w-1);\n\t\t\t\t\t\tif(y1==i*h && y2==(i+1)*h-1 && x1 == j*w && x2 == (j+1)*w-1)res = Math.min(res, min[i][j]);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(int y=y1;y<=y2;y++)for(int x=x1;x<=x2;x++)\n\t\t\t\t\t\t\t\tres = Math.min(res, a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//School of Killifish\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint INF = Integer.MAX_VALUE;\n\t\tint[][] min = new int[1000][1000];\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt(), C = sc.nextInt(), Q = sc.nextInt(), MIN = INF;\n\t\t\tif((R|C|Q)==0)break;\n\t\t\tint h = (int) Math.ceil(Math.sqrt(R)), w = (int) Math.ceil(Math.sqrt(C));\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)min[i][j]=INF;\n\t\t\tint[][] a = new int[R][C];\n\t\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tint I = i/h, J = j/w;\n\t\t\t\tmin[I][J] = Math.min(min[I][J], a[i][j]);\n\t\t\t\tMIN = Math.min(MIN, INF);\n\t\t\t}\n\t\t\twhile(Q--!=0){\n\t\t\t\tint r1 = sc.nextInt(), c1 = sc.nextInt(), r2 = sc.nextInt(), c2 = sc.nextInt(), res = INF;\n\t\t\t\tfor(int i=r1/h;i<=r2/h;i++){\n\t\t\t\t\tint y1 = Math.max(r1, i*h), y2 = Math.min(r2, i*h+h-1);\n\t\t\t\t\tfor(int j=c1/w;j<=c2/w;j++){\n\t\t\t\t\t\tint x1 = Math.max(c1, j*w), x2 = Math.min(c2, j*w+w-1);\n\t\t\t\t\t\tif(y1==i*h && y2==(i+1)*h-1 && x1 == j*w && x2 == (j+1)*w-1)res = Math.min(res, min[i][j]);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(int y=y1;y<=Math.min(y2, i*h+h-1);y++)for(int x=x1;x<=Math.min(x2, j*w+w-1);x++)\n\t\t\t\t\t\t\t\tres = Math.min(res, a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res==MIN)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(res==MIN)break;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 500;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = 0;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n\t\t\t\t\tif((ry+1)*divSize-1<y1){\n\t\t\t\t\t\try++;continue;\n\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package jp.tuyano.eclipsebook;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic final int INF = Integer.MAX_VALUE;\n\t\n\tstatic int W, H, WW, HH, segH, segW;\n\tstatic int[][] data;\n\tstatic int[][] segTree;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tH = Integer.parseInt(in.next());\n\t\t\tW = Integer.parseInt(in.next());\n\t\t\tint Q = Integer.parseInt(in.next());\n\t\t\t\n\t\t\tif(H==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\t\n\t\t\tdata = new int[H][W];\n\t\t\t\n\t\t\tfor(int i=0; i<H; i++){\n\t\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t\tdata[i][j] = Integer.parseInt(in.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint logH = H == 1 ? 0 : 31 - Integer.numberOfLeadingZeros(H-1),\n\t\t\t\tlogW = W == 1 ? 0 : 31 - Integer.numberOfLeadingZeros(W-1);\n\t\t\tHH = 1<<(logH+1);\n\t\t\tWW = 1<<(logW+1);\n\t\t\tsegH = 2*HH-1;\n\t\t\tsegW = 2*WW-1;\n\t\t\t\n\t\t\tsegTree = new int[segH][segW];\n\t\t\t\n\t\t\tinitializeH(0,0,HH);\n\t\t\t\n\t\t\tfor(int i=0; i<Q; i++){\n\t\t\t\tint y1 = Integer.parseInt(in.next());\n\t\t\t\tint x1 = Integer.parseInt(in.next());\n\t\t\t\tint y2 = Integer.parseInt(in.next());\n\t\t\t\tint x2 = Integer.parseInt(in.next());\n\t\t\t\tSystem.out.println(query(y1, x1, y2+1, x2+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void initializeW(int y, int cur, int lx, int rx){\n\t\tif(rx - lx <= 1){\n\t\t\tif(y < H && lx < W){\n\t\t\t\tsegTree[y+HH-1][cur] = data[y][lx];\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tint mid = (lx + rx) / 2;\n\t\t\n\t\tinitializeW(y, 2*cur+1, lx, mid);\n\t\tinitializeW(y, cur*2+2, mid, rx);\n\t\t\n\t\tsegTree[y+HH-1][cur] = Math.min(segTree[y+HH-1][2*cur+1], segTree[y+HH-1][2*cur+2]);\n\t}\n\t\n\tstatic int queryW(int nodeY, int fx, int tx, int cur, int lx, int rx){\n\t\tif(rx <= fx || tx <= lx){\n\t\t\treturn INF;\n\t\t}\n\t\t\n\t\tif(fx<=lx&&rx<=tx){\n\t\t\treturn segTree[nodeY][cur];\n\t\t}\n\t\t\n\t\tint mid = (lx+rx)/2;\n\t\treturn Math.min(queryW(nodeY, fx, tx, cur*2+1, lx, mid), queryW(nodeY, fx, tx, cur*2+2, mid, rx));\n\t}\n\t\n\tstatic void initializeH(int cur, int ly, int ry){\n\t\tif(ry -ly <= 1){\n\t\t\tinitializeW(ly, 0, 0, WW);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tint mid = (ly+ry)/2;\n\t\t\n\t\tinitializeH(2*cur+1, ly, mid);\n\t\tinitializeH(2*cur+2, mid, ry);\n\t\t\n\t\tfor(int j=0; j<segW; j++){\n\t\t\tsegTree[cur][j] = Math.min(segTree[2*cur+1][j], segTree[2*cur+2][j]);\n\t\t}\n\t}\n\t\n\tstatic int queryH(int fy, int ty, int fx, int tx, int cur, int ly, int ry){\n\t\tif(ry<=fy || ty<=ly){\n\t\t\treturn INF;\n\t\t}\n\t\tif(fy <=ly && ry<=ty){\n\t\t\treturn queryW(cur, fx, tx, 0, 0, WW);\n\t\t}\n\t\t\n\t\tint mid = (ly+ry)/2;\n\t\treturn Math.min(queryH(fy, ty, fx, tx, cur*2+1, ly, mid), queryH(fy, ty, fx, tx, cur*2+2, mid, ry));\n\t}\n\t\n\tstatic int query(int y1, int x1, int y2, int x2){\n\t\treturn queryH(y1, y2, x1, x2, 0, 0, HH);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n\tScanner s = new Scanner(System.in);\n\twhile(true) {\n\t    int r = s.nextInt();\n\t    int c = s.nextInt();\n\t    int n = s.nextInt();\n\t    if(n == 0) break;\n\t    int[][] data = new int[r][c];\n\t    for(int i=0 ; i<r ; i++) {\n\t\tfor(int j=0 ; j<c ; j++)\n\t\t    data[i][j] = s.nextInt();\n\t    }\n\t    for(int i=0 ; i<n ; i++) {\n\t\tint x1 = s.nextInt();\n\t\tint y1 = s.nextInt();\n\t\tint x2 = s.nextInt();\n\t\tint y2 = s.nextInt();\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int j=x1 ; j<=x2 ; j++) {\n\t\t    for(int k=y1 ; k<=y2 ; k++)\n\t\t\tif(min>data[j][k]) min = data[j][k];\n\t\t}\n\t\tSystem.out.println(min);\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n\n    void run(){\n        Scanner sc = new Scanner();\n        int divSize = 1000;\n        int INF = Integer.MAX_VALUE;\n        while(true){\n            int r = sc.nextInt();\n            int c = sc.nextInt();\n            int q = sc.nextInt();\n            if((r|c|q)==0)break;\n            int[][] a = new int[r][c];\n            for(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n            int xsize = 1;while(xsize*divSize<c)xsize++;\n            int ysize = 1;while(ysize*divSize<r)ysize++;\n            int x[][] = new int[r][xsize];\n            for(int i=0;i<r;i++){\n                for(int j=0;j<xsize;j++){\n                    int min = INF;\n                    for(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n                    x[i][j] = min;\n                }\n            }\n            int y[][] = new int[c][ysize];\n            for(int j=0;j<c;j++){\n                for(int k=0;k<ysize;k++){\n                    int min = INF;\n                    for(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n                    y[j][k] = min;\n                }\n            }\n            int xy[][] = new int[ysize][xsize];\n            for(int i=0;i<ysize;i++){\n                for(int j=0;j<xsize;j++){\n                    int min = INF;\n                    for(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n                    xy[i][j] = min;\n                }\n            }\n//          System.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//          for(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//          for(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//          for(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n            while(q--!=0){\n                int y1 = sc.nextInt();\n                int x1 = sc.nextInt();\n                int y2 = sc.nextInt();\n                int x2 = sc.nextInt();\n                int ry = (y1+1)/divSize-1;\n                int min = INF;\n                while(ry<ysize){\n//                  if((ry+1)*divSize-1<y1){\n//                      ry++;continue;\n//                  }\n                    //ry row block\n                    if(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n                        int rx = (x1+1)/divSize-1;\n                        while(rx<xsize){\n//                          if((rx+1)*divSize-1<x1){\n//                              rx++;\n//                              continue;\n//                          }\n                            //rx col block\n                            if(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n                                min = Math.min(min, xy[ry][rx]);\n                            }\n                            else{\n                                for(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n                                    if(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n                                }\n                            }\n                            rx++;\n                        }\n                    }\n                    //not hit block ry\n                    else{\n                        for(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n                            if(!(y1<=i&&i<=y2))continue;\n                            int rx = (x1+1)/divSize-1;\n                            while(rx<xsize){\n                                if((rx+1)*divSize-1<x1){\n                                    rx++;continue;\n                                }\n                                //hit rx block\n                                if(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n                                    min = Math.min(min, x[i][rx]);\n                                }\n                                else{\n                                    for(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n                                        if(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n                                    }\n                                }\n                                rx++;\n                            }\n                        }\n                    }\n                    ry++;\n                }\n                System.out.println(min);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    class Scanner {\n        int nextInt() {\n            try {\n                int c = System.in.read();\n                while (c != '-' && (c < '0' || '9' < c))\n                    c = System.in.read();\n                if (c == '-') return -nextInt();\n                int res = 0;\n                do {\n                    res *= 10;\n                    res += c - '0';\n                    c = System.in.read();\n                } while ('0' <= c && c <= '9');\n                return res;\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "//import java.util.Scanner;\nimport java.io.*;\n\nclass Rmq{\n    int segt[] = new int[(1<<21)*2];\n    public int inp[] =new int[(1<<21)];\n    int MAX_VALUE=2147483647;\n    int min(int a,int b){return a<b?a:b;}\n    int max(int a,int b){return a>b?a:b;}\n    void update(int value,int pos,int n){\n\tint index=n-1+pos;\n\tsegt[index]=value;//[pos,pos]\n\twhile(index>0){\n\t    index=(index-1)/2;\n\t    segt[index]=min(segt[index*2+1],segt[index*2+2]);\n\t}\n    }\n    int query(int l,int r,int now,int ql,int qr){\n\tif (l == ql && r == qr){\n\t    return segt[now];\n\t}\n\tint midr=(l+r)/2,midl=midr+1;\n\tint ret=MAX_VALUE;\n\tif (ql <= midr)ret=min(ret,query(l,midr,now*2+1,ql,min(qr,midr)));\n\tif (midl <= qr)ret=min(ret,query(midl,r,now*2+2,max(midl,ql),qr));\n\treturn ret;\n    }\n\n    public void init(int r,int c,int lim){\n\tboolean isrowmajor=r<=c;\n\tfor(int i=0;i<lim;i++){\n\t    segt[i]=MAX_VALUE;\n\t}\n\tif (isrowmajor){\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i*c+j],i*c+j,lim);\n\t\t}\n\t    }\n\t}else {\n\t    for(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t    update(inp[i+j*r],i+j*r,lim);\n\t\t}\n\t    }\n\t}\n    }\n    int searchmin(int r1,int c1,int r2,int c2,int r,int c,int lim){\n\tboolean isrowmajor = r<=c;  \n\tint ret=MAX_VALUE;\n\tlim--;\n\tif (isrowmajor){\n\t    for(int i=r1;i<=r2;i++){\n\t\tret=min(ret,query(0,lim,0,i*c+c1,i*c+c2));\n\t    }\n\t}else {\n\t    for(int j=c1;j<=c2;j++){\n\t\tret=min(ret,query(0,lim,0,j*r+r1,j*r+r2));\n\t    }\n\t}\n\treturn ret;\n    }    \n\n}\n\nclass Main{\n    void run(){\n\tScanner in = new Scanner();\n\t//System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\tint r,c,q;\n\tRmq rmq=new Rmq();\n\twhile(true){\n\t    r=in.nextInt();\n\t    c=in.nextInt();\n\t    q=in.nextInt();\n\t    if (r == 0)break;\n\t    int lim=1;\n\t    boolean isrowmajor = r<=c;\n\t    while(true){\n\t\tif (lim >= r*c)break;\n\t\tlim*=2;\n\t    }\n\t    if (isrowmajor){\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i*c+j]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }else {\n\t\tfor(int i=0;i<r;i++){\n\t\t    for(int j=0;j<c;j++){\n\t\t\trmq.inp[i+j*r]=in.nextInt();\n\t\t    }\n\t\t}\n\t    }\n\t    rmq.init(r,c,lim);\n\t    for(int i=0;i<q;i++){\n\t\tint r1,r2,c1,c2;\n\t\tr1=in.nextInt();\n\t\tc1=in.nextInt();\n\t\tr2=in.nextInt();\n\t\tc2=in.nextInt();\n\t\tSystem.out.println(rmq.searchmin(r1,c1,r2,c2,r,c,lim));\n\t    }\n\t}\n    }\n    public static void main(String args[]){\n\tMain a = new Main();\n\ta.run();\n    }\n}\n\n\nclass Scanner {\n    int nextInt() {\n        try {\n            int c = System.in.read();\n            if (c == -1)\n                return c;\n            while (c != '-' && (c < '0' || '9' < c)) {\n                c = System.in.read();\n                if (c == -1)\n                    return c;\n            }\n            if (c == '-')\n                return -nextInt();\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    long nextLong() {\n        try {\n            int c = System.in.read();\n            if(c==-1)return -1;\n            while (c != '-' && (c < '0' || '9' < c)){\n                c = System.in.read();\n                if(c==-1)return -1;\n            }\n            if (c == '-')\n                return -nextLong();\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = System.in.read();\n            } while ('0' <= c && c <= '9');\n            return res;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n \n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n    String next() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (Character.isWhitespace(c))\n                c = System.in.read();\n            do {\n                res.append((char) c);\n            } while (!Character.isWhitespace(c = System.in.read()));\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n \n    String nextLine() {\n        try {\n            StringBuilder res = new StringBuilder(\"\");\n            int c = System.in.read();\n            while (c == '\\r' || c == '\\n')\n                c = System.in.read();\n            do {\n                res.append((char) c);\n                c = System.in.read();\n            } while (c != '\\r' && c != '\\n');\n            return res.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint r = io.nextInt();\n\t\t\tint c = io.nextInt();\n\t\t\tint q = io.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] grid = io.nextIntMatrix(r, c);\n\t\t\tRMQ2D rmq = new RMQ2D(grid);\n\t\t\tfor(int qq=0;qq<q;qq++) {\n\t\t\t\tint r1 = io.nextInt();\n\t\t\t\tint c1 = io.nextInt();\n\t\t\t\tint r2 = io.nextInt() + 1;\n\t\t\t\tint c2 = io.nextInt() + 1;\n\t\t\t\tio.println(rmq.min(r1, c1, r2, c2));\n\t\t\t}\n\t\t}\n\t\tio.flush();\n\t}\n}\nclass RMQ2D {\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tint n,m,n2 = 1,m2 = 1;\n\tint[][] data;\n\tpublic RMQ2D (int[][] a) {\n\t\tthis.n = a.length;\n\t\tthis.m = a[0].length;\n\t\twhile(n2 < n) n2 *= 2;\n\t\twhile(m2 < m) m2 *= 2;\n\t\tdata = new int[n2*2+1][m2*2+1];\n\t\tfor(int i=0;i<=n2*2;i++) {\n\t\t\tArrays.fill(data[i], INF);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tdata[n2-1+i][m2-1+j] = a[i][j];\n\t\t\t}\n\t\t\tfor(int j=m2-2;j>=0;j--) {\n\t\t\t\tdata[n2-1+i][j] = Math.min(data[n2-1+i][j*2+1], data[n2-1+i][j*2+2]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n2-2;i>=0;i--) {\n\t\t\tfor(int j=0;j<=m2*2;j++) {\n\t\t\t\tdata[i][j] = Math.min(data[i*2+1][j], data[i*2+2][j]);\n\t\t\t}\n\t\t}\n\t}\n\tpublic int min(int i1,int j1,int i2,int j2) {\n\t\treturn min(i1,i2,0,0,n2,j1,j2);\n\t}\n\tprivate int min(int a,int b,int k,int l,int r,int j1,int j2) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn minRow(k, j1, j2, 0, 0, m2) ;\n\t\t}else{\n\t\t\treturn Math.min(min(a, b, k*2+1, l, l+r >>> 1, j1, j2), min(a, b, k*2+2, l+r >>> 1, r, j1, j2));\n\t\t}\n\t}\n\tprivate int minRow(int ki,int a,int b,int k,int l,int r) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn data[ki][k];\n\t\t}else{\n\t\t\treturn Math.min(minRow(ki, a, b, k*2+1, l, l+r >>> 1), minRow(ki, a, b, k*2+2, l+r >>> 1, r));\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "//School of Killifish\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint INF = Integer.MAX_VALUE;\n\t\tint[][] min = new int[1000][1000];\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt(), C = sc.nextInt(), Q = sc.nextInt(), MIN = INF;\n\t\t\tif((R|C|Q)==0)break;\n\t\t\tint h = (int) Math.ceil(Math.sqrt(R)), w = (int) Math.ceil(Math.sqrt(C));\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)min[i][j]=INF;\n\t\t\tint[][] a = new int[R][C];\n\t\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tint I = i/h, J = j/w;\n\t\t\t\tmin[I][J] = Math.min(min[I][J], a[i][j]);\n\t\t\t\tMIN = Math.min(MIN, INF);\n\t\t\t}\n\t\t\twhile(Q--!=0){\n\t\t\t\tint r1 = sc.nextInt(), c1 = sc.nextInt(), r2 = sc.nextInt(), c2 = sc.nextInt(), res = INF;\n\t\t\t\tfor(int i=r1/h;i<=r2/h;i++){\n\t\t\t\t\tint y1 = Math.max(r1, i*h), y2 = Math.min(r2, i*h+h-1);\n\t\t\t\t\tfor(int j=c1/w;j<=c2/w;j++){\n\t\t\t\t\t\tif(res <= min[i][j])break;\n\t\t\t\t\t\tint x1 = Math.max(c1, j*w), x2 = Math.min(c2, j*w+w-1);\n\t\t\t\t\t\tif(y1==i*h && y2==(i+1)*h-1 && x1 == j*w && x2 == (j+1)*w-1)res = Math.min(res, min[i][j]);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(int y=y1;y<=y2;y++)for(int x=x1;x<=x2;x++)\n\t\t\t\t\t\t\t\tres = Math.min(res, a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(res==MIN)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(res==MIN)break;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint divSize = 200;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = (y1+1)/divSize-1;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n//\t\t\t\t\tif((ry+1)*divSize-1<y1){\n//\t\t\t\t\t\try++;continue;\n//\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\twhile(rx<xsize){\n//\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n//\t\t\t\t\t\t\t\trx++;\n//\t\t\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextLong();\n\t\t\t\tlong res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static int MAX_MOD = 10001;\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint h = 1;\n\t\t\n\t\tint b;\n\t\tint c;\n\t\t\n\t\tb = N<=0 ? N : 1;\n\t\tc = N<=0 ? 1 : N;\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = b;i<=c;i++){\n\t\t\tans+=i;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint R = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint C = sc.nextInt();\n\t\t\tint Q = sc.nextInt();\n\t\t\tint[][] G = new int[R][C];\n\t\t\tint[][] tr = new int[C][R];\n\t\t\tfor (int i = 0; i < R; ++i) {\n\t\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\t\ttr[j][i] = G[i][j] = Integer.parseInt(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ru = 1;\n\t\t\twhile (ru < C * 2) {\n\t\t\t\tru *= 2;\n\t\t\t}\n\t\t\tint[][] row = new int[R][ru];\n\t\t\tfor (int i = 0; i < R; ++i) {\n\t\t\t\tbuild(G[i], row[i]);\n\t\t\t}\n\t\t\tint cu = 1;\n\t\t\twhile (cu < R * 2) {\n\t\t\t\tcu *= 2;\n\t\t\t}\n\t\t\tint[][] col = new int[C][cu];\n\t\t\tfor (int i = 0; i < C; ++i) {\n\t\t\t\tbuild(tr[i], col[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\t\tint R1 = Integer.parseInt(sc.next());\n\t\t\t\tint C1 = Integer.parseInt(sc.next());\n\t\t\t\tint R2 = Integer.parseInt(sc.next());\n\t\t\t\tint C2 = Integer.parseInt(sc.next());\n\t\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\t\tif (R2 - R1 < C2 - C1) {\n\t\t\t\t\tfor (int j = R1; j <= R2; ++j) {\n\t\t\t\t\t\tans = Math.min(ans, get(row[j], 0, C1, C2 + 1, 0, ru / 2));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = C1; j <= C2; ++j) {\n\t\t\t\t\t\tans = Math.min(ans, get(col[j], 0, R1, R2 + 1, 0, cu / 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void build(int[] in, int[] out) {\n\t\tfor (int i = 0; i < in.length; ++i) {\n\t\t\tout[out.length / 2 - 1 + i] = in[i];\n\t\t}\n\t\tfor (int i = in.length; i < out.length / 2; ++i) {\n\t\t\tout[out.length / 2 - 1 + i] = Integer.MAX_VALUE;\n\t\t}\n\t\tfor (int i = out.length / 2 - 2; i >= 0; --i) {\n\t\t\tout[i] = Math.min(out[i * 2 + 1], out[i * 2 + 2]);\n\t\t}\n\t}\n\n\tstatic int get(int[] tree, int cur, int f, int e, int left, int right) {\n\t\tif (right <= f || e <= left) return Integer.MAX_VALUE;\n\t\tif (f <= left && right <= e) return tree[cur];\n\t\tint mid = (left + right + 1) / 2;\n\t\treturn Math.min(get(tree, cur * 2 + 1, f, e, left, mid), get(tree, cur * 2 + 2, f, e, mid, right));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//School of Killifish\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint INF = Integer.MAX_VALUE;\n\t\tint[][] min = new int[1000][1000];\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt(), C = sc.nextInt(), Q = sc.nextInt();\n\t\t\tif((R|C|Q)==0)break;\n\t\t\tint h = (int) Math.ceil(Math.sqrt(R)), w = (int) Math.ceil(Math.sqrt(C));\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)min[i][j]=INF;\n\t\t\tint[][] a = new int[R][C];\n\t\t\tfor(int i=0;i<R;i++)for(int j=0;j<C;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tint I = i/h, J = j/w;\n\t\t\t\tmin[I][J] = Math.min(min[I][J], a[i][j]);\n\t\t\t}\n\t\t\twhile(Q--!=0){\n\t\t\t\tint r1 = sc.nextInt(), c1 = sc.nextInt(), r2 = sc.nextInt(), c2 = sc.nextInt(), res = INF;\n\t\t\t\tfor(int i=r1/h;i<=r2/h;i++){\n\t\t\t\t\tint y1 = Math.max(r1, i*h), y2 = Math.min(r2, i*h+h-1);\n\t\t\t\t\tfor(int j=c1/w;j<=c2/w;j++){\n\t\t\t\t\t\tif(res <= min[i][j])continue;\n\t\t\t\t\t\tint x1 = Math.max(c1, j*w), x2 = Math.min(c2, j*w+w-1);\n\t\t\t\t\t\tif(y1==i*h && y2==(i+1)*h-1 && x1 == j*w && x2 == (j+1)*w-1)res = Math.min(res, min[i][j]);\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(int y=y1;y<=y2;y++)for(int x=x1;x<=x2;x++)\n\t\t\t\t\t\t\t\tres = Math.min(res, a[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 1000;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = 0;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n\t\t\t\t\tif((ry+1)*divSize-1<y1){\n\t\t\t\t\t\try++;continue;\n\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = 0;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint r = io.nextInt();\n\t\t\tint c = io.nextInt();\n\t\t\tint q = io.nextInt();\n\t\t\tif (r == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] grid = io.nextIntMatrix(r, c);\n\t\t\tRMQ2D rmq = new RMQ2D(grid);\n\t\t\tfor(int qq=0;qq<q;qq++) {\n\t\t\t\tint r1 = io.nextInt();\n\t\t\t\tint c1 = io.nextInt();\n\t\t\t\tint r2 = io.nextInt() + 1;\n\t\t\t\tint c2 = io.nextInt() + 1;\n\t\t\t\tio.println(rmq.min(r1, c1, r2, c2));\n\t\t\t}\n\t\t\tio.flush();\n\t\t\tSystem.gc();\n\t\t}\n\t\tio.flush();\n\t}\n}\nclass RMQ2D {\n\tpublic static final int INF = Integer.MAX_VALUE;\n\tint n,m,n2 = 1,m2 = 1;\n\tint[][] data;\n\tpublic RMQ2D (int[][] a) {\n\t\tthis.n = a.length;\n\t\tthis.m = a[0].length;\n\t\twhile(n2 < n) n2 *= 2;\n\t\twhile(m2 < m) m2 *= 2;\n\t\tdata = new int[n2*2+1][m2*2+1];\n\t\tfor(int i=0;i<=n2*2;i++) {\n\t\t\tArrays.fill(data[i], INF);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tdata[n2-1+i][m2-1+j] = a[i][j];\n\t\t\t}\n\t\t\tfor(int j=m2-2;j>=0;j--) {\n\t\t\t\tdata[n2-1+i][j] = Math.min(data[n2-1+i][j*2+1], data[n2-1+i][j*2+2]);\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(data[n2-1+i]));\n\t\t}\n\t\tfor(int i=n2-2;i>=0;i--) {\n\t\t\tfor(int j=0;j<=m2*2;j++) {\n\t\t\t\tdata[i][j] = Math.min(data[i*2+1][j], data[i*2+2][j]);\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(Arrays.deepToString(data));\n\t}\n\n\tpublic int min(int i1,int j1,int i2,int j2) {\n\t\treturn min(i1,i2,0,0,n2,j1,j2);\n\t}\n\tprivate int min(int a,int b,int k,int l,int r,int j1,int j2) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn minRow(k, j1, j2, 0, 0, m2) ;\n\t\t}else{\n\t\t\treturn Math.min(min(a, b, k*2+1, l, l+r >>> 1, j1, j2), min(a, b, k*2+2, l+r >>> 1, r, j1, j2));\n\t\t}\n\t}\n\tprivate int minRow(int ki,int a,int b,int k,int l,int r) {\n\t\tif (r <= a || b <= l) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn data[ki][k];\n\t\t}else{\n\t\t\treturn Math.min(minRow(ki, a, b, k*2+1, l, l+r >>> 1), minRow(ki, a, b, k*2+2, l+r >>> 1, r));\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    sb.append(ans).append('\\n');\n                }\n                System.out.println(sb);\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint divSize = 500;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = (y1+1)/divSize-1;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n//\t\t\t\t\tif((ry+1)*divSize-1<y1){\n//\t\t\t\t\t\try++;continue;\n//\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\twhile(rx<xsize){\n//\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n//\t\t\t\t\t\t\t\trx++;\n//\t\t\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    sb.append(ans).append('\\n');\n                }\n                System.out.print(sb);\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n    static class Scanner implements Closeable {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int cur;\n        private int num;\n\n        Scanner(InputStream stream) {\n            this.stream = stream;\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int nextInt() {\n            return (int) nextLong();\n        }\n\n        long nextLong() {\n            int c = read();\n            while (isdel(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long l = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                l *= 10;\n                l += c - '0';\n                c = read();\n            } while (!isdel(c));\n            return l * sgn;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            int c = read();\n            while (isdel(c))\n                c = read();\n            StringBuilder s = new StringBuilder();\n            do {\n                s.appendCodePoint(c);\n                c = read();\n            } while (!isdel(c));\n            return s.toString();\n        }\n\n        private int read() {\n            if (num == -1)\n                throw new InputMismatchException();\n            if (cur >= num) {\n                cur = 0;\n                try {\n                    num = stream.read(buf);\n                } catch (Exception e) {\n                    throw new InputMismatchException();\n                }\n                if (num <= 0)\n                    return -1;\n            }\n            return buf[cur++];\n        }\n\n        private boolean isdel(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        @Override\n        public void close() {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint divSize = 500;\n\t\tint INF = Integer.MAX_VALUE;\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif((r|c|q)==0)break;\n\t\t\tint[][] a = new int[r][c];\n\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<c;j++)a[i][j]=sc.nextInt();\n\t\t\tint xsize = 1;while(xsize*divSize<c)xsize++;\n\t\t\tint ysize = 1;while(ysize*divSize<r)ysize++;\n\t\t\tint x[][] = new int[r][xsize];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, a[i][k]);\n\t\t\t\t\tx[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint y[][] = new int[c][ysize];\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tfor(int k=0;k<ysize;k++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int i=k*divSize;i<r&&i<(k+1)*divSize;i++)min = Math.min(min, a[i][j]);\n\t\t\t\t\ty[j][k] = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xy[][] = new int[ysize][xsize];\n\t\t\tfor(int i=0;i<ysize;i++){\n\t\t\t\tfor(int j=0;j<xsize;j++){\n\t\t\t\t\tint min = INF;\n\t\t\t\t\tfor(int k=j*divSize;k<c&&k<(j+1)*divSize;k++)min = Math.min(min, y[k][i]);\n\t\t\t\t\txy[i][j] = min;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"XSIZE: \" + xsize + \" Ysize:\" + ysize);\n//\t\t\tfor(int i=0;i<r;i++)for(int j=0;j<xsize;j++)System.out.println(\"X: Row:\" + i + \" Backet:\" + j + \" Val:\" + x[i][j]);\n//\t\t\tfor(int i=0;i<c;i++)for(int j=0;j<ysize;j++)System.out.println(\"Y: Col:\" + i + \" Backet:\" + j + \" Val:\" + y[i][j]);\n//\t\t\tfor(int i=0;i<ysize;i++)for(int j=0;j<xsize;j++)System.out.println(\"XY: Block Row:\" + i + \" Block Col:\" + j + \" Val:\" + xy[i][j]);\n\t\t\twhile(q--!=0){\n\t\t\t\tint y1 = sc.nextInt();\n\t\t\t\tint x1 = sc.nextInt();\n\t\t\t\tint y2 = sc.nextInt();\n\t\t\t\tint x2 = sc.nextInt();\n\t\t\t\tint ry = (y1+1)/divSize-1;\n\t\t\t\tint min = INF;\n\t\t\t\twhile(ry<ysize){\n//\t\t\t\t\tif((ry+1)*divSize-1<y1){\n//\t\t\t\t\t\try++;continue;\n//\t\t\t\t\t}\n\t\t\t\t\t//ry row block\n\t\t\t\t\tif(y1<=ry*divSize&&(ry+1)*divSize-1<=y2){\n\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\twhile(rx<xsize){\n//\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n//\t\t\t\t\t\t\t\trx++;\n//\t\t\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//rx col block\n\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\tmin = Math.min(min, xy[ry][rx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, y[j][ry]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//not hit block ry\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=ry*divSize;i<=(ry+1)*divSize-1;i++){\n\t\t\t\t\t\t\tif(!(y1<=i&&i<=y2))continue;\n\t\t\t\t\t\t\tint rx = (x1+1)/divSize-1;\n\t\t\t\t\t\t\twhile(rx<xsize){\n\t\t\t\t\t\t\t\tif((rx+1)*divSize-1<x1){\n\t\t\t\t\t\t\t\t\trx++;continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//hit rx block\n\t\t\t\t\t\t\t\tif(x1<=rx*divSize&&(rx+1)*divSize-1<=x2){\n\t\t\t\t\t\t\t\t\tmin = Math.min(min, x[i][rx]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tfor(int j=rx*divSize;j<=(rx+1)*divSize-1;j++){\n\t\t\t\t\t\t\t\t\t\tif(x1<=j&&j<=x2)min = Math.min(min, a[i][j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\try++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextLong();\n\t\t\t\tlong res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\tStringBuilder res =new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c=='\\r' || c=='\\n')\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while (c!='\\r' && c!='\\n');\n\t\t\t\treturn res.toString();\n\t\t\t}catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            for (;;) {\n                int r = in.nextInt(), c = in.nextInt(), q = in.nextInt();\n                if (r == 0 && c == 0 && q == 0) {\n                    break;\n                }\n                SegmentTree2D st2d = new SegmentTree2D(r, c);\n                for (int i = 0; i < r; i++) {\n                    for (int j = 0; j < c; j++) {\n                        st2d.update(i, j, in.nextInt());\n                    }\n                }\n                StringBuilder sb = new StringBuilder();\n                while (q-- > 0) {\n                    int r1 = in.nextInt(), c1 = in.nextInt(), r2 = in.nextInt(), c2 = in.nextInt();\n                    int ans = st2d.query(r1, r2 + 1, c1, c2 + 1);\n                    sb.append(ans).append('\\n');\n                }\n                System.out.print(sb);\n            }\n        }\n    }\n\n    static class SegmentTree2D {\n\n        private final int m, n;\n\n        private final SegmentTree[] dat;\n\n        public SegmentTree2D(int _m, int _n) {\n            m = SegmentTree.getSize(_m);\n            n = SegmentTree.getSize(_n);\n            dat = new SegmentTree[(m - 1) + m];\n            for (int i = 0; i < dat.length; i++) {\n                dat[i] = new SegmentTree(n);\n            }\n        }\n\n        /** 0-indexed mk (vertical), nk (horizontal), a (value) */\n        public void update(int mk, int nk, int a) {\n            mk += m - 1;\n            dat[mk].update(nk, a);\n            while (mk > 0) {\n                mk = (mk - 1) / 2;\n                if (dat[mk].dat[nk + n - 1] > a) {\n                    dat[mk].update(nk, a);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        /** 2D range-query for [ma, mb) (vertical) [na, nb) (horizontal) */\n        public int query(int ma, int mb, int na, int nb) {\n            return query(ma, mb, na, nb, 0, 0, m);\n        }\n\n        private int query(int ma, int mb, int na, int nb, int mk, int ml, int mr) {\n            if (mr <= ma || mb <= ml) {\n                return Integer.MAX_VALUE;\n            }\n            if (ma <= ml && mr <= mb) {\n                return dat[mk].query(na, nb);\n            }\n            int vl = query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) / 2);\n            int vr = query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) / 2, mr);\n            return Math.min(vl, vr);\n        }\n\n        /** 1D implementation */\n        static class SegmentTree {\n\n            private static int getSize(int _n) {\n                int n = 1;\n                while (n < _n) {\n                    n *= 2;\n                }\n                return n;\n            }\n\n            private final int n;\n\n            private final int[] dat;\n\n            public SegmentTree(int _n) {\n                n = getSize(_n);\n                dat = new int[(n - 1) + n];// tree(n - 1) + raw (n)\n                Arrays.fill(dat, Integer.MAX_VALUE);\n            }\n\n            public void update(int k, int a) {\n                k += n - 1;\n                dat[k] = a;\n                while (k > 0) {\n                    k = (k - 1) / 2;\n                    dat[k] = Math.min(dat[k * 2 + 1], dat[k * 2 + 2]);\n                }\n            }\n\n            public int query(int a, int b) {\n                return query(a, b, 0, 0, n);\n            }\n\n            private int query(int a, int b, int k, int l, int r) {\n                if (r <= a || b <= l) {\n                    return Integer.MAX_VALUE;\n                }\n                if (a <= l && r <= b) {\n                    return dat[k];\n                }\n                int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n                int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(vl, vr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 31) - 1\n\n### main\n\nloop do\n  r, c, q = gets.split.map(&:to_i)\n  break if (r | c | q) == 0\n\n  mtx = r.times.map{gets.split.map(&:to_i)}\n  #p mtx\n\n  q.times do\n    r0, c0, r1, c1 = gets.split.map(&:to_i)\n    #p [r0, c0, r1, c1]\n\n    min_g = MAX_INT\n\n    for r in (r0..r1)\n      gs = mtx[r]\n      for c in (c0..c1)\n        g = gs[c]\n        min_g = g if min_g > g\n      end\n    end\n\n    puts min_g\n  end\nend"
  },
  {
    "language": "Python",
    "code": "from math import inf\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    # update (mk, nk) value to a\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            # update only if a is smaller here! otherwise this overwrites.\n            if a >= self.dat[mk].get(nk):\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        # ?°????????????????????´???°???2???????????????\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        # ??????????????????INT_MAX???\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    # k????????????(0-indexed)???a????????´\n    def update(self, k, a):\n        # ????????????\n        k += self.n - 1\n        self.dat[k] = a\n        # ?????????????????´??°\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    # [a, b)???????°????????±???????\n    # ???????????????????????°???????¨????????°?????????????????????°???\n    # k?????????????????????l, r??????????????????[l, r)???????????\\?????????????????¨?????¨??????\n    # ???????????£??????????????????query(a, b, 0, 0, n)??¨???????????¶???\n    def __query(self, a, b, k, l, r):\n        # [a, b)??¨[l, r)???????????????????????°???INT_MAX\n        if r <= a or b <= l:\n            return inf\n        # [a, b)???[l, r)????????¨???????????§????????°?????????????????????\n        if a <= l and r <= b:\n            return self.dat[k]\n        # ????????§???????????°???2????????????????°????\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\nwhile True:\n    r, c, q = map(int, input().split())\n    if (r, c, q) == (0, 0, 0):\n        break\n    rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n    for i in range(1, r + 1):\n        rc[i] = [0] + [int(cj) for cj in input().split()]\n\n    st2 = segt2d(r, c)\n    for i in range(1, r + 1):\n        for j in range(1, c + 1):\n            st2.update(i - 1, j - 1, rc[i][j])\n\n    for qi in range(q):\n        r1, c1, r2, c2 = map(int, input().split())\n        ans = st2.query(r1, r2 + 1, c1, c2 + 1)\n        print(ans)"
  },
  {
    "language": "Python",
    "code": "# from math import inf  # not supported in Python 3.4.2 hmmmmmmm\ninf = float('inf')\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            if a >= self.dat[mk].get(nk):  # this\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    def update(self, k, a):\n        k += self.n - 1\n        self.dat[k] = a\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    def __query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return inf\n        if a <= l and r <= b:\n            return self.dat[k]\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\nwhile True:\n    r, c, q = map(int, input().split())\n    if (r, c, q) == (0, 0, 0):\n        break\n    rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n    for i in range(1, r + 1):\n        rc[i] = [0] + [int(cj) for cj in input().split()]\n\n    st2 = segt2d(r, c)\n    for i in range(1, r + 1):\n        for j in range(1, c + 1):\n            st2.update(i - 1, j - 1, rc[i][j])\n\n    # st2.show()\n    ans = [None] * q\n    for qi in range(q):\n        r1, c1, r2, c2 = map(int, input().split())\n        ans[qi] = str(st2.query(r1, r2 + 1, c1, c2 + 1))\n    print('\\n'.join(ans))"
  },
  {
    "language": "Python",
    "code": "from math import inf\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            if a >= self.dat[mk].get(nk):\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    def update(self, k, a):\n        k += self.n - 1\n        self.dat[k] = a\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    def __query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return inf\n        if a <= l and r <= b:\n            return self.dat[k]\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\nwhile True:\n    r, c, q = map(int, input().split())\n    if (r, c, q) == (0, 0, 0):\n        break\n    rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n    for i in range(1, r + 1):\n        rc[i] = [0] + [int(cj) for cj in input().split()]\n\n    st2 = segt2d(r, c)\n    for i in range(1, r + 1):\n        for j in range(1, c + 1):\n            st2.update(i - 1, j - 1, rc[i][j])\n\n    for qi in range(q):\n        r1, c1, r2, c2 = map(int, input().split())\n        ans = st2.query(r1, r2 + 1, c1, c2 + 1)\n        print(ans)"
  },
  {
    "language": "Python",
    "code": "from math import inf\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    # update (mk, nk) value to a\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            # update only if a is smaller here! otherwise this overwrites.\n            if a >= self.dat[mk].get(nk):\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        # ?°????????????????????´???°???2???????????????\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        # ??????????????????INT_MAX???\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    # k????????????(0-indexed)???a????????´\n    def update(self, k, a):\n        # ????????????\n        k += self.n - 1\n        self.dat[k] = a\n        # ?????????????????´??°\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    # [a, b)???????°????????±???????\n    # ???????????????????????°???????¨????????°?????????????????????°???\n    # k?????????????????????l, r??????????????????[l, r)???????????\\?????????????????¨?????¨??????\n    # ???????????£??????????????????query(a, b, 0, 0, n)??¨???????????¶???\n    def __query(self, a, b, k, l, r):\n        # [a, b)??¨[l, r)???????????????????????°???INT_MAX\n        if r <= a or b <= l:\n            return inf\n        # [a, b)???[l, r)????????¨???????????§????????°?????????????????????\n        if a <= l and r <= b:\n            return self.dat[k]\n        # ????????§???????????°???2????????????????°????\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\ndef solve():\n    while True:\n        r, c, q = map(int, input().split())\n        if (r, c, q) == (0, 0, 0):\n            break\n        rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n        for i in range(1, r + 1):\n            rc[i] = [0] + [int(cj) for cj in input().split()]\n\n        st2 = segt2d(r, c)\n        for i in range(1, r + 1):\n            for j in range(1, c + 1):\n                st2.update(i - 1, j - 1, rc[i][j])\n\n        for qi in range(q):\n            r1, c1, r2, c2 = map(int, input().split())\n            ans = st2.query(r1, r2 + 1, c1, c2 + 1)\n            print(ans)\n\n\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "from math import inf\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            if a >= self.dat[mk].get(nk):\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    def update(self, k, a):\n        k += self.n - 1\n        self.dat[k] = a\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    def __query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return inf\n        if a <= l and r <= b:\n            return self.dat[k]\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\nwhile True:\n    r, c, q = map(int, input().split())\n    if (r, c, q) == (0, 0, 0):\n        break\n    rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n    for i in range(1, r + 1):\n        rc[i] = [0] + [int(cj) for cj in input().split()]\n\n    st2 = segt2d(r, c)\n    for i in range(1, r + 1):\n        for j in range(1, c + 1):\n            st2.update(i - 1, j - 1, rc[i][j])\n\n    for qi in range(q):\n        r1, c1, r2, c2 = map(int, input().split())\n        ans = st2.query(r1, r2 + 1, c1, c2 + 1)\n        print(ans)"
  },
  {
    "language": "Python",
    "code": "# from math import inf  # not supported in Python 3.4.2 hmmmmmmm\ninf = float('inf')\n\n\nclass segt2d:\n    def __init__(self, m, n):\n        self.m = 1\n        while self.m < m:\n            self.m *= 2\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [segt(n) for _ in range(2 * self.m - 1)]\n\n    def update(self, mk, nk, a):\n        mk += self.m - 1\n        self.dat[mk].update(nk, a)\n        while mk > 0:\n            mk = (mk - 1) // 2\n            if a >= self.dat[mk].get(nk):\n                break\n            self.dat[mk].update(nk, a)\n\n    def query(self, ma, mb, na, nb):\n        return self.__query(ma, mb, na, nb, 0, 0, self.m)\n\n    def __query(self, ma, mb, na, nb, mk, ml, mr):\n        if mr <= ma or mb <= ml:\n            return inf\n        if ma <= ml and mr <= mb:\n            return self.dat[mk].query(na, nb)\n        vl = self.__query(ma, mb, na, nb, mk * 2 + 1, ml, (ml + mr) // 2)\n        vr = self.__query(ma, mb, na, nb, mk * 2 + 2, (ml + mr) // 2, mr)\n        return min(vl, vr)\n\n    def show(self):\n        for d in self.dat:\n            print(d.dat)\n\n\nclass segt:\n    def __init__(self, n):\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.dat = [inf for _ in range(2 * self.n - 1)]\n\n    def update(self, k, a):\n        k += self.n - 1\n        self.dat[k] = a\n        while k > 0:\n            k = (k - 1) // 2\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2])\n\n    def query(self, a, b):\n        return self.__query(a, b, 0, 0, self.n)\n\n    def __query(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return inf\n        if a <= l and r <= b:\n            return self.dat[k]\n        vl = self.__query(a, b, k * 2 + 1, l, (l + r) // 2)\n        vr = self.__query(a, b, k * 2 + 2, (l + r) // 2, r)\n        return min(vl, vr)\n\n    def get(self, k):\n        k += self.n - 1\n        return self.dat[k]\n\n\nwhile True:\n    r, c, q = map(int, input().split())\n    if (r, c, q) == (0, 0, 0):\n        break\n    rc = [[0 for _ in range(c + 1)]] + [None for _ in range(r)]\n    for i in range(1, r + 1):\n        rc[i] = [0] + [int(cj) for cj in input().split()]\n\n    st2 = segt2d(r, c)\n    for i in range(1, r + 1):\n        for j in range(1, c + 1):\n            st2.update(i - 1, j - 1, rc[i][j])\n\n    # st2.show()\n    for qi in range(q):\n        r1, c1, r2, c2 = map(int, input().split())\n        ans = st2.query(r1, r2 + 1, c1, c2 + 1)\n        print(ans)"
  }
]