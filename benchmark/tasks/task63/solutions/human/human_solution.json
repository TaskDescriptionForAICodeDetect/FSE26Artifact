[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  val DIRS = Array(\"R\",\"D\",\"L\",\"U\")\n  val tox = Array(1,0,-1,0)\n  val toy = Array(0,1,0,-1)\n\n  def f(x:Int,y:Int,d:Int,v:Array[String],h:Array[String]):(Int,Int,Int,String) = {\n    val path = d match {\n          case 3 => v(y-1)(x)\n          case 0 => h(y)(x)\n          case 1 => v(y)(x)\n          case 2 => h(y)(x-1)\n          case _ => '0'\n    }\n    if(path == '1') (tox(d),toy(d),d,DIRS(d)) else f(x,y,(d+1)%4,v,h)\n  }\n\n\n  def getPath(x:Int,y:Int,d:Int,s:String,v:Array[String],h:Array[String]):String = {\n    if(x==1 && y==1) s\n    else {\n      val (x2,y2,d2,s2) = f(x,y,(d+3)%4,v,h)\n      getPath(x+x2,y+y2,d2,s+s2,v,h)\n    }\n  }\n\n  def main(args:Array[String]) = {\n    val v = new ArrayBuffer[String]\n    val h = new ArrayBuffer[String]\n\n    h += \"0\"*6; v += \"0\"*7\n    for(i<-1 to 4) { h += \"0\"+readLine.trim+\"0\"; v += \"0\"+readLine.trim+\"0\" }\n    h += \"0\"+readLine.trim+\"0\"\n    v += \"0\"*7; h += \"0\"*6\n\n    println(getPath(2,1,0,\"R\",v.toArray,h.toArray))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  val DIRS = Array(\"R\",\"D\",\"L\",\"U\")\n  val tox = Array(1,0,-1,0)\n  val toy = Array(0,1,0,-1)\n\n  def f(x:Int,y:Int,d:Int,v:Array[String],h:Array[String]):(Int,Int,Int,String) = {\n    val path = d match {\n          case 3 => v(y-1)(x)\n          case 0 => h(y)(x)\n          case 1 => v(y)(x)\n          case 2 => h(y)(x-1)\n          case _ => '0'\n    }\n    if(path == '1') (tox(d),toy(d),d,DIRS(d)) else f(x,y,(d+1)%4,v,h)\n  }\n\n\n  def getPath(x:Int,y:Int,d:Int,s:String,v:Array[String],h:Array[String]):String = {\n    if(x==1 && y==1) s\n    else {\n      val (x2,y2,d2,s2) = f(x,y,(d+3)%4,v,h)\n      getPath(x+x2,y+y2,d2,s+s2,v,h)\n    }\n  }\n\n  def main(args:Array[String]) = {\n    val v = new ArrayBuffer[String]\n    val h = new ArrayBuffer[String]\n\n    h += \"0\"*6; v += \"0\"*7\n    for(i<-1 to 4) { h += \"0\"+readLine.trim+\"0\"; v += \"0\"+readLine.trim+\"0\" }\n    h += \"0\"+readLine.trim+\"0\"\n    v += \"0\"*7; h += \"0\"*6\n\n    println(getPath(2,1,0,\"\",v.toArray,h.toArray))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.readLine\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main {\n  val DIRS = Array(\"R\",\"D\",\"L\",\"U\")\n  val tox = Array(1,0,-1,0)\n  val toy = Array(0,1,0,-1)\n\n  def f(x:Int,y:Int,d:Int,v:Array[String],h:Array[String]):(Int,Int,Int,String) = {\n    val path = d match {\n          case 3 => v(y-1)(x)\n          case 0 => h(y)(x)\n          case 1 => v(y)(x)\n          case 2 => h(y)(x-1)\n          case _ => '0'\n    }\n    if(path == '1') (tox(d),toy(d),d,DIRS(d)) else f(x,y,(d+1)%4,v,h)\n  }\n\n\n  def getPath(x:Int,y:Int,d:Int,s:String,v:Array[String],h:Array[String]):String = {\n    if(x==1 && y==1) s\n    else {\n      val (x2,y2,d2,s2) = f(x,y,(d+3)%4,v,h)\n      getPath(x+x2,y+y2,d2,s+s2,v,h)\n    }\n  }\n\n  def main(args:Array[String]) = {\n    val v = new ArrayBuffer[String]\n    val h = new ArrayBuffer[String]\n\n    h += \"0\"*6; v += \"0\"*7\n    for(i<-1 to 4) { h += \"0\"+readLine.trim+\"0\"; v += \"0\"+readLine.trim+\"0\" }\n    h += \"0\"+readLine.trim+\"0\"\n    v += \"0\"*7; h += \"0\"*6\n\n    println(getPath(2,1,0,\"R\",v.toArray,h.toArray))\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse if(v[y][x]=='0') xyf*=-1;\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n\telse if(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse if(v[y][x]=='0') xyf*=-1;\n\telse{\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse if(h[y][x-1]=='0') xyf*=-1;\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse if(h[y][x]=='0') xyf*=-1;\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define RIGHT 1\n#define LEFT -1\n#define UP 2\n#define DOWN -2\nusing namespace std;\n\nint main(){\n\tint i,j,state,sy=0,sx=1,t_state;\n\tchar row[5][4],col[4][5];\n\n\tcin>>row[0];\n\tfor(i=0;i<4;i++){\n\t\tcin>>col[i];\n\t\tcin>>row[i+1];\n\t}\n\n\tfor(i=0;i<5;i++){\n\t\tfor(j=0;j<4;j++){\n\t\t\trow[i][j]=row[i][j]-'0';\n\t\t}\n\t}\n\tfor(i=0;i<5;i++){\n\t\tfor(j=0;j<4;j++){\n\t\t\tcol[j][i]=col[j][i]-'0';\n\t\t}\n\t}\n\n\tcout<<\"R\"<<flush;\n\tstate=RIGHT;\n\twhile(sy || sx){\n\t\tswitch(state){\n\t\t\tcase RIGHT:\n\t\t\t\tif(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}else if(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}else if(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}else if(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}else if(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}else if(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}else if(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}else if(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}else if(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tstate=t_state;\n\t}\n\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef vector <string> vs;\n\nstruct pos{\n\tint x;\n\tint y;\n};\n\nvs wx,wy;\n\nint readdata(){\n\tstring tmp;\n\tbool f=true;\n\twhile (true){\n\t\tgetline(cin,tmp);\n\t\tif (cin.eof()) break;\n\t\tif (f) wx.push_back(tmp);\n\t\telse wy.push_back(tmp);\n\t\tf = !f;\n\t}\n\treturn 0;\n}\n\nbool ispath(pos p, int d){\n\tstring c=\"\";\n\tswitch (d){\n\t\tcase 0:\n\t\t\tif (p.y>0) c=wy[p.y-1][p.x];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (p.x<(int)wy.size()) c=wx[p.y][p.x];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (p.y<(int)wx[0].size()) c=wy[p.y][p.x];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (p.x>0) c=wx[p.y][p.x-1];\n\t};\n\treturn c==\"1\";\n}\n\nint nextpath(pos p, int d0){\n\tconst int N=4, dd[N]={3,0,1,2};\n\tint d = -1;\n\tfor (int i=0; i<N; i++){\n\t\td = (d0+dd[i])%4;\n\t\tif (ispath(p, d)) return d;\n\t}\n\treturn d;\n}\n\nstring f0037(){\n\tpos p;\n\tp.x=0; p.y=0;\n\tint dp=1, dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\tstring msg=\"\", news=\"URDL\";\n\twhile (true){\n\t\tdp = nextpath(p, dp);\n\t\tp.x += dx[dp];\n\t\tp.y += dy[dp];\n\t\tmsg += news[dp];\n\t\tif (p.x==0 && p.y==0) break;\n\t}\n\treturn msg;\n}\n\nint main(void){\n\treaddata();\n\tcout<<f0037()<<endl;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint main() {\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,-1,0,1};\n\n  bool yoko[4][5];\n  bool tate[5][4];\n  REP(i,9) {\n    char x;\n    if (i%2==0)\n      REP(j,4) {\n        cin >> x;\n        yoko[j][i/2] = (x=='1');\n      }\n    else\n      REP(j,5) {\n        cin >> x;\n        tate[j][i/2] = (x=='1');\n      }\n  }\n  int x=0,y=0;\n  int dir = 0;\n  char ss[4] = {'R','U','L','D'};\n  x++;\n  while(true) {\n    cout << ss[dir];\n    if (x==0&&y==0) break;\n    if (dir == 0) {\n      if (y>0&&tate[x][y-1]) {\n        dir = 1;\n        y--;\n      } else if (x<4&&yoko[x][y]) {\n        x++;\n      } else if (y<4&&tate[x][y]) {\n        dir = 3;\n        y++;\n      }\n    } else if (dir == 1) {\n      if (x>0&&yoko[x-1][y]) {\n        dir = 2;\n        x--;\n      } else if (y>0&&tate[x][y-1]) {\n        y--;\n      } else if (x<4&&yoko[x][y]) {\n        dir = 0;\n        x++;\n      }\n    } else if (dir == 2) {\n      if (y<4&&tate[x][y]) {\n        dir = 3;\n        y++;\n      } else if (x>0&&yoko[x-1][y]) {\n        x--;\n      } else if (y>0&&tate[x][y-1]) {\n        dir = 1;\n        y--;\n      }\n    } else if (dir == 3) {\n      if (x<4&&yoko[x][y]) {\n        dir = 0;\n        x++;\n      } else if (y<4&&tate[x][y]) {\n        y++;\n      } else if (x>0&&yoko[x-1][y]) {\n        dir = 2;\n        x--;\n      }\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include<math.h>\n#include<iomanip>\n#include<stdio.h>\n#include <stdlib.h>  \n#include<map>\n#include<set>\nusing namespace std;\n\nint main(){\n\tbool f[13][13]={};\n\tint TT[15][15]={};\n\tstring p,q;\n\tfor(int i=1;i<=4;i++){\n\t\tcin>>p>>q;\n\t\tfor(int j=0;j<p.size();j++)\n\t\t\tif(p[j]=='1')f[2*i-1][j+1]=1;\n\t\tfor(int j=0;j<q.size();j++)\n\t\t\tif(q[j]=='1')f[i*2][j+1]=1;\n\t}\n\tcin>>p;\n\t\tfor(int j=0;j<p.size();j++)\n\t\t\tif(p[j]=='1')f[9][j+1]=1;\n\t/*for(int i=0;i<=10;i++){\n\t\tfor(int j=0;j<=5;j++)\n\t\t\tcout<<f[i][j];\n\t\tcout<<endl;\n\t}*/\n\tint x=1,y=1;\n\tchar z='R';int v=0;\n\twhile(1){\n\t\tif(z=='R'){\n\t\t\tif(f[y-1][x]){\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t\telse if(f[y][x]){\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t}\n\t\telse if(z=='L'){\n\t\t\tif(f[y+1][x]){\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t\telse if(f[y][x-1]){\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t}\n\n\t\telse if(z=='U'){\n\t\t\tif(f[y][x-1]){\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t\telse if(f[y-1][x]){\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t}\n\t\telse if(z=='D'){\n\t\t\tif(f[y][x]){\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t\telse if(f[y+1][x]){\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t}\n\t\tif(x==1&&y==1)break;\n\t\tv++;\n\t\t//if(v>30)break;\n\t\t//cout<<x<<\" \"<<y<<\"#\"<<v<<endl;\n\t\tTT[y][x]=v;\n\t}/*\n\tfor(int i=0;i<=10;i++){\n\t\tfor(int j=0;j<=5;j++)\n\t\t\tcout<<TT[i][j];\n\t\tcout<<endl;\n\t}\n\t*/\n\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 10\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool wall[4][MAX][MAX];\n\nvoid print(int d) {\n  switch(d) {\n  case 0: cout<<\"L\"; break;\n  case 1: cout<<\"U\"; break;\n  case 2: cout<<\"R\"; break;\n  case 3: cout<<\"D\"; break;\n  }\n}\n\nint main() {\n  \n  char ch;\n  for(int i=0; i<5; i++) {\n    for(int j=0; j<4; j++) {\n      cin >> ch;\n      wall[3][i][j+1] = wall[1][i+1][j+1] = 1;\n    }\n    if(i<4) {\n      for(int j=0; j<5; j++) {\n\tcin >> ch;\n\twall[2][i+1][j] = wall[0][i+1][j+1] = 1;\n      }\n    }\n  }\n  \n  bool start = 0;\n  int x = 1, y = 0;\n  int d = 2;\n  while( !(x == 1 && y == 0 && start) ) {\n    start = 1;\n    \n    x += dx[d], y += dy[d]; print(d);\n    \n    if(!wall[d][y][x]) {\n      d = (d + 1) % 4;\n      x += dx[d], y += dy[d]; print(d);\n    }\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nint main() {\n\tvector<string>sts;\n\tstring st;\n\twhile (cin >> st) {\n\t\tsts.emplace_back(st);\n\t}\n\tint asize = sts.size() / 2 + 4;\n\tvector<vector<vector<int>>>walls(asize, vector<vector<int>>(asize, vector<int>(4)));\n\tfor (int i = 0; i < sts.size() / 2+1; ++i) {\n\t\tfor (int j = 0; j < sts[2*i].size(); ++j) {\n\t\t\tint num = sts[2*i][j] == '1';\n\t\t\twalls[i+1][j+2][1] = num;\n\t\t\twalls[i + 2][j + 2][3] = num;\n\t\t}\n\t}\n\tfor (int i = 0; i < sts.size() / 2; ++i) {\n\t\tfor (int j = 0; j < sts[2 * i+1].size(); ++j) {\n\t\t\tint num = sts[2 * i+1][j] == '1';\n\t\t\twalls[i +2][j+1][2] = num;\n\t\t\twalls[i + 2][j + 2][0] = num;\n\t\t}\n\t}\n\tvector<int>ways;\n\tint nway = 2;\n\tint nx = 2;\n\tint ny = 1;\n\twhile (1) {\n\t\tassert(walls[ny][nx][(nway +3) % 4]);\n\t\tif (walls[ny][nx][nway]) {\n\t\t\tways.emplace_back(nway);\n\t\t\tnway = (nway + 1) % 4;\n\t\t}\n\t\telse if (walls[ny + dy[nway]][nx + dx[nway]][(nway + 3) % 4]) {\n\t\t\tways.emplace_back(nway);\n\t\t\tny += dy[nway];\n\t\t\tnx += dx[nway];\n\n\t\t\tif (ny == 1 && nx == 2)break;\n\t\t}\n\t\telse if (walls[ny + dy[nway] + dy[(nway + 3) % 4]][nx + dx[nway] + dx[(nway + 3) % 4]][(nway + 2) % 4]) {\n\t\t\tways.emplace_back(nway);\n\t\t\t//ways.emplace_back((nway + 3) % 4);\n\t\t\tny += dy[nway] + dy[(nway + 3) % 4];\n\t\t\tnx += dx[nway] + dx[(nway + 3) % 4];\n\t\t\tnway = (nway + 3) % 4;\n\t\t\tif (ny == 1 && nx == 2)break;\n\t\t}\n\t\telse {\n\t\t\tways.emplace_back(nway);\n\t\t\t//ways.emplace_back((nway + 3) % 4);\n\t\t\t//ways.emplace_back((nway + 2) % 4);\n\t\t\tny += dy[(nway + 3) % 4];\n\t\t\tnx += dx[(nway + 3) % 4];\n\t\t\tnway = (nway + 2) % 4;\n\t\t\tif (ny == 1 && nx == 2)break;\n\t\t}\n\t\tif (nx == 2 && ny == 1)break;\n\t}\n\tstring mp;\n\tmp = \"LDRU\";\n\tfor (auto w : ways) {\n\t\tcout << mp[w];\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char d[4] = {'L','U','R','D'};\n \nint main(){\n  char ch;\n  bool G[6][6][4];\n  memset(G,false,sizeof(G));\n  for(int i = 0 ; i < 9 ; i++){\n    int d = i%2;\n    for(int j = 0 ; j < 4+d ; j++){\n      cin >> ch;\n      if(ch == '1'){\n        if(d%2){\n          G[i/2+1][j][2] = G[i/2+1][j+1][0] = true;\n        }else{\n          G[i/2][j+1][3] = G[i/2+1][j+1][1] = true;\n        }\n      }\n    }\n  }\n  int x = 1,y = 0,dir = 2;\n  string ans;\n  while(true){\n    if(!x && !y) break;\n    ans += d[dir];\n    int rh = (dir+1)%4;\n    if(G[y][x][dir]){\n      dir--;\n      dir = (dir == -1 ? 3 : dir);\n    }else if(!G[y+dy[dir]][x+dx[dir]][rh]){\n      x += dx[dir], y += dy[dir];\n      if(!x && !y) break;\n      x += dx[rh], y += dy[rh];\n      dir = rh;\n      int nrh = (rh+1)%4;\n      if(!G[y][x][nrh] && !(!x && !y)){\n        x += dx[nrh], y += dy[nrh];\n        dir = nrh;\n      }\n    }else{\n      x += dx[dir]; y += dy[dir];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nint main(){\n    bool w[5][5][4]={};\n    \n    char a;\n    \n    rep(i,5){\n        rep(j,4){\n            cin>>a;\n            w[i  ][j  ][0] = a-'0';\n            w[i  ][j+1][2] = a-'0';\n        }\n        if(i==4)continue;\n        \n        rep(j,5){\n            cin>>a;\n            w[i  ][j  ][1] = a-'0';\n            w[i+1][j  ][3] = a-'0';\n        }\n    }\n    \n    assert(w[0][0][0]);\n    \n    int py = 0, px = 0;\n    int dir = 0;\n    \n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    \n    string ans = \"\";\n    string ch[] = {\"R\", \"D\", \"L\", \"U\"};\n    do{\n        for(int i=-1;i<=2;i++){\n            int nd = ( dir+i+4 )%4;\n            if( w[py][px][nd] ){\n                ans += ch[nd];\n                py += dy[nd];\n                px += dx[nd];\n                dir = nd;\n                break;\n            }\n        }\n    }while( py!=0 || px!=0 );\n    \n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\n\nvoid dfs( int dir, int x, int y ) {\n    // cout << dir << \", \" << x << \", \" << y << endl;\n    cout << D[dir];\n    if ( dir != RIGHT && x == 0 && y == 0 ) return;\n\n    if ( dir == RIGHT ) {\n        if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n            return dfs( UP, x+1, y-1 );\n        }\n        if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n            return dfs( RIGHT, x+1, y );\n        }\n        if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n            return dfs( DOWN, x+1, y+1 );\n        }\n    } else if ( dir == DOWN ) {\n        if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n            return dfs( RIGHT, x, y+1 );\n        }\n        if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n            return dfs( DOWN, x, y+2 );\n        }\n        if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y+1 );\n        }\n    } else if ( dir == LEFT ) {\n        if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n            return dfs( DOWN, x, y+1 );\n        }\n        if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y );\n        }\n        if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n            return dfs( UP, x, y-1 );\n        }\n    } else if ( dir == UP ) {\n        if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y-1 );\n        }\n        if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n            return dfs( UP, x, y-2 );\n        }\n        if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n            return dfs( RIGHT, x, y-1 );\n        }\n    }\n}\n\nint main() {\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\t//while(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\t//memset(yoko,0,sizeof(yoko));\n\t\t//memset(tate,0,sizeof(tate));\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c;\n\t\t\t}\n\t\t\tif(i!=4){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin>>c;\n\t\t\t\t\ttate[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\tstring str=\"\";\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tstr+='R';\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tstr+='D';\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tstr+='L';\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tstr+='U';\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0){\n\t\t\t\tbreak;\n\t\t\t}\n}\n\n//cout<<str<<endl;\n//break;\n\n//}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 1;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 0){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&1){t = 3;}\n\telse{y--;}\n      }\n      else{x++;t = 1;}\n    }\n    else if(t == 1){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&2){t = 0;}\n\telse{x++;}\n      }\n      else{y++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&4){t = 1;}\n\telse{y++;}\n      }\n      else{x--;t = 3;}\n    }\n    else if(t == 3){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&8){t = 2;}\n\telse{x--;}\n      }\n      else{y--;t = 0;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nusing namespace std;\ntypedef long long  ll;\n\n/** Problem0037 : Path on a Grid **/\nint main()\n{\n\tstring s, ds=\"LRUD\";\n\tbool grid[5][5][4]={0};\n\tint y=0;\n\trep(k, 9) {\n\t\tcin>>s;\n\t\tif (k%2==0) {\n\t\t\tfor (int i=0; i<4; i++) {\n\t\t\t\tif (s[i] == '1') {\n\t\t\t\t\tgrid[i][y][1]=true;\n\t\t\t\t\tgrid[i+1][y][0]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i=0; i<5; i++) {\n\t\t\t\tif (s[i] == '1') {\n\t\t\t\t\tgrid[i][y][3]=true;\n\t\t\t\t\tgrid[i][y+1][2]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty++;\n\t\t}\n\t}\n\tint d=1, x=0; y=0;\n\twhile (1) {\n\t\tswitch (d) {\n\t\t\tcase 1:\n\t\t\t\tif (grid[x][y][2]) {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else if (grid[x][y][1]) {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else if (grid[x][y][3]) {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (grid[x][y][1]) {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else if (grid[x][y][3]) {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else if (grid[x][y][0]) {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 0:\n\t\t\t\tif (grid[x][y][3]) {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else if (grid[x][y][0]) {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else if (grid[x][y][2]) {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (grid[x][y][0]) {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else if (grid[x][y][2]) {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else if (grid[x][y][1]) {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} break;\n\t\t}\n\t\tif (x==0 && y==0)\n\t\t\tbreak;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>///////AOJ0037\n                            int\n                            w[5\n       ][5],i,j;char(b)[    128\n       ],*           p;F    (//\n       int           v){    for\n       (i=    scanf(\"%s\"    ,b)\n       -1,    p=b    ;*p    ;++\n       p){    w[p    -b+    1-v\n       ][j    +v]|=((w[p    -b]\n       [j]                  |=(\n       p[0                  ]==\n       49)<<3-v)&8>>v)>>2;}j+=v\n\n     ;}\n    main\n  (){  for\n (;F     (0)\n,j-       4;F\n(1));for(p=b,\nj=(       *b=\n3)^       3;i        +=-66+\"BAB\\\nC\"[       *b]      ,j+=       \"?\\\n@A\"       \"@\"      [*b        ]-(\n                   1<<        6),*\n                   ++p        =(*\n                   b)[        \"U\"\n                   \"L\"        \"D\"\n                   \"R\"        ],i\n                    +j;)for((++*\n  b)&=~4;!((1<<*\n         b)&\n         w[i\n         ][j\n]);      (*b\n+=3      )&=\n~4)     ;re\\\nturn   !puts\n  (b+1);}\n\n"
  },
  {
    "language": "C++",
    "code": "// 今向いている方向にとっての左から始めて、時計回りに壁を探して、最初にみつけた壁の方向に進む\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct Direction {\n  bool u, d, r, l;\n};\n\nvoid dump_Direction(Direction di) {\n  cout << \"[\" << di.u << di.r << di.d << di.l << \"]\";\n}\n\n\n\nint main() {\n  // ifstream cin(\"../test.txt\");\n  Direction g[5][5];\n  string s;\n  for (int i = 0; i < 9; i++) {\n    getline(cin, s);\n    if (i % 2 == 0) {\n      for (int j = 0; j < 4; j++) {\n        int k = i / 2;\n        g[k][j].r = (s[j] == '1');\n        g[k][j+1].l = (s[j] == '1');\n      }\n    } else {\n      for (int j = 0; j < 5; j++) {\n        int k = i / 2;\n        g[k][j].d = (s[j] == '1');\n        g[k+1][j].u = (s[j] == '1');\n      }\n    }\n  }\n  // 表示用\n  // for (int i = 0; i < 5; i++) {\n  //   for (int  j = 0; j < 5; j++) {\n  //     dump_Direction(g[i][j]);\n  //   }\n  //   cout << endl;\n  // }\n\n  int x = 0;\n  int y = 0;\n  int d = 0; // 0: u, 1: r, 2: d, 3: l\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  char c[] = {'U','R','D','L'};\n  while (true) {\n    bool dir[] = {g[y][x].u, g[y][x].r, g[y][x].d, g[y][x].l};\n    // dump_Direction(g[y][x]);\n    int i = 0;\n    for (;i < 4; i++) {\n      if (dir[(i+d)%4]) break;\n    }\n    int j = (i+d)%4;\n    // cout << j;\n    x += dx[j];\n    y += dy[j];\n    cout << c[j];\n    d = (j + 3) % 4;\n    if (!(x|y)) break;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\n#define East  1\n#define South 2\n#define West  4\n#define North 8\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.pg\", \"r\", stdin);\n\tstring str = \"\";\n\tvector <string> grid;\n\tint maxlen = 0;\n\n\twhile (getline (cin, str ) ){\n\t\tif (str.empty() ){\n\t\t\tbreak;\n\t\t} // end if\n\t\tint len = str.length();\n\t\tmaxlen = max (maxlen, len );\n\t\tgrid.push_back(str );\n\t} // end while\n\n\tint size = grid.size();\n\tvector <vector <char> > room((size+1)/2+1, vector <char> (maxlen, 0 ) );\n\tint i,j,k;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < grid[i].length(); ++j){\n\t\t\tif (grid[i][j] == '1'){\n\t\t\t\tif (i % 2 == 0){\t// north or south wall\n\t\t\t\t\troom[i/2][j] |= South;\n\t\t\t\t}else{\t\t\t// east or west wall\n\t\t\t\t\troom[i/2+1][j-1] |= East;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tfor (i = 0; i < room.size(); ++i){\n\t\tfor (j = 0; j < room[i].size(); ++j){\n\t\t\tif (i == 0){\n\t\t\t\troom[i][j] |= North;\n\t\t\t}else if (i == room.size() - 1){\n\t\t\t\troom[i][j] |= South;\n\t\t\t} // end if\n\t\t\tif (i > 0 && room[i-1][j] & South){\n\t\t\t\troom[i][j] |= North;\n\t\t\t} // end if\n\t\t\tif (j == 0){\n\t\t\t\troom[i][j] |= West;\n\t\t\t}else if (j == room[i].size() - 1){\n\t\t\t\troom[i][j] |= East;\n\t\t\t} // end if\n\t\t\tif (j > 0 && room[i][j-1] & East){\n\t\t\t\troom[i][j] |= West;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint row = 0;\n\tint col = 0;\n\tint dir = East;\n\tint right_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n\tstring res = \"\";\n\tres += 'R';\n\tbool turn = false;\n\tint reach = 0;\n\n\tdo{\n\t\tif (turn || (right_hand & room[row][col]) ){\n\t\t\tturn = false;\n\t\t\t// go faword\n\t\t\tswitch (dir){\n\t\t\t\tcase East:\n\t\t\t\t\tif (!(room[row][col] & East)){ \n\t\t\t\t\t\t++col;// res += 'R';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = North;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\t\t\t\t\tif (!(room[row][col] & South)){\n\t\t\t\t\t \t++row;// res += 'D';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = East;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\t\t\t\t\tif (!(room[row][col] & West)){\n\t\t\t\t\t\t--col;// res += 'L';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = South;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase North:\n\t\t\t\t\tif (!(room[row][col] & North)){\n\t\t\t\t\t\t--row;// res += 'U';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = West;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if  \n\t\t\t\t\tbreak;\n\t\t\t} // end switch\n\t\t}else{ // if !(right_hand & room[row][col])\n\t\t\t// turn\n\t\t\tswitch (dir){\n\t\t\t\tcase East:  dir = South; break;\n\t\t\t\tcase South: dir = West; break;\n\t\t\t\tcase West:  dir = North; break;\n\t\t\t\tcase North: dir = East; break;\n\t\t\t} // end switch\n\t\t\tturn = true;\n\t\t} // end if\n\n\t\tright_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n\n\t\tif (row == 1 && col == 0){\n\t\t\t++reach;\n\t\t} // end if\n\n\t} while (reach < 3);\n\troom.clear();\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tstd::cout << 'R';\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && crd[1] == 0)\n\t\t{\n\t\t\tstd::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar const * direct_text[] = {\"R\", \"D\", \"L\", \"U\"};\n\nbool can_move(int a[10][6], int x, int y, int d)\n{\n    if ( (d == 0 && a[2*x-1][y  ] == 1) ||\n         (d == 1 && a[2*x  ][y  ] == 1) ||\n         (d == 2 && a[2*x-1][y-1] == 1) ||\n         (d == 3 && a[2*x-2][y  ] == 1) )\n        return 1;\n    else \n        return 0;\n}\n\nint main(void) {\n    int a[10][6] = {{}};\n    char c;\n\n    for (int i = 1; i <= 9; ++i)\n        for (int j = 1; j <= 5; ++j)\n            if (j <= 4 || i%2==0) {\n                cin >> c;\n                a[i][j] = c - '0';\n            }\n\n    int x = 1, y = 1, d = 0;\n\n    while (true) {\n        for (int i = 0; i < 4; ++i) {\n            if (can_move(a, x, y, (d+3+i)%4)) {\n                d = (d+3+i)%4;\n                if (d == 0)\n                    y += 1;\n                else if (d == 1)\n                    x += 1;\n                else if (d == 2)\n                    y -= 1;\n                else\n                    x -= 1;\n                cout << direct_text[d];\n                break;\n            }\n        }\n        if (x == 1 && y == 1)\n            break;\n    }\n    cout << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv=(v+loop[i])%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x==0&& y==0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst int INF = 1e9+7;\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define tr(c, i) for(auto i = (c).begin(); i != (c).end(); i++)\n#define rtr(c, i) for(auto i = (c).rbegin(); i != (c).rend(); i++)\n#define repab(i,a,b) for(auto i=a;i<(b);i++)\n#define rep(i,b) for(auto i=0;i<(b);i++)\n#define pb push_back\n#define sz(c) int((c).size())\n\nint main(int argc, char **argv)\n{\n  const int north = 0;\n  const int east  = 1;\n  const int south = 2;\n  const int west  = 3;\n  const vi xwall = { 0,  1, 0,  0};\n  const vi ywall = {-2, -1, 0, -1};\n  const vi xmove = { 0,  1, 0, -1};\n  const vi ymove = {-2,  0, 2,  0};\n  const vector<char> movec = {'U', 'R', 'D', 'L'};\n  const int mg = 2;\n  int fsz = 10;\n  int x, y;\n  vvi field(fsz+2*mg, vi(fsz+2*mg, 0));\n\n  x = y = mg;\n  for (;;) {\n    char c;\n    cin.get(c);\n    if (cin.eof())\n      break;\n    if (c == '\\n') {\n      x = mg;\n      y++;\n      continue;\n    }\n    field[x][y] = c-'0';\n    x++;\n  }\n\n\n  int step = 0;\n  int direction = east;\n  x = y = mg;\n  do {\n    int r = (direction + 1)%4;\n    do {\n      if (!field[x+xwall[r]][y+ywall[r]]) {\n        break;\n      }\n      r = (r+3)%4;\n    } while (r != (direction+1)%4);\n    cout << movec[r];\n    direction = r;\n    x = x + xmove[r];\n    y = y + ymove[r];\n  } while (x != mg || y != mg);\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {-1, 0, 1, 0};\n\nvoid print(int c){\n    if(c == 0) cout << \"L\";\n    else if(c == 1) cout << \"U\";\n    else if(c == 2) cout << \"R\";\n    else cout << \"D\";\n}\n\nint main(){\n\n\n    vector<vector<bool> > a(13, vector<bool> (13, true));\n    for(int i = 0; i < 13; i++){\n        a[i][0] = a[i][12] = false;\n    }\n\n    for(int j = 0; j < 13; j++){\n        a[0][j] = a[12][j] = false;\n    }\n\n    for(int i = 0; i < 9; i++){\n\n        if(i % 2 == 0){\n            int h = i + 2;\n            string s; cin >> s;\n            for(int j = 0; j < 4; j++){\n                int w = j * 2 + 3;\n                if(s[j] == '1'){\n                    a[h][w - 1] = false;\n                    a[h][w] = false;\n                    a[h][w + 1] = false;                    \n                }\n            }\n        }else{\n            int h = i + 2;\n            string s; cin >> s;\n            for(int j = 0; j < 5; j++){\n                int w = j * 2 + 2;\n                if(s[j] == '1'){\n                    a[h - 1][w] = false;\n                    a[h][w] = false;\n                    a[h + 1][w] = false;                    \n                }\n            }\n        }\n    }\n\n    /*for(int i = 0; i < 13; i++){\n        for(int j = 0; j < 13; j++){\n            cout << a[i][j];\n        }\n        cout << endl;\n    }*/\n\n    int s_k = 2;\n    int s_i = 2;\n    int s_j = 2;\n    int k = 2;\n    int i = 2;\n    int j = 2;\n    bool flag = false;\n    while(1){\n\n        if(flag && i == s_i && j == s_j) break;\n        \n        flag = true;\n        for(int h = 0; h < 4; h++){\n\n            int c = (k - 1 + 4 + h) % 4;\n            if(a[i + di[c]][j + dj[c]] == 0 && a[i + 2*di[c]][j + 2*dj[c]] == 0){\n                print(c);\n                i = i + 2*di[c];\n                j = j + 2*dj[c];\n                k = c;\n                break;\n            }\n\n        } \n    \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool t[222][222][4];\nint w,h,n,a[202][202];\nint seach(int x,int y,int d){\n \n  int turn =1,p=0;\n   \n  while(1){\n    if(!p){\n      if(d==3)cout<<'R';\n      if(d==2)cout<<'U';\n      if(d==1)cout<<'L';\n      if(d==0)cout<<'D';\n    }\n    p=0;\n\n    if(t[y][x][d])break;\n    t[y][x][d]=1;\n    if(d==0){\n        if(a[y+1][x]==1)d=3;\n    else if(a[y+2][x]==0){\n      if(a[y+2][x-1]==1)y+=2;\n      else d=1,y+=2,p++;\n    }\n \n    }\n    else if(d==1){\n        if(a[y][x-1]==1)d=0;\n    else if(a[y][x-2]==0){\n      if(a[y-1][x-2]==1)x-=2;\n      else d=2,x-=2,p++;\n    }\n \n    }\n    else if(d==2){\n        if(a[y-1][x]==1)d=1;\n    else if(a[y-2][x]==0){\n      if(a[y-2][x+1]==1)y-=2;\n      else d=3,y-=2,p++;\n    }\n \n    }\n    else if(d==3){\n        if(a[y][x+1]==1)d=2;\n    else if(a[y][x+2]==0){\n      if(a[y+1][x+2]==1)x+=2;\n      else d=0,x+=2,p++;\n    }\n \n      }\n\n  }\n}\nint main(){\n\n    memset(a,0,sizeof(a));\n\n    for(int i=0;i<9;i++){\n      string x;\n      cin>>x;\n      if(i%2){\n        for(int j=0;j<5;j++)if(x[j]=='1')\n          a[i+3][j*2+3]=1;\n      }\n      else{\n        for(int j=0;j<4;j++)if(x[j]=='1')\n          a[i+3][j*2+1+3]=1;\n      }\n    }\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++)\n        cout<<a[i][j];cout<<endl;\n    }\n    seach(4,2,3);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\nint cnt[100][100];\n\nvoid dfs( int dir, int x, int y, int a ) {\n    // cout << dir << \", \" << x << \", \" << y << endl;\n    cout << D[dir];\n    if ( x == 0 && y == 0 && cnt[y][x] > 1 ) return;\n    if ( x == 0 && y == 1 && dir == UP ) return;\n\n    if ( dir == RIGHT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 0 );\n            }\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 1 );\n            }\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 1 );\n            }\n        }\n    } else if ( dir == DOWN ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 0 );\n            }\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 1 );\n            }\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 1 );\n            }\n        }\n    } else if ( dir == LEFT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 0 );\n            }\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 0 );\n            }\n        } else {\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 1 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 0 );\n            }\n        }\n    } else if ( dir == UP ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 0 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 0 );\n            }\n        } else {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 1 );\n            }\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 0 );\n            }\n        }\n    }\n}\n\nint main() {\n    for ( int i = 0; i < 100; i++ ) {\n        for ( int j = 0; j < 100; j++ ) {\n            cnt[i][j] = 0;\n        }\n    }\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define X first\n#define Y second\n#define WIDTH 8\n#define HEIGHT 8\n\nusing namespace std;\n\nstruct point{\n\tpoint(int x = 0, int y = 0, char dir = 'R'):x(x), y(y), dir(dir){}\n\tint x;\n\tint y;\n\tchar dir;\n};\n\nchar moveMap(vector<string> &map, point &player){\n\tswitch(player.dir){\n\tcase 'R':\n\t\tif(player.y != 0 && map[player.y - 1][player.x + 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y][player.x + 1] == '1'){\n\t\t\tplayer.x += 1;\n\t\t}\n\t\telse if(player.y != 8 && map[player.y + 1][player.x + 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\tif(player.y != 8 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\telse if(player.x != 0 && map[player.y][player.x - 1] == '1'){\n\t\t\tplayer.x -= 1;\n\t\t}\n\t\telse if(player.y != 0 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\tbreak;\n\tcase 'U':\n\t\tif(player.x != 0 && map[player.y - 1][player.x - 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\telse if(player.y != 1 && map[player.y - 2][player.x] == '1'){\n\t\t\tplayer.y -= 2;\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tif(player.x != map[player.y].size() - 1 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\telse if(player.y != 7 && map[player.y + 2][player.x] == '1'){\n\t\t\tplayer.y += 2;\n\t\t}\n\t\telse if(player.x != 0 && map[player.y + 1][player.x - 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn player.dir;\n}\n\nint main(){\n\tstring tmp;\n\twhile(cin >> tmp){\n\t\tif(cin.eof()) break;\n\t\t\n\t\tvector<string> map;\n\t\tmap.push_back(tmp);\n\t\tfor(int i = 1; i < 9; i++){\n\t\t\tcin >> tmp;\n\t\t\tmap.push_back(tmp);\n\t\t}\n\n\t\tpoint player(0, 0, 'R');\n\t\tstring root;\n\t\troot.push_back('R');\n\t\t\n\t\twhile(1){\n\t\t\troot.push_back(moveMap(map, player));\n\t\t\tif(player.x == 0 && player.y == 0) break;\n\t\t}\n\n\t\tfor(int i = 0; i < root.size(); i++){\n\t\t\tcout << root[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[3000];\nint len;\nint fie[3001][3001];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else dir=(dir+1)%4;\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n\nint main(){\n\n\tint yoko[10][10];\n\tint tate[10][10];\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c-'0';\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\ttate[i][j]=c-'0';\n\t\t\t}\n\t\t}\n\t}\n\tcout<<'R';\n\tint cx=1;\n\tint cy=0;\n\n\t// 0:E,1:º,2:¶,3:ã\n\tint angle=0;\n\twhile(1){\n\t\tint nx=cx;\n\t\tint ny=cy;\n\t\tif(angle==0){\n\n\t\t\tnx=cx+1;\n\t\t\tny=cy;\n\t\t\tif(cy!=0&&tate[cy-1][cx]){\n\t\t\t\tangle=3;\n\t\t\t\tcy--;\n\t\t\t\tcout<<\"U\";\n\t\t\t}\n\t\t\t// Çª éÈç\n\t\t\telse if(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'R';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse if(tate[cy][cx]){\n\t\t\t\tangle=1;\n\t\t\t\tcout<<\"D\";\n\t\t\t\tcy++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tangle=2;\n\t\t\t\tcout<<\"L\";\n\t\t\t\tcx--;\n\t\t\t}\n\t\t}\n\t\telse if(angle==1){\n\t\t\tnx=cx;\n\t\t\tny=cy+1;\n\t\t\t// EÌÇðDæ\n\t\t\tif(cx!=4&&yoko[cy][cx]){\n\t\t\t\tcx++;\n\t\t\t\tcout<<\"R\";\n\t\t\t\tangle=0;\n\t\t\t}\n\t\t\t// Çª éÈç\n\t\t\telse if(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'D';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\t\t// ¶\n\t\t\telse if(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\tcx--;\n\t\t\t\tcout<<\"L\";\n\t\t\t\tangle=2;\n\t\t\t}\n\t\t\t// ÍñÄñ\n\t\t\telse{\n\t\t\t\tcy--;\n\t\t\t\tcout<<'U';\n\t\t\t\tangle=3;\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tnx=cx-1;\n\t\t\tny=cy;\n\t\t\t// ºÌÇªDæ\n\t\t\tif(cy!=4&&tate[cy][cx]){\n\t\t\t\tcout<<'D';\n\t\t\t\tcy++;\n\t\t\t\tangle=1;\n\t\t\t}\n\t\t\t// Çª éÈç\n\t\t\telse if(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx-1]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'L';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\t// ã\n\t\t\telse if(cy!=0&&tate[cy-1][cx]){\n\t\t\t\tcout<<'U';\n\t\t\t\tangle=3;\n\t\t\t\tcy--;\n\t\t\t}\n\t\t\t// ÍñÄñ\n\t\t\telse{\n\t\t\t\tcout<<'R';\n\t\t\t\tangle=0;\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tnx=cx;\n\t\t\tny=cy-1;\n\t\t\t// Çª éÈç\n\t\t\t// ¶ÌÇðDæ\n\t\t\tif(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\tcout<<'L';\n\t\t\t\tangle=2;\n\t\t\t\tcx--;\n\t\t\t}\n\t\t\telse if(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy-1][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'U';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\t// E\n\t\t\telse if(cx!=4&&yoko[cy][cx]){\n\t\t\t\tangle=0;\n\t\t\t\tcout<<'R';\n\t\t\t\tcx++;\n\t\t\t}\n\t\t\t// ÍñÄñ\n\t\t\telse{\n\t\t\t\tcout<<'D';\n\t\t\t\tcy++;\n\t\t\t\tangle=1;\n\t\t\t}\n\t   }\n\t\tif(cx==0&&cy==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nchar yoko[10][10];\nchar tate[10][10];\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin>>yoko[i][j];\n\t\t}\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tcin>>tate[i][j];\n\t\t}\n\t}\n\t// 0,1,2,3ÅEAºA¶Aã\n\tint angle=0;\n\tint px,py;\n\tpx=py=0;\n\twhile(1){\n\t\tif(angle==0){\n\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tpx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ãÖ\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx--;\n\t\t\t\t\tangle=2;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// º\n\t\telse if(angle==1){\n\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\tcout<<\"D\";\n\t\t\t\tpy++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tpx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\t// ãÖ\n\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx++;\n\t\t\t\t\tangle=2;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\tcout<<\"U\";\n\t\t\t\tpy--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(px==0&&py==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 5;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst char C[] = {'R','D','L','U'};\nint g[N][N];\n\nint main() {\n  fill(g[0], g[N], 0);\n  for(int s = 0; s < 2*N-1; ++s) {\n    for(int j = 0; j < N-1+s%2; ++j) {\n      int i = s/2;\n      char a;\n      cin >> a;\n      if(a == '1') {\n\tif(s%2 == 0) {\n\t  g[i][j] |= (1<<0);\n\t  g[i][j+1] |= (1<<2);\n\t} else {\n\t  g[i][j] |= (1<<1);\n\t  g[i+1][j] |= (1<<3);\n\t}\n      }\n    }\n  }\n\n  int i, j, d;\n  i = j = 0;\n  d = 0;\n  do {\n    for(int k = 0; k < 4; ++k) {\n      int nd = (d+3+k)%4;\n      if(g[i][j] & (1<<nd)) {\n\td = nd;\n\ti += di[d];\n\tj += dj[d];\n\tcout << C[d];\n\tbreak;\n      }\n    }\n  } while(!(i == 0 && j == 0));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 20;\n\nvoid printMaze(int w, int h, bool M[N][N], int x, int y){\n\trep(i,h + h + 1){\n\t\trep(j,w + w + 1){\n\t\t\tif(i == y and j == x) cout << \"*\";\n\t\t\telse cout << M[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid extensionOfMaze(int w, int h, bool M[N][N]){\n\tstring s[N];\n\trep(i,N) cin >> s[i];\n\n\trep(i,N) rep(j,N) M[i][j] = 0;\n\trep(i,h + h - 1){\n\t\tauto it = s[i].begin();\n\t\tif(i % 2 == 0){ //横線\n\t\t\tfor(int j = 0; j < w + w - 1; j++){\n\t\t\t\tif(j % 2 == 0) M[i + 1][j + 1] = 1;\n\t\t\t\telse{\n\t\t\t\t\tM[i + 1][j + 1] = *it == '1' ? true : false;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{ //縦線\n\t\t\tfor(int j = 0; j < w + w; j++){\n\t\t\t\tif(j % 2 == 1) M[i + 1][j + 1] = 0;\n\t\t\t\telse{\n\t\t\t\t\tM[i + 1][j + 1] = *it == '1' ? true : false;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int dy[16] = { 0, 1, 0,-1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\nconst char dir[4] = {'R', 'D', 'L', 'U'};\n\n// 右手法\n// right[d] := d方向（東から時計回り）を向いているときの優先順序\nconst int rightHand[4][4] = {\n\t{1,0,3,2},\n\t{2,1,0,3},\n\t{3,2,1,0},\n\t{0,3,2,1}\n};\n\nvector<pair<int,char>> getCommand(bool m[N][N]){\n\tint y = 0, x = 0;\n\tm[y + 1][x] = 1;\n\n\tint d = 0;\n\tvector<pair<int,char>> res;\n\twhile(true){\n\t\tif(y == 2 and x == 0) break;\n\n\t\trep(i,4){\n\t\t\tint rh = rightHand[d][i];\n\n\t\t\tint ny = y + dy[rh];\n\t\t\tint nx = x + dx[rh];\n\t\t\tif(m[ny][nx] == 0){\n\t\t\t\td = rh;\n\t\t\t\ty = y + dy[rh] * 2;\n\t\t\t\tx = x + dx[rh] * 2;\n\n\t\t\t\tint nrh = rightHand[d][0];\n\t\t\t\tint ny = y + dy[nrh];\n\t\t\t\tint nx = x + dx[nrh];\n\t\t\t\tif(m[ny][nx] == 0){\n\t\t\t\t\ty = y + dy[nrh] * 0;\n\t\t\t\t\tx = x + dx[nrh] * 0;\n\t\t\t\t}\n\t\t\t\tif(res.empty() or res.back().second != dir[d]) res.emplace_back(make_pair(1, dir[d]));\n\t\t\t\telse res.back().first++;\n\t\t\t\tbreak;\n\t\t\t}else{ \n\t\t\t\tif(i == 0) continue;;\n\t\t\t\tif(res.empty() or res.back().second != dir[rh]) res.emplace_back(make_pair(1, dir[rh]));\n\t\t\t\telse res.back().first++;\n\n\t\t\t}\n\t\t\t\t//break;\n\t\t}\n\t\t//printMaze(5,5,m,x,y); cout << endl;\n\n\t}\n\treturn res;\n}\n\nint main(){\n\tbool m[N][N];\n\textensionOfMaze(5, 5, m);\n\t//printMaze(5, 5, m);\n\t\n\tvector<pair<int,char>> tmp = getCommand(m);\n\tint f = 1;\n\tfor(auto p : tmp){\n\t\t//cout << p.first << ' ' << p.second << endl;\n\t\tif(p.first == 1) f = 0;\n\t\trep(i,p.first - f){\n\t\t\tcout << p.second;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nchar lab[11][7];\nstring s;\n\nvoid f(int i,int j){\n\n\tif(i==1 && j==1) return;\n\telse{\n\n\t\tstring a=\"URDLURDLUR\";\n\t\tint dx[]={0 ,-1,0,1, 0,-1,0};\n\t    int dy[]={-1, 0,0,0,-1, 0,0};\n\n        rep(k,4){\n\t\tif(s[s.size()-1]==a[k]){\n\n\t\tif(lab[i+dx[k]][j+dy[k]]-'0'==1){\n\t\t\ts+=a[k+3];\n\t\t\tif(dx[k]==0 && dy[k]==0) f(i,j+1);  else f(i+2*dx[k],j+dy[k]);\n\t\t}\n\t\telse if(lab[i+dx[k+1]][j+dy[k+1]]-'0'==1){\n\t\t\ts+=a[k+4];\n\t\t\tif(dx[k+1]==0 && dy[k+1]==0) f(i,j+1);  else f(i+2*dx[k+1],j+dy[k+1]);\n\t\t}\n\t\telse if(lab[i+dx[k+2]][j+dy[k+2]]-'0'==1){\n\t\t\ts+=a[k+5];\n\t\t\tif(dx[k+2]==0 && dy[k+2]==0) f(i,j+1);  else f(i+2*dx[k+2],j+dy[k+2]);\n\t\t}\n\t\telse if(lab[i+dx[k+3]][j+dy[k+3]]-'0'==1){\n\t\t\ts+=a[k+6];\n\t\t\tif(dx[k+3]==0 && dy[k+3]==0) f(i,j+1);  else f(i+2*dx[k+3],j+dy[k+3]);\n\t\t}\n\t\tbreak;\n\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\n\tREP(i,1,9){\n\tif(i%2==1)\n\tREP(j,1,4) cin >> lab[i][j];\n\telse\n\tREP(k,1,5) cin >> lab[i][k];\n\t}\n\n    s+='R';\n\n   f(1,2);\n\n   cout << s << endl;\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(c<50){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&m.d==2) {\n      cout << \"L\";\n      break;\n    }\n    if(m.x==0&&m.y==1&&f) {\n      //cout << \"U\";\n      break;\n    }\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"R\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(m.y<5){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.x++;\n\t  cout << \"R\";\n\t  continue;\n\t}\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.x++;\n\t  m.y++;\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      m.y++;\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"D\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y<4){\n\tif(st[m.y*2+1][m.x-1]=='1') {\n\t  m.y++;\n\t  cout << \"D\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y<5){\n\tif(st[m.y*2][m.x-2]=='1') {\n\t  m.x--;\n\t  m.y++;\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      m.x--;\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y>0){\n\tif(st[(m.y-1)*2][m.x-2]=='1') {\n\t  m.x--;\n\t  cout << \"L\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y>1){\n\tif(st[(m.y-1)*2-1][m.x-1]=='1') {\n\t  m.x--;\n\t  m.y--;\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      m.y--;\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"U\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(m.y>1){\n\tif(st[(m.y-1)*2-1][m.x]=='1') {\n\t  m.y--;\n\t  cout << \"U\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x]=='1') {\n\t  m.x++;\n\t  m.y--;\n\t  cout << \"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      m.x++;\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout  << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG 0\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[15][15];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U','R','D','L'};\n\nstring res;\nvoid touch_wall (int row, int col, int dir, int hand )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n\n\tfor (int i = 1; i <= 9; i++ ){\n\t\tstring s = \"\";\n\t\tcin >> s;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j+1] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j+1] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tif (j == 0 ){\n\t\t\t\t\t\tgrid[i/2][j+1] |= 1<<LEFT;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgrid[i/2][j+1] |= 1<<LEFT;\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<RIGHT;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n#if DEBUG2\n\trep (i, 10 ){\n\t\trep (j, 10 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n#endif\n\n\tint row = 0, col = 1, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tres = \"\";\n\tdo{\n\t\ttouch_wall (row, col, dir, hand );\n\t\tif ((1<<hand & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった、なくなった方向に回転\n\t\t\tdir = hand;\n\t\t}else\n\t\tif ((1<<dir & grid[row][col] ) != 0 ){\t\n\t\t\twhile ((1<<dir & grid[row][col] ) != 0 ){// 右手の壁があったとしても前に進めない\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand );\n\t\t\t} // end while\n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t}while (!(row == 0 && col == 0 ) ); // end while\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\n\nbool flg = true;\nint pos = 0;\nchar dir = 'R';\nint bar[11][6] = {0};\n\nvoid move(void)\n{\n\tflg = false;\n\tswitch(dir){\n\tcase 'R':\n\t\tif\t   (bar[pos/10  ][pos%10  ]) {pos-=20; dir='U'; cout<<dir;}\n\t\telse if(bar[pos/10+1][pos%10+1]) {pos+= 1; dir='R'; cout<<dir;}\n\t\telse if(bar[pos/10+2][pos%10  ]) {pos+=20; dir='D'; cout<<dir;}\n\t\telse\t\t\t\t\t\t\t {pos-= 1; dir='L'; cout<<dir;}\n\t\tbreak;\n\tcase 'L':\n\t\tif\t   (bar[pos/10  ][pos%10  ]) {pos-=20; dir='U'; cout<<dir;}\n\t\telse if(bar[pos/10+1][pos%10  ]) {pos-= 1; dir='L'; cout<<dir;}\n\t\telse if(bar[pos/10+2][pos%10  ]) {pos+=20; dir='D'; cout<<dir;}\n\t\telse\t\t\t\t\t\t\t {pos+= 1; dir='R'; cout<<dir;}\n\t\tbreak;\n\tcase 'U':\n\t\tif\t   (bar[pos/10+1][pos%10  ]) {pos-= 1; dir='L'; cout<<dir;}\n\t\telse if(bar[pos/10  ][pos%10  ]) {pos-=20; dir='U'; cout<<dir;}\n\t\telse if(bar[pos/10+1][pos%10+1]) {pos+= 1; dir='R'; cout<<dir;}\n\t\telse\t\t\t\t\t\t\t {pos+=20; dir='D'; cout<<dir;}\n\t\tbreak;\n\tcase 'D':\n\t\tif\t   (bar[pos/10+1][pos%10+1]) {pos+= 1; dir='R'; cout<<dir;}\n\t\telse if(bar[pos/10+2][pos%10  ]) {pos+=20; dir='D'; cout<<dir;}\n\t\telse if(bar[pos/10+1][pos%10  ]) {pos-= 1; dir='L'; cout<<dir;}\n\t\telse\t\t\t\t\t\t\t {pos-=20; dir='U'; cout<<dir;}\n\t\tbreak;\n\t}\n}\n\nint main(void)\n{\n\tstring str[10];\n\n\tfor(int i=1; i<10; i++)\n\t\tcin >> str[i];\n\n\tfor(int i=1; i<10; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(i%2 == 1)\n\t\t\t{\n\t\t\t\tif(j!=0)\n\t\t\t\t{\n\t\t\t\t\tbar[i][j] = atoi(str[i].substr(j-1,1).c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbar[i][j] = atoi(str[i].substr(j,1).c_str());\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile(pos!=0 || flg==true)\n\t\tmove();\n\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n\nint main(){\n\n\tint yoko[10][10];\n\tint tate[10][10];\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c-'0';\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\ttate[i][j]=c-'0';\n\t\t\t}\n\t\t}\n\t}\n\tint cx=0;\n\tint cy=0;\n\n\t// 0:E,1:º,2:¶,3:ã\n\tint angle=0;\n\twhile(1){\n\t\tint nx=cx;\n\t\tint ny=cy;\n\t\tif(angle==0){\n\t\t\tnx=cx+1;\n\t\t\tny=cy;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'R';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\tif(cy!=0&&tate[cy-1][cx]){\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t\telse if(tate[cy][cx]){\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(angle==1){\n\t\t\tnx=cx;\n\t\t\tny=cy+1;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'D';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// EÌÇðDæ\n\t\t\t\tif(cx!=4&&yoko[cy][cx]){\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t\t// ¶\n\t\t\t\telse if(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tnx=cx-1;\n\t\t\tny=cy;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx-1]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'L';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// ºÌÇªDæ\n\t\t\t\tif(cy!=4&&tate[cy][cx]){\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t\t// ã\n\t\t\t\telse if(cy!=0&&tate[cy-1][cx]){\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tnx=cx;\n\t\t\tny=cy-1;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy-1][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'U';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// ¶ÌÇðDæ\n\t\t\t\tif(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t\t// E\n\t\t\t\telse if(cx!=4&&yoko[cy][cx]){\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t}\t\t\n\t   }\n\t\tif(cx==0&&cy==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}\n\n\n//\n//int main(){\n//\n//\t//while(1){\n//\t\tchar yoko[10][10];\n//\t\tchar tate[10][10];\n//\t\t//memset(yoko,0,sizeof(yoko));\n//\t\t//memset(tate,0,sizeof(tate));\n//\t\tfor(int i = 0; i < 5; i++){\n//\t\t\tfor(int j = 0; j < 4; j++){\n//\t\t\t\tchar c;\n//\t\t\t\tcin>>c;\n//\t\t\t\tyoko[i][j]=c;\n//\t\t\t}\n//\t\t\tif(i!=4){\n//\t\t\t\tfor(int j = 0; j < 5; j++){\n//\t\t\t\t\tchar c;\n//\t\t\t\t\tcin>>c;\n//\t\t\t\t\ttate[i][j]=c;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\t// 0,1,2,3ÅEAºA¶Aã\n//\t\tint angle=0;\n//\t\tint px,py;\n//\t\tpx=py=0;\n//\t\tstring str=\"\";\n//\t\twhile(1){\n//\t\t\tif(angle==0){\n//\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\tstr+='R';\n//\t\t\t\t\tpx++;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ãÖ\n//\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t\t// ºÉÇª êÎAºÖ\n//\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// º\n//\t\t\telse if(angle==1){\n//\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\tstr+='D';\n//\t\t\t\t\tpy++;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª³¯êÎA½]\n//\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t}\n//\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// ¶\n//\t\t\telse if(angle==2){\n//\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\tstr+='L';\n//\t\t\t\t\tpx--;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª êÎAºÖ\n//\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t\t// ãÖ\n//\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// ã\n//\t\t\telse if(angle==3){\n//\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\tstr+='U';\n//\t\t\t\t\tpy--;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª³¯êÎA½]\n//\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t}\n//\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(px==0&&py==0){\n//\t\t\t\tbreak;\n//\t\t\t}\n//}\n//\n////cout<<str<<endl;\n////break;\n//\n////}\n//return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int field[6][6]={0};\n  string s;\n  for(int i=0; i<5; i++){\n    cin >>s;\n    for(int j=0; j<s.size(); j++){\n      if(s[j] == '1'){\n\tfield[i][j+1]+=4;\n\tfield[i+1][j+1]+=1;\n      }\n    }\n    cin >>s;\n    if(i!=4){\n      for(int j=0; j<s.size(); j++){\n\tif(s[j] == '1'){\n\t  field[i+1][j]+=2;\n\t  field[i+1][j+1]+=8;\n\t}\n      }\n    }\n  }\n  int d = 2,x = 0,y = 1;\n  for(;;){\n    if(d == 1){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&1)d = 8;\n\telse x--; \n      }\n      else{d = 2;y++;}\n    }\n    else if(d == 2){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&2) d = 1;\n\telse y++;\n      }\n      else{d = 4;x++;}\n    }\n    else if(d == 4){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&4) d = 2;\n\telse x++;\n      }\n      else{d = 8;y--;}\n    }\n    else if(d == 8){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&8) d = 4;\n\telse y--;\n      }\n      else{d = 1;x--;}\n    }\n    if(x == 0 && y == 1) break;\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar m[10][10];\n\nbool end(int x, int y) {\n  return (x == 1 && y == 1) || (x == 0 && y == 1) ;\n}\n\nvoid check(int x, int y, int d) {\n  printf(\"x,y = %d,%d : %d\\n\", x, y, d);\n  assert(false);\n}\n\nint main() {\n  memset(m, 0, sizeof m);\n  string ans = \"R\";\n  rep(i,9) scanf(\" %s\", m[i]);\n  rep(i,9) {\n    rep(j,5) {\n      m[i][j] = (m[i][j] == '1') ? 1 : 0 ;\n    }\n  }\n  \n  int x = 1, y = 0, d = 1;\n  do {\n    // printf(\"(%d,%d) : %d : %s\\n\", x, y, d, ans.c_str());\n    switch (d) {\n      case 0: {\n        // up\n        if (m[2*(y-1)][x-1]) {\n          ans += 'L';\n          d = 3;\n        } else if (m[2*(y-2)+1][x]) {\n          // ok\n          ans += 'U';\n          --y;\n        } else if (m[2*(y-1)][x]) {\n          // ok\n          ans += 'R';\n          d = 1;\n          ++x; --y;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 1: {\n        // right\n        if (m[2*(y-1)+1][x]) {\n          ans += 'U';\n          d = 0;  \n        } else if (m[2*y][x]) {\n          // ok\n          ans += 'R';\n          ++x;\n        } else if (m[2*y+1][x]) {\n          // ok\n          ans += 'D';\n          d = 2;\n          ++x; ++y;\n        } else {check(x,y,d);}\n        break;        \n      }\n      case 2: {\n        // down\n        if (m[2*y][x-1]) {\n          ans += 'R';\n          d = 1;\n        } else if (m[2*y+1][x-1]) {\n          // ok\n          ans += 'D';\n          ++y;\n        } else if (m[2*y][x-2]) {\n          // ok\n          ans += 'L';\n          d = 3;\n          --x; ++y;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 3: {\n        // left\n        if (m[2*(y-1)+1][x-1]) {\n          ans += 'D';\n          d = 2;\n        } else if (m[2*(y-1)][x-2]) {\n          // ok\n          ans += 'L';\n          --x;\n        } else if (m[2*(y-2)+1][x-1]) {\n          // ok\n          ans += 'U';\n          d = 0;\n          --x; --y;\n        } else {check(x,y,d);}\n        break;        \n      }\n    }\n  } while (!end(x,y));\n  if (x == 1 && y == 1 && d == 0) ans += 'L';\n  printf(\"%s\\n\", ans.c_str());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool wall[5][5][4];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n\tstring s;\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s;\n\n\t\tif(i % 2 == 0){\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tif(s[j] == '1'){\n\t\t\t\t\twall[j][i / 2][0] = wall[j + 1][i / 2][2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 0; j < 5; ++j){\n\t\t\t\tif(s[j] == '1'){\n\t\t\t\t\twall[j][i / 2][1] = wall[j][i / 2 + 1][3] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts.clear();\n\tint x = 0, y = 0, dir = 0;\n\tdo{\n\t\ts += \"RDLU\"[dir];\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\n\t\tif(wall[x][y][(dir + 3) % 4]){\n\t\t\tdir = (dir + 3) % 4;\n\t\t}\n\t\telse if(!wall[x][y][dir]){\n\t\t\tif(wall[x][y][(dir + 1) % 4]){\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir = (dir + 2) % 4;\n\t\t\t}\n\t\t}\n\t} while(x != 0 || y != 0 || dir != 0);\n\t\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nconst int N = 11;\nbool a[N][N][4];\nchar c[4] = {'R', 'D', 'L', 'U'};\n\nint main() {\n\t//ios :: sync_with_stdio(0);\n\n\tfor(int i = 0; i < 9; i ++) {\n\t\tstring s; cin >> s;\n\t\tif(i & 1) {\n\t\t\tfor(int j = 0; j < 5; j ++)\n\t\t\t\tif(s[j] == '1') {\n\t\t\t\t\ta[i / 2][j][1] = 1;\n\t\t\t\t\ta[i / 2 + 1][j][3] = 1;\n\t\t\t\t}\n\t\t} else {\n\t\t\tfor(int j = 0; j < 4; j ++)\n\t\t\t\tif(s[j] == '1') {\n\t\t\t\t\ta[i / 2][j][0] = 1;\n\t\t\t\t\ta[i / 2][j + 1][2] = 1;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tint x = 0, y = 0, d = 0;\n\tfor(;;) {\n\t\td = (d + 3) % 4;\n\t\twhile(!a[x][y][d])\n\t\t\td = (d + 1) % 4;\n\t\t//cout << x << ' ' << y << ' ' << d << '\\n';\n\t\tx += dx[d]; y += dy[d];\n\t\tcout << c[d];\n\t\tif(!x && !y) break;\n\t}\n\tcout << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n\nbool in(int x,int y){\n    return 0<=x && x<9 && 0<=y && y<9;\n}\n\nint main(){\n    enum {U,R,D,L};\n    const int dy[]={-1,0,1,0};\n    const int dx[]={0,1,0,-1};\n    vvb g(9,vb(9));\n    rep(i,9){\n        string s;cin>>s;\n        if(i%2==0){\n            rep(j,4)g[i][j*2+1]=s[j]-'0';\n        }else{\n            rep(j,5)g[i][j*2]=s[j]-'0';\n        }\n    }\n    \n    int i=0,j=0;\n    int prev=R;\n    while(1){\n        int next[4]={L,U,R,D};\n        rotate(next,next+prev,next+4);\n        int k=0;\n        for(;k<4;k++){\n            if(in(i+dy[next[k]],j+dx[next[k]]) && g[i+dy[next[k]]][j+dx[next[k]]]){\n                break;\n            }\n        }\n        \n        putchar(\"URDL\"[next[k]]);\n        i+=dy[next[k]]*2;\n        j+=dx[next[k]]*2;\n        prev=next[k];\n        if(i==0 && j==0){\n            break;\n        }\n    }\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<string>\n#include<algorithm>\n#define UP_DIRECTION 3\n#define RIGHT_DIRECTION 2\n#define DOWN_DIRECTION 1\n#define LEFT_DIRECTION 0\nusing namespace std;\nint dy[]={0,1,0,-1},dx[]={-1,0,1,0};\nint main(){\n    bitset<4>Square[5][5];\n    string Wall[9];\n    char For_Output[]=\"LDRU\";\n    for(int i=0;i<9;i++)cin>>Wall[i];\n\n    for(int i=0;i<9;i+=2){\n        Wall[i]=\"0\"+Wall[i]+\"0\";\n        for(int j=0;j<5;j++){\n            Square[i/2][j][LEFT_DIRECTION]=(Wall[i][j]-'0');\n            Square[i/2][j][RIGHT_DIRECTION]=(Wall[i][j+1]-'0');\n        }\n    }\n\n    for(int i=1;i<9;i+=2){\n        for(int j=0;j<5;j++){\n            Square[i/2][j][DOWN_DIRECTION]=(Wall[i][j]-'0');\n            Square[i/2+1][j][UP_DIRECTION]=(Wall[i][j]-'0');\n        }\n    }\n    int Direction=RIGHT_DIRECTION;\n    int y=0,x=0;\n\n    do{\n        if(Square[y][x][(Direction+1)%4])\n            Direction++;\n\n        else if(!Square[y][x][Direction])\n            Direction--;\n\n        if(Direction>3)Direction=0;\n        if(Direction<0)Direction=3;\n\n        y+=dy[Direction];\n        x+=dx[Direction];\n        cout<<For_Output[Direction];\n    }while(y!=0||x!=0);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  int vwall[5][6] = {0}, hwall[5][6] = {0};\n  string tmp;\n  for (int i = 0; i < 9; i++) {\n    cin >> tmp;\n    if (i % 2 == 0)\n      for (int j = 0; j < 4; j++)\n        hwall[i/2][j+1] = tmp[j]-'0';\n    else\n      for (int j = 0; j < 5; j++)\n        vwall[j][i/2+1] = tmp[j]-'0';\n  }\n\n  string str = \"\";\n  enum Compass {N = 0, E, W, S};\n  enum Compass compass = E;\n  int x = 0, y = 0;\n  while (true) {\n    if (compass == E)\n      if (vwall[x][y]) {\n        compass = N;\n        str += 'U';\n        y--;\n      } else if (hwall[y][x+1]) {\n        x++;\n        str += 'R';\n      } else if (vwall[x][y+1]) {\n        compass = S;\n        str += 'D';\n        y++;\n      } else {\n        compass = W;\n      }\n    else if (compass == W)\n      if (vwall[x][y+1]) {\n        compass = S;\n        str += 'D';\n        y++;\n      } else if (hwall[y][x]) {\n        x--;\n        str += 'L';\n      } else if (vwall[x][y]) {\n        compass = N;\n        str += 'U';\n        y--;\n      } else {\n        compass = E;\n      }\n    else if (compass == N)\n      if (hwall[y][x]) {\n        compass = W;\n        str += 'L';\n        x--;\n      } else if (vwall[x][y]) {\n        y--;\n        str += 'U';\n      } else if (hwall[y][x+1]) {\n        compass = E;\n        str += 'R';\n        x++;\n      } else {\n        compass = S;\n      }\n    else if (compass == S)\n      if (hwall[y][x+1]) {\n        compass = E;\n        str += 'R';\n        x++;\n      } else if (vwall[x][y+1]) {\n        y++;\n        str += 'D';\n      } else if (hwall[y][x]) {\n        compass = W;\n        str += 'L';\n        x--;\n      } else {\n        compass = N;\n      }\n    if (x == 0 && y == 0) {\n      cout << str << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nstring s[9], ans;\nsigned main(void)\n{\n  REP(i, 9) cin >> s[i];\n  int x = 1, y = 0, dir = 0;\n  while(true) {\n    if(dir == 0) {\n      //cout << s[2*y][x-1] << \" \" << s[2*y-1][x+1] << endl;\n      if(x >= 1 && y >= 1 && s[2*y][x-1] == '1' && s[2*y-1][x] == '1') {\n        dir = 3;\n      } else if(x >= 1 && s[2*y][x-1] == '1' && s[2*y][x] == '1') {\n        ++x;\n      } else if(x >= 1 && s[2*y][x-1] == '1' && s[2*y+1][x] == '1') {\n        ++x; ++y; dir = 1;\n      } else if(x >= 1 && s[2*y][x-1] == '1') {\n        ++y; dir = 2;\n      }\n      cout << 'R';\n    } else if(dir == 1) {\n      if(x >= 1 && y >= 1 && s[2*y-1][x-1] == '1' && s[2*y][x-1] == '1') {\n        dir = 0;\n      } else if(x >= 1 && y >= 1 && s[2*y-1][x-1] == '1' && s[2*y+1][x-1] == '1') {\n        ++y;\n      } else if(x >= 2 && y >= 1 && s[2*y-1][x-1] == '1' && s[2*y][x-2] == '1') {\n        --x; ++y; dir = 2;\n      } else if(x >= 1 && y >= 1 && s[2*y-1][x-1] == '1') {\n        --x; dir = 3;\n      }\n      cout << 'D';\n    } else if(dir == 2) {\n      if(x >= 1 && y >= 1 && s[2*y-2][x-1] == '1' && s[2*y-1][x-1] == '1') {\n        dir = 1;\n      } else if(x >= 2 && y >= 1 && s[2*y-2][x-1] == '1' && s[2*y-2][x-2] == '1') {\n        --x;\n      } else if(x >= 1 && y >= 1 && s[2*y-2][x-1] == '1' && s[2*y-3][x-1] == '1') {\n        --x; --y; dir = 3;\n      } else if(x >= 1 && y >= 1 && s[2*y-2][x-1]) {\n        --y; dir = 0;\n      }\n      cout << 'L';\n    } else if(dir == 3) {\n      if(x >= 1 && y >= 1 && s[2*y-1][x] == '1' && s[2*y-2][x-1] == '1') {\n        dir = 2;\n      } else if(y >= 2 && s[2*y-1][x] == '1' && s[2*y-3][x] == '1') {\n        y--;\n      } else if(y >= 1 && s[2*y-1][x] == '1' && s[2*y-2][x] == '1') {\n        ++x; --y; dir = 0;\n      } else if(y >= 1 && s[2*y-1][x] == '1') {\n        ++x; dir = 2;\n      }\n      cout << 'U';\n    }\n    //cout << x << \" \" << y << \" \" << dir << endl;\n    if((x == 1 && y == 0) || (x == 1 && y == 1) || (x == 0 && y == 1)) {\n      if(dir == 0) cout << 'R';\n      else if(dir == 1) cout << 'D';\n      else if(dir == 2) cout << 'L';\n      else if(dir == 3) cout << 'U';\n      cout << endl;\n      return 0;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n\n    while ( true ) {\n        putchar( T[s] );\n        if ( r == 2 && c == 2 && s != R ) break;\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define LEFT 0\n#define UP   1\n#define RIGHT 2\n#define DOWN 3\n\n#define MIN(X,Y) ((X<Y)?X:Y)\n#define MAX(X,Y) ((X>Y)?X:Y)\n\nbool map[5][5][5][5];\nint direction=RIGHT;\nint pos[2]={0,0};\nchar nul[5000];\n\n\nvoid read(void)\n{\n\tfor(int y=0;y<4;y++)\n\t{\n\t\tfor(int x=0;x<4;x++)\n\t\t\tmap[x][y][x+1][y] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t\tfor(int x=0;x<5;x++)\n\t\t\tmap[x][y][x][y+1] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t}\n\tfor(int x=0;x<4;x++)\n\t\tmap[x][4][x+1][4] = (getchar()-'0' == 1);\n\treturn;\n}\n\nbool isenable(int x, int y)\n{\n\treturn ((0<=x)&&(x<=4))&&((0<=y)&&(y<=4));\n}\n\nbool isconnect(int dir)\n{\n\tint x=pos[0], y=pos[1];\n\tswitch(dir) {\n\t\tcase LEFT:   x--;\n\t\t\t     break;\n\t\tcase UP:     y--;\n\t\t\t     break;\n\t\tcase RIGHT:  x++;\n\t\t\t     break;\n\t\tcase DOWN:   y++;\n\t\t\t     break;\n\t}\n\treturn (isenable(x,y)&&(map[MIN(pos[0],x)][MIN(pos[1],y)][MAX(pos[0],x)][MAX(pos[1],y)]));\n}\nvoid step(int dir)\n{\n\tswitch(dir) {\n\t\tcase LEFT:   pos[0]--; std::cout << \"L\" << std::flush; direction=LEFT;\n\t\t\t     break;\n\t\tcase UP:     pos[1]--; std::cout << \"U\" << std::flush; direction=UP;\n\t\t\t     break;\n\t\tcase RIGHT:  pos[0]++; std::cout << \"R\" << std::flush; direction=RIGHT;\n\t\t\t     break;\n\t\tcase DOWN:   pos[1]++; std::cout << \"D\" << std::flush; direction=DOWN;\n\t\t\t     break;\n\t}\n\treturn;\n}\n\nvoid move(void)\n{\n\tdo {\n\t\tif(isconnect((direction+LEFT-1+4)%4))\n\t\t\tstep((direction+LEFT-1+4)%4);\n\t\telse if(isconnect((direction+UP-1+4)%4))\n\t\t\tstep((direction+UP-1+4)%4);\n\t\telse if(isconnect((direction+RIGHT-1+4)%4))\n\t\t\tstep((direction+RIGHT-1+4)%4);\n\t\telse\n\t\t\t//std::cerr << \"error\" << std::endl;\n\n\t\t//std::cerr << \"(x,y):\" << pos[0] << \",\" << pos[1] << std::endl;\n\t}while(!(pos[0]==0 && pos[1]==0));\n\n\tstd::cout << std::endl;\n\treturn;\n}\n\nint main(void)\n{\n\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tfor(int k=0; j<5; j++)\n\t\t\t\tfor(int l=0; j<5; j++)\n\t\t\t\t\tmap[i][j][k][l] = false;\n\n\tread();\n\tmove();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nstring dc = \"RDLU\";\n\nint main() {\n    int g[11][11] = {};\n    char c;\n    for (int i=1; i<10; ++i) {\n        int k = 1 + (i % 2);\n        int l = 9 - (i % 2);\n        for (int j=k; j<=l; j+=2) {\n            cin >> c;\n            g[i][j] = g[i][j-1] = g[i][j+1] = c - '0';\n        }\n    }\n    int x = 1, y = 1, d = 0;\n    do {\n        for (int t=(d+3)%4; t<=(d+2)%4; t=(t+1)%4) {\n            if (g[y + dy[t]][x + dx[t]]) {\n                d = t;\n                break;\n            }\n        }\n        x += dx[d] * 2;\n        y += dy[d] * 2;\n        cout << dc[d];\n    } while (x != 1 || y != 1);\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid change(int,int);\nint muki = 0,flag = 0;\n\nint main(){\n\tint i,j,x = 0,y = 0,wall_x[4][5],wall_y[5][4];\n\tfor(i = 0;i < 9;i++){\n\t\tif(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n\t\telse for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n\t}\n\tdo{\n\t\tif(muki == 0){\n\t\t\tif(x != 4 && wall_x[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('R');\n\t\t\t\tx++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 1){\n\t\t\tif(y != 4 && wall_y[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('D');\n\t\t\t\ty++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 2){\n\t\t\tif(x != 0 && wall_x[x - 1][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('L');\n\t\t\t\tx--;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 3){\n\t\t\tif(y != 0 && wall_y[x][y - 1] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('U');\n\t\t\t\ty--;\n\t\t\t}else change(x,y);\n\t\t}\n\t}while(x != 0 || y != 0);\n\tputs(\"\");\n\treturn 0;\n}\n\nvoid change(int x,int y){\n\tint i;\n\tif(!flag){\n\t\tflag = 1;\n\t\tmuki = (muki + 3) % 4;\n\t}\n\telse muki = (muki + 1) % 4;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define sc(x) cin >> x\n#define sc2(x, y) cin >> x >> y\n#define sc3(x, y, z) cin >> x >> y >> z\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define debugn(i, n, a) rep(i, n)cout << \" --- \" << a[i] << \"\\n\";\n#define debugin(i, n, a) rep(i, n)printf(\" --- %10d\\n\", a[i])\n#define debugi2n(i, n, a, b) rep(i, n)printf(\" --- %10d %10d\\n\", a[i], b[i])\n#define debugiin(i, n, a) rep(i, n)printf(\" --- %10d %10d\\n\", a[i].first, a[i].second)\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\n\nsigned main(void){\n  int i, j, k;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  string res = \"RDLU\";\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    bool f[11][11] = {false};\n    string s;\n    sc(s);\n    rep(i, 4){\n      if(s[i] == '1')f[1][i * 2 + 2] = true;\n      else f[1][i * 2 + 2] = false;\n    }\n\n    rep(i, 4){\n      sc(s);\n      rep(j, 5){\n        if(s[j] == '1')f[i * 2 + 2][2 * j + 1] = true;\n        else f[i * 2 + 2][2 * j + 1] = false;\n      }\n      sc(s);\n      rep(j, 4){\n        if(s[j] == '1')f[i * 2 + 3][2 * j + 2] = true;\n        else f[i * 2 + 3][2 * j + 2] = false;\n      }\n    }\n\n    rep(i, 11){\n      rep(j, 11){\n        if(f[i][j])cout << \"1\";\n        else cout << \"0\";\n      }\n      kara;\n    }\n\n    pair<i_i, int> now = mp(mp(0, 2), 0);\n\n    for(int times = 50;times--;){\n      if(f[now.X.X + dx[now.Y]][now.X.Y + dy[now.Y]]){\n        cout << res[now.Y];\n        now.Y = (now.Y + 3) % 4;\n      }else{\n        now.X.X += dx[now.Y] * 2;\n        now.X.Y += dy[now.Y] * 2;\n        cout << res[now.Y];\n        for(int qwe = 4;qwe--;){\n          if(!f[now.X.X + dx[(now.Y + 1) % 4]][now.X.Y + dy[(now.Y + 1) % 4]]){\n            now.Y = (now.Y + 1) % 4;\n            now.X.X += dx[now.Y] * 2;\n            now.X.Y += dy[now.Y] * 2;\n          }else break;\n        }\n      }\n      if(now.X.X == 0 && now.X.Y == 2)break;\n    }\n\n    kara;\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef enum _DIRECTION { dU, dR, dD, dL, DIR_MAX } DIR;\n\nconst int MAX_N = 5;\nconst int MAX_D = 4;\n\nbool mat[MAX_N][MAX_N][MAX_D];\n\nint main ( void )\n{\n\tfor (int i = 0; i < MAX_N; ++i) {\n\t\tfor (int j = 0; j < MAX_N; ++j) {\n\t\t\tfill(mat[i][j], mat[i][j]+MAX_D, false);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 9; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (i & 1) {\n\t\t\tfor (int j = 0, J = str.size(); j < J; ++j) {\n\t\t\t\tmat[i/2][j][dD] = (str[j] == '1');\n\t\t\t\tif (i/2+1 < MAX_N) {\n\t\t\t\t\tmat[i/2+1][j][dU] = (str[j] == '1');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0, J = str.size(); j < J; ++j) {\n\t\t\t\tmat[i/2][j][dR] = mat[i/2][j+1][dL] = (str[j] == '1');\n\t\t\t}\n\t\t}\n\t}\n\n\tchar c_dir[] = \"URDL\";\n\tint dx[] = { 0, 1, 0, -1 }, dy[] = { -1, 0, 1, 0 };\n\tDIR dir = dU;\n\tint x = 0, y = 0;\n\tbool hit = true;\n\n\twhile (hit) {\n\t\thit = false;\n\t\tfor (int i = 0; i < DIR_MAX; ++i) {\n\t\t\tDIR next = (DIR)((dir + DIR_MAX - 1 + i) % DIR_MAX);\n\t\t\tif (mat[y][x][next]) {\n\t\t\t\tdir = next;\n\t\t\t\tmat[y][x][dir] = false;\n\t\t\t\tcout << c_dir[dir];\n\t\t\t\tx += dx[dir];\n\t\t\t\ty += dy[dir];\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  char c;\n  bool a[10][5];\n  bool b[5][5][4];\n  char label[4] = {'R', 'D', 'L', 'U'};\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {1, 0, -1, 0}; \n  int x, y, d, nd;\n\n  for (int i=0; i<9; i++) {\n    int r = (i%2) ? 5 : 4;\n    for (int j=0; j<r; j++) {\n      cin >> c;\n      a[i][j] = c - '0';\n    }\n  }\n\n  for (int i=0; i<5; i++) {\n    for (int j=0; j<5; j++) {\n      b[i][j][0] = (j<4) ? a[2*i][j] : false;\n      b[i][j][1] = (i<4) ? a[2*i+1][j] : false;\n      b[i][j][2] = (j) ? a[2*i][j-1] : false;\n      b[i][j][3] = (i) ? a[2*i-1][j] : false;\n    }\n  }\n\n  d = 0;\n  cout << label[d];\n  x = 0; y = 1;\n  do {\n    for (int i=0; i<4; i++) {\n      nd = (d+i+3)%4;\n      if (b[x][y][nd]) {\n        d = nd;\n        break;\n      }\n    }\n    cout << label[d];\n    x += dx[d]; y+= dy[d];\n  } while (x || y);\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nint map[10][5];\nbool used[10][5];\n\nbool f = true;\nstring S = \"LURD\";\nvoid dfs( int r, int c, int a, int o )\n{\n    used[r][c] = true;\n    if ( o ) {\n        cout << S[a];\n    }\n\n    if ( !f && r == 0 && c == 0 ) {\n        cout << endl;\n        return;\n    }\n\n    if ( f ) {\n        if ( a == 0 ) {\n            if ( c == 0 || !map[r][c-1] ) {\n                if ( !used[r][c-1] ) {\n                    dfs( r-1, c, 1, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            } else if ( map[r][c-1] ) {\n                if ( !used[r][c-1] ) {\n                    dfs( r, c-1, 0, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            }\n        } else if ( a == 1 ) {\n            if ( r == 1 || !map[r-2][c] ) {\n                if ( !used[r-1][c] ) {\n                    dfs( r-1, c, 2, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            } else if ( map[r-2][c] ) {\n                if ( !used[r-2][c] ) {\n                    dfs( r-2, c, 1, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            }\n        } else if ( a == 2 ) {\n            if ( c == 3 || !map[r][c+1] ) {\n                if ( !used[r+1][c+1] ) {\n                    dfs( r+1, c+1, 3, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            } else if ( map[r][c+1] ) {\n                if ( !used[r][c+1] ) {\n                    dfs( r, c+1, 2, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            }\n        } else if ( a == 3 ) {\n            if ( c == 7 || !map[r+2][c] ) {\n                if ( !used[r+1][c-1] ) {\n                    dfs( r+1, c-1, 0, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            } else if ( map[r+2][c] ) {\n                if ( !used[r+2][c] ) {\n                    dfs( r+2, c, 3, 1 );\n                } else {\n                    f = false;\n                    dfs( r, c, a, 0 );\n                }\n            }\n        }\n    } else {\n        if ( a == 0 ) {\n            if ( c == 0 || !map[r][c-1] ) {\n                dfs( r+1, c, 3, 1 );\n            } else if ( map[r][c-1] ) {\n                dfs( r, c-1, 0, 1 );\n            }\n        } else if ( a == 1 ) {\n            if ( r == 1 || !map[r-2][c] ) {\n                dfs( r-1, c-1, 0, 1 );\n            } else if ( map[r-2][c] ) {\n                dfs( r-2, c, 1, 1 );\n            }\n        } else if ( a == 2 ) {\n            if ( c == 3 || !map[r][c+1] ) {\n                dfs( r-1, c+1, 1, 1 );\n            } else if ( map[r][c+1] ) {\n                dfs( r, c+1, 2, 1 );\n            }\n        } else if ( a == 3 ) {\n            if ( r == 7 || !map[r+2][c] ) {\n                dfs( r+1, c, 2, 1 );\n            } else if ( map[r+2][c] ) {\n                dfs( r+2, c, 3, 1 );\n            }\n        }\n    }\n}\n\nint main( void )\n{\n    for ( int i = 0; i < 9; i++ ) {\n        string line;\n        cin >> line;\n        for ( int j = 0; j < (i%2==0?4:5); j++ ) {\n            map[i][j] = (int)(line[j] - '0');\n        }\n    }\n\n    dfs( 0, 0, 2, 1 );\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  while(1) {\n    rep(i, 5) {\n      char x;\n      rep(j, 4) {\n        cin >> x; if(cin.eof()) return 0;\n        if(x-'0') {\n          G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n          G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n        }\n      }\n\n      if(i == 4) break;\n\n      rep(j, 5) {\n        cin >> x;\n        if(x-'0') {\n          G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n          G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n        }\n      }\n    }\n\n    string const OP = \"LURD\";\n\n    int y = 0, x = 0, d = 2;\n\n    while(y != 0 || x != 0 || d != 0) {\n      bool ok = 0; int le = -1, ri = -1;\n      for(auto && e: G[y * 5 + x]) {\n        if(e.second == (d + 3) % 4) le = e.second;\n        if(e.second == (d + 1) % 4) ri = e.second;\n        if(e.second != d) continue;\n        ok = 1;\n        y = e.first / 5, x = e.first % 5;\n        cout << OP[d];\n        break;\n      }\n      if(!ok) {\n        if(le != -1) d = le;\n        else if(ri != -1) d = ri;\n        else (d += 1) %= 4;\n      }\n    }\n    cout << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntypedef struct{\n\tint flg[4];\n}Point;\n\nint main(void){\n\tint di[] = {-1,0,1,0};\n\tint dj[] = {0,1,0,-1};\n\tchar ch[] = \"URDL\";\n\tPoint p[5][5];\n\tmemset(p,0,sizeof(p));\n\n\tfor(int i=0;i<9;i++){\n\t\tchar wall[8];\n\t\tcin>>wall;\n\t\tif(i % 2){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tp[i/2][j].flg[2] = p[i/2+1][j].flg[0] = wall[j] - '0';\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tp[i/2][j].flg[1] = p[i/2][j+1].flg[3] = wall[j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\n\tint pi=0, pj=1, d=1;\n\tcout<<\"R\";\n\twhile(pi != 0 || pj != 0){\n\t\tint front = p[pi][pj].flg[d];\n\t\tint left = p[pi][pj].flg[(d+3)%4];\n\n\t\tif(left == 1 || left == 0 && front == 1){\n\t\t\tif(left == 1) d = (d+3)%4;\n\t\t\tcout<<ch[d];\n\t\t\tpi += di[d];\n\t\t\tpj += dj[d];\n\t\t}\n\t\telse{\n\t\t\td = (d+1)%4;\n\t\t}\n\t}\n\tcout<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint i, j, a[6][6] = {}, b[6][5] = {};\nstring output = \"\";\n\nint right(), left(), up(), down();\n\nint right(){\n\toutput += \"R\";\n\tif(b[i-1][j] == 1){\n\t\ti--;\n\t\tup();\n\t}\n\telse if(a[i][j+1] == 1){\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"R\"; }\n\telse {\n\t\tdown();\n\t}\n\treturn 0;\n}\n\nint left(){\n\toutput += \"L\";\n\tif (b[i][j-1] == 1) {\n\t\tj--;\n\t\tdown();\n\t}\n\telse if (a[i][j-1] == 1) {\n\t\tj--;\n\t\tleft();\n\t}\n\telse if (a[i][j - 1] == 2) { output += \"L\"; }\n\telse {\n\t\ti--;\n\t\tj--;\n\t\tup();\n\t}\n\treturn 0;\n}\n\nint up(){\n\toutput += \"U\";\n\tif (a[i][j] == 1) {\n\t\tleft();\n\t}\n\telse if (a[i][j] == 2) {  }\n\telse if (b[i-1][j] == 1) {\n\t\ti--;\n\t\tup();\n\t}\n\telse if (a[i][j + 1] == 2) {  }\n\telse {\n\t\tj++;\n\t\tright();\n\t}\n\treturn 0;\n}\n\nint down(){\n\toutput += \"D\";\n\tif (a[i+1][j+1] == 1) {\n\t\ti++;\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i + 1][j + 1] == 2) {  }\n\telse if (b[i + 1][j] == 1) {\n\t\ti++;\n\t\tdown();\n\t}\n\telse if (a[i + 1][j] == 2) { }\n\telse {\n\t\ti++;\n\t\tleft();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tstring input, k;\n\tfor(i = 1; i<10;i++){\n\t\tgetline(cin, input);\n\t\tif (input.size() != 4) {\n\t\t\tfor(int j= 0;j<5;j++){\n\t\t\t\tk = input[j];\n\t\t\t\tb[i / 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1;j<5;j++){\n\t\t\t\tk = input[j-1];\n\t\t\t\ta[(i + 1)/ 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\n\t}\n\n\ta[1][1] = 2;\n\ti = 1;\n\tj = 1;\n\tright();\n\tcout << output << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nvector<string> strs;\nint H,W;\nbool isroad(int fx,int fy,int tx,int ty){\n    int fromx,fromy,tox,toy;\n    fromx=min(fx,tx);\n    fromy=min(fy,ty);\n    tox=max(fx,tx);\n    toy=max(fy,ty);\n    if(fromx<1 || tox<1 || tox>W || fromx>W || fromy<1 || toy<1 || fromy>H || toy>H) return false;\n    if(fromx==tox){\n        if(strs[(fromy-1)*2+1][fromx-1]=='1') return true;\n        else{\n            return false;\n        }\n    }else{\n        if(strs[(fromy-1)*2][fromx-1]=='1') return true;\n        else{\n            return false;\n        }\n    }\n}\nint vx[]={1,0,-1,0},vy[]={0,-1,0,1};\nint main(){\n    string ins;\n    while(cin>>ins){\n        strs.push_back(ins);\n    }\n    W=strs[0].size()+1;\n    H=strs.size()/2+1;\n    int nx=2,ny=1,v=0;\n    string outs=\"R\";\n    while(nx!=1 || ny!=1){\n        for(int i=5;i>=2;i--){\n            bool r=isroad(nx,ny,nx+vx[(v+i)%4],ny+vy[(v+i)%4]);\n            if(r){\n                v=(v+i)%4;\n                nx+=vx[v];\n                ny+=vy[v];\n                if(v==0) outs+='R';\n                else if(v==1) outs+='U';\n                else if(v==2) outs+='L';\n                else outs+='D';\n                break;\n            }\n        }\n    }\n    cout<<outs<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n  \nusing namespace std;\n  \nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0&&way==3){\n  \tcout<<\"L\";\n  \treturn;\n  }\n  if(y==1&&x==0&&way==2){\n  \tcout<<\"U\";\n  \treturn;\n  }\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<5&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x]=='1')solve(y,x,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y][x]=='1')solve(y,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x]=='1')solve(y,x,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y][x]=='1')solve(y,x,2);\n  }\n  return;\n}\n  \nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  solve(0,0,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n \nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n \nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n \n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n                checkTable[i][k][p] = 0;\n            }\n        }\n    }\n \n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n \n    printf(\"R\");\n    char current = 'R';\n \n    checkTable[0][0][1] = 1;\n \n    row = 0,col = 0;\n \n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else{\n                printf(\"U\");\n                checkTable[row][col][2] = 1;\n                current = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n \n   printf(\"\\n\");\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nstring dc = \"RDLU\";\n\nint main() {\n    int g[11][11] = {};\n    char c;\n    for (int i=1; i<10; ++i) {\n        if (i % 2 == 1) {\n            for (int j=2; j<=8; j+=2) {\n                cin >> c;\n                g[i][j] = c - '0';\n                g[i][j-1] |= g[i][j];\n                g[i][j+1] |= g[i][j];\n            }\n        } else {\n            for (int j=1; j<=9; j+=2) {\n                cin >> c;\n                g[i][j] = c - '0';\n                g[i-1][j] |= g[i][j];\n                g[i+1][j] |= g[i][j];\n            }\n        }\n    }\n    int x = 1, y = 1, d = 0;\n    do {\n        for (int t=3; t<=6; ++t) {\n            if (g[y + dy[(d + t) % 4]][x + dx[(d + t) % 4]]) {\n                d = (d + t) % 4;\n                break;\n            }\n        }\n        x += dx[d] * 2;\n        y += dy[d] * 2;\n        cout << dc[d];\n    } while ( ! (x == 1 && y == 1));\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[100];\nint len;\nint fie[101][101];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=9;\n\tfor(int i=0;i<10;i++)cin >> str[i];\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else dir=(dir+1)%4;\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n\n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n            \tcheckTable[i][k][p] = 0;\n            }\n        }\n    }\n\n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n\n    printf(\"R\");\n    char current = 'R';\n\n    checkTable[0][0][1] = 1;\n\n    row = 0,col = 0;\n\n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else if(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                col++;\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else if(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n                col--;\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else if(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n               row -= 2;\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else if(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else{\n            \tprintf(\"U\");\n            \tcheckTable[row][col][2] = 1;\n            \tcurrent = 'U';\n            \trow += 2;\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n\n   printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n    static bool wall[6][6][4];\n    const int dx[4] = { 1, 0, -1, 0 };\n    const int dy[4] = { 0, 1, 0, -1 };\n    REP(i,6) REP(j,6) REP(k,4) {\n        int ni = i + dy[k];\n        int nj = j + dx[k];\n        if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n            wall[i][j][k] = 0;\n        }\n        else {\n            wall[i][j][k] = 1;\n        }\n    }\n    \n    string s;\n    for(int i = 0; i < 4; i++) {\n        getline(cin, s);\n        for(int j = 0; j < 4; j++) {\n            wall[i][j + 1][1] = (s[j] == '1');\n            wall[i + 1][j + 1][3] = (s[j] == '1');\n        }\n        getline(cin, s);\n        for(int j = 0; j < 5; j++) {\n            wall[i + 1][j][0] = (s[j] == '1');\n            wall[i + 1][j + 1][2] = (s[j] == '1');\n        }\n    }\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n        wall[4][j + 1][1] = (s[j] == '1');\n        wall[5][j + 1][3] = (s[j] == '1');\n    }\n\n    string icon = \"RDLU\";\n#if 0\n    REP(i,6) REP(j,6) {\n        cerr << \"(\" << i << \",\" << j << \")\";\n        REP(k,4) {\n            if(wall[i][j][k] == false) cerr << icon[k];\n        }\n        cerr << endl;\n    }\n#endif\n\n    int X = 1, Y = 0, dir = 0;\n    string ans = \"R\";\n    do {\n#if 0\n        cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n        if(wall[Y][X][dir] == 1) {\n            dir = (dir - 1 + 4) % 4;\n            ans.push_back(icon[dir]);\n        }\n        else {\n            Y += dy[dir];\n            X += dx[dir];\n            if(wall[Y][X][(dir+1)%4]==1) {\n                ans.push_back(icon[dir]);\n            }\n            else {\n                dir = (dir + 1) % 4;\n                Y += dy[dir];\n                X += dx[dir];\n                if(wall[Y][X][(dir+1)%4]==1) {\n                    ans.push_back(icon[dir]);\n                }\n                else {\n                    dir = (dir + 1) % 4;\n                    ans.push_back(icon[dir]);\n                }\n            }\n        }\n    } while(!(X == 1 && Y == 1 && dir == 2));\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n#define RIGHT 0\n#define DOWN 1\n#define LEFT 2\n#define UP 3\n\nint main(){\n\tbool cross[5][5][4];\t// x,y,dir\n\tint px=0, py=0, dir = RIGHT;\n\tint d[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\n\tstring str;\n\tmemset( cross, 0, sizeof(cross) );\n\tfor( int i=0; i<4; i++ ){\n\t\tgetline( cin, str );\n\t\tfor( int j=0; j<4; j++ ){\n\t\t\tcross[j][i][RIGHT] = cross[j+1][i][LEFT] = (str[j]=='1');\n\t\t}\n\t\tgetline( cin, str );\n\t\tfor( int j=0; j<5; j++ ){\n\t\t\tcross[j][i][DOWN] = cross[j][i+1][UP] = (str[j]=='1');\n\t\t}\n\t}\n\tgetline( cin, str );\n\tfor( int j=0; j<4; j++ ){\n\t\tcross[j][4][RIGHT] = cross[j+1][4][LEFT] = (str[j]=='1');\n\t}\n\tdo{\n\t\tfor( int i=0; i<4; i++ ){\n\t\t\tif( cross[px][py][(dir+3+i)%4] ){\n\t\t\t\tdir = (dir+3+i)%4;\n\t\t\t\tpx += d[dir][0];\n\t\t\t\tpy += d[dir][1];\n//\t\t\t\tcout << (dir==RIGHT)?\"R\":((dir==DOWN)?\"D\":((dir==LEFT)?\"L\":\"U\"));\n\t\t\t\tif( dir == RIGHT ){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t}else if( dir == DOWN ){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t}else if( dir == LEFT ){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t}else if( dir == UP ){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while( px!=0 || py!=0 );\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG 0\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[15][15];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U', 'R', 'D', 'L' };\n\nstring res;\nvoid touch_wall (int row, int col, int dir, int hand )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n\tstring s = \"\";\n\tfor (int i = 1;getline (cin, s ); i++  ){\n//\t\tif (getline (cin, s ) )\n//\t\tgetline (cin, s );\n//\t\tcin >> s;\n//\t\tif (s.empty() ) break;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j+1] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j+1] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j] |= 1<<RIGHT;\n\t\t\t\t\tgrid[i/2][j+1] |= 1<<LEFT;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n\n#if DEBUG2\n\trep (i, 15 ){\n\t\trep (j, 15 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n#endif\n\tint row = 0, col = 1, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tres = \"\";\n\tdo{\n\t\ttouch_wall (row, col, dir, hand );\n\t\tif (((1<<hand) & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった、なくなった方向に回転\n\t\t\tdir = hand;\n\t\t}else{\n\t\t\twhile (((1<<dir) & grid[row][col] ) != 0 ){ // 右手の壁があったとしても前に進めない\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand );\n\t\t\t} // end while \n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t}while (!(row == 0 && col == 0 ) ); // end while\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nstring vec=\"RULD\";\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4!=0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\n\n\nint main() {\n    int dp[5][5][4] = {};\n    string d = \"RDLU\";\n    array<int, 4> dy{0, 1, 0, -1}, dx{1, 0, -1, 0};\n    for (int i = 0; i < 9; ++i) {\n        string s;\n        cin >> s;\n        if(i&1){\n            for (int j = 0; j < 5; ++j) {\n                if(s[j] == '1'){\n                    dp[i/2][j][1] = dp[i/2+1][j][3] = 1;\n                }\n            }\n        }else {\n            for (int j = 0; j < 4; ++j) {\n                if(s[j] == '1'){\n                    dp[i/2][j][0] = dp[i/2][j+1][2] = 1;\n                }\n            }\n        }\n    }\n    int y = 0, x = 0, cur = 0, started = 0;\n    for (int i = 0; !started || y || x; ++i) {\n        if(dp[y][x][(cur+3)&3]){\n            cur = (cur+3)&3;\n            cout << d[cur];\n            y += dy[cur], x += dx[cur];\n        } else if(dp[y][x][cur]){\n            started = 1;\n            cout << d[cur];\n            y += dy[cur]; x += dx[cur];\n        }else cur = (cur+1)&3;\n    }\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar horz[5][4+1];\nchar vert[4][5+1];\nint x, y, vx, vy;\n\nvoid turn_left() {\n\tint temp = vx;\n\tvx = vy;\n\tvy = -temp;\n}\n\nvoid turn_right() {\n\tint temp = vx;\n\tvx = -vy;\n\tvy = temp;\n}\n\ninline bool ok(char c) { return (c == '1'); }\n\nbool avail() {\n\tif (vx == 1) {\n\t\tif (x < 4 && ok(horz[y][x]))\n\t\t\treturn true;\n\t} else if (vx == -1) {\n\t\tif (x > 0 && ok(horz[y][x-1]))\n\t\t\treturn true;\n\t} else if (vy == 1) {\n\t\tif (y < 4 && ok(vert[y][x]))\n\t\t\treturn true;\n\t} else /* if (vy == -1) */ {\n\t\tif (y > 0 && ok(vert[y-1][x]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid print() {\n\tif (vx == 1) cout << \"R\";\n\telse if (vx == -1) cout << \"L\";\n\telse if (vy == 1) cout << \"D\";\n\telse /* if (vy == -1) */ cout << \"U\";\n}\n\nint main() {\n\tfor (int i = 0; i < 4; i++)\n\t\tcin >> horz[i] >> vert[i];\n\tcin >> horz[4];\n\n\tx=0, y=0, vx=0, vy=-1;\n\tdo {\n\t\twhile (!avail()) turn_right();\n\t\tprint();\n\t\tx += vx, y += vy;\n\t\tturn_left();\n\t} while (x != 0 || y != 0);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n/*\nconst int dx[4] = {-1,0,0,0};\nconst int dy[4] = {0,-1,0,0};\nconst int dx2[4] = {-1,0,1,0};\nconst int dy2[4] = {0,1,0,-1};\n*/\nstatic const int dx[4] = {1,0,-1,0};\nstatic const int dy[4] = {0,1,0,-1};\nint main(void){\n  int d = 0;\n  /*\n  int a[5][4];\n  int b[4][5];\n  */\n  int m[9][9];\n  int x=0,y=0;\n  string tmp;\n  /*\n  for(int i=0; i<4; i++){\n    for(int j=0; j<4; j++){\n      c = getchar();\n      a[i][j] = c - '0';\n    }\n    getchar();\n    for(int j=0; j<5; j++){\n      c = getchar();\n      b[i][j] = c - '0';\n    }\n    getchar();\n  }\n  for(int j=0; j<4; j++){\n    c = getchar();\n    a[4][j] = c - '0';\n  }\n  */\n  for(int i=0; i<9; i++){\n    cin>>tmp;\n    int jbegin;\n    if(i%2){\n      jbegin=0;\n    }else{\n      jbegin=1;\n    }\n    for(int j=jbegin,k=0; j<9; j+=2,k++){\n      m[i][j] = tmp[k];\n    }\n  }\n  for(int time=0; time>-1; time++){\n    for(int r=-1; r<3; r++){\n      //printf(\"%d\",(d+r+4)%4);\n      if(y+dy[(d+r+4)%4]>=0&&y+dy[(d+r+4)%4]<=8\n          &&x+dx[(d+r+4)%4]>=0&&x+dx[(d+r+4)%4]<=8&&\n          m[y+dy[(d+r+4)%4]][x+dx[(d+r+4)%4]]=='1'){\n        d = (d+r+4)%4;\n        x += 2*dx[d];\n        y += 2*dy[d];\n        break;\n      }\n    }\n    char out;\n    switch(d){\n      case 0:\n        out = 'R';\n        break;\n      case 1:\n        out = 'D';\n        break;\n      case 2:\n        out = 'L';\n        break;\n      case 3:\n        out = 'U';\n        break;\n    }\n    putchar(out);\n    //printf(\"%d,%d\\n\",x,y);\n    if(x==0&&y==0) break;\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define for0(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nstring s[10];\nint x, y, d = 1;\nbool fU() {\n\tif (y == 0)return 0;\n\telse return s[y * 2 - 1][x] == '1';\n}\nvoid mU() { cout << \"U\"; y--; return; }\nbool fD() {\n\tif (y == 4)return 0;\n\telse return s[y * 2 + 1][x] == '1';\n}\nvoid mD() { cout << \"D\"; y++; return; }\nbool fL() {\n\tif (x == 0)return 0;\n\telse return s[y * 2][x - 1] == '1';\n}\nvoid mL() { cout << \"L\"; x--; return; }\nbool fR() {\n\tif (x == 4)return 0;\n\telse return s[y * 2][x] == '1';\n}\nvoid mR() { cout << \"R\"; x++; return; }\nsigned main() {\n\tfor0(i, 9)cin >> s[i];\n\tmR();\n\twhile (x + y > 0) {\n\t\tfor0(i, 4) {\n\t\t\tif ((i + 3 + d) % 4 == 0) {\n\t\t\t\tif (fU()) { mU(); d = 0; break; }\n\t\t\t}\n\t\t\telse if ((i + 3 + d) % 4 == 1) {\n\t\t\t\tif (fR()) { mR(); d = 1; break; }\n\t\t\t}\n\t\t\telse if ((i + 3 + d) % 4 == 2) {\n\t\t\t\tif (fD()) { mD(); d = 2; break; }\n\t\t\t}\n\t\t\telse if ((i + 3 + d) % 4 == 3) {\n\t\t\t\tif (fL()) { mL(); d = 3; break; }\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main(){\n\n\t//while(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t//\tif(cin.eof())\n\t//\t\tbreak;\n\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tcin>>yoko[i][j];\n\t\t\t}\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tcin>>tate[i][j];\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0)\n\t\t\t\tbreak;\n}\ncout<<endl;\n//}\n\t\t\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dx[]{ 0,1,0,-1 }, dy[]{ 1,0,-1,0 };\nchar dir[] = \"RDLU\";\nint main() {\n\tvector<pair<P, P>>v;\n\trep(i, 9) {\n\t\trep(j, i & 1 ? 5 : 4) {\n\t\t\tint d; scanf(\"%1d\", &d);\n\t\t\tif (d) {\n\t\t\t\tif (i & 1)v.push_back({ {i / 2,j},{i / 2 + 1,j} });\n\t\t\t\telse v.push_back({ {i / 2,j},{i / 2,j + 1} });\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint id = 0, x = 0, y = 0;\n\tdo {\n\t\tint nx = x + dx[(id + 3) % 4], ny = y + dy[(id + 3) % 4];\n\t\tP a(x, y), b(nx, ny); if (a > b)swap(a, b);\n\t\tif (binary_search(v.begin(), v.end(), make_pair(a, b))) {\n\t\t\tid = (id + 3) % 4; x += dx[id]; y += dy[id];\n\t\t}\n\t\telse {\n\t\t\tnx = x + dx[id], ny = y + dy[id];\n\t\t\tP a(x, y), b(nx, ny); if (a > b)swap(a, b);\n\t\t\tif (!binary_search(v.begin(), v.end(), make_pair(a, b))) {\n\t\t\t\tid = (id + 1) % 4; x += dx[id]; y += dy[id];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx += dx[id]; y += dy[id];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%c\", dir[id]);\n\t} while (x != 0 || y != 0);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar w[9][6];\n\nbool is_up(int x, int y){\n\tif(y <= 0){ return false; }\n\treturn w[y*2-1][x] == '1';\n}\n\nbool is_down(int x, int y){\n\tif(y >= 4){ return false; }\n\treturn w[y*2+1][x] == '1';\n}\n\nbool is_left(int x, int y){\n\tif(x <= 0){ return false; }\n\treturn w[y*2][x-1] == '1';\n}\n\nbool is_right(int x, int y){\n\tif(x >= 4){ return false; }\n\treturn w[y*2][x] == '1';\n}\n\nint main(void){\n\tchar r[100];\n\tint st = 0;\n\tint px=0, py=0;\n\tfor(int i=0;i<9;++i){\n\t\tscanf(\"%s\", w+i);\n\t}\n\n\tr[st++] = 'R';\n\tpx=1;\n\n\twhile(px!=0 || py!=0){\n\t\tswitch(r[st-1]){\n\t\tcase 'U':\n\t\t\tif(is_left(px, py)){ r[st++] = 'L'; px--; }\n\t\t\telse if(is_up(px, py)){ r[st++] = 'U'; py--; }\n\t\t\telse if(is_right(px, py)){ r[st++] = 'R'; px++; }\n\t\t\telse{ r[st++] = 'D'; py++; }\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(is_up(px, py)){ r[st++] = 'U'; py--; }\n\t\t\telse if(is_right(px, py)){ r[st++] = 'R'; px++; }\n\t\t\telse if(is_down(px, py)){ r[st++] = 'D'; py++; }\n\t\t\telse{ r[st++] = 'L'; px--; }\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(is_right(px, py)){ r[st++] = 'R'; px++; }\n\t\t\telse if(is_down(px, py)){ r[st++] = 'D'; py++; }\n\t\t\telse if(is_left(px, py)){ r[st++] = 'L'; px--; }\n\t\t\telse{ r[st++] = 'U'; py--; }\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif(is_down(px, py)){ r[st++] = 'D'; py++; }\n\t\t\telse if(is_left(px, py)){ r[st++] = 'L'; px--; }\n\t\t\telse if(is_up(px, py)){ r[st++] = 'U'; py--; }\n\t\t\telse{ r[st++] = 'R'; px++; }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tputs(\"error\");\n\t\t\tbreak;\n\t\t}\n\t\t//printf(\"%d,%d\\n\",px,py);\n\t}\n\tr[st] = '\\0';\n\tputs(r);\n\t//getchar();getchar();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint main() {\n\tint g[100][100];\n\tmemset(g, 0, sizeof(g));\n\trep(i, 9) rep(j, 4 + i % 2) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tg[i + 1][j * 2 + (i + 1) % 2 + 1] = c - '0';\n\t}\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {-1, 0, 1, 0};\n\tchar c[] = \"URDL\";\n\tint x = 2, y = 0, v = 1;\n\tdo {\n\t\tcout << c[v];\n\t\tint pv = (v - 1 + 4) % 4;\n\t\tint nv = (v + 1) % 4;\n\t\t\n\t\tif (g[y + dy[v]][x + dx[v]] == 1) {\n\t\t\tv = pv;\n\t\t}\n\t\telse if (g[y + dy[v] * 2 + dy[nv]][x + dx[v] * 2 + dx[nv]] == 1) {\n\t\t\tx += dx[v] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t}\n\t\telse {\n\t\t\tx += dx[v] * 2;\n\t\t\tx += dx[nv] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t\ty += dy[nv] * 2;\n\t\t\tv = nv;\n\t\t}\n\t\tif (x == 0 && y == 0) break;\n\t\tif (x == 2 && y == 0) break;\n\t} while(true);\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  bool w[11][11]={{}};\n  for(int i=1;i<=9;i++){\n    for(int j=1+i%2;j<10;j+=2){\n      char c;\n      cin>>c;\n      w[i][j]=c-'0';\n    }\n  }\n  int y=0,x=2;\n  int d=1;\n  int dy[]={-1,0,1,0};\n  int dx[]={0,1,0,-1};\n  do{\n    const char *s=\"URDL\";\n    d=(d+1)%4;\n    while(w[y+dy[d]][x+dx[d]]){\n      cout<<s[(d+3)%4];\n      d=(d+3)%4;\n    }\n    y+=dy[d]*2;\n    x+=dx[d]*2;\n  }while(x||y>2);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nint mox[2][2]={{1,-1},{0,-1}},moy[2][2]={{-1,1},{-1,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4;\n        if(now%2==0){\n            if(y+moy[0][now/2]<5&&y+moy[0][now/2]>-1&&side[y+moy[1][now/2]][x]=='1'){\n                cout<<str[now];\n                serch(x,y+moy[0][now/2],now-1);\n            }\n        }\n        else{\n            if(x+mox[0][now/2]<5&&x+mox[0][now/2]>-1&&Longitudinal[y][x+mox[1][now/2]]=='1'){\n                cout<<str[now];\n                serch(x+mox[0][now/2],y,now-1);\n            }\n        }\n    }\n}\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define N 10\nusing namespace std;\n\nbool h[N][N]; // setinel\nbool v[N][N];\nchar dir = 'R';\nint mx = 1;\nint my = 1;\n\nbool left(){\n\tif(h[my][mx-1]){\n\t\tmx--;\n\t\tdir = 'L';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool right(){\n\tif(h[my][mx]){\n\t\tmx++;\n\t\tdir = 'R';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool up(){\n\tif(v[my-1][mx]){\n\t\tmy--;\n\t\tdir = 'U';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool down(){\n\tif(v[my][mx]){\n\t\tmy++;\n\t\tdir = 'D';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstring str, ans = \"\";\n\tint i, j, len;\n\n\ti = j = 1;\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (dir == 'L') {\n\t\t\tif(down()){\n\t\t\t}else if(left()){\n\t\t\t}else if(up()){\n\t\t\t}\n\t\t}else if (dir == 'R') {\n\t\t\tif(up()){\n\t\t\t}else if(right()){\n\t\t\t}else if(down()){\n\t\t\t}\n\t\t}else if (dir == 'U') {\n\t\t\tif(left()){\n\t\t\t}else if(up()){\n\t\t\t}else if(right()){\n\t\t\t}\n\t\t}else if (dir == 'D') {\n\t\t\tif(right()){\n\t\t\t}else if(down()){\n\t\t\t}else if(left()){\n\t\t\t}\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-10;\n\nint main() {\n\tstring s[16], ans(\"R\");\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tint x = 0, y = 0;\n\tint d = 0; // 0:right, 1:down, 2:left, 3:up\n\tbool flag = false;\n\twhile(1){\n\t\tif(d == 0){\n\t\t\tif(s[y][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x + 1] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\tx += 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\telse if(d == 1){\n\t\t\tif(s[y + 2][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 2;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\ty += 1;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y + 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 2){\n\t\t\tif(s[y][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\telse if(d == 3){\n\t\t\tif(y >= 3 && s[y - 2][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 2;\n\t\t\t}\n\t\t\telse if(s[y - 1][x] == '1'){\n\t\t\t\ty -= 1;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y - 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\ty -= 1;\n\t\t\t\tx -= 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\t/*if(x == 1 && y == 8 && flag)\n\t\t\tbreak;\n\t\tif(x == 1 && y == 8){\n\t\t\tflag = true;\n\t\t\t//break;\n\t\t}*/\n\t\tif(x == 0 && y == 0)\n\t\t\tbreak;\n\t}\n\t/*cout << s[8][3] << endl;\n\tcout << d << endl;*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char ch[] = {\"ULDR\"};\n\nbool g[10][10][10][10];\n\nint main()\n{\n\tchar c;\n\t\n\tfor (int i = 1; i <= 5; i++){\n\t\tfor (int j = 1; j <= 4; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i][j + 1] = true;\n\t\t\tg[i][j + 1][i][j] = true;\n\t\t}\n\t\tif (i == 5) continue;\n\t\tfor (int j = 1; j <= 5; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i + 1][j] = true;\n\t\t\tg[i + 1][j][i][j] = true;\n\t\t}\n\t}\n\t\n\tint dir = 3;\n\tint x = 1, y = 2;\n\twhile (true){\n\t\tprintf(\"%c\", ch[dir]);\n\t\tif (x == 1 && y == 1) break;\n\t\tfor (int t = 1; t >= -1; t--){\n\t\t\tint nd = (dir + t + 4) % 4;\n\t\t\tint nx = x + dx[nd];\n\t\t\tint ny = y + dy[nd];\n\t\t\tif (g[x][y][nx][ny]){\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t\tdir = nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\nconst char d[4] = {'L', 'U', 'R', 'D'};\n  \nint main()\n{\n    char ch;\n    bool G[6][6][4];\n    memset(G, 0, sizeof(G));\n    for (int i = 0; i < 9; i++) {\n\tint d = i%2;\n\tfor (int j = 0; j < 4+d; j++) {\n\t    cin >> ch;\n\t    if (ch == '1') {\n\t\tif (d % 2) {\n\t\t    G[i/2+1][j][2] = G[i/2+1][j+1][0] = 1;\n\t\t} else {\n\t\t    G[i/2][j+1][3] = G[i/2+1][j+1][1] = 1;\n\t\t}\n\t    }\n\t}\n    }\n    int x = 1, y = 0, dir = 2;\n    string ans;\n    while(1){\n\tif (!x && !y) break;\n\tans += d[dir];\n\tint rh = (dir+1) % 4;\n\tif (G[y][x][dir]) {\n\t    dir--;\n\t    dir = (dir == -1 ? 3 : dir);\n\t} else if (!G[y+dy[dir]][x+dx[dir]][rh]) {\n\t    x += dx[dir], y += dy[dir];\n\t    if (!x && !y) break;\n\t    x += dx[rh], y += dy[rh];\n\t    dir = rh;\n\t    int nrh = (rh+1) % 4;\n\t    if (!G[y][x][nrh] && !(!x && !y)) {\n\t\tx += dx[nrh], y += dy[nrh];\n\t\tdir = nrh;\n\t    }\n\t} else {\n\t    x += dx[dir]; y += dy[dir];\n\t}\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nstring vec=\"RULD\";\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4==1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nenum Direction {R, L, U, D};\n\nbool input(char b[][5])\n{\n\tchar dummy;\n\tfor (int i=0; i<9; i++) {\n\t\tfor (int j=0; j<5; j++) {\n\t\t\tif ((i&1)==0 && j==4) continue;\n\t\t\tif ( !(cin >> b[i][j]) ) return false;\n\t\t}\n\t\t//cin >> dummy;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tchar board[9][5];\n\tinput(board);\n\t\n\tpair<int, int> curr_pos = (board[1][0] == '1') ? pair<int,int>(1,0) : pair<int,int>(0,0);\n\tenum Direction curr_dir = (board[1][0] == '1') ? D : R;\n\tif (curr_dir == D) cout << D;\n\telse cout << R;\n\t\n\tdo {\n\t\tswitch (curr_dir) {\n\t\tcase R:\n\t\t\t// priority : U > R > D\n\t\t\tif ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--; curr_pos.second++;\n\t\t\t} else if ( curr_pos.second < 3 && board[curr_pos.first][curr_pos.second+1] == '1' ){\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.second++;\n\t\t\t} else {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++; curr_pos.second++;\n\t\t\t} \n\t\t\tbreak;\n\t\tcase L:\n\t\t\t// priority : D > L > U\n\t\t\tif ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.second--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\t// priority : L > U > R\n\t\t\tif ( curr_pos.second > 0 && board[curr_pos.first-1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first--; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 2 && board[curr_pos.first-2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first-=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\t// priority : R > D > L\n\t\t\tif ( board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.first < 6 && board[curr_pos.first+2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first+=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first++; curr_pos.second--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ( curr_pos.first != 0 || curr_pos.second != 0 );\n\t\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "ツづ卍つーツつ「"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main() {\n  char w[9][9],e[5]=\"URDL\";\n  int x=0,y=0,h=1,i,g;\n  int dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n  for (i=0;i<9;i++) gets(w[i]);\n  while(true) {\n   h=(h+3) % 4;\n   for (i=0;i<4;i++) {\n\t   if (y+dy[h]>=0 && y+dy[h]<=4 && x+dx[h]>=0 && x+dx[h]<=4) {\n          if (dx[h]==-1) g=-1; else g=0;\n\t\t  if (w[2*y+dy[h]][x+g]=='1') break;\n\t   }\n\t   \t  h=(h+1) % 4;\n   }\n   x+=dx[h]; y+=dy[h];\n   cout << e[h];\n   if (x==0 && y==0) break;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can[10][10][4];\n\n// RDLU\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstring answer;\nint dfs(int y,int x,int py,int px,int d){\n\n\tif( py != -1 ){\n\t\tif( y == py ){\n\t\t\tif( x - px > 0 ) answer += \"R\"; else answer += \"L\";\n\t\t}else{\n\t\t\tif( y - py > 0 ) answer += \"D\"; else answer += \"U\";\n\t\t}\n\t}\n\tif( py != -1 && x == 0 && y == 0 ) return 0;\n\t//cout << y << \" \" << x << \" \" << can[y][x][0] << \" \" << can[y][x][1] << \" \" << can[y][x][2] << \" \" << can[y][x][3] << \" \" << endl;\n\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( can[y][x][(i+d)%4]  ){\n\t\t\tint tx = x + dx[(i+d)%4];\n\t\t\tint ty = y + dy[(i+d)%4];\n\t\t\tif( tx == px && ty == py ) continue;\n\t\t\tcan[y][x][(i+d)%4] = 0;\n\t\t\tdfs(ty,tx,y,x,(i+d)%4);\n\t\t\treturn 0;\n\t\t}\n\t}\n}// RDLU\nint main(){\n\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tif( i % 2 ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][1] = 1;\n\t\t\t\t\tcan[i/2+1][j][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][0] = 1; \n\t\t\t\t\tcan[i/2][j+1][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0,0,-1,-1,0);\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nstring e = \"RDLU\";\nstring s[9]; bool d[6][6][4];\nint main() {\n\tfor (int i = 0; i < 9; i++) cin >> s[i];\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[i * 2][j] == '1') d[i][j + 1][1] = d[i + 1][j + 1][3] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tif (s[i * 2 + 1][j] == '1') d[i + 1][j][0] = d[i + 1][j + 1][2] = true;\n\t\t}\n\t}\n\tstring ret = \"R\";\n\tint x = 0, y = 1, dr = 0;\n\twhile (true) {\n\t\tif (d[x][y][dr]) dr = (dr + 3) & 3, ret += e[dr];\n\t\telse {\n\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\tif (x == 0 && y == 1) break;\n\t\t\tint cnt = 0;\n\t\t\twhile (!d[x][y][(dr + 1) & 3]) {\n\t\t\t\tdr = (dr + 1) & 3;\n\t\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\t\tif (x == 0 && y == 1) break;\n\t\t\t}\n\t\t\tif (x == 0 && y == 1) break;\n\t\t\tret += e[dr];\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool t[222][222][4];\nint w,h,n,a[202][202];\nint seach(int x,int y,int d){\n \n  int turn =1,p=0;\n   \n  while(1){\n    if(t[y][x][d])break;\n    t[y][x][d]=1;\n    if(!p){\n      if(d==3)cout<<'R';\n      if(d==2)cout<<'U';\n      if(d==1)cout<<'L';\n      if(d==0)cout<<'D';\n    }\n    p=0;\n\n    \n    if(d==0){\n        if(a[y+1][x]==1)d=3;\n    else if(a[y+2][x]==0){\n      if(a[y+2][x-1]==1)y+=2;\n      else d=1,y+=2,p++;\n    }\n \n    }\n    else if(d==1){\n        if(a[y][x-1]==1)d=0;\n    else if(a[y][x-2]==0){\n      if(a[y-1][x-2]==1)x-=2;\n      else d=2,x-=2,p++;\n    }\n \n    }\n    else if(d==2){\n        if(a[y-1][x]==1)d=1;\n    else if(a[y-2][x]==0){\n      if(a[y-2][x+1]==1)y-=2;\n      else d=3,y-=2,p++;\n    }\n \n    }\n    else if(d==3){\n        if(a[y][x+1]==1)d=2;\n    else if(a[y][x+2]==0){\n      if(a[y+1][x+2]==1)x+=2;\n      else d=0,x+=2,p++;\n    }\n \n      }\n\n  }\n}\nint main(){\n\n    memset(a,0,sizeof(a));\n\n    for(int i=0;i<9;i++){\n      string x;\n      cin>>x;\n      if(i%2){\n        for(int j=0;j<5;j++)if(x[j]=='1')\n          a[i+3][j*2+3]=1;\n      }\n      else{\n        for(int j=0;j<4;j++)if(x[j]=='1')\n          a[i+3][j*2+1+3]=1;\n      }\n    }\n    for(int i=0;i<20;i++){\n      for(int j=0;j<20;j++)\n        cout<<a[i][j];cout<<endl;\n    }\n    seach(4,2,3);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n \nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n \nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n \n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n                checkTable[i][k][p] = 0;\n            }\n        }\n    }\n \n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n \n    printf(\"R\");\n    char current = 'R';\n \n    checkTable[0][0][1] = 1;\n \n    row = 0,col = 0;\n \n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else{\n                printf(\"U\");\n                checkTable[row][col][2] = 1;\n                current = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n \n   printf(\"\\n\");\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct point {\n\tint left;\n\tint down;\n\tint right;\n\tint up;\n};\n\nvoid move(point able[5][5], int& x, int& y, int& direction){\n\tswitch(direction){\n\tcase 0: \n\t\tif(able[y][x].down){\n\t\t\ty++;\n\t\t\tdirection = 3;\n\t\t\tcout << \"D\";\n\t\t}else if(able[y][x].left){\n\t\t\tx--;\n\t\t\tdirection = 0;\n\t\t\tcout << \"L\";\n\t\t}else if(able[y][x].up){\n\t\t\ty--;\n\t\t\tdirection = 1;\n\t\t\tcout << \"U\";\n\t\t}else if(able[y][x].right){\n\t\t\tx++;\n\t\t\tdirection = 2;\n\t\t\tcout << \"R\";\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif(able[y][x].left){\n\t\t\tx--;\n\t\t\tdirection = 0;\n\t\t\tcout << \"L\";\n\t\t}else if(able[y][x].up){\n\t\t\ty--;\n\t\t\tdirection = 1;\n\t\t\tcout << \"U\";\n\t\t}else if(able[y][x].right){\n\t\t\tx++;\n\t\t\tdirection = 2;\n\t\t\tcout << \"R\";\n\t\t}else if(able[y][x].down){\n\t\t\ty++;\n\t\t\tdirection = 3;\n\t\t\tcout << \"D\";\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif(able[y][x].up){\n\t\t\ty--;\n\t\t\tdirection = 1;\n\t\t\tcout << \"U\";\n\t\t}else if(able[y][x].right){\n\t\t\tx++;\n\t\t\tdirection = 2;\n\t\t\tcout << \"R\";\n\t\t}else if(able[y][x].down){\n\t\t\ty++;\n\t\t\tdirection = 3;\n\t\t\tcout << \"D\";\n\t\t}else if(able[y][x].left){\n\t\t\tx--;\n\t\t\tdirection = 0;\n\t\t\tcout << \"L\";\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif(able[y][x].right){\n\t\t\tx++;\n\t\t\tdirection = 2;\n\t\t\tcout << \"R\";\n\t\t}else if(able[y][x].down){\n\t\t\ty++;\n\t\t\tdirection = 3;\n\t\t\tcout << \"D\";\n\t\t}else if(able[y][x].left){\n\t\t\tx--;\n\t\t\tdirection = 0;\n\t\t\tcout << \"L\";\n\t\t}else if(able[y][x].up){\n\t\t\ty--;\n\t\t\tdirection = 1;\n\t\t\tcout << \"U\";\n\t\t}\n\t}\n}\n\nint main(){\n\tint direction = 3;\n\tint x = 0, y = 0;\n\tpoint able[5][5];\n\tchar c;\n\tfor(int i = 0; i < 5; i++)\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\table[i][j].left = 0;\n\t\t\table[i][j].right = 0;\n\t\t\table[i][j].down = 0;\n\t\t\table[i][j].up = 0;\n\t\t}\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin >> c;\n\t\t\tif(c == '1'){\n\t\t\t\table[i][j].right = 1;\n\t\t\t\table[i][j+1].left = 1;\n\t\t\t}\n\t\t}\n\t\tif(i == 4) break;\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tcin >> c;\n\t\t\tif(c == '1'){\n\t\t\t\table[i][j].down = 1;\n\t\t\t\table[i+1][j].up = 1;\n\t\t\t}\n\t\t}\n\t}\n\tmove(able, x, y, direction);\n\twhile(x != 0 || y != 0){\n\t\tmove(able, x, y, direction);\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\t//while(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tmemset(yoko,0,sizeof(yoko));\n\t\tmemset(tate,0,sizeof(tate));\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c;\n\t\t\t}\n\t\t\tif(i!=4){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin>>c;\n\t\t\t\t\ttate[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\tstring str=\"\";\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tstr+='R';\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tstr+='D';\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tstr+='L';\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tstr+='U';\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0){\n\t\t\t\tbreak;\n\t\t\t}\n}\n\ncout<<str<<endl;\n//break;\n\n//}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can[10][10][4];\n\n// RDLU\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstring answer;\nint dfs(int y,int x,int py,int px,int d){\n\n\tif( py != -1 ){\n\t\tif( y == py ){\n\t\t\tif( x - px > 0 ) answer += \"R\"; else answer += \"L\";\n\t\t}else{\n\t\t\tif( y - py > 0 ) answer += \"D\"; else answer += \"U\";\n\t\t}\n\t}\n\tif( py != -1 && x == 0 && y == 0 ) return 0;\n\t//cout << y << \" \" << x << \" \" << can[y][x][0] << \" \" << can[y][x][1] << \" \" << can[y][x][2] << \" \" << can[y][x][3] << \" \" << endl;\n\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( can[y][x][(i+d)%4]  ){\n\t\t\tint tx = x + dx[(i+d)%4];\n\t\t\tint ty = y + dy[(i+d)%4];\n\t\t\tif( tx == px && ty == py ) continue;\n\t\t\tcan[y][x][(i+d)%4] = 0;\n\t\t\tdfs(ty,tx,y,x,(i+d)%4);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( can[y][x][(i+d)%4]  ){\n\t\t\tcan[y][x][(i+d)%4] = 0;\n\t\t\tint tx = x + dx[(i+d)%4];\n\t\t\tint ty = y + dy[(i+d)%4];\n\t\t\t//if( tx == px && ty == py ) continue;\n\t\t\tdfs(ty,tx,y,x,(i+d)%4);\n\t\t\treturn 0;\n\t\t}\n\t}\n}// RDLU\nint main(){\n\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tif( i % 2 ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][1] = 1;\n\t\t\t\t\tcan[i/2+1][j][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][0] = 1; \n\t\t\t\t\tcan[i/2][j+1][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0,0,-1,-1,0);\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            //cout << \"(\" << y << \",\" << x << \",\" << d << \")\" << endl;\n            if (map[y][x][d])\n                ;\n            else if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nbool mas[11][11][4];\nstring s = \"LURD\";\nconst int dy[] = { 0, -1, 0, 1}, dx[] = { -1, 0, 1, 0};\n\nvoid dfs( int y, int x, int pos){\n  cout << s[pos];\n  if(!y && !x){\n    cout << endl;\n    return;\n  }\n  for(int i = 0 ; i < 4 ; i++ ){\n    int dd = ( pos + 3 + i ) % 4;\n    int ny = y + dy[ dd], nx = x + dx[ dd];\n    if(mas[y][x][dd]){\n      dfs( y + dy[ dd], x + dx[ dd], dd);\n      return;\n    }\n  }\n}\nint main(){\n  char c;\n  for(int i = 0 ; i < 9 ; i++ ){\n    if(i & 1)\n      for(int j = 0 ; j < 5 ; j++ ){\n        cin >> c;\n        if(c == '1') mas[i / 2][j][3] = mas[i / 2 + 1][j][1] = true;\n      }\n    else\n      for(int j = 0 ; j < 4 ; j++ ){\n        cin >> c;\n        if(c == '1') mas[i / 2][j][2] = mas[i / 2][j + 1][0] = true;\n      }\n  }\n  dfs( 0, 1, 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nusing namespace std;\ntypedef long long  ll;\n\n/** Problem0037 : Path on a Grid **/\nint main()\n{\n\tbool wall[6][6][4]={0};\n\tstring s;\n\tint y=1;\n\trep(k, 9) {\n\t\tcin >> s;\n\t\tif (s.length()==4) {\n\t\t\trep(x, 4) {\n\t\t\t\tif (s[x]=='1') {\n\t\t\t\t\twall[x+1][y-1][3]=true;\n\t\t\t\t\twall[x+1][y][2]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (s.length()==5) {\n\t\t\tREP(x, 1, 6) {\n\t\t\t\tif (s[x-1]=='1') {\n\t\t\t\t\twall[x-1][y][1]=true;\n\t\t\t\t\twall[x][y][0]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty++;\n\t\t}\n\t}\n\t\n\tint x=1, d=1; y=0;\n\tcout << \"R\";\n\twhile (1) {\n\t\tswitch (d) {\n\t\t\tcase 1:\n\t\t\t\tif (wall[x][y][1]) {\n\t\t\t\t\tif (wall[x][y][2]) {\n\t\t\t\t\t\td=0;\n\t\t\t\t\t\tcout << \"U\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty--; d=2;\n\t\t\t\t\t\tcout << \"RU\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x+1][y][3]) {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else if (wall[x][y+1][1]) {\n\t\t\t\t\ty++; x++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else {\n\t\t\t\t\ty++; d=0;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (wall[x][y][3]) {\n\t\t\t\t\tif (wall[x][y][1]) {\n\t\t\t\t\t\td=2;\n\t\t\t\t\t\tcout << \"R\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx++; d=1;\n\t\t\t\t\t\tcout << \"DR\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x][y+1][0]) {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else if (wall[x-1][y][3]) {\n\t\t\t\t\tx--; y++; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else {\n\t\t\t\t\tx--; d=2;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 0:\n\t\t\t\tif (wall[x][y][0]) {\n\t\t\t\t\tif (wall[x][y][3]) {\n\t\t\t\t\t\td=1;\n\t\t\t\t\t\tcout << \"D\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty++; d=3;\n\t\t\t\t\t\tcout << \"LD\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x-1][y][2]) {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else if (wall[x][y-1][0]) {\n\t\t\t\t\tx--; y--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else {\n\t\t\t\t\ty--; d=1;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (wall[x][y][2]) {\n\t\t\t\t\tif (wall[x][y][0]) {\n\t\t\t\t\t\td=3;\n\t\t\t\t\t\tcout << \"L\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx--; d=0;\n\t\t\t\t\t\tcout << \"UL\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x][y-1][1]) {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else if (wall[x+1][y][2]) {\n\t\t\t\t\tx++; y--; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else {\n\t\t\t\t\tx++; d=3;\n\t\t\t\t} break;\n\t\t}\n\t\tcout << flush;\n\t\tif (d==2 && x==0 && y==1)\n\t\t\tbreak;\n\t\tif (d==0 && x==1 && y==1) {\n\t\t\tcout << \"L\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid change(int,int);\nint wall_x[4][5],wall_y[5][4],muki = 0,flag = 0;\n\nint main(){\n\tint i,j,x = 0,y = 0;\n\tfor(i = 0;i < 9;i++){\n\t\tif(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n\t\telse for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n\t}\n\tdo{\n\t\tif(muki == 0){\n\t\t\tif(x != 4 && wall_x[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tx++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 1){\n\t\t\tif(y != 4 && wall_y[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"D\");\n\t\t\t\ty++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 2){\n\t\t\tif(x != 0 && wall_x[x - 1][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tx--;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 3){\n\t\t\tif(y != 0 && wall_y[x][y - 1] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"U\");\n\t\t\t\ty--;\n\t\t\t}else change(x,y);\n\t\t}\n\t}while(x != 0 || y != 0);\n\treturn 0;\n}\n\nvoid change(int x,int y){\n\tint i;\n\tif(!flag){\n\t\tflag = 1;\n\t\tmuki = (muki + 3) % 4;\n\t}\n\telse muki = (muki + 1) % 4;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n \nvoid input(bool grid[][9])\n{\n    rep(i,9){\n        string s;\n        cin>>s;\n        if(i%2==0)\n            rep(j,4)\n                grid[i][j*2+1]=s[j]-'0';\n        else\n            rep(j,5)a\n                grid[i][j*2]=s[j]-'0';\n    }\n}\n \nenum dir{\n    UP,RIGHT,DOWN,LEFT\n};\nconst int di[]={-1,0,1,0};\nconst int dj[]={0,1,0,-1};\nconst char output[]=\"URDL\";\n \nbool in_range(int i,int j)\n{\n    return 0<=i && i<9 && 0<=j && j<9;\n}\n \nint main()\n{\n    bool grid[9][9]={{0}};\n    input(grid);\n     \n    int i=0,j=0;\n    dir prev=RIGHT;\n    for(;;){\n        dir next[4]={LEFT,UP,RIGHT,DOWN};\n        rotate(next,next+prev,next+4);\n         \n        int k;\n        for(k=0;k<3;k++){\n            if(in_range(i+di[next[k]],j+dj[next[k]]) && grid[i+di[next[k]]][j+dj[next[k]]])\n                break;\n        }\n         \n        cout<<output[next[k]];\n         \n        i+=di[next[k]]*2;\n        j+=dj[next[k]]*2;\n        prev=next[k];\n         \n        if(i==0 && j==0)\n            break;\n    }\n    cout<<endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n  static bool wall[6][6][4];\n  const int dx[4] = { 1, 0, -1, 0 };\n  const int dy[4] = { 0, 1, 0, -1 };\n  REP(i,6) REP(j,6) REP(k,4) {\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n      wall[i][j][k] = 0;\n    }\n    else {\n      wall[i][j][k] = 1;\n    }\n  }\n\n  string s;\n  for(int i = 0; i < 4; i++) {\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n      wall[i][j + 1][1] = (s[j] == '1');\n      wall[i + 1][j + 1][3] = (s[j] == '1');\n    }\n    getline(cin, s);\n    for(int j = 0; j < 5; j++) {\n      wall[i + 1][j][0] = (s[j] == '1');\n      wall[i + 1][j + 1][2] = (s[j] == '1');\n    }\n  }\n  getline(cin, s);\n  for(int j = 0; j < 4; j++) {\n    wall[4][j + 1][1] = (s[j] == '1');\n    wall[5][j + 1][3] = (s[j] == '1');\n  }\n\n  string icon = \"RDLU\";\n#if 0\n  REP(i,6) REP(j,6) {\n    cerr << \"(\" << i << \",\" << j << \")\";\n    REP(k,4) {\n      if(wall[i][j][k]) cerr << icon[k];\n    }\n    cerr << endl;\n  }\n#endif\n\n  int X = 1, Y = 0, dir = 0;\n  string ans = \"R\";\n  do {\n#if 1\n    cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n    if(wall[Y][X][dir] == 0) {\n      Y += dy[dir];\n      X += dx[dir];\n      if(wall[Y][X][(dir + 1) % 4] == 0) {\n        dir = (dir + 1) % 4;\n        X += dx[dir];\n        Y += dy[dir];\n        if(wall[Y][X][(dir + 1) % 4] == 0) {\n          dir = (dir + 1) % 4;\n          X += dx[dir];\n          Y += dy[dir];\n          ans.push_back(icon[dir]);\n        }\n        else {\n          ans.push_back(icon[dir]);\n        }\n      }\n      else {\n        ans.push_back(icon[dir]);\n      }\n    }\n    else {\n      dir = (dir - 1 + 4) % 4;\n      ans.push_back(icon[dir]);\n    }\n  } while(!((X == 1 && Y == 0)));\n  ans.pop_back();\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> field;\n\nvoid init() {\n    string l;\n    for (int i = 0; i < 9; i++) {\n        cin >> l;\n        string line = \"\";\n        if (i % 2) {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(' ');\n                } else {\n                    line.push_back(l[j/2]);\n                }\n            }\n        } else {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(l[j/2]);\n                } else {\n                    line.push_back(' ');\n                }\n            }\n        }\n        field.push_back(line);\n    }\n}\n\n#define R 0\n#define U 1\n#define L 2\n#define D 3\n\nchar DIRSTR[] = {'R', 'U', 'L', 'D'};\n\nint main() {\n    init();\n\n    int dir = R;\n    int x = 0;\n    int y = 0;\n\n    while (true) {\n        switch (dir) {\n            case R:\n                if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                    dir = U;\n                    y -= 2;\n                    cout << DIRSTR[dir];\n                    break;\n                }\n                if (x + 2 >= 9 || field[y][x+1] == '0')  {\n                    if (!(y + 2 >= 9 || field[y+1][x] == '0')) {\n                        dir = D;\n                    } else {\n                        dir = L;\n                    }\n                } else {\n                    x += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case D:\n                if (!(x + 2 >= 9 || field[y][x+1] == '0'))  {\n                    dir = R;\n                    x += 2;\n                    cout << DIRSTR[dir];\n                    break;\n                }\n                if (y + 2 >= 9 || field[y+1][x] == '0') {\n                    if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                        dir = L;\n                    } else {\n                        dir = U;\n                    }\n                } else {\n                    y += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case L:\n                if (!(y + 2 >= 9 || field[y+1][x] == '0')) {\n                    dir = D;\n                    y += 2;\n                    cout << DIRSTR[dir];\n                    break;\n                }\n                if (x - 2 < 0 || field[y][x-1] == '0') {\n                    if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                        dir = U;\n                    } else {\n                        dir = R;\n                    }\n                } else {\n                    x -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case U:\n                if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                    dir = L;\n                    x -= 2;\n                    cout << DIRSTR[dir];\n                    break;\n                }\n                if (y - 2 < 0 || field[y-1][x] == '0') {\n                    if (!(x + 2 >= 9 || field[y][x+1] == '0'))  {\n                        dir = R;\n                    } else {\n                        dir = D;\n                    }\n                } else {\n                    y -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n        }\n        if (x == 0 && y == 0) break;\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dx[]{ 0,1,0,-1 }, dy[]{ 1,0,-1,0 };\nchar dir[] = \"RDLU\";\nbool b[5][5][5][5];\nint main() {\n\trep(i, 9) {\n\t\trep(j, i & 1 ? 5 : 4) {\n\t\t\tint d; scanf(\"%1d\", &d);\n\t\t\tif (i & 1)b[i / 2][j][i / 2 + 1][j] = b[i / 2 + 1][j][i / 2][j] = d;\n\t\t\telse b[i / 2][j][i / 2][j + 1] = b[i / 2][j + 1][i / 2][j] = d;\n\t\t}\n\t}\n\tint id = 0, x = 0, y = 0;\n\tdo {\n\t\tfor (int i = 3; i <= 6; i++) {\n\t\t\tint nx = x + dx[(id + i) % 4], ny = y + dy[(id + i) % 4];\n\t\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5 && b[x][y][nx][ny]) {\n\t\t\t\tx = nx; y = ny; (id += i) %= 4; printf(\"%c\", dir[id]); break;\n\t\t\t}\n\t\t}\n\t} while (x != 0 || y != 0);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sec second\nint angle=0;\nint edge[6][6][4]={0};\nvector<int> ans;\nP now;\nP nextpoint(P t,int angl)\n{\n\tP f;\n\tf.fi=t.fi;\n\tf.sec=t.sec;\n\tif(angl==0)\n\t{\n\t\tf.sec++;\n\t}\n\tif(angl==1)\n\t{\n\t\tf.fi++;\n\t}\n\tif(angl==2)\n\t{\n\t\tf.sec--;\n\t}\n\tif(angl==3)\n\t{\n\t\tf.fi--;\n\t}\n\treturn f;\n}\nvoid output(int n)\n{\n\tif(n==0)\n\t{\n\t\tcout << 'R';\n\t}\n\telse if(n==1)\n\t{\n\t\tcout << 'D';\n\t}\n\telse if(n==2)\n\t{\n\t\tcout << 'L';\n\t}\n\telse\n\t{\n\t\tcout << 'U';\n\t}\n\treturn ;\n}\nvoid step()\n{\n\tint tmp;\n\tint ans;\n\ttmp=(angle+4-1)%4;\n\twhile(1)\n\t{\n\t\tif(edge[now.fi][now.sec][tmp])break;\n\t\ttmp=(tmp+1)%4;\n\t}\n\tangle=tmp;\n\tP r;\n\tr.fi=nextpoint(now,angle).fi;\n\tr.sec=nextpoint(now,angle).sec;\n\tnow.fi=r.fi;\n\tnow.sec=r.sec;\n\treturn ;\n}\nint main()\n{\n\tnow.fi=1;now.sec=1;\n\tfor(int i=1;i<=9;i++)\n\t{\n\t\tif(i%2==1)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tedge[(i+1)/2][j+1][0]=s[j]-'0';\n\t\t\t\tedge[(i+1)/2][j+2][2]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tedge[i/2][j+1][1]=s[j]-'0';\n\t\t\t\tedge[i/2+1][j+1][3]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tstep();\n\t\tans.pb(angle);\n\t\tif(now.fi==1&&now.sec==1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\toutput(ans[i]);\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nchar RideBack[9][9],T[6],ans[4]={'L','U','R','D'};int a[4][2]={-1,0,0,-1,1,0,0,1};bool OK=true;\nvoid dfs(int x, int y, int w, int deep) {if (deep) printf(\"%c\",ans[w]);if (!x && !y && deep) OK=false;for (int j=(w+3)&3;OK;j=(j+1)&3) {int n_x=x+a[j][0],n_y=y+a[j][1];if (n_x>=0 && n_x<9 && n_y>=0 && n_y<9 && RideBack[n_y][n_x]=='1') dfs(x+a[j][0]*2,y+a[j][1]*2,j,deep+1);}}\nint main() {int i,j,k;for (i=0;i<9;i++) {scanf(\"%s\",&T);if (i&1) for (k=0,j=0;j<5;RideBack[i][k]=T[j++],k+=2); else for (k=1,j=0;j<4;RideBack[i][k]=T[j++],k+=2);}dfs(0,0,1,0);puts(\"\");return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can[40][40];\nint inside[40][40];\n\n// DLUR\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\n\nstring answer;\n\nvector<int> v;\nint dfs(int x,int y,int hand){\n\tif(x == 1 && y == 2 ) return 0;\n\t//cout << x << \" \" << y << endl;\n\t\n\tif( !can[y+dy[hand]][x+dx[hand]] ){\n\t\t//v.push_back(hand);\n\t\ty += dy[hand];\n\t\tx += dx[hand];\n\t\thand = (hand+1)%4;\n\t\t\n\t}\n\tif( can[y+dy[(hand+3)%4]][x+dx[(hand+3)%4]] ){\n\t\tdo{\n\t\t\thand = (hand+1)%4;\n\t\t}while(!can[y+dy[hand]][x+dx[hand]]);\n\t\tv.push_back(hand);\n\t}\n\tv.push_back(hand);\n\tdfs(x+dx[(hand+3)%4],y+dy[(hand+3)%4],hand);\n\t\n}\nint main(){\n\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tif( i % 2 ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[1+i/2*3][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+1][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+2][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+3][1+3*j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2*3+1][1+j*3+0] = 1; \n\t\t\t\t\tcan[i/2*3+1][1+j*3+1] = 1;\n\t\t\t\t\tcan[i/2*3+1][1+j*3+2] = 1;  \n\t\t\t\t\tcan[i/2*3+1][1+j*3+3] = 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1,0,0);\n\tv.push_back(-1);\n\tint idx = 0;\n\tfor(int i = 1 ; i < v.size() ; i++){\n\t\tif( v[i] != v[i-1] ){\n\t\t\tint len = (i - idx);\n\t\t\t//cout << len << endl;\n\t\t\tcout << string((len+1)/3,\"RDLU\"[v[idx]]);\n\t\t\tidx = i;\n\t\t}\n\t}\n\tcout << endl;\n\t\n}\n/*\nRRRRRDDDDDLLLLUUUURRRDDDLLUURULLDDDRRRUUUULLLL\nRRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <iostream>\n\n\nusing namespace std;\n\n\n\nint main()\n{\n\tbool points[5][5][4];\n\tfor (int i = 0; i < 5; ++i)\n\t\tfor (int j = 0; j < 5; ++j)\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\tpoints[i][j][k] = false;\n\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tint y = i/2;\n\t\tif (i%2 == 0)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][1] = points[y][j+1][3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][2] = points[y+1][j][0] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint x, y;\n\tx = 1;\n\ty = 0;\n\tint dir = 1;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { -1, 0, 1, 0 };\n\tchar* ds = \"URDL\";\n\tputchar(ds[dir]);\n\twhile (!(x == 0 && y == 0))\n\t{\n\t\tif (points[y][x][(dir+3)%4])\n\t\t\tdir = (dir+3)%4;\n\t\telse if (points[y][x][dir])\n\t\t\t;\n\t\telse if (points[y][x][(dir+1)%4])\n\t\t\tdir = (dir+1)%4;\n\t\telse\n\t\t\tdir = (dir+2)%4;\n\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tputchar(ds[dir]);\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint muki = 1;//0 is n,1 is e,2 is s,3 is w\n\tint t = 1, myoko= 1, mtate = 0;\n\tchar yoko[7][6], tate[7][6];\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tyoko[i][j] = '0';\n\t\t\ttate[i][j] = '0';\n\t\t}\n\t}\n\tfor(int i = 1; i < 10; i++){\n\t\tif(i % 2 != 0){\n\t\t\tfor(int j = 1; j < 5; j++){\n\t\t\t\tcin >> yoko[(i/2)+1][j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1; j < 6; j++){\n\t\t\t\tcin >> tate[j][t];\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t}\n\tcout << \"R\";\n\twhile(myoko != 0 || mtate != 0){\n\t\tif(muki == 0){\n\t\t\tif(yoko[mtate+1][myoko] == '1'){\n\t\t\t\tmyoko = myoko-1;\n\t\t\t\tcout << \"L\";\n\t\t\t\tmuki = 3;\n\t\t\t}\n\t\t\telse if(tate[myoko+1][mtate] == '1'){\n\t\t\t\tmtate = mtate-1;\n\t\t\t\tcout << \"U\";\n\t\t\t\tmuki = 0;\n\t\t\t}\n\t\t\telse if(yoko[mtate+1][myoko+1] == '1'){\n\t\t\t\tmyoko = myoko+1;\n\t\t\t\tcout << \"R\";\n\t\t\t\tmuki = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmtate = mtate+1;\n\t\t\t\tcout << \"D\";\n\t\t\t\tmuki = 2;\n\t\t\t}\n\t\t}\n\t\telse if(muki == 1){\n\t\t\tif(tate[myoko+1][mtate] == '1'){\n\t\t\t\tmtate = mtate-1;\n\t\t\t\tcout << \"U\";\n\t\t\t\tmuki = 0;\n\t\t\t}\n\t\t\telse if(yoko[mtate+1][myoko+1] == '1'){\n\t\t\t\tmyoko = myoko+1;\n\t\t\t\tcout << \"R\";\n\t\t\t\tmuki = 1;\n\t\t\t}\n\t\t\telse if(tate[myoko+1][mtate+1] == '1'){\n\t\t\t\tmtate = mtate+1;\n\t\t\t\tcout << \"D\";\n\t\t\t\tmuki = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmyoko = myoko-1;\n\t\t\t\tcout << \"L\";\n\t\t\t\tmuki = 3;\n\t\t\t}\n\t\t}\n\t\telse if(muki == 2){\n\t\t\tif(yoko[mtate+1][myoko+1] == '1'){\n\t\t\t\tmyoko = myoko+1;\n\t\t\t\tcout << \"R\";\n\t\t\t\tmuki = 1;\n\t\t\t}\n\t\t\telse if(tate[myoko+1][mtate+1] == '1'){\n\t\t\t\tmtate = mtate+1;\n\t\t\t\tcout << \"D\";\n\t\t\t\tmuki = 2;\n\t\t\t}\n\t\t\telse if(yoko[mtate+1][myoko] == '1'){\n\t\t\t\tmyoko = myoko-1;\n\t\t\t\tcout << \"L\";\n\t\t\t\tmuki = 3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmtate = mtate-1;\n\t\t\t\tcout << \"U\";\n\t\t\t\tmuki = 0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(tate[myoko+1][mtate+1] == '1'){\n\t\t\t\tmtate = mtate+1;\n\t\t\t\tcout << \"D\";\n\t\t\t\tmuki = 2;\n\t\t\t}\n\t\t\telse if(yoko[mtate+1][myoko] == '1'){\n\t\t\t\tmyoko = myoko-1;\n\t\t\t\tcout << \"L\";\n\t\t\t\tmuki = 3;\n\t\t\t}\n\t\t\telse if(tate[myoko+1][mtate] == '1'){\n\t\t\t\tmtate = mtate-1;\n\t\t\t\tcout << \"U\";\n\t\t\t\tmuki = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmyoko = myoko+1;\n\t\t\t\tcout << \"R\";\n\t\t\t\tmuki = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n\nint main()\n{\n\tint field[5][5] = {{0}};\n\trep(i, 9){\n\t\tchar str[6];\n\t\tscanf(\"%s\", str);\n\t\tif(i%2){\n\t\t\trep(j, 5){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<2;\n\t\t\t\tfield[i/2+1][j] |= a;\n\t\t\t}\n\t\t}else{\n\t\t\trep(j, 4){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<1;\n\t\t\t\tfield[i/2][j+1] |= a<<3;\n\t\t\t}\n\t\t}\n\t}\n\n\tputchar('R');\n\tint y=0, x=1;\n\tint pre = 1;\n\tdo{\n\t\t// printf(\"(%d, %d)\\n\", x, y);\n\t\tpre = (pre+2)%4;\n\t\tint dire = pre;\n\t\tdo{\n\t\t\tdire = (dire + 1)%4;\n\t\t}while(!((field[y][x]>>dire)&1));\n\t\tpre = dire;\n\t\tputchar(\"URDL\"[dire]);\n\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx += dx[dire];\n\t\ty += dy[dire];\n\t}while(y!=0 || x!=0 || (field[0][0]==6 && pre==3));\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n \nusing namespace std;\n \nint d;\nint x, y;\nbool data[9][5];\n \nmain(){\n  for(int i=0;i<9;i++){\n    for(int j=0;j<5;j++){\n      data[i][j]=false;\n    }\n  }\n  for(int i=0;i<9;i++){\n    for(int j=0;j<=5;j++){\n      char c;\n      scanf(\"%c\", &c);\n      if(c=='n') break;\n      if(c=='1') data[i][j]=true;\n    }\n  }\n   \n  x=0;\n  y=0;\n  d=0;\n  for(int i=0;;i++, d++){\n    //    printf(\"(%d,%d,%d)n\", x, y, d);\n    if(d==4) d=0;\n    if(d==0){\n      if(y==0) continue;\n      if(data[2*(y-1)+1][x]){\n    cout << 'U';\n    y--;\n    d=2;\n      }\n    }else if(d==1){\n      if(x==4) continue;\n      if(data[2*y][x]){\n    cout << 'R';\n    x++;\n    d=-1;\n      }\n    }else if(d==2){\n      if(y==4) continue;\n      if(data[2*y+1][x]){\n    cout << 'D';\n    y++;\n    d=0;\n      }\n    }else if(d==3){\n      if(x==0) continue;\n      if(data[2*y][x-1]){\n    cout << 'L';\n    x--;\n    d=1;\n      }\n    }\n    if(y==0 && x==0) break;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int field[6][6]={0};\n  string s;\n  for(int i=0; i<5; i++){\n    cin >>s;\n    for(int j=0; j<4; j++){\n      if(s[j] == '1'){\n\tfield[j+1][i]+=4;\n\tfield[j+1][i+1]+=1;\n      }\n    }\n    if(i<4){\n      cin >>s;\n      for(int j=0; j<5; j++){\n\tif(s[j] == '1'){\n\t  field[j][i+1]+=2;\n\t  field[j+1][i+1]+=8;\n\t}\n      }\n    }\n  }\n  int px = 1,py=0,d=2;\n  for(int i=0;; i++){\n    if(d == 1){\n      if(!(field[px][py]&2)){px++;d = 2;}\n      else{\n\tif(field[px][py]&1){cout <<\"U\";d = 8;}\n\telse{cout <<\"U\";py--;}\n      }\n    }\n    else if(d == 2){\n      if(!(field[px][py]&4)){py++;d = 4;}\n      else{\n\tif(field[px][py]&2){cout <<\"R\";d = 1;}\n\telse{cout <<\"R\";px++;}\n      }\n    }\n    else if(d == 4){\n      if(!(field[px][py]&8)){px--;d = 8;}\n      else{\n\tif(field[px][py]&4){cout <<\"D\";d = 2;}\n\telse if(field[px][py]&8){cout <<\"D\";py++;}\n      }\n    }\n    else if(d == 8){\n      if(!(field[px][py]&1)){py--;d = 1;}\n      else{\n\tif(field[px][py]&8){cout <<\"L\";d = 4;}\n\telse{cout <<\"L\";px--;}\n      }\n    }\n    if(px == 1 && py == 0) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sec second\nint angle=0;\nint edge[6][6][4]={0};\nvector<int> ans;\nP now;\nP nextpoint(P t,int angl)\n{\n\tP f;\n\tf.fi=t.fi;\n\tf.sec=t.sec;\n\tif(angl==0)\n\t{\n\t\tf.sec++;\n\t}\n\tif(angl==1)\n\t{\n\t\tf.fi++;\n\t}\n\tif(angl==2)\n\t{\n\t\tf.sec--;\n\t}\n\tif(angl==3)\n\t{\n\t\tf.fi--;\n\t}\n\treturn f;\n}\nvoid output(int n)\n{\n\tif(n==0)\n\t{\n\t\tcout << 'R';\n\t}\n\telse if(n==1)\n\t{\n\t\tcout << 'D';\n\t}\n\telse if(n==2)\n\t{\n\t\tcout << 'L';\n\t}\n\telse\n\t{\n\t\tcout << 'U';\n\t}\n\treturn ;\n}\nvoid step()\n{\n\tint tmp;\n\tint ans;\n\ttmp=(angle+4-1)%4;\n\twhile(1)\n\t{\n\t\tif(edge[now.fi][now.sec][tmp])break;\n\t\ttmp=(tmp+1)%4;\n\t}\n\tangle=tmp;\n\tP r;\n\tr.fi=nextpoint(now,angle).fi;\n\tr.sec=nextpoint(now,angle).sec;\n\tnow.fi=r.fi;\n\tnow.sec=r.sec;\n\treturn ;\n}\nint main()\n{\n\tnow.fi=1;now.sec=1;\n\tfor(int i=1;i<=9;i++)\n\t{\n\t\tif(i%2==1)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tedge[(i+1)/2][j+1][0]=s[j]-'0';\n\t\t\t\tedge[(i+1)/2][j+2][2]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tedge[i/2][j+1][1]=s[j]-'0';\n\t\t\t\tedge[i/2+1][j+1][3]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tstep();\n\t\tans.pb(angle);\n\t\tif(now.fi==1&&now.sec==1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\toutput(ans[i]);\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring wall[9];\n\nint dy[4]={0,1,0,-1};\nint dx[4]={1,0,-1,0};\n\ninline int iswall(int cx,int cy,int d){\n\tswitch(d){\n\t\tcase 0:\n\t\t\tcy=2*cy;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcy=2*cy+1;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcy=2*cy;\n\t\t\tcx=cx-1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcy=2*cy-1;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t}\n\tif(cy<0||9<=cy||cx<0||5<=cx) return 0;\n\treturn wall[cy][cx]=='1';\n}\n\nint main(void){\n\trep(i,9){\n\t\tcin >> wall[i];\n\t\tif(wall[i].size()==4) wall[i]+=\"0\";\n\t}\n\tcout << 'R';\n\tint cx=1,cy=0,cd=0;\n\tmap<int,char> dir;\n\tdir[0]='R',dir[1]='D',dir[2]='L',dir[3]='U';\n\twhile(1){\n\t\trep(i,4){\n\t\t\tint index[4]={0,3,1,2};\n\t\t\tint nd=(cd+index[i])%4;\n\t\t\tif(iswall(cx,cy,nd)){\n\t\t\t\tcout << dir[nd];\n\t\t\t\tcy+=dy[nd],cx+=dx[nd],cd=nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(cx==0&&cy==0) break;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s[9];\nint x,y,t;\n\nbool R()\n{\n\tif(x < 4 && s[y][x] == '1'){\n\t\tcout << 'R'; t = 0;\n\t\tx++; return true;\n\t}\n\treturn false;\n}\n\nbool L()\n{\n\tif(0 < x && s[y][x-1] == '1'){\n\t\tcout << 'L'; t = 2;\n\t\tx--; return true;\n\t}\n\treturn false;\n}\n\nbool U()\n{\n\tif(1 < y && s[y-1][x] == '1'){\n\t\tcout << 'U'; t = 3;\n\t\ty -= 2; return true;\n\t}\n\treturn false;\n}\n\nbool D()\n{\n\tif(y < 7 && s[y+1][x] == '1'){\n\t\tcout << 'D'; t = 1;\n\t\ty += 2; return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tbool (*move[])() = {U,R,D,L};\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tcout << 'R'; x = 1;\n\twhile(!(x == 0 &&y == 0)){\n\t\tfor(int i =0; i < 4; ++i){\n\t\t\tif(move[(t+i)%4]())break;\n\t\t}\n\t}\n\tcout << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<complex>\n#include<map>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EPS (1e-10)\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\nint kabe[5][5][5][5];\n\nenum direct {\n  RIGHT = 0,\n  DOWN  = 1,\n  LEFT  = 2,\n  UP    = 3\n};\n\nconst char *dstr = \"RDLU\";\n\nconst int dx[4] = { 1, 0,-1, 0};\nconst int dy[4] = { 0, 1, 0,-1};\n\n#define D(d) (((d)+4)%4)\n\nbool go(int x1, int y1, int x2, int y2){\n  if(x2 < 0 || y2 < 0 || x2 >= 5 || y2 >= 5) return false;\n  return kabe[x1][y1][x2][y2] == 1;\n}\n\nint main(){\n  string str;\n  REP(i,9){\n    cin>>str;\n    if(i%2 == 0){\n      REP(j,4){\n\tint x = j;\n\tint y = i/2;\n\tif(str[j] == '1'){\n\t  kabe[x][y][x+1][y] = kabe[x+1][y][x][y] = 1;\n\t}\n      }\n    }else{\n      REP(j,5){\n\tint x = j;\n\tint y = i/2;\n\tif(str[j] == '1'){\n\t  kabe[x][y][x][y+1] = kabe[x][y+1][x][y] = 1;\n\t}\n      }\n    }\n  }\n  int x = 0, y = 0;\n  int d = RIGHT;\n  while(x != 0 || y != 0 || d == RIGHT){\n    d = D(d-1);\n    while(!go(x,y,x+dx[d],y+dy[d])) d = D(d+1);\n    putchar(dstr[d]);\n    x += dx[d]; y += dy[d];\n  }\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar ver[10][10], hol[10][10];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst char dir[] = {'U','R','D','L'};\n\nvoid input() {\n  scanf(\"%s\", hol[1]+1);\n  rep(i,4) {\n    scanf(\"%s\", ver[i+1]+1);\n    scanf(\"%s\", hol[i+2]+1);\n  }\n  rep(i,8) rep(j,8) {\n    if (hol[i][j] == '1') hol[i][j] = 1;\n    else hol[i][j] = 0;\n    if (ver[i][j] == '1') ver[i][j] = 1;\n    else ver[i][j] = 0;\n  }\n  // rep(i,8) {\n  //   putchar(' ');\n  //   rep(j,8) printf(\"%2d\", hol[i][j]); puts(\"\");\n  //   rep(j,8) printf(\"%2d\", ver[i][j]); puts(\"\");\n  // }\n}\n\nbool is_end(int x, int y, int d) {\n  return (x == 0 && y == 1 && d == 0) ||\n      (x == 1 && y == 1 && d == 3);\n}\n\nvoid update(int &x, int &y, int &d) {\n  const int bx = x, by = y, bd = d;\n  switch (d) {\n    case 0: {\n      if (hol[y][x]) d = 3;\n      else if (ver[y-1][x+1]) --y;\n      else if (hol[y][x+1]) { ++x; --y; d = 1; }\n      break;\n    }\n    case 1: {\n      if (ver[y][x+1]) d = 0;\n      else if (hol[y+1][x+1]) ++x;\n      else if (ver[y+1][x+1]) { ++x; ++y; d = 2; }\n      break;\n    }\n    case 2: {\n      if (hol[y+1][x]) d = 1;\n      else if (ver[y+1][x]) ++y;\n      else if (hol[y+1][x-1]) { --x; ++y; d = 3; }\n      break;\n    }\n    case 3: {\n      if (ver[y][x]) d = 2;\n      else if (hol[y][x-1]) --x;\n      else if (ver[y-1][x]) { --x; --y; d = 0; }\n      break;\n    }\n  }\n  if (bx == x && by == y && bd == d) {\n    printf(\"%d %d %d\\n\", x, y, d);\n    assert(false);\n  }\n}\n\nvoid solve() {\n  int x = 1, y = 0, d = 1;\n  string ans = \"R\";\n  do {\n    // printf(\"%d,%d - %d : %s\\n\", x, y, d, ans.c_str());\n    update(x, y, d);\n    ans += dir[d];\n  } while (!is_end(x,y,d));\n  printf(\"%s\\n\", ans.c_str());\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <map>\nusing namespace std;\n \n#define rep(i,n) for(int i=0;i<int(n);++i)\n \nstatic const double PI=6*asin(0.5);\ntypedef complex<double> P;\ntypedef long long ll;\n\nint m[10][10];\nint p[10][10][10][10];\nint vec=0;//right=0 down=1 left=2 up=3\nint x=1,y=0;\nint cou=0;\n\nint pgo(int x,int y,int vec);\n\nbool go_to(int x1,int y1,int x2,int y2){\n\tbool f;\n    int a[]={x1,y1,x2,y2};\n    rep(i,4){\n        if(a[i]<0||a[i]>6) return false;\n    }\n    f= p[y1][x1][y2][x2]==1?true:false;\n\tif(f)\n\t//cout<<endl<<x1<<\" \"<<y1<<\"  \"<<x2<<\" \"<<y2<<endl;\n\treturn f;\n}\nvoid dgo(int x,int y,int vec){\n    cout<<\"D\";\n\t//cout<<\"y=\"<<y<<endl;\n\t//vec=1;\n\tpgo(x,y+1,1);\n}\nvoid rgo(int x,int y,int vec){\n    cout<<\"R\";\n    //x++;\n    //vec=0;\n\tpgo(x+1,y,0);\n}\nvoid lgo(int x,int y,int vec){\n    cout<<\"L\";\n    //x--;\n    //vec=2;\n\tpgo(x-1,y,2);\n}\nvoid ugo(int x,int y,int vec){\n    cout<<\"U\";\n    //y--;\n    //vec=3;\n\tpgo(x,y-1,3);\n}\n\nint pgo(int x,int y, int vec){\n\tcou++;\n\t//if(cou==30) return 0;\n    if(x==1&&y==1&&cou!=1) return 0;\n    else if(vec==0){\n        if(go_to(x,y,x,y-1)) ugo(x,y,0);\n        else if(go_to(x,y,x+1,y)) rgo(x,y,0);\n        else if(go_to(x,y,x,y+1)) dgo(x,y,0);\n        else if(go_to(x,y,x-1,y)) lgo(x,y,0);\n\n    }\n    else if(vec==1){\n        if(go_to(x,y,x+1,y)) rgo(x,y,1);\n        else if(go_to(x,y,x,y+1)) dgo(x,y,1);\n        else if(go_to(x,y,x-1,y)) lgo(x,y,1);\n        else if(go_to(x,y,x,y-1)) ugo(x,y,1);\n    }\n    else if(vec==2){\n        if(go_to(x,y,x,y+1)) dgo(x,y,2);\n        else if(go_to(x,y,x-1,y)) lgo(x,y,2);\n        else if(go_to(x,y,x,y-1)) ugo(x,y,2);\n        else if(go_to(x,y,x+1,y)) rgo(x,y,2);\n    }\n    else if(vec==3){\n        if(go_to(x,y,x-1,y)) lgo(x,y,3);\n        else if(go_to(x,y,x,y-1)) ugo(x,y,3);\n        else if(go_to(x,y,x+1,y)) rgo(x,y,3);\n        else if(go_to(x,y,x,y+1)) dgo(x,y,3);\n    }\n    //pgo(x,y,vec);\n\treturn 0;\n}\n\nint main(){\n    rep(a,10) rep(b,10) rep(c,10) rep(d,10) p[a][b][c][d]=0;\n    rep(i,10) rep(j,10) m[i][j]=0;\n    rep(i,4){\n        char t;\n    \tstring tm;\n        int tmp;\n        rep(j,4){\n            cin>>t;\n        \ttm=t;\n            if(tm==\"0\") tmp=0;\n            else if(tm==\"1\") tmp=1;\n        \t//cout<<t<<\" \"<<tmp<<endl;\n            p[i+1][j+1][i+1][j+2]=tmp;\n            p[i+1][j+2][i+1][j+1]=tmp;\n        \t\t//cout<<tmp<<\"  \"<<j+1<<\",\"<<i+1<<\"-\"<<j+2<<\",\"<<i+1<<endl;\n        }\n        rep(j,5){\n            cin>>t;\n        \ttm = t;\n            if(tm==\"0\") tmp=0;\n            else if(tm==\"1\") tmp=1;\n            p[i+1][j+1][i+2][j+1]=tmp;\n            p[i+2][j+1][i+1][j+1]=tmp;\n        \t\n        \t\t//cout<<tmp<<\"  \"<<j+1<<\",\"<<i+1<<\"-\"<<j+2<<\",\"<<i+1<<endl;\n        }\n    }\n    rep(j,4){\n        int i=4;\n        char t;\n        int tmp;\n    \tstring tm;\n        cin>>t;\n    \ttm = t;\n        if(tm==\"0\") tmp=0;\n        else if(tm==\"1\") tmp=1;\n        p[i+1][j+1][i+1][j+2]=tmp;\n        p[i+1][j+2][i+1][j+1]=tmp;\n    \t\n        \t\t//cout<<tmp<<\"  \"<<j+1<<\",\"<<i+1<<\"-\"<<j+2<<\",\"<<i+1<<endl;\n    }\n    \n    pgo(1,1,0);\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 5;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst char C[] = {'R','D','L','U'};\nint g[N][N];\nint main(void){\n  fill(g[0],g[N],0);\n  for(int s = 0 ; s < 2 * N - 1 ; s ++){\n    for(int j = 0 ; j < N - 1 + s % 2 ; j ++){\n      int i = s / 2;\n      char a;\n      cin>> a;\n      if(a=='1'){\n\tif(s%2==0){\n\t  g[i][j] |= (1<<0);\n\t  g[i][j+1] |= (1<<2);\n\t} else{\n\t  g[i][j] |= (1<<1);\n\t  g[i+1][j] |= (1<<3); \n\t}\n      }\n    }\n  }\n\n  int i,j,d;\n  i = j = d = 0;\n  do{\n    for(int k = 0 ; k < 4 ; k ++){\n      int nd = (d+3+k) % 4;\n      if(g[i][j] & (1<<nd)){\n\td = nd;\n\ti += di[d];\n\tj += dj[d];\n\tcout << C[d];\n\tbreak;\n      }\n    }\n  }while(!(i==0 && j==0));\n  cout<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n#define S 6\n// right, down, left, up\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint const MOD = 1000000007;\n\nint main() {\n    bool board[S][S][4] = {};\n    rep(i,0,9) {\n        int l, n;\n        if(i % 2 == 0) l = 4;\n        else l = 5;\n        rep(j,0,l) {\n            scanf(\"%1d\", &n);\n            if(n == 1) {\n                if(i % 2 == 0) {\n                    board[i/2][j+1][1] = true;\n                    board[i/2+1][j+1][3] = true;\n                }\n                else {\n                    board[i/2+1][j][0] = true;\n                    board[i/2+1][j+1][2] = true;\n                }\n            }\n        }\n    }\n\n    string d = \"RDLU\";\n    string ret;\n    int dir = 0;\n    int nx = 0, ny = 1;\n    for(int i=0; i<150; i++) {\n        if(nx == 1 && ny == 0 && dir == 2) break;\n        if(nx == 0 && ny == 0 && dir == 3) break;\n        int x, y;\n        x = nx + dx[dir], y = ny + dy[dir];\n        if(board[nx][ny][(dir + 1) % 4] == 0) {\n            dir = (dir + 1) % 4;\n            nx = nx + dx[dir], ny = ny + dy[dir];\n        }\n        else if(board[nx][ny][dir] == 1) {\n            ret += d[dir];\n            dir = (dir - 1 + 4) % 4;\n        }\n        else {\n            ret += d[dir];\n            nx = x, ny = y;\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <bitset>\n#include <cstdint>\n\nint main()\n{\n\tenum { Left, Up, Right, Down };\n\n\ttypedef std::array<std::bitset<4>, 5> Row;\n\ttypedef std::array<Row, 5> Matrix;\n\tMatrix matrix;\n\n\tstd::string input;\n\tstd::getline(std::cin, input);\n\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\tif (input[x] == '1') {\n\t\t\tmatrix[0][x].set(Right);\n\t\t\tmatrix[0][x + 1].set(Left);\n\t\t}\n\t}\n\n\tfor (std::uint16_t y = 0; y < 4U; ++y) {\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 5U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y][x].set(Down);\n\t\t\t\tmatrix[y + 1][x].set(Up);\n\t\t\t}\n\t\t}\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y + 1][x].set(Right);\n\t\t\t\tmatrix[y + 1][x + 1].set(Left);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::uint16_t y = 0, x = 0;\n\tchar direct = 'R';\n\tdo {\n\t\tif (direct == 'R') {\n\t\t\tif (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'D') {\n\t\t\tif (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'L') {\n\t\t\tif (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'U') {\n\t\t\tif (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t}\n\t\tstd::cout << direct << std::flush;\n\t} while (not (y == 0 and x == 0));\n\tstd::cout << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n\nint main(){\n  bool w[5][5][4]={};\n  char a;\n  rep(i,5){\n    rep(j,4){\n      cin>>a;\n      w[i][j][0]=a-'0';\n      w[i][j+1][2]=a-'0';\n    }\n    if(i==4)continue;\n    rep(j,5){\n      cin>>a;\n      w[i][j][1]=a-'0';\n      w[i+1][j][3]=a-'0';\n    }\n  }\n  assert(w[0][0][0]);\n  int py=0,px=0;\n  int dir=0;\n  int dx[]={1,0,-1,0};\n  int dy[]={0,1,0,-1};\n  string ans=\"\";\n  string ch[]={\"R\",\"D\",\"L\",\"U\"};\n  do{\n    for(int i=-1;i<=2;i++){\n      int nd=(dir+i+4)%4;\n      if(w[py][px][nd]){\n        ans+=ch[nd];\n        py+=dy[nd];\n        px+=dx[nd];\n        dir=nd;\n        break;\n      }\n    }\n  }while(py!=0||px!=0);\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            //cout << \"(\" << y << \",\" << x << \",\" << d << \")\" << endl;\n            if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n    static bool wall[6][6][4];\n    const int dx[4] = { 1, 0, -1, 0 };\n    const int dy[4] = { 0, 1, 0, -1 };\n    REP(i,6) REP(j,6) REP(k,4) {\n        int ni = i + dy[k];\n        int nj = j + dx[k];\n        if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n            wall[i][j][k] = 0;\n        }\n        else {\n            wall[i][j][k] = 1;\n        }\n    }\n    \n    string s;\n    for(int i = 0; i < 4; i++) {\n        getline(cin, s);\n        for(int j = 0; j < 4; j++) {\n            wall[i][j + 1][1] = (s[j] == '1');\n            wall[i + 1][j + 1][3] = (s[j] == '1');\n        }\n        getline(cin, s);\n        for(int j = 0; j < 5; j++) {\n            wall[i + 1][j][0] = (s[j] == '1');\n            wall[i + 1][j + 1][2] = (s[j] == '1');\n        }\n    }\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n        wall[4][j + 1][1] = (s[j] == '1');\n        wall[5][j + 1][3] = (s[j] == '1');\n    }\n\n    string icon = \"RDLU\";\n#if 0\n    REP(i,6) REP(j,6) {\n        cerr << \"(\" << i << \",\" << j << \")\";\n        REP(k,4) {\n            if(wall[i][j][k] == false) cerr << icon[k];\n        }\n        cerr << endl;\n    }\n#endif\n\n    int X = 1, Y = 0, dir = 0;\n    string ans = \"R\";\n    do {\n#if 0\n        cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n        if(wall[Y][X][dir] == 0) {\n            Y += dy[dir];\n            X += dx[dir];\n\n            if(wall[Y][X][(dir + 1) % 4] == 0) {\n                dir = (dir + 1) % 4;\n                X += dx[dir];\n                Y += dy[dir];\n                ans.push_back(icon[dir]);\n            }\n            else {\n                ans.push_back(icon[dir]);\n            }\n        }\n        else {\n            dir = (dir - 1 + 4) % 4;\n            ans.push_back(icon[dir]);\n        }\n    } while(!((X == 1 && Y == 0) || (X == 1 && Y == 1)));\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unistd.h>\n#define U 0\n#define R 1\n#define D 2\n#define L 3\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nint wall[5][5];\nchar buf[128];\nvoid readH(int y){\n//  read(0,buf,6);buf[4]=0;\n  scanf(\"%s\",buf);\n  for (int i=0; i<4; i++){\n    wall[i][y] |= (buf[i]=='1') << R;\n    wall[i+1][y] |= (buf[i]=='1') << L;\n  }\n}\nvoid readV(int y){\n  scanf(\"%s\",buf);\n  for (int i=0; i<5; i++){\n    wall[i][y] |= (buf[i]=='1') << D;\n    wall[i][y+1] |= (buf[i]=='1') << U;\n  }\n}\nint main(void){\n  int x,y,dir;\n  \n  for (int i=0; i<4; i++){\n    readH(i); readV(i);\n  }\n  readH(4);\n  \n/*  for (int y=0; y<=4; y++){\n    for (int x=0; x<=4; x++){\n      printf(\"%x \", wall[x][y]);\n    }puts(\"\");\n  }\n  */\n//  for(x=y=(dir=R)^R;x+=dx[dir],y+=dy[dir],write(1,&(*buf=\"URDL\"[dir]),1),x+y;){\n  for(x=y=(dir=R)^R;x+=dx[dir],y+=dy[dir],putchar(\"URDL\"[dir]),x+y;){\n    for((dir+=3)&=~4;!(wall[x][y]&(1<<dir)); (dir+=1)&=~4){\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint di[4] = {0, 1, 0, -1};\nint dj[4] = {1, 0, -1, 0};\nstring s = \"RDLU\";\n\n#define inRange(x,a,b) (a <= x && x < b)\n\nint main(){\n    char mat[9][5];\n    for(int i = 0; i < 9; i++){\n        for(int j = 0; j < (i%2 == 0 ? 4 : 5); j++){\n            cin >> mat[i][j];\n        }\n    }\n\n    int i = 0, j = 1, dir = 0;\n    string ans = \"R\";\n    \n    while(1){\n        if(i == 0 && j == 0)    break;\n        \n        if(dir % 2 == 0){\n            int ti = 2*i + (dir-1);\n            if(inRange(ti, 0, 9)){\n                if(mat[ti][j] == '1'){\n                    dir = (dir - 1 + 4)%4;\n                    i += di[dir], j += dj[dir];\n                    ans += s[dir];\n                    continue;\n                }\n            }\n            int tj = j - dir/2;\n            if(!inRange(tj, 0, 4) || mat[2*i][tj] == '0'){\n                dir = (dir + 1)%4;\n            }else{\n                i += di[dir], j += dj[dir];\n                ans += s[dir];\n            }\n        }else{\n            int tj = j - dir/2;\n            if(inRange(tj, 0, 4)){\n                if(mat[2*i][tj] == '1'){\n                    dir = (dir - 1 + 4)%4;\n                    i += di[dir], j += dj[dir];\n                    ans += s[dir];\n                    continue;\n                }\n            }\n            int ti = 2*i + (2-dir);\n            if(!inRange(ti, 0, 9) || mat[ti][j] == '0'){\n                dir = (dir + 1)%4;\n            }else{\n                i += di[dir], j += dj[dir];\n                ans += s[dir]; \n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n\n    while ( true ) {\n        putchar( T[s] );\n        if ( r == 2 && c == 2 && s == L ) break;\n        if ( r == 3 && c == 2 && s == U ) break;\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else {\n                s = R;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else {\n                s = L;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else {\n                s = D;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else {\n                s = U;\n            }\n        }\n    }\n    putchar( '\\n' );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nstruct\n{\n} undefined;\n\nauto turnRight (char d) -> char\n{\n    switch (d)\n    {\n    case 'R' :\n        return 'D';\n    case 'D' :\n        return 'L';\n    case 'L' :\n        return 'U';\n    case 'U' :\n        return 'R';\n    default :\n        return d;\n    }\n}\n\nauto move (char (& a) [5] [4] , char (& b) [4] [5] , int & x , int & y , char & right) -> char\n{\n    right = [&] () -> char\n    {\n        switch (right)\n        {\n        case 'R' :\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            break;\n        case 'D' :\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            break;\n        case 'L' :\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            break;\n        case 'U' :\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            break;\n        }\n        throw undefined;\n    } ();\n    switch (right)\n    {\n        case 'R' :\n            ++ x;\n            break;\n        case 'D' :\n            ++ y;\n            break;\n        case 'L' :\n            -- x;\n            break;\n        case 'U' :\n            -- y;\n            break;\n    }\n    return right;\n}\n\nauto main () -> int\n{\n    char a [5] [4];\n    char b [4] [5];\n    for (auto && elem : a [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [4])\n    {\n        std::cin >> elem;\n    }\n\n    int x = 0 , y = 0;\n    char right = 'R';\n    std::list <char> res;\n\n    while (true)\n    {\n#ifdef DEBUG\n        std::cout << \"debug: \" << x << \",\" << y << std::endl;\n#endif\n        res.push_back (move (a , b , x , y , right));\n#ifdef DEBUG\n        std::cout << res.back () << std::endl;\n#endif\n        if (x == 0 && y == 0)\n        {\n            break;\n        }\n    }\n    for (auto && elem : res)\n    {\n        std::cout << elem;\n    }\n    std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n\telse if(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse{\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define N 10\nusing namespace std;\n\nint main(){\n\tstring str, ans = \"\";\n\tbool h[N][N]; // setinel\n\tbool v[N][N];\n\tchar dir = 'R';\n\tint mx = 1;\n\tint my = 1;\n\tint i, j, len;\n\t\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = 0; j < N; j++) {\n\t\t\th[i][j] = v[i][j] = false;\n\t\t}\n\t}\n\n\ti = j = 1;\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\n\tdo{\n\t\tif (dir == 'L') {\n\t\t\tif(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}else if(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}else if(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}\n\t\t}else if (dir == 'R') {\n\t\t\tif(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}else if(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}else if(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}\n\t\t}else if (dir == 'U') {\n\t\t\tif(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}else if(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}else if(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}\n\t\t}else if (dir == 'D') {\n\t\t\tif(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}else if(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}else if(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define N 2000\nusing namespace std;\n\nbool h[N][N]; // setinel\nbool v[N][N];\nchar dir = 'R';\nint mx = 1;\nint my = 1;\n\nbool left(){\n\tif(h[my][mx-1]){\n\t\tmx--;\n\t\tdir = 'L';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool right(){\n\tif(h[my][mx]){\n\t\tmx++;\n\t\tdir = 'R';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool up(){\n\tif(v[my-1][mx]){\n\t\tmy--;\n\t\tdir = 'U';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool down(){\n\tif(v[my][mx]){\n\t\tmy++;\n\t\tdir = 'D';\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstring str, ans = \"\";\n\tint i, j, len;\n\n\ti = j = 1;\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (dir == 'L') {\n\t\t\tif(down()){\n\t\t\t}else if(left()){\n\t\t\t}else if(up()){\n\t\t\t}\n\t\t}else if (dir == 'R') {\n\t\t\tif(up()){\n\t\t\t}else if(right()){\n\t\t\t}else if(down()){\n\t\t\t}\n\t\t}else if (dir == 'U') {\n\t\t\tif(left()){\n\t\t\t}else if(up()){\n\t\t\t}else if(right()){\n\t\t\t}\n\t\t}else if (dir == 'D') {\n\t\t\tif(right()){\n\t\t\t}else if(down()){\n\t\t\t}else if(left()){\n\t\t\t}\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nint mox[2][4]={{0,1,0,-1},{0,0,0,-1}},moy[2][4]={{-1,0,1,0},{-1,0,0,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4;\n        if(now%2==0){\n            if(y+moy[0][now]<5&&y+moy[0][now]>-1&&side[y+moy[1][now]][x]=='1'){\n                cout<<str[now];\n                serch(x,y+moy[0][now],now-1);\n            }\n        }\n        else{\n            if(x+mox[0][now]<5&&x+mox[0][now]>-1&&Longitudinal[y][x+mox[1][now]]=='1'){\n                cout<<str[now];\n                serch(x+mox[0][now],y,now-1);\n            }\n        }\n    }\n}int main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n/*\nconst int dx[4] = {-1,0,0,0};\nconst int dy[4] = {0,-1,0,0};\nconst int dx2[4] = {-1,0,1,0};\nconst int dy2[4] = {0,1,0,-1};\n*/\nstatic const int dx[4] = {1,0,-1,0};\nstatic const int dy[4] = {0,1,0,-1};\nint main(void){\n  int d = 0;\n  /*\n  int a[5][4];\n  int b[4][5];\n  */\n  int m[9][9];\n  int x=0,y=0;\n  string tmp;\n  /*\n  for(int i=0; i<4; i++){\n    for(int j=0; j<4; j++){\n      c = getchar();\n      a[i][j] = c - '0';\n    }\n    getchar();\n    for(int j=0; j<5; j++){\n      c = getchar();\n      b[i][j] = c - '0';\n    }\n    getchar();\n  }\n  for(int j=0; j<4; j++){\n    c = getchar();\n    a[4][j] = c - '0';\n  }\n  */\n  for(int i=0; i<9; i++){\n    cin>>tmp;\n    int jbegin;\n    if(i%2){\n      jbegin=0;\n    }else{\n      jbegin=1;\n    }\n    for(int j=jbegin,k=0; j<9; j+=2,k++){\n      m[i][j] = tmp[k];\n    }\n  }\n  for(int time=0; time>-1; time++){\n    for(int r=-1; r<2; r++){\n      //printf(\"%d\",(d+r+4)%4);\n      if(y+dy[(d+r+4)%4]>=0&&y+dy[(d+r+4)%4]<=8\n          &&x+dx[(d+r+4)%4]>=0&&x+dx[(d+r+4)%4]<=8&&\n          m[y+dy[(d+r+4)%4]][x+dx[(d+r+4)%4]]=='1'){\n        d = (d+r+4)%4;\n        x += 2*dx[d];\n        y += 2*dy[d];\n        break;\n      }\n    }\n    char out;\n    switch(d){\n      case 0:\n        out = 'R';\n        break;\n      case 1:\n        out = 'D';\n        break;\n      case 2:\n        out = 'L';\n        break;\n      case 3:\n        out = 'U';\n        break;\n    }\n    putchar(out);\n    //printf(\"%d,%d\\n\",x,y);\n    if(x==0&&y==0) break;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool map[11][11] = { false };\nint x = 1, y = 1, vec = 0;\nint dir[4] = {3, 0, 1, 2};\nint dx[2][4] = { {1, 0, -1, 0}, {2, 0, -2, 0} };\nint dy[2][4] = { {0, 1, 0, -1}, {0, 2, 0, -2} };\nstring opr[] = { \"R\", \"D\", \"L\", \"U\" };\n\nvoid solve() {\n\tint tmp = 0;\n\tbool next = true;\n\twhile (next) {\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\tif (map[y + dy[0][tmp]][x + dx[0][tmp]]) {\n\t\t\t\ty += dy[1][tmp];\n\t\t\t\tx += dx[1][tmp];\n\n\t\t\t\tvec = tmp;\n\t\t\t\tcout << opr[tmp];\n\t\t\t\tif (x == 1 && y == 1) next = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tstring str;\n\tint tmp;\n\tfor (int i = 0; i < 9; i++) {\n\t\tcin >> str;\n\t\tif (i % 2 == 0) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\ttmp = str[j] - '0';\n\t\t\t\tif (tmp == 1) {\n\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\ttmp = str[j] - '0';\n\t\t\t\tif (tmp == 1) {\n\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Dot{\npublic:\n  bool d[4];\n  Dot() {\n    d[0] = d[1] = d[2] = d[3] = false;\n  }\n};\n\nint main() {\n  Dot data[5][5];\n  for(int i = 0; i < 9; i++) {\n    string str;\n    getline(cin, str);\n    int y = i/2;\n    if(i % 2 == 0) {\n      for(int j = 0; j < 4; j++) {\n\tif(str[j] == '1') {\n\t  data[y][j].d[0] = data[y][j+1].d[2] = true;\n\t}\n      }\n    } else {\n      for(int j = 0; j < 5; j++)  {\n\tif(str[j] == '1') {\n\t  data[y][j].d[1] = data[y+1][j].d[3] = true;\n\t}\n      }\n    }\n  }\n\n  int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  int x = 0;\n  int y = 0;\n  int dir = 0;\n  while(1) {\n    for(int i = 0; i < 4; i++) {\n      int t = (dir+i+3)%4;\n      if(data[y][x].d[t]) {\n\tdir = t;\n\tx += d[t][0];\n\ty += d[t][1];\n\tswitch(t) {\n\tcase 0: cout << 'R'; break;\n\tcase 1: cout << 'D'; break;\n\tcase 2: cout << 'L'; break;\n\tcase 3: cout << 'U'; break;\n\t}\n\tbreak;\n      }\n    }\n    if(x == 0 && y == 0) {\n      cout << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint xdir[4] = {1, 0, -1, 0} ,ydir[4] = {0, 1, 0, -1};\nchar dir[4] = {'R', 'D', 'L', 'U'};\n\nint main()\n{\n  int l, x, y, d;\n  string str;\n  bool a[11][11][11][11]; // current pos[h][w], next pos[h][w]\n\n  while(cin>>str){\n    l = str.size()+1;\n    y = 1;\n    fill(&a[0][0][0][0], &a[l+1][0][0][0], false);\n\n    for(int i = 1; i < l; ++i)\n      if(str[i-1] == '1')\n\ta[0][i-1][0][i] = a[0][i][0][i-1] = true;\n\n    for(int i = 1; i <= 8; ++i){\n      cin >> str;\n      if(i%2){\n\tfor(int j = 0; j < l; ++j)\n\t  if(str[j] == '1') \n\t    a[y-1][j][y][j] = a[y][j][y-1][j] = true;\n      } else {\n\tfor(int j = 1; j < l; ++j)\n\t  if(str[j-1] == '1')\n\t    a[y][j-1][y][j] = a[y][j][y][j-1] = true;\n\ty++;\n      }\n    }\n\n    x = y = d = 0;\n    do {\n      int dx = x+xdir[d], dy = y+ydir[d];\n      if(0 > dx || dx >= l || 0 > dy || dy >= l || !a[y][x][dy][dx]){\n\tint d1 = (d+1)%4, d2 = (d+3)%4, d3 = (d+2)%4;\n\tdx = x+xdir[d1]; dy = y+ydir[d1];\n\tif(0 > dx || dx >= l || 0 > dy || dy >= l || !a[y][x][dy][dx]){\n\t  dx = x+xdir[d2]; dy = y+ydir[d2];\n\t  if(0 > dx || dx >= l || 0 > dy || dy >= l || !a[y][x][dy][dx]){\n\t    dx = x+xdir[d3]; dy = y+ydir[d3];\n\t    d = d3;\n\t  } else {\n\t    d = d2;\n\t  }\n\t} else {\n\t  d = d1;\n\t}\n      }      \n\n      // for(int i = 0; i < 4; ++i){\n      // int dx = x+xdir[(d+i)%4], dy = y+ydir[(d+i)%4];\n\n\n      // if(0 <= dx && dx < l && 0 <= dy && dy < l && a[y][x][dy][dx]){\n      // cout << dir[(d+i)%4];\n      cout << dir[d];\n      // cout<<\": (\"<<x<<\", \"<<y<<\") -> (\"<<dx<<\", \"<<dy<<\")\"<<endl;  \n\t  a[y][x][dy][dx] = false;\n\t  x = dx;\n\t  y = dy;\n\t  // d = (d+i)%4;\n\t  // break;\n\t  // \t}\n\t// }\n    } while(x+y != 0);\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<array>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<unordered_map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n//#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) {cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) {cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nconst int MOD = 1e9 + 7;\n\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,-1,0,1 };\nstring LURD = \"LURD\";\nbool M[16][16][4];\n\n//????????¨??????????????????\nint main() {\n\trep(i, 0, 9) {\n\t\tif (i % 2) {\n\t\t\trep(j, 0, 5) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == '1') {\n\t\t\t\t\tM[i / 2][j][3] = true;\n\t\t\t\t\tM[i / 2 + 1][j][1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(j, 0, 4) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == '1') {\n\t\t\t\t\tM[i / 2][j][2] = true;\n\t\t\t\t\tM[i / 2][j + 1][0] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint x = 0, y = 0, dir = 2, cnt = 0;\n\tdo {\n\t\trep(i, 0, 4) {\n\t\t\t//?????????????????????????£????????????????????????????????????????????????????????????????\n\t\t\tint dir2 = (dir + 3 + i) % 4;\n\t\t\tif (M[y][x][dir2]) {\n\t\t\t\tx += dx[dir2]; y += dy[dir2];\n\t\t\t\tdir = dir2;\n\t\t\t\tcout << LURD[dir2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (x || y);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//0037\n//include-------------------------------------\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n//typedef--------------------------------------\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\n#define MP make_pair\n\n//repetition-----------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\n//constant-------------------------------------\nconst double PI = acos(-1.0);\n\n//cout,cin-------------------------------------\n#define COUT(x) cout<<(x)<<endl\n#define CIN(x) cin>>(x)\n\nint main(){\n\tint wall[5][5][4] = { { 0 }, { 0 }, { 0 } };\n\tint now[5][5];\n\tstring dir = \"RDLU\";\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { 1, 0, -1, 0 };\n\n\tREP(i, 9){\n\t\tstring st;\n\t\tCIN(st);\n\t\tif (i % 2) REP(j, 5){\n\t\t\twall[(i - 1) / 2][j][1] = st[j]-'0';\n\t\t\twall[(i - 1) / 2 + 1][j][3] = st[j] - '0';\n\t\t}\n\t\telse REP(j, 4){\n\t\t\twall[i / 2][j][0] = st[j] - '0';\n\t\t\twall[i / 2][j + 1][2] = st[j] - '0';\n\t\t}\n\t}\n\n\tint x = 0;\n\tint y = 1;\n\tnow[x][y] = 0;\n\t\n\tcout << 'R';\n\twhile (!(x == 0 && y == 0)){\n\t\tint p=now[x][y];\n\t\tif (wall[x][y][(now[x][y] + 3) % 4] == 1){\n\t\t\tx += dx[(now[x][y] + 3) % 4];\n\t\t\ty += dy[(now[x][y] + 3) % 4];\n\t\t\tnow[x][y] = (p + 3) % 4;\n\t\t\tcout<< dir[now[x][y]];\n\t\t}\n\t\telse if (wall[x][y][now[x][y]] == 1){\n\t\t\tx += dx[now[x][y]];\n\t\t\ty += dy[now[x][y]];\n\t\t\tnow[x][y] = p;\n\t\t\tcout<< dir[now[x][y]];\n\t\t}\n\t\telse{\n\t\t\tx += dx[(now[x][y] + 1) % 4];\n\t\t\ty += dy[(now[x][y] + 1) % 4];\n\t\t\tnow[x][y] = (p + 1) % 4;\n\t\t\tcout<<dir[now[x][y]];\n\t\t}\n\t}\n\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define repp(i, n) rep(i, n)\n#define reppp(i, n) repp(i, n)\n#define rrepp(i, n) rrep(i, n)\n#define repss(i, n) reps(i, n)\n#define repcc(i, n) repc(i, n)\n#define repii(i, a, b) repi(i, a, b)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n \nusing namespace std;\n \nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n \ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n \nvoid solve() {\n  vstr lr(5), du(5);\n  rep(i, 5) {\n    cin >> lr[i]; lr[i].push_back('0');\n    if (i == 4) { du[i] = string(5, '0'); break; }\n    cin >> du[i];\n  }\n  string ans;\n  int x = 0, y = 0;\n  char d = 'R';\n  while (true) {\n    switch (d) {\n    case 'R':\n      if (y > 0 && du[y - 1][x] == '1') d = 'U', ans.push_back(d), y--;\n      else if (lr[y][x] == '1') ans.push_back(d), x++;\n      else d = 'D';\n      break;\n    case 'D':\n      if (lr[y][x] == '1') d = 'R', ans.push_back(d), x++;\n      else if (du[y][x] == '1') ans.push_back(d), y++;\n      else d = 'L';\n      break;\n    case 'L':\n      if (du[y][x] == '1') d = 'D', ans.push_back(d), y++;\n      else if (x > 0 && lr[y][x - 1] == '1') ans.push_back(d), x--;\n      else d = 'U';\n      break;\n    case 'U':\n      if (x > 0 && lr[y][x - 1] == '1') d = 'L', ans.push_back(d), x--;\n      else if (y > 0 && du[y - 1][x] == '1') ans.push_back(d), y--;\n      else d = 'R';\n      break;\n    }\n    if (x == 0 && y == 0) break;\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dc[]={'R','D','L','U'};\nbool t[7][7][4];\nstring str;\nint flg=0;\nvoid init();\nvoid getnum(int,int,int);\nbool ck(int y,int x,int d){\n\tif(t[y][x][d]==1)return true;\n\tint ny=y+dy[d];\n\tint nx=x+dx[d];\n\tif(t[ny][nx][(d+2)%4]==1)return true;\n\treturn false; \n}\nvoid rec(int y,int x,int d);\nint main(){\n\tinit();\n\t//cout<<\"test\"<<endl;\n\tfor(int i=1;i<=4;i++){\n\t\tfor(int j=1;j<=4;j++){\n\t\t\t//cin>>t[i][j][0];\n\t\t\tgetnum(i,j,0);\n\t\t}\n\t\tfor(int j=1;j<=5;j++){\n\t\t\t//cin>>t[i][j][1];\n\t\t\tgetnum(i,j,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=4;i++)getnum(5,i,0);//cin>>t[5][i][0];\n\t//cout<<\"inputend\"<<endl;\n\trec(1,1,0);\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<7;i++)\n\t\tfor(int j=0;j<7;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tt[i][j][k]=0;\n\tstring s;\n\tstr=\"\";\n\tfor(int i=0;i<9;i++){\n\t\tcin>>s;\n\t\tstr+=s;\t\n\t}\n}\nvoid rec(int y,int x,int d){\n\t//cout<<y << \" \" <<x<<\" \"<<d<<endl;\n\tflg++;\n\tif(y==1&&x==1&&flg>1){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t\n\tint d1=(d+1)%4;\n\tint d2=(d+2)%4;\n\tint d3=(d+3)%4;\n\tif(ck(y,x,d3)){\n\t\tcout<<dc[d3];\n\t\trec(y+dy[d3],x+dx[d3],d3);\n\t}else if(ck(y,x,d)){\n\t\tcout<<dc[d];\n\t\trec(y+dy[d],x+dx[d],d);\n\t}else if(ck(y,x,d1)){\n\t\tcout<<dc[d1];\n\t\trec(y+dy[d1],x+dx[d1],d1);\n\t}else{\n\t\tcout<<dc[d2];\n\t\trec(y+dy[d2],x+dx[d2],d2);\n\t}\n}\nvoid getnum(int a,int b,int c){\n\tif(str[0]=='0')t[a][b][c]=0;\n\telse t[a][b][c]=1;\n\tif(str.size()>=2)str=str.substr(1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nvector<string> strs;\nint H,W;\nbool isroad(int fx,int fy,int tx,int ty){\n    int fromx,fromy,tox,toy;\n    fromx=min(fx,tx);\n    fromy=min(fy,ty);\n    tox=max(fx,tx);\n    toy=max(fy,ty);\n    if(fromx<1 || tox<1 || tox>W || fromx>W || fromy<1 || toy<1 || fromy>H || toy>H) return false;\n    if(fromx==tox){\n        if(strs[(fromy-1)*2+1][fromx-1]=='1') return true;\n        else{\n            return false;\n        }\n    }else{\n        if(strs[(fromy-1)*2][fromx-1]=='1') return true;\n        else{\n            return false;\n        }\n    }\n}\nint vx[]={1,0,-1,0},vy[]={0,-1,0,1};\nint main(){\n    string ins;\n    while(cin>>ins){\n        strs.push_back(ins);\n    }\n    W=strs[0].size()+1;\n    H=strs.size()/2+1;\n    int nx=2,ny=1,v=0;\n    string outs=\"R\";\n    while(nx!=1 || ny!=1){\n        for(int i=5;i>=3;i--){\n            bool r=isroad(nx,ny,nx+vx[(v+i)%4],ny+vy[(v+i)%4]);\n            if(r){\n                v=(v+i)%4;\n                nx+=vx[v];\n                ny+=vy[v];\n                if(v==0) outs+='R';\n                else if(v==1) outs+='U';\n                else if(v==2) outs+='L';\n                else outs+='D';\n                break;\n            }\n        }\n    }\n    cout<<outs<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tif(cin.eof())\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tcin>>yoko[i][j];\n\t\t\t}\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tcin>>tate[i][j];\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0)\n\t\t\t\tbreak;\n}\ncout<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <stdlib.h>\nusing namespace std;\n\n\nint main(){\n\tchar w1[7][7],w2[7][7],dir;\n\tint x=1,y=1;\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tw1[i][j] = '0';\n\t\t\tw2[i][j] = '0';\n\t\t}\n\t}\n\tfgets(w1[1],7,stdin);\n\tfgets(w2[1],7,stdin);\n\tfgets(w1[2],7,stdin);\n\tfgets(w2[2],7,stdin);\n\tfgets(w1[3],7,stdin);\n\tfgets(w2[3],7,stdin);\n\tfgets(w1[4],7,stdin);\n\tfgets(w2[4],7,stdin);\n\tfgets(w1[5],7,stdin);\n\t\n\tfor(int i=5;i>=0;i--){\n\t\tw1[1][i+1]=w1[1][i];\n\t\tw2[1][i+1]=w2[1][i];\n\t\tw1[2][i+1]=w1[2][i];\n\t\tw2[2][i+1]=w2[2][i];\n\t\tw1[3][i+1]=w1[3][i];\n\t\tw2[3][i+1]=w2[3][i];\n\t\tw1[4][i+1]=w1[4][i];\n\t\tw2[4][i+1]=w2[4][i];\n\t\tw1[5][i+1]=w1[5][i];\n\t}\n\tw1[1][0]='0';\n\tw2[1][0]='0';\n\tw1[2][0]='0';\n\tw2[2][0]='0';\n\tw1[3][0]='0';\n\tw2[3][0]='0';\n\tw1[4][0]='0';\n\tw2[4][0]='0';\n\tw1[5][0]='0';/*\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(w1[i][j]=='1') printf(\"+-\");\n\t\t\telse printf(\"+ \");\n\t\t}\n\t\tprintf(\"+\\n\");\n\t\tfor(int j=0;j<7;j++){\n\t\t\tif(w2[i][j]=='1') printf(\"| \");\n\t\t\telse printf(\"  \");\n\t\t}\n\t\t\n\t\tprintf(\"\\n\");\n\t}*/\n\tprintf(\"R\");\n\tdir = 'R';\n\twhile(1){\n\t\tif(dir=='R'){\n\t\t\tif(w2[x-1][y+1]=='1'){\n\t\t\t\tdir = 'U';\n\t\t\t\tx = x-1;\n\t\t\t\ty = y+1;\n\t\t\t}\n\t\t\telse if(w1[x][y+1]=='1'){\n\t\t\t\tdir = 'R';\n\t\t\t\tx = x;\n\t\t\t\ty = y+1;\n\t\t\t}\n\t\t\telse if(w2[x][y+1]=='1'){\n\t\t\t\tdir = 'D';\n\t\t\t\tx = x;\n\t\t\t\ty = y+1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdir = 'L';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t}\n\t\telse if(dir=='L'){\n\t\t\tif(w2[x][y]=='1'){\n\t\t\t\tdir = 'D';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse if(w1[x][y-1]=='1'){\n\t\t\t\tdir = 'L';\n\t\t\t\tx = x;\n\t\t\t\ty = y-1;\n\t\t\t}\n\t\t\telse if(w2[x-1][y]=='1'){\n\t\t\t\tdir = 'U';\n\t\t\t\tx = x-1;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdir = 'R';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t}\n\t\telse if(dir=='U'){\n\t\t\tif(w1[x][y-1]=='1'){\n\t\t\t\tdir = 'L';\n\t\t\t\tx = x;\n\t\t\t\ty = y-1;\n\t\t\t}\n\t\t\telse if(w2[x-1][y]=='1'){\n\t\t\t\tdir = 'U';\n\t\t\t\tx = x-1;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse if(w1[x][y]=='1'){\n\t\t\t\tdir = 'R';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdir = 'D';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t}\n\t\t\n\t\telse if(dir=='D'){\n\t\t\tif(w1[x+1][y]=='1'){\n\t\t\t\tdir = 'R';\n\t\t\t\tx = x+1;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse if(w2[x+1][y]=='1'){\n\t\t\t\tdir = 'D';\n\t\t\t\tx = x+1;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t\telse if(w1[x+1][y-1]=='1'){\n\t\t\t\tdir = 'L';\n\t\t\t\tx = x+1;\n\t\t\t\ty = y-1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdir = 'U';\n\t\t\t\tx = x;\n\t\t\t\ty = y;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%c\",dir);\n\t\tif(x==1&&y==1)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1){\n        if(Longitudinal[y][x-1]=='1'){\n            cout<<\"L\";\n            serch(x-1,y,2);\n        }\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1){\n        if(side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nvoid serch(int x,int y,int then)\n{\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    if(then==0){\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n    }\n    else if(then==1){\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n    }\n    else if(then==2){\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n    }\n    else{\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse if(v[y][x]=='0') xyf*=-1;\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n\telse if(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse if(v[y][x]=='0') xyf*=-1;\n\telse{\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse if(h[y][x-1]=='0') xyf*=-1;\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse if(h[y][x]=='0') xyf*=-1;\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nbool mas[4][4][4];\nstring s = \"LURD\";\nconst int dy[] = { 0, -1, 0, 1}, dx[] = { -1, 0, 1, 0};\n\nvoid dfs( int y, int x, int pos){\n  cout << s[pos];\n  if(!y && !x){\n    cout << endl;\n    return;\n  }\n  for(int i = 0 ; i < 4 ; i++ ){\n    int dd = ( pos + 3 + i ) % 4;\n    int ny = y + dy[ dd], nx = x + dx[ dd];\n    if(mas[y][x][dd]){\n      dfs( y + dy[ dd], x + dx[ dd], dd);\n      return;\n    }\n  }\n}\nint main(){\n  char c;\n  for(int i = 0 ; i < 9 ; i++ ){\n    if(i & 1) for(int j = 0 ; j < 5 ; j++ ){\n      cin >> c;\n      if(c == '1') mas[i / 2][j][3] = mas[i / 2 + 1][j][1] = true;\n    } else for(int j = 0 ; j < 4 ; j++ ){\n      cin >> c;\n      if(c == '1') mas[i / 2][j][2] = mas[i / 2][j + 1][0] = true;\n    }\n  }\n  dfs( 0, 1, 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\n\n\nint main(void){\n\nint hk=5; //0:上 1:右 2:下 3:左\nint cnt=0;\nstring  w[12],ans=\"\";\nstring shk[4]={\"U\",\"R\",\"D\",\"L\"};\n\n\trep(i,9) {\n\t\tcin >> w[i+1] ;\n\t\tw[i+1] = \" \" + w[i+1];\n\t}\n\n\tint x=1, y=1;\n\tif(w[1][1]=='1') { hk = 1; cout <<\"R\";}\n\telse\t\t\t {hk = 2; cout << \"U\";}\n\n\twhile(1){\n//\t\tprintf(\"\\n%d h=%d (%d,%d) %c:\",cnt,hk,y,x,w[y][x]);\n\t\tswitch( hk){\n\t\tcase  0:\n\t\t\tif(w[y-1][x-1] == '1' ) {\n\t\t\t\thk = 3; y--; x--;}\n\t\t\telse if(w[y-2][x] == '1') {\n\t\t\t\thk = 0; y -=2;}\n\t\t\telse if(w[y-1][x] == '1'){\n\t\t\t\thk = 1; y--;}\n\t\t\telse {\n\t\t\t\thk = 2; }\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(w[y-1][x+1] == '1' ){\n\t\t\t\thk = 0; y--; x++;}\n\t\t\telse if(w[y][x+1] == '1') {\n\t\t\t\thk = 1; x++;}\n\t\t\telse if(w[y+1][x+1] == '1'){\n\t\t\t\thk = 2; y++; x++;}\n\t\t\telse {\n\t\t\t\thk = 3; }\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(w[y+1][x] == '1' ) {\n\t\t\t\thk = 1; y++; }\n\t\t\telse if(w[y+2][x] == '1' ) {\n\t\t\t\thk = 2; y +=2;}\n\t\t\telse if( w[y+1][x-1] == '1'){\n\t\t\t\thk = 3; y++; x--;}\n\t\t\telse {\n\t\t\t\thk = 0;}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(w[y+1][x] == '1' ){\n\t\t\t\thk = 2; y++; }\n\t\t\telse if(w[y][x-1] == '1') {\n\t\t\t\thk = 3; x--;}\n\t\t\telse if( w[y-1][x] == '1'){\n\t\t\t\thk = 0; y--; }\n\t\t\telse {\n\t\t\t\thk = 1; }\n\t\t\tbreak;\n\t\t}\n\t\tcout << shk[hk];\n//\t\tans = ans + shk[hk];\n\t\tcnt++; if(cnt>200) break;\n\t\tif(x==1 && y ==1) break;\n\t}\t\n\tcout << endl;\n//\tcout << ans << endl;\n\t\n\treturn 0;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint node(int y, int x) {\n  return 5 * y + x;\n}\n\nint to(int dy, int dx, int now) {\n  int y = now / 5 + dy, x = now % 5 + dx;\n  return node(y, x);\n}\n\nbool inside(int now) {\n  int y = now / 5, x = now % 5;\n  return 0 <= node(y, x) && node(y, x) < 25;\n}\n\nbool g[25][25];\n\nint main() {\n  // input\n  for (int i = 0; i < 9; ++i) {\n    if (i & 1) {\n      for (int j = 0; j < 5; ++j) {\n        int f;\n        scanf(\"%1d\", &f);\n        g[node(i / 2, j)][node(i / 2 + 1, j)] = f;\n        g[node(i / 2 + 1, j)][node(i / 2, j)] = f;\n      }\n    } else {\n      for (int j = 0; j < 4; ++j) {\n        int f;\n        scanf(\"%1d\", &f);\n        g[node(i / 2, j)][node(i / 2, j + 1)] = f;\n        g[node(i / 2, j + 1)][node(i / 2, j)] = f;\n      }\n    }\n  }\n\n  int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};\n  char d[] = {'U', 'R', 'D', 'L'};\n\n  int now = node(0, 1);\n  int direction = 1;\n  string ans = \"R\";\n\n  while (now) {\n    direction = (direction + 3) % 4;\n    for (int i = 0; i < 4; ++i) {\n      int dir = (direction + i) % 4;\n      int next = to(dy[dir], dx[dir], now);\n      if (!inside(next) || !g[now][next]) continue;\n\n      now = next;\n      direction = dir;\n      ans += d[dir];\n      break;\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <istream>\n#include <string>\n#include <vector>\nusing namespace std;\nint main() {\n  vector<bool> w(11 * 11, false);\n  for (int i = 1; i < 10; i++) {\n    for (int j = 1 + i % 2; j < 10; j += 2) {\n      char c;\n      cin >> c;\n      if (c - '0') w[i * 11 + j] = true;\n    }\n  }\n  int x = 2, y = 0, d = 1, dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\n  do {\n    const string s = \"URDL\";\n    d = (d + 1) % 4;\n    while (w[(y + dy[d]) * 11 + x + dx[d]]) {\n      cout << s[(d + 3) % 4];\n      d = (d + 3) % 4;\n    }\n    y += dy[d] * 2;\n    x += dx[d] * 2;\n  }\n  while (x || y);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t\tif(cin.eof()){\n\t\t\tbreak;\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[9][9][4],x,y,dir=1;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s=\"URDL\";\nint main(){\n  r(i,9){\n    if(i%2){\n      r(j,5){\n        scanf(\"%1d\",&x);\n        if(x)a[i/2][j][2]=a[i/2+1][j][0]=1;\n      }\n    }else{\n      r(j,4){\n        scanf(\"%1d\",&x);\n        if(x)a[i/2][j][1]=a[i/2][j+1][3]=1;\n      }\n    }\n  }x=1;\n  cout<<s[dir];\n  while(!(!x&&!y)){\n    if(a[y][x][(dir+3)%4])dir=(dir+3)%4;\n    else if(a[y][x][dir]);\n    else if(a[y][x][(dir+1)%4])dir=(dir+1)%4;\n    else dir=(dir+2)%4;\n    x+=dx[dir];\n    y+=dy[dir];\n    cout<<s[dir];\n  }\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nenum Direction {R, L, U, D};\n\nbool input(char b[][5])\n{\n\tchar dummy;\n\tfor (int i=0; i<9; i++) {\n\t\tfor (int j=0; j<5; j++) {\n\t\t\tif ((i&1)==0 && j==4) continue;\n\t\t\tif ( !(cin >> b[i][j]) ) return false;\n\t\t}\n\t\t//cin >> dummy;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tchar board[9][5];\n\tinput(board);\n\t\n\tpair<int, int> curr_pos(0,0);\n\tenum Direction curr_dir = R;\n\tcout << \"R\";\n\t\n\tdo {\n\t\tswitch (curr_dir) {\n\t\tcase R:\n\t\t\t// priority : U > R > D > L\n\t\t\tif ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--; curr_pos.second++;\n\t\t\t} else if ( curr_pos.second < 3 && board[curr_pos.first][curr_pos.second+1] == '1' ){\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.second++;\n\t\t\t} else if ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++; curr_pos.second++;\n\t\t\t} else {\n\t\t\t\tcurr_dir = L; cout << \"L\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase L:\n\t\t\t// priority : D > L > U > R\n\t\t\tif ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = R; cout << \"R\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\t// priority : L > U > R > D\n\t\t\tif ( curr_pos.second > 0 && board[curr_pos.first-1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first--; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 2 && board[curr_pos.first-2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first-=2;\n\t\t\t} else if ( curr_pos.second < 4 && board[curr_pos.first-1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = D; cout << \"D\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\t// priority : R > D > L > U\n\t\t\tif ( curr_pos.second < 4 &&  board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.first < 6 && board[curr_pos.first+2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first+=2;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first+1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first++; curr_pos.second--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = U; cout << \"U\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ( curr_pos.first != 0 || curr_pos.second != 0 );\n\t\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tstd::cout << 'R';\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && (crd[1] == 0 || crd[1] == 1))\n\t\t{\n\t\t\tstd::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//参考http://hadrori.hateblo.jp/entry/aoj0037 \nconst int dx[] ={-1,0,1,0};\nconst int dy[] ={0,-1,0,1};\nint path[16][16][4];//0:L,1:U,2:R,3:D\nint main()\n{\n  char c;\n  for(int i = 0;i <9;i++){\n    if(i%2){\n      for(int j = 0;j < 5;j++){\n\tcin >>c;\n\tif(c =='1'){\n\t  path[i/2][j][3] = 1;\n\t  path[i/2+1][j][1] = 1;\n\t}\n      }\n    }else{\n      for(int j = 0;j < 4;j++){\n\tcin >>c;\n\tif(c =='1'){\n\t  path[i/2][j][2] = 1;\n\t  path[i/2][j+1][0] = 1;\n\t}\n      }\n    }\n  }\n  int x = 0,y = 0,d = 2;\n  /*\n(前の方向：右 の場合)\n進む方向の優先順位は、上、右、下、左となる。\n\n(前の方向：左 の場合)\n進む方向の優先順位は、下、左、上、右となる。\n\n(前の方向：上 の場合)\n進む方向の優先順位は、左、上、右、下となる。\n\n(前の方向：下 の場合)\n  進む方向の優先順位は、右、下、左、上となる。*/\n  string dir =\"LURD\";\n  do{\n    for(int i = 0;i < 4;i++){\n      int dd =(d+i+3)%4;\n      if(path[y][x][dd]==1){\n\tpath[y][x][dd] -=1;\n\tx +=dx[dd];\n\ty +=dy[dd];\n\td = dd;\n\tcout <<dir[dd];\n\tbreak;\n      }\n    }\n  }while(x||y);\n  cout <<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\tdo\n\t\t\tp=(p+1)%4;\n\t\twhile(!((f[y][x]>>p)&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\treturn !puts(\"\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconst static int SIZE = 11;\nconst static int H_LEN = 4;\nconst static int V_LEN = 5;\nint main() {\n  int field [ SIZE  ][ SIZE ] = { 0 };\n  for( int i = 0; i < SIZE; i++ ) {\n    if( i == 0 || i == SIZE - 1 ) { continue; }\n    string line;\n    cin >> line;\n    if( i % 2 ) {\n      for( int j = 0; j < H_LEN; j++ ) {\n        field[ i ][ 2 + j * 2 ] = line[ j ] - '0';\n      }\n    } else {\n      for( int j = 0; j < V_LEN; j++ ) {\n        field[ i ][ 1 + j * 2 ] = line[ j ] - '0';\n      }\n \n    }\n  }\n/*\n  for( int i = 0; i < SIZE; i++ ) {\n    for( int j = 0; j < SIZE; j++ ) {\n      if( i % 2 ) {\n        cout << ( field[ i ][ j ] ? string(\"-\") : string(\".\") ) << \" \" << flush;\n      } else {\n        cout << ( field[ i ][ j ] ? string(\"|\") : string(\".\") ) << \" \" << flush;\n      }\n    }\n    cout << endl;\n  }\n*/\n  int counter = 0;\n  int dir = 0;\n  int x = 1, y = 1;\n  int vx[ 4 ] = { 2, 0, -2, 0 };\n  int vy[ 4 ] = { 0, 2, 0, -2 };\n  int ax[ 4 ] = { 2, 1, -2, -1 };\n  int ay[ 4 ] = { -1, 2, 1, -2 };\n  int bx[ 4 ] = { 3, 0, -3, 0 };\n  int by[ 4 ] = { 0, 3, 0, -3 };\n  int cx[ 4 ] = { 2, -1, -2, 1 };\n  int cy[ 4 ] = { 1, 2, -1, -2 };\n  do {\n    if( field[ y + ay[ dir ] ][ x + ax[ dir ] ] ) {\n      x += vx[ dir ];\n      y += vy[ dir ];\n      cout << (\n        dir == 0 ? \"R\" :\n        dir == 1 ? \"D\" :\n        dir == 2 ? \"L\" : \"U\"\n      ) << flush;\n      dir = ( dir - 1 + 4 ) % 4;\n    } else if( field[ y + by[ dir ] ][ x + bx[ dir ] ] ) {\n      x += vx[ dir ];\n      y += vy[ dir ];\n      cout << (\n        dir == 0 ? \"R\" :\n        dir == 1 ? \"D\" :\n        dir == 2 ? \"L\" : \"U\"\n      ) << flush;\n    } else if( field[ y + cy[ dir ] ][ x + cx[ dir ] ] ) {\n      x += vx[ dir ];\n      y += vy[ dir ];\n      cout << (\n        dir == 0 ? \"R\" :\n        dir == 1 ? \"D\" :\n        dir == 2 ? \"L\" : \"U\"\n      ) << flush;\n      dir = ( dir + 1 ) % 4;\n    } else {\n      x += vx[ dir ];\n      y += vy[ dir ];\n       cout << (\n        dir == 0 ? \"R\" :\n        dir == 1 ? \"D\" :\n        dir == 2 ? \"L\" : \"U\"\n      ) << flush;\n      dir = ( dir + 2 ) % 4;\n    }\n  } while( x != 1 || y != 1 );\n  cout << endl;\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "\n//わざとまちがい\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tchar fie[11][8];\n\tfor(int i=0;i<11;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tfie[i][j]='0';\n\t\t}\n\t}\n\tfor(int i=1;i<=9;i++){\n\t\tfor(int j=1;j<=5;j++){\n\t\t\tif(i%2==1&&j==5)break;\n\t\t\tcin>>fie[i][j];\n\t\t}\n\t}\n\t\n\tint nowx=0,nowy=0,muki=1,upper=0;\n\tfor(int i=0;;i++){\n\t\tif(i!=0&&nowx==0&&nowy==0)break;\n\t\t\n\t}\n\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tchar WX[7][6],WY[6][7];\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<6;j++){\n\t\t\tWX[i][j] = 0;\n\t\t\tWY[j][i] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<5;i++) cin >> WX[i][1];\n\tfor(int i=1;i<6;i++) cin >> WY[1][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][2];\n\tfor(int i=1;i<6;i++) cin >> WY[2][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][3];\n\tfor(int i=1;i<6;i++) cin >> WY[3][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][4];\n\tfor(int i=1;i<6;i++) cin >> WY[4][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][5];\n\n\tint NX = 1;\n\tint NY = 1;\n\tchar s = 'R';\n\twhile(1){\n\t\tif(s=='R'){\n\t\t\tif(WY[NY-1][NX]=='1'){ s = 'U'; NY--; cout << s;}\n\t\t\telse if(WX[NX][NY]=='1'){ NX++; cout << s;}\n\t\t\telse if(WY[NY][NX]=='1'){ s = 'D'; NY++; cout << s;}\n\t\t\telse s = 'L';\n\t\t}\n\t\telse if(s=='L'){\n\t\t\tif(WY[NY][NX]=='1'){ s = 'D'; NY++; cout << s;}\n\t\t\telse if(WX[NX-1][NY]=='1'){ NX--; cout << s;}\n\t\t\telse if(WY[NY-1][NX]=='1'){ s = 'U'; NY--; cout << s;}\n\t\t\telse s = 'R';\n\t\t}\n\t\telse if(s=='U'){\n\t\t\tif(WX[NX-1][NY]=='1'){ s = 'L'; NX--; cout << s;}\n\t\t\telse if(WY[NY-1][NX]=='1'){ NY--; cout << s;}\n\t\t\telse if(WX[NX][NY]=='1'){ s = 'R'; NX++; cout << s;}\n\t\t\telse s = 'D';\n\t\t}\n\t\telse if(s=='D'){\n\t\t\tif(WX[NX][NY]=='1'){ s = 'R'; NX++; cout << s;}\n\t\t\telse if(WY[NY][NX]=='1'){ NY++; cout << s;}\n\t\t\telse if(WX[NX-1][NY]=='1'){ s = 'L'; NX--; cout << s;}\n\t\t\telse s = 'U';\n\t\t}\n\t\tif(NX*NY==1) break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<vector<vector<bool> > > wall(6, vector<vector<bool> >(6, vector<bool>(4, false)));\n\n    for(int i=0; i<5; ++i){\n        for(int j=0; j<4; ++j){\n            char a;\n            cin >> a;\n            if(a == '1')\n                wall[i][j+1][1] = wall[i+1][j+1][3] = true;\n        }\n        if(i < 4){\n            for(int j=0; j<5; ++j){\n                char a;\n                cin >> a;\n                if(a == '1')\n                    wall[i+1][j][0] = wall[i+1][j+1][2] = true;\n            }\n        }\n    }\n\n    char dir[] = {'R', 'D', 'L', 'U'};\n    int dy[] = {0, 1, 0, -1};\n    int dx[] = {1, 0, -1, 0};\n\n    int y = 0;\n    int x = 1;\n    int d = 0;\n    for(;;){\n        if(!wall[y][x][(d+1)%4]){\n            ++ d;\n            d %= 4;\n        }\n        if(!wall[y][x][d]){\n            y += dy[d];\n            x += dx[d];\n            cout << dir[d];\n        }else{\n            d += 3;\n            d %= 4;\n        }\n\n        if(y == 1 && x == 0 && d == 2)\n            break;\n        if(y == 0 && x == 0)\n            break;\n    }\n\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nchar s[13][7];\nint order[24] = {0, 1, 2, 0, 3, 2, 2, 1, 0, 2, 3, 0,\n                 3, 0, 1, 3, 2, 1, 1, 0, 3, 1, 2, 3};\nint nds[24] = {4, 0, 7, 6, 1, 5, 5, 2, 6, 7, 3, 4,\n               3, 4, 0, 1, 5, 2, 2, 6, 1, 0, 7, 3};\nint ds[8] = {1, 3, 1, 3, 0, 2, 0, 2};\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar ls[8] = {'R', 'L', 'R', 'L', 'U', 'D', 'U', 'D'};\nint i, j;\n\nbool doesWallExist(int x, int y, int d){\n    // printf(\"%d, %d, %d, %d, %d: \", x, y, d, x+(dx[d]-1)/2, 2*y+(dy[d]-1)/2);\n    if(s[2*y+dy[d]][x+(dx[d]-1)/2] == '1'){\n        //puts(\"o\");\n        return true;\n    }\n    //puts(\"x\");\n    return false;\n}\n\nint main(){\n    for(i=0;i<13;i++){\n        for(j=0;j<7;j++){\n            s[i][j] = '0';\n        }\n    }\n\n    for(i=2;i<=10;i++){\n        int ub = i%2?5:4;\n        for(j=0;j<ub;j++){\n            scanf(\"%c\", &s[i][j+1]);\n        }\n        scanf(\"%*c\");\n    }\n\n    bool f = false;\n    int x = 1, y = 1, d = 0;\n    while(!(x == 1 && y == 1 && f)){\n        if(!f){f = true;}\n\n        // printf(\"%d, %d, %d\\n\", x, y, d);\n        putchar(ls[d]);\n        x += dx[ds[d]]; y += dy[ds[d]];\n\n        for(i=0;i<3;i++){\n            if(doesWallExist(x, y, order[d*3+i])){\n                d = nds[d*3+i];\n                break;\n            }\n        }\n    }\n    puts(\"\");\n\n    /* for(int i=0;i<13;i++){ */\n    /*     for(int j=0;j<7;j++){ */\n    /*         putchar(s[i][j]); */\n    /*     } */\n    /*     puts(\"\"); */\n    /* } */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n    int cnt = 0;\n\n    while ( cnt < 2 ) {\n        if ( r == 2 && c == 2 ) {\n            ++ cnt;\n        }\n\n        putchar( T[s] );\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint map[12][12] = {0};\nenum Dir{ RIGHT , DOWN , LEFT , UP };\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nchar d[4] = { 'R' , 'D' , 'L' , 'U'};\n\nint main(){\n\tint x = 2, y = 0, dir = RIGHT;\n\tstring f;\n\n\tfor(int y=0 ; y<9 ; y++){\n\t\tcin >> f;\n\t\tfor(unsigned int x=0 ; x<f.size() ; x++){\n\t\t\tmap[y+1][2*x+((y+1)%2)+1] = f[x] - '0';\n\t\t}\n\t}\n\t\n\twhile( 1 ){\n\t\tif( x==0 && y==2 ) break;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tint nx = x + dx[(dir+1)%4];\n\t\tint ny = y + dy[(dir+1)%4];\n\t\tif( map[ny][nx] == 1 ){\n\t\t\tcout << d[dir];\n\t\t}\n\n\t\tif( map[my][mx] == 0 ){\t\t\n\t\t\tif( map[ny][nx] == 0 ){\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\tnx = x + dx[(dir+1)%4];\n\t\t\t\tny = y + dy[(dir+1)%4];\n\t\t\t\tif( map[ny][nx] == 1 ){\n\t\t\t\t\tcout << d[dir];\n\t\t\t\t}\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}else{\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}\n\t\t}else{\n\t\t\tif( map[ny][nx] == 0 ){\n\t\t\t\tdir = ( dir + 1 ) % 4;\n\t\t\t\tnx = x + dx[(dir+1)%4];\n\t\t\t\tny = y + dy[(dir+1)%4];\n\t\t\t\tif( map[ny][nx] == 1 ){\n\t\t\t\t\tcout << d[dir];\n\t\t\t\t}\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}else{\n\t\t\t\tdir = ( dir + 3 ) % 4;\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include<math.h>\n#include<iomanip>\n#include<stdio.h>\n#include <stdlib.h>  \n#include<map>\n#include<set>\nusing namespace std;\n\nint main(){\n\tbool f[13][13]={};\n\tint TT[15][15]={};\n\tstring p,q;\n\tfor(int i=1;i<=4;i++){\n\t\tcin>>p>>q;\n\t\tfor(int j=0;j<p.size();j++)\n\t\t\tif(p[j]=='1')f[2*i-1][j+1]=1;\n\t\tfor(int j=0;j<q.size();j++)\n\t\t\tif(q[j]=='1')f[i*2][j+1]=1;\n\t}\n\tcin>>p;\n\t\tfor(int j=0;j<p.size();j++)\n\t\t\tif(p[j]=='1')f[9][j+1]=1;\n\t/*for(int i=0;i<=10;i++){\n\t\tfor(int j=0;j<=5;j++)\n\t\t\tcout<<f[i][j];\n\t\tcout<<endl;\n\t}*/\n\tint x=1,y=1;\n\tchar z='R';int v=0;\n\twhile(1){\n\t\tif(z=='R'){\n\t\t\tif(f[y-1][x]){\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t\telse if(f[y][x]){\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t\telse if(f[y+1][x]){\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\n\n\t\t}\n\t\telse if(z=='L'){\n\t\t\tif(f[y+1][x]){\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t\telse if(f[y][x-1]){\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t\telse if(f[y-1][x]){\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t}\n\n\t\telse if(z=='U'){\n\t\t\tif(f[y][x-1]){\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t\telse if(f[y-1][x]){\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t\telse if(f[y][x]){\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t}\n\t\telse if(z=='D'){\n\t\t\tif(f[y][x]){\n\t\t\t\tcout<<\"R\";z='R';x++;\n\t\t\t}\n\t\t\telse if(f[y+1][x]){\n\t\t\t\tcout<<\"D\";z='D';y+=2;\n\t\t\t}\n\t\t\telse if(f[y][x-1]){\n\t\t\t\tcout<<\"L\";z='L';x--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"U\";z='U';y-=2;\n\t\t\t}\n\t\t}\n\t\tif(x==1&&y==1)break;\n\t\tv++;\n\t\t//if(v>30)break;\n\t\t//cout<<x<<\" \"<<y<<\"#\"<<v<<endl;\n\t\tTT[y][x]=v;\n\t}/*\n\tfor(int i=0;i<=10;i++){\n\t\tfor(int j=0;j<=5;j++)\n\t\t\tcout<<TT[i][j];\n\t\tcout<<endl;\n\t}\n\t*/\n\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6]={0};\n  for(int i=0; i<9; i++){\n    if(i%2 == 0){\n      for(int j=0,a; j<4; j++){\n\tscanf(\"%1d\",&a);\n\tfield[i/2][j+1]+=4*a;\n\tfield[i/2+1][j+1]+=a;\n      }\n    }\n    else{\n      for(int j=0,a; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[i/2+1][j]+=2*a;\n\tfield[i/2+1][j+1]+=8*a;\n      }\n    }\n  }\n  int x=0,y=1,d=2;\n  for(;;){\n    if(d == 1){\n      if(!(field[x][y]&2)){d = 2;y++;}\n      else if(field[x][y]&1){cout <<\"U\";d = 8;}\n      else{cout <<\"U\";x--;}\n    }\n    else if(d == 2){\n      if(!(field[x][y]&4)){d = 4;x++;}\n      else if(field[x][y]&2){cout <<\"R\";d = 1;}\n      else{cout <<\"R\";y++;}\n    }\n    else if(d == 4){\n      if(!(field[x][y]&8)){d = 8;y--;}\n      else if(field[x][y]&4){cout <<\"D\";d = 2;}\n      else{cout <<\"D\";x++;}\n    }\n    else if(d == 8){\n      if(!(field[x][y]&1)){d = 1;x--;}\n      else if(field[x][y]&8){cout <<\"L\";d = 4;}\n      else{cout <<\"L\";y--;}\n    }\n    if(x == 0 && y == 1 && d == 2) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n\tint x,y;\n\tP(int x,int y) : x(x), y(y){}; \n\tP(){}\n};\nbool operator < (const P &a,const P &b){\n\tif( a.x != b.x ) return a.x < b.x;\n\treturn a.y < b.y;\n}\n\n\nstring dd = \"RDLU\";\n\nP g[5][5][4];\n\nmap<P,string> memo;\nstring dfs(P p,int d,string s,string rs){\n\t//cout << p.x << \" \" << p.y <<\" \" << d<< endl;\n\tif( memo.count(p) ){\n\t\tstring r = memo[p];\n\t\treverse(r.begin(),r.end());\n\t\tcout << s + r << endl;\n\t\texit(0);\n\t}\n\tmemo[p] = rs;\n\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( g[p.y][p.x][(i+d)%4].x != -1){\n\t\t\tdfs(g[p.y][p.x][(i+d)%4],(i+d)%4,s+dd[(i+d)%4],rs+dd[(i+d+2)%4]);\n\t\t\t\n\t\t}\n\t}\n\n}\nint main(){\n\tfor(int i = 0 ; i < 5 ; i++)\n\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\tfor(int k = 0 ; k < 4 ; k++)\n\t\t\t\tg[i][j][k] = P(-1,-1);\n\t\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\t//cout << s << endl;\n\t\tif( i % 2 ){\n\t\t\tint y = i / 2;\n\t\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\t\tif( s[j] == '1' ){\n\t\t\t\t\t//cout << j << \" \" << y+1 << \"<\" << endl;\n\t\t\t\t\tg[y][j][1] = P(j,y+1);\n\t\t\t\t\tg[y+1][j][3] = P(j,y);\n\t\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tint y = i / 2;\n\t\t\tfor(int j = 0 ; j < 4 ; j++)\n\t\t\t\tif( s[j] == '1' ){\n\t\t\t\t\tg[y][j][0] = P(j+1,y);\n\t\t\t\t\tg[y][j+1][2] = P(j,y);\n\t\t\t\t}\n\t\t}\n\t\t\n\t}\n\tdfs(P(0,0),0,\"\",\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nchar dc[] = \"RDLU\";\n\nint main() {\n\tint g[11][11] = {};\n\tchar c;\n\tfor (int i=1; i<10; ++i) {\n\t\tfor (int j=1+i%2; j<=9; j+=2) {\n\t\t\tcin >> c;\n\t\t\tg[i][j] |= c - '0';\n\t\t}\n\t}\n\tint x=1, y=1, d=0;\n\tdo {\n\t\tfor (int t=d+3; ; ++t) {\n\t\t\tif (g[y + dy[t%4]][x + dx[t%4]]) {\n\t\t\t\td = t%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx += dx[d] * 2;\n\t\ty += dy[d] * 2;\n\t\tcout << dc[d];\n\t} while (x != 1 || y != 1);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\tchar yoko[10][10];\n\tchar tate[10][10];\n\tmemset(yoko,0,sizeof(yoko));\n\tmemset(tate,0,sizeof(tate));\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tyoko[i][j]=c;\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\ttate[i][j]=c;\n\t\t\t}\n\t\t}\n\t}\n\tif(cin.eof())\n\t\tbreak;\n\n\n\t// 0,1,2,3ÅEAºA¶Aã\n\tint angle=0;\n\tint px,py;\n\tpx=py=0;\n\twhile(1){\n\t\tif(angle==0){\n\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tpx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ãÖ\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx--;\n\t\t\t\t\tangle=2;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// º\n\t\telse if(angle==1){\n\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\tcout<<\"D\";\n\t\t\t\tpy++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tpx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\t// ãÖ\n\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx++;\n\t\t\t\t\tangle=0;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\tcout<<\"U\";\n\t\t\t\tpy--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(px==0&&py==0)\n\t\t\tbreak;\n\t\t}\n\t\tcout<<endl;\n\n\t\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//int main(){\n//    bool w[5][5][4]={};\n//    \n//    char a;\n//    \n//    rep(i,5){\n//        rep(j,4){\n//            cin>>a;\n//            w[i  ][j  ][0] = a-'0';\n//            w[i  ][j+1][2] = a-'0';\n//        }\n//        if(i==4)continue;\n//        \n//        rep(j,5){\n//            cin>>a;\n//            w[i  ][j  ][1] = a-'0';\n//            w[i+1][j  ][3] = a-'0';\n//        }\n//    }\n//    \n//    assert(w[0][0][0]);\n//    \n//    int py = 0, px = 0;\n//    int dir = 0;\n//    \n//    int dx[] = {1, 0, -1, 0};\n//    int dy[] = {0, 1, 0, -1};\n//    \n//    string ans = \"\";\n//    string ch[] = {\"R\", \"D\", \"L\", \"U\"};\n//    do{\n//        for(int i=-1;i<=2;i++){\n//            int nd = ( dir+i+4 )%4;\n//            if( w[py][px][nd] ){\n//                ans += ch[nd];\n//                py += dy[nd];\n//                px += dx[nd];\n//                dir = nd;\n//                break;\n//            }\n//        }\n//    }while( py!=0 || px!=0 );\n//    \n//    cout<<ans<<endl;\n//}\n\n\nint main(){\n    int a;\n    rep(i,9)cin>>a;\n    cout<<\"RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x==0 && y==0 && ((v+loop[i])%4)==2 || ((v+loop[i])%4==1)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nint main(void) {\n\tint row, col;\n\tchar direction = 'R';\n\n\t//char str[11][6] = { \"00000\",\"1111\",\"00001\",\"0110\",\"01011\",\"0010\",\"01111\",\"0010\",\"01001\",\"0111\",\"00000\" };\n\tchar str[11][6] = {'\\0'};\n\tfor (int i = 1; i < 10; i++) {\n\t\tscanf(\"%s\", str[i]);\n\t}\n\n\tprintf(\"R\");\n\trow = 1;\n\tcol = 1;\n\twhile (1) {\n\t\tswitch (direction) {\n\t\tcase 'U':\n\t\t\t//left\n\t\t\tif (col != 0 && str[row][col - 1] == '1') {\n\t\t\t\tdirection = 'L';\n\t\t\t\tcol = col - 1;\n\t\t\t\tprintf(\"L\");\n\t\t\t}\n\t\t\t//up\n\t\t\telse if (row != 1 && str[row - 1][col] == '1') {\n\t\t\t\tdirection = 'U';\n\t\t\t\trow = row - 2;\n\t\t\t\tprintf(\"U\");\n\t\t\t}\n\t\t\t//right\n\t\t\telse if (col != 4 && str[row][col] == '1') {\n\t\t\t\tdirection = 'R';\n\t\t\t\tcol = col + 1;\n\t\t\t\tprintf(\"R\");\n\t\t\t}\n\t\t\t//down\n\t\t\telse if (row != 9 && str[row + 1][col] == '1') {\n\t\t\t\tdirection = 'D';\n\t\t\t\trow = row + 2;\n\t\t\t\tprintf(\"D\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':  \n\t\t\t//right\n\t\t\tif (col != 4 && str[row][col] == '1') {\n\t\t\t\tdirection = 'R';\n\t\t\t\tcol = col + 1;\n\t\t\t\tprintf(\"R\");\n\t\t\t}\n\t\t\t//down\n\t\t\telse if (row != 9 && str[row + 1][col] == '1') {\n\t\t\t\tdirection = 'D';\n\t\t\t\trow = row + 2;\n\t\t\t\tprintf(\"D\");\n\t\t\t}\n\t\t\t//left\n\t\t\telse if (col != 0 && str[row][col - 1] == '1') {\n\t\t\t\tdirection = 'L';\n\t\t\t\tcol = col - 1;\n\t\t\t\tprintf(\"L\");\n\t\t\t}\n\t\t\t//up\n\t\t\telse if (row != 1 && str[row - 1][col] == '1') {\n\t\t\t\tdirection = 'U';\n\t\t\t\trow = row - 2;\n\t\t\t\tprintf(\"U\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':  \n\t\t\t//down\n\t\t\tif (row != 9 && str[row + 1][col] == '1') {\n\t\t\t\tdirection = 'D';\n\t\t\t\trow = row + 2;\n\t\t\t\tprintf(\"D\");\n\t\t\t}\n\t\t\t//left\n\t\t\telse if (col != 0 && str[row][col - 1] == '1') {\n\t\t\t\tdirection = 'L';\n\t\t\t\tcol = col - 1;\n\t\t\t\tprintf(\"L\");\n\t\t\t}\n\t\t\t//up\n\t\t\telse if (row != 1 && str[row - 1][col] == '1') {\n\t\t\t\tdirection = 'U';\n\t\t\t\trow = row - 2;\n\t\t\t\tprintf(\"U\");\n\t\t\t}\n\t\t\t//right\n\t\t\telse if (col != 4 && str[row][col] == '1') {\n\t\t\t\tdirection = 'R';\n\t\t\t\tcol = col + 1;\n\t\t\t\tprintf(\"R\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':  \n\t\t\t//up\n\t\t\tif (row != 1 && str[row - 1][col] == '1') {\n\t\t\t\tdirection = 'U';\n\t\t\t\trow = row - 2;\n\t\t\t\tprintf(\"U\");\n\t\t\t}\n\t\t\t//right\n\t\t\telse if (col != 4 && str[row][col] == '1') {\n\t\t\t\tdirection = 'R';\n\t\t\t\tcol = col + 1;\n\t\t\t\tprintf(\"R\");\n\t\t\t}\n\t\t\t//down\n\t\t\telse if (row != 9 && str[row + 1][col] == '1') {\n\t\t\t\tdirection = 'D';\n\t\t\t\trow = row + 2;\n\t\t\t\tprintf(\"D\");\n\t\t\t}\n\t\t\t//left\n\t\t\telse if (col != 0 && str[row][col - 1] == '1') {\n\t\t\t\tdirection = 'L';\n\t\t\t\tcol = col - 1;\n\t\t\t\tprintf(\"L\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (row == 1 && col == 1) {\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n\nusing namespace std;\n\nbool wall[11][11];\n\nclass Cbot{\nprivate:\n\npublic:\n\tint x, y;\n\tint direc;\n\tstring log;\n\n\tCbot();\n\tint Start();\n\n};\n\nCbot::Cbot(){\n\tx = 2;\n\ty = 0;\n\tdirec = 1;\n\tlog = \"\";\n}\n\nint Cbot::Start(){\n\n\tint rx[4] = { 1, 0, -1, 0 };\n\tint ry[4] = { 0, 1, 0, -1 };\n\tint fx[4] = { 0, 1, 0, -1 };\n\tint fy[4] = { -1, 0, 1, 0 };\n\tint dx[4] = { 0, 2, 0, -2 };\n\tint dy[4] = { -2, 0, 2, 0 };\n\tchar logd[4] = { 'U', 'R', 'D', 'L' };\n\n\tint cnt = 0;\n\n\twhile (1){\n\n\t\t//????????§??????\n\t\tif (wall[y + ry[direc]][x + rx[direc]] == 1){\n\t\t\t//????????§??????\n\t\t\tlog += logd[direc];\n\t\t\tif (wall[y + fy[direc]][x + fx[direc]] == 0){\n\t\t\t\t//??????\n\t\t\t\tx += dx[direc];\n\t\t\t\ty += dy[direc];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//?????????\n\t\t\t\tif (direc == 0)direc = 3;\n\t\t\t\telse direc--;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t//?????????+??????\n\t\t\tif (direc == 3)direc = 0;\n\t\t\telse direc++;\n\t\t\tx += dx[direc];\n\t\t\ty += dy[direc];\n\t\t}\n\n\t\t//??´????????????\n\t\tif (x == 0 && y == 2 && direc == 3) break;\n\t\tif (x == 0 && y == 0 && direc == 0) break;\n\t\tif (cnt++ > 100) return 0;\n\t}\n\n\treturn 1;\n}\n\nint main(){\n\n\tint index = 1;\n\tchar buf;\n\tCbot bot;\n\n\tfor (int i = 0; i < 11; i++){\n\t\tfor (int j = 0; j < 11; j++){\n\t\t\twall[i][j] = 0;\n\t\t}\n\t}\n\n\t//??????????????????\n\twhile (1){\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tcin >> buf;\n\t\t\twall[index][(i + 1) * 2] = buf - '0';\n\t\t}\n\t\tindex++;\n\t\tif (index == 10)break;\n\n\t\tfor (int i = 0; i < 5; i++){\n\t\t\tcin >> buf;\n\t\t\twall[index][i * 2 + 1] = buf - '0';\n\t\t}\n\t\tindex++;\n\t}\n\n\tbot.Start();\n\n\tcout << bot.log << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n\tstring in[9];\n\tint x = 0, y = 0, d = 0;\n\t//d..direction  0→、1↓、2←、3↑\n\tfor (int i = 0; i < 9; i++)\n\t\tcin >> in[i];\n\tdo {\n\t\tif (d == 0) {\n\t\t\tif (y > 0) {\n\t\t\t\tif (in[2 * y - 1][x] == '1') {\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t\td = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < in[0].size()) {\n\t\t\t\tif (in[2 * y][x] == '1') {\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < 4) {\n\t\t\t\tif (in[2 * y + 1][x] == '1') {\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t\td = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"L\";\n\t\t\tx--;\n\t\t\td = 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (d == 1) {\n\t\t\tif (x < in[0].size()) {\n\t\t\t\tif (in[2 * y][x] == '1') {\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t\td = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < 4) {\n\t\t\t\tif (in[2 * y + 1][x] == '1') {\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 0) {\n\t\t\t\tif (in[2 * y][x - 1] == '1') {\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t\td = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"U\";\n\t\t\td = 3;\n\t\t\ty--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (d == 2) {\n\t\t\tif (y < 4) {\n\t\t\t\tif (in[2 * y + 1][x] == '1') {\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t\td = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x > 0) {\n\t\t\t\tif (in[2 * y][x - 1] == '1') {\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y > 0) {\n\t\t\t\tif (in[2 * y - 1][x] == '1') {\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t\td = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"R\";\n\t\t\td = 0;\n\t\t\tx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (d == 3) {\n\t\t\tif (x > 0) {\n\t\t\t\tif (in[2 * y][x - 1] == '1') {\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t\td = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y > 0) {\n\t\t\t\tif (in[2 * y - 1][x] == '1') {\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < in[0].size()) {\n\t\t\t\tif (in[2 * y][x] == '1') {\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t\td = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"D\";\n\t\t\td = 1;\n\t\t\ty++;\n\t\t\tcontinue;\n\t\t}\n\t}while (x != 0 || y != 0);\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n//R:0 L:1 U:2 D:3\n\nint map[11][7];\nint type;\nint x=2,y=1;\nchar a[4],b[5];\n\nvoid init(){\n\tfor(int i=1;i<=9;i++){\n\t\tif(i%2){\n\t\t\tcin>>a;\n\t\t\tfor(int n=0;n<4;n++)map[i][n+1]=char(a[n])-'0';\n\t\t}\n\t\telse{\n\t\t\tcin>>b;\n\t\t\tfor(int m=0;m<5;m++)map[i][m+1]=char(b[m])-'0';\n\t\t}\n\t}\n}\n\nvoid Right(){\n\tif(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse if(map[y][x])type=0, x+=1, cout<<'R';\n\telse if(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse  type=1, x-=1, cout<<'L';\n}\n\nvoid Left(){\n\tif(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse if(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse if(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse type=0, x+=1, cout<<'R';\n}\n\nvoid Up(){\n\tif(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse if(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse if(map[y][x])type=0, x+=1, cout<<'R';\n\telse type=3, y+=2, cout<<'D';\n}\n\nvoid Down(){\n\tif(map[y][x])type=0, x+=1, cout<<'R';\n\telse if(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse if(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse type=2, y-=2, cout<<'U';\n}\n\nvoid solve(){\n\twhile(!(x==1&&y==1)){\n\t\tswitch(type){\n\t\t\tcase 0:Right();\n\t\t\t\tbreak;\n\t\t\tcase 1:Left();\n\t\t\t\tbreak;\n\t\t\tcase 2:Up();\n\t\t\t\tbreak;\n\t\t\tcase 3:Down();\n\t\t\t\tbreak;\n\t\t\tdefault: return;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\tcout<<'R';\n\tsolve();\n\tcout<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint points[5][5];\nint dir[4] = {1,2,4,8};\nchar dirc[4] = {'R','D','L','U'};\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n// [0,1,2,3] : [right,bottom,left,top]\n\nint main(){\n  REP(i,9){\n    int x;\n    cin>>x;\n    if(i%2==0){\n      // yokonaga\n      REP(_j,4){\n        int j = 3-_j;\n        int val = x%10;\n        x/=10;\n        if(val==1){\n          points[j][i/2] |= dir[0];\n          points[j+1][i/2] |= dir[2];\n        }\n      }\n    }else{\n      // tatenaga\n      REP(_j,5){\n        int j = 4-_j;\n        int val = x%10;\n        x/=10;\n        if(val==1){\n          points[j][i/2] |= dir[1];\n          points[j][i/2+1] |= dir[3];\n        }\n      }\n    }\n  }\n  // input end\n  int x=0, y=0, d=0;\n  string res = \"\";\n  while(!(x==0 && y==0) || res.size()==0){\n    int kabe = (d+3)%4;\n    if(points[x][y] & dir[kabe]) d = kabe;\n    while(!(points[x][y] & dir[d])) d = (d+1)%4;\n    res += dirc[d];\n    x += dx[d];\n    y += dy[d];\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0){\n    if(way==2)cout<<\"U\";\n    else cout<<\"L\";\n    return;\n  }\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n  }\n}\n\nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define sc(x) cin >> x\n#define sc2(x, y) cin >> x >> y\n#define sc3(x, y, z) cin >> x >> y >> z\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define debugn(i, n, a) rep(i, n)cout << \" --- \" << a[i] << \"\\n\";\n#define debugin(i, n, a) rep(i, n)printf(\" --- %10d\\n\", a[i])\n#define debugi2n(i, n, a, b) rep(i, n)printf(\" --- %10d %10d\\n\", a[i], b[i])\n#define debugiin(i, n, a) rep(i, n)printf(\" --- %10d %10d\\n\", a[i].first, a[i].second)\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n\n\nsigned main(void){\n  int i, j, k;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  string res = \"RDLU\";\n  for(int testcase = 0;testcase < 1234567;testcase++){\n    bool f[11][11] = {false};\n    string s;\n    sc(s);\n    rep(i, 4){\n      if(s[i] == '1')f[1][i * 2 + 2] = true;\n      else f[1][i * 2 + 2] = false;\n    }\n\n    rep(i, 4){\n      sc(s);\n      rep(j, 5){\n        if(s[j] == '1')f[i * 2 + 2][2 * j + 1] = true;\n        else f[i * 2 + 2][2 * j + 1] = false;\n      }\n      sc(s);\n      rep(j, 4){\n        if(s[j] == '1')f[i * 2 + 3][2 * j + 2] = true;\n        else f[i * 2 + 3][2 * j + 2] = false;\n      }\n    }\n/*\n    rep(i, 11){\n      rep(j, 11){\n        if(f[i][j])cout << \"1\";\n        else cout << \"0\";\n      }\n      kara;\n    }*/\n\n    pair<i_i, int> now = mp(mp(0, 2), 0);\n\n    for(int times = 50;times--;){\n      if(f[now.X.X + dx[now.Y]][now.X.Y + dy[now.Y]]){\n        cout << res[now.Y];\n        now.Y = (now.Y + 3) % 4;\n      }else{\n        now.X.X += dx[now.Y] * 2;\n        now.X.Y += dy[now.Y] * 2;\n        cout << res[now.Y];\n        for(int qwe = 4;qwe--;){\n          if(!f[now.X.X + dx[(now.Y + 1) % 4]][now.X.Y + dy[(now.Y + 1) % 4]]){\n            now.Y = (now.Y + 1) % 4;\n            now.X.X += dx[now.Y] * 2;\n            now.X.Y += dy[now.Y] * 2;\n          }else break;\n        }\n      }\n      if(now.X.X == 0 && now.X.Y == 2)break;\n    }\n\n    kara;\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nint main(){\n\tint p[5][5][4];\n\tmemset(p, 0, sizeof(p));\n\tstring s;\n\trep(i, 9){\n\t\tcin>>s;\n\t\trep(j, s.size()){\n\t\t\tif(s[j] == '1'){\n\t\t\t\tif(i%2 == 0){\n\t\t\t\t\tp[i/2][j][0] = 1;\n\t\t\t\t\tp[i/2][j + 1][2] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tp[i/2][j][3] = 1;\n\t\t\t\t\tp[i/2 + 1][j][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dir = 0;\n\ts =\"RULD\";\n\tint x = 0, y = 0;\n\twhile(1){\n\t\tif(dir == 0){\n\t\t\tif(p[y][x][1]){\n\t\t\t\tdir = 1;\n\t\t\t}else if(p[y][x][0]){\n\n\t\t\t}else if(p[y][x][3]){\n\t\t\t\tdir = 3;\n\t\t\t}else if(p[y][x][2]){\n\t\t\t\tdir = 2;\n\t\t\t}\n\t\t}else if(dir == 1){\n\t\t\tif(p[y][x][2]){\n\t\t\t\tdir = 2;\n\t\t\t}else if(p[y][x][1]){\n\n\t\t\t}else if(p[y][x][0]){\n\t\t\t\tdir = 0;\n\t\t\t}else if(p[y][x][3]){\n\t\t\t\tdir = 3;\n\t\t\t}\n\t\t}else if(dir == 2){\n\t\t\tif(p[y][x][3]){\n\t\t\t\tdir = 3;\n\t\t\t}else if(p[y][x][2]){\n\n\t\t\t}else if(p[y][x][1]){\n\t\t\t\tdir = 1;\n\t\t\t}else if(p[y][x][0]){\n\t\t\t\tdir = 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(p[y][x][0]){\n\t\t\t\tdir = 0;\n\t\t\t}else if(p[y][x][3]){\n\n\t\t\t}else if(p[y][x][2]){\n\t\t\t\tdir = 2;\n\t\t\t}else if(p[y][x][1]){\n\t\t\t\tdir = 1;\n\t\t\t}\n\t\t}\n\t\tcout<<s[dir];\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\t//printf(\" (%d, %d)\\n\", x, y);\n\t\tif(x == 0 && y == 0) break;\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            //cout << \"(\" << y << \",\" << x << \",\" << d << \")\" << endl;\n            if (map[y][x][d])\n                ;\n            else if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(void){\n  int state; //ツ前ツ嘉アツづ個督ョツつ「ツつスツ陛サツ古シ\n  int x, y; //current position\n  bool horizon[5][4];\n  bool vertical[4][5];\n  char tmp;\n  int i,j;\n\n  for(i=0;i<9;i++){\n\tif(i%2 == 0){\n\t  for(j=0;j<4;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  horizon[i/2][j] = true;\n\t\t}else{\n\t\t  horizon[i/2][j] = false;\n\t\t}\n\t  }\n\t}else{\n\t  for(j=0;j<5;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  vertical[i/2][j] = true;\n\t\t}else{\n\t\t  vertical[i/2][j] = false;\n\t\t}\n\t  }\n\t}\n  }\n\n  state = 'R';\n  cout << \"R\";\n  x = 0;\n  y = 1;\n  \n  while(!(x == 0 && y == 0)){\n\tif(state == 'R'){\n\t  if(x - 1 >= 0 && vertical[x-1][y] ){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else{\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }\n\t}else if(state == 'D'){\n\t  if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else{\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }\n\t}else if(state == 'L'){\n\t  if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else{\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }\n\t}else{\n\t  if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else if(x >= 1 && vertical[x-1][y]){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else{\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }\n\t}\n\t//cout << x << \" \" << y << endl;\n\t//cin >> i;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define RIGHT 1\n#define LEFT -1\n#define UP 2\n#define DOWN -2\nusing namespace std;\n\nint main(){\n\tint i,j,state,sy=0,sx=1,t_state;\n\tchar row[5][4],col[4][5];\n\n\tcin>>row[0];\n\tfor(i=0;i<4;i++){\n\t\tcin>>col[i];\n\t\tcin>>row[i+1];\n\t}\n\n\tfor(i=0;i<5;i++){\n\t\tfor(j=0;j<4;j++){\n\t\t\trow[i][j]=row[i][j]-'0';\n\t\t}\n\t}\n\tfor(i=0;i<5;i++){\n\t\tfor(j=0;j<4;j++){\n\t\t\tcol[j][i]=col[j][i]-'0';\n\t\t}\n\t}\n\n\tcout<<\"R\"<<flush;\n\tstate=RIGHT;\n\twhile(sy || sx){\n\t\tswitch(state){\n\t\t\tcase RIGHT:\n\t\t\t\tif(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}else if(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}else if(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}else if(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}else if(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}else if(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}else if(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}else if(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}else if(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}else if(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(sx<4 && row[sy][sx]){\n\t\t\t\t\tcout<<\"R\"<<flush;\n\t\t\t\t\tt_state=RIGHT;\n\t\t\t\t\tsx++;\n\t\t\t\t}else if(sy<4 && col[sy][sx]){\n\t\t\t\t\tcout<<\"D\"<<flush;\n\t\t\t\t\tt_state=DOWN;\n\t\t\t\t\tsy++;\n\t\t\t\t}else if(sx>0 && row[sy][sx-1]){\n\t\t\t\t\tcout<<\"L\"<<flush;\n\t\t\t\t\tt_state=LEFT;\n\t\t\t\t\tsx--;\n\t\t\t\t}else if(sy>0 && col[sy-1][sx]){\n\t\t\t\t\tcout<<\"U\"<<flush;\n\t\t\t\t\tt_state=UP;\n\t\t\t\t\tsy--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tstate=t_state;\n\t}\n\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 2;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 0){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&1){t = 3;}\n\telse{y--;}\n      }\n      else{x++;t = 1;}\n    }\n    else if(t == 1){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&2){t = 0;}\n\telse{x++;}\n      }\n      else{y++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&4){t = 1;}\n\telse{y++;}\n      }\n      else{x--;t = 3;}\n    }\n    else if(t == 3){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&8){t = 2;}\n\telse{x--;}\n      }\n      else{y--;t = 0;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(/*x+1<5 && */tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(/* y+1<5 && */ yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(1){\n    c++;\n    mo=false;\n     \n    if(m.x==1&&m.y==1&&m.d==2) {\n      //cout << \"L\";\n      break;\n    }\n    if(m.x==0&&m.y==1&&f) {\n      //cout << \"U\";\n      break;\n    }\n    f=true;\n     \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n    if(st[m.y*2-1][m.x]=='1') {\n      cout << \"U\";\n      m.d=3;\n      continue;\n    }\n      }\n      if(m.y<5){\n    if(st[m.y*2][m.x]=='1') {\n      m.x++;\n      cout << \"R\";\n      continue;\n    }\n      }\n      if(m.y<4){\n    if(st[m.y*2+1][m.x]=='1') {\n      m.x++;\n      m.y++;\n      cout << \"D\";\n      m.d=1;\n      continue;\n    }\n      }\n      m.y++;\n      cout << \"L\";\n      m.d=2;\n      continue;\n    }\n     \n    if(m.d==1){\n      if(m.y<5){\n    if(st[m.y*2][m.x-1]=='1') {\n      cout <<\"R\";\n      m.d=0;\n      continue;\n    }\n      }\n      if(m.x>0&&m.y<4){\n    if(st[m.y*2+1][m.x-1]=='1') {\n      m.y++;\n      cout << \"D\" ;\n      mo=true;\n      continue;\n    }\n      }\n      if(m.x>1&&m.y<5){\n    if(st[m.y*2][m.x-2]=='1') {\n      m.x--;\n      m.y++;\n      cout << \"L\";\n      m.d=2;\n      continue;\n    }\n      }\n      m.x--;\n      cout << \"U\";\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n    if(st[m.y*2-1][m.x-1]=='1') {\n      cout << \"D\";\n      m.d=1;\n      continue;\n    }\n      }\n      if(m.x>1&&m.y>0){\n    if(st[(m.y-1)*2][m.x-2]=='1') {\n      m.x--;\n      cout << \"L\" ;\n      mo=true;\n      continue;\n    }\n      }\n      if(m.x>0&&m.y>1){\n    if(st[(m.y-1)*2-1][m.x-1]=='1') {\n      m.x--;\n      m.y--;\n      cout << \"U\";\n      m.d=3;\n      continue;\n    }\n      }\n      m.y--;\n      cout << \"R\";\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n \n      if(m.y>0){\n    if(st[(m.y-1)*2][m.x-1]=='1') {\n      cout << \"L\";\n      m.d=2;\n      continue;\n    }\n      }\n      if(m.y>1){\n    if(st[(m.y-1)*2-1][m.x]=='1') {\n      m.y--;\n      cout << \"U\" ;\n      mo=true;\n      continue;\n    }\n      }\n      if(m.y>0){\n    if(st[(m.y-1)*2][m.x]=='1') {\n      m.x++;\n      m.y--;\n      cout << \"R\";\n      m.d=0;\n      continue;\n    }\n      }\n      m.x++;\n      cout << \"D\";\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n   \n  cout  << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n//R:0 L:1 U:2 D:3\n\n\nint map[11][7], type, x=2, y=1;\nchar a[4], b[5];\n\n\nvoid init(){\n\tfor(int i=1; i<=9; i++){\n\t\tif(i%2){\n\t\t\tcin>>a;\n\t\t\tfor(int n=0; n<4; n++)map[i][n+1] = char(a[n])-'0';\n\t\t}\n\t\telse {\n\t\t\tcin>>b;\n\t\t\tfor(int m=0; m<5; m++)map[i][m+1] = char(b[m])-'0';\n\t\t}\t\t\t\n\t}\n}\n\n\nvoid Right(){\n\tif(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse if(map[y][x])type=0, x+=1, cout<<'R';\n\telse if(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse  type=1, x-=1, cout<<'L';\n}\nvoid Left(){\n\tif(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse if(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse if(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse type=0, x+=1, cout<<'R';\n}\nvoid Up(){\n\tif(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse if(map[y-1][x])type=2, y-=2, cout<<'U';\n\telse if(map[y][x])type=0, x+=1, cout<<'R';\n\telse type=3, y+=2, cout<<'D';\n}\nvoid Down(){\n\tif(map[y][x])type=0, x+=1, cout<<'R';\n\telse if(map[y+1][x])type=3, y+=2, cout<<'D';\n\telse if(map[y][x-1])type=1, x-=1, cout<<'L';\n\telse type=2, y-=2, cout<<'U';\n}\n\n\nvoid solve(){\n\twhile(!(x==1&&y==1)){\n\t\tswitch(type){\n\t\t\tcase 0: Right(); break;\n\t\t\tcase 1: Left(); break;\n\t\t\tcase 2: Up(); break;\n\t\t\tcase 3: Down(); break;\n\t\t\tdefault: return;\n\t\t}\n\t}\n}\n \nint main(){\n\tinit();\n\t\n\tcout<<'R';\n\tsolve();\n\tcout<<\"\\n\";\t\n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(1){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&m.d==2) {\n      //cout << \"L\";\n      break;\n    }\n    if(m.x==0&&m.y==1&&f) {\n      //cout << \"U\";\n      break;\n    }\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(m.y<5){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.x++;\n\t  cout << \"R\";\n\t  continue;\n\t}\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.x++;\n\t  m.y++;\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      m.y++;\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y<4){\n\tif(st[m.y*2+1][m.x-1]=='1') {\n\t  m.y++;\n\t  cout << \"D\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y<5){\n\tif(st[m.y*2][m.x-2]=='1') {\n\t  m.x--;\n\t  m.y++;\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      m.x--;\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y>0){\n\tif(st[(m.y-1)*2][m.x-2]=='1') {\n\t  m.x--;\n\t  cout << \"L\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y>1){\n\tif(st[(m.y-1)*2-1][m.x-1]=='1') {\n\t  m.x--;\n\t  m.y--;\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      m.y--;\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(m.y>1){\n\tif(st[(m.y-1)*2-1][m.x]=='1') {\n\t  m.y--;\n\t  cout << \"U\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x]=='1') {\n\t  m.x++;\n\t  m.y--;\n\t  cout << \"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      m.x++;\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout  << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(c,i) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nvoid input(bool grid[][9])\n{\n\trep(i,9){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(i%2==0)\n\t\t\trep(j,4)\n\t\t\t\tgrid[i][j*2+1]=s[j]-'0';\n\t\telse\n\t\t\trep(j,5)\n\t\t\t\tgrid[i][j*2]=s[j]-'0';\n\t}\n}\n\nenum dir{\n\tUP,RIGHT,DOWN,LEFT\n};\nconst int di[]={-1,0,1,0};\nconst int dj[]={0,1,0,-1};\nconst char output[]=\"URDL\";\n\nbool in_range(int i,int j)\n{\n\treturn 0<=i && i<9 && 0<=j && j<9;\n}\n\nint main()\n{\n\tbool grid[9][9]={{0}};\n\tinput(grid);\n\t//rep(i,9){\n\t//\trep(j,9)\n\t//\t\tcout<<grid[i][j]<<\" \";\n\t//\tcout<<endl;\n\t//}\n\t\n\tint i=0,j=0;\n\tdir prev=RIGHT;\n\tfor(;;){\n\t\t//printf(\"# (%d,%d) prev:%c\\n\",i,j,output[prev]);\n\t\t\n\t\tdir next[4];\n\t\tif(prev==UP){\n\t\t\tnext[0]=LEFT;next[1]=UP;next[2]=RIGHT;next[3]=DOWN;\n\t\t}\n\t\telse if(prev==RIGHT){\n\t\t\tnext[0]=UP;next[1]=RIGHT;next[2]=DOWN;next[3]=LEFT;\n\t\t}\n\t\telse if(prev==DOWN){\n\t\t\tnext[0]=RIGHT;next[1]=DOWN;next[2]=LEFT;next[3]=UP;\n\t\t}\n\t\telse if(prev==LEFT){\n\t\t\tnext[0]=DOWN;next[1]=LEFT;next[2]=UP;next[3]=RIGHT;\n\t\t}\n\t\tint k;\n\t\tfor(k=0;k<3;k++){\n\t\t\tif(in_range(i+di[next[k]],j+dj[next[k]]) && grid[i+di[next[k]]][j+dj[next[k]]])\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//printf(\"%d(%c)\\n\",k,output[next[k]]);\n\t\tcout<<output[next[k]];\n\t\t\n\t\ti+=di[next[k]]*2;\n\t\tj+=dj[next[k]]*2;\n\t\tprev=next[k];\n\t\t\n\t\tif(i==0 && j==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nconst int horz_node_count = 5;\nconst int vert_node_count = 5;\nconst int direction_count = 4;\t// [0]:left, [1]:up, [2]:right [3]:down\nenum { left, up, right, down };\n\nint index(int x, int y, int direction)\n{\n\treturn (y * horz_node_count + x) * direction_count + direction;\n}\n\nvoid read_data(int* walls)\n{\n\tstd::vector<std::string> input;\n\tfor (int i = 0; i < vert_node_count * 2 - 1; ++i) {\n\t\tstd::string line;\n\t\tif (std::getline(std::cin, line)) {\n\t\t\tinput.push_back(line);\n\t\t}\n\t}\n\n\tstd::fill_n(walls, horz_node_count * vert_node_count * direction_count, 0);\n\n\tfor (int y = 0; y < vert_node_count; ++y) {\n\t\tfor (int x = 0; x < horz_node_count - 1; ++x) {\n\t\t\tif (input[y*2][x] == '1') {\n\t\t\t\twalls[index(x,y,right)] = 1;\n\t\t\t\twalls[index(x+1,y,left)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 0; y < vert_node_count - 1; ++y) {\n\t\tfor (int x = 0; x < horz_node_count; ++x) {\n\t\t\tif (input[y*2+1][x] == '1') {\n\t\t\t\twalls[index(x,y,down)] = 1;\n\t\t\t\twalls[index(x,y+1,up)] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool wall_exists(const int* walls, int x, int y, int direction)\n{\n\treturn (0 <= x && x < horz_node_count)\n\t\t&& (0 <= y && y < vert_node_count)\n\t\t&& (walls[index(x,y,direction)] != 0);\n}\n\nint main()\n{\n\tint walls[horz_node_count * vert_node_count * direction_count] = {};\n\tread_data(walls);\n\n\tint x = 0, y = 0, direction = right;\n\tdo {\n\t\t// determine the next direction\n\t\tdirection = (direction + direction_count - 1) % direction_count;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (wall_exists(walls, x, y, direction)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection = (direction + 1) % direction_count;\n\t\t}\n\t\t// step forward\n\t\tswitch (direction) {\n\t\t\tcase left:\n\t\t\t\t--x;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tbreak;\n\t\t\tcase up:\n\t\t\t\t--y;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tbreak;\n\t\t\tcase right:\n\t\t\t\t++x;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tbreak;\n\t\t\tcase down:\n\t\t\t\t++y;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tbreak;\n\t\t}\n\t} while (x > 0 || y > 0);\n\n\tstd::cout << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int p[5][5][4];\n    for (int i = 0; i < 5; i++)\n        for (int j = 0; j < 5; j++ )\n            for (int k = 0; k < 4; k++) p[i][j][k] = 0;\n    string s;\n    for (int i = 0; i < 4; i++) {\n        cin >> s;\n        for (int j = 0; j < 4; j++) {\n            if (s[j] == '1') {\n                p[i][j][1] = p[i][j+1][3] = 1;\n            }\n        }\n        cin >> s;\n        for (int j = 0; j < 5; j++) {\n            if (s[j] == '1') {\n                p[i][j][2] = p[i+1][j][0] = 1;\n            }\n        }\n    }\n    cin >> s;\n    for (int j = 0; j < 4; j++) {\n        if (s[j] == '1') {\n            p[4][j][1] = p[4][j+1][3] = 1;\n        }\n    }\n    string DIR = \"URDL\";\n    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n    int px = 0, py = 1, dir = 1;\n    cout << \"R\";\n    int q = 0;\n    while ((px != 0 || py != 0) && q++ < 40) {\n        for (int i = 0; i < 4; i++) {\n            if (p[px][py][(((dir + 3) % 4) + i) % 4] == 1) {\n                dir = (((dir + 3) % 4) + i) % 4;\n                px += dx[dir];\n                py += dy[dir];\n                cout << DIR[dir];\n                break;\n            }\n        }\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nint mox[2][2]={{1,-1},{0,-1}},moy[2][2]={{-1,1},{-1,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(!x&&!y){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4,ka=now/2;\n        if(!(now%2)&&y+moy[0][ka]<5&&y+moy[0][ka]>-1&&side[y+moy[1][ka]][x]=='1'){\n            cout<<str[now];\n            serch(x,y+moy[0][ka],now-1);\n        }\n        if(now%2&&x+mox[0][ka]<5&&x+mox[0][now/2]>-1&&Longitudinal[y][x+mox[1][ka]]=='1'){\n            cout<<str[now];\n            serch(x+mox[0][ka],y,now-1);\n        }\n    }\n}\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <bitset>\n#include <cstdint>\n\nint main()\n{\n\tenum { Left, Up, Right, Down };\n\n\ttypedef std::array<std::bitset<4>, 5> Row;\n\ttypedef std::array<Row, 5> Matrix;\n\tMatrix matrix;\n\tfor (auto& row : matrix) {\n\t\trow.fill(std::bitset<4>());\n\t}\n\n\tstd::string input;\n\tstd::getline(std::cin, input);\n\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\tif (input[x] == '1') {\n\t\t\tmatrix[0][x].set(Right);\n\t\t\tmatrix[0][x + 1].set(Left);\n\t\t}\n\t}\n\n\tfor (std::uint16_t y = 0; y < 4U; ++y) {\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 5U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y][x].set(Down);\n\t\t\t\tmatrix[y + 1][x].set(Up);\n\t\t\t}\n\t\t}\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y + 1][x].set(Right);\n\t\t\t\tmatrix[y + 1][x + 1].set(Left);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::uint16_t y = 0, x = 0;\n\tchar direct = 'R';\n\tdo {\n\t\tif (direct == 'R') {\n\t\t\tif (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'D') {\n\t\t\tif (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'L') {\n\t\t\tif (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'U') {\n\t\t\tif (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t}\n\t\tstd::cout << direct << std::flush;\n\t} while (not (y == 0 and x == 0));\n\tstd::cout << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nint mox[2][2]={{1,-1},{0,-1}},moy[2][2]={{-1,1},{-1,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(!x&&!y){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4,ka=now/2;\n        if(!(now%2)&&y+moy[0][ka]<5&&y+moy[0][ka]>-1&&side[y+moy[1][ka]][x]=='1'){\n            cout<<str[now];\n            serch(x,y+moy[0][ka],now-1);\n        }\n        else if(now%2&&x+mox[0][ka]<5&&x+mox[0][now/2]>-1&&Longitudinal[y][x+mox[1][ka]]=='1'){\n            cout<<str[now];\n            serch(x+mox[0][ka],y,now-1);\n        }\n    }\n}\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n\nint main(){\n\n\tint yoko[10][10];\n\tint tate[10][10];\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c-'0';\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\ttate[i][j]=c-'0';\n\t\t\t}\n\t\t}\n\t}\n\tcout<<'R';\n\tint cx=1;\n\tint cy=0;\n\n\t// 0:E,1:º,2:¶,3:ã\n\tint angle=0;\n\twhile(1){\n\t\tint nx=cx;\n\t\tint ny=cy;\n\t\tif(angle==0){\n\t\t\tnx=cx+1;\n\t\t\tny=cy;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'R';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\tif(cy!=0&&tate[cy-1][cx]){\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t\telse if(tate[cy][cx]){\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(angle==1){\n\t\t\tnx=cx;\n\t\t\tny=cy+1;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'D';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// EÌÇðDæ\n\t\t\t\tif(cx!=4&&yoko[cy][cx]){\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t\t// ¶\n\t\t\t\telse if(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tnx=cx-1;\n\t\t\tny=cy;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&yoko[cy][cx-1]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'L';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// ºÌÇªDæ\n\t\t\t\tif(cy!=4&&tate[cy][cx]){\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t\t// ã\n\t\t\t\telse if(cy!=0&&tate[cy-1][cx]){\n\t\t\t\t\tangle=3;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tnx=cx;\n\t\t\tny=cy-1;\n\t\t\t// Çª éÈç\n\t\t\tif(nx>=0&&ny>=0&&ny<5&&nx<5&&tate[cy-1][cx]){\n\t\t\t\tcy=ny;\n\t\t\t\tcx=nx;\n\t\t\t\tcout<<'U';\n\t\t\t}\n\t\t\t// È¢ÈçAü«ðÏX\n\t\t\telse{\n\t\t\t\t// ¶ÌÇðDæ\n\t\t\t\tif(cx!=0&&yoko[cy][cx-1]){\n\t\t\t\t\tangle=2;\n\t\t\t\t}\n\t\t\t\t// E\n\t\t\t\telse if(cx!=4&&yoko[cy][cx]){\n\t\t\t\t\tangle=0;\n\t\t\t\t}\n\t\t\t\t// ÍñÄñ\n\t\t\t\telse{\n\t\t\t\t\tangle=1;\n\t\t\t\t}\n\t\t\t}\t\t\n\t   }\n\t\tif(cx==0&&cy==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}\n\n\n//\n//int main(){\n//\n//\t//while(1){\n//\t\tchar yoko[10][10];\n//\t\tchar tate[10][10];\n//\t\t//memset(yoko,0,sizeof(yoko));\n//\t\t//memset(tate,0,sizeof(tate));\n//\t\tfor(int i = 0; i < 5; i++){\n//\t\t\tfor(int j = 0; j < 4; j++){\n//\t\t\t\tchar c;\n//\t\t\t\tcin>>c;\n//\t\t\t\tyoko[i][j]=c;\n//\t\t\t}\n//\t\t\tif(i!=4){\n//\t\t\t\tfor(int j = 0; j < 5; j++){\n//\t\t\t\t\tchar c;\n//\t\t\t\t\tcin>>c;\n//\t\t\t\t\ttate[i][j]=c;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\t// 0,1,2,3ÅEAºA¶Aã\n//\t\tint angle=0;\n//\t\tint px,py;\n//\t\tpx=py=0;\n//\t\tstring str=\"\";\n//\t\twhile(1){\n//\t\t\tif(angle==0){\n//\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\tstr+='R';\n//\t\t\t\t\tpx++;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ãÖ\n//\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t\t// ºÉÇª êÎAºÖ\n//\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// º\n//\t\t\telse if(angle==1){\n//\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\tstr+='D';\n//\t\t\t\t\tpy++;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª³¯êÎA½]\n//\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t}\n//\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// ¶\n//\t\t\telse if(angle==2){\n//\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\tstr+='L';\n//\t\t\t\t\tpx--;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª êÎAºÖ\n//\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t\t// ãÖ\n//\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\t\tpy--;\n//\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tstr+='U';\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t// ã\n//\t\t\telse if(angle==3){\n//\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\tstr+='U';\n//\t\t\t\t\tpy--;\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\t// ºÉÇª³¯êÎA½]\n//\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t\tangle=2;\n//\t\t\t\t\t\tpx--;\n//\t\t\t\t\t}\n//\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tstr+='R';\n//\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tpx++;\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tpy++;\n//\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tstr+='D';\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(px==0&&py==0){\n//\t\t\t\tbreak;\n//\t\t\t}\n//}\n//\n////cout<<str<<endl;\n////break;\n//\n////}\n//return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint d;\nint x, y;\nbool data[9][5];\n\nmain(){\n  for(int i=0;i<9;i++){\n    for(int j=0;j<5;j++){\n      data[i][j]=false;\n    }\n  }\n  for(int i=0;i<9;i++){\n    for(int j=0;j<=5;j++){\n      char c;\n      scanf(\"%c\", &c);\n      if(c=='\\n') break;\n      if(c=='1') data[i][j]=true;\n    }\n  }\n  \n  x=0;\n  y=0;\n  d=0;\n  for(int i=0;;i++, d++){\n    //    printf(\"(%d,%d,%d)\\n\", x, y, d);\n    if(d==4) d=0;\n    if(d==0){\n      if(y==0) continue;\n      if(data[2*(y-1)+1][x]){\n\tcout << 'U';\n\ty--;\n\td=2;\n      }\n    }else if(d==1){\n      if(x==4) continue;\n      if(data[2*y][x]){\n\tcout << 'R';\n\tx++;\n\td=-1;\n      }\n    }else if(d==2){\n      if(y==4) continue;\n      if(data[2*y+1][x]){\n\tcout << 'D';\n\ty++;\n\td=0;\n      }\n    }else if(d==3){\n      if(x==0) continue;\n      if(data[2*y][x-1]){\n\tcout << 'L';\n\tx--;\n\td=1;\n      }\n    }\n    if(y==0 && x==0) break;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sec second\nint angle=0;\nint edge[6][6][4]={0};\nvector<int> ans;\nP now;\nP nextpoint(P t,int angl)\n{\n\tP f;\n\tf.fi=t.fi;\n\tf.sec=t.sec;\n\tif(angl==0)\n\t{\n\t\tf.sec++;\n\t}\n\tif(angl==1)\n\t{\n\t\tf.fi++;\n\t}\n\tif(angl==2)\n\t{\n\t\tf.sec--;\n\t}\n\tif(angl==3)\n\t{\n\t\tf.fi--;\n\t}\n\treturn f;\n}\nvoid output(int n)\n{\n\tif(n==0)\n\t{\n\t\tcout << 'R';\n\t}\n\telse if(n==1)\n\t{\n\t\tcout << 'D';\n\t}\n\telse if(n==2)\n\t{\n\t\tcout << 'L';\n\t}\n\telse\n\t{\n\t\tcout << 'U';\n\t}\n\treturn ;\n}\nvoid step()\n{\n\tint tmp;\n\tint ans;\n\ttmp=(angle+4-1)%4;\n\twhile(1)\n\t{\n\t\tif(edge[now.fi][now.sec][tmp])break;\n\t\ttmp=(tmp+1)%4;\n\t}\n\tangle=tmp;\n\tP r;\n\tr.fi=nextpoint(now,angle).fi;\n\tr.sec=nextpoint(now,angle).sec;\n\tnow.fi=r.fi;\n\tnow.sec=r.sec;\n\treturn ;\n}\nint main()\n{\n\tnow.fi=1;now.sec=1;\n\tfor(int i=1;i<=9;i++)\n\t{\n\t\tif(i%2==1)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tedge[(i+1)/2][j+1][0]=s[j]-'0';\n\t\t\t\tedge[(i+1)/2][j+2][2]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tedge[i/2][j+1][1]=s[j]-'0';\n\t\t\t\tedge[i/2+1][j+1][3]=s[j]-'0';\n\t\t\t}\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tstep();\n\t\tif(now.fi==1&&now.sec==1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tans.pb(angle);\n\t}\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\toutput(ans[i]);\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dc[]={'R','D','L','U'};\nbool t[5][5][4];\nint flg=0;\nvoid init();\nbool ck(int y,int x,int d){\n\tif(t[y][x][d]==1)return true;\n\tint ny=y+dy[d];\n\tint nx=x+dx[d];\n\tif(t[ny][nx][(d+2)%4]==1)return true;\n\treturn false; \n}\nvoid rec(int y,int x,int d);\nint main(){\n\tinit();\n\t//cout<<\"test\"<<endl;\n\tfor(int i=0;i<=3;i++){\n\t\tfor(int j=0;j<=3;j++){\n\t\t\tcin>>t[i][j][0];\n\t\t}\n\t\tfor(int j=0;j<=4;j++){\n\t\t\tcin>>t[i][j][1];\n\t\t}\n\t}\n\tfor(int i=0;i<=3;i++)cin>>t[4][i][0];\n\t//cout<<\"inputend\"<<endl;\n\trec(0,0,0);\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<5;i++)\n\t\tfor(int j=0;j<5;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tt[i][j][k]=0;\n}\nvoid rec(int y,int x,int d){\n\t//cout<<y << \" \" <<x<<\" \"<<d<<endl;\n\tflg++;\n\tif(y==0&&x==0&&flg>1){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t\n\tint d1=(d+1)%4;\n\tint d2=(d+2)%4;\n\tint d3=(d+3)%4;\n\tif(ck(y,x,d3)){\n\t\tcout<<dc[d3];\n\t\trec(y+dy[d3],x+dx[d3],d3);\n\t}else if(ck(y,x,d)){\n\t\tcout<<dc[d];\n\t\trec(y+dy[d],x+dx[d],d);\n\t}else if(ck(y,x,d1)){\n\t\tcout<<dc[d1];\n\t\trec(y+dy[d1],x+dx[d1],d1);\n\t}else{\n\t\tcout<<dc[d2];\n\t\trec(y+dy[d2],x+dx[d2],d2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char ch[] = {\"ULDR\"};\n\nbool g[10][10][10][10];\n\nint main()\n{\n\tchar c;\n\t\n\tfor (int i = 1; i <= 5; i++){\n\t\tfor (int j = 1; j <= 4; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i][j + 1] = true;\n\t\t\tg[i][j + 1][i][j] = true;\n\t\t}\n\t\tif (i == 5) continue;\n\t\tfor (int j = 1; j <= 5; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i + 1][j] = true;\n\t\t\tg[i + 1][j][i][j] = true;\n\t\t}\n\t}\n\t\n\tint dir = 3;\n\tint x = 1, y = 2;\n\twhile (true){\n\t\tprintf(\"%c\", ch[dir]);\n\t\tif (x == 1 && y == 1) break;\n\t\tfor (int t = -1; t <= 2; t++){\n\t\t\tint nd = (dir + t + 4) % 4;\n\t\t\tint nx = x + dx[nd];\n\t\t\tint ny = y + dy[nd];\n\t\t\tif (g[x][y][nx][ny]){\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t\tdir = nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n\n    while ( true ) {\n        putchar( T[s] );\n        if ( r == 2 && c == 2 && s == L ) break;\n        if ( r == 3 && c == 2 && s == U ) break;\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            }\n        }\n    }\n    putchar( '\\n' );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n\n#define R 1\n#define D 2\n#define L 3\n#define U 4\n\nusing namespace std;\n\nint main(void){\n\n\tint tate[4][5];\n\tchar inp;\n\tint yoko[5][4];\n\tint x,y;\n\tint now;\n\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tinp=getchar();\n\t\t\tyoko[i][j]=(int)(inp-'0');\n\t\t}\n\t\tgetchar();\n\t\tif(i!=4){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tinp=getchar();\n\t\t\t\ttate[i][j]=(int)(inp-'0');\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t}\n\n\tnow=R;\n\tx=0,y=0;\n\twhile(1){\n\t\tif(now==R){\n\t\t\tnow=D;\n\t\t\tif(y-1>=0&&y-1<4&&x>=0&&x<5){\n\t\t\t\tif(tate[y-1][x]==1) now=U;\n\t\t\t}\n\t\t\tif(y>=0&&y<5&&x>=0&&x<4){\n\t\t\t\tif(yoko[y][x]==1){\n\t\t\t\t\tx++;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tnow=R;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(now==D){\n\t\t\tnow=L;\n\t\t\tif(y>=0&&y<5&&x>=0&&x<4){\n\t\t\t\tif(yoko[y][x]==1) now=R;\n\t\t\t}\n\t\t\tif(y>=0&&y<4&&x>=0&&x<5){\n\t\t\t\tif(tate[y][x]==1){\n\t\t\t\t\ty++;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tnow=D;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(now==L){\n\t\t\tnow=U;\n\t\t\tif(y>=0&&y<4&&x>=0&&x<5){\n\t\t\t\tif(tate[y][x]==1) now=D;\n\t\t\t}\n\t\t\tif(y>=0&&y<5&&x-1>=0&&x-1<4){\n\t\t\t\tif(yoko[y][x-1]==1){\n\t\t\t\t\tx--;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tnow=L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(now==U){\n\t\t\tnow=R;\n\t\t\tif(y>=0&&y<5&&x-1>=0&&x-1<4){\n\t\t\t\tif(yoko[y][x-1]==1) now=L;\n\t\t\t}\n\t\t\tif(y-1>=0&&y-1<4&&x>=0&&x<5){\n\t\t\t\tif(tate[y-1][x]==1){\n\t\t\t\t\ty--;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tnow=U;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x==0&&y==0) break;\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 2;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 0){\n      if(field[x][y]&1){\n\tcout <<\"U\";\n\tif(field[x][y]&1){t = 3;}\n\telse{y--;}\n      }\n      else{x++;t = 1;}\n    }\n    else if(t == 1){\n      if(field[x][y]&2){\n\tcout <<\"R\";\n\tif(field[x][y]&2){t = 0;}\n\telse{x++;}\n      }\n      else{y++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&3){\n\tcout <<\"D\";\n\tif(field[x][y]&3){t = 1;}\n\telse{y++;}\n      }\n      else{x--;t = 3;}\n    }\n    else if(t == 3){\n      if(field[x][y]&0){\n\tcout <<\"L\";\n\tif(field[x][y]&0){t = 2;}\n\telse{x--;}\n      }\n      else{y--;t = 0;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst char ch[] = {\"ULDR\"};\n\nbool g[10][10][10][10];\n\nint main()\n{\n\tchar c;\n\t\n\tfor (int i = 1; i <= 5; i++){\n\t\tfor (int j = 1; j <= 4; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i][j + 1] = true;\n\t\t\tg[i][j + 1][i][j] = true;\n\t\t}\n\t\tif (i == 5) continue;\n\t\tfor (int j = 1; j <= 5; j++){\n\t\t\tscanf(\" %c\", &c);\n\t\t\tif (c == '0') continue;\n\t\t\tg[i][j][i + 1][j] = true;\n\t\t\tg[i + 1][j][i][j] = true;\n\t\t}\n\t}\n\t\n\tint dir = 3;\n\tint x = 1, y = 2;\n\twhile (true){\n\t\tprintf(\"%c\", ch[dir]);\n\t\tif (x == 1 && y == 1) break;\n\t\tfor (int t = 1; t >= -2; t--){\n\t\t\tint nd = (dir + t + 4) % 4;\n\t\t\tint nx = x + dx[nd];\n\t\t\tint ny = y + dy[nd];\n\t\t\tif (g[x][y][nx][ny]){\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t\tdir = nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nchar perm_angle[4] = {'R','U','L','D'};\nint grid[5][5][4] = {0};\n\nvoid move(int,int,char);\nchar det_angle(int,int,char);\n\nint main(){\n\tint flag;\n\tfor(int i=0;i<9;i++){\n\t\tif(i%2 == 0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag);\n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"+\";\n\t\t\t\t\tgrid[i/2][j][0]  = 1; //R\n\t\t\t\t\tgrid[i/2][j+1][2]= 1; //L\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag); \n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"-\";\n\t\t\t\t\tgrid[i/2][j][3]  = 1; //D\n\t\t\t\t\tgrid[i/2+1][j][1]= 1; //U\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t//cout << endl;\n\t}\n\t/*for(int i=0;i<5;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcout << 100*i+j;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout <<  \" \"  << grid[i][j][k];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}*/\n//\tif(fscanf(stdin,\"%1d\",&map[i][j]) != EOF){\n\n\t//int x = 0, y = 0;\n\t//char angle = 'R';\n\t/*do{\n\t\tmove(x,y,det_angle(x,y,angle))\n\t}while(x == 0 && y == 0);*/\n\tcout << 'R';\n\tmove(0,1,'R');\n}\n\nvoid move(int x,int y,char angle){\n\tif(x == 0 && y== 0)\n\t\texit(1);\n\t\n\tcout << angle;\n\t\n\tif(angle == 'R'){\n\t\t++y;\n\t}\n\telse if(angle == 'U'){\n\t\t--x;\n\t}\n\telse if(angle == 'L'){\n\t\t--y;\n\t}\n\telse if(angle == 'D'){\n\t\t++x;\n\t}\n\t//cout << \"test\" << x <<\" \" << y;\n\tmove(x,y,det_angle(x,y,angle));\n\t//cout << angle << endl; \n}\n\nchar det_angle(int x,int y,char angle){\n\t\n\t//cout << x << y << \" \" << angle << endl;\n\tint start;\n\tif(angle == 'R'){\n\t\tstart = 5;\n\t}\n\telse if(angle == 'U'){\n\t\tstart = 6;\n\t}\n\telse if(angle == 'L'){\n\t\tstart = 7;\t\n\t}\n\telse if(angle == 'D'){\n\t\tstart = 4;\n\t}\n\t//cout << start << endl;\n\tfor(int i = start;start - i < 4 ;--i){\n\t\tif(grid[x][y][i%4] == 1){\n\t\t\t//cout << \"kettei\" << i <<endl ;\n\t\t\treturn perm_angle[i%4];\n\t\t}\n\t}\n\treturn 'Z';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\nstatic const int X = 11, Y = 11;\nstatic const int DIR = 4;\nstatic const string dirchar= \"RDLU\";\nstatic const int dirx[DIR] = {1,0,-1,0}, diry[DIR] = {0,1,0,-1};\n\nint main(){\n\tint field[X][Y] = {0};\n\tstring s;\n\tint x,y;\n\ty=0;\n\twhile( getline(cin,s) ){\n\t\tfor(x=0;x<s.size();++x)field[x*2+1][y+1] = s[x]-'0';\n\t\ty++;\n\t}\n\tfor(y=1;y<Y;y+=2) for(x=1;x<X;x+=2) if(field[x][y])field[x+1][y] = 1;\n\tfor(y=2;y<Y;y+=2) for(x=1;x<X;x+=2)\n\t\tif(field[x][y]){\n\t\t\tfield[x][y+1] = 1;\n\t\t\tfield[x][y-1] = 1;\n\t\t}\n\tvector<int> ans;\n\tx=y=1;\n\tint dir=0;\n\twhile(true){\n\t\tfor(int i=0; i<DIR; ++i){\n\t\t\tconst int tdir = (dir+DIR-1+i)%DIR;\n\t\t\tif( field[x + dirx[tdir]][y + diry[tdir]] ){\n\t\t\t\tx += dirx[tdir]*2;\n\t\t\t\ty += diry[tdir]*2;\n\t\t\t\tans.push_back(tdir);\n\t\t\t\tdir = tdir;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( x==1 && y==1 )break;\n\t}\n\tfor(int i=0;i<ans.size();++i)cout << dirchar[ans[i]];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>//////////AOJ0037\n                               int\ni,j,w[5][5];char*p,b[1<<7];;   int\nF(int(v)){scanf(\"%s\",b);for(   p=b\n;*p;++p                 ){w[   p-b\n+1-v][j   +v]|=((w[p-   b][j   ]|=\n(*p==49   )<<3-v)&8>>   v)>>   2;}\nreturn(   j+=v          );/*   */}\nmain(){   for(   ;4-F   (0);   F(1\n));for(   p=b,   i=j=   (*b=   3)^\n3;i+=\"\"   \"BA\"          \"BC\"   [*b\n]-66,j=   (*b)[\"ABCB\"]-66+j,   *++\np=\"ULDR   \"[*b],i+j;)for((*    b+=\n1)&=~4;                        !(w\n[i][j]&(1<<*b));(*b+=3)&=3);return\n!puts(b+1);}/*May2018,tw:@siikya*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\nint cnt[100][100];\n\nvoid dfs( int dir, int x, int y, int a ) {\n    // cout << dir << \", \" << x << \", \" << y << endl;\n    cout << D[dir];\n    cnt[y][x]++;\n    if ( x == 0 && y == 0 && cnt[y][x] > 1 ) return;\n\n    if ( dir == RIGHT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 0 );\n            }\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 1 );\n            }\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 1 );\n            }\n        }\n    } else if ( dir == DOWN ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 0 );\n            }\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 1 );\n            }\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 1 );\n            }\n        }\n    } else if ( dir == LEFT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 0 );\n            }\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 0 );\n            }\n        } else {\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 1 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 0 );\n            }\n        }\n    } else if ( dir == UP ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 0 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 0 );\n            }\n        } else {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 1 );\n            }\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 0 );\n            }\n        }\n    }\n}\n\nint main() {\n    for ( int i = 0; i < 100; i++ ) {\n        for ( int j = 0; j < 100; j++ ) {\n            cnt[i][j] = 0;\n        }\n    }\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar go[5] = \"RDLU\";\n\nbool cangocw(int y, int x, int dir, vector<string> &s){\n    if(dir%2==0){\n        return s[2*y +1][x +1-(dir/2)] == '0';\n    }else{\n        return s[2*y +(1-dir/2)*2][x+1] == '0';\n    }\n}\n\nint main(){\n    vector<string> s(11);\n    s[0] = s[10] = \"0000000\";\n    for(int i=1; i<=9; i++){\n        cin >> s[i];\n        s[i] = \"0\" + s[i] + \"0\";\n    }\n    int dir=0;\n    int x=0, y=0;\n    string ans = \"\";\n    \n    do{\n        if(cangocw(y, x, dir, s)){\n            dir = (dir+1)%4;\n            continue;\n        }\n        x += dx[dir];\n        y += dy[dir];\n        ans += go[dir];\n        dir = (dir+3)%4;\n    }while(!(x==0 && y==0 && dir==0));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <algorithm>\n\nusing namespace std;\n\nchar x[11][11];\n\nvoid search(int i, int j, int direction);\n\nint main () {\n    \n    for(int i=0; i<11; i++){\n        for(int j=0; j<11; j++){\n            x[i][j]='0';\n        }\n    }\n\n\n    while(cin\n          >>x[1][2]>>x[1][4]>>x[1][6]>>x[1][8]\n          >>x[2][1]>>x[2][3]>>x[2][5]>>x[2][7]>>x[2][9]\n          >>x[3][2]>>x[3][4]>>x[3][6]>>x[3][8]\n          >>x[4][1]>>x[4][3]>>x[4][5]>>x[4][7]>>x[4][9]\n          >>x[5][2]>>x[5][4]>>x[5][6]>>x[5][8]\n          >>x[6][1]>>x[6][3]>>x[6][5]>>x[6][7]>>x[6][9]\n          >>x[7][2]>>x[7][4]>>x[7][6]>>x[7][8]\n          >>x[8][1]>>x[8][3]>>x[8][5]>>x[8][7]>>x[8][9]\n          >>x[9][2]>>x[9][4]>>x[9][6]>>x[9][8]\n          )\n        \n        \n    {\n        search(1, 1, 1);\n        cout<<endl;\n        \n    }\n    \n    return 0;\n}\n\nvoid search(int i, int j, int direction){\n    while(1){\n    char around[4];\n    around[0]=x[i-1][j];\n    around[1]=x[i][j+1];\n    around[2]=x[i+1][j];\n    around[3]=x[i][j-1];\n    \n    char output[4]={'U','R','D','L'};\n    int next[4]={0,1,2,3};\n    \n        int move[4][2]={0};\n    if(around[0]=='1'){\n        move[0][0]=i-2;move[0][1]=j;\n    }\n    if(around[1]=='1'){\n        move[1][0]=i;move[1][1]=j+2;\n    }\n    if(around[2]=='1'){\n        move[2][0]=i+2;move[2][1]=j;\n    }\n    if(around[3]=='1'){\n        move[3][0]=i;move[3][1]=j-2;\n    }\n    \n    for(int k=0; k<4; k++){\n        int temp = (direction+3+k)%4;\n        if(around[temp]=='1'){\n            direction=next[temp];\n            i=move[temp][0];\n            j=move[temp][1];\n            cout<<output[temp];\n            break;\n        }\n    }\n        if(i==1&&j==1){\n            break;\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 2;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 0){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&2){t = 3;}\n\telse{y--;}\n      }\n      else{x++;t = 1;}\n    }\n    else if(t == 1){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&4){t = 0;}\n\telse{x++;}\n      }\n      else{y++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&8){t = 1;}\n\telse{y++;}\n      }\n      else{x--;t = 3;}\n    }\n    else if(t == 3){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&1){t = 2;}\n\telse{x--;}\n      }\n      else{y--;t = 0;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nlong i,j,k;\nstring s[9];\nfor(i=0;i<9;i++)cin>>s[i];\ni=j=k=0;\ncout<<\"R\";j++;\nfor(;;){\n     if(k==0&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==0&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==0&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==0)                     {cout<<\"L\";j--; k=2;}\nelse if(k==1&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==1&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==1&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==1)                     {cout<<\"U\";i-=2;k=3;}\nelse if(k==2&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==2&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==2&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==2)                     {cout<<\"R\";j++; k=0;}\nelse if(k==3&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==3&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==3&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==3)                     {cout<<\"D\";i+=2;k=1;}\nif(i==0&&j==0)break;\n}\ncout<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar m[10][10];\n\nbool end(int x, int y) {\n  return (x == 1 && y == 1) || (x == 0 && y == 1) ;\n}\n\nvoid check(int x, int y, int d) {\n  printf(\"x,y = %d,%d : %d\\n\", x, y, d);\n  assert(false);\n}\n\nint main() {\n  memset(m, 0, sizeof m);\n  string ans = \"R\";\n  rep(i,9) scanf(\" %s\", m[i]);\n  rep(i,9) {\n    rep(j,5) {\n      m[i][j] = (m[i][j] == '1') ? 1 : 0 ;\n    }\n  }\n  // rep(i,9) {\n  //   rep(j,5) printf(\"%2d\", m[i][j]); puts(\"\");\n  // }\n\n  int x = 1, y = 0, d = 1;\n  do {\n    // printf(\"(%d,%d) : %d : %s\\n\", x, y, d, ans.c_str());\n    switch (d) {\n      case 0: {\n        // up\n        if (m[2*(y-2)+1][x]) {\n          // ok\n          ans += 'U';\n          --y;\n        } else if (m[2*(y-1)][x]) {\n          // ok\n          ans += 'R';\n          d = 1;\n          ++x; --y;\n        } else if (m[2*(y-1)][x-1]) {\n          ans += 'L';\n          d = 3;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 1: {\n        // right\n        if (m[2*y][x]) {\n          // ok\n          ans += 'R';\n          ++x;\n        } else if (m[2*(y-1)+1][x]) {\n          ans += 'U';\n          d = 0;  \n        } else if (m[2*y+1][x]) {\n          // ok\n          ans += 'D';\n          d = 2;\n          ++x; ++y;\n        } else {check(x,y,d);}\n        break;        \n      }\n      case 2: {\n        // down\n        if (m[2*y+1][x-1]) {\n          // ok\n          ans += 'D';\n          ++y;\n        } else if (m[2*y][x-1]) {\n          ans += 'R';\n          d = 1;\n        } else if (m[2*y][x-2]) {\n          // ok\n          ans += 'L';\n          d = 3;\n          --x; ++y;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 3: {\n        // left\n        if (m[2*(y-1)][x-2]) {\n          // ok\n          ans += 'L';\n          --x;\n        } else if (m[2*(y-2)+1][x-1]) {\n          // ok\n          ans += 'U';\n          d = 0;\n          --x; --y;\n        } else if (m[2*(y-1)+1][x-1]) {\n          ans += 'D';\n          d = 2;\n        } else {check(x,y,d);}\n        break;        \n      }\n    }\n  } while (!end(x,y) && ans.size() < 40);\n  if (x == 1 && y == 1 && d == 0) ans += 'L';\n  printf(\"%s\\n\", ans.c_str());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\n\n#define RIGHT 0\n#define DOWN 1\n#define LEFT 2\n#define UP 3\n\nint main(){\n\tbool cross[5][5][4];\t// x,y,dir\n\tint px=0, py=0, dir = RIGHT;\n\tint d[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\n\tstring str;\n\tmemset( cross, 0, sizeof(cross) );\n\tfor( int i=0; i<4; i++ ){\n\t\tgetline( cin, str );\n\t\tfor( int j=0; j<4; j++ ){\n\t\t\tcross[j][i][RIGHT] = cross[j+1][i][LEFT] = (str[j]=='1');\n\t\t}\n\t\tgetline( cin, str );\n\t\tfor( int j=0; j<5; j++ ){\n\t\t\tcross[j][i][DOWN] = cross[j][i+1][UP] = (str[j]=='1');\n\t\t}\n\t}\n\tgetline( cin, str );\n\tfor( int j=0; j<4; j++ ){\n\t\tcross[j][4][RIGHT] = cross[j+1][4][LEFT] = (str[j]=='1');\n\t}\n\tdo{\n\t\tfor( int i=0; i<4; i++ ){\n\t\t\tif( cross[px][py][(dir+3+i)%4] ){\n\t\t\t\tdir = (dir+3+i)%4;\n\t\t\t\tpx += d[dir][0];\n\t\t\t\tpy += d[dir][1];\n//\t\t\t\tcout << (dir==RIGHT)?\"R\":((dir==DOWN)?\"D\":((dir==LEFT)?\"L\":\"U\"));\n\t\t\t\tif( dir == RIGHT ){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t}else if( dir == DOWN ){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t}else if( dir == LEFT ){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t}else if( dir == UP ){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while( px!=0 || py!=0 );\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <array>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nstruct P {int x, y;};\n\nint main() {\n\tconst int d[4][4] = {{0, 0, 1, 0}, {0, -1, 0, -2}, {-1, 0, -1, 0}, {0, 1, 0, 2}};\n\tarray<array<int, 6>, 11> m{};\n\tfor (int i = 1; i <= 9; i++) {\n\t\tfor (int j = 1, e = 5 - i % 2; j <= e; j ++)\n\t\t\tm[i][j] = gcu() - '0';\n\t\tgcu();\n\t}\n\tP p = {1, 1};\n\tint r = 0;\n\tdo {\n\t\tfor (r = (r + 1) % 4;; r = (r + 3) % 4)\n\t\t\tif (m[p.y + d[r][1]][p.x + d[r][0]]) {\n\t\t\t\tp.x += d[r][2], p.y += d[r][3];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tout(\"RULD\"[r]);\n\t} while(!(p.x == 1 && p.y == 1));\n\toutl();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse if(v[y][x]=='0'||y==4) xyf*=-1;\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n\telse if(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse if(v[y-1][x]=='0'||y==0) xyf*=-1;\n\telse{\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse if(h[y][x-1]=='0'||x==0) xyf*=-1;\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse if(h[y][x]=='0'||x==4) xyf*=-1;\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n#define S 6\n// right, down, left, up\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint const MOD = 1000000007;\n\nint main() {\n    bool board[S][S][4] = {};\n    // rep(i,0,S) board[i][S-1][0] = true; // right\n    // rep(i,0,S) board[S-1][i][1] = true; // down\n    // rep(i,0,S) board[i][0][2]   = true; // left\n    // rep(i,0,S) board[0][i][3]   = true; // up\n\n    rep(i,0,9) {\n        int l, n;\n        if(i % 2 == 0) l = 4;\n        else l = 5;\n        rep(j,0,l) {\n            scanf(\"%1d\", &n);\n            if(n == 1) {\n                if(i % 2 == 0) {\n                    board[i/2][j+1][1] = true;\n                    board[i/2+1][j+1][3] = true;\n                }\n                else {\n                    board[i/2+1][j][0] = true;\n                    board[i/2+1][j+1][2] = true;\n                }\n            }\n        }\n    }\n\n    string d = \"RDLU\";\n    string ret;\n    int dir = 0;\n    int nx = 0, ny = 1;\n    int cas = 1;\n    while(1) {\n        int x, y;\n        // printf(\"test: board[%d][%d][%d] = %d\\n\", nx, ny, (dir+1)%4, board[nx][ny][(dir+1)%4] ? 1 : 0);\n        x = nx + dx[dir], y = ny + dy[dir];\n        if(board[nx][ny][(dir + 1) % 4] == 0) {\n            // printf(\"case 1: (%d, %d)\\n\", nx, ny);\n            dir = (dir + 1) % 4;\n            nx = nx + dx[dir], ny = ny + dy[dir];\n            // ret += d[dir];\n            continue;\n        }\n        if(board[nx][ny][dir] == 1) {\n            // printf(\"case 2: (%d, %d)\\n\", nx, ny);\n            if(cas == 1) ret += d[dir];\n            dir = (dir - 1 + 4) % 4;\n            ret += d[dir];\n            cas = 2;\n            continue;\n        }\n        ret += d[dir];\n        nx = x, ny = y;\n        if(nx == 1 && ny == 1 && dir == 2) break;\n        if(nx == 1 && ny == 0 && dir == 3) break;\n    }\n    // printf(\"endx: %d, endy: %d, dir = %d\\n\", nx, ny, dir);\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<pair<int, int>>x[10][10]; string S;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 }; char V[5] = \"RDLU\";\nint main() {\n\tint cnt = 0;\n\tfor (int i = 0; i < 9;i++){\n\t\tcin >> S;\n\t\tif (i % 2 == 0) {\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '0')continue;\n\t\t\t\tx[cnt][j].push_back(make_pair(cnt, j + 1));\n\t\t\t\tx[cnt][j + 1].push_back(make_pair(cnt, j));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '0')continue;\n\t\t\t\tx[cnt][j].push_back(make_pair(cnt + 1, j));\n\t\t\t\tx[cnt + 1][j].push_back(make_pair(cnt, j));\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\tint cx = 0, cy = 0, dir = 0;\n\twhile (true) {\n\t\tcx += dx[dir]; cy += dy[dir]; cout << V[dir];\n\t\tif (cx == 0 && cy == 0)break;\n\t\tfor (int i = 3; i <= 6; i++) {\n\t\t\tint F = (i + dir) % 4;\n\t\t\tfor (int j = 0; j < x[cx][cy].size(); j++) {\n\t\t\t\tif (x[cx][cy][j] == make_pair(cx + dx[F], cy + dy[F])) {\n\t\t\t\t\tdir = F; goto E;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    vector<vector<char> > root (9, vector<char>(5));\n\n    char c;\n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 4 + (i % 2); j++) {\n            cin >> c;\n            root[i][j] = c;\n        }\n    }\n\n    cout << \"R\";\n\n    int x = 1;\n    int y = 0;\n    int d = 2;\n    char dirs [] = { 'L', 'U', 'R', 'D', 'L', 'U', 'R' }; \n\n    while ( x || y ) {\n        bool gone = false;\n        for (int i = -1; i < 2; i++) {\n            switch(dirs[d + i]) {\n                case 'L':\n                    if (x > 0 && root[2 * y][x - 1] == '1') {\n                        x -= 1;\n                        d = 4;\n                        cout << 'L';\n                        gone = true;\n                    }\n                    break;\n                case 'U':\n                    if (y > 0 && root[2 * y - 1][x] == '1') {\n                        y -= 1;\n                        d = 1;\n                        cout << 'U';\n                        gone = true;\n                    }\n                    break;\n                case 'R':\n                    if (x < 4 && root[2 * y][x] == '1') {\n                        x += 1;\n                        d = 2;\n                        cout << 'R';\n                        gone = true;\n                    }\n                    break;\n                case 'D':\n                    if (y < 4 && root[2 * y + 1][x] == '1') {\n                        y += 1;\n                        d = 3;\n                        cout << 'D';\n                        gone = true;\n                    }\n                    break;\n            }\n            if (gone) break;\n        }\n    }\n    cout << endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<endl;\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\t//cout<<endl;\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(x+1<5 && /*y+1<5 &&*/ tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    char ma[11][11];\n    memset(ma,'0',sizeof(ma));\n    for(int i=1;i<10;i++){\n        if(i%2==1)\n            for(int j=2;j<9;j+=2)\n                cin>>ma[i][j];\n        else\n            for(int j=1;j<10;j+=2)\n                cin>>ma[i][j];\n    }\n    int x=1,y=1,dir=0;\n    int mv[4][2]={{2,0},{0,2},{-2,0},{0,-2}};\n    int ts[4][6]={{1,-1,1,0,0,-1},{1,1,0,1,1,0},{-1,1,-1,0,0,1},{-1,-1,0,-1,-1,0}};\n    string str[4]={\"R\",\"D\",\"L\",\"U\"};\n    string path=\"\";\n    int ch=0;\n    for(int k=0;k<40;k++){\n        int wen=1;\n        while(ma[y+ts[dir][3]][x+ts[dir][2]]=='1'){\n            y+=mv[dir][1];\n            x+=mv[dir][0];\n            wen=0;\n            path+=str[dir];\n            wen++;\n        }\n        if(x==1&&y==1)\n            break;\n        if(ma[y+ts[dir][5]][x+ts[dir][4]]=='1')ch=1;\n        do{\n            if(ch==0)dir=(dir+1)%4;\n            else dir=(dir+4-1)%4;\n        }while((y+ts[dir][3]>10||y+ts[dir][3]<0||x+ts[dir][2]>10||x+ts[dir][2]<0)||ma[y+ts[dir][1]][x+ts[dir][0]]=='1');\n        \n    }\n    cout<<path<<endl;\n}\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\nfor(int i=0;i<20;i++){\nfor(int j=0;j<20;j++){\nfor(int k=0;k<4;k++){\nmap[i][j][k]=0;\n}\n}\n}\n}\nvoid setmap(){\nfor(int i=0;i<20;i++){\nfor(int j=0;j<20;j++){\nif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\nif(maphor[i][j]=='1'){\nmap[i][j][0]=1;\n}\n}\nif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\nif(maphor[i][j-1]=='1'){\nmap[i][j][2]=1;\n}\n}\nif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\nif(mapver[i][j]=='1'){\nmap[i][j][3]=1;\n}\n}\nif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\nif(mapver[i-1][j]=='1'){\nmap[i][j][1]=1;\n}\n}\n}\n}\n}\nint solve(){\nint x=0,y=0;\nint v=0;\nstring vec=\"RULD\";\nint loop[4]={1,0,3,2};\nint vx[4]={1,0,-1,0};\nint vy[4]={0,-1,0,1};\nint count=0;\nwhile(1){\ncount++;\nif(count>100)return -1;\nfor(int i=0;i<5;i++){\nif(i==4)return -1;\nif(x==0\n&& y==0\n&&(((v+loop[i])%4)==2)){\nreturn 0;\n}\nif(map[y][x][(v+loop[i])%4]==1){\nv+=loop[i];\nv=v%4;\nx+=vx[v];\ny+=vy[v];\ncout<<vec[v];\nbreak;\n}\n}\n}\n}\nint main(){\nstring tmp;\nfor(int i=0;cin>>tmp;i++){\nif(i%2==0){\nmaphor.push_back(tmp);\n}else{\nmapver.push_back(tmp);\n}\n}\nxsize=maphor[0].size()+1;\nysize=mapver.size()+1;\ninit();setmap();\n/*\nfor(int i=0;i<xsize;i++){\nfor(int j=0;j<ysize;j++){\nfor(int k=0;k<4;k++){\ncout<<map[i][j][k];\n}\ncout<<\" \";\n}\ncout<<endl;\n}\n*/\nif(solve()==-1)return -1;\ncout<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar m[10][10];\n\nbool end(int x, int y) {\n  return (x == 1 && y == 1) || (x == 0 && y == 1) ;\n}\n\nvoid check(int x, int y, int d) {\n  printf(\"x,y = %d,%d : %d\\n\", x, y, d);\n  assert(false);\n}\n\nint main() {\n  memset(m, 0, sizeof m);\n  string ans = \"R\";\n  rep(i,9) scanf(\" %s\", m[i]);\n  rep(i,9) {\n    rep(j,5) {\n      m[i][j] = (m[i][j] == '1') ? 1 : 0 ;\n    }\n  }\n  // rep(i,9) {\n  //   rep(j,5) printf(\"%2d\", m[i][j]); puts(\"\");\n  // }\n\n  int x = 1, y = 0, d = 1;\n  do {\n    // printf(\"(%d,%d) : %d : %s\\n\", x, y, d, ans.c_str());\n    switch (d) {\n      case 0: {\n        // up\n        if (m[2*(y-2)+1][x]) {\n          ans += 'U';\n          --y;\n        } else if (m[2*(y-1)][x]) {\n          ans += 'R';\n          d = 1;\n          ++x; --y;\n        } else if (m[2*(y-1)][x-1]) {\n          ans += 'L';\n          d = 3;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 1: {\n        // right\n        if (m[2*y][x]) {\n          ans += 'R';\n          ++x;\n        } else if (m[2*(y-1)+1][x]) {\n          ans += 'U';\n          d = 0;  \n        } else if (m[2*y+1][x]) {\n          ans += 'D';\n          d = 2;\n          ++x; ++y;\n        } else {check(x,y,d);}\n        break;        \n      }\n      case 2: {\n        // down\n        if (m[2*y+1][x-1]) {\n          ans += 'D';\n          ++y;\n        } else if (m[2*y][x-1]) {\n          ans += 'R';\n          d = 1;\n        } else if (m[2*y][x-2]) {\n          ans += 'L';\n          d = 3;\n          --x; ++y;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 3: {\n        // left\n        if (m[2*(y-1)][x-2]) {\n          ans += 'L';\n          --x;\n        } else if (m[2*(y-2)+1][x-1]) {\n          ans += 'U';\n          d = 0;\n          --x; --y;\n        } else if (m[2*(y-1)+1][x-1]) {\n          ans += 'D';\n          d = 2;\n        } else {check(x,y,d);}\n        break;        \n      }\n    }\n  } while (!end(x,y) && ans.size() < 40);\n  printf(\"%s\\n\", ans.c_str());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar yokosen[7][6];\nchar tatesen[6][7];\n\nint main(){\n\tfor(int i=0;i<9;i++)scanf(\"%s\",i%2?tatesen[i/2+1]+1:yokosen[i/2+1]+1);\n\tint dir=100000;\n\tint row=1;\n\tint col=2;\n\tprintf(\"R\");\n\twhile(1){\n\t//\tprintf(\"\\n%c %c\",tatesen[row][col],yokosen[row][col]);\n\t\tswitch(dir%4){\n\t\t\tcase 0://migi\n\t\t\t\tif(tatesen[row-1][col]=='1'){\n\t\t\t\t\tdir--;\n\t\t\t\t\trow--;\n\t\t\t\t\tprintf(\"U\");\n\t\t\t\t}\n\t\t\t\telse if(yokosen[row][col]=='1'){\n\t\t\t\t\tcol++;\n\t\t\t\t\tprintf(\"R\");\n\t\t\t\t}\n\t\t\t\telse if(tatesen[row][col]=='1'){\n\t\t\t\t\trow++;\n\t\t\t\t\tdir++;\n\t\t\t\t\tprintf(\"D\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcol--;\n\t\t\t\t\tdir+=2;\n\t\t\t\t\tprintf(\"L\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1://shita\n\t\t\t\tif(yokosen[row][col]=='1'){\n\t\t\t\t\tcol++;\n\t\t\t\t\tdir--;\n\t\t\t\t\tprintf(\"R\");\n\t\t\t\t}\n\t\t\t\telse if(tatesen[row][col]=='1'){\n\t\t\t\t\trow++;\n\t\t\t\t\tprintf(\"D\");\n\t\t\t\t}\n\t\t\t\telse if(yokosen[row][col-1]=='1'){\n\t\t\t\t\tcol--;\n\t\t\t\t\tdir++;\n\t\t\t\t\tprintf(\"L\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdir+=2;\n\t\t\t\t\trow--;\n\t\t\t\t\tprintf(\"U\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2://hidari\n\t\t\t\tif(tatesen[row][col]=='1'){\n\t\t\t\t\trow++;\n\t\t\t\t\tdir--;\n\t\t\t\t\tprintf(\"D\");\n\t\t\t\t}\n\t\t\t\telse if(yokosen[row][col-1]=='1'){\n\t\t\t\t\tcol--;\n\t\t\t\t\tprintf(\"L\");\n\t\t\t\t}\n\t\t\t\telse if(tatesen[row-1][col]=='1'){\n\t\t\t\t\tdir++;\n\t\t\t\t\trow--;\n\t\t\t\t\tprintf(\"U\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcol++;\n\t\t\t\t\tdir+=2;\n\t\t\t\t\tprintf(\"R\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3://ue\n\t\t\t\tif(yokosen[row][col-1]=='1'){\n\t\t\t\t\tcol--;\n\t\t\t\t\tdir--;\n\t\t\t\t\tprintf(\"L\");\n\t\t\t\t}\n\t\t\t\telse if(tatesen[row-1][col]=='1'){\n\t\t\t\t\trow--;\n\t\t\t\t\tprintf(\"U\");\n\t\t\t\t}\n\t\t\t\telse if(yokosen[row][col]=='1'){\n\t\t\t\t\tcol++;\n\t\t\t\t\tdir++;\n\t\t\t\t\tprintf(\"R\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdir+=2;\n\t\t\t\t\trow++;\n\t\t\t\t\tprintf(\"D\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif(row==1&&col==1)break;\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\ntemplate<typename V> typename V::value_type sum(const V &v) { return accumulate(all(v), 0); }\nvoid solve();\n\n// clang-format on\n\nmain {\n  vs t(9);\n  rep(i, 9) cin >> t[i];\n  int h = 5, w = t[1].size();\n  vvi m(h, vi(w));\n  rep(i, h) {\n    int k = i * 2;\n    rep(j, t[k].size()) {\n      if (t[k][j] == '1') {\n        m[i][j] += 0b10;\n        m[i][j + 1] += 0b1000;\n      }\n    }\n  }\n  rep(i, h - 1) {\n    int k = i * 2 + 1;\n    rep(j, t[k].size()) {\n      if (t[k][j] == '1') {\n        m[i][j] += 0b100;\n        m[i + 1][j] += 0b1;\n      }\n    }\n  }\n  rep(i, h) {\n    rep(j, w) cerr << setw(3) << m[i][j];\n    cerr << endl;\n  }\n  int x = 0, y = 0, p = 1, wa = 2;\n  char c[] = {'U', 'R', 'D', 'L'};\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {-1, 0, 1, 0};\n  do {\n    // TODO: simulation (aka yarudake)\n    // Sorry, but I have no time to implement it.\n  } while (!(x == 0 && y == 0));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin>>tmp;i++){\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n\tif(row % 2 == 0){\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint checkTable[9][5],row,col;\n\tchar array[9][6];\n\n\tfor(int i = 0; i < 9; i++){\n\t\tfor(int k=0; k < 5; k++){\n\t\t\tcheckTable[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int i=0;i < 9; i++){\n\t\tscanf(\"%s\",array[i]);\n\t}\n\n\tprintf(\"R\");\n\tchar current = 'R';\n\n\tcheckTable[0][0] = 1;\n\n\trow = 0,col = 0;\n\n\tbool FLG = true;\n\n\twhile(FLG){\n\t\tswitch(current){\n\t\tcase 'L':\n\t\t\tif(rangeCheck(row,col-1)&&checkTable[row][col-1] == 0 && array[row][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row][col-1] = 1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(row,col+1)&&checkTable[row][col+1] == 0 && array[row][col+1] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row][col+1] = 2;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row-1,col+1)&&checkTable[row-1][col+1] == 0 && array[row-1][col+1] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col+1] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row+1,col+1)&&checkTable[row+1][col+1] == 0 && array[row+1][col+1] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col+1] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t\tcol = col+1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tif(rangeCheck(row-2,col)&&checkTable[row-2][col] == 0 && array[row-2][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-2][col] = 3;\n\t\t\t\trow = row - 2;\n\t\t\t}else if(rangeCheck(row-1,col-1)&&checkTable[row-1][col-1] == 0 && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row-1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row-1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(row+2,col)&&checkTable[row+2][col] == 0 && array[row+2][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+2][col] = 4;\n\t\t\t\trow = row+2;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row+1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row+1,col-1)&&checkTable[row+1][col-1] == 0 && array[row+1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row+1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row +1;\n\t\t\t\tcol = col -1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tFLG = true;\n\n\twhile(FLG){\n\t\tswitch(current){\n\t\tcase 'L':\n\t\t\tif(rangeCheck(row,col-1)&&checkTable[row][col-1] != 1 && array[row][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row][col-1] = 1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] != 4 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] != 3 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(row,col+1)&&checkTable[row][col+1] != 2 && array[row][col+1] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row][col+1] = 2;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row-1,col+1)&&checkTable[row-1][col+1] != 3 && array[row-1][col+1] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col+1] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row+1,col+1)&&checkTable[row+1][col+1] != 4 && array[row+1][col+1] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col+1] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t\tcol = col+1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tif(rangeCheck(row-2,col)&&checkTable[row-2][col] != 3 && array[row-2][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-2][col] = 3;\n\t\t\t\trow = row - 2;\n\t\t\t}else if(rangeCheck(row-1,col-1)&&checkTable[row-1][col-1] != 1 && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row-1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] != 2 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row-1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(row+2,col)&&checkTable[row+2][col] != 4 && array[row+2][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+2][col] = 4;\n\t\t\t\trow = row+2;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] != 2 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row+1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row+1,col-1)&&checkTable[row+1][col-1] != 1 && array[row+1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row+1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row +1;\n\t\t\t\tcol = col -1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\n\tprintf(\"L\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nint main(){\n    char ma[11][11];\n    memset(ma,'0',sizeof(ma));\n    for(int i=1;i<10;i++){\n        if(i%2==1)\n            for(int j=2;j<9;j+=2)\n                cin>>ma[i][j];\n        else\n            for(int j=1;j<10;j+=2)\n                cin>>ma[i][j];\n    }\n    int x=1,y=1,dir=0;\n    int mv[4][2]={{2,0},{0,2},{-2,0},{0,-2}};\n    int ts[4][8]={{1,-1,1,0,0,-1,0,1},{1,1,0,1,1,0,-1,0},{-1,1,-1,0,0,1,0,-1},{-1,-1,0,-1,-1,0,1,0}};\n    string str[4]={\"R\",\"D\",\"L\",\"U\"};\n    string path=\"\";\n    int ch=0;\n    for(int k=0;k<40;k++){\n        int wen=1;\n        while(ma[y+ts[dir][3]][x+ts[dir][2]]=='1'){\n            y+=mv[dir][1];\n            x+=mv[dir][0];\n            wen=0;\n            path+=str[dir];\n            wen++;\n        }\n        if(x==1&&y==1)\n            break;\n        \n        if(ma[y+ts[dir][5+2*ch]][x+ts[dir][4+2*ch]]=='1')ch=(ch+1)%2;\n        do{\n            if(ch==0)dir=(dir+1)%4;\n            else dir=(dir+4-1)%4;\n        }while((y+ts[dir][3]>10||y+ts[dir][3]<0||x+ts[dir][2]>10||x+ts[dir][2]<0)||ma[y+ts[dir][1]][x+ts[dir][0]]=='1');\n        \n    }\n    cout<<path<<endl;\n}\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF INT_MAX / 3\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef valarray<int> Array;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i];if(i==a.size()-1)cout<<endl;else cout<<\" \";}}\nint gcd(int a,int b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nint lcm(int a,int b){return a==0||b==0?0:a*b/gcd(a,b);}\n\nint a[35];\n\nvoid solve()\n{\n  string ans = \"\";\n  int dir = 0;\n  int now = 0;\n  do\n  {\n    int pre = (dir+2)%4;\n    for(int i=(pre+1)%4;i!=pre;++i%=4)\n    {\n      if(a[now]>>i&1)\n      {\n        dir = i;\n        break;\n      }\n    }\n    switch(dir)\n    {\n      case 0:\n        ans += \"R\";\n        now += 1;\n        break;\n      case 1:\n        ans += \"D\";\n        now += 5;\n        break;\n      case 2:\n        ans += \"L\";\n        now -= 1;\n        break;\n      case 3:\n        ans += \"U\";\n        now -= 5;\n        break;\n    }\n  }\n  while(now != 0);\n  cout << ans << \"\\n\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fill_n(a,35,0);\n  string s;\n  REP(i,9)\n  {\n    cin >> s;\n    if(i%2==0)\n    {\n      int c = i/2;\n      REP(j,4) if(s[j]=='1')\n      {\n        a[c*5+j] += 1;\n        a[c*5+j+1] += 4;\n      }\n    }\n    else\n    {\n      int c = (i-1)/2;\n      REP(j,5) if(s[j]=='1')\n      {\n        a[c*5+j] += 2;\n        a[(c+1)*5+j] += 8;\n      }\n    }\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint map[11][7], type, x = 2, y = 1;\n\nvoid right(void)\n{\n\tif (map[y-1][x]){ type = 2; y -= 2; cout << \"U\"; }\n\telse if (map[y][x]){ type = 0; x += 1; cout << \"R\"; }\n\telse if (map[y+1][x]){ type = 3; y += 2; cout << \"D\"; }\n\telse { type = 1; x -= 1; cout << \"L\"; }\n\treturn;\n}\n\nvoid left(void)\n{\n\tif (map[y+1][x]){ type = 3; y += 2; cout << \"D\"; }\n\telse if (map[y][x-1]){ type = 1; x -= 1; cout << \"L\"; }\n\telse if (map[y-1][x]){ type = 2; y -= 2; cout << \"U\"; }\n\telse { type = 0; x += 1; cout << \"R\"; }\n\treturn;\n}\n\nvoid up(void)\n{\n\tif (map[y][x-1]){ type = 1; x -= 1; cout << \"L\"; }\n\telse if (map[y-1][x]){ type = 2; y -= 2; cout << \"U\"; }\n\telse if (map[y][x]){ type = 0; x += 1; cout << \"R\"; }\n\telse { type = 3; y += 2; cout << \"D\"; }\n\treturn;\n}\n\nvoid down(void)\n{\n\tif (map[y][x]){ type = 0; x += 1; cout << \"R\"; }\n\telse if (map[y+1][x]){ type = 3; y += 2; cout << \"D\"; }\n\telse if (map[y][x-1]){ type = 1; x -= 1; cout << \"L\"; }\n\telse { type = 2; y -= 2; cout << \"U\"; }\n\treturn;\n}\n\nint main(void)\n{\n\tstring a, b;\n\tfor (int i = 1; i <= 9; i++){\n\t\tif (i % 2 == 1){\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tmap[i][j+1] = a[j] - '0';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcin >> b;\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tmap[i][j+1] = b[j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!(x == 1 && y == 1)){\n\t\tswitch(type){\n\t\t\tcase 0:\n\t\t\t\tright();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tleft();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tup();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tdown();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tputs(\"\");\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n \nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n \nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n \n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n                checkTable[i][k][p] = 0;\n            }\n        }\n    }\n \n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n \n    printf(\"R\");\n    char current = 'R';\n \n    checkTable[0][0][1] = 1;\n \n    row = 0,col = 0;\n \n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else{\n                printf(\"U\");\n                checkTable[row][col][2] = 1;\n                current = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n \n   printf(\"\\n\");\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF INT_MAX / 3\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef valarray<int> Array;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i];if(i==a.size()-1)cout<<endl;else cout<<\" \";}}\nint gcd(int a,int b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nint lcm(int a,int b){return a==0||b==0?0:a*b/gcd(a,b);}\n\nint a[35];\n\nvoid solve()\n{\n  string ans = \"\";\n  int pre, i, dir = 0, now = 0;\n  do\n  {\n    pre = (dir+2)%4;\n    for(i=(pre+1)%4;i!=pre;++i%=4)\n    {\n      if(a[now]>>i&1)\n      {\n        dir = i;\n        break;\n      }\n    }\n    if(i == pre) dir = pre;\n    switch(dir)\n    {\n      case 0:\n        ans += \"R\";\n        now += 1;\n        break;\n      case 1:\n        ans += \"D\";\n        now += 5;\n        break;\n      case 2:\n        ans += \"L\";\n        now -= 1;\n        break;\n      case 3:\n        ans += \"U\";\n        now -= 5;\n        break;\n    }\n  }\n  while(now != 0);\n  cout << ans << \"\\n\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fill_n(a,35,0);\n  string s;\n  REP(i,9)\n  {\n    cin >> s;\n    if(i%2==0)\n    {\n      int c = i/2;\n      REP(j,4) if(s[j]=='1')\n      {\n        a[c*5+j] += 1;\n        a[c*5+j+1] += 4;\n      }\n    }\n    else\n    {\n      int c = (i-1)/2;\n      REP(j,5) if(s[j]=='1')\n      {\n        a[c*5+j] += 2;\n        a[(c+1)*5+j] += 8;\n      }\n    }\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\nll grid[6][6];\n// u = 1,r = 2, d = 4, l = 8\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vary(char,v,5,0);\n  rep(i,9){\n    if(i % 2){\n      rep(j,5){\n        cin >> v[j];\n        v[j] -= '0';\n          grid[j+1][i/2+1] |= 8 *v[j];\n          grid[j][i/2+1] |= 2 * v[j];\n      }\n    }\n    else{\n      rep(j,4){\n        cin >> v[j];\n        v[j] -= '0';\n        grid[j+1][i/2+1] |= v[j];\n        grid[j+1][i/2] |= v[j]* 4;\n      }\n    }\n  }\n  ll x = 1,y = 0,c=0,dir = 2;\n  ll u = 1,r = 2, d = 4,l = 8;\n  cout << \"R\";\n  while(1){\n    if(x == 1 && y == 0 && c) break;\n    ++c;\n    if(c > 100)break;\n    if(dir == 0){\n      if(grid[x][y+1] & l){\n        ++y;\n        cout << \"D\";\n      }\n      else if(grid[x-1][y+1] & u){\n        --x;\n        ++y;\n        dir = 1;\n        cout << \"L\";\n      }\n    }\n    else if(dir == 1){\n      if(grid[x-1][y] & u){\n        --x;\n        cout << \"L\";\n      }\n      else if(grid[x-1][y-1] & r){\n        --x;\n        --y;\n        dir = 3;\n        cout << \"U\";\n      }\n    }\n    else if(dir == 2){\n      if(grid[x+1][y] & d){\n        ++x;\n        cout << \"R\";\n      }\n      else if(grid[x+1][y+1] & l){\n        ++x;\n        ++y;\n        dir = 0;\n        cout << \"D\";\n      }\n    }\n    else if(dir == 3){\n      if(grid[x][y-1] & r){\n        --y;\n        cout << \"U\";\n      }\n      else if(grid[x+1][y-1] & d){\n        ++x;\n        --y;\n        dir =2;\n        cout << \"R\";\n      }\n    }\n    if(dir == 0){\n      if(grid[x][y] & d){\n        dir = 2;\n        cout << \"R\";\n        if(grid[x][y] & r){\n          dir = 3;\n          cout << \"U\";\n        }\n      }\n    }\n    else if(dir == 1){\n      if(grid[x][y] & l){\n        dir = 0;\n        cout << \"D\";\n        if(grid[x][y] & d){\n          dir = 2;\n          cout << \"R\";\n        }\n      }\n    }\n    else if(dir == 2){\n      if(grid[x][y] & r){\n        dir = 3;\n        cout << \"U\";\n        if(grid[x][y] & u){\n          dir = 1;\n          cout <<\"L\";\n        }\n      }\n    }\n    else if(dir == 3){\n      if(grid[x][y] & u){\n        dir = 1;\n        cout <<\"L\";\n        if(grid[x][y] & l){\n          dir = 0;\n          cout << \"D\";\n        }\n      }\n    }\n  }\n  cout << endl;\n//   cout << \"u = 1,r = 2, d = 4, l = 8\"<<endl;\n//   rep(i,6){\n//     rep(j,6){\n//       scout(3) << grid[j][i];\n//     }\n//     cout << endl;\n//   }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool t[222][222][4];\nint w,h,n,a[202][202];\nint seach(int x,int y,int d){\n \n  int turn =1,p=0;\n   \n  while(1){\n    if(t[y][x][d])break;\n    t[y][x][d]=1;\n    if(!p){\n      if(d==3)cout<<'R';\n      if(d==2)cout<<'U';\n      if(d==1)cout<<'L';\n      if(d==0)cout<<'D';\n    }\n    p=0;\n\n    \n    if(d==0){\n        if(a[y+1][x]==1)d=3;\n    else if(a[y+2][x]==0){\n      if(a[y+2][x-1]==1)y+=2;\n      else d=1,y+=2,p++;\n    }\n \n    }\n    else if(d==1){\n        if(a[y][x-1]==1)d=0;\n    else if(a[y][x-2]==0){\n      if(a[y-1][x-2]==1)x-=2;\n      else d=2,x-=2,p++;\n    }\n \n    }\n    else if(d==2){\n        if(a[y-1][x]==1)d=1;\n    else if(a[y-2][x]==0){\n      if(a[y-2][x+1]==1)y-=2;\n      else d=3,y-=2,p++;\n    }\n \n    }\n    else if(d==3){\n        if(a[y][x+1]==1)d=2;\n    else if(a[y][x+2]==0){\n      if(a[y+1][x+2]==1)x+=2;\n      else d=0,x+=2,p++;\n    }\n \n      }\n\n  }\n}\nint main(){\n\n    memset(a,0,sizeof(a));\n    int p=0;\n    for(int i=0;i<9;i++){\n      string x;\n      cin>>x;\n      if(i%2){\n        for(int j=0;j<5;j++)if(x[j]=='1')\n          a[i+3][j*2+3]=1,p=i;\n      }\n      else{\n        for(int j=0;j<4;j++)if(x[j]=='1')\n          a[i+3][j*2+1+3]=1,p=i;\n      }\n    }\n    for(int i=0;i<20;i++)a[1][i]=a[i+3][i]=1;\n    for(int i=0;i<20;i++)a[i][1]=a[i][i+3]=1;\n\n    seach(4,2,3);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(c<50){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&f) break;\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"R\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2][m.x]=='1') {\n\tm.x++;\n\tcout << \"R\";\n\tcontinue;\n      }\n      \n      if(st[m.y*2+1][m.x]=='1') {\n\tm.x++;\n\tm.y++;\n\tcout << \"D\";\n\tm.d=1;\n\tcontinue;\n      }\n      m.y++;\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"D\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2+1][m.x-1]=='1') {\n\tm.y++;\n\tcout << \"D\" ;\n\tmo=true;\n\tcontinue;\n      }\n      \n      if(st[m.y*2][m.x-2]=='1') {\n\tm.x--;\n\tm.y++;\n\tcout << \"L\";\n\tm.d=2;\n\tcontinue;\n      }\n      m.x--;\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(st[(m.y-1)*2][m.x-2]=='1') {\n\tm.x--;\n\tcout << \"L\" ;\n\tmo=true;\n\tcontinue;\n      }\n      \n      if(st[(m.y-1)*2-1][m.x-1]=='1') {\n\tm.x--;\n\tm.y--;\n\tcout << \"U\";\n\tm.d=3;\n\tcontinue;\n      }\n      m.y--;\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"U\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      \n      if(st[(m.y-1)*2-1][m.x]=='1') {\n\tm.y--;\n\tcout << \"U\" ;\n\tmo=true;\n\tcontinue;\n      }\n      \n      if(st[(m.y-1)*2][m.x]=='1') {\n\tm.x++;\n\tm.y--;\n\tcout << \"R\";\n\tm.d=0;\n\tcontinue;\n      }\n      m.x++;\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout << \"L\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(c<50){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&f) {\n      cout << \"L\";\n      break;\n    }\n    if(m.x==0&&m.y==1&&f) {\n      //cout << \"U\";\n      break;\n    }\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"R\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(m.y<5){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.x++;\n\t  cout << \"R\";\n\t  continue;\n\t}\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.x++;\n\t  m.y++;\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      m.y++;\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"D\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y<4){\n\tif(st[m.y*2+1][m.x-1]=='1') {\n\t  m.y++;\n\t  cout << \"D\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y<5){\n\tif(st[m.y*2][m.x-2]=='1') {\n\t  m.x--;\n\t  m.y++;\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      m.x--;\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y>0){\n\tif(st[(m.y-1)*2][m.x-2]=='1') {\n\t  m.x--;\n\t  cout << \"L\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y>1){\n\tif(st[(m.y-1)*2-1][m.x-1]=='1') {\n\t  m.x--;\n\t  m.y--;\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      m.y--;\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"U\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(m.y>1){\n\tif(st[(m.y-1)*2-1][m.x]=='1') {\n\t  m.y--;\n\t  cout << \"U\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x]=='1') {\n\t  m.x++;\n\t  m.y--;\n\t  cout << \"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      m.x++;\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout  << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n  \nusing namespace std;\n  \nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0&&way==3){\n  \tcout<<\"L\";\n  \treturn;\n  }\n  if(y==1&&x==0&&way==2){\n  \tcout<<\"U\";\n  \treturn;\n  }\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<5&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x]=='1')solve(y,x,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y][x]=='1')solve(y,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x]=='1')solve(y,x,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y][x]=='1')solve(y,x,2);\n  }\n  return;\n}\n  \nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\tif(flag==false){\n\t\t\tflag=true;\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\ttest(0, 0, 0);\n\t\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n    static bool wall[6][6][4];\n    const int dx[4] = { 1, 0, -1, 0 };\n    const int dy[4] = { 0, 1, 0, -1 };\n    REP(i,6) REP(j,6) REP(k,4) {\n        int ni = i + dy[k];\n        int nj = j + dx[k];\n        if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n            wall[i][j][k] = 0;\n        }\n        else {\n            wall[i][j][k] = 1;\n        }\n    }\n    \n    string s;\n    for(int i = 0; i < 4; i++) {\n        getline(cin, s);\n        for(int j = 0; j < 4; j++) {\n            wall[i][j + 1][1] = (s[j] == '1');\n            wall[i + 1][j + 1][3] = (s[j] == '1');\n        }\n        getline(cin, s);\n        for(int j = 0; j < 5; j++) {\n            wall[i + 1][j][0] = (s[j] == '1');\n            wall[i + 1][j + 1][2] = (s[j] == '1');\n        }\n    }\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n        wall[4][j + 1][1] = (s[j] == '1');\n        wall[5][j + 1][3] = (s[j] == '1');\n    }\n\n    string icon = \"RDLU\";\n#if 0\n    REP(i,6) REP(j,6) {\n        cerr << \"(\" << i << \",\" << j << \")\";\n        REP(k,4) {\n            if(wall[i][j][k] == false) cerr << icon[k];\n        }\n        cerr << endl;\n    }\n#endif\n\n    int X = 1, Y = 0, dir = 0;\n    string ans = \"R\";\n    do {\n#if 0\n        cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n        if(wall[Y][X][dir] == 0) {\n            Y += dy[dir];\n            X += dx[dir];\n\n            if(wall[Y][X][(dir + 1) % 4] == 0) {\n                dir = (dir + 1) % 4;\n                X += dx[dir];\n                Y += dy[dir];\n                if(wall[Y][X][(dir + 1) % 4] == 0) {\n                    dir = (dir + 1) % 4;\n                    X += dx[dir];\n                    Y += dy[dir];\n                }\n                else {\n                    ans.push_back(icon[dir]);\n                }\n            }\n            else {\n                ans.push_back(icon[dir]);\n            }\n        }\n        else {\n            dir = (dir - 1 + 4) % 4;\n            ans.push_back(icon[dir]);\n        }\n    } while(!((X == 1 && Y == 0)));\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n#define S 6\n// right, down, left, up\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint const MOD = 1000000007;\n\nint main() {\n    bool board[S][S][4] = {};\n    // rep(i,0,S) board[i][S-1][0] = true; // right\n    // rep(i,0,S) board[S-1][i][1] = true; // down\n    // rep(i,0,S) board[i][0][2]   = true; // left\n    // rep(i,0,S) board[0][i][3]   = true; // up\n\n    rep(i,0,9) {\n        int l, n;\n        if(i % 2 == 0) l = 4;\n        else l = 5;\n        rep(j,0,l) {\n            scanf(\"%1d\", &n);\n            if(n == 1) {\n                if(i % 2 == 0) {\n                    board[i/2][j+1][1] = true;\n                    board[i/2+1][j+1][3] = true;\n                }\n                else {\n                    board[i/2+1][j][0] = true;\n                    board[i/2+1][j+1][2] = true;\n                }\n            }\n        }\n    }\n\n    string d = \"RDLU\";\n    string ret;\n    int dir = 0;\n    int nx = 0, ny = 1;\n    for(int i=0; i<150; i++) {\n        // printf(\"test: board[%d][%d][%d] = %d\\n\", nx, ny, (dir)%4, board[nx][ny][(dir)%4] ? 1 : 0);\n        if(nx == 1 && ny == 0 && dir == 2) break;\n        if(nx == 0 && ny == 0 && dir == 3) break;\n        int x, y;\n        x = nx + dx[dir], y = ny + dy[dir];\n        if(board[nx][ny][(dir + 1) % 4] == 0) {\n            // printf(\"case 1: (%d, %d)\\n\", nx, ny);\n            dir = (dir + 1) % 4;\n            nx = nx + dx[dir], ny = ny + dy[dir];\n        }\n        else if(board[nx][ny][dir] == 1) {\n            // printf(\"case 2: (%d, %d)\\n\", nx, ny);\n            ret += d[dir];\n            dir = (dir - 1 + 4) % 4;\n        }\n        else {\n            ret += d[dir];\n            nx = x, ny = y;\n        }\n    }\n    // printf(\"endx: %d, endy: %d, dir = %d\\n\", nx, ny, dir);\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int vx[]={1,0,-1,0};\nconst int vy[]={0,-1,0,1};\nconst char vec[]={'R','U','L','D'};\n\nint main(void){\n    string s;\n    int cd=0;\n    int cm[2]={0,1};\n    vector<vector<vector<bool> > >m(5,vector<vector<bool> >(5,vector<bool>(4,false)));\n    for (int i = 0; i < 9; ++i) {\n        cin >> s;\n        for (int j = 0; j < s.length(); ++j) {\n            if (i % 2 == 0) {\n                if (s[j] == '1') {\n                    m[i / 2][j][0] = true;\n                    m[i / 2][j + 1][2] = true;\n                }\n            } else {\n                if (s[j] == '1') {\n                    m[(i - 1) / 2][j][3] = true;\n                    m[(i + 1) / 2][j][1] = true;\n                }\n            }\n        }\n    }\n        int nd[4];\n        int d;\n        cout<<\"R\";\n        while(cm[0]!=0||cm[1]!=0){\n            for (int i = 0; i < 4; ++i) {\n                d=(cd+1-i>3)?0:cd+1-i;\n                if(d<0)d+=4;\n                nd[i]=d;\n            }\n            for (int i = 0; i < 4; ++i) {\n                if(m[cm[0]][cm[1]][nd[i]]){\n                    cm[0]+=vy[nd[i]];\n                    cm[1]+=vx[nd[i]];\n                    cd=nd[i];\n                    cout<<vec[nd[i]];\n                    break;\n                }\n            }\n        }\n        cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar w[10][8];\n\nint dd[4][2] = {{0,1},{1,0},{0,-1},{-1,0}}, k;\nchar dr[8] = \"RDLU\";\nint pos[2] = {0,1};\n\nbool existWall(int i){\n    int rem = (k+i+4)%4;\n    if( pos[0] == 0 && rem == 3 ) return false;\n    if( pos[1] == 0 && rem == 2 ) return false;\n    if( rem%2 ){\n        return w[2*pos[0]+2-rem][pos[1]] == '1';\n    }else{\n        return w[2*pos[0]][pos[1]-rem/2] == '1';\n    }\n}\n\nint main(){\n    for(int i = 0; i < 9; i++){\n        cin >> w[i];\n    }\n    cout << 'R';\n    k = 0;\n    while( pos[0] != 0 || pos[1] != 0 ){\n        for(int i = -1; i < 3; i++){\n            if( existWall(i) ){\n                k = (k+i+4)%4;\n                break;\n            }\n        }\n        pos[0] += dd[k][0];\n        pos[1] += dd[k][1];\n        cout << dr[k];\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint main() {\n\tint g[100][100];\n\tmemset(g, 0, sizeof(g));\n\trep(i, 9) rep(j, 4 + i % 2) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tg[i + 1][j * 2 + (i + 1) % 2 + 1] = c - '0';\n\t}\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {-1, 0, 1, 0};\n\tchar c[] = \"URDL\";\n\tint x = 2, y = 0, v = 1;\n\tdo {\n\t\tcout << c[v];\n\t\tint pv = (v - 1 + 4) % 4;\n\t\tint nv = (v + 1) % 4;\n\t\tint nnv = (v + 2) % 4;\n\t\t\n\t\tif (g[y + dy[v]][x + dx[v]] == 1) {\n\t\t\tv = pv;\n\t\t}\n\t\telse if (g[y + dy[v] * 2 + dy[nv]][x + dx[v] * 2 + dx[nv]] == 1) {\n\t\t\tx += dx[v] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t}\n\t\telse if (g[y + dy[v] * 2 + dy[nv] * 2 + dy[nnv]][x + dx[v] * 2 + dx[nv] * 2 + dx[nnv]] == 1) {\n\t\t\tx += dx[v] * 2;\n\t\t\tx += dx[nv] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t\ty += dy[nv] * 2;\n\t\t\tv = nv;\n\t\t}\n\t\telse {\n\t\t\tx += dx[nv] * 2;\n\t\t\ty += dy[nv] * 2;\n\t\t\tv = nnv;\n\t\t}\n\t\tif (x == 0 && y == 0) break;\n\t\tif (x == 2 && y == 0) break;\n\t} while(true);\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring wall[9];\n\nint dy[4]={1,0,-1,0};\nint dx[4]={0,1,0,-1};\n\ninline int iswall(int cx,int cy,int d){\n\tswitch(d){\n\t\tcase 0:\n\t\t\tcy=2*cy;\n\t\t\tcx=cx-1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcy=2*cy-1;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcy=2*cy-2;\n\t\t\tcx=cx-1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcy=2*cy-1;\n\t\t\tcx=cx-1;\n\t\t\tbreak;\n\t}\n\tif(cy<0||9<=cy||cx<0||5<=cx) return 0;\n\n\treturn wall[cy][cx]=='1';\n}\n\nint main(void){\n\trep(i,9){\n\t\tcin >> wall[i];\n\t\tif(wall[i].size()==4) wall[i]+=\"0\";\n\t}\n\tint cx=1,cy=0,cd=1;\n\tmap<int,char> dir;\n\tdir[0]='D',dir[1]='R',dir[2]='U',dir[3]='L';\n\twhile(1){\n\t\trep(i,4){\n\t\t\tint nd=(cd+i+3)%4;\n\t\t\tif(!iswall(cx,cy,nd)){\n\t\t\t\tif(i) cout << dir[nd];\n\t\t\t\tcy+=dy[nd],cx+=dx[nd],cd=nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(cx==1&&cy==0) break;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst char dir[] = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            if (map[y][x][d])\n                ;\n            else if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n        cout << endl;\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint a[12][12];\nint dx[4]  = {1,0,-1,0};\nint dy[4]  = {0,1,0,-1};\nchar dc[4] = {'R','D','L','U'};\n\n//©ªÌüÍS}XÌÇÌóÔð²×é\nvoid cheakWall(int* wall , const int& px ,const int& py ,const int& d ){\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = px + dx[(d+i)%4];\n\t\tint my = py + dy[(d+i)%4];\n\t\twall[i] = a[my][mx];\n\t}\n}\n\n//iñ¾ü«ðL^\nvoid record(string& s,int* wall,const int d){\n\tif( wall[1] ){\n\t\ts.push_back( dc[d] );\n\t}\n}\n\n//iÞ\nvoid go(int& px, int& py, const int& d,int* wall, string& s){\n\tpx += dx[d]*2;\n\tpy += dy[d]*2;\n\trecord( s , wall , d );\n}\n\nint main(){\n\tstring s;\n\n\t//zñÌú»\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tfor(int x=0 ; x<12 ; ++x )\n\t\t\ta[y][x] = 0;\n\n\t//üÍ\n\tfor(int i=0 ; i<9 ; ++i ){\n\t\tcin >> s;\n\t\tint y = i+1;\n\t\tint x = (i+1)%2 + 1;\n\t\tfor(int j=0 ; j<(int)s.size() ; ++j , x+=2 ){\n\t\t\ta[y][x] = s[j] - '0';\n\t\t}\n\t}\n\n\tint px = 2, py = 0, d = 0;\n\tbool flag = false;\n\ts.clear();\n\n\twhile( 1 ){\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tint wall[4]; \n\t\t//©ªÌüèÌóÔ\n\t\tcheakWall( wall , px , py , d );\n\n\t\tif( !wall[1] ){//EªÇ¶áÈ©Á½ç\n\t\t\t//ü«ðEü«Éñé\n\t\t\td = (d+1)%4;\n\t\t\t//iÞ\n\t\t\tgo( px , py , d , wall , s );\n\t\t\tflag = false;\n\t\t}else{\n\t\t\tif( !wall[0] ){//OªÇ¶áÈ©Á½ç\n\t\t\t\t//iÞ\n\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\tflag = false;\n\t\t\t}else{\n\t\t\t\tif( !wall[3] ){//¶ªÇ¶áÈ©Á½ç\n\t\t\t\t\tif( flag == false ){\n\t\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\t\trecord( s , wall , d );\n\t\t\t\t\t}\n\t\t\t\t\t//ü«ð¶ü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iÞ\n\t\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\t\tflag = false;\n\t\t\t\t}else{//OEEE¶ªÇ¾Á½ç\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\trecord( s , wall , d );\n\t\t\t\t\t//ü«ðEü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\ts.push_back( dc[d] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nint maze[20][20];\n\nchar s[6];\nchar ans[100];\nint sz=0;\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nchar sym[]=\"RDLU\";\n\nint main(){\n  REP(i,9){\n    scanf(\"%s\",s);\n    REP(j,strlen(s)){\n      if (i%2==0){\n\tmaze[i+1][2*j+2]=s[j]-'0';\n      }else{\n\tmaze[i+1][2*j+1]=s[j]-'0';\n      }\n    }\n  }\n  ans[0]='R';\n  sz++;\n  int x=3,y=1;\n  int dir=0;\n  while (x!=1 || y!=1){\n    REP(i,4){\n      int d=(dir+3+i)%4;\n      if (maze[y+dy[d]][x+dx[d]]){\n\tdir=d;\n\tbreak;\n      }\n    }\n    x+=dx[dir]*2;\n    y+=dy[dir]*2;\n    ans[sz++]=sym[dir];\n  }\n  printf(\"%s\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint i, j, a[6][6] = {}, b[6][5] = {};\nstring output = \"\";\n\nint right(), left(), up(), down();\n\nint right(){\n\toutput += \"R\";\n\tif(b[i-1][j] == 1){\n\t\ti--;\n\t\tup();\n\t}\n\telse if(a[i][j+1] == 1){\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i][j + 1] == 2) {  }\n\telse {\n\t\tdown();\n\t}\n\treturn 0;\n}\n\nint left(){\n\toutput += \"L\";\n\tif (b[i][j-1] == 1) {\n\t\tj--;\n\t\tdown();\n\t}\n\telse if (a[i][j-1] == 1) {\n\t\tj--;\n\t\tleft();\n\t}\n\telse if (a[i][j - 1] == 2) { output += \"L\"; }\n\telse {\n\t\ti--;\n\t\tj--;\n\t\tup();\n\t}\n\treturn 0;\n}\n\nint up(){\n\toutput += \"U\";\n\tif (a[i][j] == 1) {\n\t\tleft();\n\t}\n\telse if (a[i][j] == 2) { output += \"L\"; }\n\telse if (b[i-1][j] == 1) {\n\t\ti--;\n\t\tup();\n\t}\n\telse if (a[i][j + 1] == 2) {  }\n\telse {\n\t\tj++;\n\t\tright();\n\t}\n\treturn 0;\n}\n\nint down(){\n\toutput += \"D\";\n\tif (a[i+1][j+1] == 1) {\n\t\ti++;\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i + 1][j + 1] == 2) {  }\n\telse if (b[i + 1][j] == 1) {\n\t\ti++;\n\t\tdown();\n\t}\n\telse if (a[i + 1][j] == 2) { output += \"L\"; }\n\telse {\n\t\ti++;\n\t\tleft();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tstring input, k;\n\tfor(i = 1; i<10;i++){\n\t\tgetline(cin, input);\n\t\tif (input.size() != 4) {\n\t\t\tfor(int j= 0;j<5;j++){\n\t\t\t\tk = input[j];\n\t\t\t\tb[i / 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1;j<5;j++){\n\t\t\t\tk = input[j-1];\n\t\t\t\ta[(i + 1)/ 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\n\t}\n\n\ta[1][1] = 2;\n\ti = 1;\n\tj = 1;\n\tright();\n\tcout << output << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unistd.h>\n#define U 0\n#define R 1\n#define D 2\n#define L 3\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nint wall[5][5];\nchar buf[128];\nvoid readH(int y){\n  read(0,buf,6);buf[4]=0;\n  for (int i=0; i<4; i++){\n    wall[i][y] |= (buf[i]=='1') << R;\n    wall[i+1][y] |= (buf[i]=='1') << L;\n  }\n}\nvoid readV(int y){\n  read(0,buf,7);buf[5]=0;\n  for (int i=0; i<5; i++){\n    wall[i][y] |= (buf[i]=='1') << D;\n    wall[i][y+1] |= (buf[i]=='1') << U;\n  }\n}\nint main(void){\n  int x,y,dir;\n  \n  for (int i=0; i<4; i++){\n    readH(i); readV(i);\n  }\n  readH(4);\n  \n/*  for (int y=0; y<=4; y++){\n    for (int x=0; x<=4; x++){\n      printf(\"%x \", wall[x][y]);\n    }puts(\"\");\n  }\n  */\n  for(x=y=(dir=R)^R;x+=dx[dir],y+=dy[dir],write(1,&(*buf=\"URDL\"[dir]),1),x+y;){\n    for((dir+=3)&=~4;!(wall[x][y]&(1<<dir)); (dir+=1)&=~4){\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nstruct P {\n  bool r, d, l, u;\n  P() { r = d = l = u = false; }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  string s;\n  P p[5][5];\n  for (int i = 0; i < 9; i++) {\n    cin >> s;\n    if (i & 1) {\n      for (int j = 0; j < 5; j++) {\n        if (s[j] == '1') p[i / 2][j].d = p[i / 2 + 1][j].u = true;\n      }\n    } else {\n      for (int j = 0; j < 4; j++) {\n        if (s[j] == '1') p[i / 2][j].r = p[i / 2][j + 1].l = true;\n      }\n    }\n  }\n  string ans = \"R\";\n  int y = 0, x = 1, d = 0;\n  while (!(y == 0 && x == 0)) {\n    if (d == 0) {\n      if (p[y][x].u) y--, d = 3, ans += 'U';\n      else if (p[y][x].r) x++, d = 0, ans += 'R';\n      else if (p[y][x].d) y++, d = 1, ans += 'D';\n      else x--, d = 2, ans += 'L';\n    } else if (d == 1) {\n      if (p[y][x].r) x++, d = 0, ans += 'R';\n      else if (p[y][x].d) y++, d = 1, ans += 'D';\n      else if (p[y][x].l) x--, d = 2, ans += 'L';\n      else y--, d = 3, ans += 'U';\n    } else if (d == 2) {\n      if (p[y][x].d) y++, d = 1, ans += 'D';\n      else if (p[y][x].l) x--, d = 2, ans += 'L';\n      else if (p[y][x].u) y--, d = 3, ans += 'U';\n      else x++, d = 0, ans += 'R';\n    } else {\n      if (p[y][x].l) x--, d = 2, ans += 'L';\n      else if (p[y][x].u) y--, d = 3, ans += 'U';\n      else if (p[y][x].r) x++, d = 0, ans += 'R';\n      else y++, d = 1, ans += 'D';\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nenum Direction {R, L, U, D};\n\nbool input(char b[][5])\n{\n\tchar dummy;\n\tfor (int i=0; i<9; i++) {\n\t\tfor (int j=0; j<5; j++) {\n\t\t\tif ((i&1)==0 && j==4) continue;\n\t\t\tif ( !(cin >> b[i][j]) ) return false;\n\t\t}\n\t\t//cin >> dummy;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tchar board[9][5];\n\tinput(board);\n\t\n\tpair<int, int> curr_pos = (board[1][0] == '1') ? pair<int,int>(1,0) : pair<int,int>(0,0);\n\tenum Direction curr_dir = (board[1][0] == '1') ? D : R;\n\tcout << curr_dir;\n\t\n\tdo {\n\t\tswitch (curr_dir) {\n\t\tcase R:\n\t\t\t// priority : U > R > D\n\t\t\tif ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--; curr_pos.second++;\n\t\t\t} else if ( curr_pos.second < 3 && board[curr_pos.first][curr_pos.second+1] == '1' ){\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.second++;\n\t\t\t} else {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++; curr_pos.second++;\n\t\t\t} \n\t\t\tbreak;\n\t\tcase L:\n\t\t\t// priority : D > L > U\n\t\t\tif ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.second--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\t// priority : L > U > R\n\t\t\tif ( curr_pos.second > 0 && board[curr_pos.first-1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first--; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 2 && board[curr_pos.first-2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first-=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\t// priority : R > D > L\n\t\t\tif ( board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.first < 6 && board[curr_pos.first+2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first+=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first++; curr_pos.second--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ( curr_pos.first != 0 || curr_pos.second != 0 );\n\t\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n\n    while ( true ) {\n        putchar( T[s] );\n        if ( r == 2 && c == 2 && s == L ) break;\n        if ( r == 3 && c == 2 && s == U ) break;\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else {\n                break;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else {\n                break;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else {\n                break;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else {\n                break;\n            }\n        }\n    }\n    putchar( '\\n' );\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n\n#define R 1\n#define D 2\n#define L 3\n#define U 4\n\nusing namespace std;\n\nint main(void){\n\n\tint tate[6][7]={0};\n\tchar inp;\n\tint yoko[7][6]={0};\n\tint x,y;\n\tint now;\n\n\tfor(int i=1;i<6;i++){\n\t\tfor(int j=1;j<5;j++){\n\t\t\tinp=getchar();\n\t\t\tyoko[i][j]=(int)(inp-'0');\n\t\t}\n\t\tgetchar();\n\t\tif(i!=5){\n\t\t\tfor(int j=1;j<6;j++){\n\t\t\t\tinp=getchar();\n\t\t\t\ttate[i][j]=(int)(inp-'0');\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t}\n\tnow=R;\n\tbool f=false;\n\tx=1,y=1;\n\twhile(1){\n\t\tif(now==R){\n\t\t\tnow=D;\n\t\t\tif(tate[y-1][x]==1&&f==false) now=U,f=true;\n\t\t\telse if(yoko[y][x]==1){\n\t\t\t\tx++;\n\t\t\t\tcout<<\"R\";\n\t\t\t\tnow=R;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(now==D){\n\t\t\tnow=L;\n\t\t\tif(yoko[y][x]==1&&f==false) now=R,f=true;\n\t\t\telse if(tate[y][x]==1){\n\t\t\t\ty++;\n\t\t\t\tcout<<\"D\";\n\t\t\t\tnow=D;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(now==L){\n\t\t\tnow=U;\n\t\t\tif(tate[y][x]==1&&f==false) now=D,f=true;\n\t\t\telse if(yoko[y][x-1]==1){\n\t\t\t\tx--;\n\t\t\t\tcout<<\"L\";\n\t\t\t\tnow=L;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(now==U){\n\t\t\tnow=R;\n\t\t\tif(yoko[y][x-1]==1&&f==false) now=L,f=true;\n\t\t\telse if(tate[y-1][x]==1){\n\t\t\t\ty--;\n\t\t\t\tcout<<\"U\";\n\t\t\t\tnow=U;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(x==1&&y==1) break;\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nvoid serch(int x,int y,int then)\n{\n    if(then==0){\n        if(x+1<5&&Longitudinal[y][x]=='1'){\n            cout<<\"R\";\n            serch(x+1,y,0);\n        }\n        else if(y-1>-1&&side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n        else if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n    }\n    else if(then==1){\n        if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n        else if(x+1<5&&Longitudinal[y][x]=='1'){\n            cout<<\"R\";\n            serch(x+1,y,0);\n        }\n        else if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n            cout<<\"L\";\n            serch(x-1,y,2);\n        }\n    }\n    else if(then==2){\n        if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n        cout<<\"L\";\n        serch(x-1,y,2);\n        }\n        else if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n        else if(y-1>-1&&side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n    }\n    else{\n        if(y-1>-1&&side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n        else if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n            cout<<\"L\";\n            serch(x-1,y,2);\n        }\n        else if(x+1<5&&Longitudinal[y][x]=='1'){\n            cout<<\"R\";\n            serch(x+1,y,0);\n        }\n    }\n}\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    serch(0,0,0);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<endl;\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\t//cout<<endl;\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nmain(){\ncout << \"«ã¤èÍz\"<<endll;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;++i)\nint main()\n{\n\tint f[5][5]={{0}};\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\tint d=p;\n\t\tdo\n\t\t\td=(d+1)%4;\n\t\twhile(!((f[y][x]>>d)&1));\n\t\tp=d;\n\t\tputchar(\"URDL\"[d]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[d];\n\t\ty+=dy[d];\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct block{\n  bool right;\n  bool down;\n  bool left;\n  bool up;\n  block():right(false),down(false),left(false),up(false){}\n};\nvoid ud(block* b,string& s,int row){\n  for(int i=0;i<4;i++){\n    if(s[i]=='1'){\n      b[row*6+i+1].down=true;\n      b[(row+1)*6+i+1].up=true;\n    }\n  }\n}\nvoid lr(block* b,string& s,int row){\n  for(int i=0;i<5;i++){\n    if(s[i]=='1'){\n      b[row*6+i].right=true;\n      b[row*6+i+1].left=true;\n    }\n  }\n}\nenum direction{UP,RIGHT,DOWN,LEFT};\n\nint main(){\n  block b[36]{};\n  int p=1;\n  direction d=direction::RIGHT;\n  string s;\n  cin>>s; ud(b,s,0);\n  cin>>s; lr(b,s,1);\n  cin>>s; ud(b,s,1);\n  cin>>s; lr(b,s,2);\n  cin>>s; ud(b,s,2);\n  cin>>s; lr(b,s,3);\n  cin>>s; ud(b,s,3);\n  cin>>s; lr(b,s,4);\n  cin>>s; ud(b,s,4);\n  do{\n    switch(d){\n    case direction::UP:\n      cout<<\"U\";\n      if(b[p].up){\n\td=direction::LEFT;\n      }else{\n\tp-=6;\n\tif(!b[p].right){\n\t  p+=1;\n\t  d=direction::RIGHT;\n\t  if(!b[p].down){\n\t    p+=6;\n\t    d=direction::DOWN;\n\t  }\n\t}\n      }\n      break;\n    case direction::RIGHT:\n      cout<<\"R\";\n      if(b[p].right){\n\td=direction::UP;\n      }else{\n\tp+=1;\n\tif(!b[p].down){\n\t  p+=6;\n\t  d=direction::DOWN;\n\t  if(!b[p].left){\n\t    p-=1;\n\t    d=direction::LEFT;\n\t  }\n\t}\n      }\n      break;\n    case direction::DOWN:\n      cout<<\"D\";\n      if(b[p].down){\n\td=direction::RIGHT;\n      }else{\n\tp+=6;\n\tif(!b[p].left){\n\t  p-=1;\n\t  d=direction::LEFT;\n\t  if(!b[p].up){\n\t    p-=6;\n\t    d=direction::UP;\n\t  }\n\t}\n      }\n      break;\n    case direction::LEFT:\n      cout<<\"L\";\n      if(b[p].left){\n\td=direction::DOWN;\n      }else{\n\tp-=1;\n\tif(!b[p].up){\n\t  p-=6;\n\t  d=direction::UP;\n\t  if(!b[p].right){\n\t    p+=1;\n\t    d=direction::RIGHT;\n\t  }\n\t}\n      }\n      break;\n    }\n  }while(p!=1);\n  cout<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\n\nvoid dfs( int dir, int x, int y ) {\n    cout << D[dir];\n\n    if ( dir == RIGHT ) {\n        if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n            return dfs( UP, x+1, y-1 );\n        }\n        if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n            return dfs( RIGHT, x+1, y );\n        }\n        if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n            return dfs( DOWN, x+1, y+1 );\n        }\n    } else if ( dir == DOWN ) {\n        if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n            return dfs( RIGHT, x, y+1 );\n        }\n        if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n            return dfs( DOWN, x, y+2 );\n        }\n        if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y+1 );\n        }\n    } else if ( dir == LEFT ) {\n        if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n            return dfs( DOWN, x, y+1 );\n        }\n        if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y );\n        }\n        if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n            return dfs( UP, x, y-1 );\n        }\n    } else if ( dir == UP ) {\n        if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n            return dfs( LEFT, x-1, y-1 );\n        }\n        if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n            return dfs( UP, x, y-2 );\n        }\n        if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n            return dfs( RIGHT, x, y-1 );\n        }\n    }\n}\n\nint main() {\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1){\n        if(Longitudinal[y][x-1]=='1'){\n            cout<<\"L\";\n            serch(x-1,y,2);\n        }\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1){\n        if(side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nvoid serch(int x,int y,int then)\n{\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    if(then==0){\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n    }\n    else if(then==1){\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n    }\n    else if(then==2){\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n    }\n    else{\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <string> VS;\nconst int size = 9;\n\nint main() {\n    VS lines( size );\n    for ( int i = 0; i < size; ++ i ) {\n        cin >> lines[i];\n    }\n\n    bool O[size + 5][size + 5];\n    for ( int i = 0; i < size + 5; ++ i ) {\n        for ( int j = 0; j < size + 5; ++ j ) {\n            O[i][j] = false;\n        }\n    }\n    for ( int i = 0; i < size; ++ i ) {\n        for ( int j = 0; j < ( i % 2 == 0 ? 4 : 5 ); ++ j ) {\n            O[i+2][j+2] = ( lines[i][j] == '1' );\n        }\n    }\n\n    const string T  = \"RDLU\";\n    const int R = 0;\n    const int D = 1;\n    const int L = 2;\n    const int U = 3;\n    int r = 2;\n    int c = 2;\n    int s = R;\n\n    while ( true ) {\n        putchar( T[s] );\n        if ( r == 2 && c == 2 && s == L ) break;\n        if ( r == 3 && c == 2 && s == U ) break;\n\n        if ( s == L ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            }\n        } else if ( s == R ) {\n            if ( O[r - 1][c + 1] ) {\n                -- r;\n                ++ c;\n                s = U;\n            } else if ( O[r][c + 1] ) {\n                ++ c;\n                s = R;\n            } else if ( O[r + 1][c + 1] ) {\n                ++ r;\n                ++ c;\n                s = D;\n            } else if ( O[r][c - 1] ) {\n                -- c;\n                s = L;\n            }\n        } else if ( s == U ) {\n            if ( O[r - 1][c - 1] ) {\n                -- r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            } else if ( O[r - 1][c] ) {\n                -- r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            }\n        } else if ( s == D ) {\n            if ( O[r + 1][c] ) {\n                ++ r;\n                s = R;\n            } else if ( O[r + 2][c] ) {\n                r += 2;\n                s = D;\n            } else if ( O[r + 1][c - 1] ) {\n                ++ r;\n                -- c;\n                s = L;\n            } else if ( O[r - 2][c] ) {\n                r -= 2;\n                s = U;\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nvoid input(bool grid[][9])\n{\n\trep(i,9){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(i%2==0)\n\t\t\trep(j,4)\n\t\t\t\tgrid[i][j*2+1]=s[j]-'0';\n\t\telse\n\t\t\trep(j,5)\n\t\t\t\tgrid[i][j*2]=s[j]-'0';\n\t}\n}\n\nenum dir{\n\tUP,RIGHT,DOWN,LEFT\n};\nconst int di[]={-1,0,1,0};\nconst int dj[]={0,1,0,-1};\nconst char output[]=\"URDL\";\n\nbool in_range(int i,int j)\n{\n\treturn 0<=i && i<9 && 0<=j && j<9;\n}\n\nint main()\n{\n\tbool grid[9][9]={{0}};\n\tinput(grid);\n\t\n\tint i=0,j=0;\n\tdir prev=RIGHT;\n\tfor(;;){\n\t\tdir next[4]={LEFT,UP,RIGHT,DOWN};\n\t\trotate(next,next+prev,next+4);\n\t\t\n\t\tint k;\n\t\tfor(k=0;k<3;k++){\n\t\t\tif(in_range(i+di[next[k]],j+dj[next[k]]) && grid[i+di[next[k]]][j+dj[next[k]]])\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcout<<output[next[k]];\n\t\t\n\t\ti+=di[next[k]]*2;\n\t\tj+=dj[next[k]]*2;\n\t\tprev=next[k];\n\t\t\n\t\tif(i==0 && j==0)\n\t\t\tbreak;\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <algorithm>\n\nusing namespace std;\n\nchar x[11][11];\n\nvoid search(int i, int j, int direction);\n\nint main () {\n    \n    for(int i=0; i<11; i++){\n        for(int j=0; j<11; j++){\n            x[i][j]='0';\n        }\n    }\n\n\n    while(cin\n          >>x[1][2]>>x[1][4]>>x[1][6]>>x[1][8]\n          >>x[2][1]>>x[2][3]>>x[2][5]>>x[2][7]>>x[2][9]\n          >>x[3][2]>>x[3][4]>>x[3][6]>>x[3][8]\n          >>x[4][1]>>x[4][3]>>x[4][5]>>x[4][7]>>x[4][9]\n          >>x[5][2]>>x[5][4]>>x[5][6]>>x[5][8]\n          >>x[6][1]>>x[6][3]>>x[6][5]>>x[6][7]>>x[6][9]\n          >>x[7][2]>>x[7][4]>>x[7][6]>>x[7][8]\n          >>x[8][1]>>x[8][3]>>x[8][5]>>x[8][7]>>x[8][9]\n          >>x[9][2]>>x[9][4]>>x[9][6]>>x[9][8]\n          )\n        \n        \n    {\n        search(1, 1, 1);\n        \n    }\n    \n    return 0;\n}\n\nvoid search(int i, int j, int direction){\n    while(1){\n    char around[4];\n    around[0]=x[i-1][j];\n    around[1]=x[i][j+1];\n    around[2]=x[i+1][j];\n    around[3]=x[i][j-1];\n    \n    char output[4]={'U','R','D','L'};\n    int next[4]={0,1,2,3};\n    \n        int move[4][2]={0};\n    if(around[0]=='1'){\n        move[0][0]=i-2;move[0][1]=j;\n    }\n    if(around[1]=='1'){\n        move[1][0]=i;move[1][1]=j+2;\n    }\n    if(around[2]=='1'){\n        move[2][0]=i+2;move[2][1]=j;\n    }\n    if(around[3]=='1'){\n        move[3][0]=i;move[3][1]=j-2;\n    }\n    \n    for(int k=0; k<4; k++){\n        int temp = (direction+3+k)%4;\n        if(around[temp]=='1'){\n            direction=next[temp];\n            i=move[temp][0];\n            j=move[temp][1];\n            cout<<output[temp]<<endl;\n            break;\n        }\n    }\n        if(i==1&&j==1){\n            break;\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int X = 1000;\nconst int Y = 10;\nbool g[Y][X][Y][X];\n\nstruct State {\n    int x;\n    int y;\n    int dir;\n};\nint dirx[] = {1, 0, -1, 0};\nint diry[] = {0, 1, 0, -1};\nstring ans = \"\";\n\nvector<int> inputLine() {\n    string s;\n    vector<int> a;\n    cin >> s;\n    for(char c : s) {\n        a.push_back(c - '0');\n    }\n    return a;\n}\n\nstring toString(int dir) {\n    switch(dir) {\n    case 0:\n        return \"R\";\n    case 1:\n        return \"D\";\n    case 2:\n        return \"L\";\n    case 3:\n        return \"U\";\n    }\n}\n\nstruct State at(struct State st) {\n    for(int i=0;i<4;i++) {\n        int ndir = (st.dir + i) % 4;\n        int nx = st.x + dirx[ndir];\n        int ny = st.y + diry[ndir];\n        if(0 <= nx && 0 <= ny && g[st.y][st.x][ny][nx]) {\n            // printf(\"nx: %d, ny: %d, ndir: %d\\n\", nx, ny, ndir);\n            ans += toString(ndir);\n            int nndir = (ndir+3)%4;\n            int nnx = nx + dirx[nndir];\n            int nny = ny + diry[nndir];\n            if(0 <= nnx && 0 <= nny && g[ny][nx][nny][nnx]) {\n                // print(\"dirx: %d, diry: %d\\n\", dirx[ndir\n                // printf(\"nnx: %d, nny: %d, nndir: %d\\n\", nnx, nny, nndir);\n                return (State){nx, ny, nndir};\n            }else {\n                return (State){nx, ny, ndir};\n            }\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> a;\n    for(int i=0;i<9;i++) {\n        a.push_back(inputLine());\n    }\n    for(int i=0;i<Y;i++) {\n        for(int j=0;j<X;j++) {\n            for(int k=0;i<Y;i++) {\n                for(int l=0;j<X;j++) {\n                    g[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n    for(int i=0;i<4;i++) {\n        for(int j=0;j<a[0].size();j++) {\n            if(a[2*i][j] == 1) {\n                g[i][j][i][j+1] = true;\n                g[i][j+1][i][j] = true;\n            }\n        }\n        for(int j=0;j<a[1].size();j++) {\n            if(a[2*i+1][j] == 1) {\n                g[i][j][i+1][j] = true;\n                g[i+1][j][i][j] = true;\n            }\n        }\n    }\n    for(int j=0;j<a[0].size();j++) {\n        if(a[8][j] == 1) {\n            g[4][j][4][j+1] = true;\n            g[4][j+1][4][j] = true;\n        }\n    }\n    auto st = at((State){0, 0, 0});\n    while(st.x != 0 || st.y != 0) {\n        // printf(\"x: %d, y: %d, dir: %d\\n\", st.x, st.y, st.dir);\n        st = at(st);\n        // cout << st.dir << endl;\n    }\n    // printf(\"x: %d, y: %d, dir: %d\\n\", st.x, st.y, st.dir);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nchar perm_angle[4] = {'R','U','L','D'};\nint grid[5][5][4] = {0};\n\nvoid move(int,int,char);\nchar det_angle(int,int,char);\n\nint main(){\n\tint flag;\n\tfor(int i=0;i<9;i++){\n\t\tif(i%2 == 0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag);\n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"+\";\n\t\t\t\t\tgrid[i/2][j][0]  = 1; //R\n\t\t\t\t\tgrid[i/2][j+1][2]= 1; //L\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag); \n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"-\";\n\t\t\t\t\tgrid[i/2][j][3]  = 1; //D\n\t\t\t\t\tgrid[i/2+1][j][1]= 1; //U\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t//cout << endl;\n\t}\n\t/*for(int i=0;i<5;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcout << 100*i+j;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout <<  \" \"  << grid[i][j][k];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}*/\n//\tif(fscanf(stdin,\"%1d\",&map[i][j]) != EOF){\n\n\t//int x = 0, y = 0;\n\t//char angle = 'R';\n\t/*do{\n\t\tmove(x,y,det_angle(x,y,angle))\n\t}while(x == 0 && y == 0);*/\n\tcout << 'R';\n\tmove(0,1,'R');\n}\n\nvoid move(int x,int y,char angle){\n\tif(x == 0 && y== 0)\n\t\texit(1);\n\t\n\tcout << angle;\n\t\n\tif(angle == 'R'){\n\t\t++y;\n\t}\n\telse if(angle == 'U'){\n\t\t--x;\n\t}\n\telse if(angle == 'L'){\n\t\t--y;\n\t}\n\telse if(angle == 'D'){\n\t\t++x;\n\t}\n\t//cout << \"test\" << x <<\" \" << y;\n\tmove(x,y,det_angle(x,y,angle));\n\t//cout << angle << endl; \n}\n\nchar det_angle(int x,int y,char angle){\n\t\n\t//cout << x << y << \" \" << angle << endl;\n\tint start;\n\tif(angle == 'R'){\n\t\tstart = 5;\n\t}\n\telse if(angle == 'U'){\n\t\tstart = 6;\n\t}\n\telse if(angle == 'L'){\n\t\tstart = 7;\t\n\t}\n\telse if(angle == 'D'){\n\t\tstart = 4;\n\t}\n\t//cout << start << endl;\n\tfor(int i = start;start - i < 4 ;--i){\n\t\tif(grid[x][y][i%4] == 1){\n\t\t\t//cout << \"kettei\" << i <<endl ;\n\t\t\treturn perm_angle[i%4];\n\t\t}\n\t}\n\treturn 'Z';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {-1, 0, 1, 0};\nchar dir[4] = {'U', 'R', 'D', 'L'};\n\nint main()\n{\n  int l, x, y, d;\n  string str;\n  bool a[11][11][11][11]; // current pos[h][w], next pos[h][w]\n\n  while(cin>>str){\n    l = str.size()+1;\n    y = 1;\n    fill(&a[0][0][0][0], &a[l+1][0][0][0], false);\n\n    for(int i = 1; i < l; ++i)\n      if(str[i-1] == '1')\n\ta[0][i-1][0][i] = a[0][i][0][i-1] = true;\n\n    for(int i = 1; i <= 8; ++i){\n      cin >> str;\n      if(i%2){\n\tfor(int j = 0; j < l; ++j)\n\t  if(str[j] == '1') \n\t    a[y-1][j][y][j] = a[y][j][y-1][j] = true;\n      } else {\n\tfor(int j = 1; j < l; ++j)\n\t  if(str[j-1] == '1')\n\t    a[y][j-1][y][j] = a[y][j][y][j-1] = true;\n\ty++;\n      }\n    }\n\n    x = y = d = 0;\n    do {\n      for(int i = 3; i < 7; ++i){\n\tint dx = x+xdir[(d+i)%4], dy = y+ydir[(d+i)%4];\n\t\n\tif(0 <= dx && dx < l && 0 <= dy && dy < l && a[y][x][dy][dx]){\n\t  cout << dir[(d+i)%4];\n\t  // cout<<\": (\"<<x<<\", \"<<y<<\") -> (\"<<dx<<\", \"<<dy<<\")\"<<endl;  \n\t  a[y][x][dy][dx] = false;\n\t  x = dx;\n\t  y = dy;\n\t  d = (d+i)%4;\n\t  break;\n\t}\n      }\n    } while(x+y != 0);\n    \n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nbool is_path[10][10][10][10];\nconst char ch_dir[] = {'U','R','D','L'};\n\nvoid dfs(int sx,int sy,int dir){\n  for(int i=0;i<4;i++){\n    int next_dir = (dir + i + 3) % 4;\n    int dx = tx[next_dir] + sx;\n    int dy = ty[next_dir] + sy;\n    if(dx < 0 || dx > 4 || dy < 0 || dy > 4) continue;\n    if(!is_path[sx][sy][dx][dy]) continue;\n\n    printf(\"%c\",ch_dir[next_dir]);\n    if(dx == 0 && dy == 0) return;\n\n    dfs(dx,dy,next_dir);\n    break;\n  }\n}\n\nint main(){\n\n  memset(is_path,false,sizeof(is_path));\n  for(int i=0;i<9;i++){\n    char buf[8];\n    scanf(\"%s\",buf);\n    int y = i / 2;\n    \n    if(i % 2 == 0){\n      for(int x=0;x<4;x++){\n\tif(buf[x] == '1'){\n\t  is_path[x][y][x+1][y] = true;\n\t  is_path[x+1][y][x][y] = true;\n\t}\n      }\n    }\n    else if(i % 2 != 0){\n      for(int x=0;x<5;x++){\n\tif(buf[x] == '1'){\n\t  is_path[x][y][x][y+1] = true;\n\t  is_path[x][y+1][x][y] = true;\n\t}\n      }\n    }\n  }\n\n  dfs(0,0,1);\n  printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char d[4] = {'L','U','R','D'};\n \nint main(){\n  char ch;\n  bool G[6][6][4];\n  memset(G,false,sizeof(G));\n  for(int i = 0 ; i < 9 ; i++){\n    int d = i%2;\n    for(int j = 0 ; j < 4+d ; j++){\n      cin >> ch;\n      if(ch == '1'){\n        if(d%2){\n          G[i/2+1][j][2] = G[i/2+1][j+1][0] = true;\n        }else{\n          G[i/2][j+1][3] = G[i/2+1][j+1][1] = true;\n        }\n      }\n    }\n  }\n  bool flg = true;\n  int x = 1,y = 0,dir = 2;\n  string ans;\n  while(true){\n    if(!x && !y) break;\n    if(flg){\n      ans += d[dir];\n    }\n    flg = true;\n    int rh = (dir+1)%4;\n    if(G[y][x][rh]){\n      if(G[y][x][dir]){\n        dir--;\n        dir = (dir == -1 ? 3 : dir);\n      }else if(!G[y+dy[dir]][x+dx[dir]][rh]){\n        x += dx[dir], y += dy[dir];\n        x += dx[rh], y += dy[rh];\n        dir = rh;\n      }else{\n        x += dx[dir]; y += dy[dir];\n      }\n    }else{\n      x += dx[rh], y += dy[rh];\n      flg = false;\n      dir = rh;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rep(i,n) for(int i = 0 ; i < n ; i++ )\nusing namespace std;\nvoid input(bool grid[][9]){\n  rep(i,9){\n    string s;\n    cin >> s;\n    if(i%2 == 0){\n      rep(j,4)grid[i][j*2+1] = s[j] - '0';\n    } else {\n      rep(j,5)grid[i][j*2] = s[j] - '0';\n    }\n  }\n}\n\nenum dir{\n  UP,RIGHT,DOWN,LEFT\n};\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst char output[] = \"URDL\";\n\nbool in_range(int a,int b){\n  return 0 <= a && a < 9 && 0 <= b && b < 9;\n}\nint main(){\n  bool grid[9][9] = {{0}};\n  input(grid);\n\n  int i = 0,j = 0;\n  dir prev = RIGHT;\n  for(;;){\n    dir next[] = {LEFT,UP,RIGHT,DOWN};\n    rotate(next,next + prev,next + 4);\n\n    int k;\n    for(k = 0 ; k < 3 ; k++ ){\n      if(in_range(i+di[next[k]],j+dj[next[k]]) &&\n\t grid[i+di[next[k]]][j+dj[next[k]]]){\n\tbreak;\n      }\n    }\n    cout << output[next[k]];\n    i+=di[next[k]]*2;\n    j+=dj[next[k]]*2;\n    prev = next[k];\n    if(i == 0 && j == 0)break;\n  } \n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<endl;\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\t//cout<<endl;\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(/*x+1<5 && *//*y+1<5 &&*/ tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(/*x+1<5 &&*/ tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(/*x+1<5 &&*/ tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n\tif(row % 2 == 0){\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint checkTable[9][5],returnCheckTable[9][5],row,col;\n\tchar array[9][6];\n\n\tfor(int i = 0; i < 9; i++){\n\t\tfor(int k=0; k < 5; k++){\n\t\t\tcheckTable[i][k] = 0;\n\t\t\treturnCheckTable[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int i=0;i < 9; i++){\n\t\tscanf(\"%s\",array[i]);\n\t}\n\n\tprintf(\"R\");\n\tchar current = 'R';\n\n\tcheckTable[0][0] = 1;\n\n\trow = 0,col = 0;\n\n\tbool FLG = true;\n\n\twhile(FLG){\n\t\tswitch(current){\n\t\tcase 'L':\n\t\t\tif(rangeCheck(row,col-1)&&checkTable[row][col-1] == 0 && array[row][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row][col-1] = 1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(row,col+1)&&checkTable[row][col+1] == 0 && array[row][col+1] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row][col+1] = 2;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row-1,col+1)&&checkTable[row-1][col+1] == 0 && array[row-1][col+1] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-1][col+1] = 3;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row+1,col+1)&&checkTable[row+1][col+1] == 0 && array[row+1][col+1] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col+1] = 4;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t\tcol = col+1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tif(rangeCheck(row-2,col)&&checkTable[row-2][col] == 0 && array[row-2][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcheckTable[row-2][col] = 3;\n\t\t\t\trow = row - 2;\n\t\t\t}else if(rangeCheck(row-1,col-1)&&checkTable[row-1][col-1] == 0 && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row-1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row-1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(row+2,col)&&checkTable[row+2][col] == 0 && array[row+2][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+2][col] = 4;\n\t\t\t\trow = row+2;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row+1][col] = 2;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row+1,col-1)&&checkTable[row+1][col-1] == 0 && array[row+1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row+1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row +1;\n\t\t\t\tcol = col -1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tFLG = true;\n\n\twhile(FLG){\n\t\tswitch(current){\n\t\tcase 'L':\n\t\t\tif(rangeCheck(row,col-1)&&checkTable[row][col-1] != 1 && returnCheckTable[row][col-1] == 0 && array[row][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\treturnCheckTable[row][col-1] = 1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] != 4 && returnCheckTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\treturnCheckTable[row+1][col] = 1;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] != 3 &&returnCheckTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\treturnCheckTable[row-1][col] = 1;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(row,col+1)&&checkTable[row][col+1] != 2 &&returnCheckTable[row][col+1] == 0 && array[row][col+1] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\treturnCheckTable[row][col+1] = 1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row-1,col+1)&&checkTable[row-1][col+1] != 3 && returnCheckTable[row-1][col+1] == 0 && array[row-1][col+1] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\treturnCheckTable[row-1][col+1] = 1;\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row+1,col+1)&&checkTable[row+1][col+1] != 4 && returnCheckTable[row+1][col+1] == 0 && array[row+1][col+1] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\treturnCheckTable[row+1][col+1] = 1;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t\tcol = col+1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tif(rangeCheck(row-2,col)&&checkTable[row-2][col] != 3 && returnCheckTable[row-2][col] == 0 && array[row-2][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\treturnCheckTable[row-2][col] = 1;\n\t\t\t\trow = row - 2;\n\t\t\t}else if(rangeCheck(row-1,col-1)&&checkTable[row-1][col-1] != 1 && returnCheckTable[row-1][col-1] == 0 && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\treturnCheckTable[row-1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row-1,col)&&checkTable[row-1][col] != 2 && returnCheckTable[row-1][col] == 0 && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\treturnCheckTable[row-1][col] = 1;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(row+2,col)&&checkTable[row+2][col] != 4 && returnCheckTable[row+2][col] == 0 && array[row+2][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\treturnCheckTable[row+2][col] = 1;\n\t\t\t\trow = row+2;\n\t\t\t}else if(rangeCheck(row+1,col)&&checkTable[row+1][col] != 2 && returnCheckTable[row+1][col] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\treturnCheckTable[row+1][col] = 1;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row+1,col-1)&&checkTable[row+1][col-1] != 1 && returnCheckTable[row+1][col-1] == 0 && array[row+1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\treturnCheckTable[row+1][col-1] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row +1;\n\t\t\t\tcol = col -1;\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\n\tprintf(\"L\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0 && y==0 && ((v+loop[i])%4)==2 || ((v+loop[i])%4==1)){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unistd.h>\n#define U 0\n#define R 1\n#define D 2\n#define L 3\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nint wall[5][5];\nchar buf[128];\nvoid readH(int y){\n//  read(0,buf,6);buf[4]=0;\n  scanf(\"%s\",buf);\n  for (int i=0; i<4; i++){\n    wall[i][y] |= (buf[i]=='1') << R;\n    wall[i+1][y] |= (buf[i]=='1') << L;\n  }\n}\nvoid readV(int y){\n  scanf(\"%s\",buf);\n  for (int i=0; i<5; i++){\n    wall[i][y] |= (buf[i]=='1') << D;\n    wall[i][y+1] |= (buf[i]=='1') << U;\n  }\n}\nint main(void){\n  int x,y,dir;\n  \n  for (int i=0; i<4; i++){\n    readH(i); readV(i);\n  }\n  readH(4);\n  \n/*  for (int y=0; y<=4; y++){\n    for (int x=0; x<=4; x++){\n      printf(\"%x \", wall[x][y]);\n    }puts(\"\");\n  }\n  */\n//  for(x=y=(dir=R)^R;x+=dx[dir],y+=dy[dir],write(1,&(*buf=\"URDL\"[dir]),1),x+y;){\n  for(x=y=(dir=R)^R;x+=dx[dir],y+=dy[dir],putchar(\"URDL\"[dir]),x+y;){\n    for((dir+=3)&=~4;!(wall[x][y]&(1<<dir)); (dir+=1)&=~4){\n    }\n  }\nputs(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint a[12][12];\nint dx[4]  = {1,0,-1,0};\nint dy[4]  = {0,1,0,-1};\nchar dc[4] = {'R','D','L','U'};\nstring f[4] = {\"¨\" , \"«\" , \"©\", \"ª\"};\n\n//©ªÌüÍS}XÌÇÌóÔð²×é\nvoid cheakWall(int* wall , const int& px ,const int& py ,const int& d ){\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = px + dx[(d+i)%4];\n\t\tint my = py + dy[(d+i)%4];\n\t\twall[i] = a[my][mx];\n\t}\n}\n\n//iÞ\nvoid go(int& px, int& py, const int& d,int* wall, string& s){\n\tpx += dx[d]*2;\n\tpy += dy[d]*2;\n\t//cheakWall( wall , px , py , d );\n\tif( wall[1] ){\n\t\t//iñ¾ü«ðL^\n\t\ts.push_back( dc[d] );\n\t}\n}\n\nint main(){\n\tstring s;\n\n\t//zñÌú»\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tfor(int x=0 ; x<12 ; ++x )\n\t\t\ta[y][x] = 0;\n\n\t//üÍ\n\tfor(int i=0 ; i<9 ; ++i ){\n\t\tcin >> s;\n\t\tint y = i+1;\n\t\tint x = (i+1)%2 + 1;\n\t\tfor(int j=0 ; j<(int)s.size() ; ++j , x+=2 ){\n\t\t\ta[y][x] = s[j] - '0';\n\t\t}\n\t}\n\n\tint px = 2, py = 0, d = 0;\n\tbool flag = false;\n\ts.clear();\n\n\twhile( 1 ){\n\t\t//cout << \"x:\" << px << \" y:\" << py << \" d:\" << f[d] << endl;\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tint wall[4]; \n\t\t//©ªÌüèÌóÔ\n\t\tcheakWall( wall , px , py , d );\n\n\t\tif( !wall[1] ){//EªÇ¶áÈ©Á½ç\n\t\t\t//ü«ðEü«Éñé\n\t\t\td = (d+1)%4;\n\t\t\t//iÞ\n\t\t\tgo( px , py , d , wall , s );\n\t\t\tflag = false;\n\t\t}else{\n\t\t\tif( !wall[0] ){//OªÇ¶áÈ©Á½ç\n\t\t\t\t//iÞ\n\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\tflag = false;\n\t\t\t}else{\n\t\t\t\tif( !wall[3] ){//¶ªÇ¶áÈ©Á½ç\n\t\t\t\t\tif( wall[1] && flag == false ){\n\t\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\t\ts.push_back( dc[d] );\n\t\t\t\t\t}\n\t\t\t\t\t//ü«ð¶ü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iÞ\n\t\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\t\tflag = false;\n\t\t\t\t}else{//OEEE¶ªÇ¾Á½ç\n\t\t\t\t\tflag = true;\n\t\t\t\t\tif( wall[1] ){\n\t\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\t\ts.push_back( dc[d] );\n\t\t\t\t\t}\n\t\t\t\t\t//ü«ðEü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\ts.push_back( dc[d] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tstd::cout << 'R';\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tif (wall[crd[1] - 1][crd[0]] == 0)\n\t\t\t\t{\n\t\t\t\t\tdir = R;\n\t\t\t\t\tstd::cout << 'R';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcrd[1]--;\n\t\t\t\t\tdir = U;\n\t\t\t\t\tstd::cout << 'U';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tif (wall[crd[1] + 1][crd[0] + 1] == 0)\n\t\t\t\t{\n\t\t\t\t\tdir = L;\n\t\t\t\t\tstd::cout << 'L';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcrd[0]++;\n\t\t\t\t\tcrd[1]++;\n\t\t\t\t\tdir = D;\n\t\t\t\t\tstd::cout << 'D';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tif (wall[crd[1] - 1][crd[0]] == 0)\n\t\t\t\t{\n\t\t\t\t\tdir = D;\n\t\t\t\t\tstd::cout << 'D';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcrd[1]--;\n\t\t\t\t\tdir = R;\n\t\t\t\t\tstd::cout << 'R';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tif (wall[crd[1] + 1][crd[0] - 1] == 0)\n\t\t\t\t{\n\t\t\t\t\tdir = U;\n\t\t\t\t\tstd::cout << 'U';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcrd[0]--;\n\t\t\t\t\tcrd[1]++;\n\t\t\t\t\tdir = L;\n\t\t\t\t\tstd::cout << 'L';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && (crd[1] == 0 || crd[1] == 1))\n\t\t{\n\t\t\tstd::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<deque>\nusing namespace std;\n#define MAX_MAP 10\n\ndeque<string> map;\n\nint y=0,x=-1,vec=0;\nstring v=\"RULD\";\nint dvx[4]={1,0,-1,0};\nint dvy[4]={0,-1,0,1};\n\nbool wall_front(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\t//cout<<map[y*2+1]<<\" \"<<(x+2)<<endl;\n\t\tif(map[y*2+1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_straight(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[y*2][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+3][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_rightAngle(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[(y*2+1)+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[(y*2+1)-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[(y*2)-1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[(y*2+1)+1][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n\n\nvoid go_straight(){\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\nvoid go_straight_move(){\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\n\nvoid solve(){\n\tint count=0;\n\twhile(y!=1||x!=-1){\n\t\tif(count>100)break;\n\t\t//cout<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n\t\tif(wall_front()){\n\t\t\t//cout<<\"front\"<<endl;\n\t\t\tvec++;\n\t\t\tvec=vec%4;\n\t\t\tcout<<v[vec];\n\t\t}else if(wall_straight()){\n\t\t\t//cout<<\"straight\"<<endl;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}else if(wall_rightAngle()){\n\t\t\t//cout<<\"right\"<<endl;\n\t\t\tgo_straight_move();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}else{\n\t\t\t//cout<<\"turn\"<<endl;\n\t\t\tgo_straight();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcout<<v[vec];\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight_move();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}\n\t\tcount++;\n\t}\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin.eof()!=true){\n\t\tcin>>s;\n\t\ts=\"00\"+s+\"00\";\n\t\tmap.push_back(s);\n\t}\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\t/*\n\tfor(int i=0;i<map.size();i++){\n\t\tcout<<map[i]<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nstring e = \"RDLU\";\nstring s[9]; bool d[6][6][4];\nint main() {\n\tfor (int i = 0; i < 9; i++) cin >> s[i];\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[i * 2][j] == '1') d[i][j + 1][1] = d[i + 1][j + 1][3] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tif (s[i * 2 + 1][j] == '1') d[i + 1][j][0] = d[i + 1][j + 1][2] = true;\n\t\t}\n\t}\n\tstring ret = \"R\";\n\tint x = 0, y = 1, dr = 0;\n\twhile (true) {\n\t\tif (d[x][y][dr]) dr = (dr + 3) & 3, ret += e[dr];\n\t\telse {\n\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\tif (x == 1 && y == 0) break;\n\t\t\tif (!d[x][y][(dr + 1) & 3]) {\n\t\t\t\tdr = (dr + 1) & 3;\n\t\t\t\tx += dir[dr], y += dir[dr ^ 1]; ret += e[dr];\n\t\t\t}\n\t\t\telse ret += e[dr];\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  vector<string>in(9);\n  cout<<'R';\n  rep(i,9)cin>>in[i];\n  int x=1,y=0;\n  int to=0;\n  //int co=0;\n  while(x||y){\n    //co++;\n    //if(co>50)break;\n    //cout<<x<<\" \"<<y<<\" \"<<to<<endl;\n    if(to==0){\n      if(y!=0&&in[2*y-1][x]=='1'){\n\ty--;to=3;cout<<'U';\n      }else if(x!=4&&in[2*y][x]=='1'){\n\tx++;cout<<'R';\n      }else if(y!=4&&in[2*y+1][x]=='1'){\n\ty++;to=1;cout<<'D';\n      }else if(x!=0&&in[2*y][x-1]=='1'){\n\tto=2;x--;cout<<'L';\n      }\n    }else if(to==1){\n      if(x!=4&&in[2*y][x]=='1'){\n\tx++;to=0;cout<<'R';\n      }else if(y!=4&&in[2*y+1][x]=='1'){\n\ty++;to=1;cout<<'D';\n      }else if(x!=0&&in[2*y][x-1]=='1'){\n\tto=2;x--;cout<<'L';\n      }else if(y!=0&&in[2*y-1][x]=='1'){\n\ty--;to=3;cout<<'U';\n      }\n    }else if(to==2){\n      if(y!=4&&in[2*y+1][x]=='1'){\n\ty++;to=1;cout<<'D';\n      }else if(x!=0&&in[2*y][x-1]=='1'){\n\tto=2;x--;cout<<'L';\n      }else if(y!=0&&in[2*y-1][x]=='1'){\n\ty--;to=3;cout<<'U';\n      }else if(x!=4&&in[2*y][x]=='1'){\n\tx++;to=0;cout<<'R';\n      }\n    }else if(to==3){\n      if(x!=0&&in[2*y][x-1]=='1'){\n\tto=2;x--;cout<<'L';\n      }else if(y!=0&&in[2*y-1][x]=='1'){\n\ty--;to=3;cout<<'U';\n      }else if(x!=4&&in[2*y][x]=='1'){\n\tx++;to=0;cout<<'R';\n      }else if(y!=4&&in[2*y+1][x]=='1'){\n\ty++;to=1;cout<<'D';\n      }\n    }\n  }\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst int dy[] = {0,1, 0,-1};\nconst int dx[] = {1,0,-1, 0};\nconst int DY[4][4] = {{-1,0, 1,0},{1,2, 1,0},{ 1, 0,-1,0},{-1,-2,-1,0}};\nconst int DX[4][4] = {{ 1,2, 1,0},{1,0,-1,0},{-1,-2,-1,0},{-1, 0, 1,0}};\nconst int chdir[] = {3,0,1,2};\nconst string Dir = \"URDLURDL\";\nll grid[10][10];\n// u = 1,r = 2, d = 4, l = 8\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vary(char,v,5,0);\n  rep(i,9){\n    if(i % 2){\n      rep(j,5){\n        cin >> v[j];\n        v[j] -= '0';\n        grid[j*2][i] = v[j];\n      }\n    }\n    else{\n      rep(j,4){\n        cin >> v[j];\n        v[j] -= '0';\n        grid[j*2+1][i] = v[j];\n      }\n    }\n  }\n  ll x = 1,y = 0,c = 0,dir = 0;\n  cout << \"R\";\n  while(1){\n    if(x == 1 && y == 0 && c) break;\n    rep(i,4){\n      ll nx = x + (DX[dir][i]),ny = y + (DY[dir][i]);\n      if(value(nx,ny,10,10) && grid[nx][ny]){\n        x = nx,y = ny;\n        cout << Dir[dir+i];\n        dir += chdir[i];\n        dir %= 4;\n        break;\n      }\n    }\n    ++c;\n    if(c > 100) break;\n  }\n  cout << endl;\n//   rep(i,10){\n//     rep(j,10){\n//       scout(3) << grid[j][i];\n//     }\n//     cout << endl;\n//   }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define LEFT 0\n#define UP   1\n#define RIGHT 2\n#define DOWN 3\n\n#define MIN(X,Y) ((X<Y)?X:Y)\n#define MAX(X,Y) ((X>Y)?X:Y)\n\nbool map[5][5][5][5];\nint direction=RIGHT;\nint pos[2]={0,0};\nchar nul[5000];\n\n\nvoid read(void)\n{\n\tfor(int y=0;y<4;y++)\n\t{\n\t\tfor(int x=0;x<4;x++)\n\t\t\tmap[x][y][x+1][y] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t\tfor(int x=0;x<5;x++)\n\t\t\tmap[x][y][x][y+1] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t}\n\tfor(int x=0;x<4;x++)\n\t\tmap[x][4][x+1][4] = (getchar()-'0' == 1);\n\treturn;\n}\n\nbool isenable(int x, int y)\n{\n\treturn ((0<=x)&&(x<=4))&&((0<=y)&&(y<=4));\n}\n\nbool isconnect(int dir)\n{\n\tint x=pos[0], y=pos[1];\n\tswitch(dir) {\n\t\tcase LEFT:   x--;\n\t\t\t     break;\n\t\tcase UP:     y--;\n\t\t\t     break;\n\t\tcase RIGHT:  x++;\n\t\t\t     break;\n\t\tcase DOWN:   y++;\n\t\t\t     break;\n\t}\n\treturn (isenable(x,y)&&(map[MIN(pos[0],x)][MIN(pos[1],y)][MAX(pos[0],x)][MAX(pos[1],y)]));\n}\nvoid step(int dir)\n{\n\tswitch(dir) {\n\t\tcase LEFT:   pos[0]--; std::cout << \"L\" << std::flush; direction=LEFT;\n\t\t\t     break;\n\t\tcase UP:     pos[1]--; std::cout << \"U\" << std::flush; direction=UP;\n\t\t\t     break;\n\t\tcase RIGHT:  pos[0]++; std::cout << \"R\" << std::flush; direction=RIGHT;\n\t\t\t     break;\n\t\tcase DOWN:   pos[1]++; std::cout << \"D\" << std::flush; direction=DOWN;\n\t\t\t     break;\n\t}\n\treturn;\n}\n\nvoid move(void)\n{\n\tdo {\n\t\tif(isconnect((direction+LEFT-1+4)%4))\n\t\t\tstep((direction+LEFT-1+4)%4);\n\t\telse if(isconnect((direction+UP-1+4)%4))\n\t\t\tstep((direction+UP-1+4)%4);\n\t\telse if(isconnect((direction+RIGHT-1+4)%4))\n\t\t\tstep((direction+RIGHT-1+4)%4);\n\t\telse\n\t\t\tstep((direction+DOWN-1+4)%4);\n\n\t\t//std::cerr << \"(x,y):\" << pos[0] << \",\" << pos[1] << std::endl;\n\t}while(!(pos[0]==0 && pos[1]==0));\n\n\tstd::cout << std::endl;\n\treturn;\n}\n\nint main(void)\n{\n\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tfor(int k=0; j<5; j++)\n\t\t\t\tfor(int l=0; j<5; j++)\n\t\t\t\t\tmap[i][j][k][l] = false;\n\n\tread();\n\tmove();\n}"
  },
  {
    "language": "C++",
    "code": "«ã¤èÍz"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0){\n    cout<<\"L\";\n    return;\n  }\n  if(y==1&&x==0&&way==2){\n    cout<<\"U\";\n    return;\n  }\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n  }\n}\n\nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>///////AOJ0037\n                            int\n                            w[5\n       ][5],i,j;char(b)[    128\n       ],*           p;F    (//\n       int           v){    for\n       (i=    scanf(\"%s\"    ,b)\n       -1,    p=b    ;*p    ;++\n       p){    w[p    -b+    1-v\n       ][j    +v]|=((w[p    -b]\n       [j]                  |=(\n       p[0                  ]==\n       49)<<3-v)&8>>v)>>2;}j+=v\n\n     ;}\n    main\n  (){  for\n (;F     (0)\n,j-       4;F\n(1));for(p=b,\nj=(       *b=\n3)^       3;i        +=-66+\"BAB\\\nC\"[       *b]      ,j+=       \"?\\\n@A\"       \"@\"      [*b        ]-(\n                   1<<        6),*\n                   ++p        =(*\n                   b)[        \"U\"\n                   \"L\"        \"D\"\n                   \"R\"        ],i\n                    +j;)for((++*\n  b)&=~4;!((1<<*\n         b)&\n         w[i\n         ][j\n]);      (*b\n+=3      )&=\n~4)     ;re\\\nturn   !puts\n  (b+1);}\n\n"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#include <bitset>\nusing namespace std;\nconst int INF=1<<30;\n\nint d[11][7];\nint x=2,y=1;\nint k=0;\n\ntypedef pair<int,int> P;\n\n\nvoid R(){\n\tif(d[y-1][x]) {\n\tk=2; \n\ty-=2; \n\tcout<<\"U\";\n\t}\n\telse if(d[y][x]) {\n\tk=0; \n\tx++; \n\tcout<<\"R\";\n\t}\n\telse if(d[y+1][x]){\n\t\tk=3;\n\t\ty+=2;\n\t\tcout<<\"D\";\n\t}\n\telse{\n\t\tk=1;\n\t\tx--;\n\t\tcout<<\"L\";\n\t}\n\n}\nvoid L(){\n\tif(d[y+1][x]) {\n\tk=3; \n\ty+=2; \n\tcout<<\"D\";\n\t}\n\telse if(d[y][x-1]) {\n\tk=1; \n\tx--; \n\tcout<<\"L\";\n\t}\n\telse if(d[y-1][x]){\n\t\tk=2;\n\t\ty-=2;\n\t\tcout<<\"U\";\n\t}\n\telse{\n\t\tk=0;\n\t\tx++;\n\t\tcout<<\"R\";\n\t}\n\n}\nvoid U(){\n\tif(d[y][x-1]) {\n\tk=1; \n\tx--; \n\tcout<<\"L\";\n\t}\n\telse if(d[y-1][x]) {\n\tk=2; \n\ty-=2; \n\tcout<<\"U\";\n\t}\n\telse if(d[y][x]){\n\t\tk=0;\n\t\tx++;\n\t\tcout<<\"R\";\n\t}\n\telse{\n\t\tk=3;\n\t\ty+=2;\n\t\tcout<<\"D\";\n\t}\n\n}\nvoid D(){\n\tif(d[y][x]) {\n\tk=0; \n\tx++; \n\tcout<<\"R\";\n\t}\n\telse if(d[y+1][x]) {\n\tk=3; \n\ty+=2; \n\tcout<<\"D\";\n\t}\n\telse if(d[y][x-1]){\n\t\tk=1;\n\t\tx--;\n\t\tcout<<\"L\";\n\t}\n\telse{\n\t\tk=2;\n\t\ty-=2;\n\t\tcout<<\"U\";\n\t}\n\n}\n\nvoid tansaku(){\n\t\n\twhile(!(x==1&&y==1)){\n\t\tswitch(k){\n\t\tcase 0: R();break;\n\t\tcase 1: L();break;\n\t\tcase 2: U();break;\n\t\tcase 3: D();break;\n\t\tdefault:return;\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\tstring s;\n\tfor(int i=1;i<10;i++){\n\t\tgetline(cin,s);\n\t\tif(s[s.size()-1]=='\\r')\n\t\t\ts.substr(0,s.size()-1);\n\t\tfor(int j=0;j<s.size();j++){\n\t\t\tif(i%2!=0){\n\t\t\t\td[i][j+1]=s[j]-'0';\n\t\t\t}\n\t\t\telse{\n\t\t\t\td[i][j+1]=s[j]-'0';\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<\"R\";\n\ttansaku();\n\tcout<<endl;\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[3000];\nint len;\nint fie[3001][3001];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==2)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n\nint zu[20][20];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};//UP,RIGHT,DOWN,LEFT\nchar pr[]={'U','R','D','L'};\n\nmain(){\n\t\n\tfor(int i=0;i<13;i++){\n\t\tzu[0][i]=1;\n\t\tzu[i][0]=1;\n\t\tzu[12][i]=1;\n\t\tzu[i][12]=1;\n\t}\n\t\n\tfor(int i=0;i<9;i++){\n\t\tif(i&1){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c-'0'){\n\t\t\t\t\tzu[i+2][j*2+2]=1;\n\t\t\t\t\tzu[i+1][j*2+2]=1;\n\t\t\t\t\tzu[i+3][j*2+2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c-'0'){\n\t\t\t\t\tzu[i+2][j*2+3]=1;\n\t\t\t\t\tzu[i+2][j*2+2]=1;\n\t\t\t\t\tzu[i+2][j*2+4]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint x=2,y=2,d=1;\n\twhile(true){\n\t\tint td=(d+3)%4;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(zu[y+dy[td]][x+dx[td]])break;\n\t\t\ttd=(td+1)%4;\n\t\t}\n\t\td=td;\n\t\tcout<<pr[d];\n\t\tx+=2*dx[d];\n\t\ty+=2*dy[d];\n\t\tif(x==2 && y==2)break;\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to) \nint r[7][6];\nint c[6][7];\n\nvoid turn() {\n\tint nr[7][6], nc[6][7];\n\trep(i,6) {\n\t\trep(j,7) {\n\t\t\tnc[i][j] = r[6-j][i];\n\t\t}\n\t}\n\trep(i,7) {\n\t\trep(j,6) {\n\t\t\tnr[i][j] = c[5-j][i];\n\t\t}\n\t}\n\trep(i,7) {\n\t\trep(j,6) {\n\t\t\tr[i][j] = nr[i][j];\n\t\t}\n\t}\n\trep(i,6) {\n\t\trep(j,7) {\n\t\t\tc[i][j] = nc[i][j];\n\t\t}\n\t}\n}\n\nint main() {\n\trep(i,7) {\n\t\trep(j,6) {\n\t\t\tr[i][j] = 0;\n\t\t}\n\t}\n\trep(i,6) {\n\t\trep(j,7) {\n\t\t\tc[i][j] = 0;\n\t\t}\n\t}\n\tstring s;\n\trep2(i,1,5) {\n\t\tcin >> s;\n\t\trep2(j,1,5) {\n\t\t\t\n\t\t\tr[i][j] = s[j-1] - '0';\n\t\t}\n\t\tcin >> s;\n\t\trep2(j,1,6) {\n\t\t\tc[i][j] = s[j-1] - '0';\n\t\t}\n\t}\n\tcin >> s;\n\trep2(i,1,5) {\n\t\tr[5][i] = s[i-1] - '0';\n\t}\n\n\tint x = 0, y = 0;\n\tint gx = 0, gy = 0;\n\tchar d[4] = {'R', 'U', 'L', 'D'};\n\tint dir = 0;\n\twhile(1) {\t\t\n\t\tif(!c[y][x+1] && !c[y+1][x+1] && !r[y+1][x+1]) {\n\t\t\t// turn 180\n\t\t\tdir = (dir+2) % 4;\n\t\t\tcout << d[dir];\n\t\t\trep(i,2) turn();\n\t\t\tx = 4 - x;\n\t\t\ty = 4 - y;\n\t\t\tgx = 4 - gx;\n\t\t\tgy = 4 - gy;\n\t\t\tx++;\n\t\t\tif(x == gx && y == gy) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c[y][x+1] == 1) {\n\t\t\t// turn left\n\t\t\tdir = (dir+1) % 4;\n\t\t\tcout << d[dir];\n\t\t\tturn();\n\t\t\tswap(y = 4 - y, x);\n\t\t\tswap(gy = 4 - gy, gx);\n\t\t\tx++;\n\t\t\tif(x == gx && y == gy) break;\n\n\t\t\tcontinue;\n\t\t} \n\t\tif(r[y+1][x+1] == 1) {\n\t\t\t// go straight\n\t\t\tcout << d[dir];\n\t\t\tx++;\n\t\t\tif(x == gx && y == gy) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif(c[y+1][x+1] == 1) {\n\t\t\t// turn right\n\t\t\tdir = (dir+3) % 4;\n\t\t\tcout << d[dir];\n\t\t\trep(i,3) turn();\n\t\t\tswap(x = 4 - x, y);\n\t\t\tswap(gx = 4 - gx, gy);\n\t\t\tx++;\n\t\t\tif(x == gx && y == gy) break;\n\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  rep(i, 5) {\n    char x;\n    rep(j, 4) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n        G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n      }\n    }\n\n    if(i == 4) break;\n\n    rep(j, 5) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n        G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n      }\n    }\n  }\n\n  string const OP = \"LURD\";\n\n  int y = 0, x = 0, d = 2;\n\n  while(y != 0 || x != 0 || d != 0) {\n    int le = -1, st = -1, ri = -1, dw = -1;\n    for(auto && e: G[y * 5 + x]) {\n      if(e.second == (d + 3) % 4) le = e.second;\n      if(e.second == (d + 1) % 4) ri = e.second;\n      if(e.second == d) st = e.second;\n      if(e.second == (d + 2) % 4) dw = e.second;\n    }\n    if(le != -1) d = le;\n    else if(st != -1) ;\n    else if(ri != -1) d = ri;\n    else d = dw;\n    y += dy[d], x += dx[d];\n    cout << OP[d];\n  }\n  cout << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar f[6][6],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tscanf(\"%s\",f[5]);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=f[5][j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\treturn !puts(\"\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint table[100][100];\nstring s;\n\nint dx[] = { 0, 1, 0, -1, 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0, -1, 0, 1, 0 };\nchar c[] = \"URDLURDL\";\n\nint main(){\n\tREP(i, 9){\n\t\tcin >> s;\n\t\tREP(j, s.size()){\n\t\t\tif (i % 2 == 0)\ttable[i][2 * j + 1] = s[j] - '0';\n\t\t\telse table[i][2 * j] = s[j] - '0';\n\t\t}\n\t}\n\tbool f = 0;\n\tstring ans = \"\";\n\tint x = 0, y = 0, muki = 0;\n\twhile (1){\n\t\tcout << x << \" \" << y << endl;\n\t\tif (f&&x == 0 && y == 0)break;\n\t\tint ny, nx;\n\t\tfor (int i = muki; i < muki + 4; i++){\n\t\t\tnx = x + dx[i], ny = y + dy[i];\n\t\t\tif (nx >= 0 && nx <= 8 && ny >= 0 && ny <= 8){\n\t\t\t\tif (table[ny][nx] == 1){\n\t\t\t\t\tx += 2 * dx[i];\n\t\t\t\t\ty += 2 * dy[i];\n\t\t\t\t\tans += c[i];\n\t\t\t\t\tif (c[i] == 'U')muki = 3;\n\t\t\t\t\telse if (c[i] == 'R')muki = 0;\n\t\t\t\t\telse if (c[i] == 'D')muki = 1;\n\t\t\t\t\telse muki = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = 1;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar ver[10][10], hol[10][10];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst char dir[] = {'U','R','D','L'};\n\nvoid input() {\n  scanf(\"%s\", hol[1]+1);\n  rep(i,4) {\n    scanf(\"%s\", ver[i+1]+1);\n    scanf(\"%s\", hol[i+2]+1);\n  }\n  rep(i,8) rep(j,8) {\n    if (hol[i][j] == '1') hol[i][j] = 1;\n    else hol[i][j] = 0;\n    if (ver[i][j] == '1') ver[i][j] = 1;\n    else ver[i][j] = 0;\n  }\n  // rep(i,8) {\n  //   putchar(' ');\n  //   rep(j,8) printf(\"%2d\", hol[i][j]); puts(\"\");\n  //   rep(j,8) printf(\"%2d\", ver[i][j]); puts(\"\");\n  // }\n}\n\nbool is_end(int x, int y, int d) {\n  return (x == 0 && y == 1 && d == 0) ||\n      (x == 1 && y == 1 && d == 3);\n}\n\nvoid update(int &x, int &y, int &d) {\n  const int bx = x, by = y, bd = d;\n  switch (d) {\n    case 0: {\n      if (hol[y][x]) d = 3;\n      else if (ver[y-1][x+1]) --y;\n      else if (hol[y][x+1]) { ++x; --y; d = 1; }\n      break;\n    }\n    case 1: {\n      if (ver[y][x+1]) d = 0;\n      else if (hol[y+1][x+1]) ++x;\n      else if (ver[y+1][x+1]) { ++x; ++y; d = 2; }\n      break;\n    }\n    case 2: {\n      if (hol[y+1][x]) d = 1;\n      else if (ver[y+1][x]) ++y;\n      else if (hol[y+1][x-1]) { --x; ++y; d = 3; }\n      break;\n    }\n    case 3: {\n      if (ver[y][x]) d = 2;\n      else if (hol[y][x-1]) --x;\n      else if (ver[y-1][x]) { --x; --y; d = 0; }\n      break;\n    }\n  }\n  if (bx == x && by == y && bd == d) {\n    printf(\"%d %d %d\\n\", x, y, d);\n    // assert(false);\n  }\n}\n\nvoid solve() {\n  int x = 1, y = 0, d = 1;\n  string ans = \"R\";\n  do {\n    // printf(\"%d,%d - %d : %s\\n\", x, y, d, ans.c_str());\n    update(x, y, d);\n    ans += dir[d];\n  } while (!is_end(x,y,d));\n  printf(\"%s\\n\", ans.c_str());\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<vector<vector<bool> > > wall(6, vector<vector<bool> >(6, vector<bool>(4, false)));\n\n    for(int i=0; i<5; ++i){\n        for(int j=0; j<4; ++j){\n            char a;\n            cin >> a;\n            if(a == '1')\n                wall[i][j+1][1] = wall[i+1][j+1][3] = true;\n        }\n        if(i < 4){\n            for(int j=0; j<5; ++j){\n                char a;\n                cin >> a;\n                if(a == '1')\n                    wall[i+1][j][0] = wall[i+1][j+1][2] = true;\n            }\n        }\n    }\n\n    char dir[] = {'R', 'D', 'L', 'U'};\n    int dy[] = {0, 1, 0, -1};\n    int dx[] = {1, 0, -1, 0};\n\n    int y = 0;\n    int x = 1;\n    int d = 0;\n    do{\n        if(!wall[y][x][(d+1)%4]){\n            ++ d;\n            d %= 4;\n        }\n        if(!wall[y][x][d]){\n            y += dy[d];\n            x += dx[d];\n            cout << dir[d];\n        }else{\n            d += 3;\n            d %= 4;\n        }\n    }while(y != 1 || x != 0);\n\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n\n  string in;\n\n  vector< string > wall_s, wall_v;\n  wall_s.push_back( \"0000000000\" );\n  for ( long long int i = 0; cin >> in; i++ ) {\n    if ( ( i % 2 ) == 0 ) {\n      wall_v.push_back( \"0\" + in + \"0\" );\n    }else {\n      wall_s.push_back( in );\n    }\n    if ( i == 8 ) break;\n  }\n  wall_s.push_back( \"0000000000\" );\n  long long int mx = 0;\n  long long int my = 0;\n  long long int d = 0;\n  while( true ) {\n    if ( d == 0 ) {\n      if ( wall_v[my][mx+1] == '1' ) {\n\tcout << \"R\";\n\tmx++;\n\tif ( wall_s[my][mx] == '1' ) {\n\t  d = 3;\n\t}\n      }else {\n\td = 1;\n      }\n    }else if ( d == 1 ) {\n      if ( wall_s[my+1][mx] == '1' ) {\n\tcout << \"D\";\n\tmy++;\n\tif ( wall_v[my][mx+1] == '1' ) {\n\t  d = 0;\n\t}\n      }else {\n\td = 2;\n      }\n    }else if ( d == 2 ) {\n      if ( wall_v[my][mx] == '1' ) {\n\tcout << \"L\";\n\tmx--;\n\tif ( wall_s[my+1][mx] == '1' ) {\n\t  d = 1;\n\t}\n      }else {\n\td = 3;\n      }\n    }else {\n      if ( wall_s[my][mx] == '1' ) {\n\tcout << \"U\";\n\tmy--;\n\tif ( wall_v[my][mx] == '1' ) {\n\t  d = 2;\n\t}\n      }else {\n\td = 0;\n      }\n    }\n    if ( mx == 0 && my == 0 && d == 0 ) break;\n\n  }\n  cout << endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define N 10\nusing namespace std;\n\nint main(){\n\tstring str, ans = \"\";\n\tbool h[N][N]; // setinel\n\tbool v[N][N];\n\tchar dir = 'R';\n\tint mx = 1;\n\tint my = 1;\n\tint i, j, len;\n\t\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = 0; j < N; j++) {\n\t\t\th[i][j] = v[i][j] = false;\n\t\t}\n\t}\n\n\ti = j = 1;\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\n\tdo{\n\t\tif (dir == 'L') {\n\t\t\tif(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}else if(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}else if(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}else{\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}\n\t\t}else if (dir == 'R') {\n\t\t\tif(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}else if(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}else if(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}else{\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}\n\t\t}else if (dir == 'U') {\n\t\t\tif(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}else if(v[my-1][mx]){\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}else if(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}else{\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}\n\t\t}else if (dir == 'D') {\n\t\t\tif(h[my][mx]){\n\t\t\t\tmx++;\n\t\t\t\tdir = 'R';\n\t\t\t}else if(v[my][mx]){\n\t\t\t\tmy++;\n\t\t\t\tdir = 'D';\n\t\t\t}else if(h[my][mx-1]){\n\t\t\t\tmx--;\n\t\t\t\tdir = 'L';\n\t\t\t}else{\n\t\t\t\tmy--;\n\t\t\t\tdir = 'U';\n\t\t\t}\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst char mark[4] = {'R', 'D', 'L', 'U'};\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nint main(void) {\n    bool w[5][9];\n    for (int i = 0; i < 9; i++) {\n        int x = 4 + i % 2;\n        for (int j = 0; j < x; j++) {\n            char c;\n            cin >> c;\n            w[j][i] = (c == '1');\n        }\n    }\n    int x = 0, y = 0, d = 0;\n    do {\n        int dx, dy, _x, _y;\n        d--;\n        if (d < 0) d += 4;\n        for (int i = 0; i < 4; i++) {\n            dx = dir[d][0];\n            dy = dir[d][1];\n            _x = x + dx;\n            _y = y + dy;\n            if (_x >= 0 && _x <= 4 && _y >= 0 && _y <= 4) {\n                if (d % 2 == 0 && w[min(x, _x)][y * 2]) break;\n                if (d % 2 == 1 && w[x][min(y, _y) * 2 + 1]) break;\n            }\n            d++;\n            d %= 4;\n        }\n        x = _x;\n        y = _y;\n        cout << mark[d];\n    } while (!(x == 0 && y == 0));\n\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dc[]={'R','D','L','U'};\nbool t[5][5][4];\nint flg=0;\nvoid init();\nbool ck(int y,int x,int d){\n\tif(t[y][x][d]==1)return true;\n\tint ny=y+dy[d];\n\tint nx=x+dx[d];\n\tif(t[ny][nx][(d+2)%4]==1)return true;\n\treturn false; \n}\nvoid rec(int y,int x,int d);\nint main(){\n\tinit();\n\tcout<<\"test\"<<endl;\n\tfor(int i=0;i<=3;i++){\n\t\tfor(int j=0;j<=3;j++){\n\t\t\tcin>>t[i][j][0];\n\t\t}\n\t\tfor(int j=0;j<=4;j++){\n\t\t\tcin>>t[i][j][1];\n\t\t}\n\t}\n\tfor(int i=0;i<=3;i++)cin>>t[4][i][0];\n\tcout<<\"inputend\"<<endl;\n\trec(0,0,0);\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<5;i++)\n\t\tfor(int j=0;j<5;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tt[i][j][k]=0;\n}\nvoid rec(int y,int x,int d){\n\t//cout<<y << \" \" <<x<<\" \"<<d<<endl;\n\tflg++;\n\tif(y==0&&x==0&&flg>1){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t\n\tint d1=(d+1)%4;\n\tint d2=(d+2)%4;\n\tint d3=(d+3)%4;\n\tif(ck(y,x,d3)){\n\t\tcout<<dc[d3];\n\t\trec(y+dy[d3],x+dx[d3],d3);\n\t}else if(ck(y,x,d)){\n\t\tcout<<dc[d];\n\t\trec(y+dy[d],x+dx[d],d);\n\t}else if(ck(y,x,d1)){\n\t\tcout<<dc[d1];\n\t\trec(y+dy[d1],x+dx[d1],d1);\n\t}else{\n\t\tcout<<dc[d2];\n\t\trec(y+dy[d2],x+dx[d2],d2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-10;\n\nint main() {\n\tstring s[16], ans(\"R\");\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tint x = 0, y = 0;\n\tint d = 0; // 0:right, 1:down, 2:left, 3:up\n\tbool flag = false;\n\twhile(1){\n\t\tif(d == 0){\n\t\t\tif(s[y][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x + 1] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\tx += 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'L';\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 1){\n\t\t\tif(s[y + 2][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 2;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\ty += 1;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y + 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 2){\n\t\t\tif(s[y][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\telse if(d == 3){\n\t\t\tif(y >= 3 && s[y - 2][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 2;\n\t\t\t}\n\t\t\telse if(s[y - 1][x] == '1'){\n\t\t\t\ty -= 1;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y - 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\ty -= 1;\n\t\t\t\tx -= 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\t/*if(x == 1 && y == 8 && flag)\n\t\t\tbreak;\n\t\tif(x == 1 && y == 8){\n\t\t\tflag = true;\n\t\t\t//break;\n\t\t}*/\n\t\tif(x == 0 && y == 0)\n\t\t\tbreak;\n\t}\n\t/*cout << s[8][3] << endl;\n\tcout << d << endl;*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//0037\n//include-------------------------------------\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<stack>\n\nusing namespace std;\n\n//typedef--------------------------------------\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\n#define MP make_pair\n\n//repetition-----------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\n//constant-------------------------------------\nconst double PI = acos(-1.0);\n\n//cout,cin-------------------------------------\n#define COUT(x) cout<<(x)<<endl\n#define CIN(x) cin>>(x)\n\nint main(){\n\tint wall[5][5][4] = { { 0 }, { 0 }, { 0 } };\n\tint now[5][5];\n\tstring dir = \"RDLU\";\n\tstring ans = \"R\";\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { 1, 0, -1, 0 };\n\n\tREP(i, 9){\n\t\tstring st;\n\t\tCIN(st);\n\t\tif (i % 2) REP(j, 5){\n\t\t\twall[(i - 1) / 2][j][1] = st[j]-'0';\n\t\t\twall[(i - 1) / 2 + 1][j][3] = st[j] - '0';\n\t\t}\n\t\telse REP(j, 4){\n\t\t\twall[i / 2][j][0] = st[j] - '0';\n\t\t\twall[i / 2][j + 1][2] = st[j] - '0';\n\t\t}\n\t}\n\n\tint x = 0;\n\tint y = 1;\n\tnow[x][y] = 0;\n\t\n\n\twhile (!(x == 0 && y == 0)){\n\t\tint p=now[x][y];\n\t\tif (wall[x][y][(now[x][y] + 3) % 4] == 1){\n\t\t\tx += dx[(now[x][y] + 3) % 4];\n\t\t\ty += dy[(now[x][y] + 3) % 4];\n\t\t\tnow[x][y] = (p + 3) % 4;\n\t\t\tans += dir[(now[x][y] + 3) % 4];\n\t\t}\n\t\telse if (wall[x][y][now[x][y]] == 1){\n\t\t\tx += dx[now[x][y]];\n\t\t\ty += dy[now[x][y]];\n\t\t\tnow[x][y] = p;\n\t\t\tans += dir[now[x][y]];\n\t\t}\n\t\telse{\n\t\t\tx += dx[(now[x][y] + 1) % 4];\n\t\t\ty += dy[(now[x][y] + 1) % 4];\n\t\t\tnow[x][y] = (p + 1) % 4;\n\t\t\tans += dir[(now[x][y] + 1) % 4];\n\t\t}\n\t}\n\n\tCOUT(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(void){\n  int state; //ツ前ツ嘉アツづ個督ョツつ「ツつスツ陛サツ古シ\n  int x, y; //current position\n  bool horizon[5][4];\n  bool vertical[4][5];\n  char tmp;\n  int i,j;\n\n  for(i=0;i<9;i++){\n\tif(i%2 == 0){\n\t  for(j=0;j<4;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  horizon[i/2][j] = true;\n\t\t}else{\n\t\t  horizon[i/2][j] = false;\n\t\t}\n\t  }\n\t}else{\n\t  for(j=0;j<5;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  vertical[i/2][j] = true;\n\t\t}else{\n\t\t  vertical[i/2][j] = false;\n\t\t}\n\t  }\n\t}\n  }\n\n  state = 'R';\n  cout << \"R\";\n  x = 0;\n  y = 1;\n  \n  while(!(x == 0 && y == 0)){\n\tif(state == 'R'){\n\t  if(x - 1 >= 0 && vertical[x-1][y] ){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else{\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }\n\t}else if(state == 'D'){\n\t  if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else if( y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else{\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }\n\t}else if(state == 'L'){\n\t  if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else if(x >= 1 && vertical[x-1][y]){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else{\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }\n\t}else{\n\t  if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else if(x >= 1 && vertical[x-1][y]){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else{\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }\n\t}\n\t//cout << x << \" \" << y << endl;\n\t//cin >> i;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 1;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 0){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&1){t = 3;}\n\telse{y--;}\n      }\n      else{x++;t = 1;}\n    }\n    else if(t == 1){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&2){t = 0;}\n\telse{x++;}\n      }\n      else{y++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&4){t = 1;}\n\telse{y++;}\n      }\n      else{x--;t = 3;}\n    }\n    else if(t == 3){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&8){t = 2;}\n\telse{x--;}\n      }\n      else{y--;t = 0;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 20;\n\nvoid printMaze(int w, int h, bool M[N][N], int x, int y){\n\trep(i,h + h + 1){\n\t\trep(j,w + w + 1){\n\t\t\tif(i == y and j == x) cout << \"*\";\n\t\t\telse cout << M[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid extensionOfMaze(int w, int h, bool M[N][N]){\n\tstring s[N];\n\trep(i,N) cin >> s[i];\n\n\trep(i,N) rep(j,N) M[i][j] = 0;\n\trep(i,h + h - 1){\n\t\tauto it = s[i].begin();\n\t\tif(i % 2 == 0){ //横線\n\t\t\tfor(int j = 0; j < w + w - 1; j++){\n\t\t\t\tif(j % 2 == 0) M[i + 1][j + 1] = 1;\n\t\t\t\telse{\n\t\t\t\t\tM[i + 1][j + 1] = *it == '1' ? true : false;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{ //縦線\n\t\t\tfor(int j = 0; j < w + w; j++){\n\t\t\t\tif(j % 2 == 1) M[i + 1][j + 1] = 0;\n\t\t\t\telse{\n\t\t\t\t\tM[i + 1][j + 1] = *it == '1' ? true : false;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int dy[16] = { 0, 1, 0,-1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\nconst char dir[4] = {'R', 'D', 'L', 'U'};\n\n// 右手法\n// right[d] := d方向（東から時計回り）を向いているときの優先順序\nconst int rightHand[4][4] = {\n\t{1,0,3,2},\n\t{2,1,0,3},\n\t{3,2,1,0},\n\t{0,3,2,1}\n};\n\nvector<pair<int,char>> getCommand(bool m[N][N]){\n\tint y = 0, x = 0;\n\tm[y + 1][x] = 1;\n\n\tint d = 0;\n\tvector<pair<int,char>> res;\n\twhile(true){\n\t\tif(y == 2 and x == 0) break;\n\n\t\trep(i,4){\n\t\t\tint rh = rightHand[d][i];\n\n\t\t\tint ny = y + dy[rh];\n\t\t\tint nx = x + dx[rh];\n\t\t\tif(m[ny][nx] == 0){\n\t\t\t\td = rh;\n\t\t\t\ty = y + dy[rh] * 2;\n\t\t\t\tx = x + dx[rh] * 2;\n\n\t\t\t\tint nrh = rightHand[d][0];\n\t\t\t\tint ny = y + dy[nrh];\n\t\t\t\tint nx = x + dx[nrh];\n\t\t\t\tif(m[ny][nx] == 0){\n\t\t\t\t\ty = y + dy[nrh] * 0;\n\t\t\t\t\tx = x + dx[nrh] * 0;\n\t\t\t\t}\n\t\t\t\tif(res.empty() or res.back().second != dir[d]) res.emplace_back(make_pair(1, dir[d]));\n\t\t\t\telse res.back().first++;\n\t\t\t\tbreak;\n\t\t\t}else{ \n\t\t\t\tif(i == 0) continue;;\n\t\t\t\tif(res.empty() or res.back().second != dir[rh]) res.emplace_back(make_pair(1, dir[rh]));\n\t\t\t\telse res.back().first++;\n\n\t\t\t}\n\t\t\t\t//break;\n\t\t}\n\t\t//printMaze(5,5,m,x,y); cout << endl;\n\n\t}\n\treturn res;\n}\n\nint main(){\n\tbool m[N][N];\n\textensionOfMaze(5, 5, m);\n\t//printMaze(5, 5, m);\n\t\n\tvector<pair<int,char>> tmp = getCommand(m);\n\tint f = 1;\n\tfor(auto p : tmp){\n\t\t//cout << p.first << ' ' << p.second << endl;\n\t\tif(p.first == 1) f = 0;\n\t\trep(i,p.first - f){\n\t\t\tcout << p.second;\n\t\t}\n\t}\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tchar WX[7][6],WY[6][7];\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<6;j++){\n\t\t\tWX[i][j] = 0;\n\t\t\tWY[j][i] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<5;i++) cin >> WX[i][1];\n\tfor(int i=1;i<6;i++) cin >> WY[1][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][2];\n\tfor(int i=1;i<6;i++) cin >> WY[2][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][3];\n\tfor(int i=1;i<6;i++) cin >> WY[3][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][4];\n\tfor(int i=1;i<6;i++) cin >> WY[4][i];\n\tfor(int i=1;i<5;i++) cin >> WX[i][5];\n\n\tint NX = 1;\n\tint NY = 1;\n\tchar s = 'R';\n\twhile(1){\n\t\tif(s=='R'){\n\t\t\tif(WY[NY-1][NX]=='1'){ s = 'U'; NY--; cout << s;}\n\t\t\telse if(WX[NX][NY]=='1'){ NX++; cout << s;}\n\t\t\telse if(WY[NY][NX]=='1'){ s = 'D'; NY++; cout << s;}\n\t\t\telse s = 'L';\n\t\t}\n\t\telse if(s=='L'){\n\t\t\tif(WY[NY][NX]=='1'){ s = 'D'; NY++; cout << s;}\n\t\t\telse if(WX[NX-1][NY]=='1'){ NX--; cout << s;}\n\t\t\telse if(WY[NY-1][NX]=='1'){ s = 'U'; NY--; cout << s;}\n\t\t\telse s = 'R';\n\t\t}\n\t\telse if(s=='U'){\n\t\t\tif(WX[NX-1][NY]=='1'){ s = 'L'; NX--; cout << s;}\n\t\t\telse if(WY[NY-1][NX]=='1'){ NY--; cout << s;}\n\t\t\telse if(WX[NX][NY]=='1'){ s = 'R'; NX++; cout << s;}\n\t\t\telse s = 'D';\n\t\t}\n\t\telse if(s=='D'){\n\t\t\tif(WX[NX][NY]=='1'){ s = 'R'; NX++; cout << s;}\n\t\t\telse if(WY[NY][NX]=='1'){ NY++; cout << s;}\n\t\t\telse if(WX[NX-1][NY]=='1'){ s = 'L'; NX--; cout << s;}\n\t\t\telse s = 'U';\n\t\t}\n\t\tif(NX*NY==1) break;\n\t}\ncout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<pair<int, int>>x[10][10]; string S;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 }; char V[5] = \"RDLU\";\nint main() {\n\tint cnt = 0;\n\tfor (int i = 0; i < 9;i++){\n\t\tcin >> S;\n\t\tif (i % 2 == 0) {\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '0')continue;\n\t\t\t\tx[cnt][j].push_back(make_pair(cnt, j + 1));\n\t\t\t\tx[cnt][j + 1].push_back(make_pair(cnt, j));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '0')continue;\n\t\t\t\tx[cnt][j].push_back(make_pair(cnt + 1, j));\n\t\t\t\tx[cnt + 1][j].push_back(make_pair(cnt, j));\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\tint cx = 0, cy = 0, dir = 0;\n\twhile (true) {\n\t\tcx += dx[dir]; cy += dy[dir]; cout << V[dir];\n\t\tif (cx == 0 && cy == 0)break;\n\t\tfor (int i = 3; i <= 6; i++) {\n\t\t\tint F = (i + dir) % 4;\n\t\t\tfor (int j = 0; j < x[cx][cy].size(); j++) {\n\t\t\t\tif (x[cx][cy][j] == make_pair(cx + dx[F], cy + dy[F])) {\n\t\t\t\t\tdir = F; goto E;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tE:;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {-1, 0, 1, 0};\nchar dir[4] = {'U', 'R', 'D', 'L'};\n\nint main()\n{\n  int l, x, y, d;\n  string str;\n  bool a[11][11][11][11];\n\n  while(cin>>str){\n    l = str.size()+1;\n    y = 1;\n    fill(&a[0][0][0][0], &a[l+1][0][0][0], false);\n\n    for(int i = 1; i < l; ++i)\n      if(str[i-1] == '1')\n\ta[0][i-1][0][i] = a[0][i][0][i-1] = true;\n\n    for(int i = 1; i <= 8; ++i){\n      cin >> str;\n      if(i%2){\n\tfor(int j = 0; j < l; ++j)\n\t  if(str[j] == '1') \n\t    a[y-1][j][y][j] = a[y][j][y-1][j] = true;\n      } else {\n\tfor(int j = 1; j < l; ++j)\n\t  if(str[j-1] == '1')\n\t    a[y][j-1][y][j] = a[y][j][y][j-1] = true;\n\ty++;\n      }\n    }\n\n    x = y = d = 0;\n    do {\n      for(int i = 3; i < 7; ++i){\n\tint nd = (d+i)%4;\n\tint dx = x+xdir[nd], dy = y+ydir[nd];\n\t\n\tif(0 <= dx && dx < l && 0 <= dy && dy < l && a[y][x][dy][dx]){\n\t  cout << dir[(d+i)%4];\n\t  a[y][x][dy][dx] = false;\n\t  x = dx;\n\t  y = dy;\n\t  d = nd;\n\t  break;\n\t}\n      }\n    } while(x+y != 0);\n    \n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\n\nvoid dfs( int dir, int x, int y, int a ) {\n    cout << D[dir];\n\n    if ( dir == RIGHT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 0 );\n            }\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 1 );\n            }\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 1 );\n            }\n        }\n    } else if ( dir == DOWN ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 0 );\n            }\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 1 );\n            }\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 1 );\n            }\n        }\n    } else if ( dir == LEFT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 0 );\n            }\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 0 );\n            }\n        } else {\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 1 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 0 );\n            }\n        }\n    } else if ( dir == UP ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 0 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 0 );\n            }\n        } else {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 1 );\n            }\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 0 );\n            }\n        }\n    }\n}\n\nint main() {\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;++i)\nint main()\n{\n\tint f[5][5]={{0}};\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\tint d=p;\n\t\tdo\n\t\t\td=(d+1)%4;\n\t\twhile(!((f[y][x]>>d)&1));\n\t\tp=d;\n\t\tputchar(\"URDL\"[d]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[d];\n\t\ty+=dy[d];\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define LEFT 0\n#define UP   1\n#define RIGHT 2\n#define DOWN 3\n\n#define MIN(X,Y) ((X<Y)?X:Y)\n#define MAX(X,Y) ((X>Y)?X:Y)\n\nbool map[5][5][5][5];\nint direction=RIGHT;\nint pos[2]={0,0};\nchar nul[5000];\n\n\nvoid read(void)\n{\n\tfor(int y=0;y<4;y++)\n\t{\n\t\tfor(int x=0;x<4;x++)\n\t\t\tmap[x][y][x+1][y] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t\tfor(int x=0;x<5;x++)\n\t\t\tmap[x][y][x][y+1] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t}\n\tfor(int x=0;x<4;x++)\n\t\tmap[x][4][x+1][4] = (getchar()-'0' == 1);\n\treturn;\n}\n\nbool isenable(int x, int y)\n{\n\treturn ((0<=x)&&(x<=4))&&((0<=y)&&(y<=4));\n}\n\nbool isconnect(int dir)\n{\n\tint x=pos[0], y=pos[1];\n\tswitch(dir) {\n\t\tcase LEFT:   x--;\n\t\t\t     break;\n\t\tcase UP:     y--;\n\t\t\t     break;\n\t\tcase RIGHT:  x++;\n\t\t\t     break;\n\t\tcase DOWN:   y++;\n\t\t\t     break;\n\t}\n\treturn (isenable(x,y)&&(map[MIN(pos[0],x)][MIN(pos[1],y)][MAX(pos[0],x)][MAX(pos[1],y)]));\n}\nvoid step(int dir)\n{\n\tswitch(dir) {\n\t\tcase LEFT:   pos[0]--; std::cout << \"L\" << std::flush; direction=LEFT;\n\t\t\t     break;\n\t\tcase UP:     pos[1]--; std::cout << \"U\" << std::flush; direction=UP;\n\t\t\t     break;\n\t\tcase RIGHT:  pos[0]++; std::cout << \"R\" << std::flush; direction=RIGHT;\n\t\t\t     break;\n\t\tcase DOWN:   pos[1]++; std::cout << \"D\" << std::flush; direction=DOWN;\n\t\t\t     break;\n\t}\n\treturn;\n}\n\nvoid move(void)\n{\n\tdo {\n\t\tif(isconnect((direction+LEFT-1+4)%4))\n\t\t\tstep((direction+LEFT-1+4)%4);\n\t\telse if(isconnect((direction+UP-1+4)%4))\n\t\t\tstep((direction+UP-1+4)%4);\n\t\telse if(isconnect((direction+RIGHT-1+4)%4))\n\t\t\tstep((direction+RIGHT-1+4)%4);\n\t\t//else\n\t\t\t//std::cerr << \"error\" << std::endl;\n\n\t\t//std::cerr << \"(x,y):\" << pos[0] << \",\" << pos[1] << std::endl;\n\t}while(!(pos[0]==0 && pos[1]==0));\n\n\tstd::cout << std::endl;\n\treturn;\n}\n\nint main(void)\n{\n\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tfor(int k=0; j<5; j++)\n\t\t\t\tfor(int l=0; j<5; j++)\n\t\t\t\t\tmap[i][j][k][l] = false;\n\n\tread();\n\tmove();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define LEFT 0\n#define UP   1\n#define RIGHT 2\n#define DOWN 3\n\n#define MIN(X,Y) ((X<Y)?X:Y)\n#define MAX(X,Y) ((X>Y)?X:Y)\n\nbool map[5][5][5][5];\nint direction=RIGHT;\nint pos[2]={0,0};\nchar nul[5000];\n\n\nvoid read(void)\n{\n\tfor(int y=0;y<4;y++)\n\t{\n\t\tfor(int x=0;x<4;x++)\n\t\t\tmap[x][y][x+1][y] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t\tfor(int x=0;x<5;x++)\n\t\t\tmap[x][y][x][y+1] = (getchar()-'0' == 1);\n\t\tgets(nul);\n\t}\n\tfor(int x=0;x<4;x++)\n\t\tmap[x][4][x+1][4] = (getchar()-'0' == 1);\n\treturn;\n}\n\nbool isenable(int x, int y)\n{\n\treturn ((0<=x)&&(x<=4))&&((0<=y)&&(y<=4));\n}\n\nbool isconnect(int dir)\n{\n\tint x=pos[0], y=pos[1];\n\tswitch(dir) {\n\t\tcase LEFT:   x--;\n\t\t\t     break;\n\t\tcase UP:     y--;\n\t\t\t     break;\n\t\tcase RIGHT:  x++;\n\t\t\t     break;\n\t\tcase DOWN:   y++;\n\t\t\t     break;\n\t}\n\treturn (isenable(x,y)&&(map[MIN(pos[0],x)][MIN(pos[1],y)][MAX(pos[0],x)][MAX(pos[1],y)]));\n}\nvoid step(int dir)\n{\n\tswitch(dir) {\n\t\tcase LEFT:   pos[0]--; std::cout << \"L\" << std::flush; direction=LEFT;\n\t\t\t     break;\n\t\tcase UP:     pos[1]--; std::cout << \"U\" << std::flush; direction=UP;\n\t\t\t     break;\n\t\tcase RIGHT:  pos[0]++; std::cout << \"R\" << std::flush; direction=RIGHT;\n\t\t\t     break;\n\t\tcase DOWN:   pos[1]++; std::cout << \"D\" << std::flush; direction=DOWN;\n\t\t\t     break;\n\t}\n\treturn;\n}\n\nvoid move(void)\n{\n\tdo {\n\t\tif(isconnect((direction+LEFT-1+4)%4))\n\t\t\tstep((direction+LEFT-1+4)%4);\n\t\telse if(isconnect((direction+UP-1+4)%4))\n\t\t\tstep((direction+UP-1+4)%4);\n\t\telse if(isconnect((direction+RIGHT-1+4)%4))\n\t\t\tstep((direction+RIGHT-1+4)%4);\n\t\telse\n\t\t\t//std::cerr << \"error\" << std::endl;\n\n\t\t//std::cerr << \"(x,y):\" << pos[0] << \",\" << pos[1] << std::endl;\n\t}while(!(pos[0]==0 && pos[1]==0));\n\n\tstd::cout << std::endl;\n\treturn;\n}\n\nint main(void)\n{\n\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tfor(int k=0; j<5; j++)\n\t\t\t\tfor(int l=0; j<5; j++)\n\t\t\t\t\tmap[i][j][k][l] = false;\n\n\tread();\n\tmove();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(c<50){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&f) break;\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"R\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(m.y<5){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.x++;\n\t  cout << \"R\";\n\t  continue;\n\t}\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.x++;\n\t  m.y++;\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      m.y++;\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"D\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y<4){\n\tif(st[m.y*2+1][m.x-1]=='1') {\n\t  m.y++;\n\t  cout << \"D\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y<5){\n\tif(st[m.y*2][m.x-2]=='1') {\n\t  m.x--;\n\t  m.y++;\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      m.x--;\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y>0){\n\tif(st[(m.y-1)*2][m.x-2]=='1') {\n\t  m.x--;\n\t  cout << \"L\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y>1){\n\tif(st[(m.y-1)*2-1][m.x-1]=='1') {\n\t  m.x--;\n\t  m.y--;\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      m.y--;\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"U\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(m.y>1){\n\tif(st[(m.y-1)*2-1][m.x]=='1') {\n\t  m.y--;\n\t  cout << \"U\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x]=='1') {\n\t  m.x++;\n\t  m.y--;\n\t  cout << \"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      m.x++;\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout << \"L\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin(); it!=(c).end(); it++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pr(a) cout << (a) << endl\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAX=1000000000;\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\n\nint main() {\n  vector<string> s;\n  string t;\n  while(cin >> t) s.pb(t);\n  int d[s.size()+2][s[1].size()*2+1];\n  memset(d,0,sizeof(d));\n  rep(i,s.size()) {\n    rep(j,s[i].size()) {\n      if(i%2) {\n\td[i+1][j*2+1]=(s[i][j]=='1');\n      } else {\n\td[i+1][j*2+2]=(s[i][j]=='1');\n      }\n    }\n  }\n  string ans=\"\";\n  int x=1,y=1,z=0;\n  char c[4]={'U','R','D','L'};\n  for(int i=0; i<4; i++) {\n    int k=(z+3)%4;\n    int nx=x+dx[(i+k)%4],ny=y+dy[(i+k)%4];\n    if(d[nx][ny]==1) {\n      x+=dx[(i+k)%4]*2;\n      y+=dy[(i+k)%4]*2;\n      ans+=c[(i+k)%4];\n      z=(i+k)%4;\n      break;\n    }\n  }\n  while(x!=1 || y!=1) {\n    for(int i=0; i<4; i++) {\n      int k=(z+3)%4;\n      int nx=x+dx[(i+k)%4],ny=y+dy[(i+k)%4];\n      if(d[nx][ny]==1) {\n\tx+=dx[(i+k)%4]*2;\n\ty+=dy[(i+k)%4]*2;\n\tans+=c[(i+k)%4];\n\tz=(i+k)%4;\n\tbreak;\n      }\n    }\n  }\n  pr(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\tdo\n\t\t\tp=(p+1)%4;\n\t\twhile(!((f[y][x]>>p)&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\treturn puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n \nbool mas[4][4][4];\nstring s = \"LURD\";\nconst int dy[] = { 0, -1, 0, 1}, dx[] = { -1, 0, 1, 0};\n \nvoid dfs( int y, int x, int pos){\n  cout << s[pos];\n  if(!y && !x){\n    cout << endl;\n    return;\n  }\n  for(int i = 0 ; i < 4 ; i++ ){\n    int dd = ( pos + 3 + i ) % 4;\n    int ny = y + dy[ dd], nx = x + dx[ dd];\n    if(mas[y][x][dd]){\n      dfs( y + dy[ dd], x + dx[ dd], dd);\n      return;\n    }\n  }\n}\nint main(){\n  char c;\n  for(int i = 0 ; i < 9 ; i++ ){\n    if(i & 1) for(int j = 0 ; j < 5 ; j++ ){\n      cin >> c;\n      if(c == '1') mas[i / 2][j][3] = mas[i / 2 + 1][j][1] = true;\n    } else for(int j = 0 ; j < 4 ; j++ ){\n      cin >> c;\n      if(c == '1') mas[i / 2][j][2] = mas[i / 2][j + 1][0] = true;\n    }\n  }\n  dfs( 0, 1, 2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(/*y+1<5 && */yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(/*x+1<5 && */tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(/* y+1<5 && */ yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(/*x+1<5 && */tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(/*y+1<5 && */yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(/*x+1<5 && */tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\nusing namespace std;\n\nenum Dir\n{\n\tU,R,D,L,DirSize\n};\n\nint main()\n{\n\tbitset<DirSize+1> node[10][10];\n\tfor(int y=0; y<5; y++)\n\tfor(int x=0; x<5; x++)\n\t{\n\t\tnode[y*2  ][x*2  ].set(R);\n\t\tnode[y*2  ][x*2  ].set(D);\n\t\tnode[y*2  ][x*2+1].set(D);\n\t\tnode[y*2  ][x*2+1].set(L);\n\t\tnode[y*2+1][x*2+1].set(L);\n\t\tnode[y*2+1][x*2+1].set(U);\n\t\tnode[y*2+1][x*2  ].set(U);\n\t\tnode[y*2+1][x*2  ].set(R);\n\t}\n\tnode[0][0].reset(D);\n\tnode[1][0].reset(U);\n\n\tchar str[16];\n\tfor(int y=0; y<5; y++)\n\t{\n\t\tcin>>str;\n\t\tfor(int x=0; x<4; x++)\n\t\t{\n\t\t\tif(str[x]=='1')\n\t\t\t{\n\t\t\t\tnode[y*2  ][x*2+1].set(R);\n\t\t\t\tnode[y*2  ][x*2+1].reset(D);\n\t\t\t\tnode[y*2+1][x*2+1].set(R);\n\t\t\t\tnode[y*2+1][x*2+1].reset(U);\n\t\t\t\tnode[y*2  ][x*2+2].set(L);\n\t\t\t\tnode[y*2  ][x*2+2].reset(D);\n\t\t\t\tnode[y*2+1][x*2+2].set(L);\n\t\t\t\tnode[y*2+1][x*2+2].reset(U);\n\t\t\t}\n\t\t}\n\n\t\tif(y==4) break;\n\n\t\tcin>>str;\n\t\tfor(int x=0; x<5; x++)\n\t\t{\n\t\t\tif(str[x]=='1')\n\t\t\t{\n\t\t\t\tnode[y*2+1][x*2  ].set(D);\n\t\t\t\tnode[y*2+1][x*2  ].reset(R);\n\t\t\t\tnode[y*2+1][x*2+1].set(D);\n\t\t\t\tnode[y*2+1][x*2+1].reset(L);\n\t\t\t\tnode[y*2+2][x*2  ].set(U);\n\t\t\t\tnode[y*2+2][x*2  ].reset(R);\n\t\t\t\tnode[y*2+2][x*2+1].set(U);\n\t\t\t\tnode[y*2+2][x*2+1].reset(R);\n\t\t\t}\n\t\t}\n\t}\n\n\tint y=0,x=0;\n\tconst int  dx[]={ 0, 1, 0,-1};\n\tconst int  dy[]={-1, 0, 1, 0};\n\tconst char dc[]={'U','R','D','L'};\n\n\tbool end=false;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tif(node[y][x][i])\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\n\t\t\t\tif(x/2!=nx/2 || y/2!=ny/2)\n\t\t\t\t{\n\t\t\t\t\tcout << dc[i];\n\t\t\t\t}\n\t\t\t\tx=nx; y=ny;\n\t\t\t\tnode[y][x].reset((i+2)%4);\n\t\t\t\tend=false; break;\n\t\t\t}\n\t\t}\t\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstring ans=\"\";\nbool a[5][5][4] = {{{0}}};\nint main(){\n    string str;\n    for(int i=0;i<9;i++){\n        if(i%2==0){\n            cin>>str;\n            for(int j=0;j<4;j++){\n                if(str[j]=='1'){\n\n                    a[i/2][j][1] = true;\n                    a[i/2][j+1][3] = true;\n                    //cout<<\"-(\"<<i/2<<\" ,\"<<j<<\")(\"<<i/2<<\" ,\"<<j+1<<\")\"<<endl;\n                }\n\n            }\n        }\n        else{\n            cin>>str;\n            for(int j=0;j<5;j++){\n                if(str[j]=='1'){\n                    a[i/2][j][2] = true;\n                    a[i/2+1][j][0] = true;\n                    //cout<<\"|(\"<<i/2<<\" ,\"<<j<<\")(\"<<i/2+1<<\" ,\"<<j<<\")\"<<endl;\n                }\n\t\t\t\t\n            }\n        }\n    }\n\tcout<<\"L\";\n\t\tint x=1,y=0,way=1;\n\t\twhile(1){\n\t\t\tif(x==0&&y==0)break;\n\t\t\tif(way == 0){\n\t\t\t\tif(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 1){\n\t\t\t\tif(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 2){\n\t\t\t\tif(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 3){\n\t\t\t\tif(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n\tcout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse if(v[y][x]=='0'||y==4) xyf*=-1;\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n\telse if(v[y][x]=='0'||y==4) xyf*=-1;\n\telse{\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse if(h[y][x-1]=='0'||x==0) xyf*=-1;\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse if(h[y][x]=='0'||x==4) xyf*=-1;\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nstring vec=\"RULD\";\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4==3){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nint main(){\n    char ma[11][11];\n    memset(ma,'0',sizeof(ma));\n    for(int i=1;i<10;i++){\n        if(i%2==1)\n            for(int j=2;j<9;j+=2)\n                cin>>ma[i][j];\n        else\n            for(int j=1;j<10;j+=2)\n                cin>>ma[i][j];\n    }\n    int x=1,y=1,dir=0;\n    int mv[4][2]={{2,0},{0,2},{-2,0},{0,-2}};\n    int ts[4][6]={{1,-1,1,0,0,-1},{1,1,0,1,1,0},{-1,1,-1,0,0,1},{-1,-1,0,-1,-1,0}};\n    string str[4]={\"R\",\"D\",\"L\",\"U\"};\n    string path=\"\";\n    int ch=0;\n    for(int k=0;k<40;k++){\n        int wen=1;\n        while(ma[y+ts[dir][3]][x+ts[dir][2]]=='1'){\n            y+=mv[dir][1];\n            x+=mv[dir][0];\n            wen=0;\n            path+=str[dir];\n            wen++;\n        }\n        if(x==1&&y==1)\n            break;\n        if(ma[y+ts[dir][5]][x+ts[dir][4]]=='1')ch=1;\n        do{\n            if(ch==0)dir=(dir+1)%4;\n            else dir=(dir+4-1)%4;\n        }while((y+ts[dir][3]>10||y+ts[dir][3]<0||x+ts[dir][2]>10||x+ts[dir][2]<0)||ma[y+ts[dir][1]][x+ts[dir][0]]=='1');\n        \n    }\n    cout<<path<<endl;\n}\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1){\n        if(Longitudinal[y][x-1]=='1'){\n            cout<<\"L\";\n            serch(x-1,y,2);\n        }\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1){\n        if(side[y-1][x]=='1'){\n            cout<<\"U\";\n            serch(x,y-1,3);\n        }\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nint mox[2][4]={{0,1,0,-1},{0,0,0,-1}},moy[2][4]={{-1,0,1,0},{-1,0,0,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4;\n        if(now%2==0){\n            if(y+moy[0][now]<5&&y+moy[0][now]>-1&&side[y+moy[1][now]][x]=='1'){\n                cout<<str[now];\n                serch(x,y+moy[0][now],now-1);\n            }\n        }\n        else{\n            if(x+mox[0][now]<5&&x+mox[0][now]>-1&&Longitudinal[y][x+mox[1][now]]=='1'){\n                cout<<str[now];\n                serch(x+mox[0][now],y,now-1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\n\nvoid Solution()\n{\n    long i,j,k;\n    \n    string s[9]; //use string instead of int type\n    \n    for(int i=0; i<9; i++)\n    {\n        cin>>s[i];\n    }\n    \n    i = j = k = 0;\n    \n    cout<<\"R\";\n    \n    j++;\n    \n    for(;;) // infinite loop\n    {\n        //algorithm\n        if(k == 0 && i > 0 && s[i - 1][j] == '1')\n        {\n            cout<<\"U\";\n            i -= 2;\n            k = 3;\n        }\n        else if(k == 0 && s[i][j] == '1')\n        {\n            cout<<\"R\";\n            j++;\n            k = 0;\n        }\n        else if(k == 0 && i < 8 && s[i + 1][j] == '1')\n        {\n            cout<<\"D\";\n            i += 2;\n            k = 1;\n        }\n        else if(k == 0)\n        {\n            cout<<\"L\";\n            j--;\n            k = 2;\n        }\n        else if(k == 1 && s[i][j] == '1')\n        {\n            cout<<\"R\";\n            j++;\n            k = 0;\n        }\n        else if(k == 1 && i < 8 && s[i + 1][j] == '1')\n        {\n            cout<<\"D\";\n            i += 2;\n            k = 1;\n        }\n        else if(k == 1 && j > 0 && s[i][j - 1] == '1')\n        {\n            cout<<\"L\";\n            j--;\n            k = 2;\n        }\n        else if(k == 1)\n        {\n            cout<<\"U\";\n            i -= 2;\n            k = 3;\n        }\n        else if(k == 2 && i < 8 && s[i + 1][j] == '1')\n        {\n            cout<<\"D\";\n            i += 2;\n            k = 1;\n        }\n        else if(k == 2 && j > 0 && s[i][j - 1] == '1')\n        {\n            cout<<\"L\";\n            j--;\n            k = 2;\n        }\n        else if(k == 2 && i > 0 && s[i - 1][j] == '1')\n        {\n            cout<<\"U\";\n            i -= 2;\n            k = 3;\n        }\n        else if(k == 2)\n        {\n            cout<<\"R\";\n            j++;\n            k = 0;\n        }\n        else if(k == 3 && j > 0 && s[i][j - 1] == '1')\n        {\n            cout<<\"L\";\n            j--;\n            k = 2;\n        }\n        else if(k == 3 && i > 0 && s[i - 1][j] == '1')\n        {\n            cout<<\"U\";\n            i -= 2;\n            k = 3;\n        }\n        else if(k == 3 && s[i][j] == '1')\n        {\n            cout<<\"R\";\n            j++;\n            k = 0;\n        }\n        else if(k == 3)\n        {\n            cout<<\"D\";\n            i += 2;\n            k = 1;\n        }\n        \n        if(i == 0 && j == 0)\n        {\n            break;\n        }\n    }\n    \n    cout<<endl;\n    \n}\n\nint main()\n{\n    Solution();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<complex>\n#include<map>\n \n#define f first\n#define s second\n#define mp make_pair\n \n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define EPS (1e-10)\nusing namespace std;\n \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n \nint kabe[5][5][5][5];\n \nenum direct {\n  RIGHT = 0,\n  DOWN  = 1,\n  LEFT  = 2,\n  UP    = 3\n};\n \nconst char *dstr = \"RDLU\";\n \nconst int dx[4] = { 1, 0,-1, 0};\nconst int dy[4] = { 0, 1, 0,-1};\n \n#define D(d) (((d)+4)%4)\n \nbool go(int x1, int y1, int x2, int y2){\n  if(x2 < 0 || y2 < 0 || x2 >= 5 || y2 >= 5) return false;\n  return kabe[x1][y1][x2][y2] == 1;\n}\n \nint main(){\n  string str;\n  REP(i,9){\n    cin>>str;\n    if(i%2 == 0){\n      REP(j,4){\n    int x = j;\n    int y = i/2;\n    if(str[j] == '1'){\n      kabe[x][y][x+1][y] = kabe[x+1][y][x][y] = 1;\n    }\n      }\n    }else{\n      REP(j,5){\n    int x = j;\n    int y = i/2;\n    if(str[j] == '1'){\n      kabe[x][y][x][y+1] = kabe[x][y+1][x][y] = 1;\n    }\n      }\n    }\n  }\n  int x = 0, y = 0;\n  int d = RIGHT;\n  while(x != 0 || y != 0 || d == RIGHT){\n    d = D(d-1);\n    while(!go(x,y,x+dx[d],y+dy[d])) d = D(d+1);\n    putchar(dstr[d]);\n    x += dx[d]; y += dy[d];\n  }\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <bitset>\n#include <cstdint>\n\nint main()\n{\n\tenum { Left, Up, Right, Down };\n\n\ttypedef std::array<std::bitset<4>, 5> Row;\n\ttypedef std::array<Row, 5> Matrix;\n\tMatrix matrix;\n\tfor (auto& row : matrix) {\n\t\trow.fill(std::bitset<4>());\n\t}\n\n\tstd::string input;\n\tstd::getline(std::cin, input);\n\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\tif (input[x] == '1') {\n\t\t\tmatrix[0][x].set(Right);\n\t\t\tmatrix[0][x + 1].set(Left);\n\t\t}\n\t}\n\n\tfor (std::uint16_t y = 0; y < 4U; ++y) {\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 5U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y][x].set(Down);\n\t\t\t\tmatrix[y + 1][x].set(Up);\n\t\t\t}\n\t\t}\n\t\tstd::getline(std::cin, input);\n\t\tfor (std::uint16_t x = 0; x < 4U; ++x) {\n\t\t\tif (input[x] == '1') {\n\t\t\t\tmatrix[y + 1][x].set(Right);\n\t\t\t\tmatrix[y + 1][x + 1].set(Left);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::uint16_t y = 0, x = 0;\n\tchar direct = 'R';\n\tdo {\n\t\tif (direct == 'R') {\n\t\t\tif (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'D') {\n\t\t\tif (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'L') {\n\t\t\tif (matrix[y][x][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'U') {\n\t\t\tif (matrix[y][x][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--x;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--y;\n\t\t\t}\n\t\t\telse if (matrix[y][x][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++y;\n\t\t\t}\n\t\t}\n\t\tstd::cout << direct << std::flush;\n\t} while (not (y == 0 and x == 0));\n\tstd::cout << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nclass P{\n\tpublic:\n\tint a,b,c;\n\tP(){}\n\tP(int a,int b,int c):a(a),b(b),c(c){}\n};\n\nint main(){\n\t\n\tconst int N = 20;\n\tconst int B = 2;\n\tstring m[2][N];\n\t\n\tP dp[4];\n\tdp[0]=P(0,0,0);\n\tdp[1]=P(1,-1,0);\n\tdp[2]=P(0,-1,0);\n\tdp[3]=P(1,-1,1);\n\t\n\t\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\tstring ds=\"RDLU\";\n\t\n\trep(i,B){\n\t\tm[0][i]=m[1][i]=\"00000000000\";\n\t\tm[0][i+9/2+B]=m[1][i+9/2+B]=\"00000000000\";\n\t}\n\trep(i,9){\n\t\tstring s;\n\t\tcin>>s;\n\t\t\t\n\t\tif(i%2==0){\n\t\t\tm[0][i/2+B]=\"00\"+s+\"00\"; \n\t\t}\n\t\telse{\n\t\t\tm[1][i/2+B]=\"00\"+s+\"00\";\n\t\t}\n\t}\n\t\n\tint x = B;\n\tint y = B;\n\tint dir = 0;\n\tstring ans = \"\";\n\twhile(1){\n\t\tif(x==B && y==B && dir==0 && ans.size()!=0)break;\n\t\t\n\t\t//printf(\"%d %d %d  [%s]%d\\n\",x,y,dir,ans.c_str(),ans.size());\n\t\tif(ans.size()>50)break;\n\t\t\n\t\tP right = dp[dir];\n\t\tP front = dp[(dir+3)%4];\n\t\t\n\t\tans += ds[dir];\n\t\t\n\t\tif(m[front.a][y+front.b][x+front.c]=='1'){\n\t\t\tdir=(dir+3)%4;\t\n\t\t}else\tif(m[right.a][y+right.b+dy[dir]][x+right.c+dx[dir]]=='0'){\n\t\t\t\n\t\t\tP nr = dp[dir];\n\t\t\twhile(m[nr.a][y+nr.b+dy[dir]][x+nr.c+dx[dir]]=='0'){\n\t\t\t\tx+=dx[dir];\n\t\t\t\ty+=dy[dir];\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t\tnr=dp[dir];\n\t\t\t} \n\t\t\tx+=dx[dir];\n\t\t\ty+=dy[dir];\n\t\t}else{\n\t\t\tx+=dx[dir];\n\t\t\ty+=dy[dir];\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n \nint a[12][12];\nint dx[4]  = {1,0,-1,0};\nint dy[4]  = {0,1,0,-1};\nchar dc[4] = {'R','D','L','U'};\n \n//ツ篠ゥツ閉ェツづ個偲シツ暗債４ツマツスツづ個陛?づ個湘ウツ妥板づーツ陳イツづ猟づゥ\nvoid cheakWall(int* wall , const int& px ,const int& py ,const int& d ){\n    for(int i=0 ; i<4 ; ++i ){\n        int mx = px + dx[(d+i)%4];\n        int my = py + dy[(d+i)%4];\n        wall[i] = a[my][mx];\n    }\n}\n \n//ツ進ツづアツつセツ古シツつォツづーツ記ツ録\nvoid record(string& s,int* wall,const int d){\n    if( wall[1] ){\n        s.push_back( dc[d] );\n    }\n}\n \n//ツ進ツづ?void go(int& px, int& py, const int& d,int* wall, string& s){\n    px += dx[d]*2;\n    py += dy[d]*2;\n    record( s , wall , d );\n}\n \nint main(){\n    string s;\n \n    //ツ配ツ療アツづ個渉可甘コツ可サ\n    for(int y=0 ; y<12 ; ++y )\n        for(int x=0 ; x<12 ; ++x )\n            a[y][x] = 0;\n \n    //ツ禿シツ療?    for(int i=0 ; i<9 ; ++i ){\n        cin >> s;\n        int y = i+1;\n        int x = (i+1)%2 + 1;\n        for(int j=0 ; j<(int)s.size() ; ++j , x+=2 ){\n            a[y][x] = s[j] - '0';\n        }\n    }\n \n    int px = 2, py = 0, d = 0;\n    bool flag = false;\n    s.clear();\n \n    while( 1 ){\n        if( px == 0 && py == 0 ) break;\n \n        int wall[4]; \n        //ツ篠ゥツ閉ェツづ個偲シツづィツづ個湘ウツ妥?        cheakWall( wall , px , py , d );\n \n        if( !wall[1] ){//ツ右ツつェツ陛?つカツづ。ツづ按つゥツづ?つスツづァ\n            //ツ古シツつォツづーツ右ツ古シツつォツづ可嘉アツづゥ\n            d = (d+1)%4;\n            //ツ進ツづ?         go( px , py , d , wall , s );\n            flag = false;\n        }else{\n            if( !wall[0] ){//ツ前ツつェツ陛?つカツづ。ツづ按つゥツづ?つスツづァ\n                //ツ進ツづ?             go( px , py , d , wall , s );\n                flag = false;\n            }else{\n                if( !wall[3] ){//ツ債カツつェツ陛?つカツづ。ツづ按つゥツづ?つスツづァ\n                    if( flag == false ){\n                        //ツ進ツづアツつセツ古シツつォツづーツ記ツ録\n                        record( s , wall , d );\n                    }\n                    //ツ古シツつォツづーツ債カツ古シツつォツづ可嘉アツづゥ\n                    d = (d+3)%4;\n                    //ツ進ツづ?                 go( px , py , d , wall , s );\n                    flag = false;\n                }else{//ツ前ツ・ツ右ツ・ツ債カツつェツ陛?つセツづ?つスツづァ\n                    flag = true;\n                    //ツ進ツづアツつセツ古シツつォツづーツ記ツ録\n                    record( s , wall , d );\n                    //ツ古シツつォツづーツ右ツ古シツつォツづ可嘉アツづゥ\n                    d = (d+3)%4;\n                    //ツ進ツづアツつセツ古シツつォツづーツ記ツ録\n                    s.push_back( dc[d] );\n                }\n            }\n        }\n    }\n    cout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid change(int,int);\nint wall_x[4][5],wall_y[5][4],muki = 0,flag = 0;\n\nint main(){\n\tint i,j,x = 0,y = 0;\n\tfor(i = 0;i < 9;i++){\n\t\tif(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n\t\telse for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n\t}\n\tdo{\n\t\tif(muki == 0){\n\t\t\tif(x != 4 && wall_x[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tx++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 1){\n\t\t\tif(y != 4 && wall_y[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"D\");\n\t\t\t\ty++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 2){\n\t\t\tif(x != 0 && wall_x[x - 1][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tx--;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 3){\n\t\t\tif(y != 0 && wall_y[x][y - 1] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tprintf(\"U\");\n\t\t\t\ty--;\n\t\t\t}else change(x,y);\n\t\t}\n\t}while(x != 0 || y != 0);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nvoid change(int x,int y){\n\tint i;\n\tif(!flag){\n\t\tflag = 1;\n\t\tmuki = (muki + 3) % 4;\n\t}\n\telse muki = (muki + 1) % 4;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor[0].size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(count!=0\n\t\t\t\t&&x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[3000];\nint len;\nint fie[3001][3001];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && (y==2 || y==0))break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\tint data[5][5][5][5];\n\n\tfor (int i = 0; i < 9; i++) {\n\t\tstring a;\n\t\tif (i % 2 == 0) {\n\t\t\tint k = i/2;\n\t\t\tcin >> a;\n\t\t\tdata[k][0][k][1] = data[k][1][k][0] = a[0]-'0';\n\t\t\tdata[k][1][k][2] = data[k][2][k][1] = a[1]-'0';\n\t\t\tdata[k][2][k][3] = data[k][3][k][2] = a[2]-'0';\n\t\t\tdata[k][3][k][4] = data[k][4][k][3] = a[3]-'0';\n\t\t} else {\n\t\t\tint k = i/2;\n\t\t\tcin >> a;\n\t\t\tdata[k][0][k+1][0] = data[k+1][0][k][0] = a[0]-'0';\n\t\t\tdata[k][1][k+1][1] = data[k+1][1][k][1] = a[1]-'0';\n\t\t\tdata[k][2][k+1][2] = data[k+1][2][k][2] = a[2]-'0';\n\t\t\tdata[k][3][k+1][3] = data[k+1][3][k][3] = a[3]-'0';\n\t\t\tdata[k][4][k+1][4] = data[k+1][4][k][4] = a[4]-'0';\n\t\t}\n\t}\n\tcout << 'R';\n\tint p[4] = {0};\n\tp[3] = 1;\n\tint pp = 0;\n\twhile (p[2] != 0 || p[3] != 0) {\n\t\tif (pp == 0) {\n\t\t\tif (p[2] != 0 && data[p[2]][p[3]][p[2]-1][p[3]] == 1) {\n\t\t\t\tcout << 'U';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]--;\n\t\t\t\tpp = 3;\n\t\t\t} else if (p[3] != 4 && data[p[2]][p[3]][p[2]][p[3]+1] == 1) {\n\t\t\t\tcout << 'R';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]++;\n\t\t\t\tpp = 0;\n\t\t\t} else if (p[2] != 4 && data[p[2]][p[3]][p[2]+1][p[3]] == 1) {\n\t\t\t\tcout << 'D';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]++;\n\t\t\t\tpp = 1;\n\t\t\t} else {\n\t\t\t\tcout << 'L';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]--;\n\t\t\t\tpp = 2;\n\t\t\t}\n\t\t} else if (pp == 1) {\n\t\t\tif (p[3] != 4 && data[p[2]][p[3]][p[2]][p[3]+1] == 1) {\n\t\t\t\tcout << 'R';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]++;\n\t\t\t\tpp = 0;\n\t\t\t} else if (p[2] != 4 && data[p[2]][p[3]][p[2]+1][p[3]] == 1) {\n\t\t\t\tcout << 'D';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]++;\n\t\t\t\tpp = 1;\n\t\t\t} else if (p[3] != 0 && data[p[2]][p[3]][p[2]][p[3]-1] == 1){\n\t\t\t\tcout << 'L';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]--;\n\t\t\t\tpp = 2;\n\t\t\t} else {\n\t\t\t\tcout << 'U';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]--;\n\t\t\t\tpp = 3;\n\t\t\t}\n\t\t} else if (pp == 2) {\n\t\t\tif (p[2] != 4 && data[p[2]][p[3]][p[2]+1][p[3]] == 1) {\n\t\t\t\tcout << 'D';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]++;\n\t\t\t\tpp = 1;\n\t\t\t} else if (p[3] != 0 && data[p[2]][p[3]][p[2]][p[3]-1] == 1){\n\t\t\t\tcout << 'L';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]--;\n\t\t\t\tpp = 2;\n\t\t\t} else if (p[2] != 0 && data[p[2]][p[3]][p[2]-1][p[3]] == 1) {\n\t\t\t\tcout << 'U';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]--;\n\t\t\t\tpp = 3;\n\t\t\t} else {\n\t\t\t\tcout << 'R';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]++;\n\t\t\t\tpp = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (p[3] != 0 && data[p[2]][p[3]][p[2]][p[3]-1] == 1){\n\t\t\t\tcout << 'L';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]--;\n\t\t\t\tpp = 2;\n\t\t\t} else if (p[2] != 0 && data[p[2]][p[3]][p[2]-1][p[3]] == 1) {\n\t\t\t\tcout << 'U';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]--;\n\t\t\t\tpp = 3;\n\t\t\t} else if (p[3] != 4 && data[p[2]][p[3]][p[2]][p[3]+1] == 1) {\n\t\t\t\tcout << 'R';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[3]++;\n\t\t\t\tpp = 0;\n\t\t\t} else {\n\t\t\t\tcout << 'D';\n\t\t\t\tp[0] = p[2];\n\t\t\t\tp[1] = p[3];\n\t\t\t\tp[2]++;\n\t\t\t\tpp = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nstruct\n{\n} undefined;\n\nauto turnRight (char d) -> char\n{\n    switch (d)\n    {\n    case 'R' :\n        return 'D';\n    case 'D' :\n        return 'L';\n    case 'L' :\n        return 'U';\n    case 'U' :\n        return 'R';\n    default :\n        return d;\n    }\n}\n\nauto move (char (& a) [5] [4] , char (& b) [4] [5] , int & x , int & y , char & right) -> char\n{\n    right = [&] () -> char\n    {\n        switch (right)\n        {\n        case 'R' :\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            break;\n        case 'D' :\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            break;\n        case 'L' :\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            break;\n        case 'U' :\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            break;\n        }\n        throw undefined;\n    } ();\n    switch (right)\n    {\n        case 'R' :\n            ++ x;\n            break;\n        case 'D' :\n            ++ y;\n            break;\n        case 'L' :\n            -- x;\n            break;\n        case 'U' :\n            -- y;\n            break;\n    }\n    return right;\n}\n\nauto main () -> int\n{\n    char a [5] [4];\n    char b [4] [5];\n    for (auto && elem : a [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [4])\n    {\n        std::cin >> elem;\n    }\n\n    int x = 0 , y = 0;\n    char right = 'R';\n    std::list <char> res;\n\n    while (true)\n    {\n        // std::cout << \"debug: \" << x << \",\" << y << std::endl;\n        res.push_back (move (a , b , x , y , right));\n        // std::cout << res.back () << std::endl;\n        if (x == 0 && y == 0)\n        {\n            break;\n        }\n    }\n    for (auto && elem : res)\n    {\n        std::cout << elem;\n    }\n    std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n\n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n            \tcheckTable[i][k][p] = 0;\n            }\n        }\n    }\n\n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n\n    printf(\"R\");\n    char current = 'R';\n\n    checkTable[0][0][1] = 1;\n\n    row = 0,col = 0;\n\n    while(true){\n        switch(current){\n        case 'L':\n        \tif(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcheckTable[row+1][col][3] = 1;\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n        \t}else if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                current = 'R';\n            }\n            break;\n        case 'R':\n        \tif(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n        \t}else if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n            }\n            break;\n        case 'U':\n        \tif(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcheckTable[row-1][col-1][0] = 1;\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n        \t}else if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n            }\n            break;\n        case 'D':\n        \tif(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcheckTable[row+1][col][1] = 1;\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n        \t}else if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else{\n            \tprintf(\"U\");\n            \tcheckTable[row][col][2] = 1;\n            \tcurrent = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n\n   printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<deque>\nusing namespace std;\n#define MAX_MAP 10\n\ndeque<string> map;\n\nint y=0,x=-1,vec=0;\nstring v=\"RULD\";\nint dvx[4]={1,0,-1,0};\nint dvy[4]={0,-1,0,1};\n\nbool wall_front(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\t//cout<<map[y*2+1]<<\" \"<<(x+2)<<endl;\n\t\tif(map[y*2+1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_straight(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[y*2][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+3][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_rightAngle(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[(y*2+1)+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[(y*2+1)-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[(y*2)-1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[(y*2+1)+1][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n\n\nvoid go_straight(){\n\tcout<<v[vec];\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\nvoid go_straight_move(){\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\n\nvoid solve(){\n\tint count=0;\n\twhile(y!=1||x!=0){\n\t\tif(count>100)break;\n\t\t//cout<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n\t\tif(wall_front()){\n\t\t\t//cout<<\"front\"<<endl;\n\t\t\tvec++;\n\t\t\tvec=vec%4;\n\t\t\tcout<<v[vec];\n\t\t}else if(wall_straight()){\n\t\t\t//cout<<\"straight\"<<endl;\n\t\t\tgo_straight();\n\t\t}else if(wall_rightAngle()){\n\t\t\t//cout<<\"right\"<<endl;\n\t\t\tgo_straight_move();\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t}else{\n\t\t\t//cout<<\"turn\"<<endl;\n\t\t\tgo_straight();\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight_move();\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t}\n\t\tcount++;\n\t}\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin.eof()!=true){\n\t\tcin>>s;\n\t\ts=\"00\"+s+\"00\";\n\t\tmap.push_back(s);\n\t}\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\t/*\n\tfor(int i=0;i<map.size();i++){\n\t\tcout<<map[i]<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <string> VS;\n\nVS R;\nstring D = \"RDLU\";\nconst int RIGHT = 0;\nconst int DOWN = 1;\nconst int LEFT = 2;\nconst int UP = 3;\n\nvoid dfs( int dir, int x, int y, int a ) {\n    cout << D[dir];\n    if ( dir != RIGHT && x == 0 && y == 0 ) return;\n\n    if ( dir == RIGHT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 0 );\n            }\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x+1 < R[y+1].size() && R[y+1][x+1] == '1' ) {\n                return dfs( DOWN, x+1, y+1, 0 );\n            }\n            if ( x+1 < R[y].size() && R[y][x+1] == '1' ) {\n                return dfs( RIGHT, x+1, y, 1 );\n            }\n            if ( y-1 >= 0 && x+1 < R[y-1].size() && R[y-1][x+1] == '1' ) {\n                return dfs( UP, x+1, y-1, 1 );\n            }\n        }\n    } else if ( dir == DOWN ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 0 );\n            }\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 1 );\n            }\n        } else {\n            if ( y+1 < R.size() && x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( RIGHT, x, y+1, 0 );\n            }\n            if ( y+2 < R.size() && R[y+2][x] == '1' ) {\n                return dfs( DOWN, x, y+2, 1 );\n            }\n            if ( y+1 < R.size() && x-1 >= 0 && R[y+1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y+1, 1 );\n            }\n        }\n    } else if ( dir == LEFT ) {\n        // 0:ue, 1:sita\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 0 );\n            }\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 0 );\n            }\n        } else {\n            if ( y+1 < R.size()&& x < R[y+1].size() && R[y+1][x] == '1' ) {\n                return dfs( DOWN, x, y+1, 1 );\n            }\n            if ( x-1 >= 0 && R[y][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y, 1 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( UP, x, y-1, 0 );\n            }\n        }\n    } else if ( dir == UP ) {\n        // 0:hidari, 1:migi\n        if ( a == 0 ) {\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 0 );\n            }\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 0 );\n            }\n        } else {\n            if ( y-1 >= 0 && x < R[y-1].size() && R[y-1][x] == '1' ) {\n                return dfs( RIGHT, x, y-1, 1 );\n            }\n            if ( y-2 >= 0 && R[y-2][x] == '1' ) {\n                return dfs( UP, x, y-2, 1 );\n            }\n            if ( y-1 >= 0 && x-1 >= 0 && R[y-1][x-1] == '1' ) {\n                return dfs( LEFT, x-1, y-1, 0 );\n            }\n        }\n    }\n}\n\nint main() {\n    R = VS( 9 );\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> R[i];\n    }\n    dfs( 0, 0, 0, 0 );\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n  int vx,vy,direction;\n  string str;\n  vx = 2;\n  vy = 2;\n  direction = 1;\n  int ex[9][8]={0},ey[8][9]={0};\n  for(int i=0;i<9;i++) {\n    if((i == 0)||(i == 2)||(i == 4)||(i == 6)||(i == 8)) {\n      //  cin >> ex[i/2][0] >> ex[i/2][1] >> ex[i/2][2] >> ex[i/2][3];\n      cin >> str;\n      ex[i/2+2][2] = atoi(str.substr(0,1).c_str());\n      ex[i/2+2][3] = atoi(str.substr(1,1).c_str());\n      ex[i/2+2][4] = atoi(str.substr(2,1).c_str());\n      ex[i/2+2][5] = atoi(str.substr(3,1).c_str());\n    }\n    else {\n      //  cin >> ey[0][(i-1)/2] >> ey[1][(i-1)/2] >> ey[2][(i-1)/2] >> ey[3][(i-1)/2] >> ey[4][(i-1)/2];\n      cin >> str;\n      ey[2][(i-1)/2+2] = atoi(str.substr(0,1).c_str());\n      ey[3][(i-1)/2+2] = atoi(str.substr(1,1).c_str());\n      ey[4][(i-1)/2+2] = atoi(str.substr(2,1).c_str());\n      ey[5][(i-1)/2+2] = atoi(str.substr(3,1).c_str());\n      ey[6][(i-1)/2+2] = atoi(str.substr(4,1).c_str());\n    }\n  }\n  /*    for(int i=2;i<7;i++) {\n      for(int j=2;j<6;j++) {\n      cout << ex[i][j];\n      }\n      cout << endl;\n      } */\n\n  while(1) {\n    if(direction == 1) {\n      if(ey[vy-1][vx] == 1) {\n\tvy--;\n\tdirection = 2;\n\tcout << \"U\";\n      }\n      else if(ex[vy][vx] == 1) {\n\tvx++;\n\tdirection = 1;\n\tcout << \"R\";\n      }\n      else if(ey[vy][vx] == 1) {\n\tvy++;\n\tdirection = 4;\n\tcout << \"D\";\n      }\n    }\n    else if(direction == 2) {\n      if(ex[vy][vx-1] == 1) {\n\tvx--;\n\tdirection = 3;\n\tcout << \"L\";\n      }\n      else if(ey[vy-1][vx] == 1) {\n\tvy--;\n\tdirection = 2;\n\tcout << \"U\";\n      }\n      else if(ex[vy][vx] == 1) {\n\tvx++;\n\tdirection = 1;\n\tcout << \"R\";\n      }\n    }\n    else if(direction == 3) {\n      if(ey[vy][vx] == 1) {\n\tvy++;\n\tdirection = 4;\n\tcout << \"D\";\n      }\n      else if(ex[vy][vx-1] == 1) {\n\tvx--;\n\tdirection = 3;\n\tcout << \"L\";\n      }\n      else if(ey[vy-1][vx] == 1) {\n\tvy--;\n\tdirection = 2;\n\tcout << \"U\";\n      }\n    }\n    else if(direction == 4) {\n      if(ey[vy][vx] == 1) {\n\tvx++;\n\tdirection = 1;\n\tcout << \"R\";\n      }\n      else if(ey[vy][vx] == 1) {\n\tvy++;\n\tdirection = 4;\n\tcout << \"D\";\n      }\n      else if(ex[vy][vx-1] == 1) {\n\tvx--;\n\tdirection = 3;\n\tcout << \"L\";\n      }\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar m[10][10];\n\nbool end(int x, int y) {\n  return (x == 1 && y == 1) || (x == 0 && y == 1) ;\n}\n\nvoid check(int x, int y, int d) {\n  printf(\"x,y = %d,%d : %d\\n\", x, y, d);\n  assert(false);\n}\n\nint main() {\n  memset(m, 0, sizeof m);\n  string ans = \"R\";\n  rep(i,9) scanf(\" %s\", m[i]);\n  rep(i,9) {\n    rep(j,5) {\n      m[i][j] = (m[i][j] == '1') ? 1 : 0 ;\n    }\n  }\n  // rep(i,9) {\n  //   rep(j,5) printf(\"%2d\", m[i][j]); puts(\"\");\n  // }\n\n  int x = 1, y = 0, d = 1;\n  do {\n    // printf(\"(%d,%d) : %d : %s\\n\", x, y, d, ans.c_str());\n    switch (d) {\n      case 0: {\n        // up\n        if (m[2*(y-2)+1][x]) {\n          // ok\n          ans += 'U';\n          --y;\n        } else if (m[2*(y-1)][x]) {\n          // ok\n          ans += 'R';\n          d = 1;\n          ++x; --y;\n        } else if (m[2*(y-1)][x-1]) {\n          ans += 'L';\n          d = 3;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 1: {\n        // right\n        if (m[2*y][x]) {\n          // ok\n          ans += 'R';\n          ++x;\n        } else if (m[2*(y-1)+1][x]) {\n          ans += 'U';\n          d = 0;  \n        } else if (m[2*y+1][x]) {\n          // ok\n          ans += 'D';\n          d = 2;\n          ++x; ++y;\n        } else {check(x,y,d);}\n        break;        \n      }\n      case 2: {\n        // down\n        if (m[2*y+1][x-1]) {\n          // ok\n          ans += 'D';\n          ++y;\n        } else if (m[2*y][x-1]) {\n          ans += 'R';\n          d = 1;\n        } else if (m[2*y][x-2]) {\n          // ok\n          ans += 'L';\n          d = 3;\n          --x; ++y;\n        } else {check(x,y,d);}\n        break;\n      }\n      case 3: {\n        // left\n        if (m[2*(y-1)][x-2]) {\n          // ok\n          ans += 'L';\n          --x;\n        } else if (m[2*(y-2)+1][x-1]) {\n          // ok\n          ans += 'U';\n          d = 0;\n          --x; --y;\n        } else if (m[2*(y-1)+1][x-1]) {\n          ans += 'D';\n          d = 2;\n        } else {check(x,y,d);}\n        break;        \n      }\n    }\n  } while (!end(x,y));\n  if (x == 1 && y == 1 && d == 0) ans += 'L';\n  printf(\"%s\\n\", ans.c_str());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\nlong i,j,k;\nstring s[9];\nfor(i=0;i<9;i++)cin>>s[i];\ni=j=k=0;\ncout<<\"R\";j++;\nfor(;;){\n     if(k==0&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==0&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==0&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==0)                     {cout<<\"L\";j--; k=2;}\nelse if(k==1&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==1&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==1&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==1)                     {cout<<\"U\";i-=2;k=3;}\nelse if(k==2&&i<8&&s[i+1][j]=='1'){cout<<\"D\";i+=2;k=1;}\nelse if(k==2&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==2&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==2)                     {cout<<\"R\";j++; k=0;}\nelse if(k==3&&j>0&&s[i][j-1]=='1'){cout<<\"L\";j--; k=2;}\nelse if(k==3&&i>0&&s[i-1][j]=='1'){cout<<\"U\";i-=2;k=3;}\nelse if(k==3&&     s[i][j]  =='1'){cout<<\"R\";j++; k=0;}\nelse if(k==3)                     {cout<<\"D\";i+=2;k=1;}\nif(i==0&&j==0)break;\n}\ncout<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\n\ninline bool value(int x,int y,int w,int h){\n\treturn (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst int dy[] = {1,0,0,-1,1,-1,1,-1};\nconst int dx[] = {0,-1,1,0,1,-1,-1,1};\nconst int bit[] = {8,4,1,2,1,};\nconst string = \"DLRU\";\nll grid[6][6];\n// u = 1,r = 2, d = 4, l = 8\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvary(char,v,5,0);\n\trep(i,9){\n\t\tif(i % 2){\n\t\t\trep(j,5){\n\t\t\t\tcin >> v[j];\n\t\t\t\tv[j] -= '0';\n\t\t\t\tgrid[j+1][i/2+1] |= 8 *v[j];\n\t\t\t\tgrid[j][i/2+1] |= 2 * v[j];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trep(j,4){\n\t\t\t\tcin >> v[j];\n\t\t\t\tv[j] -= '0';\n\t\t\t\tgrid[j+1][i/2+1] |= v[j];\n\t\t\t\tgrid[j+1][i/2] |= v[j]* 4;\n\t\t\t}\n\t\t}\n\t}\n\tll x = 1,y = 0,c=0,dir = 2;\n\tll u = 1,r = 2, d = 4,l = 8;\n\tcout << \"R\";\n\twhile(1){\n\t\tif(x == 1 && y == 0 && c) break;\n\t\t++c;\n\t\tif(c > 100)break;\n\t\tif(dir == 0){\n\t\t\tif(grid[x][y+1] & l){\n\t\t\t\t++y;\n\t\t\t\tcout << \"D\";\n\t\t\t}\n\t\t\telse if(grid[x-1][y+1] & u){\n\t\t\t\t--x;\n\t\t\t\t++y;\n\t\t\t\tdir = 1;\n\t\t\t\tcout << \"L\";\n\t\t\t}\n\t\t}\n\t\telse if(dir == 1){\n\t\t\tif(grid[x-1][y] & u){\n\t\t\t\t--x;\n\t\t\t\tcout << \"L\";\n\t\t\t}\n\t\t\telse if(grid[x-1][y-1] & r){\n\t\t\t\t--x;\n\t\t\t\t--y;\n\t\t\t\tdir = 3;\n\t\t\t\tcout << \"U\";\n\t\t\t}\n\t\t}\n\t\telse if(dir == 2){\n\t\t\tif(grid[x+1][y] & d){\n\t\t\t\t++x;\n\t\t\t\tcout << \"R\";\n\t\t\t}\n\t\t\telse if(grid[x+1][y+1] & l){\n\t\t\t\t++x;\n\t\t\t\t++y;\n\t\t\t\tdir = 0;\n\t\t\t\tcout << \"D\";\n\t\t\t}\n\t\t}\n\t\telse if(dir == 3){\n\t\t\tif(grid[x][y-1] & r){\n\t\t\t\t--y;\n\t\t\t\tcout << \"U\";\n\t\t\t}\n\t\t\telse if(grid[x+1][y-1] & d){\n\t\t\t\t++x;\n\t\t\t\t--y;\n\t\t\t\tdir =2;\n\t\t\t\tcout << \"R\";\n\t\t\t}\n\t\t}\n\t\tif(dir == 0){\n\t\t\tif(grid[x][y] & d){\n\t\t\t\tdir = 2;\n\t\t\t\tcout << \"R\";\n\t\t\t\tif(grid[x][y] & r){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir == 1){\n\t\t\tif(grid[x][y] & l){\n\t\t\t\tdir = 0;\n\t\t\t\tcout << \"D\";\n\t\t\t\tif(grid[x][y] & d){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir == 2){\n\t\t\tif(grid[x][y] & r){\n\t\t\t\tdir = 3;\n\t\t\t\tcout << \"U\";\n\t\t\t\tif(grid[x][y] & u){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tcout <<\"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir == 3){\n\t\t\tif(grid[x][y] & u){\n\t\t\t\tdir = 1;\n\t\t\t\tcout <<\"L\";\n\t\t\t\tif(grid[x][y] & l){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n\t//   cout << \"u = 1,r = 2, d = 4, l = 8\"<<endl;\n\t//   rep(i,6){\n\t//     rep(j,6){\n\t//       scout(3) << grid[j][i];\n\t//     }\n\t//     cout << endl;\n\t//   }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[10][10];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U','R','D','L'};\n\nvoid touch_wall (int row, int col, int dir, int hand, string & res )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n/*\n\trep (j, 5 ){\n\t\tgrid[0][j] |= 1<<TOP;\n\t\tgrid[5][j] |= 1<<BOTTOM;\n\t} // end rep\n\trep (i, 6 ){\n\t\tgrid[i][0] |= 1<<LEFT;\n\t\tgrid[i][4] |= 1<<RIGHT;\n\t} // end rep\n*/\n\tfor (int i = 1; i <= 9; i++ ){\n\t\tstring s = \"\";\n\t\tcin >> s;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tif (j == 0 ){\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t\tgrid[i/2][j-1] |= 1<<RIGHT;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n/*\n\trep (i, 6 ){\n\t\trep (j, 5 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n*/\n\tint row = 0, col = 0, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tstring res = \"\";\n\twhile (!(row == 1 && col == 0 && (dir == LEFT ) ) ){\n\t\ttouch_wall (row, col, dir, hand, res );\n\t\tif ((1<<hand & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった、なくなった方向に回転\n\t\t\tdir = hand;\n\t\t}else\n\t\tif ((1<<dir & grid[row][col] ) != 0 ){\t\n\t\t\twhile ((1<<dir & grid[row][col] ) != 0 ){// 右手の壁があったとしても前に進めない\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand, res );\n\t\t\t} // end while\n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t} // end while\n\ttouch_wall (row, col, dir, hand, res );\n\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n#define M_PI 3.141592\n#define toRad 2.0*M_PI/360.0\n#define inin(x) int x;cin>>x;\n#define all(x) x.begin(),x.end()\n\nstruct point\n{\n\tbool b[4];\n};\n\n\n\nint main()\n{\n\tpoint a[5][5];\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfor (int l = 0; l < 5; l++)\n\t\t{\n\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t{\n\t\t\t\ta[i][l].b[k] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor (int l = 0; l < 4; l++)\n\t\t{\n\t\t\ta[i][l].b[1] = a[i][l + 1].b[3] = str[l] - '0';\n\t\t}\n\n\t\tif (i != 5 - 1)\n\t\t{\n\t\t\tcin >> str;\n\t\t\tfor (int l = 0; l < 5; l++)\n\t\t\t{\n\t\t\t\ta[i][l].b[2] = a[i + 1][l].b[0] = str[l] - '0';\n\t\t\t}\n\t\t}\n\t}\n\tint x, y, v;\n\tx = y = 0;\n\tv = 1;\n\twhile (1)\n\t{\n\t\tint d[4] = { -1 + 4,0 + 4,+1 + 4,+2 + 4 };\n\t\tint dx[4] = { 0,1,0,-1 };\n\t\tint dy[4] = { -1,0,1,0 };\n\t\tchar dc[5] = \"URDL\";\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint di = (v + d[i]) % 4;\n\t\t\tif (a[y][x].b[di])\n\t\t\t{\n\t\t\t\tx += dx[di];\n\t\t\t\ty += dy[di];\n\t\t\t\tv = di;\n\t\t\t\tcout << dc[di];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (x == y&&x == 0)\n\t\t{\n\t\t\tcout << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tmemset(yoko,0,sizeof(yoko));\n\t\tmemset(tate,0,sizeof(tate));\n\t\t\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c;\n\t\t\t}\n\t\t\tif(i!=4){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin>>c;\n\t\t\t\t\ttate[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//\tif(cin.eof())\n\t//\t\tbreak;\n\t\t\n\t\t\n// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\tstring str=\"\";\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tstr+='R';\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tstr+='L';\n//\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n//\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tstr+='D';\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tstr+='L';\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n//\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n//\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n//\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tstr+='U';\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n//\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n//\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n//\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0){\n\t\t\t\tbreak;\n\t\t\t}\n}\n\ncout<<str<<endl;\nbreak;\n\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n\nint main()\n{\n\tint field[5][5] = {{0}};\n\trep(i, 9){\n\t\tchar str[6];\n\t\tscanf(\"%s\", str);\n\t\tif(i%2){\n\t\t\trep(j, 5){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<2;\n\t\t\t\tfield[i/2+1][j] |= a;\n\t\t\t}\n\t\t}else{\n\t\t\trep(j, 4){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<1;\n\t\t\t\tfield[i/2][j+1] |= a<<3;\n\t\t\t}\n\t\t}\n\t}\n\n\tputchar('R');\n\tint y=0, x=1;\n\tint pre = 1;\n\tbool right = false;\n\tdo{\n\t\tpre = (pre+2)%4;\n\t\tint dire = pre;\n\t\tdo{\n\t\t\tdire = (dire + right*2+1)%4;\n\t\t}while(!((field[y][x]>>dire)&1));\n\t\tif(dire == pre)\n\t\t\tright = !right;\n\t\tpre = dire;\n\t\tputchar(\"URDL\"[dire]);\n\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx += dx[dire];\n\t\ty += dy[dire];\n\t}while(y!=0 || x!=0);\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s[9];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint r;\nbool in(int a)\n{\n\treturn 0<=a&&a<=4;\n}\nbool check(int a,int b,int c,int d)\n{\n\tif(!(in(a)&&in(b)&&in(c)&&in(d)))return false;\n\tif(a==c)\n\t{\n\t\treturn s[2*a][b<d?b:d]=='1';\n\t}\n\telse\n\t{\n\t\treturn s[2*(a<c?a:c)+1][b]=='1';\n\t}\n}\nmain()\n{\n\tfor(int i=0;i<9;i++)cin>>s[i];\n\tint x=0,y=0;\n\twhile(1)\n\t{\n\t\tfor(int dr=3;dr<7;dr++)\n\t\t{\n\t\t\tint nr=(r+dr)%4;\n\t\t\tint tx=x+dx[nr],ty=y+dy[nr];\n\t\t\tif(check(x,y,tx,ty))\n\t\t\t{\n\t\t\t\tr=nr;\n\t\t\t\tx=tx;\n\t\t\t\ty=ty;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<\"RDLU\"[r];\n\t\tif(x==0&&y==0)break;\n\t}\n\tcout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nint mox[2][2]={{1,-1},{0,-1}},moy[2][2]={{-1,1},{-1,0}};\nchar str[5]=\"URDL\";\nvoid serch(int x,int y,int then)\n{\n    if(then==-1)then=3;\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    for(int i=0;i<4;i++){\n        int now=(then+i)%4,ka=now/2;\n        if(now%2==0){\n            if(y+moy[0][ka]<5&&y+moy[0][ka]>-1&&side[y+moy[1][ka]][x]=='1'){\n                cout<<str[now];\n                serch(x,y+moy[0][ka],now-1);\n            }\n        }\n        else{\n            if(x+mox[0][ka]<5&&x+mox[0][now/2]>-1&&Longitudinal[y][x+mox[1][ka]]=='1'){\n                cout<<str[now];\n                serch(x+mox[0][ka],y,now-1);\n            }\n        }\n    }\n}\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nenum Direction {R, L, U, D};\n\nbool input(char b[][5])\n{\n\tchar dummy;\n\tfor (int i=0; i<9; i++) {\n\t\tfor (int j=0; j<5; j++) {\n\t\t\tif ((i&1)==0 && j==4) continue;\n\t\t\tif ( !(cin >> b[i][j]) ) return false;\n\t\t}\n\t\t//cin >> dummy;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tchar board[9][5];\n\tinput(board);\n\t\n\tpair<int, int> curr_pos = pair<int,int>(0,0);\n\tenum Direction curr_dir = R;\n\tcout << \"R\";\n\t\n\tdo {\n\t\tswitch (curr_dir) {\n\t\tcase R:\n\t\t\t// priority : U > R > D\n\t\t\tif ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--; curr_pos.second++;\n\t\t\t} else if ( curr_pos.second < 3 && board[curr_pos.first][curr_pos.second+1] == '1' ){\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.second++;\n\t\t\t} else {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++; curr_pos.second++;\n\t\t\t} \n\t\t\tbreak;\n\t\tcase L:\n\t\t\t// priority : D > L > U\n\t\t\tif ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.second--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\t// priority : L > U > R\n\t\t\tif ( curr_pos.second > 0 && board[curr_pos.first-1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first--; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 2 && board[curr_pos.first-2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first-=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\t// priority : R > D > L\n\t\t\tif ( board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.first < 6 && board[curr_pos.first+2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first+=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first++; curr_pos.second--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ( curr_pos.first != 0 || curr_pos.second != 0 );\n\t\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4], Longitudinal[5];\nint mox[2][2] = { { 1, -1 }, { 0, -1 } }, moy[2][2] = { { -1, 1 }, { -1, 0 } };\nchar str[5] = \"URDL\";\n//1,0,0\nvoid serch(int x, int y, int then)\n{\n\tif (then == -1)\n\t\tthen = 3;\n\tif (!x && !y) {\n\t\tcout << endl;\n\t\texit(0);\n\t}\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint now = (then + i) % 4, ka = now / 2;\n\t\tif (!(now % 2) && y + moy[0][ka] < 5 &&\n\t\ty + moy[0][ka] > -1 && side[y + moy[1][ka]][x] == '1') {\n\t\t\tcout << str[now];\n\t\t\tserch(x, y + moy[0][ka], now - 1);\n\t\t}\n\t\tif (now % 2 && x + mox[0][ka] < 5 &&\n\t\tx + mox[0][now / 2] > -1 && Longitudinal[y][x + mox[1][ka]] == '1') {\n\t\t\tcout << str[now];\n\t\t\tserch(x + mox[0][ka], y, now - 1);\n\t\t}\n\t}\n\n}\n\nint main()\n\n{\n\tfor (int i = 0; i < 4; i++)\n\t\tcin >> Longitudinal[i] >> side[i];\n\tcin >> Longitudinal[4];\n\tcout << \"R\";\n\tserch(1, 0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint i, j, a[6][6] = {}, b[6][5] = {};\nstring output = \"\";\n\nint right(), left(), up(), down();\n\nint right(){\n\toutput += \"R\";\n\tif(b[i-1][j] == 1){\n\t\ti--;\n\t\tup();\n\t}\n\telse if(a[i][j+1] == 1){\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"R\"; }\n\telse {\n\t\tdown();\n\t}\n\treturn 0;\n}\n\nint left(){\n\toutput += \"L\";\n\tif (b[i][j-1] == 1) {\n\t\tj--;\n\t\tdown();\n\t}\n\telse if (a[i][j-1] == 1) {\n\t\tj--;\n\t\tleft();\n\t}\n\telse if (a[i][j - 1] == 2) { output += \"L\"; }\n\telse {\n\t\ti--;\n\t\tj--;\n\t\tup();\n\t}\n\treturn 0;\n}\n\nint up(){\n\toutput += \"U\";\n\tif (a[i][j] == 1) {\n\t\tleft();\n\t}\n\telse if (a[i][j] == 2) { output += \"L\"; }\n\telse if (b[i-1][j] == 1) {\n\t\ti--;\n\t\tup();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"U\"; }\n\telse {\n\t\tj++;\n\t\tright();\n\t}\n\treturn 0;\n}\n\nint down(){\n\toutput += \"D\";\n\tif (a[i+1][j+1] == 1) {\n\t\ti++;\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i + 1][j + 1] == 2) {  }\n\telse if (b[i + 1][j] == 1) {\n\t\ti++;\n\t\tdown();\n\t}\n\telse if (a[i + 1][j] == 2) { output += \"L\"; }\n\telse {\n\t\ti++;\n\t\tleft();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tstring input, k;\n\tfor(i = 1; i<10;i++){\n\t\tgetline(cin, input);\n\t\tif (input.size() != 4) {\n\t\t\tfor(int j= 0;j<5;j++){\n\t\t\t\tk = input[j];\n\t\t\t\tb[i / 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1;j<5;j++){\n\t\t\t\tk = input[j-1];\n\t\t\t\ta[(i + 1)/ 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\n\t}\n\n\ta[1][1] = 2;\n\ti = 1;\n\tj = 1;\n\tright();\n\tcout << output << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOL q0037\n// YAMADA Terushige\n// 2013.4.12\n\n#include<iostream>\n \nusing namespace std;\nint grid[5][5][4];\n \nint main(){\n \n  enum Direc {L,U,R,D};\n  string s;\n\n  int i,j,k,d;\n  for(i=0;i<4;i++){\n    cin >> s;\n    for(j=0;j<4;j++){\n      grid[i][j][R]=grid[i][j+1][L]=s[j]-'0';\n    }\n    cin >> s;\n    for(j=0;j<5;j++){\n      grid[i][j][D]=grid[i+1][j][U]=s[j]-'0';\n    }\n  }\n  cin >> s;\n  for(j=0;j<4;j++){\n    grid[i][j][R]=grid[i][j+1][L]=s[j]-'0';\n  }\n\n  i=0;j=1;\n  d=R;cout <<'R';\n  while(i!=0 || j!=0){\n    d=(d+2)%4;\n    for(k=0;k<4;k++){\n      d=(d+1)%4;\n      if(grid[i][j][d]==1)break;\n    }\n\n    switch(d){\n    case L:\n      cout << 'L';j--;\n      break;\n    case U:\n      cout << 'U';i--;\n      break;\n    case R:\n      cout << 'R';j++;\n      break;\n    case D:\n      cout << 'D';i++;\n      break;\n    }\n\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,x = 1,y = 0,t = 2;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 1){\n      if(field[x][y]&2){\n\tcout <<\"U\";\n\tif(field[x][y]&1){t = 8;}\n\telse{y--;}\n      }\n      else{x++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[x][y]&4){\n\tcout <<\"R\";\n\tif(field[x][y]&2){t = 1;}\n\telse{x++;}\n      }\n      else{y++;t = 4;}\n    }\n    else if(t == 4){\n      if(field[x][y]&8){\n\tcout <<\"D\";\n\tif(field[x][y]&4){t = 2;}\n\telse{y++;}\n      }\n      else{x--;t = 8;}\n    }\n    else if(t == 8){\n      if(field[x][y]&1){\n\tcout <<\"L\";\n\tif(field[x][y]&8){t = 4;}\n\telse{x--;}\n      }\n      else{y--;t = 1;}\n    }\n    if(!x && !y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4] = {-1,0,1,0}, dy[4] = {0,-1,0,1};\n\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  rep(i, 5) {\n    char x;\n    rep(j, 4) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n        G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n      }\n    }\n\n    if(i == 4) break;\n\n    rep(j, 5) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n        G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n      }\n    }\n  }\n\n  string const OP = \"LURD\";\n\n  int y = 0, x = 0, d = 2;\n\n  while(y != 0 || x != 0 || d != 0) {\n    int le = -1, st = -1, ri = -1, dw = -1;\n    for(auto && e: G[y * 5 + x]) {\n      if(e.second == (d + 3) % 4) le = e.second;\n      if(e.second == (d + 1) % 4) ri = e.second;\n      if(e.second == d) st = e.second;\n      if(e.second == (d + 2) % 4) dw = e.second;\n    }\n    if(le != -1) d = le;\n    else if(st != -1) ;\n    else if(ri != -1) d = ri;\n    else d = dw;\n    y += dy[d], x += dx[d];\n    cout << OP[d];\n  }\n  cout << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nstring sdir = \"URDL\";\nint dx[] = {0, 0, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main(){\n\tvector<string> v(9);\n\n\trep(i, 9){\n\t\tcin >> v[i];\n\t\tv[i] += '0';\n\t}\n\n\tint x = 0, y = 0;\n\tint dir = 1;\n\tdo{\n\t\tdir += 3;\n\t\trep(i, 4){\n\t\t\tint ndir = (dir+i)%4;\n\t\t\tint nx = x + dx[ndir];\n\t\t\tint ny = y*2 + dy[ndir];\n\t\t\tif(nx < 0 || nx >= 5 ||ny < 0 || ny >= 9) continue;\n\t\t\tif(v[ny][nx] == '0') continue;\n\t\t\tx += dx[ndir]+(ndir==1);\n\t\t\ty += dy[ndir];\n\t\t\tdir = ndir;\n\t\t\tcout << sdir[ndir];\n\t\t\tbreak;\n\t\t}\n\t}while(x!=0||y!=0);\n\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nchar dc[] = \"RDLU\";\n\nint main() {\n\tbool g[11][11];\n\tchar c;\n\tfor (int i=1; i<10; ++i) {\n\t\tfor (int j=1+i%2; j<=9; j+=2) {\n\t\t\tcin >> c;\n\t\t\tg[i][j] |= c - '0';\n\t\t}\n\t}\n\tint x=1, y=1, d=0;\n\tdo {\n\t\tfor (int t=d+3; ; ++t) {\n\t\t\tif (g[y + dy[t%4]][x + dx[t%4]]) {\n\t\t\t\td = t%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx += dx[d] * 2;\n\t\ty += dy[d] * 2;\n\t\tcout << dc[d];\n\t} while (x != 1 || y != 1);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor[0].size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(count!=0\n\t\t\t\t&&x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  while(cin>>h[0]){\n    for(int i=0;i<4;i++){\n      cin>>v[i];\n      cin>>h[i+1];\n    }\n    f=xyf=1;\n    y=0;\n    x=1;cout<<\"R\";\n    while(x!=0||y!=0){\n      if(f==1){\n\tif(xyf==1){\n\t  if(y>0&&v[y-1][x]=='1'){\n\t    y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t  }\n\t  else if(x<4&&h[y][x]=='1'){\n\t    x++;cout<<\"R\";\n\t  }\n\t  else if(v[y][x]=='0') xyf*=-1;\n\t  else{\n\t    y++;f*=-1;cout<<\"D\";\n\t  }\n\t}\n\telse{\n\t  if(y>0&&v[y-1][x]=='1'){\n\t    y--;cout<<\"U\";f*=-1;\n\t  }\n\t  else if(x>0&&h[y][x-1]=='1'){\n\t    x--;cout<<\"L\";\n\t  }\n\t  else if(v[y][x]=='0') xyf*=-1;\n\t  else{\n\t    y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t  }\n\t}\n      }\n      else{\n\tif(xyf==1){\n\t  if(x<4&&h[y][x]=='1'){\n\t    x++;cout<<\"R\";f*=-1;\n\t  }\n\t  else if(y<4&&v[y][x]=='1'){\n\t    y++;cout<<\"D\";\n\t  }\n\t  else if(h[y][x-1]=='0') xyf*=-1;\n\t  else{\n\t    x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t  }\n\t}\n\telse{\n\t  if(x>0&&h[y][x-1]=='1'){\n\t    x--;cout<<\"L\";f*=-1;\n\t  }\n\t  else if(y>0&&v[y-1][x]=='1'){\n\t    y--;cout<<\"U\";\n\t  }\n\t  else if(h[y][x]=='0') xyf*=-1;\n\t  else{\n\t    x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t  }\n\t}\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ROW_BLOCK 4\n#define COL_BLOCK 4\n#define ROW_NUM (ROW_BLOCK + 2) * 2 - 1\n#define COL_NUM (COL_BLOCK + 2) * 2 - 1\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n\nconst char command[5] = \"URDL\";\nconst int dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};\nconst int gy = 1, gx = 1;\n\nint main(void){\n\tint i, j, stage[ROW_NUM][COL_NUM];\n\tmemset(stage,0,sizeof(stage));\n\tfor(i = 1;i < ROW_NUM - 1;i++){\n\t\tchar str[ROW_BLOCK + 2];\n\t\tscanf(\"%s\",str);\n\t\tfor(j = 1 + i % 2;j < COL_NUM - 1;j+=2){\n\t\t\tstage[i][j] = str[(j - 1) / 2] - '0';\n\t\t}\n\t}\n\tint nd = RIGHT, nx = 1, ny = 1;\n\tdo{\n\t\tif(stage[ny + dy[nd]][nx + dx[nd]] == 0 && stage[ny + dy[(nd + 3) % 4]][nx + dx[(nd + 3) % 4]] == 0){ // 今向いている方向に壁がなく右手にも壁がなければれば\n\t\t\tnd = (nd + 1) % 4;\n\t\t}else if(stage[ny + dy[(nd + 3) % 4]][nx + dx[(nd + 3) % 4]] == 1){\n\t\t\tnd = (nd + 3) % 4;\n\t\t\tny += dy[nd] * 2;\n\t\t\tnx += dx[nd] * 2;\n\t\t\tprintf(\"%c\",command[nd]);\n\t\t}else{\n\t\t\tny += dy[nd] * 2;\n\t\t\tnx += dx[nd] * 2;\n\t\t\tprintf(\"%c\",command[nd]);\n\t\t}\n\n\t\t/*for(i = 0;i < ROW_NUM;i++){\n\t\t\tfor(j = 0;j < COL_NUM;j++){\n\t\t\t\tif(ny == i && nx == j){\n\t\t\t\t\tprintf(\"# \");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d \",stage[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\twhile(getchar() != '\\n');*/\n\t}while(!((nx == gx) && (ny == gy)));\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[100];\nint len;\nint fie[101][101];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=9;\n\tfor(int i=0;i<10;i++)cin >> str[i];\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t}else if(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else dir=(dir+1)%4;\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nstruct\n{\n} undefined;\n\nauto turnRight (char d) -> char\n{\n    switch (d)\n    {\n    case 'R' :\n        return 'D';\n    case 'D' :\n        return 'L';\n    case 'L' :\n        return 'U';\n    case 'U' :\n        return 'R';\n    default :\n        return d;\n    }\n}\n\nauto move (char (& a) [5] [4] , char (& b) [4] [5] , int & x , int & y , char & right) -> char\n{\n    right = [&] () -> char\n    {\n        switch (right)\n        {\n        case 'R' :\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            break;\n        case 'D' :\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            break;\n        case 'L' :\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            break;\n        case 'U' :\n            if (x > 0 && a [y] [x - 1] == '1')\n            {\n                return 'L';\n            }\n            if (y > 0 && b [y - 1] [x] == '1')\n            {\n                return 'U';\n            }\n            if (x < 4 && a [y] [x] == '1')\n            {\n                return 'R';\n            }\n            if (y < 4 && b [y] [x] == '1')\n            {\n                return 'D';\n            }\n            break;\n        }\n        throw undefined;\n    } ();\n    switch (right)\n    {\n        case 'R' :\n            ++ x;\n            break;\n        case 'D' :\n            ++ y;\n            break;\n        case 'L' :\n            -- x;\n            break;\n        case 'U' :\n            -- y;\n            break;\n    }\n    return right;\n}\n\nauto main () -> int\n{\n    char a [5] [4];\n    char b [4] [5];\n    for (auto && elem : a [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [0])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [1])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [2])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : b [3])\n    {\n        std::cin >> elem;\n    }\n    for (auto && elem : a [4])\n    {\n        std::cin >> elem;\n    }\n\n    int x = 0 , y = 0;\n    char right = 'R';\n    std::list <char> res;\n\n    while (true)\n    {\n#ifdef DEBUG\n        std::cout << \"debug: \" << x << \",\" << y << std::endl;\n#endif\n        res.push_back (move (a , b , x , y , right));\n#ifdef DEBUG\n        std::cout << res.back () << std::endl;\n#endif\n        if (x == 0 && y == 0)\n        {\n            break;\n        }\n    }\n    for (auto && elem : res)\n    {\n        std::cout << elem;\n    }\n    std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst char dir[] = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        // do {\n        //     if (map[y][x][d])\n        //         ;\n        //     else if (map[y][x][(d + 1) % 4]) \n        //         d = (d + 1) % 4;\n        //     else if (map[y][x][(d + 3) % 4]) \n        //         d = (d + 3) % 4;\n\n            // map[y][x][d] = false;\n            // x += dx[d];\n            // y += dy[d];\n            // cout << dir[d];\n        // } while (x || y);\n        do {\n            int del = (d + 3) % 4;\n            for (int i = 0; i < 4; i++) \n                if (map[y][x][(del + i) % 4]) {\n                    d = (del + i) % 4;\n                    break;\n                }\n\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tdir = D;\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tdir = U;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tdir = U;\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tdir = D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tdir = L;\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tdir = R;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tdir = R;\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tdir = L;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && crd[1] == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0)return;\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n  }\n  //cout<<\"error\"<<endl;\n}\n\nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int H = 5;\nconst int W = 5;\nconst int D = 4;\nconst string DIR = \"RULD\";\n\nint v[H][W][D], my[4] = {0, -1, 0, 1}, mx[4] = {1, 0, -1, 0}, d = 0, y = 0, x = 1;\n\nint main() {\n  REP(i, 9){\n    string s; cin >>s;\n    if(i % 2) REP(j, s.length()) if(s[j] == '1') v[(i + 1) / 2 - 1][j][3] = v[(i + 1) / 2][j][1] = true;\n    if(!(i % 2)) REP(j, s.length()) if(s[j] == '1') v[i / 2][j][0] = v[i / 2][j + 1][2] = true;\n  }\n  stringstream ss; ss << 'R';\n  while(y != 0 || x != 0){\n    if(v[y][x][(d + 1) % 4]){\n      d = (d + 1) % 4; y += my[d]; x += mx[d];\n      ss << DIR[d];\n    } else if (v[y][x][d]){\n      y += my[d]; x += mx[d];\n      ss << DIR[d];\n    } else{\n      d = (d + 3) % 4;\n    }\n  }\n  cout <<ss.str() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(count!=0&&x==0&&y==0/*&&(v+loop[i])%4==2*/){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4] = {-1,0,1,0}, dy[4] = {0,-1,0,1};\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  rep(i, 5) {\n    char x;\n    rep(j, 4) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n        G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n      }\n    }\n\n    if(i == 4) break;\n\n    rep(j, 5) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n        G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n      }\n    }\n  }\n\n  string const OP = \"LURD\";\n\n  int y = 0, x = 0, d = 2;\n\n  while(y != 0 || x != 0 || d != 0) {\n    int le = -1, st = -1, ri = -1, dw = -1;\n    for(auto && e: G[y * 5 + x]) {\n      if(e.second == (d + 3) % 4) le = e.second;\n      if(e.second == (d + 1) % 4) ri = e.second;\n      if(e.second == d) st = e.second;\n      if(e.second == (d + 2) % 4) dw = e.second;\n    }\n    if(le != -1) d = le;\n    else if(st != -1) ;\n    else if(ri != -1) d = ri;\n    else d = dw;\n    y += dy[d], x += dx[d];\n    cout << OP[d];\n  }\n  cout << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n\tif(row % 2 == 0){\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nint main(){\n\tint row,col;\n\tchar array[9][6];\n\n\tfor(int i=0;i < 9; i++){\n\t\tscanf(\"%s\",array[i]);\n\t}\n\n\tprintf(\"R\");\n\tchar current = 'R';\n\n\trow = 0,col = 0;\n\n\twhile(true){\n\t\tswitch(current){\n\t\tcase 'L':\n\t\t\tif(rangeCheck(row,col-1)&& array[row][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row+1,col) && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row-1,col) && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcurrent = 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(row,col+1) && array[row][col+1] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row-1,col+1) && array[row-1][col+1] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcurrent = 'U';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col+1;\n\t\t\t}else if(rangeCheck(row+1,col+1) && array[row+1][col+1] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcurrent = 'D';\n\t\t\t\trow = row+1;\n\t\t\t\tcol = col+1;\n\t\t\t}else{\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcurrent = 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tif(rangeCheck(row-2,col) && array[row-2][col] == '1'){\n\t\t\t\tprintf(\"U\");\n\t\t\t\trow = row - 2;\n\t\t\t}else if(rangeCheck(row-1,col-1) && array[row-1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row-1;\n\t\t\t\tcol = col-1;\n\t\t\t}else if(rangeCheck(row-1,col) && array[row-1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row-1;\n\t\t\t}else{\n\t\t\t\tprintf(\"D\");\n\t\t\t\tcurrent = 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(row+2,col) && array[row+2][col] == '1'){\n\t\t\t\tprintf(\"D\");\n\t\t\t\trow = row+2;\n\t\t\t}else if(rangeCheck(row+1,col) && array[row+1][col] == '1'){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tcurrent = 'R';\n\t\t\t\trow = row+1;\n\t\t\t}else if(rangeCheck(row+1,col-1) && array[row+1][col-1] == '1'){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tcurrent = 'L';\n\t\t\t\trow = row +1;\n\t\t\t\tcol = col -1;\n\t\t\t}else{\n\t\t\t\tprintf(\"U\");\n\t\t\t\tcurrent = 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(row == 0 && col == 0)break;\n\t}\n\n\tprintf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nenum eCOURSE{\n\tCOURSE_U,\n\tCOURSE_R,\n\tCOURSE_D,\n\tCOURSE_L,\n};\n\nstruct tDataSet{\n\tint *pX, *pY, *field;\n\teCOURSE* course;\n};\n\nconst int SIZE_X = 7;\nconst int SIZE_Y = 11;\n\nbool checkGoal( tDataSet& data ){\n\tif ( ( *data.pX == 0 && *data.pY == 1 && *data.course == COURSE_U && data.field[ 2*SIZE_X + 1 ] ) ||\n\t\t ( *data.pX == 1 && *data.pY == 1 && *data.course == COURSE_L && data.field[ 1*SIZE_X + 1 ] && !data.field[ 2*SIZE_X + 1 ] ) ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstring s;\n\tint field[ SIZE_Y * SIZE_X ];\n\n\tfor ( int i = 0; i < SIZE_Y * SIZE_X; ++i ){\n\t\tfield[ i ] = 0;\n\t}\n\n\tfor ( int i = 1; i < SIZE_Y - 1; ++i ){\n\t\tcin >> s;\n\t\tfor ( unsigned j = 0; j < s.size(); ++j ){\n\t\t\tfield[ i*7 + (j+1) ] = static_cast< int >( s[ j ] - '0' );\n\t\t}\n\t}\n\n\ts = \"\";\n\tint pX = 1, pY = 0;\n\teCOURSE course = COURSE_R;\n\n\ttDataSet data;\n\tdata.pX = &pX;\n\tdata.pY = &pY;\n\tdata.course = &course;\n\tdata.field = field;\n\n\tbool goal = false;\n\n\twhile ( !goal ){\n\t\tint defU = ( 2 * pY ) * SIZE_X + ( pX + 1 );\n\t\tint defR = ( 2 * pY + 1 ) * SIZE_X + pX;\n\t\tint defD = ( 2 * pY ) * SIZE_X + pX;\n\t\tint defL = ( 2 * ( pY - 1 ) + 1 ) * SIZE_X + pX;\n\n\t\tswitch ( course ){\n\t\t\tcase COURSE_U : \n\t\t\t\tif ( field[ defU ] ){\n\t\t\t\t\ts += 'U';\n\t\t\t\t\tgoal = checkGoal( data );\n\t\t\t\t\tif ( field[ defL ] ){\n\t\t\t\t\t\tcourse = COURSE_L;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t--pY;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcourse = COURSE_R;\n\t\t\t\t\t++pX;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase COURSE_R :\n\t\t\t\tif ( field[ defR ] ){\n\t\t\t\t\ts += 'R';\n\t\t\t\t\tgoal = checkGoal( data );\n\t\t\t\t\tif ( field[ defU ] ){\n\t\t\t\t\t\tcourse = COURSE_U;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++pX;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcourse = COURSE_D;\n\t\t\t\t\t++pY;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase COURSE_D :\n\t\t\t\tif ( field[ defD ] ){\n\t\t\t\t\ts += 'D';\n\t\t\t\t\tgoal = checkGoal( data );\n\t\t\t\t\tif ( field[ defR ] ){\n\t\t\t\t\t\tcourse = COURSE_R;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++pY;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcourse = COURSE_L;\n\t\t\t\t\t--pX;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase COURSE_L :\n\t\t\t\tif ( field[ defL ] ){\n\t\t\t\t\ts += 'L';\n\t\t\t\t\tgoal = checkGoal( data );\n\t\t\t\t\tif ( field[ defD ] ){\n\t\t\t\t\t\tcourse = COURSE_D;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t--pX;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcourse = COURSE_U;\n\t\t\t\t\t--pY;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\n\tcout << s << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF INT_MAX / 3\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef valarray<int> Array;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i];if(i==a.size()-1)cout<<endl;else cout<<\" \";}}\nint gcd(int a,int b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nint lcm(int a,int b){return a==0||b==0?0:a*b/gcd(a,b);}\n\nint a[35];\n\nvoid solve()\n{\n  string ans = \"\";\n  int dir = 0;\n  int now = 0;\n  do\n  {\n    int pre = (dir+2)%4;\n    for(int i=(pre+1)%4;i!=pre;++i%=4)\n    {\n      if(a[now]>>i&1)\n      {\n        dir = i;\n        break;\n      }\n    }\n    switch(dir)\n    {\n      case 0:\n        ans += \"R\";\n        now += 1;\n        break;\n      case 1:\n        ans += \"D\";\n        now += 5;\n        break;\n      case 2:\n        ans += \"L\";\n        now -= 1;\n        break;\n      case 3:\n        ans += \"U\";\n        now -= 5;\n        break;\n    }\n  }\n  while(now != 0);\n  cout << ans << \"\\n\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fill_n(a,35,0);\n  string s;\n  REP(i,9)\n  {\n    cin >> s;\n    if(i%2==0)\n    {\n      int c = i/2;\n      REP(j,4) if(s[j]=='1')\n      {\n        a[c*5+j] += 1;\n        a[c*5+j+1] += 4;\n      }\n    }\n    else\n    {\n      int c = (i-1)/2;\n      REP(j,5) if(s[j]=='1')\n      {\n        a[c*5+j] += 2;\n        a[(c+1)*5+j] += 8;\n      }\n    }\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=1;m.y=0;m.d=0;\n  int c=0;\n  cout << \"R\";\n  while(1){\n    c++;\n    mo=false;\n    \n    if(m.x==1&&m.y==1&&m.d==2) {\n      //cout << \"L\";\n      break;\n    }\n    if(m.x==0&&m.y==1&&f) {\n      //cout << \"U\";\n      break;\n    }\n    f=true;\n    \n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      if(m.y<5){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.x++;\n\t  cout << \"R\";\n\t  continue;\n\t}\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.x++;\n\t  m.y++;\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      m.y++;\n      cout << \"L\";\n      m.d=2;\n      continue;\n    }\n    \n    if(m.d==1){\n      if(m.y<5){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  cout <<\"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y<4){\n\tif(st[m.y*2+1][m.x-1]=='1') {\n\t  m.y++;\n\t  cout << \"D\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y<5){\n\tif(st[m.y*2][m.x-2]=='1') {\n\t  m.x--;\n\t  m.y++;\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      m.x--;\n      cout << \"U\";\n      m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      if(m.x>0){\n\tif(st[m.y*2-1][m.x-1]=='1') {\n\t  cout << \"D\";\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(m.x>1&&m.y>0){\n\tif(st[(m.y-1)*2][m.x-2]=='1') {\n\t  m.x--;\n\t  cout << \"L\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.x>0&&m.y>1){\n\tif(st[(m.y-1)*2-1][m.x-1]=='1') {\n\t  m.x--;\n\t  m.y--;\n\t  cout << \"U\";\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      m.y--;\n      cout << \"R\";\n      m.d=0;\n      continue;\n    }\n    if(m.d==3){\n\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x-1]=='1') {\n\t  cout << \"L\";\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(m.y>1){\n\tif(st[(m.y-1)*2-1][m.x]=='1') {\n\t  m.y--;\n\t  cout << \"U\" ;\n\t  mo=true;\n\t  continue;\n\t}\n      }\n      if(m.y>0){\n\tif(st[(m.y-1)*2][m.x]=='1') {\n\t  m.x++;\n\t  m.y--;\n\t  cout << \"R\";\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      m.x++;\n      cout << \"D\";\n      m.d=1;\n      continue;\n    }\n    //if(!mo)m.d=(m.d+2)%4;\n  }\n  \n  cout  << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            //cout << \"(\" << y << \",\" << x << \",\" << d << \")\" << endl;\n            if (map[y][x][d])\n                ;\n            else if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nstring vec=\"RULD\";\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4==2){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <utility>\n#include <complex>\n#include <stack>\n#include <climits>\n#include <set>\n#include <numeric>\n\nusing namespace std;\nbool points[5][5][4];\nint main()\n{\n    for (int i = 0; i < 9; ++i){\n        int y = i/2;\n        if (i%2 == 0){\n            for (int j = 0; j < 4; ++j){\n                int e;\n                scanf(\"%1d\", &e);\n                if (e)\n                    points[y][j][1] = points[y][j+1][3] = true;\n            }\n\t\t} else {\n            for (int j = 0; j < 5; ++j){\n                int e;\n                scanf(\"%1d\", &e);\n                if (e)\n                    points[y][j][2] = points[y+1][j][0] = true;\n            }\n        }\n    }\n \n    int x, y;\n    x = 1;\n    y = 0;\n    int dir = 1;\n    int dx[] = { 0, 1, 0, -1 };\n    int dy[] = { -1, 0, 1, 0 };\n    char* ds = \"URDL\";\n    putchar(ds[dir]);\n    while (!(x == 0 && y == 0)) {\n        if (points[y][x][(dir+3)%4])\n            dir = (dir+3)%4;\n        else if (points[y][x][dir])\n            ;\n        else if (points[y][x][(dir+1)%4])\n            dir = (dir+1)%4;\n        else\n            dir = (dir+2)%4;\n \n        x += dx[dir];\n        y += dy[dir];\n        putchar(ds[dir]);\n    }\n    putchar('\\n');\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\n\nvoid test(int x, int y, int j){\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\ttest(0, 0, 0);\n\t\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nstruct P{\n\tint x,y;\n\tP(int x,int y) : x(x), y(y){}; \n\tP(){}\n};\nbool operator < (const P &a,const P &b){\n\tif( a.x != b.x ) return a.x < b.x;\n\treturn a.y < b.y;\n}\n\n\nstring dd = \"RDLU\";\n\nP g[5][5][4];\n\nmap<P,string> memo;\nstring dfs(P p,int d,string s,string rs){\n\tcout << p.x << \" \" << p.y <<\" \" << d<< endl;\n\tif( memo.count(p) ){\n\t\tstring r = memo[p];\n\t\treverse(r.begin(),r.end());\n\t\tcout << s + r << endl;\n\t\texit(0);\n\t}\n\tmemo[p] = rs;\n\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( g[p.y][p.x][(i+d)%4].x != -1){\n\t\t\tdfs(g[p.y][p.x][(i+d)%4],(i+d)%4,s+dd[(i+d)%4],rs+dd[(i+d+2)%4]);\n\t\t\t\n\t\t}\n\t}\n\n}\nint main(){\n\tfor(int i = 0 ; i < 5 ; i++)\n\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\tfor(int k = 0 ; k < 4 ; k++)\n\t\t\t\tg[i][j][k] = P(-1,-1);\n\t\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\t//cout << s << endl;\n\t\tif( i % 2 ){\n\t\t\tint y = i / 2;\n\t\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\t\tif( s[j] == '1' ){\n\t\t\t\t\tcout << j << \" \" << y+1 << \"<\" << endl;\n\t\t\t\t\tg[y][j][1] = P(j,y+1);\n\t\t\t\t\tg[y+1][j][3] = P(j,y);\n\t\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tint y = i / 2;\n\t\t\tfor(int j = 0 ; j < 4 ; j++)\n\t\t\t\tif( s[j] == '1' ){\n\t\t\t\t\tg[y][j][0] = P(j+1,y);\n\t\t\t\t\tg[y][j+1][2] = P(j,y);\n\t\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\tcout << g[1][4][1].x << '-' << g[1][4][1].y << endl;\n\t\t\tdfs(P(0,0),0,\"\",\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\tchar yoko[10][10];\n\tchar tate[10][10];\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin>>yoko[i][j];\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tcin>>tate[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tif(cin.eof())\n\t\tbreak;\n\n\n\t// 0,1,2,3ÅEAºA¶Aã\n\tint angle=0;\n\tint px,py;\n\tpx=py=0;\n\twhile(1){\n\t\tif(angle==0){\n\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tpx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ãÖ\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx--;\n\t\t\t\t\tangle=2;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// º\n\t\telse if(angle==1){\n\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\tcout<<\"D\";\n\t\t\t\tpy++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tpx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\t// ãÖ\n\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx++;\n\t\t\t\t\tangle=0;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\tcout<<\"U\";\n\t\t\t\tpy--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(px==0&&py==0)\n\t\t\tbreak;\n\t\t}\n\t\tcout<<endl;\n\n\t\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nint pack(int x, int y) {\n    return x*5+y;\n}\n\nPoint unpack(int p) {\n    return make_pair(p/5, p%5);\n}\n\nbool can(const vector<vector<int> > &v, int x1, int y1, int x2, int y2) {\n    if(x1 < 0 || y1 < 0 || x1 >= 5 || y1 >= 5) return false;\n    if(x2 < 0 || y2 < 0 || x2 >= 5 || y2 >= 5) return false;\n    return v[pack(x1,y1)][pack(x2,y2)];\n}\n\nint main() {\n    vector<vector<int> > v(30, vector<int>(30, 0));\n    for(int i = 0; i < 9; ++i) {\n        string str;\n        cin >> str;\n        for(int j = 0; j < str.size(); ++j) {\n            if(i % 2 == 0) v[pack(j, i/2)][pack(j+1, i/2)] = v[pack(j+1,i/2)][pack(j,i/2)] = str[j]-'0';\n            else v[pack(j, i/2)][pack(j, i/2+1)] = v[pack(j,i/2+1)][pack(j,i/2)] = str[j]-'0';\n        }\n    }\n\n    const char *dirchar = \"RDLU\";\n    const int delta[][2] = {\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\n    };\n    int x = 0, y = 0;\n    int dir = 0;\n    while(true) {\n        cout << dirchar[dir];\n        x += delta[dir][0];\n        y += delta[dir][1];\n        if(x == 0 && y == 0) break;\n\n        int left = (dir+3)%4;\n        int right = (dir+1)%4;\n        if(can(v, x,y, x+delta[left][0],y+delta[left][1])) {\n            dir = left;\n        }\n        else if(can(v, x,y, x+delta[dir][0],y+delta[dir][1])) {\n            dir = dir;\n        }\n        else if(can(v, x,y, x+delta[right][0],y+delta[right][1])) {\n            dir = right;\n        }\n        else dir = (dir+2)%4;\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n  static bool wall[6][6][4];\n  const int dx[4] = { 1, 0, -1, 0 };\n  const int dy[4] = { 0, 1, 0, -1 };\n  REP(i,6) REP(j,6) REP(k,4) {\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n      wall[i][j][k] = 0;\n    }\n    else {\n      wall[i][j][k] = 1;\n    }\n  }\n\n  string s;\n  for(int i = 0; i < 4; i++) {\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n      wall[i][j + 1][1] = (s[j] == '1');\n      wall[i + 1][j + 1][3] = (s[j] == '1');\n    }\n    getline(cin, s);\n    for(int j = 0; j < 5; j++) {\n      wall[i + 1][j][0] = (s[j] == '1');\n      wall[i + 1][j + 1][2] = (s[j] == '1');\n    }\n  }\n  getline(cin, s);\n  for(int j = 0; j < 4; j++) {\n    wall[4][j + 1][1] = (s[j] == '1');\n    wall[5][j + 1][3] = (s[j] == '1');\n  }\n\n  string icon = \"RDLU\";\n#if 0\n  REP(i,6) REP(j,6) {\n    cerr << \"(\" << i << \",\" << j << \")\";\n    REP(k,4) {\n      if(wall[i][j][k]) cerr << icon[k];\n    }\n    cerr << endl;\n  }\n#endif\n\n  int X = 1, Y = 0, dir = 0;\n  string ans = \"R\";\n  do {\n#if 1\n    cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n    if(wall[Y][X][dir] == 0) {\n      Y += dy[dir];\n      X += dx[dir];\n      if(wall[Y][X][(dir + 1) % 4] == 0) {\n        dir = (dir + 1) % 4;\n        X += dx[dir];\n        Y += dy[dir];\n        if(wall[Y][X][(dir + 1) % 4] == 0) {\n          dir = (dir + 1) % 4;\n          X += dx[dir];\n          Y += dy[dir];\n          ans.push_back(icon[dir]);\n        }\n        else {\n          ans.push_back(icon[dir]);\n        }\n      }\n      else {\n        ans.push_back(icon[dir]);\n      }\n    }\n    else {\n      dir = (dir - 1 + 4) % 4;\n      ans.push_back(icon[dir]);\n    }\n  } while(!((X == 1 && Y == 0)));\n  ans = ans.substr(0, (int)ans.size() - 1);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tstd::cout << 'R';\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && (crd[1] == 0 || crd[1] == 1))\n\t\t{\n\t\t\t//std::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define N 5\nint main(){\n  bool G[N][N][4];\n  char ch;\n  rep(i, N) rep(j, N) rep(k, 4) G[i][j][k] = false;\n  rep(i, 2*N-1){\n    if (i%2){\n      rep(j, N) {\n\tcin >> ch;\n\tif (ch == '1') G[(i+1)/2-1][j][3] = G[(i+1)/2][j][1] = true;\n      }\n    } else {\n      rep(j, N-1) {\n\tcin >> ch;\n\tif (ch == '1') G[i/2][j][0] = G[i/2][j+1][2] = true;\n      }\n    }\n  }\n  \n  string D = \"RULD\";\n  int di[4] = {0, -1, 0, 1};\n  int dj[4] = {1, 0, -1, 0};\n  int pi = 0, pj = 0, dir = 0;\n  \n  while(1){\n    if ( G[pi][pj][(dir+1)%4] ){\n      dir = (dir+1)%4;\n      pi += di[dir];\n      pj += dj[dir];\n      cout << D[dir];\n    } else if ( G[pi][pj][dir] ){\n      pi += di[dir];\n      pj += dj[dir];\n      cout << D[dir];\n    } else dir = (dir+3)%4;\n    if ( pi == 0 && pj == 0 ) break;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\nusing namespace std;\n\nint main(){\n    char ma[11][11];\n    memset(ma,'0',sizeof(ma));\n    for(int i=1;i<10;i++){\n        if(i%2==1)\n            for(int j=2;j<9;j+=2)\n                cin>>ma[i][j];\n        else\n            for(int j=1;j<10;j+=2)\n                cin>>ma[i][j];\n    }\n    int x=1,y=1,dir=0;\n    int mv[4][2]={{2,0},{0,2},{-2,0},{0,-2}};\n    int ts[4][8]={{1,-1,1,0,0,-1,0,1},{1,1,0,1,1,0,-1,0},{-1,1,-1,0,0,1,0,-1},{-1,-1,0,-1,-1,0,1,0}};\n    string str[4]={\"R\",\"D\",\"L\",\"U\"};\n    string path=\"\";\n    int ch=0;\n    for(int k=0;k<40;k++){\n        int wen=1;\n        while(ma[y+ts[dir][3]][x+ts[dir][2]]=='1'){\n            y+=mv[dir][1];\n            x+=mv[dir][0];\n            wen=0;\n            path+=str[dir];\n            wen++;\n           // cout<<x<<\" \"<<y<<\"    \"<<dir<<endl;\n            if(ma[y+ts[dir][5]][x+ts[dir][4]]=='1'){\n               // cout<<\"dir: \"<<dir<<\"    \"<<x<<\" \"<<y<<\"   \"<<x+ts[dir][4]<<\"    \"<<y+ts[dir][5]<<\"     \"<<ma[y+ts[dir][5]][x+ts[dir][4]]<<endl;\n                break;\n            }\n        }\n        if(x==1&&y==1)\n            break;\n       // cout<<x<<\" \"<<y<<\"    \"<<dir<<endl;\n        if(ma[y+ts[dir][5]][x+ts[dir][4]]=='1')dir=(dir+3)%4;\n        else do{\n            dir=(dir+1)%4;\n        }while((y+ts[dir][3]>10||y+ts[dir][3]<0||x+ts[dir][2]>10||x+ts[dir][2]<0)||ma[y+ts[dir][1]][x+ts[dir][0]]=='1');\n        \n    }\n    cout<<path<<endl;\n}\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false;\n  man m;\n  m.x=0;m.y=0;m.d=0;\n  int c=0;\n  while(1){\n    if(m.x==0&&m.y==0&&f) break;\n    f=true;\n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(st[m.y*2][m.x]=='1') {\n\tm.x++;\n\tcout << \"R\" ;\n\t//continue;\n      }\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      \n      if(st[m.y*2+1][m.x]=='1') {\n\tm.d=1;\n\tcontinue;\n      }\n      //m.d=2;\n      continue;\n    }\n    if(m.d==1){\n      \n      if(st[m.y*2+1][m.x]=='1') {\n\tm.y++;\n\tcout << \"D\" ;\n\t//continue;\n      }\n      if(m.x<4){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2][m.x-1]=='1') {\n\tm.d=2;\n\tcontinue;\n      }\n      //m.d=3;\n      continue;\n    }\n    if(m.d==2){\n      \n      if(st[m.y*2][m.x-1]=='1') {\n\tm.x--;\n\tcout << \"L\" ;\n\t//continue;\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2-1][m.x]=='1') {\n\tm.d=1;\n\tcontinue;\n      }\n      //m.d=0;\n      continue;\n    }\n    if(m.d==3){\n      \n      if(st[m.y*2-1][m.x]=='1') {\n\tm.y--;\n\tcout << \"U\" ;\n\t//continue;\n      }\n      if(m.x>0){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2][m.x]=='1') {\n\tm.d=0;\n\tcontinue;\n      }\n      //m.d=1;\n      continue;\n    }\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\n#include<string>\n#include<algorithm>\n#define UP_DIRECTION 3\n#define RIGHT_DIRECTION 2\n#define DOWN_DIRECTION 1\n#define LEFT_DIRECTION 0\nusing namespace std;\nint dy[]={0,1,0,-1},dx[]={-1,0,1,0};\nint main(){\n    bitset<4>Square[5][5];\n    string Wall[9];\n    char For_Output[]=\"LDRU\";\n    for(int i=0;i<9;i++)cin>>Wall[i];\n\n    for(int i=0;i<9;i+=2){\n        Wall[i]=\"0\"+Wall[i]+\"0\";\n        for(int j=0;j<5;j++){\n            Square[i/2][j][LEFT_DIRECTION]=(Wall[i][j]-'0');\n            Square[i/2][j][RIGHT_DIRECTION]=(Wall[i][j+1]-'0');\n        }\n    }\n\n    for(int i=1;i<9;i+=2){\n        for(int j=0;j<5;j++){\n            Square[i/2][j][DOWN_DIRECTION]=(Wall[i][j]-'0');\n            Square[i/2+1][j][UP_DIRECTION]=(Wall[i][j]-'0');\n        }\n    }\n    int Direction=RIGHT_DIRECTION;\n    int y=0,x=0;\n\n    do{\n        int R=Direction-1;\n        int L=Direction+1;\n        int B=Direction-2;\n        if(R<0)R=3;\n        if(B<0)B+=4;\n        L%=4;\n        if(Square[y][x][L])\n            Direction=L;\n\n        else if(Square[y][x][Direction]);\n        else if(Square[y][x][R])\n            Direction=R;\n        else Direction=B;\n\n        y+=dy[Direction];\n        x+=dx[Direction];\n        cout<<For_Output[Direction];\n    }while(y!=0||x!=0);\n    cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst char dir[] = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            int del = (d + 3) % 4;\n            for (int i = 0; i < 4; i++) \n                if (map[y][x][(del + i) % 4]) {\n                    d = (del + i) % 4;\n                    break;\n                }\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar f[6][6],s[6],i,j,a,y,x,p,b;\nint main()\n{\n\tfor(;i<9;++i,b=!b){\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+b;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<1+b;\n\t\t\tf[i/2+b][j+!b]|=a<<3-b*3;\n\t\t}\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y|x|f[0][0]==6&p==3);\n\treturn!puts(\"\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\nvector<string> mp;\nchar c[]={'U','R','D','L'};\nint dx[]={0,1,0,-1},\n\tdy[]={-1,0,1,0},\n\tfx[]={1,0,-1,0},\n\tfy[]={0,1,0,-1};\nvoid func(int y,int x,int dir){\n\tcout<<c[dir];\n\tif((y==1&&x==0&&dir==0)||(y==1&&x==1&&dir==3)){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t//ツ前\n\tif(mp[dy[dir]+2*y][dx[dir]+2*x]=='1'){\n\t\tfunc(y,x,(dir+3)%4);\n\t\treturn;\n\t}\n\tif(mp[y*2+dy[(dir+1)%4]+2*dy[dir]][x*2+dx[(dir+1)%4]+2*dx[dir]]=='1'){\n\t\tfunc(y+dy[dir],x+dx[dir],dir);\n\t\treturn ;\n\t}\n\t//\n\tif(mp[2*y+dy[dir]+dy[(dir+1)%4]*2][2*x+dx[dir]+dx[(dir+1)%4]*2]=='1'){\n\t\tint q=(dir+1)%4;\n\t\tfunc(y+dy[dir]+dy[q],x+dx[dir]+dx[q],q);\n\t\treturn;\n\t}\n\tfunc(y+fy[dir],x+fx[dir],(dir+2)%4);\n\treturn;\n}\nint main(){\n\tstring pre;\n\tmp.push_back(\" 0 0 0 0 0 \");\n\tfor(int i=0;i<9;i++){\n\t\tstring s;\n\t\tif(i%2==0){\n\t\t\ts=\"0 \";\n\t\t\tcin>>pre;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\ts+=pre[j];\n\t\t\t\ts+=' ';\n\t\t\t}\n\t\t\ts+='0';\n\t\t\tmp.push_back(s);\n\t\t}\n\t\telse{\n\t\t\tcin>>pre;\n\t\t\ts+=' ';\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\ts+=pre[j];\n\t\t\t\ts+=' ';\n\t\t\t}\n\t\t\ts+=' ';\n\t\t\tmp.push_back(s);\n\t\t}\n\t}\n\tmp.push_back(\" 0 0 0 0 0 \");\n\tfunc(0,1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\nvector<string> mp;\nchar c[]={'U','R','D','L'};\nint dx[]={0,1,0,-1},\n\tdy[]={-1,0,1,0},\n\tfx[]={1,0,-1,0},\n\tfy[]={0,1,0,-1};\nvoid func(int y,int x,int dir){\n\tcout<<c[dir];\n\tif(y==1&&(x==0||x==1)){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t//ツ前\n\tif(mp[dy[dir]+2*y][dx[dir]+2*x]=='1'){\n\t\tfunc(y,x,(dir+3)%4);\n\t\treturn;\n\t}\n\tif(mp[y*2+dy[(dir+1)%4]+2*dy[dir]][x*2+dx[(dir+1)%4]+2*dx[dir]]=='1'){\n\t\tfunc(y+dy[dir],x+dx[dir],dir);\n\t\treturn ;\n\t}\n\t//\n\tif(mp[2*y+dy[dir]+dy[(dir+1)%4]*2][2*x+dx[dir]+dx[(dir+1)%4]*2]=='1'){\n\t\tint q=(dir+1)%4;\n\t\tfunc(y+dy[dir]+dy[q],x+dx[dir]+dx[q],q);\n\t\treturn;\n\t}\n\tfunc(y+fy[dir],x+fx[dir],(dir+2)%4);\n\treturn;\n}\nint main(){\n\tstring pre;\n\tmp.push_back(\" 0 0 0 0 0 \");\n\tfor(int i=0;i<9;i++){\n\t\tstring s;\n\t\tif(i%2==0){\n\t\t\ts=\"0 \";\n\t\t\tcin>>pre;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\ts+=pre[j];\n\t\t\t\ts+=' ';\n\t\t\t}\n\t\t\ts+='0';\n\t\t\tmp.push_back(s);\n\t\t}\n\t\telse{\n\t\t\tcin>>pre;\n\t\t\ts+=' ';\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\ts+=pre[j];\n\t\t\t\ts+=' ';\n\t\t\t}\n\t\t\ts+=' ';\n\t\t\tmp.push_back(s);\n\t\t}\n\t}\n\tmp.push_back(\" 0 0 0 0 0 \");\n\tfunc(0,1,1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n\n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n            \tcheckTable[i][k][p] = 0;\n            }\n        }\n    }\n\n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n\n    printf(\"R\");\n    char current = 'R';\n\n    checkTable[0][0][1] = 1;\n\n    row = 0,col = 0;\n\n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row,col-1) == true &&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col) == true &&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else if(rangeCheck(row+1,col) == true &&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else{\n                printf(\"R\");\n                checkTable[row][col][1] = 1;\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row,col+1) == true &&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1) == true&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else if(rangeCheck(row-1,col+1) == true &&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                checkTable[row][col][0] = 1;\n                current = 'L';\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-2,col) == true&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col)== true &&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else if(rangeCheck(row-1,col-1) == true &&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else{\n               printf(\"D\");\n               checkTable[row][col][3] = 1;\n               current = 'D';\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+2,col) == true&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col-1) == true&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else if(rangeCheck(row+1,col) == true&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else{\n            \tprintf(\"U\");\n            \tcheckTable[row][col][2] = 1;\n            \tcurrent = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n\n   printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG 0\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[15][15];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U', 'R', 'D', 'L' };\n\nstring res;\nvoid touch_wall (int row, int col, int dir, int hand )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 0;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n\tstring s = \"\";\n\tfor (int i = 1;getline (cin, s ); i++  ){\n//\t\tif (getline (cin, s ) )\n//\t\tgetline (cin, s );\n//\t\tcin >> s;\n//\t\tif (s.empty() ) break;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j+1] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j+1] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tif (j == 0 ){\n\t\t\t\t\t\tgrid[i/2][j+1] |= 1<<LEFT;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgrid[i/2][j+1] |= 1<<LEFT;\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<RIGHT;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n\n#if DEBUG2\n\trep (i, 15 ){\n\t\trep (j, 15 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n#endif\n\tint row = 0, col = 1, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tres = \"\";\n\tdo{\n\t\ttouch_wall (row, col, dir, hand );\n\t\tif (((1<<hand) & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった、なくなった方向に回転\n\t\t\tdir = hand;\n\t\t}else{\n\t\t\twhile (((1<<dir) & grid[row][col] ) != 0 ){ // 右手の壁があったとしても前に進めない\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand );\n\t\t\t} // end while \n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t}while (!(row == 0 && col == 0 ) ); // end while\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\n\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x==0 && y==0 && (((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-10;\n\nint main() {\n\tstring s[16], ans(\"R\");\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tint x = 0, y = 0;\n\tint d = 0; // 0:right, 1:down, 2:left, 3:up\n\tbool flag = false;\n\twhile(1){\n\t\tif(d == 0){\n\t\t\tif(y >= 2 && s[y - 1][x + 1] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\tx += 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t}\n\t\t\t\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'L';\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 1){\n\t\t\tif(s[y + 1][x] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\ty += 1;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y + 2][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 2;\n\t\t\t}\n\t\t\telse if(s[y + 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'U';\n\t\t\t\td = 3;\n\t\t\t}\n\t\t}\n\t\telse if(d == 2){\n\t\t\tif(s[y + 1][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(s[y][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t}\n\t\telse if(d == 3){\n\t\t\tif(s[y - 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\ty -= 1;\n\t\t\t\tx -= 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(y >= 3 && s[y - 2][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 2;\n\t\t\t}\n\t\t\telse if(s[y - 1][x] == '1'){\n\t\t\t\ty -= 1;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'D';\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\t/*if(x == 1 && y == 8 && flag)\n\t\t\tbreak;\n\t\tif(x == 1 && y == 8){\n\t\t\tflag = true;\n\t\t\t//break;\n\t\t}*/\n\t\tif(x == 0 && y == 0)\n\t\t\tbreak;\n\t}\n\t/*cout << s[8][3] << endl;\n\tcout << d << endl;*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n \nusing namespace std;\n \nchar d[10][6];\n \nvoid solve(int y,int x,int way){\n  if(y==0&&x==0){\n    cout<<\"L\";\n    return;\n  }\n  if(y==1&&x==0&&way==2){\n    cout<<\"U\";\n    return;\n  }\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<5&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x]=='1')solve(y,x,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y][x]=='1')solve(y,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x]=='1')solve(y,x,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y][x]=='1')solve(y,x,2);\n  }\n}\n \nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[1000];\nint len;\nint fie[1001][1001];\nint flag[1001][1001][4];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==2)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint g[6][6][4]={};//top,bottom,left,right\n\nint main(void) {\n  int i,j;\n  rep(i,9){\n    string s;\n    cin>>s;\n    if(i%2){\n      rep(j,5){\n        g[i/2+1][j][3] = s[j] - '0';\n        g[i/2+1][1+j][2] = g[i/2+1][j][3];\n      }\n    }else{\n      rep(j,4){\n        g[i/2+1][1+j][0] = s[j] - '0';\n        g[i/2][1+j][1] = g[i/2+1][1+j][0];\n      }\n    }\n  }\n\n  char s[5] = {\"LRDU\"};\n  int dx[4] = {0,0,1,-1};\n  int dy[4] = {-1,1,0,0};\n\n  int x=0,y=1,z=1;//(x,y)右手がz\n\n  while(x+y){\n    if(g[x][y][z]){\n        cout<<s[z];\n        if((z==1 && g[x][y][1] && g[x][y][3]) || (z==0 && g[x][y][0] && g[x][y][2]) ||\n          (z==2 && g[x][y][2] && g[x][y][1]) || (z==3 && g[x][y][3] && g[x][y][0])){\n            switch(z){\n              case 0: z=2;break;\n              case 1: z=3;break;\n              case 2: z=1;break;\n              case 3: z=0;break;\n            }\n        }else{\n          x = x + dx[z];\n          y = y + dy[z];\n        }\n    }else{\n      switch(z){\n        case 0: z=3;x--;break;\n        case 1: z=2;x++;break;\n        case 2: z=0;y--;break;\n        case 3: z=1;y++;break;\n      }\n    }\n  }\n    cout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can[10][10][4];\n\n// RDLU\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstring answer;\nint dfs(int y,int x,int py,int px,int d){\n\n\tif( py != -1 ){\n\t\tif( y == py ){\n\t\t\tif( x - px > 0 ) answer += \"R\"; else answer += \"L\";\n\t\t}else{\n\t\t\tif( y - py > 0 ) answer += \"D\"; else answer += \"U\";\n\t\t}\n\t}\n\tif( py != -1 && x == 0 && y == 0 ) return 0;\n\t//cout << y << \" \" << x << \" \" << can[y][x][0] << \" \" << can[y][x][1] << \" \" << can[y][x][2] << \" \" << can[y][x][3] << \" \" << endl;\n\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( can[y][x][(i+d)%4]  ){\n\t\t\tint tx = x + dx[(i+d)%4];\n\t\t\tint ty = y + dy[(i+d)%4];\n\t\t\tif( tx == px && ty == py ) continue;\n\t\t\tcan[y][x][(i+d)%4] = 0;\n\t\t\tdfs(ty,tx,y,x,(i+d)%4);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( can[y][x][(i+d)%4]  ){\n\t\t\tcan[y][x][(i+d)%4] = 0;\n\t\t\tint tx = x + dx[(i+d)%4];\n\t\t\tint ty = y + dy[(i+d)%4];\n\t\t\t//if( tx == px && ty == py ) continue;\n\t\t\tdfs(ty,tx,y,x,(i+d)%4);\n\t\t\treturn 0;\n\t\t}\n\t}\n}// RDLU\nint main(){\n\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tif( i % 2 ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][1] = 1;\n\t\t\t\t\tcan[i/2+1][j][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2][j][0] = 1; \n\t\t\t\t\tcan[i/2][j+1][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0,0,-1,-1,0);\n\tcout << answer << endl;\n\tchar c;\n\tif( (cin >> c) ) while(1){}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ROW_BLOCK 4\n#define COL_BLOCK 4\n#define ROW_NUM (ROW_BLOCK + 2) * 2 - 1\n#define COL_NUM (COL_BLOCK + 2) * 2 - 1\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n\nconst char command[5] = \"URDL\";\nconst int dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};\nconst int gy = 1, gx = 1;\n\nint main(void){\n\tint i, j, stage[ROW_NUM][COL_NUM];\n\tmemset(stage,0,sizeof(stage));\n\tfor(i = 1;i < ROW_NUM - 1;i++){\n\t\tchar str[ROW_BLOCK + 2];\n\t\tscanf(\"%s\",str);\n\t\tfor(j = 1 + i % 2;j < COL_NUM - 1;j+=2){\n\t\t\tstage[i][j] = str[(j - 1) / 2] - '0';\n\t\t}\n\t}\n\tint nd = RIGHT, nx = 1, ny = 1, add = 1;\n\tdo{\n\t\tif(stage[ny + dy[nd]][nx + dx[nd]] == 0 && stage[ny + dy[(nd + 3) % 4]][nx + dx[(nd + 3) % 4]] == 0){ // 今向いている方向に壁がなければ\n\t\t\tnd = (nd + 1) % 4;\n\t\t\tny += dy[nd] * 2;\n\t\t\tnx += dx[nd] * 2;\n\t\t}else if(stage[ny + dy[(nd + 3) % 4]][nx + dx[(nd + 3) % 4]] == 1){\n\t\t\tnd = (nd + 3) % 4;\n\t\t\tny += dy[nd] * 2;\n\t\t\tnx += dx[nd] * 2;\n\t\t}else{\n\t\t\tny += dy[nd] * 2;\n\t\t\tnx += dx[nd] * 2;\n\t\t}\n\n\t\tprintf(\"%c\",command[nd]);\n/*\t\tfor(i = 0;i < ROW_NUM;i++){\n\t\t\tfor(j = 0;j < COL_NUM;j++){\n\t\t\t\tif(ny == i && nx == j){\n\t\t\t\t\tprintf(\"# \");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%d \",stage[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}while(!((nx == gx) && (ny == gy)));\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(count!=0\n\t\t\t\t&&x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n\tint field[6][6][4] = {0},p[3];\n\tint x,y;\n\tfor(int i=0; i<9; i++){\n\t\tif(i%2 == 0){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\tint n;\n\t\t\t\tscanf(\"%1d\",&n);\n\t\t\t\tfield[j+1][i/2][2] = n;\n\t\t\t\tfield[j+1][i/2+1][0] = n;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\tint n;\n\t\t\t\tscanf(\"%1d\",&n);\n\t\t\t\tfield[j][i/2+1][1] = n;\n\t\t\t\tfield[j+1][i/2+1][3] = n;\n\t\t\t}\n\t\t}\n\t}\n\tp[0] = 1;p[1] = 0; p[2] = 1;\n\tfor(;;){\n\t\tif(p[2] == 0){\n\t\t\tif(field[p[0]][p[1]][1] == 1){\n\t\t\t\tcout<<\"U\";\n\t\t\t\tif(field[p[0]][p[1]][0] == 1){p[2] = 3;}\n\t\t\t\telse{p[1]--;}\n\t\t\t}\n\t\t\telse if(field[p[0]][p[1]][1] == 0){p[2] = 1;p[0]++;}\n\t\t}\n\t\telse if(p[2] == 1){\n\t\t\tif(field[p[0]][p[1]][2] == 1){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tif(field[p[0]][p[1]][1] == 1){p[2] = 0;}\n\t\t\t\telse{p[0]++;}\n\t\t\t}\n\t\t\telse if(field[p[0]][p[1]][2] == 0){p[2] = 2;p[1]++;}\n\t\t}\n\t\telse if(p[2] == 2){\n\t\t\tif(field[p[0]][p[1]][3] == 1){\n\t\t\t\tcout<<\"D\";\n\t\t\t\tif(field[p[0]][p[1]][2] == 1){p[2] = 1;}\n\t\t\t\telse{p[1]++;}\n\t\t\t}\n\t\t\telse if(field[p[0]][p[1]][3] == 0){p[2] = 3;p[0]--;}\n\t\t}\n\t\telse if(p[2] == 3){\n\t\t\tif(field[p[0]][p[1]][0] == 1){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tif(field[p[0]][p[1]][3] == 1){p[2] = 2;}\n\t\t\t\telse{p[0]--;}\n\t\t\t}\n\t\t\telse if(field[p[0]][p[1]][0] == 0){p[2] = 0;p[1]--;}\n\t\t}\n\t\tif(p[0] == 1 && p[1] == 0){cout <<endl;break;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nint main(){\n\tstring str, ans = \"\";\n\tchar h[7][6]= {0}; // setinel\n\tchar v[6][7] = {0};\n\tchar dir = 'n';\n\tint mx = 1;\n\tint my = 1;\n\n\tint i = 1;\n\tint j = 1;\n\n\twhile(cin >> str){\n\t\tif(str.size() == 4){\n\t\t\th[i][1] = str[0] - '0';\n\t\t\th[i][2] = str[1] - '0';\n\t\t\th[i][3] = str[2] - '0';\n\t\t\th[i][4] = str[3] - '0';\n\t\t\ti++;\n\t\t}else if(str.size() == 5){\n\t\t\tv[j][1] = str[0] - '0';\n\t\t\tv[j][2] = str[1] - '0';\n\t\t\tv[j][3] = str[2] - '0';\n\t\t\tv[j][4] = str[3] - '0';\n\t\t\tv[j][5] = str[4] - '0';\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (v[my-1][mx] == 1 && dir != 'D' && (dir=='R' || h[my][mx-1] == 0)) {\n\t\t\tdir = 'U';\n\t\t\tmy--;\n\t\t}else if (h[my][mx] == 1 && dir != 'L' && (dir=='D' || v[my-1][mx] == 0)) {\n\t\t\tdir = 'R';\n\t\t\tmx++;\n\t\t}else if (v[my][mx] == 1 && dir != 'U' && (dir=='L' || h[my][mx] == 0)) {\n\t\t\tdir = 'D';\n\t\t\tmy++;\n\t\t}else if (h[my][mx-1] == 1 && dir != 'R' && (dir=='U' || v[my][mx] == 0)) {\n\t\t\tdir = 'L';\n\t\t\tmx--;\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  rep(i, 5) {\n    char x;\n    rep(j, 4) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n        G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n      }\n    }\n\n    if(i == 4) break;\n\n    rep(j, 5) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n        G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n      }\n    }\n  }\n\n  string const OP = \"LURD\";\n\n  int y = 0, x = 0, d = 2;\n\n  int k = 0;\n  while(y != 0 || x != 0 || d != 0) {\n    bool ok = 0; int le = -1, ri = -1;\n    for(auto && e: G[y * 5 + x]) {\n      if(e.second == (d + 3) % 4) le = e.second;\n      if(e.second == (d + 1) % 4) ri = e.second;\n      if(e.second != d) continue;\n      ok = 1;\n      y = e.first / 5, x = e.first % 5;\n      cout << OP[d];\n      break;\n    }\n    if(!ok) {\n      if(le != -1) d = le;\n      else if(ri != -1) d = ri;\n      else (d += 1) %= 4;\n    }\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nconst int N = 5,M = 9;\nint edge [25] [25];\nconst int dx [] = {0,1,0,-1};\nconst int dy [] = {-1,0,1,0};\nstring d = \"URDL\";\n\nbool in_range(int y,int x)\n{\n\treturn y >= 0 && y < N && x >= 0 && x < N;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tFOR(i,0,M){\n\t\tstring s;\n\t\tcin >> s;\n\t\tFOR(j,0,s.size()) if(s [j] == '1'){\n\t\t\tif(i % 2 == 0){\n\t\t\t\tedge [(i / 2) * N + j] [(i / 2) * N + j + 1] = true;\n\t\t\t\tedge [(i / 2) * N + j + 1] [(i / 2) * N + j] = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tedge [(i / 2) * N + j] [(i / 2 + 1) * N + j] = true;\n\t\t\t\tedge [(i / 2 + 1) * N + j] [(i / 2) * N + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstring ans(1,'R');\n\tint y = 0,x = 1,dir = 1;\n\twhile(y || x){\n\t\tfor(int i = 3;i <= 6;i++){\n\t\t\tint ny = y + dy [(dir + i) % 4],nx = x + dx [(dir + i) % 4];\n\t\t\tif(in_range(ny,nx) == false || edge [y * N + x] [ny * N + nx] == false) continue;\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t\tans += d [(dir + i) % 4];\n\t\t\t(dir += i) %= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>//////////AOJ0037\n                               int\ni,j,w[5][5];char*p,b[1<<7];;   int\nF(int(v)){scanf(\"%s\",b);for(   p=b\n;*p;++p                 ){w[   p-b\n+1-v][j   +v]|=((w[p-   b][j   ]|=\n(*p==49   )<<3-v)&8>>   v)>>   2;}\nreturn(   j+=v          );/*   */}\nmain(){   for(   ;4-F   (0);   F(1\n));for(   p=b,   i=j=   (*b=   3)^\n3;i+=\"\"   \"BA\"          \"BC\"   [*b\n]-66,j=   (*b)[\"ABCB\"]-66+j,   *++\np=\"ULDR   \"[*b],i+j;)for((*    b+=\n1)&=~4;                        !(w\n[i][j]&(1<<*b));(*b+=3)&=3);return\n!puts(b+1);}/*May2018,tw:@siikya*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string dir = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        do {\n            //cout << \"(\" << y << \",\" << x << \",\" << d << \")\" << endl;\n            if (map[y][x][d])\n                ;\n            else if (map[y][x][(d + 1) % 4]) \n                d = (d + 1) % 4;\n            else if (map[y][x][(d + 3) % 4]) \n                d = (d + 3) % 4;\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[100];\nint len;\nint fie[101][101];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tif(n>9){\n\t\tprintf(\"0\\n\")\n\t\treturn 0;\n\t}\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else dir=(dir+1)%4;\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint main(){\n\tchar d[] = {'R','D','L','U'};\n\tbool w[5][9]={{false}};\n\trep(i,9){\n\t\tint lim = 4+i%2;\n\t\trep(j,lim){\n\t\t\tchar t;\n\t\t\tcin >> t;\n\t\t\tw[j][i] = (t == '1');\n\t\t}\n\t}\n\tint x,y,s;\n\tx = y = s = 0;\n\twhile(true){\n\t\tint nx,ny;\n\t\ts--;\n\t\ts = (s+4) % 4;\n\t\trep(i,4){\n\t\t\tnx = x + dx[s];\n\t\t\tny = y + dy[s];\n\t\t\tif(nx >= 0 && nx <= 4 && ny >= 0 && ny <= 4){\n\t\t\t\tif(s%2==0 && w[min(x,nx)][y*2])break;\n\t\t\t\tif(s%2==1 && w[x][min(y,ny) * 2 + 1])break;\n\t\t\t}\n\t\t\ts++;\n\t\t\ts %= 4;\n\t\t}\n\t\ty = ny;\n\t\tx = nx;\n\t\tcout << d[s];\n\t\tif((x == 0 && y == 0))break;\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n) \n/*\nconst int dx[4] = {-1,0,0,0};\nconst int dy[4] = {0,-1,0,0};\nconst int dx2[4] = {-1,0,1,0};\nconst int dy2[4] = {0,1,0,-1};\n*/\nstatic const int dx[4] = {1,0,-1,0};\nstatic const int dy[4] = {0,1,0,-1};\nint main(void){\n  int d = 0;\n  /*\n  int a[5][4];\n  int b[4][5];\n  */\n  int m[9][9];\n  int x=0,y=0;\n  string tmp;\n  /*\n  for(int i=0; i<4; i++){\n    for(int j=0; j<4; j++){\n      c = getchar();\n      a[i][j] = c - '0';\n    }\n    getchar();\n    for(int j=0; j<5; j++){\n      c = getchar();\n      b[i][j] = c - '0';\n    }\n    getchar();\n  }\n  for(int j=0; j<4; j++){\n    c = getchar();\n    a[4][j] = c - '0';\n  }\n  */\n  for(int i=0; i<9; i++){\n    cin>>tmp;\n    int jbegin;\n    if(i%2){\n      jbegin=0;\n    }else{\n      jbegin=1;\n    }\n    for(int j=jbegin,k=0; j<9; j+=2,k++){\n      m[i][j] = tmp[k];\n    }\n  }\n  for(int time=0; time>-1; time++){\n    for(int r=-1; r<3; r++){\n      //printf(\"%d\",(d+r+4)%4);\n      if(y+dy[(d+r+4)%4]>=0&&y+dy[(d+r+4)%4]<=8\n          &&x+dx[(d+r+4)%4]>=0&&x+dx[(d+r+4)%4]<=8&&\n          m[y+dy[(d+r+4)%4]][x+dx[(d+r+4)%4]]=='1'){\n        d = (d+r+4)%4;\n        x += 2*dx[d];\n        y += 2*dy[d];\n        break;\n      }\n    }\n    char out;\n    switch(d){\n      case 0:\n        out = 'R';\n        break;\n      case 1:\n        out = 'D';\n        break;\n      case 2:\n        out = 'L';\n        break;\n      case 3:\n        out = 'U';\n        break;\n    }\n    putchar(out);\n    //printf(\"%d,%d\\n\",x,y);\n    if(x==0&&y==0) break;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nint main() {\n\tint g[100][100];\n\tmemset(g, 0, sizeof(g));\n\trep(i, 9) rep(j, 4 + i % 2) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tg[i + 1][j * 2 + (i + 1) % 2 + 1] = c - '0';\n\t}\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {-1, 0, 1, 0};\n\tchar c[] = \"URDL\";\n\tint x = 2, y = 0, v = 1;\n\tdo {\n\t\tcout << c[v];\n\t\tint pv = (v - 1 + 4) % 4;\n\t\tint nv = (v + 1) % 4;\n\t\t\n\t\tif (g[y + dy[v]][x + dx[v]] == 1) {\n\t\t\tv = pv;\n\t\t}\n\t\telse if (g[y + dy[v] * 2 + dy[nv]][x + dx[v] * 2 + dx[nv]] == 1) {\n\t\t\tx += dx[v] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t}\n\t\telse {\n\t\t\tx += dx[v] * 2;\n\t\t\tx += dx[nv] * 2;\n\t\t\ty += dy[v] * 2;\n\t\t\ty += dy[nv] * 2;\n\t\t\tv = nv;\n\t\t}\n\t\tif (x == 0 && y == 0) break;\n\t\tif (x == 1 && y == 0) break;\n\t} while(true);\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nint lab[11][7];\nstring s;\n\nvoid f(int i,int j){\n\n\tif(i==1 && j==1) return;\n\telse{\n\n\t\tstring a=\"URDLURDLUR\";\n\t\tint dx[]={0 ,-1,0,1, 0,-1,0};\n\t    int dy[]={-1, 0,0,0,-1, 0,0};\n\n        rep(k,4){\n\t\tif(s[s.size()-1]==a[k]){\n\n\t\tif(lab[i+dx[k]][j+dy[k]]==1){\n\t\t\ts+=a[k+3];\n\t\t\tif(dx[k]==0 && dy[k]==0) f(i,j+1);  else f(i+2*dx[k],j+dy[k]);\n\t\t}\n\t\telse if(lab[i+dx[k+1]][j+dy[k+1]]==1){\n\t\t\ts+=a[k+4];\n\t\t\tif(dx[k+1]==0 && dy[k+1]==0) f(i,j+1);  else f(i+2*dx[k+1],j+dy[k+1]);\n\t\t}\n\t\telse if(lab[i+dx[k+2]][j+dy[k+2]]==1){\n\t\t\ts+=a[k+5];\n\t\t\tif(dx[k+2]==0 && dy[k+2]==0) f(i,j+1);  else f(i+2*dx[k+2],j+dy[k+2]);\n\t\t}\n\t\telse if(lab[i+dx[k+3]][j+dy[k+3]]==1){\n\t\t\ts+=a[k+6];\n\t\t\tif(dx[k+3]==0 && dy[k+3]==0) f(i,j+1);  else f(i+2*dx[k+3],j+dy[k+3]);\n\t\t}\n\t\tbreak;\n\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(){\n\n\tREP(i,1,9){\n\tif(i%2==1)\n\tREP(j,1,4) cin >> lab[i][j];\n\telse\n\tREP(k,1,5) cin >> lab[i][k];\n\t}\n\n    s+='R';\n\n   f(1,2);\n\n   cout << s << endl;\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[100];\nint len;\nint fie[101][101];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tif(n>9){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else dir=(dir+1)%4;\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define X first\n#define Y second\n#define WIDTH 8\n#define HEIGHT 8\n\nusing namespace std;\n\nstruct point{\n\tpoint(int x = 0, int y = 0, char dir = 'R'):x(x), y(y), dir(dir){}\n\tint x;\n\tint y;\n\tchar dir;\n};\n\nchar moveMap(vector<string> &map, point &player){\n\tswitch(player.dir){\n\tcase 'R':\n\t\tif(player.y != 0 && map[player.y - 1][player.x + 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y][player.x + 1] == '1'){\n\t\t\tplayer.x += 1;\n\t\t}\n\t\telse if(player.y != 8 && map[player.y + 1][player.x + 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\tif(player.y != 8 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\telse if(player.x != 0 && map[player.y][player.x - 1] == '1'){\n\t\t\tplayer.x -= 1;\n\t\t}\n\t\telse if(player.y != 0 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\tbreak;\n\tcase 'U':\n\t\tif(player.x != 0 && map[player.y - 1][player.x - 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\telse if(player.y != 1 && map[player.y - 2][player.x] == '1'){\n\t\t\tplayer.y -= 2;\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tif(player.x != map[player.y].size() - 1 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\telse if(player.y != 7 && map[player.y + 2][player.x] == '1'){\n\t\t\tplayer.y += 2;\n\t\t}\n\t\telse if(player.x != 0 && map[player.y + 1][player.x - 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn player.dir;\n}\n\nint main(){\n\tstring tmp;\n\twhile(cin >> tmp){\n\t\tif(cin.eof()) break;\n\t\t\n\t\tvector<string> map;\n\t\tmap.push_back(tmp);\n\t\tfor(int i = 1; i < 9; i++){\n\t\t\tcin >> tmp;\n\t\t\tmap.push_back(tmp);\n\t\t}\n\n\t\tpoint player(0, 0, 'R');\n\t\tstring root;\n\t\troot.push_back('R');\n\t\t\n\t\twhile(1){\n\t\t\troot.push_back(moveMap(map, player));\n\t\t\tif(player.x == 0 && player.y == 0) break;\n\t\t}\n\n\t\tfor(int i = 0; i < root.size(); i++){\n\t\t\tcout << root[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint can[40][40];\nint inside[40][40];\n\n// DLUR\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\n\nstring answer;\n\nvector<int> v;\nint dfs(int x,int y,int hand){\n\tif(x == 1 && y == 2 ) return 0;\n\t//cout << x << \" \" << y << endl;\n\t\n\tif( !can[y+dy[hand]][x+dx[hand]] ){\n\t\t//v.push_back(hand);\n\t\ty += dy[hand];\n\t\tx += dx[hand];\n\t\thand = (hand+1)%4;\n\t\t\n\t}\n\tif( can[y+dy[(hand+3)%4]][x+dx[(hand+3)%4]] ){\n\t\tdo{\n\t\t\thand = (hand+1)%4;\n\t\t}while(!can[y+dy[hand]][x+dx[hand]]);\n\t\tv.push_back(hand);\n\t}\n\tv.push_back(hand);\n\tdfs(x+dx[(hand+3)%4],y+dy[(hand+3)%4],hand);\n\t\n}\nint main(){\n\n\tfor(int i = 0 ; i < 9 ; i++){\n\t\tif( i % 2 ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[1+i/2*3][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+1][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+2][1+3*j] = 1;\n\t\t\t\t\tcan[1+i/2*3+3][1+3*j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j = 0 ; j < 4 ; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '1' ){\n\t\t\t\t\tcan[i/2*3+1][1+j*3+0] = 1; \n\t\t\t\t\tcan[i/2*3+1][1+j*3+1] = 1;\n\t\t\t\t\tcan[i/2*3+1][1+j*3+2] = 1;  \n\t\t\t\t\tcan[i/2*3+1][1+j*3+3] = 1; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1,0,0);\n\tv.push_back(-1);\n\tint idx = 0;\n\tfor(int i = 1 ; i < v.size() ; i++){\n\t\tif( v[i] != v[i-1] ){\n\t\t\tint len = (i - idx);\n\t\t\t//cout << len << endl;\n\t\t\tcout << string((len+1)/3,\"RDLU\"[v[idx]]);\n\t\t\tidx = i;\n\t\t}\n\t}\n\tcout << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar d[10][6];\n\nvoid solve(int y,int x,int way){\n  if(y==0&&x==0)return;\n  if(way==1){\n    cout<<\"R\";\n    if(y>0&&d[y-1][x+1]=='1')solve(y-1,x+1,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n    else if(y<8&&d[y+1][x+1]=='1')solve(y+1,x+1,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n  }\n  else if(way==2){\n    cout<<\"U\";\n    if(x>0&&d[y-1][x-1]=='1')solve(y-1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n    else if(x<4&&d[y-1][x]=='1')solve(y-1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n  }\n  else if(way==3){\n    cout<<\"L\";\n    if(y<8&&d[y+1][x]=='1')solve(y+1,x,4);\n    else if(x>0&&d[y][x-1]=='1')solve(y,x-1,3);\n    else if(y>0&&d[y-1][x]=='1')solve(y-1,x,2);\n    else if(x<4&&d[y][x+1]=='1')solve(y,x+1,1);\n  }\n  else if(way==4){\n    cout<<\"D\";\n    if(x<4&&d[y+1][x]=='1')solve(y+1,x,1);\n    else if(y<7&&d[y+2][x]=='1')solve(y+2,x,4);\n    else if(x>0&&d[y+1][x-1]=='1')solve(y+1,x-1,3);\n    else if(y>1&&d[y-2][x]=='1')solve(y-2,x,2);\n  }\n}\n\nint main(void){\n  for(int i=0;i<9;i++){\n    cin>>d[i];\n  }\n  cout<<\"R\";\n  solve(0,1,1);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tif(cin.eof())\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tcin>>yoko[i][j];\n\t\t\t}\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tcin>>tate[i][j];\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0)\n\t\t\t\tbreak;\n}\ncout<<endl;\n}\n\t\t\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dx[]{ 0,1,0,-1 }, dy[]{ 1,0,-1,0 };\nchar dir[] = \"RDLU\";\nbool b[5][5][5][5];\nint main() {\n\trep(i, 9) {\n\t\trep(j, i & 1 ? 5 : 4) {\n\t\t\tint d; scanf(\"%1d\", &d);\n\t\t\tif (i & 1)b[i / 2][j][i / 2 + 1][j] = b[i / 2 + 1][j][i / 2][j] = d;\n\t\t\telse b[i / 2][j][i / 2][j + 1] = b[i / 2][j + 1][i / 2][j] = d;\n\t\t}\n\t}\n\tint id = 0, x = 0, y = 0;\n\tdo {\n\t\tfor (int i = 3;; i++) {\n\t\t\tint nx = x + dx[(id + i) % 4], ny = y + dy[(id + i) % 4];\n\t\t\tif (0 <= nx&&nx < 5 && 0 <= ny&&ny < 5 && b[x][y][nx][ny]) {\n\t\t\t\tx = nx; y = ny; (id += i) %= 4; printf(\"%c\", dir[id]); break;\n\t\t\t}\n\t\t}\n\t} while (x != 0 || y != 0);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nchar w[5][5];\nchar b[128], *p;\nchar i,j;\n\nvoid F(int v){\n  scanf(\"%s\",b);\n  for(p=b; *p; p++){\n    w[p-b+1-v][j+v]|=((w[p-b][j]|=(*p==49)<<3-v)&8>>v)>>2;\n  }\n  j+=v;\n}\n  \nmain(){\n  \n  for (;F(0),j-4;F(1));\n  \n  \n  for(i=j=(*b=3)^3;i+=\"BABC\"[*b]-66,j+=\"ABCB\"[*b]-66,putchar(\"ULDR\"[*b]),i+j;)\n    for((*b+=1)&=~4;!(w[i][j]&(1<<*b)); (*b+=3)&=~4);\n  return !puts(\"\");\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  char sidemap[5][4];\n  char upmap[4][5];\n  int x=0,y=0;\n  for(int i=0;i<9;i++)\n    {\n      if(i%2==0)\n\t{\n\t  for(int j=0;j<4;j++)\n\t      cin>>sidemap[i/2][j];\n\t}\n      else\n\t{\n\t  for(int j=0;j<5;j++)\n\t    cin>>upmap[i/2][j];\n\t}\n    }\n  /*\n  for(int i=0;i<5;i++,cout<<endl)\n    for(int j=0;j<4;j++)\n      {\n\tcout<<sidemap[i][j];\n      }\n\n  for(int i=0;i<4;i++,cout<<endl)\n    for(int j=0;j<5;j++)\n      {\n\tcout<<upmap[i][j];\n      }\n  */\n  char move='R';\n  do{\n    //cout<<\"now:\"<<x<<\",\"<<y;\n    //    cout<<\"X,y=\"<<x<<\",\"<<y<<endl;\n    //次の移動方向\n    if(move=='L')\n      {\n\tif(x<4&&upmap[x][y]=='1')\n\t  move='D';\n\telse if(y>0 && sidemap[x][y-1]=='1')\n\t  move='L';\n\telse if(x>0 && upmap[x-1][y]=='1')\n\t  move='U';\n\telse\n\t  move='R';\n      }\n    else if(move=='R')\n      {\n\tif(x>0&&upmap[x-1][y]=='1')\n\t  move='U';\n\telse if(y<4 && sidemap[x][y]=='1')\n\t  move='R';\n\telse if(x<4&&y<5&&upmap[x][y]=='1')\n\t  move='D';\n\telse\n\t  move='L';\n      }\n    else if(move=='U')\n      {\n\tif(y>0&&sidemap[x][y-1]=='1')\n\t  move='L';\n\telse if(x>0&&upmap[x-1][y]=='1')\n\t  move='U';\n\telse if(x<5&&y<4&&sidemap[x][y]=='1')\n\t  move='R';\n\telse\n\t  move='D';\n      }\n    else if(move=='D')\n      {\n\tif(x<5&&y<4&&sidemap[x][y]=='1')\n\t  move='R';\n\telse if(x<4&&upmap[x][y]=='1')\n\t  move='D';\n\telse if(y>0&&sidemap[x][y-1]=='1')\n\t  move='L';\n\telse \n\t  move='U';\n      }\n    //次の移動方向\n    if(move=='L')\n      {\n\ty--;\n      }\n    else if(move=='R')\n      {\n\ty++;\n      }\n    else if(move=='U')\n      {\n\tx--;\n      }\n    else if(move=='D')\n      {\n\tx++;\n      }\n      \n      cout<<move;\n      ///      cout<<endl;\n  }while(x!=0||y!=0);\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nstring e = \"RDLU\";\nstring s[9]; bool d[6][6][4];\nint main() {\n\tfor (int i = 0; i < 9; i++) cin >> s[i];\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[i * 2][j] == '1') d[i][j + 1][1] = d[i + 1][j + 1][3] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tif (s[i * 2 + 1][j] == '1') d[i + 1][j][0] = d[i + 1][j + 1][2] = true;\n\t\t}\n\t}\n\tstring ret = \"R\";\n\tint x = 0, y = 1, dr = 0;\n\twhile (true) {\n\t\tif (d[x][y][dr]) dr = (dr + 3) & 3, ret += e[dr];\n\t\telse {\n\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\tif (x == 1 && y == 0) break;\n\t\t\tif (!d[x][y][(dr + 1) & 3]) {\n\t\t\t\tdr = (dr + 1) & 3;\n\t\t\t\tx += dir[dr], y += dir[dr ^ 1]; ret += e[dr];\n\t\t\t\tif (x == 1 && y == 0) break;\n\t\t\t}\n\t\t\telse ret += e[dr];\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nenum Direction {R, L, U, D};\n\nbool input(char b[][5])\n{\n\tchar dummy;\n\tfor (int i=0; i<9; i++) {\n\t\tfor (int j=0; j<5; j++) {\n\t\t\tif ((i&1)==0 && j==4) continue;\n\t\t\tif ( !(cin >> b[i][j]) ) return false;\n\t\t}\n\t\t//cin >> dummy;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tchar board[9][5];\n\tinput(board);\n\t\n\tpair<int, int> curr_pos = (board[1][0] == '1') ? pair<int,int>(1,0) : pair<int,int>(0,0);\n\tenum Direction curr_dir = (board[1][0] == '1') ? D : R;\n\tif (curr_dir == D) cout << \"D\";\n\telse cout << \"R\";\n\t\n\tdo {\n\t\tswitch (curr_dir) {\n\t\tcase R:\n\t\t\t// priority : U > R > D\n\t\t\tif ( curr_pos.first > 0 && board[curr_pos.first-1][curr_pos.second+1] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--; curr_pos.second++;\n\t\t\t} else if ( curr_pos.second < 3 && board[curr_pos.first][curr_pos.second+1] == '1' ){\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.second++;\n\t\t\t} else {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++; curr_pos.second++;\n\t\t\t} \n\t\t\tbreak;\n\t\tcase L:\n\t\t\t// priority : D > L > U\n\t\t\tif ( curr_pos.first < 8 && board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.second > 0 && board[curr_pos.first][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.second--;\n\t\t\t} else {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\t// priority : L > U > R\n\t\t\tif ( curr_pos.second > 0 && board[curr_pos.first-1][curr_pos.second-1] == '1' ) {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first--; curr_pos.second--;\n\t\t\t} else if ( curr_pos.first > 2 && board[curr_pos.first-2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = U; cout << \"U\"; curr_pos.first-=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\t// priority : R > D > L\n\t\t\tif ( board[curr_pos.first+1][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = R; cout << \"R\"; curr_pos.first++;\n\t\t\t} else if ( curr_pos.first < 6 && board[curr_pos.first+2][curr_pos.second] == '1' ) {\n\t\t\t\tcurr_dir = D; cout << \"D\"; curr_pos.first+=2;\n\t\t\t} else {\n\t\t\t\tcurr_dir = L; cout << \"L\"; curr_pos.first++; curr_pos.second--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while ( curr_pos.first != 0 || curr_pos.second != 0 );\n\t\n\tcout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> field;\n\nvoid init() {\n    string l;\n    for (int i = 0; i < 9; i++) {\n        cin >> l;\n        string line = \"\";\n        if (i % 2) {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(' ');\n                } else {\n                    line.push_back(l[j/2]);\n                }\n            }\n        } else {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(l[j/2]);\n                } else {\n                    line.push_back(' ');\n                }\n            }\n        }\n        field.push_back(line);\n    }\n}\n\n#define R 0\n#define U 1\n#define L 2\n#define D 3\n\nchar DIRSTR[] = {'R', 'U', 'L', 'D'};\n\nint main() {\n    init();\n\n    int dir = R;\n    int x = 0;\n    int y = 0;\n\n    while (true) {\n        switch (dir) {\n            case R:\n                if (x + 2 > 9 || field[y][x+1] == '0')  {\n                    if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                        dir = U;\n                    } else if (!(y + 2 > 9 || field[y+1][x] == '0')) {\n                        dir = D;\n                    } else {\n                        dir = L;\n                    }\n                } else {\n                    x += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case D:\n                if (y + 2 > 9 || field[y+1][x] == '0') {\n                    if (!(x + 2 > 9 || field[y][x+1] == '0'))  {\n                        dir = R;\n                    } else if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                        dir = L;\n                    } else {\n                        dir = U;\n                    }\n                } else {\n                    y += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case L:\n                if (x - 2 < 0 || field[y][x-1] == '0') {\n                    if (!(y + 2 > 9 || field[y+1][x] == '0')) {\n                        dir = D;\n                    } else if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                        dir = U;\n                    } else {\n                        dir = R;\n                    }\n                } else {\n                    x -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case U:\n                if (y - 2 < 0 || field[y-1][x] == '0') {\n                    if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                        dir = L;\n                    } else if (!(x + 2 > 9 || field[y][x+1] == '0'))  {\n                        dir = R;\n                    } else {\n                        dir = D;\n                    }\n                } else {\n                    y -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n        }\n        if (x == 0 && y == 0) break;\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nstring wall_01[5];\nstring wall_02[4];\n\nchar wall_1(int x, int y){\n\tif(x <= -1 || y <= -1 || x >= 4 || y >= 5){\n\t\treturn '0';\n\t}\n\treturn wall_01[y][x];\n}\n\nchar wall_2(int x, int y){\n\tif(x <= -1 || y <= -1 || x >= 5 || y >= 4){\n\t\treturn '0';\n\t}\n\treturn wall_02[y][x];\n}\n\nint main(){\n\t\n\tfor(int i = 0; i < 9; i++){\n\t\tif(i % 2 == 0){\n\t\t\tcin >> wall_01[i / 2];\n\t\t}else{\n\t\t\tcin >> wall_02[i / 2];\n\t\t}\n\t}\n\t\n\tint pos_x = 0;\n\tint pos_y = 0;\n\t\n\tchar dir_list[4] = {'R', 'D', 'L', 'U'};\n\t\n\tchar dir = 'R';\n\t\n\twhile(true){\n\t\t\n\t\t//cout << pos_x << pos_y << dir << endl;\n\t\t\n\t\tif(dir == 'R'){\n\t\t\tif(wall_2(pos_x, pos_y - 1) == '1'){\n\t\t\t\tcout << \"U\";\n\t\t\t\tpos_y--;\n\t\t\t\tdir = 'U';\n\t\t\t}else if(wall_1(pos_x, pos_y) == '1'){\n\t\t\t\tcout << \"R\";\n\t\t\t\tpos_x++;\n\t\t\t}else if(wall_2(pos_x, pos_y) == '1'){\n\t\t\t\tdir = 'D';\n\t\t\t}else{\n\t\t\t\tdir = 'L';\n\t\t\t}\n\t\t}else if(dir == 'D'){\n\t\t\tif(wall_1(pos_x, pos_y) == '1'){\n\t\t\t\tcout << \"R\";\n\t\t\t\tpos_x++;\n\t\t\t\tdir = 'R';\n\t\t\t}else if(wall_2(pos_x, pos_y) == '1'){\n\t\t\t\tcout << \"D\";\n\t\t\t\tpos_y++;\n\t\t\t}else if(wall_1(pos_x - 1, pos_y) == '1'){\n\t\t\t\tdir = 'L';\n\t\t\t}else{\n\t\t\t\tdir = 'U';\n\t\t\t}\n\t\t}else if(dir == 'L'){\n\t\t\tif(wall_2(pos_x, pos_y) == '1'){\n\t\t\t\tcout << \"D\";\n\t\t\t\tpos_y++;\n\t\t\t\tdir = 'D';\n\t\t\t}else if(wall_1(pos_x - 1, pos_y) == '1'){\n\t\t\t\tcout << \"L\";\n\t\t\t\tpos_x--;\n\t\t\t}else if(wall_2(pos_x, pos_y - 1) == '1'){\n\t\t\t\tdir = 'U';\n\t\t\t}else{\n\t\t\t\tdir = 'R';\n\t\t\t}\n\t\t}else if(dir == 'U'){\n\t\t\tif(wall_1(pos_x - 1, pos_y) == '1'){\n\t\t\t\tcout << \"L\";\n\t\t\t\tpos_x--;\n\t\t\t\tdir = 'L';\n\t\t\t}else if(wall_2(pos_x, pos_y - 1) == '1'){\n\t\t\t\tcout << \"U\";\n\t\t\t\tpos_y--;\n\t\t\t}else if(wall_1(pos_x, pos_y) == '1'){\n\t\t\t\tdir = 'R';\n\t\t\t}else{\n\t\t\t\tdir = 'D';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(pos_x == 0 && pos_y == 0){\n\t\t\tcout << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    cout<<\"R\";\n    serch(1,0,0);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n        cout<<\"L\";\n        serch(x-1,y,2);\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1&&side[y-1][x]=='1'){\n        cout<<\"U\";\n        serch(x,y-1,3);\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nvoid serch(int x,int y,int then)\n{\n    if(x==0&&y==0){\n        cout<<endl;\n        exit(0);\n    }\n    if(then==0){\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n    }\n    else if(then==1){\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n    }\n    else if(then==2){\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n    }\n    else{\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n \n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nchar tate[4][5];\nchar yoko[5][4];\nbool flag = false;\n\nvoid test(int x, int y, int j){\n\t//cout<<x<<\" \"<<y<<\" \"<<endl;\n\tint i;\n\t//cin>>i;\n\tif(x==0&&y==0){\n\t\treturn;\n\t}\n\n\tif(j==0){                                  //右に動いた時\n\t\tif(x-1>=0 && tate[x-1][y]=='1'){       //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //右に行ける\n\t\t\tcout<<\"R\";\n\t\t\ttest(x, y+1, 0);                   \n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);    //下に\n\t\t}\n\t}\n\telse if(j==1){                             //上に動いた時\n\t\tif(y-1>=0 && yoko[x][y-1]=='1'){       //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //上に行ける\n\t\t\tcout <<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t\telse if(y+1<5 && yoko[x][y]=='1'){     //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t}\n\telse if(j==2){                             //左に動いた時\n\t\tif(x+1<5 && tate[x][y]=='1'){          //行き止まり　下に\n\t\t\tcout<<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //左に行けるなら\n\t\t\tcout<<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t\telse if(x-1>=0 && tate[x-1][y]=='1'){  //行き止まり　上に\n\t\t\tcout<<\"U\";\n\t\t\ttest(x-1, y, 1);\n\t\t}\n\t}\n\telse if(j==3){                             //下に動いた時\n\t\tif(y+1<5 && yoko[x][y]=='1'){          //行き止まり　右に\n\t\t\tcout <<\"R\";\n\t\t\ttest(x, y+1, 0);\n\t\t}\n\t\telse if(x+1<5 && tate[x][y]=='1'){     //下に行けるなら\n\t\t\tcout <<\"D\";\n\t\t\ttest(x+1, y, 3);\n\t\t}\n\t\telse if(y-1>=0 && yoko[x][y-1]=='1'){  //行き止まり　左に\n\t\t\tcout <<\"L\";\n\t\t\ttest(x, y-1, 2);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tfor(int i=0;i<4;i++){\n\t\tcin >> yoko[i][0] >> yoko[i][1] >> yoko[i][2] >> yoko[i][3];\n\t\tcin >> tate[i][0] >> tate[i][1] >> tate[i][2] >> tate[i][3] >> tate[i][4];\n\t}\n\tcin >> yoko[4][0] >> yoko[4][1] >> yoko[4][2] >> yoko[4][3];\n\t\n\tcout << \"R\";\n\ttest(0, 1, 0);\n\t\n\tcout<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring wall[9];\n\nint dy[4]={0,1,0,-1};\nint dx[4]={1,0,-1,0};\n\ninline int iswall(int cx,int cy,int d){\n\tswitch(d){\n\t\tcase 0:\n\t\t\tcy=2*cy;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcy=2*cy+1;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcy=2*cy;\n\t\t\tcx=cx-1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcy=2*cy-1;\n\t\t\tcx=cx;\n\t\t\tbreak;\n\t}\n\tif(cy<0||9<=cy||cx<0||5<=cx) return 0;\n\treturn wall[cy][cx]=='1';\n}\n\nint main(void){\n\trep(i,9){\n\t\tcin >> wall[i];\n\t\tif(wall[i].size()==4) wall[i]+=\"0\";\n\t}\n\tcout << 'R';\n\tint cx=1,cy=0,cd=0;\n\tmap<int,char> dir;\n\tdir[0]='R',dir[1]='D',dir[2]='L',dir[3]='U';\n\twhile(1){\n\t\trep(i,4){\n\t\t\tint nd=(cd+i+3)%4;\n\t\t\tif(iswall(cx,cy,nd)){\n\t\t\t\tcout << dir[nd];\n\t\t\t\tcy+=dy[nd],cx+=dx[nd],cd=nd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(cx==0&&cy==0) break;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint g[6][6][4]={};//top,bottom,left,right\n\nint main(void) {\n  int i,j;\n  rep(i,9){\n    string s;\n    cin>>s;\n    if(i%2){\n      rep(j,5){\n        g[i/2+1][j][3] = s[j] - '0';\n        g[i/2+1][1+j][2] = g[i/2+1][j][3];\n      }\n    }else{\n      rep(j,4){\n        g[i/2+1][1+j][0] = s[j] - '0';\n        g[i/2][1+j][1] = g[i/2+1][1+j][0];\n      }\n    }\n  }\n\n  char s[5] = {\"LRDU\"};\n  int dx[4] = {0,0,1,-1};\n  int dy[4] = {-1,1,0,0};\n\n  int x=0,y=1,z=1;//(x,y)右手がz\n\n  while(x+y){\n    if(g[x][y][z]){\n        cout<<s[z];\n        if((z==1 && g[x][y][1] && g[x][y][3]) || (z==0 && g[x][y][0] && g[x][y][2]) ||\n          (z==2 && g[x][y][2] && g[x][y][1]) || (z==3 && g[x][y][3] && g[x][y][0])){\n            switch(z){\n              case 0: z=2;break;\n              case 1: z=3;break;\n              case 2: z=1;break;\n              case 3: z=0;break;\n            }\n        }else{\n          x = x + dx[z];\n          y = y + dy[z];\n        }\n    }else{\n      switch(z){\n        case 0: z=3;x--;break;\n        case 1: z=2;x++;break;\n        case 2: z=0;y--;break;\n        case 3: z=1;y++;break;\n      }\n    }\n  }\n    cout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> field;\n\nvoid init() {\n    string l;\n    for (int i = 0; i < 9; i++) {\n        cin >> l;\n        string line = \"\";\n        if (i % 2) {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(' ');\n                } else {\n                    line.push_back(l[j/2]);\n                }\n            }\n        } else {\n            for (int j = 0; j < 9; j++) {\n                if (j % 2) {\n                    line.push_back(l[j/2]);\n                } else {\n                    line.push_back(' ');\n                }\n            }\n        }\n        field.push_back(line);\n    }\n}\n\n#define R 0\n#define U 1\n#define L 2\n#define D 3\n\nchar DIRSTR[] = {'R', 'U', 'L', 'D'};\n\nint main() {\n    init();\n\n    int dir = R;\n    int x = 0;\n    int y = 0;\n\n    while (true) {\n        switch (dir) {\n            case R:\n                if (x + 2 >= 9 || field[y][x+1] == '0')  {\n                    if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                        dir = U;\n                    } else if (!(y + 2 >= 9 || field[y+1][x] == '0')) {\n                        dir = D;\n                    } else {\n                        dir = L;\n                    }\n                } else {\n                    x += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case D:\n                if (y + 2 >= 9 || field[y+1][x] == '0') {\n                    if (!(x + 2 >= 9 || field[y][x+1] == '0'))  {\n                        dir = R;\n                    } else if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                        dir = L;\n                    } else {\n                        dir = U;\n                    }\n                } else {\n                    y += 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case L:\n                if (x - 2 < 0 || field[y][x-1] == '0') {\n                    if (!(y + 2 >= 9 || field[y+1][x] == '0')) {\n                        dir = D;\n                    } else if (!(y - 2 < 0 || field[y-1][x] == '0')) {\n                        dir = U;\n                    } else {\n                        dir = R;\n                    }\n                } else {\n                    x -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n            case U:\n                if (y - 2 < 0 || field[y-1][x] == '0') {\n                    if (!(x - 2 < 0 || field[y][x-1] == '0')) {\n                        dir = L;\n                    } else if (!(x + 2 >= 9 || field[y][x+1] == '0'))  {\n                        dir = R;\n                    } else {\n                        dir = D;\n                    }\n                } else {\n                    y -= 2;\n                    cout << DIRSTR[dir];\n                }\n                break;\n        }\n        if (x == 0 && y == 0) break;\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main(){\n\tchar yoko[7][6];//5 * 4\n\tchar tate[6][7];//4 * 5\n\tint x, y;//position\n\tchar dir;//next direction\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tscanf(\"%s\", yoko[i]);\n\t\tscanf(\"%s\", tate[i]);\n\t}\n\tscanf(\"%s\", yoko[4]);\n\t\n\tx = 0; y = 0; dir = 'R';\n\twhile(true){\n\t\tprintf(\"%c\", dir);\n\t\tswitch (dir){\n\t\t\tcase 82://right\n\t\t\t\tx++;\n\t\t\t\tif(y > 0 && tate[y - 1][x] == '1') dir = 'U';\n\t\t\t\telse if(yoko[y][x] == '1') dir = 'R';\n\t\t\t\telse if(tate[y][x] == '1') dir = 'D';\n\t\t\t\telse dir = 'L';\n\t\t\t\tbreak;\n\t\t\tcase 68://down\n\t\t\t\ty++;\n\t\t\t\tif(yoko[y][x] == '1') dir = 'R';\n\t\t\t\telse if(tate[y][x] == '1') dir = 'D';\n\t\t\t\telse if(x > 0 && yoko[y][x - 1] == '1') dir = 'L';\n\t\t\t\telse dir = 'U';\n\t\t\t\tbreak;\n\t\t\tcase 76://left\n\t\t\t\tx--;\n\t\t\t\tif(tate[y][x] == '1') dir = 'D';\n\t\t\t\telse if(x > 0 && yoko[y][x - 1] == '1') dir = 'L';\n\t\t\t\telse if(y > 0 && tate[y - 1][x] == '1') dir = 'U';\n\t\t\t\telse dir = 'R';\n\t\t\t\tbreak;\n\t\t\tcase 85://up\n\t\t\t\ty--;\n\t\t\t\tif(x > 0 && yoko[y][x - 1] == '1') dir = 'L';\n\t\t\t\telse if(y > 0 && tate[y - 1][x] == '1') dir = 'U';\n\t\t\t\telse if(yoko[y][x] == '1') dir = 'R';\n\t\t\t\telse dir = 'D';\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(x == 0 && y == 0) break;\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct {\n    int x, y;\n    bool root[4];\n} Node;\n\nNode v[5][5];\nconst string ord = \"URDL\";\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid init() {\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            v[i][j].x = i;\n            v[i][j].y = j;\n            for (int k = 0; k < 4; k++)\n                v[i][j].root[k] = false;\n        }\n    }\n}\n\nvoid solve(int x, int y, char c) {\n    cout << c;\n    if (x == 0 && y == 0) {\n        cout << '\\n';\n        return;\n    }\n\n    int start = (ord.find(c) + 3) % 4;\n    for (int i = 0; i < 4; i++) {\n        int ni = (i + start) % 4;\n        if (v[x][y].root[ni]) {\n            solve(x + dx[ni], y + dy[ni], ord[ni]);\n            return;\n        }\n    }\n}\n\nint main() {\n    init();\n\n    for (int i = 0; i < 9; i++) {\n        string input;\n        cin >> input;\n\n        for (int j = 0; j < input.size(); j++) {\n            if (input[j] != '1') continue;\n            \n            if (i % 2) {\n                v[(i + 1) / 2 - 1][j].root[2] = true;\n                v[(i + 1) / 2][j].root[0] = true;\n            } else {\n                v[i / 2][j].root[1] = true;\n                v[i / 2][j + 1].root[3] = true;\n            }\n        }\n    }\n\n    solve(0, 1, 'R');\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nint maze[20][20];\n\nchar s[6];\nchar ans[100];\nint sz=0;\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nchar sym[]=\"RDLU\";\n\nint main(){\n  REP(i,9){\n    scanf(\"%s\",s);\n    REP(j,strlen(s)){\n      if (i%2==0){\n\tmaze[i+1][2*j+2]=s[j]-'0';\n      }else{\n\tmaze[i+1][2*j+1]=s[j]-'0';\n      }\n    }\n  }\n  REP(i,11){\n    REP(j,11){\n      fprintf(stderr,\"%d\",maze[i][j]);\n    }\n    fprintf(stderr,\"\\n\");\n  }\n  ans[0]='R';\n  sz++;\n  int x=3,y=1;\n  int dir=0;\n  while (x!=1 || y!=1){\n    REP(i,4){\n      int d=(dir+3+i)%4;\n      if (maze[y+dy[d]][x+dx[d]]){\n\tdir=d;\n\tbreak;\n      }\n    }\n    x+=dx[dir]*2;\n    y+=dy[dir]*2;\n    ans[sz++]=sym[dir];\n  }\n  printf(\"%s\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <bitset>\n#include <cstdint>\n\nint main()\n{\n\tenum { Left, Up, Right, Down };\n\n\ttypedef std::array<std::bitset<4>, 5> Row;\n\ttypedef std::array<Row, 5> Matrix;\n\tMatrix matrix;\n\n\tfor (std::uint32_t i = 0; i < 5u; ++i) {\n\t\tstd::string input;\n\t\tstd::cin >> input;\n\t\tfor (std::uint16_t j = 0; j < 4U; ++j) {\n\t\t\tif (input[j] == '1') {\n\t\t\t\tmatrix[i][j].set(Right);\n\t\t\t\tmatrix[i][j + 1].set(Left);\n\t\t\t}\n\t\t}\n\n\t\tif (i == 4U) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstd::cin >> input;\n\t\tfor (std::uint16_t j = 0; j < 5U; ++j) {\n\t\t\tif (input[j] == '1') {\n\t\t\t\tmatrix[i][j].set(Down);\n\t\t\t\tmatrix[i + 1][j].set(Up);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::uint16_t i = 0, j = 0;\n\tchar direct = 'R';\n\tdo {\n\t\tif (direct == 'R') {\n\t\t\tif (matrix[i][j][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'D') {\n\t\t\tif (matrix[i][j][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'L') {\n\t\t\tif (matrix[i][j][Down]) {\n\t\t\t\tdirect = 'D';\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--j;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\t\telse if (direct == 'U') {\n\t\t\tif (matrix[i][j][Left]) {\n\t\t\t\tdirect = 'L';\n\t\t\t\t--j;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Up]) {\n\t\t\t\tdirect = 'U';\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse if (matrix[i][j][Right]) {\n\t\t\t\tdirect = 'R';\n\t\t\t\t++j;\n\t\t\t}\n\t\t}\n\t\tstd::cout << direct << std::flush;\n\t} while (not (i == 0 and j == 0));\n\tstd::cout << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)n; ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint main() {\n  static bool wall[6][6][4];\n  const int dx[4] = { 1, 0, -1, 0 };\n  const int dy[4] = { 0, 1, 0, -1 };\n  REP(i,6) REP(j,6) REP(k,4) {\n    int ni = i + dy[k];\n    int nj = j + dx[k];\n    if(0 <= ni && ni < 6 && 0 <= nj && nj < 6) {\n      wall[i][j][k] = 0;\n    }\n    else {\n      wall[i][j][k] = 1;\n    }\n  }\n\n  string s;\n  for(int i = 0; i < 4; i++) {\n    getline(cin, s);\n    for(int j = 0; j < 4; j++) {\n      wall[i][j + 1][1] = (s[j] == '1');\n      wall[i + 1][j + 1][3] = (s[j] == '1');\n    }\n    getline(cin, s);\n    for(int j = 0; j < 5; j++) {\n      wall[i + 1][j][0] = (s[j] == '1');\n      wall[i + 1][j + 1][2] = (s[j] == '1');\n    }\n  }\n  getline(cin, s);\n  for(int j = 0; j < 4; j++) {\n    wall[4][j + 1][1] = (s[j] == '1');\n    wall[5][j + 1][3] = (s[j] == '1');\n  }\n\n  string icon = \"RDLU\";\n#if 0\n  REP(i,6) REP(j,6) {\n    cerr << \"(\" << i << \",\" << j << \")\";\n    REP(k,4) {\n      if(wall[i][j][k]) cerr << icon[k];\n    }\n    cerr << endl;\n  }\n#endif\n\n  int X = 1, Y = 0, dir = 0;\n  string ans = \"R\";\n  do {\n#if 0\n    cerr << \"X = \" << X << \", Y = \" << Y << \", dir = \" << dir << endl;\n#endif\n    if(wall[Y][X][dir] == 0) {\n      Y += dy[dir];\n      X += dx[dir];\n      if(wall[Y][X][(dir + 1) % 4] == 0) {\n        dir = (dir + 1) % 4;\n        X += dx[dir];\n        Y += dy[dir];\n        if(wall[Y][X][(dir + 1) % 4] == 0) {\n          dir = (dir + 1) % 4;\n          X += dx[dir];\n          Y += dy[dir];\n          ans.push_back(icon[dir]);\n        }\n        else {\n          ans.push_back(icon[dir]);\n        }\n      }\n      else {\n        ans.push_back(icon[dir]);\n      }\n    }\n    else {\n      dir = (dir - 1 + 4) % 4;\n      ans.push_back(icon[dir]);\n    }\n  } while(!((X == 1 && Y == 0)));\n  ans = ans.substr(0, (int)ans.size() - 1);\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\n\t//while(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tmemset(yoko,0,sizeof(yoko));\n\t\tmemset(tate,0,sizeof(tate));\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c;\n\t\t\t}\n\t\t\tif(i!=4){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin>>c;\n\t\t\t\t\ttate[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\tstring str=\"\";\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tstr+='R';\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tstr+='D';\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tstr+='L';\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tstr+='U';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tstr+='U';\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tstr+='L';\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tstr+='R';\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tstr+='D';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0){\n\t\t\t\tbreak;\n\t\t\t}\n}\n\n//cout<<str<<endl;\n//break;\n\n//}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Dot{\npublic:\n  bool d[4];\n  Dot() {\n    d[0] = d[1] = d[2] = d[3] = false;\n  }\n};\n\nint main() {\n  Dot data[5][5];\n  for(int i = 0; i < 9; i++) {\n    string str;\n    getline(cin, str);\n    int y = i/2;\n    if(i % 2 == 0) {\n      for(int j = 0; j < 4; j++) {\n\tif(str[j] == '1') {\n\t  data[y][j].d[0] = data[y][j+1].d[2] = true;\n\t}\n      }\n    } else {\n      for(int j = 0; j < 5; j++)  {\n\tif(str[j] == '1') {\n\t  data[y][j].d[1] = data[y+1][j].d[3] = true;\n\t}\n      }\n    }\n  }\n\n  int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  int x = 0;\n  int y = 0;\n  int dir = 0;\n  while(1) {\n    for(int i = 0; i < 3; i++) {\n      int t = (dir+i+3)%4;\n      if(data[y][x].d[t]) {\n\tdir = t;\n\tx += d[t][0];\n\ty += d[t][1];\n\tswitch(t) {\n\tcase 0: cout << 'R'; break;\n\tcase 1: cout << 'D'; break;\n\tcase 2: cout << 'L'; break;\n\tcase 3: cout << 'U'; break;\n\t}\n\tbreak;\n      }\n    }\n    if(x == 0 && y == 0) {\n      cout << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tstd::cout << 'R';\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = U;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = D;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = R;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tdir = L;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && crd[1] == 0)\n\t\t{\n\t\t\tstd::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool h[7][6]; // setinel\nbool v[6][7];\n\n\nint main(){\n\tstring str, ans = \"\";\n\tchar dir = 'n';\n\tint mx = 1;\n\tint my = 1;\n\n\tint i = 1;\n\tint j = 1;\n\n\twhile(cin >> str){\n\t\tif(str.size() == 4){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(str.size() == 5){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (v[my-1][mx] && dir != 'D' && (dir=='R' || !h[my][mx-1])) {\n\t\t\tdir = 'U';\n\t\t\tmy--;\n\t\t}else if (h[my][mx] && dir != 'L' && (dir=='D' || !v[my-1][mx])) {\n\t\t\tdir = 'R';\n\t\t\tmx++;\n\t\t}else if (v[my][mx] && dir != 'U' && (dir=='L' || !h[my][mx])) {\n\t\t\tdir = 'D';\n\t\t\tmy++;\n\t\t}else if (h[my][mx-1] && dir != 'R' && (dir=='U' || !v[my][mx])) {\n\t\t\tdir = 'L';\n\t\t\tmx--;\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint table[100][100];\nstring s;\n\nint dx[] = { 0, 1, 0, -1, 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0, -1, 0, 1, 0 };\nchar c[] = \"URDLURDL\";\n\nint main(){\n\tREP(i, 9){\n\t\tcin >> s;\n\t\tREP(j, s.size()){\n\t\t\tif (i % 2 == 0)\ttable[i][2 * j + 1] = s[j] - '0';\n\t\t\telse table[i][2 * j] = s[j] - '0';\n\t\t}\n\t}\n\tbool f = 0;\n\tstring ans = \"\";\n\tint x = 0, y = 0, muki = 0;\n\twhile (1){\n\t\tif (f&&x == 0 && y == 0)break;\n\t\tint ny, nx;\n\t\tfor (int i = muki; i < muki + 4; i++){\n\t\t\tnx = x + dx[i], ny = y + dy[i];\n\t\t\tif (nx >= 0 && nx <= 8 && ny >= 0 && ny <= 8){\n\t\t\t\tif (table[ny][nx] == 1){\n\t\t\t\t\tx += 2 * dx[i];\n\t\t\t\t\ty += 2 * dy[i];\n\t\t\t\t\tans += c[i];\n\t\t\t\t\tif (c[i] == 'U')muki = 3;\n\t\t\t\t\telse if (c[i] == 'R')muki = 0;\n\t\t\t\t\telse if (c[i] == 'D')muki = 1;\n\t\t\t\t\telse muki = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = 1;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstring ans=\"\";\nbool a[5][5][4] = {{{0}}};\nint main(){\n    string str;\n    for(int i=0;i<9;i++){\n        if(i%2==0){\n            cin>>str;\n            for(int j=0;j<4;j++){\n                if(str[j]=='1'){\n\n                    a[i/2][j][1] = true;\n                    a[i/2][j+1][3] = true;\n                    //cout<<\"-(\"<<i/2<<\" ,\"<<j<<\")(\"<<i/2<<\" ,\"<<j+1<<\")\"<<endl;\n                }\n\n            }\n        }\n        else{\n            cin>>str;\n            for(int j=0;j<5;j++){\n                if(str[j]=='1'){\n                    a[i/2][j][2] = true;\n                    a[i/2+1][j][0] = true;\n                    //cout<<\"|(\"<<i/2<<\" ,\"<<j<<\")(\"<<i/2+1<<\" ,\"<<j<<\")\"<<endl;\n                }\n\t\t\t\t\n            }\n        }\n    }\n\tcout<<\"R\";\n\t\tint x=1,y=0,way=1;\n\t\twhile(1){\n\t\t\tif(x==0&&y==0)break;\n\t\t\tif(way == 0){\n\t\t\t\tif(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 1){\n\t\t\t\tif(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 2){\n\t\t\t\tif(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t\telse if(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(way == 3){\n\t\t\t\tif(y!=4&&a[y][x][2]){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\ty++;\n\t\t\t\t\tway = 2;\n\t\t\t\t}\n\t\t\t\telse if(x!=0&&a[y][x][3]){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tx--;\n\t\t\t\t\tway = 3;\n\t\t\t\t}\n\t\t\t\telse if(y!=0&&a[y][x][0]){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\ty--;\n\t\t\t\t\tway = 0;\n\t\t\t\t}\n\t\t\t\telse if(x!=4&&a[y][x][1]){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tx++;\n\t\t\t\t\tway = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n\tcout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dc[]={'R','D','L','U'};\nbool t[5][5][4];\nint flg=0;\nvoid init();\nbool ck(int y,int x,int d){\n\tif(t[y][x][d]==1)return true;\n\tint ny=y+dy[d];\n\tint nx=x+dx[d];\n\tif(t[ny][nx][(d+2)%4]==1)return true;\n\treturn false; \n}\nvoid rec(int y,int x,int d);\nint main(){\n\tinit();\n\tcout<<\"test\"<<endl;\n\tfor(int i=0;i<=3;i++){\n\t\tfor(int j=0;j<=3;j++){\n\t\t\tcin>>t[i][j][0];\n\t\t}\n\t\tfor(int j=0;j<=4;j++){\n\t\t\tcin>>t[i][j][1];\n\t\t}\n\t}\n\tfor(int i=0;i<=3;i++)cin>>t[4][i][0];\n\tcout<<\"inputend\"<<endl;\n\trec(0,0,0);\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<5;i++)\n\t\tfor(int j=0;j<5;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tt[i][j][k]=0;\n}\nvoid rec(int y,int x,int d){\n\t//cout<<y << \" \" <<x<<\" \"<<d<<endl;\n\tflg++;\n\tif(y==0&&x==0&&flg>1){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t\n\tint d1=(d+1)%4;\n\tint d2=(d+2)%4;\n\tint d3=(d+3)%4;\n\tif(ck(y,x,d3)){\n\t\tcout<<dc[d3];\n\t\trec(y+dy[d3],x+dx[d3],d3);\n\t}else if(ck(y,x,d)){\n\t\tcout<<dc[d];\n\t\trec(y+dy[d],x+dx[d],d);\n\t}else if(ck(y,x,d1)){\n\t\tcout<<dc[d1];\n\t\trec(y+dy[d1],x+dx[d1],d1);\n\t}else{\n\t\tcout<<dc[d2];\n\t\trec(y+dy[d2],x+dx[d2],d2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <iostream>\n\n\nusing namespace std;\n\n\n\nint main()\n{\n\tbool points[5][5][4];\n\tfor (int i = 0; i < 5; ++i)\n\t\tfor (int j = 0; j < 5; ++j)\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\tpoints[i][j][k] = false;\n\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tint y = i/2;\n\t\tif (i%2 == 0)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][1] = points[y][j+1][3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][2] = points[y+1][j][0] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint x, y;\n\tx = 1;\n\ty = 0;\n\tint dir = 1;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { -1, 0, 1, 0 };\n\tchar* ds = \"URDL\";\n\tputchar(ds[dir]);\n\twhile (!(x == 0 && y == 0))\n\t{\n\t\tif (points[y][x][(dir+3)%4])\n\t\t\tdir = (dir+3)%4;\n\t\telse if (points[y][x][dir])\n\t\t\t;\n\t\telse if (points[y][x][(dir+1)%4])\n\t\t\tdir = (dir+1)%4;\n\t\telse\n\t\t\tdir = (dir+2)%4;\n\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tputchar(ds[dir]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n#define U 0\n#define D 1\n#define L 2\n#define R 3\n\nclass point\n{\npublic:\n\tint x,y,d;\n\tpoint()\n\t{\n\t\tx=y=0;\n\t\td=R;\n\t}\n\tvoid move()\n\t{\n\t\tif(d==R)\n\t\t{\n\t\t\tx++;\n\t\t}\n\t\telse if(d==L)\n\t\t{\n\t\t\tx--;\n\t\t}\n\t\telse if(d==U)\n\t\t{\n\t\t\ty--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty++;\n\t\t}\n\t}\n\tchar dir()\n\t{\n\t\tif(d==U)\n\t\t{\n\t\t\treturn 'U';\n\t\t}\n\t\telse if(d==D)\n\t\t{\n\t\t\treturn 'D';\n\t\t}\n\t\telse if(d==L)\n\t\t{\n\t\t\treturn 'L';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'R';\n\t\t}\n\t}\n};\n\nclass map\n{\npublic:\n\tstring s[9];\n\tvoid input()\n\t{\n\t\tfor(int i=0;i<9;i++)\n\t\t{\n\t\t\tcin>>s[i];\n\t\t}\n\t}\n\tint state(int x, int y, int d)\n\t{\n\t\tif(d==U)\n\t\t{\n\t\t\ty=2*y-1;\n\t\t}\n\t\telse if(d==D)\n\t\t{\n\t\t\ty=2*y+1;\n\t\t}\n\t\telse if(d==L)\n\t\t{\n\t\t\tx=x-1;\n\t\t\ty=y*2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty=y*2;\n\t\t}\n\t\tif(y<0||y>=9||x<0||x>=s[y].length())\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn s[y].at(x)-'0';\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tpoint p;\n\tmap m;\n\tm.input();\n\tint dir[4][4]=\n\t{\n\t\t{L,U,R,D},\n\t\t{R,D,L,U},\n\t\t{D,L,U,R},\n\t\t{U,R,D,L}\n\t};\n\twhile(!(p.d==L&&p.x==0&&p.y==0))\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tif(p.d==i)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tif(m.state(p.x,p.y,dir[i][j])==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tp.d=dir[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp.move();\n\t\tcout<<p.dir();\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dc[5] = \"RDLU\";\n \nbool cangocw(int y, int x, int dir, vector<string> &s){\n    if(dir%2==0){\n        return s[2*y +1][x +1-(dir/2)] == '0';\n    }else{\n        return s[2*y +(1-dir/2)*2][x+1] == '0';\n    }\n}\n \nint main(){\n    vector<string> s(11);\n    s[0] = s[10] = \"0000000\";\n    for(int i=1; i<=9; i++){\n        cin >> s[i];\n        s[i] = \"0\" + s[i] + \"0\";\n    }\n    int dir=0;\n    int x=0, y=0;\n    string ans = \"\";\n     \n    do{\n        if(cangocw(y, x, dir, s)){\n            dir = (dir+1)%4;\n            continue;\n        }\n        x += dx[dir];\n        y += dy[dir];\n        ans += dc[dir];\n        dir = (dir+3)%4;\n    }while(!(x==0 && y==0 && dir==0));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint i, j, a[6][6] = {}, b[6][5] = {};\nstring output = \"\";\n\nint right(), left(), up(), down();\n\nint right(){\n\toutput += \"R\";\n\tif(b[i-1][j] == 1){\n\t\ti--;\n\t\tup();\n\t}\n\telse if(a[i][j+1] == 1){\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"R\"; }\n\telse {\n\t\tdown();\n\t}\n\treturn 0;\n}\n\nint left(){\n\toutput += \"L\";\n\tif (b[i][j-1] == 1) {\n\t\tj--;\n\t\tdown();\n\t}\n\telse if (a[i][j-1] == 1) {\n\t\tj--;\n\t\tleft();\n\t}\n\telse if (a[i][j - 1] == 2) { output += \"L\"; }\n\telse {\n\t\ti--;\n\t\tj--;\n\t\tup();\n\t}\n\treturn 0;\n}\n\nint up(){\n\toutput += \"U\";\n\tif (a[i][j] == 1) {\n\t\tleft();\n\t}\n\telse if (a[i][j] == 2) { output += \"L\"; }\n\telse if (b[i-1][j] == 1) {\n\t\ti--;\n\t\tup();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"R\"; }\n\telse {\n\t\tj++;\n\t\tright();\n\t}\n\treturn 0;\n}\n\nint down(){\n\toutput += \"D\";\n\tif (a[i+1][j+1] == 1) {\n\t\ti++;\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i + 1][j + 1] == 2) { output += \"R\"; }\n\telse if (b[i + 1][j] == 1) {\n\t\ti++;\n\t\tdown();\n\t}\n\telse if (a[i + 1][j] == 2) { output += \"L\"; }\n\telse {\n\t\ti++;\n\t\tleft();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tstring input, k;\n\tfor(i = 1; i<10;i++){\n\t\tgetline(cin, input);\n\t\tif (input.size() != 4) {\n\t\t\tfor(int j= 0;j<5;j++){\n\t\t\t\tk = input[j];\n\t\t\t\tb[i / 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1;j<5;j++){\n\t\t\t\tk = input[j-1];\n\t\t\t\ta[(i + 1)/ 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\n\t}\n\n\ta[1][1] = 2;\n\ti = 1;\n\tj = 1;\n\tright();\n\tcout << output << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\nconst char d[4] = {'L','U','R','D'};\n \nint main(){\n  char ch;\n  bool G[6][6][4];\n  memset(G,false,sizeof(G));\n  for(int i = 0 ; i < 9 ; i++){\n    int d = i%2;\n    for(int j = 0 ; j < 4+d ; j++){\n      cin >> ch;\n      if(ch == '1'){\n        if(d%2){\n          G[i/2+1][j][2] = G[i/2+1][j+1][0] = true;\n        }else{\n          G[i/2][j+1][3] = G[i/2+1][j+1][1] = true;\n        }\n      }\n    }\n  }\n  int x = 1,y = 0,dir = 2;\n  string ans;\n  while(true){\n    if(!x && !y) break;\n    ans += d[dir];\n    int rh = (dir+1)%4;\n    if(G[y][x][dir]){\n      dir--;\n      dir = (dir == -1 ? 3 : dir);\n    }else if(!G[y+dy[dir]][x+dx[dir]][rh]){\n      x += dx[dir], y += dy[dir];\n      if(!x && !y) break;\n      x += dx[rh], y += dy[rh];\n      dir = rh;\n    }else{\n      x += dx[dir]; y += dy[dir];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring line[9];\n\nbool check( int x, int y ) {\n    if ( y < 0 || y >= 9 ) return false;\n    if ( y % 2 == 0 ) {\n        if ( x < 0 || x >= 4 ) return false;\n    } else {\n        if ( x < 0 || x >= 5 ) return false;\n    }\n    return true;\n}\n\nint cnt;\nvoid solve( int a, int x, int y ) {\n    if ( cnt >= 2 ) return;\n\n    if ( x == 0 && y == 0 ) {\n        cnt++;\n    }\n\n    if ( y % 2 == 0 ) {\n        cout << ( a ? \"R\" : \"L\" );\n    } else {\n        cout << ( a ? \"U\" : \"D\" );\n    }\n\n    if ( y % 2 == 0 ) {\n        if ( a ) {\n            if ( check(x+1,y-1) && line[y-1][x+1] == '1' ) {\n                solve( 1, x+1, y-1 );\n            } else if ( check(x+1,y) && line[y][x+1] == '1' ) {\n                solve( 1, x+1, y );\n            } else if ( check(x+1,y+1) && line[y+1][x+1] == '1' ) {\n                solve( 0, x+1, y+1 );\n            }\n        } else {\n            if ( check(x,y-1) && line[y-1][x] == '1' ) {\n                solve( 1, x, y-1 );\n            } else if ( check(x-1,y) && line[y][x-1] == '1' ) {\n                solve( 0, x-1, y );\n            } else if ( check(x,y+1) && line[y+1][x] == '1' ) {\n                solve( 0, x, y+1 );\n            }\n        }\n    } else {\n        if ( a ) {\n            if ( check(x-1, y-1) && line[y-1][x-1] == '1' ) {\n                solve( 0, x-1, y-1 );\n            } else if ( check(x, y-2) && line[y-2][x] == '1' ) {\n                solve( 1, x, y-2 );\n            } else if ( check(x, y-1) && line[y-1][x] == '1' ) {\n                solve( 0, x, y-1 );\n            }\n        } else {\n            if ( check(x, y+1) && line[y+1][x] == '1' ) {\n                solve( 1, x, y+1 );\n            } else if ( check(x, y+2) && line[y+2][x] == '1' ) {\n                solve( 0, x, y+2 );\n            } else if ( check(x-1, y+1) && line[y+1][x-1] == '1' ) {\n                solve( 0, x-1, y+1 );\n            }\n        }\n    }\n}\n\nint main() {\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> line[i];\n    }\n\n    cnt = 0;\n    solve( 1, 0, 0 );\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\nusing namespace std;\n\nint dir = 0;\nint cur_x;\nint cur_y;\nint cur_side;\n\nint refd[] = {0, 1, 0, 1};\nint refx[] = {0, 0, -1, 0};\nint refy[] = {0, 0, 0, -1};\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar ans[] = \"RDLU\";\n\nbool WithinRange(int d, int y, int x) {\n  if (x < 0) return false;\n  if (y < 0) return false;\n\n  if (d == 0) { \n    if (x >= 4) return false;\n    if (y >= 5) return false;\n  } else {\n    if (x >= 5) return false;\n    if (y >= 4) return false;\n  }\n  return true;\n}\n\nchar walls[2][5][5];\n\nint main() {\n  for (int i=0; i<9; i++) {\n    int n = i%2 ? 5: 4;\n    for (int j=0; j<n; j++) {\n      scanf(\" %c\", &walls[i%2][i/2][j]);\n    }\n  }\n\n  cur_side = -1;\n  while (1) {\n    int a, b, c;\n\n    for (int i=0; i<4; i++) {\n      int ndir = (dir+3+i)%4;\n\n      a = refd[ndir];\n      b = cur_y + refy[ndir];\n      c = cur_x + refx[ndir];\n      if (WithinRange(a, b, c) && walls[a][b][c] == '1') {\n        cur_y += dy[ndir];\n        cur_x += dx[ndir];\n        printf(\"%c\", ans[ndir]);\n        dir = ndir;\n        break;\n      }\n    }\n\n    //printf(\"(%d, %d)\\n\", cur_y, cur_x);\n    if (cur_y == 0 && cur_x == 0) break;\n  }\n  puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<deque>\nusing namespace std;\n#define MAX_MAP 10\n\ndeque<string> map;\n\nint y=0,x=-1,vec=0;\nstring v=\"RULD\";\nint dvx[4]={1,0,-1,0};\nint dvy[4]={0,-1,0,1};\n\nbool wall_front(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\t//cout<<map[y*2+1]<<\" \"<<(x+2)<<endl;\n\t\tif(map[y*2+1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+2][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_straight(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[y*2+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[y*2-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[y*2][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[y*2+3][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nbool wall_rightAngle(){\n\tswitch(vec){\n\tcase 0:\n\t\tif(map[(y*2+1)+2][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 1:\n\t\tif(map[(y*2+1)-1][(x+2)+1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 2:\n\t\tif(map[(y*2)-1][(x+2)]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\tcase 3:\n\t\tif(map[(y*2+1)+1][(x+2)-1]=='1'){\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n\n\nvoid go_straight(){\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\nvoid go_straight_move(){\n\ty+=dvy[vec];\n\tx+=dvx[vec];\n\t//cout<<\"move now_pos=\"<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n}\n\nvoid solve(){\n\tint count=0;\n\twhile(y!=1||x!=-1){\n\t\tif(count>100)break;\n\t\t//cout<<y<<\" \"<<x<<\" \"<<v[vec]<<endl;\n\t\tif(wall_front()){\n\t\t\t//cout<<\"front\"<<endl;\n\t\t\tvec++;\n\t\t\tvec=vec%4;\n\t\t\tcout<<v[vec];\n\t\t}else if(wall_straight()){\n\t\t\t//cout<<\"straight\"<<endl;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}else if(wall_rightAngle()){\n\t\t\t//cout<<\"right\"<<endl;\n\t\t\tgo_straight_move();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}else{\n\t\t\t//cout<<\"turn\"<<endl;\n\t\t\tgo_straight();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//cout<<v[vec];\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight_move();\n\t\t\tif(y==1&&x==-1){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec+=3;\n\t\t\tvec=vec%4;\n\t\t\tgo_straight();\n\t\t\tcout<<v[vec];\n\t\t}\n\t\tcount++;\n\t}\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin.eof()!=true){\n\t\tcin>>s;\n\t\ts=\"00\"+s+\"00\";\n\t\tmap.push_back(s);\n\t}\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_front(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\tmap.push_back(\"000000000000000000000\");\n\t/*\n\tfor(int i=0;i<map.size();i++){\n\t\tcout<<map[i]<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nchar dc[] = \"RDLU\";\n\nint main() {\n\tint g[11][11] = {};\n\tchar c;\n\tfor (int i=1; i<10; ++i) {\n\t\tint k = i % 2; // 0=vertical, 1=horizontal\n\t\tfor (int j=1+k; j<=9-k; j+=2) {\n\t\t\tcin >> c;\n\t\t\tg[i][j] |= c - '0';\n\t\t\tg[i-1+k][j-k] |= c - '0';\n\t\t\tg[i+1-k][j+k] |= c - '0';\n\t\t}\n\t}\n\tint x=1, y=1, d=0;\n\tdo {\n\t\tfor (int t=d+3; ; ++t) {\n\t\t\tif (g[y + dy[t%4]][x + dx[t%4]]) {\n\t\t\t\td = t%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx += dx[d] * 2;\n\t\ty += dy[d] * 2;\n\t\tcout << dc[d];\n\t} while (x != 1 || y != 1);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 100 \nusing namespace std;\n\nstruct You\n{//??????????????????????????§?¨????dx[(dir+1)%4],dy[(dir+1)%4]??????????????´???\n  int x,y,dir;\n  You(int x=-inf,int y=-inf):x(x),y(y),dir(0){}\n};\n\nchar G[MAX][MAX];\nint dx[] = {+1,+0,-1,+0};\nint dy[] = {+0,+1,+0,-1};\n\nvoid init()\n{\n  rep(i,MAX)rep(j,MAX)G[i][j] = '.';\n}\n\nvoid makeGraph()\n{\n  string line;\n  int x;\n  REP(y,1,10)\n    {//odd -> yoko, even -> tate\n      cin >> line;\n      x = (y%2?1:0);\n      rep(i,line.size())\n\t{\n\t  if(line[i] == '1')\n\t    {\n\t      G[y][x] = (y%2?'-':'|');\n\t      if(y%2) G[y][x-1] = G[y][x+1] = 'o';\n\t      else    G[y+1][x] = G[y-1][x] = 'o';\n\t    }\n\t  x += 2;\n\t}\n    }\n}\n\nvoid print()\n{\n  rep(i,11)\n    {\n      rep(j,11)\n\t{\n\t  cout << G[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid compute()\n{\n  You you(0,0);\n  bool fir = true;\n  while(true)\n    {\n      int x = you.x,y = you.y,dir = you.dir;\n      int hx = x + dx[(dir+1)%4],hy = y + dy[(dir+1)%4];\n      if(!fir && hx == 0 && hy == 1)\n\t{\n\t  cout << '\\n';\n\t  return;\n\t}\n      fir = false;\n\n      int nx = x + dx[dir],ny = y + dy[dir];\n      hx += dx[dir],hy += dy[dir];\n      assert(G[ny][nx] != 'o');\n\n      if(G[ny][nx] == '|' || G[ny][nx] == '-')\n\t{\n\t  dir = (dir + 3)%4;\n\t  you.dir = dir;\n\t}\n      else if(G[hy][hx] == '.')\n\t{\n\t  dir = (dir + 1)%4;\n\t  you.x = nx + dx[dir], you.y = ny + dy[dir],you.dir = dir;\t  \n\t}\n      else if(G[hy][hx] == 'o' || G[hy][hx] == '-' || G[hy][hx] == '|')\n\t{\n\t  you.x += dx[dir],you.y += dy[dir];\n\t}\n\n      hx = you.x + dx[(dir+1)%4], hy = you.y + dy[(dir+1)%4];\n\n      if(G[hy][hx] != 'o')\n\tcout << (dir==0?'R':(dir==1?'D':(dir==2?'L':'U')));\n    }\n}\n\nint main()\n{\n  init();\n  makeGraph();\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <algorithm>\n\nusing namespace std;\n\nchar x[11][11];\n\nvoid search(int i, int j, int direction);\n\nint main () {\n    \n    for(int i=0; i<11; i++){\n        for(int j=0; j<11; j++){\n            x[i][j]='0';\n        }\n    }\n\n\n    while(cin\n          >>x[1][2]>>x[1][4]>>x[1][6]>>x[1][8]\n          >>x[2][1]>>x[2][3]>>x[2][5]>>x[2][7]>>x[2][9]\n          >>x[3][2]>>x[3][4]>>x[3][6]>>x[3][8]\n          >>x[4][1]>>x[4][3]>>x[4][5]>>x[4][7]>>x[4][9]\n          >>x[5][2]>>x[5][4]>>x[5][6]>>x[5][8]\n          >>x[6][1]>>x[6][3]>>x[6][5]>>x[6][7]>>x[6][9]\n          >>x[7][2]>>x[7][4]>>x[7][6]>>x[7][8]\n          >>x[8][1]>>x[8][3]>>x[8][5]>>x[8][7]>>x[8][9]\n          >>x[9][2]>>x[9][4]>>x[9][6]>>x[9][8]\n          )\n        \n        \n    {\n        search(1, 1, 1);\n        \n    }\n    \n    return 0;\n}\n\nvoid search(int i, int j, int direction){\n    while(1){\n    char around[4];\n    around[0]=x[i-1][j];\n    around[1]=x[i][j+1];\n    around[2]=x[i+1][j];\n    around[3]=x[i][j-1];\n    \n    char output[4]={'U','R','D','L'};\n    int next[4]={0,1,2,3};\n    \n        int move[4][2]={0};\n    if(around[0]=='1'){\n        move[0][0]=i-2;move[0][1]=j;\n    }\n    if(around[1]=='1'){\n        move[1][0]=i;move[1][1]=j+2;\n    }\n    if(around[2]=='1'){\n        move[2][0]=i+2;move[2][1]=j;\n    }\n    if(around[3]=='1'){\n        move[3][0]=i;move[3][1]=j-2;\n    }\n    \n    for(int k=0; k<3; k++){\n        int temp = (direction+3+k)%4;\n        if(around[temp]=='1'){\n            direction=next[temp];\n            i=move[temp][0];\n            j=move[temp][1];\n            cout<<output[temp]<<endl;\n            break;\n        }\n    }\n        if(i==1&&j==1){\n            break;\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[10][10];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U','R','D','L'};\n\nstring res;\nvoid touch_wall (int row, int col, int dir, int hand )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n/*\n\trep (j, 5 ){\n\t\tgrid[0][j] |= 1<<TOP;\n\t\tgrid[5][j] |= 1<<BOTTOM;\n\t} // end rep\n\trep (i, 6 ){\n\t\tgrid[i][0] |= 1<<LEFT;\n\t\tgrid[i][4] |= 1<<RIGHT;\n\t} // end rep\n*/\n\tfor (int i = 1; i <= 9; i++ ){\n\t\tstring s = \"\";\n\t\tcin >> s;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tif (j == 0 ){\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t\tgrid[i/2][j-1] |= 1<<RIGHT;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n/*\n\trep (i, 6 ){\n\t\trep (j, 5 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n*/\n\tint row = 0, col = 0, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tres = \"\";\n\twhile (!(row == 1 && col == 0 && (dir == LEFT ) ) ){\n\t\ttouch_wall (row, col, dir, hand );\n\t\tif ((1<<hand & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった、なくなった方向に回転\n\t\t\tdir = hand;\n\t\t}else\n\t\tif ((1<<dir & grid[row][col] ) != 0 ){\t\n\t\t\twhile ((1<<dir & grid[row][col] ) != 0 ){// 右手の壁があったとしても前に進めない\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand );\n\t\t\t} // end while\n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t} // end while\n\ttouch_wall (row, col, dir, hand );\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <iostream>\n\n\nusing namespace std;\n\n\n\nint main()\n{\n\tbool points[5][5][4];\n\tfor (int i = 0; i < 5; ++i)\n\t\tfor (int j = 0; j < 5; ++j)\n\t\t\tfor (int k = 0; k < 4; ++k)\n\t\t\t\tpoints[i][j][k] = false;\n\n\tfor (int i = 0; i < 9; ++i)\n\t{\n\t\tint y = i/2;\n\t\tif (i%2 == 0)\n\t\t{\n\t\t\tfor (int j = 0; j < 4; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][1] = points[y][j+1][3] = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tint e;\n\t\t\t\tscanf(\"%1d\", &e);\n\t\t\t\tif (e)\n\t\t\t\t\tpoints[y][j][2] = points[y+1][j][0] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint x, y;\n\tx = 1;\n\ty = 0;\n\tint dir = 1;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { -1, 0, 1, 0 };\n\tchar* ds = \"URDL\";\n\tputchar(ds[dir]);\n\twhile (!(x == 0 && y == 0))\n\t{\n\t\tif (points[y][x][(dir+3)%4])\n\t\t\tdir = (dir+3)%4;\n\t\telse if (points[y][x][dir])\n\t\t\t;\n\t\telse if (points[y][x][(dir+1)%4])\n\t\t\tdir = (dir+1)%4;\n\t\telse\n\t\t\tputs(\"owateru\");\n\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tputchar(ds[dir]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\nusing namespace std;\nchar walls[5][5][2];\n\nint main()\n{\n\tint x=0,y=0,flag=1;\n\tstring tmp;\n\tfor(int i = 0; i < 9; ++i)\n\t{\n\t\tflag=(flag+1)%2;\n\t\tcin>>tmp;\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t{\n\t\t\tif(!flag&&j==4) walls[i/2][4][flag]='0';\n\t\t\telse walls[i/2][j][flag]=tmp[j];\n\t\t\t//cin>>walls[i/2][j][flag];\n\t\t}\n\t}\n\n\t/*cout<<\"debug\"<<endl;\t\n\tfor(int i = 0; i < 5; ++i)\n\t{\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t{\n\t\t\tcout<<\" \"<<walls[i][j][0];\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n\tfor(int i = 0; i < 5; ++i)\n\t{\n\t\tfor(int j = 0; j < 5; ++j)\n\t\t{\n\t\t\tcout<<\" \"<<walls[i][j][1];\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\t//cout<<\"end\"<<endl;\n\n\tint dir=0;\n\tbool change=false;\n\tdo {\n\t\tif(dir==0)\n\t\t{\n\t\t\tif(!change&&0<=y-1&&walls[y-1][x][1]=='1') \n\t\t\t{\n\t\t\t\tdir=3;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(x==4||walls[y][x][0]=='0')\n\t\t\t\t{\n\t\t\t\t\tdir=1;\n\t\t\t\t\tchange=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++x;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tchange=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir==1)\n\t\t{\n\t\t\tif(!change&&x<4&&walls[y][x][0]=='1')\n\t\t\t{\n\t\t\t\tdir=0;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y==4||walls[y][x][1]=='0')\n\t\t\t\t{\n\t\t\t\t\tdir=2;\n\t\t\t\t\tchange=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++y;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tchange=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir==2)\n\t\t{\n\t\t\tif(!change&&walls[y][x][1]=='1')\n\t\t\t{\n\t\t\t\tdir=1;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(x==0||walls[y][x-1][0]=='0')\n\t\t\t\t{\n\t\t\t\t\tdir=3;\n\t\t\t\t\tchange=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t--x;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tchange=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(dir==3)\n\t\t{\n\t\t\tif(!change&&0<=x-1&&walls[y][x-1][0]=='1')\n\t\t\t{\n\t\t\t\tdir=2;\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(y==0||walls[y-1][x][1]=='0')\n\t\t\t\t{\n\t\t\t\t\tdir=0;\n\t\t\t\t\tchange=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t--y;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tchange=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<\",x=\"<<x<<\",y=\"<<y<<\",dir=\"<<dir<<endl;\n\t} while(change||x!=0||y!=0);\n\tcout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar horz[5][4+1];\nchar vert[4][5+1];\nint x, y, vx, vy;\n\nvoid turn_left() {\n\tint temp = vx;\n\tvx = vy;\n\tvy = -temp;\n}\n\nvoid turn_right() {\n\tint temp = vx;\n\tvx = -vy;\n\tvy = temp;\n}\n\ninline bool ok(char c) { return (c == '1'); }\n\nbool avail() {\n\tif (vx == 1) return (x < 4 && ok(horz[y][x]));\n\tif (vx == -1) return (x > 0 && ok(horz[y][x-1]));\n\tif (vy == 1) return (y < 4 && ok(vert[y][x]));\n\t/* if (vy == -1) */ return (y > 0 && ok(vert[y-1][x]));\n}\n\nvoid print() {\n\tif (vx == 1) cout << \"R\";\n\telse if (vx == -1) cout << \"L\";\n\telse if (vy == 1) cout << \"D\";\n\telse /* if (vy == -1) */ cout << \"U\";\n}\n\nint main() {\n\tfor (int i = 0; i < 4; i++)\n\t\tcin >> horz[i] >> vert[i];\n\tcin >> horz[4];\n\n\tx=0, y=0, vx=0, vy=-1;\n\tdo {\n\t\twhile (!avail()) turn_right();\n\t\tprint();\n\t\tx += vx, y += vy;\n\t\tturn_left();\n\t} while (x != 0 || y != 0);\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n#define\tE\t0\n#define\tN\t1\n#define\tW\t2\n#define\tS\t3\n\nusing namespace std;\n\nint wall_v[5][5];\t// wall_v[a][b] : æañ ã©çbÔÚÌÇª é©Ç¤© ([a][4]ÍíÉ0)\nint wall_h[5][5];\t// wall_h[a][b] : æas ¶©çbÔÚÌÇª é©Ç¤© ([a][4]ÍíÉ0)\n\nbool isRightWall(int x,int y,int dir){\n\tif(dir==N)\ty--;\n\tif(dir==W)\tx--;\n\tif(y<0 || 4<y || x<0 || 4<x)\treturn false;\n\n\tif(dir==E)\treturn wall_h[y][x];\n\tif(dir==N)\treturn wall_v[x][y];\n\tif(dir==W)\treturn wall_h[y][x];\n\tif(dir==S)\treturn wall_v[x][y];\n}\n\nbool isForwardWall(int x,int y,int dir){\n\tif(dir==E)\ty--;\n\tif(dir==N)\tx--;\n\tif(y<0 || 4<y || x<0 || 4<x)\treturn false;\n\n\tif(dir==E)\treturn wall_v[x][y];\n\tif(dir==N)\treturn wall_h[y][x];\n\tif(dir==W)\treturn wall_v[x][y];\n\tif(dir==S)\treturn wall_h[y][x];\n}\n\nbool isBackwardWall(int x,int y,int dir){\n\tif(dir==W)\ty--;\n\tif(dir==S)\tx--;\n\tif(y<0 || 4<y || x<0 || 4<x)\treturn false;\n\n\tif(dir==E)\treturn wall_v[x][y];\n\tif(dir==N)\treturn wall_h[y][x];\n\tif(dir==W)\treturn wall_v[x][y];\n\tif(dir==S)\treturn wall_h[y][x];\n}\n\nvoid goRight(int &x,int &y,int &dir){\n\tif(dir==E)\ty++;\n\tif(dir==N)\tx++;\n\tif(dir==W)\ty--;\n\tif(dir==S)\tx--;\n\tdir=(dir+3)%4;\n}\n\nvoid goForward(int &x,int &y,int &dir){\n\tif(dir==E)\tx++;\n\tif(dir==N)\ty--;\n\tif(dir==W)\tx--;\n\tif(dir==S)\ty++;\n}\n\nvoid goLeft(int &x,int &y,int &dir){\n\tif(dir==E)\ty--;\n\tif(dir==N)\tx--;\n\tif(dir==W)\ty++;\n\tif(dir==S)\tx++;\n\tdir=(dir+1)%4;\n}\n\nvoid goBackward(int &x,int &y,int &dir){\n\tif(dir==E)\tx--;\n\tif(dir==N)\ty++;\n\tif(dir==W)\tx++;\n\tif(dir==S)\ty--;\n\tdir=(dir+2)%4;\n}\n\nint main()\n{\n\tfor(int i=0;i<9;i++){\n\t\tchar s[8];\tcin>>s;\n\t\tif(i%2==0){\n\t\t\tfor(int j=0;j<4;j++)\twall_h[i/2][j]=s[j]-'0';\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++)\twall_v[j][i/2]=s[j]-'0';\n\t\t}\n\t}\n\n\tint x=0,y=0,dir=0;\n\tdo{\n\t\tif(!isForwardWall(x,y,dir)){\n\t\t\tif(!isRightWall(x,y,dir)){\n\t\t\t\tif(!isBackwardWall(x,y,dir))\n\t\t\t\t\t\tgoBackward(x,y,dir);\n\t\t\t\telse\tgoRight(x,y,dir);\n\t\t\t}\n\t\t\telse\t\tgoForward(x,y,dir);\n\t\t}\n\t\telse\t\t\tgoLeft(x,y,dir);\n\n\t\tswitch(dir){\n\t\t\tcase E:\tcout<<'R';\tbreak;\n\t\t\tcase N:\tcout<<'U';\tbreak;\n\t\t\tcase W:\tcout<<'L';\tbreak;\n\t\t\tcase S:\tcout<<'D';\tbreak;\n\t\t}\n\t}while(!(x==0&&y==0));\n\tcout<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nint map[11][11]={-1};\nint point[2]={1,1};\nint m=0;//向き→0↓1←2↑3\nint date[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nchar cdate[4]={'R','D','L','U'};\n\n\nbool fun()\n{\n\n\tm=(m+2)%4;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tm=(m+1)%4;\n\t\tif(map[point[1]+date[m][1]][point[0]+date[m][0]]==1)\n\t\t{\n\t\t\tpoint[0]+=2*date[m][0];\n\t\t\tpoint[1]+=2*date[m][1];\n\t\t\tprintf(\"%c\",cdate[m]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(point[0]==1&&point[1]==1)return false;\n\telse true;\n}\n\nint main()\n{\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tchar c[15];\n\t\tscanf(\"%s\",c);\n\t\tfor(int j=0;j<4;j++)\n\t\t{\n\t\t\tmap[i*2+1][(j+1)*2]=c[j]-'0';\n\t\t}\n\t\tif(i!=4)\n\t\t{\n\t\t\tscanf(\"%s\",c);\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tmap[(i+1)*2][j*2+1]=c[j]-'0';\n\t\t\t}\n\t\t}\n\t}\n\n\tfun();\n\twhile(fun()){};\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nvoid move(int,int,char);\nchar det_angle(int,int,char);\n\nchar perm_angle[4] = {'R','U','L','D'};\nint grid[5][5][4] = {0};\n\nint main(){\n\n\tint flag;\n\tfor(int i=0;i<9;i++){\n\t\tif(i%2 == 0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag);\n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"+\";\n\t\t\t\t\tgrid[i/2][j][0]  = 1; //R\n\t\t\t\t\tgrid[i/2][j+1][2]= 1; //L\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag); \n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"-\";\n\t\t\t\t\tgrid[i/2][j][3]  = 1; //D\n\t\t\t\t\tgrid[i/2+1][j][1]= 1; //U\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout << 'R';\n\tmove(0,1,'R');\n\t//cout << endl;\n}\n\nvoid move(int x,int y,char angle){\n\tif(x == 0 && y== 0){\n\t\tcout << endl;\n\t\texit(0);\n\t}\n\t\n\tcout << angle;\n\t\n\tif(angle == 'R'){\n\t\t++y;\n\t}\n\telse if(angle == 'U'){\n\t\t--x;\n\t}\n\telse if(angle == 'L'){\n\t\t--y;\n\t}\n\telse if(angle == 'D'){\n\t\t++x;\n\t}\n\t//cout << \"test\" << x <<\" \" << y;\n\tmove(x,y,det_angle(x,y,angle));\n\t//cout << angle << endl; \n}\n\nchar det_angle(int x,int y,char angle){\n\t\n\t//cout << x << y << \" \" << angle << endl;\n\tint start;\n\tif(angle == 'R'){\n\t\tstart = 5;\n\t}\n\telse if(angle == 'U'){\n\t\tstart = 6;\n\t}\n\telse if(angle == 'L'){\n\t\tstart = 7;\t\n\t}\n\telse if(angle == 'D'){\n\t\tstart = 4;\n\t}\n\t//cout << start << endl;\n\tfor(int i = start;start - i < 4 ;--i){\n\t\tif(grid[x][y][i%4] == 1){\n\t\t\t//cout << \"kettei\" << i <<endl ;\n\t\t\treturn perm_angle[i%4];\n\t\t}\n\t}\n\treturn 'Z';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n\nint main()\n{\n\tint field[5][5] = {{0}};\n\trep(i, 9){\n\t\tchar str[6];\n\t\tscanf(\"%s\", str);\n\t\tif(i%2){\n\t\t\trep(j, 5){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<2;\n\t\t\t\tfield[i/2+1][j] |= a;\n\t\t\t}\n\t\t}else{\n\t\t\trep(j, 4){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<1;\n\t\t\t\tfield[i/2][j+1] |= a<<3;\n\t\t\t}\n\t\t}\n\t}\n\n\tputchar('R');\n\tint y=0, x=1;\n\tint pre = 1;\n\tbool right = false;\n\tdo{\n\t\t// printf(\"(%d, %d)\\n\", x, y);\n\t\tpre = (pre+2)%4;\n\t\tint dire = pre;\n\t\tdo{\n\t\t\tdire = (dire + right*2+1)%4;\n\t\t}while(!((field[y][x]>>dire)&1));\n\t\tif(dire == pre)\n\t\t\tright = !right;\n\t\tpre = dire;\n\t\tputchar(\"URDL\"[dire]);\n\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx += dx[dire];\n\t\ty += dy[dire];\n\t}while((y!=0 || x!=0) && !right);\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst char dir[] = \"RDLU\";\n\nint main()\n{\n    string input;\n\n    while (cin >> input) {\n        bool map[5][5][4];\n\n        // Initialization\n        for (int i = 0; i < 5; i++)\n            for (int j = 0; j < 5; j++)\n                for (int k = 0; k < 4; k++)\n                    map[i][j][k] = false;\n\n        // Input (0,0) - (0,4)\n        for (int i = 0; i < 4; i++) \n            if (input[i] == '1') {\n                map[0][i][0] = true;\n                map[0][i + 1][2] = true;\n            }\n\n        // Input Others\n        for (int i = 0; i < 8; i++) {\n            cin >> input;\n            int lim;\n            (i % 2) ? (lim = 4) : (lim = 5);\n\n            for (int j = 0; j < lim; j++)\n                if (input[j] == '1') {\n                    if (i % 2) {\n                        map[(i + 1) / 2][j][0] = true;\n                        if (j)\n                            map[(i + 1) / 2][j + 1][2] = true;\n                    }\n                    else {\n                        map[i / 2][j][1] = true;\n                        map[(i / 2) + 1][j][3] = true;\n                    }\n                }\n        }\n\n        // algorithm\n        int x, y, d;\n\n        x = y = d = 0;\n        // do {\n        //     if (map[y][x][d])\n        //         ;\n        //     else if (map[y][x][(d + 1) % 4]) \n        //         d = (d + 1) % 4;\n        //     else if (map[y][x][(d + 3) % 4]) \n        //         d = (d + 3) % 4;\n\n            // map[y][x][d] = false;\n            // x += dx[d];\n            // y += dy[d];\n            // cout << dir[d];\n        // } while (x || y);\n        do {\n            int del = (d + 3) % 4;\n            for (int i = 0; i < 4; i++) \n                if (map[y][x][(del + i) % 4]) {\n                    d = (del + i) % 4;\n                    break;\n                }\n\n            map[y][x][d] = false;\n            x += dx[d];\n            y += dy[d];\n            cout << dir[d];\n        } while (x || y);\n\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>//////////AOJ0037\n                               int\ni,j,w[5][5];char*p,b[1<<7];;   int\nF(int(v)){scanf(\"%s\",b);for(   p=b\n;*p;++p                 ){w[   p-b\n+1-v][j   +v]|=((w[p-   b][j   ]|=\n(*p==49   )<<3-v)&8>>   v)>>   2;}\nreturn(   j+=v          );/*   */}\nmain(){   for(   ;4-F   (0);   F(1\n));for(   p=b,   i=j=   (*b=   3)^\n3;i+=\"\"   \"BA\"          \"BC\"   [*b\n]-66,j=   (*b)[\"ABCB\"]-66+j,   *++\np=\"ULDR   \"[*b],i+j;)for((*    b+=\n1)&=~4;                        !(w\n[i][j]&(1<<*b));(*b+=3)&=3);return\n!puts(b+1);}///////05-2018,@siikya\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nstring e = \"RDLU\";\nstring s[9]; bool d[6][6][4];\nint main() {\n\tfor (int i = 0; i < 9; i++) cin >> s[i];\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[i * 2][j] == '1') d[i][j + 1][1] = d[i + 1][j + 1][3] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tif (s[i * 2 + 1][j] == '1') d[i + 1][j][0] = d[i + 1][j + 1][2] = true;\n\t\t}\n\t}\n\tstring ret = \"R\";\n\tint x = 0, y = 1, dr = 0;\n\twhile (true) {\n\t\tif (d[x][y][dr]) dr = (dr + 3) & 3, ret += e[dr];\n\t\telse {\n\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\tif (x == 1 && y == 0) break;\n\t\t\tint cnt = 0;\n\t\t\twhile (!d[x][y][(dr + 1) & 3]) {\n\t\t\t\tdr = (dr + 1) & 3;\n\t\t\t\tx += dir[dr], y += dir[dr ^ 1];\n\t\t\t\tif (x == 1 && y == 0) break;\n\t\t\t}\n\t\t\tret += e[dr];\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\nenum direction\n{\n\tL, R, U, D\n};\nint main()\n{\n\tint wall[9][5];\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tstd::string foo;\n\t\tstd::cin >> foo;\n\t\tstd::stringstream bar(foo);\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tchar baz;\n\t\t\tbar >> baz;\n\t\t\twall[i][j] = static_cast<int>(baz - '0');\n\t\t\tif (i % 2 == 0 && j == 3 || j == 4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdirection dir = R;\n\tint crd[2] = { 0,0 };\n\twhile (true)\n\t{\n\t\tswitch (dir)\n\t\t{\n\t\tcase L:\n\t\t\tif (crd[1] != 8 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tdir = D;\n\t\t\t}\n\t\t\telse if (crd[0] == 0 || wall[crd[1]][crd[0] - 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tdir = U;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tif (crd[1] != 0 && wall[crd[1] - 1][crd[0] + 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tdir = U;\n\t\t\t}\n\t\t\telse if (crd[0] == 3 || wall[crd[1]][crd[0] + 1] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tdir = D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[0]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tif (crd[0] != 0 && wall[crd[1] - 1][crd[0] - 1] == 1)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tdir = L;\n\t\t\t}\n\t\t\telse if (crd[1] == 1 || wall[crd[1] - 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[1]--;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tdir = R;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] -= 2;\n\t\t\t\tstd::cout << 'U';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tif (crd[0] != 4 && wall[crd[1] + 1][crd[0]] == 1)\n\t\t\t{\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tdir = R;\n\t\t\t}\n\t\t\telse if (crd[1] == 7 || wall[crd[1] + 2][crd[0]] == 0)\n\t\t\t{\n\t\t\t\tcrd[0]--;\n\t\t\t\tcrd[1]++;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tdir = L;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcrd[1] += 2;\n\t\t\t\tstd::cout << 'D';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (crd[0] == 0 && crd[1] == 0)\n\t\t{\n\t\t\tstd::cout << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\t\tchar yoko[10][10];\n\t\tchar tate[10][10];\n\t\tmemset(yoko,0,sizeof(yoko));\n\t\tmemset(tate,0,sizeof(tate));\n\t\t\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tyoko[i][j]=c;\n\t\t\t}\n\t\t\tif(i!=4){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin>>c;\n\t\t\t\t\ttate[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tif(cin.eof())\n\t//\t\tbreak;\n\t\t\n\t\t\n\t\t// 0,1,2,3ÅEAºA¶Aã\n\t\tint angle=0;\n\t\tint px,py;\n\t\tpx=py=0;\n\t\twhile(1){\n\t\t\tif(angle==0){\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ãÖ\n\t\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// º\n\t\t\telse if(angle==1){\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\tpy++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ¶\n\t\t\telse if(angle==2){\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t\t// ãÖ\n\t\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t\tangle=3;\n\t\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ã\n\t\t\telse if(angle==3){\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t\tpy--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\t\tangle=2;\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\t\tangle=0;\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t\tangle=1;\n\t\t\t\t\t\tcout<<\"D\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(px==0&&py==0)\n\t\t\t\tbreak;\n}\n//cout<<endl;\nbreak;\n\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 100 \nusing namespace std;\n\nstruct You\n{//手の位置は自分の座標にdx[(dir+1)%4],dy[(dir+1)%4]を加えた場所\n  int x,y,dir;\n  You(int x=-inf,int y=-inf):x(x),y(y),dir(0){}\n};\n\nchar G[MAX][MAX];\nint dx[] = {+1,+0,-1,+0};\nint dy[] = {+0,+1,+0,-1};\n\nvoid init()\n{\n  rep(i,MAX)rep(j,MAX)G[i][j] = '.';\n}\n\nvoid makeGraph()\n{\n  string line;\n  int x;\n  REP(y,1,10)\n    {//odd -> yoko, even -> tate\n      cin >> line;\n      x = (y%2?1:0);\n      rep(i,line.size())\n\t{\n\t  if(line[i] == '1')\n\t    {\n\t      G[y][x] = (y%2?'-':'|');\n\t      if(y%2) G[y][x-1] = G[y][x+1] = 'o';\n\t      else    G[y+1][x] = G[y-1][x] = 'o';\n\t    }\n\t  x += 2;\n\t}\n    }\n}\n\nvoid print()\n{\n  rep(i,11)\n    {\n      rep(j,11)\n\t{\n\t  cout << G[i][j];\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid compute()\n{\n  You you(0,0);\n  bool fir = true;\n  while(true)\n    {\n      int x = you.x,y = you.y,dir = you.dir;\n      //cout << \"cur  | (\" << x << \",\" << y << \") = \" << G[y][x] << endl;\n      int hx = x + dx[(dir+1)%4],hy = y + dy[(dir+1)%4];\n      //cout << \"hand | (\" << hx << \",\" << hy <<\") = \" << G[hy][hx]<< endl;\n      if(!fir && hx == 0 && hy == 1)\n\t{\n\t  cout << '\\n';\n\t  return;\n\t}\n      fir = false;\n\n      int nx = x + dx[dir],ny = y + dy[dir];\n      hx += dx[dir],hy += dy[dir];\n      assert(G[ny][nx] != 'o');\n\n      if(G[ny][nx] == '|' || G[ny][nx] == '-')\n\t{\n\t  dir = (dir + 3)%4;\n\t  you.dir = dir;\n\t}\n      else if(G[hy][hx] == '.')\n\t{\n\t  dir = (dir + 1)%4;\n\t  you.x = nx + dx[dir], you.y = ny + dy[dir],you.dir = dir;\t  \n\t}\n      else if(G[hy][hx] == 'o' || G[hy][hx] == '-' || G[hy][hx] == '|')\n\t{\n\t  you.x += dx[dir],you.y += dy[dir];\n\t}\n\n      hx = you.x + dx[(dir+1)%4], hy = you.y + dy[(dir+1)%4];\n\n      if(G[hy][hx] != 'o')\n\tcout << (dir==0?'R':(dir==1?'D':(dir==2?'L':'U')));\n      //cout << endl;\n    }\n}\n\nint main()\n{\n  init();\n  makeGraph();\n  compute();\n  //print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring yoko[5];\nstring tate[4];\nint x = 0;\nint y = 0;\nchar d;\n\nvoid left()\n{\n\tx--;\n\td = 'L';\n\tcout << 'L';\n}\nvoid right()\n{\n\tx++;\n\td = 'R';\n\tcout << 'R';\n}\nvoid up()\n{\n\ty--;\n\td = 'U';\n\tcout << 'U';\n}\nvoid down()\n{\n\ty++;\n\td = 'D';\n\tcout << 'D';\n}\n\nint main()\n{\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tif (i % 2 == 0) cin >> yoko[i / 2];\n\t\telse cin >> tate[i / 2];\n\t}\n\n\tright();\n\n\twhile (true)\n\t{\n\t\tif (d == 'R')\n\t\t{\n\t\t\tif (y != 0 && tate[y - 1][x] == '1')  up();\n\t\t\telse if (x != 4 && yoko[y][x] == '1') right();\n\t\t\telse if (y != 4 && tate[y][x] == '1') down();\n\t\t\telse\t\t\t\t\t\t\t\t  left();\n\t\t}\n\t\telse if (d == 'L')\n\t\t{\n\t\t\tif (y != 4 && tate[y][x] == '1')\t\t  down();\n\t\t\telse if (x != 0 && yoko[y][x - 1] == '1') left();\n\t\t\telse if (y != 0 && tate[y - 1][x] == '1') up();\n\t\t\telse\t\t\t\t\t\t\t\t\t  right();\n\t\t}\n\t\telse if (d == 'U')\n\t\t{\n\t\t\tif (x != 0 && yoko[y][x - 1] == '1')\t  left();\n\t\t\telse if (y != 0 && tate[y - 1][x] == '1') up();\n\t\t\telse if (x != 4 && yoko[y][x] == '1')\t  right();\n\t\t\telse\t\t\t\t\t\t\t\t\t  down();\n\t\t}\n\t\telse if (d == 'D')\n\t\t{\n\t\t\tif (x != 4 && yoko[y][x] == '1')\t\t  right();\n\t\t\telse if (y != 4 && tate[y][x] == '1')\t  down();\n\t\t\telse if (x != 0 && yoko[y][x - 1] == '1') left();\n\t\t\telse\t\t\t\t\t\t\t\t\t  up();\n\t\t}\n\n\t\tif (x == 0 && y == 0) break;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \nint main(void){\n  int state; //ツ前ツ嘉アツづ個督ョツつ「ツつスツ陛サツ古シ\n  int x, y; //current position\n  bool horizon[5][4];\n  bool vertical[4][5];\n  char tmp;\n  int i,j;\n \n  for(i=0;i<9;i++){\n\tif(i%2 == 0){\n\t  for(j=0;j<4;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  horizon[i/2][j] = true;\n\t\t}else{\n\t\t  horizon[i/2][j] = false;\n\t\t}\n\t  }\n\t}else{\n\t  for(j=0;j<5;j++){\n\t\tcin >> tmp;\n\t\tif(tmp == '1'){\n\t\t  vertical[i/2][j] = true;\n\t\t}else{\n\t\t  vertical[i/2][j] = false;\n\t\t}\n\t  }\n\t}\n  }\n \n  state = 'R';\n  cout << \"R\";\n  x = 0;\n  y = 1;\n \n  while(!(x == 0 && y == 0)){\n\tif(state == 'R'){\n\t  if(x - 1 >= 0 && vertical[x-1][y] ){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else{\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }\n\t}else if(state == 'D'){\n\t  if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else if( y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else{\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }\n\t}else if(state == 'L'){\n\t  if(x <= 3 && vertical[x][y]){\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }else if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else if(x >= 1 && vertical[x-1][y]){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else{\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }\n\t}else{\n\t  if(y >= 1 && horizon[x][y-1]){\n\t\tstate = 'L';\n\t\ty--;\n\t\tcout << \"L\";\n\t  }else if(x >= 1 && vertical[x-1][y]){\n\t\tstate = 'U';\n\t\tx--;\n\t\tcout << \"U\";\n\t  }else if(y <= 3 && horizon[x][y]){\n\t\tstate = 'R';\n\t\ty++;\n\t\tcout << \"R\";\n\t  }else{\n\t\tstate = 'D';\n\t\tx++;\n\t\tcout << \"D\";\n\t  }\n\t}\n\t//cout << x << \" \" << y << endl;\n\t//cin >> i;\n  }\n  cout << endl;\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#define int long long\nint gd(int d, vector<int> w){\n\tif(w[(d+1)%4]==1) return (d+1)%4;\n\telse if(w[d]==1) return d;\n\telse if(w[(d+3)%4]==1) return (d+3)%4;\n\telse return (d+2)%4;\n};\nsigned main(){\n\tchar buf[256];\n\tvector<vector<vector<int>>> rms(5,vector<vector<int>>(5, vector<int>(4,0)));\n\tfor(int i=0;i<9;i++){\n\t\tscanf(\"%s\",buf);\n\t\tif(i%2==0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(buf[j]=='1'){\n\t\t\t\t\trms[i/2][j][0] = 1;\n\t\t\t\t\trms[i/2][j+1][2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tif(buf[j]=='1'){\n\t\t\t\t\trms[i/2][j][3] = 1;\n\t\t\t\t\trms[i/2+1][j][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint x=0,y=0,d=0;\n\twhile(true){\n\t\td = gd(d,rms[y][x]);\n\t\tif(d==0){cout<<\"R\"; x++;}\n\t\telse if(d==1){cout<<\"U\"; y--;}\n\t\telse if(d==2){cout<<\"L\"; x--;}\n\t\telse {cout<<\"D\"; y++;}\n\t\tif(x==0&&y==0) break;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "hoge"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nconst int horz_node_count = 5;\nconst int vert_node_count = 5;\nconst int direction_count = 4;\t// [0]:left, [1]:up, [2]:right [3]:down\nenum { left, up, right, down };\n\nint index(int x, int y, int direction)\n{\n\treturn (y * horz_node_count + x) * direction_count + direction;\n}\n\nvoid read_data(int* walls)\n{\n\tstd::vector<std::string> input;\n\tfor (int i = 0; i < vert_node_count * 2 - 1; ++i) {\n\t\tstd::string line;\n\t\tif (std::getline(std::cin, line)) {\n\t\t\tinput.push_back(line);\n\t\t}\n\t}\n\n\tstd::fill_n(walls, horz_node_count * vert_node_count * direction_count, 0);\n\n\tfor (int y = 0; y < vert_node_count; ++y) {\n\t\tfor (int x = 0; x < horz_node_count - 1; ++x) {\n\t\t\tif (input[y*2][x] == '1') {\n\t\t\t\twalls[index(x,y,right)] = 1;\n\t\t\t\twalls[index(x+1,y,left)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = 0; y < vert_node_count - 1; ++y) {\n\t\tfor (int x = 0; x < horz_node_count; ++x) {\n\t\t\tif (input[y*2+1][x] == '1') {\n\t\t\t\twalls[index(x,y,down)] = 1;\n\t\t\t\twalls[index(x,y+1,up)] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool wall_exists(const int* walls, int x, int y, int direction)\n{\n\treturn (0 <= x && x < horz_node_count)\n\t\t&& (0 <= y && y < vert_node_count)\n\t\t&& (walls[index(x,y,direction)] != 0);\n}\n\nint main()\n{\n\tint walls[horz_node_count * vert_node_count * direction_count] = {};\n\tread_data(walls);\n\n\tint x = 0, y = 0, direction = right;\n\tdo {\n\t\t// determine the next direction\n\t\tdirection = (direction + direction_count - 1) % direction_count;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (wall_exists(walls, x, y, direction)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection = (direction + 1) % direction_count;\n\t\t}\n\t\t// step forward\n\t\tswitch (direction) {\n\t\t\tcase left:\n\t\t\t\t--x;\n\t\t\t\tstd::cout << 'L';\n\t\t\t\tbreak;\n\t\t\tcase up:\n\t\t\t\t--y;\n\t\t\t\tstd::cout << 'U';\n\t\t\t\tbreak;\n\t\t\tcase right:\n\t\t\t\t++x;\n\t\t\t\tstd::cout << 'R';\n\t\t\t\tbreak;\n\t\t\tcase down:\n\t\t\t\t++y;\n\t\t\t\tstd::cout << 'D';\n\t\t\t\tbreak;\n\t\t}\n\t} while (x > 0 || y > 0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//参考http://hadrori.hateblo.jp/entry/aoj0037 \nconst int dx[] ={-1,0,1,0};\nconst int dy[] ={0,-1,0,1};\nint path[16][16][4];//0:L,1:U,2:R,3:D\nint main()\n{\n  char c;\n  for(int i = 0;i <9;i++){\n    if(i%2){\n      for(int j = 0;j < 5;j++){\n\tcin >>c;\n\tif(c =='1'){\n\t  path[i/2][j][3] = 1;\n\t  path[i/2+1][j][1] = 1;\n\t}\n      }\n    }else{\n      for(int j = 0;j < 4;j++){\n\tcin >>c;\n\tif(c =='1'){\n\t  path[i/2][j][2] = 1;\n\t  path[i/2][j+1][0] = 1;\n\t}\n      }\n    }\n  }\n  int x = 0,y = 0,d = 2;\n  /*\n(前の方向：右 の場合)\n進む方向の優先順位は、上、右、下、左となる。\n\n(前の方向：左 の場合)\n進む方向の優先順位は、下、左、上、右となる。\n\n(前の方向：上 の場合)\n進む方向の優先順位は、左、上、右、下となる。\n\n(前の方向：下 の場合)\n  進む方向の優先順位は、右、下、左、上となる。*/\n  string dir =\"LURD\";\n  do{\n    for(int i = 0;i < 4;i++){\n      int dd =(d+i)%4;\n      if(path[y][x][dd]==1){\n\tpath[y][x][dd] -=1;\n\tx +=dx[dd];\n\ty +=dy[dd];\n\td = dd;\n\tcout <<dir[dd];\n\tbreak;\n      }\n    }\n  }while(x||y);\n  cout <<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nbool field[10][6];\nint dir = 1;\nint dx[] = { 0, 1, 0, -1 }, dy[] = { -1, 0, 1, 0 };\nint x = 1, y = 0;\nchar s[5] = \"URDL\";\n\nbool safe( int x, int y )\n{\n\treturn x >= 0 && x < 9 && y >= 0 && y < 9;\n}\n\nchar g[9][9];\n\nint main()\n{\n\tfor( int i = 0; i != 9; ++i )\n\t{\n\t\tstd::string line;\n\t\tstd::cin >> line;\n\n\t\tbool odd = i & 1;\n\t\tfor( int j = !odd; j < 9; j += 2 )\n\t\t{\n\t\t\tg[i][j] = line[j/2] - '0' ? odd ? '|' : '_' : ' ';\n\t\t\tg[i][j+1] = '.';\n\t\t}\n\n\t\tif( !odd )\n\t\t\tg[i][0] = '.';\n\t}\n\t\n\tdo\n\t{\n\t\tint fdir = ( 4 + dir - 1 ) % 4;\n\t\tint fx = x + dx[dir] + dx[fdir], fy = y + dy[dir] + dy[fdir];\n\n\t\tif( !safe( x, y ) || g[y][x] == ' ' )\n\t\t{\n\t\t\tx -= dx[dir], y -= dy[dir], dir = ( dir + 1 ) % 4;\n\t\t\tx += dx[dir], y += dy[dir];\n\t\t}\n\t\telse if( safe( fx, fy ) && ( g[fy][fx] == '_' || g[fy][fx] == '|' ) )\n\t\t{\n\t\t\tstd::cout << s[dir];\n\t\t\tx += dx[dir], y += dy[dir], dir = ( 4 + dir - 1 ) % 4;\n\t\t\tx += dx[dir], y += dy[dir];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx += dx[dir] * 2, y += dy[dir] * 2;\n\t\t\tstd::cout << s[dir];\n\t\t}\n\n\t\tif( x == 1 && y == 0 )\n\t\t{\n\t\t\tstd::cout << s[dir];\n\n\t\t\tbreak;\n\t\t}\n\t}while( true );\n\n\tstd::cout << std::endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\tchar kc[6][6][4];\nint kabe[6][6][4];\nfor(int i=0;i<6;i++){\nfor(int j=0;j<6;j++){\nfor(int k=0;k<4;k++){\n\tkc[i][j][k]=' ';\nkabe[i][j][k]=0;}}}\nfor(int i=0;i<4;i++){\nscanf(\"%c%c%c%c\\n%c%c%c%c%c\\n\",&kc[i+1][1][1],&kc[i+1][2][1],&kc[i+1][3][1],&kc[i+1][4][1],&kc[i+1][1][2],&kc[i+1][2][2],&kc[i+1][3][2],&kc[i+1][4][2],&kc[i+1][5][2]);}\nscanf(\"%c%c%c%c\\n\",&kc[5][1][1],&kc[5][2][1],&kc[5][3][1],&kc[5][4][1]);\nfor(int i=1;i<6;i++){\n\tfor(int j=1;j<6;j++){\n\t\tif(kc[i][j][1]=='1'){kabe[i][j][1]=1;}\n\t\tif(kc[i][j][2]=='1'){kabe[i][j][2]=1;}\n\t}\n}\n\nfor(int i=1;i<6;i++){\nfor(int j=1;j<6;j++){\nkabe[i][j][0]=kabe[i-1][j][2];\nkabe[i][j][3]=kabe[i][j-1][1];}}\nint muki=1;\nint muki2;\nint iti[2]={1,1};\nint idou[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\nstring s=\"\";\nchar a[4]={'U','R','D','L'};\nwhile(1){\nfor(int i=3;i<7;i++){\nmuki2=muki+i;\nmuki2%=4;\nif(kabe[iti[0]][iti[1]][muki2]==1){\ns+=a[muki2];\nmuki=muki2;\niti[0]+=idou[muki][0];\niti[1]+=idou[muki][1];\nbreak;}}\nif(iti[0]==1&&iti[1]==1){break;}}\ncout<<s<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool h[100][100]; // setinel\nbool v[100][100];\n\n\nint main(){\n\tstring str, ans = \"\";\n\tchar dir = 'n';\n\tint mx = 1;\n\tint my = 1;\n\n\tint i = 1;\n\tint j = 1;\n\tint len;\n\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (v[my-1][mx] && dir != 'D' && (dir=='R' || !h[my][mx-1])) {\n\t\t\tdir = 'U';\n\t\t\tmy--;\n\t\t}else if (h[my][mx] && dir != 'L' && (dir=='D' || !v[my-1][mx])) {\n\t\t\tdir = 'R';\n\t\t\tmx++;\n\t\t}else if (v[my][mx] && dir != 'U' && (dir=='L' || !h[my][mx])) {\n\t\t\tdir = 'D';\n\t\t\tmy++;\n\t\t}else if (h[my][mx-1] && dir != 'R' && (dir=='U' || !v[my][mx])) {\n\t\t\tdir = 'L';\n\t\t\tmx--;\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector< vector<int> > map(11, vector<int>(7));\nint direction = 0;   //R:0 L:1 U:2 D:3\nint x = 2, y = 1;\nchar a[4], b[5];\n\n\nvoid init(){\n\tfor (int i = 1; i <= 9; i++)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < 4; ++j)map[i][j + 1] = char(a[j]) - '0';\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcin >> b;\n\t\t\tfor (int j = 0; j < 5; ++j)map[i][j + 1] = char(b[j]) - '0';\n\t\t}\n\t}\n}\n\nvoid Right()\n{\n\tif (map[y - 1][x])direction = 2, y -= 2, cout << 'U';\n\telse if (map[y][x])direction = 0, x += 1, cout << 'R';\n\telse if (map[y + 1][x])direction = 3, y += 2, cout << 'D';\n\telse  direction = 1, x -= 1, cout << 'L';\n}\n\nvoid Left()\n{\n\tif (map[y + 1][x])direction = 3, y += 2, cout << 'D';\n\telse if (map[y][x - 1])direction = 1, x -= 1, cout << 'L';\n\telse if (map[y - 1][x])direction = 2, y -= 2, cout << 'U';\n\telse direction = 0, x += 1, cout << 'R';\n}\n\nvoid Up()\n{\n\tif (map[y][x - 1])direction = 1, x -= 1, cout << 'L';\n\telse if (map[y - 1][x])direction = 2, y -= 2, cout << 'U';\n\telse if (map[y][x])direction = 0, x += 1, cout << 'R';\n\telse direction = 3, y += 2, cout << 'D';\n}\n\nvoid Down()\n{\n\tif (map[y][x])direction = 0, x += 1, cout << 'R';\n\telse if (map[y + 1][x])direction = 3, y += 2, cout << 'D';\n\telse if (map[y][x - 1])direction = 1, x -= 1, cout << 'L';\n\telse direction = 2, y -= 2, cout << 'U';\n}\n\n\nvoid solve()\n{\n\twhile (!(x == 1 && y == 1))\n\t{\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 0: Right(); break;\n\t\t\tcase 1: Left(); break;\n\t\t\tcase 2: Up(); break;\n\t\t\tcase 3: Down(); break;\n\t\t\tdefault: return;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\n\tcout << 'R';\n\tsolve();\n\tcout << endl;\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n#define TOP 0\n#define RIGHT 1\n#define BOTTOM 2\n#define LEFT 3\n#define DEBUG2 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.Path_on_a_Grid\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nint grid[10][10];\nconst int dr[] = {-1, 0, 1, 0 };\nconst int dc[] = { 0, 1, 0,-1 };\nconst char Dir[] = { 'U','R','D','L'};\n\nvoid touch_wall (int row, int col, int dir, int hand, string & res )\n{\n\tif ((1<<hand & grid[row][col] ) != 0 )\n\t\tres += Dir[dir];\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (grid, 0, sizeof (grid ) );\n/*\n\trep (j, 5 ){\n\t\tgrid[0][j] |= 1<<TOP;\n\t\tgrid[5][j] |= 1<<BOTTOM;\n\t} // end rep\n\trep (i, 6 ){\n\t\tgrid[i][0] |= 1<<LEFT;\n\t\tgrid[i][4] |= 1<<RIGHT;\n\t} // end rep\n*/\n\tfor (int i = 1; i <= 9; i++ ){\n\t\tstring s = \"\";\n\t\tcin >> s;\n\t\trep (j, s.length() ){\n\t\t\tif (i % 2 != 0 ){\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tgrid[i/2][j] |= 1<<BOTTOM;\n\t\t\t\t\tgrid[(i+1)/2][j] |= 1<<TOP;\n\t\t\t\t} // end if\n\t\t\t}else{\n\t\t\t\tif (s[j] == '1' ){\n\t\t\t\t\tif (j == 0 ){\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgrid[i/2][j] |= 1<<LEFT;\n\t\t\t\t\t\tgrid[i/2][j-1] |= 1<<RIGHT;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end for\n/*\n\trep (i, 6 ){\n\t\trep (j, 5 ){\n\t\t\tcout << setw(2) << grid[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\n*/\n\tint row = 0, col = 0, dir = RIGHT;\n\tint hand = (dir+1)%4;\n\tstring res = \"\";\n\twhile (!(row == 1 && col == 0 && (dir == LEFT ) ) ){\n\t\ttouch_wall (row, col, dir, hand, res );\n\t\tif ((1<<hand & grid[row][col] ) == 0 ){\t// 右手の壁がなくなった\n\t\t\tdir = hand;\n\t\t\twhile ((1<<dir & grid[row][col] ) != 0 ){\t// 進行方向に壁がある\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t} // end while\n\t\t}else\n\t\tif ((1<<dir & grid[row][col] ) != 0 ){\t// 右手の壁があったとしても前に進めない\n\t\t\tdir = (4+dir - 1)%4;\n\t\t\ttouch_wall (row, col, dir, hand, res );\n\t\t\twhile ((1<<dir & grid[row][col] ) != 0 ){\n\t\t\t\tdir = (4+dir-1)%4;\n\t\t\t\ttouch_wall (row, col, dir, hand, res );\n\t\t\t} // end while\n\t\t} // end if\n\t\trow = row + dr[dir];\n\t\tcol = col + dc[dir];\n\t\thand = (dir+1)%4;\n#if DEBUG2\n\t\tcout << '(' << row << ',' << col << ')' << \" dir: \" << dir << endl;\n#endif\n\t} // end while\n\ttouch_wall (row, col, dir, hand, res );\n\n\tcout << res << endl;\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\n//0037\nint main (){\n\tchar wall[9][6] = {'\\0'};\n\tchar state ='R';\n\n\tfor(int i=0; i<9; ++i){\n\t\tcin >> wall[i];\n\t\tif(cin.eof())break;\n\t}\n\n\tint r=0, c=0;\n\tcout << 'R';\n\twhile(1){\n\t\tstatic char state = 'R';\n\n\t\tswitch(state){\n\t\t\tcase 'R':\n\t\t\t\tif(r!=0 && wall[r-1][c+1] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tstate = 'U';\n\t\t\t\t\t++c;\n\t\t\t\t\t--r;\n\t\t\t\t}else if(c!=3 && wall[r][c+1] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\t++c;\n\t\t\t\t}else if(r!=8 && wall[r+1][c+1] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tstate = 'D';\n\t\t\t\t\t++r;\n\t\t\t\t\t++c;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif(c!=5 && wall[r+1][c] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\tstate = 'R';\n\t\t\t\t\t++r;\n\t\t\t\t}else if(r!=7 && wall[r+2][c] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tr+=2;\n\t\t\t\t}else if(c!=0 && wall[r+1][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\tstate = 'L';\n\t\t\t\t\t--c;\n\t\t\t\t\t++r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tif(r!=8 && wall[r+1][c] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tstate = 'D';\n\t\t\t\t\t++r;\n\t\t\t\t}else if(c!=0 && wall[r][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\t--c;\n\t\t\t\t}else if(r!=0 && wall[r-1][c] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tstate = 'U';\n\t\t\t\t\t--r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tif(c!=0 && wall[r-1][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\tstate = 'L';\n\t\t\t\t\t--r;\n\t\t\t\t\t--c;\n\t\t\t\t}else if(r!=1 && wall[r-2][c] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tr-=2;\n\t\t\t\t}else if(c!=4 && wall[r-1][c] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\tstate = 'R';\n\t\t\t\t\t--r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout << \" error \" << endl;\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nbool kawa=0;\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    serch(0,0,0);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n        cout<<\"L\";\n        serch(x-1,y,2);\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1&&side[y-1][x]=='1'){\n        cout<<\"U\";\n        serch(x,y-1,3);\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nvoid serch(int x,int y,int then)\n{\n    if(x==0&&y==0){\n        if(kawa==0)kawa=1;\n        else {\n            cout<<endl;\n            exit(0);\n        }\n    }\n    if(then==0){\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n    }\n    else if(then==1){\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n    }\n    else if(then==2){\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n    }\n    else{\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint a[12][12];\nint dx[4]  = {1,0,-1,0};\nint dy[4]  = {0,1,0,-1};\nchar dc[4] = {'R','D','L','U'};\n\n//©ªÌüÍS}XÌÇÌóÔð²×é\nvoid cheakWall(int* wall , const int& px ,const int& py ,const int& d ){\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = px + dx[(d+i)%4];\n\t\tint my = py + dy[(d+i)%4];\n\t\twall[i] = a[my][mx];\n\t}\n}\n\n//iñ¾ü«ðL^\nvoid record(string& s,int* wall){\n\tif( wall[1] ){\n\t\ts.push_back( dc[d] );\n\t}\n}\n\n//iÞ\nvoid go(int& px, int& py, const int& d,int* wall, string& s){\n\tpx += dx[d]*2;\n\tpy += dy[d]*2;\n\trecord(s,wall);\n}\n\nint main(){\n\tstring s;\n\n\t//zñÌú»\n\tfor(int y=0 ; y<12 ; ++y )\n\t\tfor(int x=0 ; x<12 ; ++x )\n\t\t\ta[y][x] = 0;\n\n\t//üÍ\n\tfor(int i=0 ; i<9 ; ++i ){\n\t\tcin >> s;\n\t\tint y = i+1;\n\t\tint x = (i+1)%2 + 1;\n\t\tfor(int j=0 ; j<(int)s.size() ; ++j , x+=2 ){\n\t\t\ta[y][x] = s[j] - '0';\n\t\t}\n\t}\n\n\tint px = 2, py = 0, d = 0;\n\tbool flag = false;\n\ts.clear();\n\n\twhile( 1 ){\n\t\tif( px == 0 && py == 0 ) break;\n\n\t\tint wall[4]; \n\t\t//©ªÌüèÌóÔ\n\t\tcheakWall( wall , px , py , d );\n\n\t\tif( !wall[1] ){//EªÇ¶áÈ©Á½ç\n\t\t\t//ü«ðEü«Éñé\n\t\t\td = (d+1)%4;\n\t\t\t//iÞ\n\t\t\tgo( px , py , d , wall , s );\n\t\t\tflag = false;\n\t\t}else{\n\t\t\tif( !wall[0] ){//OªÇ¶áÈ©Á½ç\n\t\t\t\t//iÞ\n\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\tflag = false;\n\t\t\t}else{\n\t\t\t\tif( !wall[3] ){//¶ªÇ¶áÈ©Á½ç\n\t\t\t\t\tif( flag == false ){\n\t\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\t\trecord(s,wall);\n\t\t\t\t\t}\n\t\t\t\t\t//ü«ð¶ü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iÞ\n\t\t\t\t\tgo( px , py , d , wall , s );\n\t\t\t\t\tflag = false;\n\t\t\t\t}else{//OEEE¶ªÇ¾Á½ç\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\trecord(s,wall);\n\t\t\t\t\t//ü«ðEü«Éñé\n\t\t\t\t\td = (d+3)%4;\n\t\t\t\t\t//iñ¾ü«ðL^\n\t\t\t\t\ts.push_back( dc[d] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x==0 && y==0 && ((v+loop[i])%4)==2 /*|| ((v+loop[i])%4==1)*/){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nchar s[13][7];\nint order[32] = {0, 1, 2, 3, 0, 3, 2, 1, 2, 1, 0, 3, 2, 3, 0, 1,\n                 3, 0, 1, 2, 3, 2, 1, 0, 1, 0, 3, 2, 1, 2, 3, 0};\nint nds[32] = {4, 0, 7, 1, 6, 1, 5, 0, 5, 2, 6, 3, 7, 3, 4, 2,\n               3, 4, 0, 5, 1, 5, 2, 4, 2, 6, 1, 7, 0, 7, 3, 6};\nint ds[8] = {1, 3, 1, 3, 0, 2, 0, 2};\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar ls[8] = {'R', 'L', 'R', 'L', 'U', 'D', 'U', 'D'};\nint i, j;\n\nbool doesWallExist(int x, int y, int d){\n    // printf(\"%d, %d, %d, %d, %d: \", x, y, d, x+(dx[d]-1)/2, 2*y+(dy[d]-1)/2);\n    if(s[2*y+dy[d]][x+(dx[d]-1)/2] == '1'){\n        //puts(\"o\");\n        return true;\n    }\n    //puts(\"x\");\n    return false;\n}\n\nint main(){\n    for(i=0;i<13;i++){\n        for(j=0;j<7;j++){\n            s[i][j] = '0';\n        }\n    }\n\n    for(i=2;i<=10;i++){\n        int ub = i%2?5:4;\n        for(j=0;j<ub;j++){\n            scanf(\"%c\", &s[i][j+1]);\n        }\n        scanf(\"%*c\");\n    }\n\n    bool f = false;\n    int x = 1, y = 1, d = 0;\n    while(!(x == 1 && y == 1 && f)){\n        if(!f){f = true;}\n\n        // printf(\"%d, %d, %d\\n\", x, y, d);\n        putchar(ls[d]);\n        x += dx[ds[d]]; y += dy[ds[d]];\n\n        for(i=0;i<4;i++){\n            if(doesWallExist(x, y, order[d*4+i])){\n                d = nds[d*4+i];\n                break;\n            }\n        }\n    }\n    puts(\"\");\n\n    /* for(int i=0;i<13;i++){ */\n    /*     for(int j=0;j<7;j++){ */\n    /*         putchar(s[i][j]); */\n    /*     } */\n    /*     puts(\"\"); */\n    /* } */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\n//0037\nint main (){\n\tchar wall[9][6] = {'\\0'};\n\tchar state ='R';\n\n\tfor(int i=0; i<9; ++i){\n\t\tcin >> wall[i];\n\t\tif(cin.eof())break;\n\t}\n\n\tint r=0, c=0;\n\tcout << 'R';\n\twhile(1){\n\t\tstatic char state = 'R';\n\n\t\tswitch(state){\n\t\t\tcase 'R':\n\t\t\t\tif(r!=0 && wall[r-1][c+1] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tstate = 'U';\n\t\t\t\t\t++c;\n\t\t\t\t\t--r;\n\t\t\t\t}else if(c!=3 && wall[r][c+1] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\t++c;\n\t\t\t\t}else if(r!=8 && wall[r+1][c+1] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tstate = 'D';\n\t\t\t\t\t++r;\n\t\t\t\t\t++c;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif(c!=5 && wall[r+1][c] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\tstate = 'R';\n\t\t\t\t\t++r;\n\t\t\t\t}else if(r!=7 && wall[r+2][c] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tr+=2;\n\t\t\t\t}else if(c!=0 && wall[r+1][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\tstate = 'L';\n\t\t\t\t\t--c;\n\t\t\t\t\t++r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tif(r==0 && c==0){\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(r!=8 && wall[r+1][c] == '1'){\n\t\t\t\t\tcout << 'D';\n\t\t\t\t\tstate = 'D';\n\t\t\t\t\t++r;\n\t\t\t\t}else if(c!=0 && wall[r][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\t--c;\n\t\t\t\t}else if(r!=0 && wall[r-1][c] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tstate = 'U';\n\t\t\t\t\t--r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tif(r==0 && c==0){\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif(c!=0 && wall[r-1][c-1] == '1'){\n\t\t\t\t\tcout << 'L';\n\t\t\t\t\tstate = 'L';\n\t\t\t\t\t--r;\n\t\t\t\t\t--c;\n\t\t\t\t}else if(r!=1 && wall[r-2][c] == '1'){\n\t\t\t\t\tcout << 'U';\n\t\t\t\t\tr-=2;\n\t\t\t\t}else if(c!=4 && wall[r-1][c] == '1'){\n\t\t\t\t\tcout << 'R';\n\t\t\t\t\tstate = 'R';\n\t\t\t\t\t--r;\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout << \" error \" << endl;\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "hige"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#endif\n\n#define ITER(c)         __typeof__((c).begin())\n#define FOREACH(it, c)  for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)        __typeof__((c).rbegin())\n#define RFOREACH(it, c) for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)       REPEAT(i, 0, n)\n#define REPEAT(i, k, n) for (int i = (k); i < (n); ++i)\n#define REVREP(i, n)    for (int i = ((n)-1); i >= 0; --i)\n#define FIND(c, n)      std::find((c).begin(), (c).end(), (n));\n#define BSEARCH(c, n)   std::binary_search((c).begin(), (c).end(), (n))\n#define LLPOW(p1,p2)    ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)      (sizeof(A)/sizeof((A)[0]))\n#define MIN(p1,p2)      (((p1)<(p2))?(p1):(p2))\n#define MAX(p1,p2)      (((p1)>(p2))?(p1):(p2))\n#define CIN_NO_SYNC     do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)       fgets((p), sizeof(p), stdin)\n#define CHOMP(p)        do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n') *_q = 0; } while(0)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\n#ifdef _DEBUG\n#define pf printf\n#define pr(n) do { cout << #n \" = \" << (n) << endl; } while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#endif\n\n#define RI  v[0]\n#define UP  v[1]\n#define LE  v[2]\n#define DW  v[3]\n\nint movex[4] = {1, 0,-1, 0};\nint movey[4] = {0,-1, 0, 1};\nconst char *str = \"RULD\";\n\nclass mc {\npublic:\n    int v[4];\n} m[5][5];\n\nint main(){\n    vector<string> sv;\n    string s;\n    cin.binary;\n    while(getline(cin, s)){\n        sv.push_back(s);\n    }\n\n    if(sv.size() != 9) throw;\n\n    for(int i = 0; i < 5; i++){\n        s = sv[i*2];\n        REP(j,4){\n            if(s[j] == '1'){\n                m[i][j].RI = m[i][j+1].LE = 1;\n            }\n        }\n    }\n    for(int i = 0; i < 4; i++){\n        s = sv[i*2+1];\n        REP(j,5){\n            if(s[j] == '1'){\n                m[i][j].DW = m[i+1][j].UP = 1;\n            }\n        }\n    }\n\n    int nx = 0, ny = 0;\n    int dir = 0;\n    while(1){\n        REP(i,4){\n            int dir2 = (dir+1-i+4)%4;\n            if(m[ny][nx].v[dir2]){\n                printf(\"%c\", str[dir2]);\n                nx += movex[dir2];\n                ny += movey[dir2];\n                if(nx < 0 || nx >= 5 || ny < 0 || ny >= 5) throw;\n                dir = dir2;\n                break;\n            }\n        }\n        if(nx == 0 && ny == 0) break;\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tvector<vector<int>> H(5,vector<int>(4)),V(4,vector<int>(5));\n\tREP(i,9){\n\t\tstring S=in<string>();\n\t\tif(!(i%2)){\n\t\t\tREP(j,4) H[i/2][j] = S[j]-'0';\n\t\t}\n\t\telse{\n\t\t\tREP(j,5) V[i/2][j] = S[j]-'0';\n\t\t}\n\t}\n\t\n\tenum{R=0,D,L,U};\n\tint X=0,Y=0,dir=R;\n\tauto check = [&](){return (!X && !Y);};\n\tstring S;\n\twhile(true){\n\t\tif(dir==R){\n\t\t\tif(Y>0 && V[Y-1][X]){\n\t\t\t\tdir = U;\n\t\t\t\tY--;\n\t\t\t\tS.push_back('U');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse if(X<4 && H[Y][X]){\n\t\t\t\tX++;\n\t\t\t\tS.push_back('R');\n\t\t\t}\n\t\t\telse if(Y<4 && V[Y][X]){\n\t\t\t\tdir = D;\n\t\t\t\tY++;\n\t\t\t\tS.push_back('D');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir = L;\n\t\t\t\tX--;\n\t\t\t\tS.push_back('L');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t}\n\t\telse if(dir==D){\n\t\t\tif(X<4 && H[Y][X]){\n\t\t\t\tdir = R;\n\t\t\t\tX++;\n\t\t\t\tS.push_back('R');\n\t\t\t}\n\t\t\telse if(Y<4 && V[Y][X]){\n\t\t\t\tY++;\n\t\t\t\tS.push_back('D');\n\t\t\t}\n\t\t\telse if(X>0 && H[Y][X-1]){\n\t\t\t\tdir = L;\n\t\t\t\tX--;\n\t\t\t\tS.push_back('L');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir = U;\n\t\t\t\tY--;\n\t\t\t\tS.push_back('U');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t}\n\t\telse if(dir==L){\n\t\t\tif(Y<4 && V[Y][X]){\n\t\t\t\tdir = D;\n\t\t\t\tY++;\n\t\t\t\tS.push_back('D');\n\t\t\t}\n\t\t\telse if(X>0 && H[Y][X-1]){\n\t\t\t\tX--;\n\t\t\t\tS.push_back('L');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse if(Y>0 && V[Y-1][X]){\n\t\t\t\tdir = U;\n\t\t\t\tY--;\n\t\t\t\tS.push_back('U');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir = R;\n\t\t\t\tX++;\n\t\t\t\tS.push_back('R');\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(X>0 && H[Y][X-1]){\n\t\t\t\tdir = L;\n\t\t\t\tX--;\n\t\t\t\tS.push_back('L');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse if(Y>0 && V[Y-1][X]){\n\t\t\t\tY--;\n\t\t\t\tS.push_back('U');\n\t\t\t\tif(check()) break;\n\t\t\t}\n\t\t\telse if(X<4 && H[Y][X]){\n\t\t\t\tdir = R;\n\t\t\t\tX++;\n\t\t\t\tS.push_back('R');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir = D;\n\t\t\t\tY++;\n\t\t\t\tS.push_back('D');\n\t\t\t}\n\t\t}\n\t}\n\t\n\tout(S);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a,T b){for(T i=a;i!=b;++i)cout<<*i<<\" \";cout<<endl;}\ntemplate<class T> void chmin(T &t,T f){if(t>f)t=f;}\ntemplate<class T> void chmax(T &t,T f){if(t<f)t=f;}\nint in(){int x;scanf(\"%d\",&x);return x;}\n\nint yoko[6][6],tate[6][6];\n\nint state;\npint pos;\n\n\nint main(){\n\tint i,j;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=0;j<4;j++)yoko[i][j]=getchar()-'0';\n\t\tgetchar();\n\t\tfor(j=0;j<5;j++)tate[i][j]=getchar()-'0';\n\t\tgetchar();\n\t}\n\tfor(j=0;j<4;j++)yoko[4][j]=getchar()-'0';\n\tcout<<\"R\";\n//cout<<endl;\n\tpos.first=1;\n\tpos.second=0;\n\tstate=0;\n/*\tfor(i=0;i<4;i++){\n\t\tfor(j=0;j<4;j++)cout<<yoko[i][j];\n\t\tcout<<endl;\n\t\tfor(j=0;j<5;j++)cout<<tate[i][j];\n\t\tcout<<endl;\n\t}\n\tfor(j=0;j<4;j++)cout<<yoko[4][j];\n\tcout<<endl;\n*/\t\n\t\n\twhile(pos.first!=0||pos.second!=0){\n//cout<<pos.first<<\" \"<<pos.second<<endl;\n\t\tswitch(state){\n\t\tcase 0:\n\t\t\tif(pos.second!=0&&tate[pos.second-1][pos.first]==1){\n\t\t\t\tpos.second--;\n\t\t\t\tstate=1;\n\t\t\t}else if(pos.first!=4&&yoko[pos.second][pos.first]==1){\n\t\t\t\tpos.first++;\n\t\t\t\tstate=0;\n\t\t\t}else if(pos.second!=4&&tate[pos.second][pos.first]==1){\n\t\t\t\tpos.second++;\n\t\t\t\tstate=3;\n\t\t\t}else{\n\t\t\t\tpos.first--;\n\t\t\t\tstate=2;\n\t\t\t}\n\t\tbreak;\n\t\tcase 1:\n\t\t\tif(pos.first!=0&&yoko[pos.second][pos.first-1]==1){\n\t\t\t\tpos.first--;\n\t\t\t\tstate=2;\t\n\t\t\t}else if(pos.second!=0&&tate[pos.second-1][pos.first]==1){\n\t\t\t\tpos.second--;\n\t\t\t\tstate=1;\n\t\t\t}else if(pos.first!=4&&yoko[pos.second][pos.first]==1){\n\t\t\t\tpos.first++;\n\t\t\t\tstate=0;\n\t\t\t}else{\n\t\t\t\tpos.second++;\n\t\t\t\tstate=3;\n\t\t\t}\n\t\tbreak;\n\t\tcase 2:\n\t\t\tif(pos.second!=4&&tate[pos.second][pos.first]==1){\n\t\t\t\tpos.second++;\n\t\t\t\tstate=3;\n\t\t\t}else if(pos.first!=0&&yoko[pos.second][pos.first-1]==1){\n\t\t\t\tpos.first--;\n\t\t\t\tstate=2;\n\t\t\t}else if(pos.second!=0&&tate[pos.second-1][pos.first]==1){\n\t\t\t\tpos.second--;\n\t\t\t\tstate=1;\n\t\t\t}else{\n\t\t\t\tpos.first++;\n\t\t\t\tstate=0;\n\t\t\t}\n\t\tbreak;\n\t\tcase 3:\n\t\t\tif(pos.first!=4&&yoko[pos.second][pos.first]==1){\n\t\t\t\tpos.first++;\n\t\t\t\tstate=0;\n\t\t\t}else if(pos.second!=4&&tate[pos.second][pos.first]==1){\n\t\t\t\tpos.second++;\n\t\t\t\tstate=3;\n\t\t\t}else if(pos.first!=0&&yoko[pos.second][pos.first-1]==1){\n\t\t\t\tpos.first--;\n\t\t\t\tstate=2;\n\t\t\t}else{\n\t\t\t\tpos.second--;\n\t\t\t\tstate=1;\n\t\t\t}\n\t\tbreak;\n\t\tdefault: cout<<\"hoge\"<<endl;\n\t\tbreak;\n\t\t}\n\t\tif(state==0)cout<<\"R\";\n\t\tif(state==1)cout<<\"U\";\n\t\tif(state==2)cout<<\"L\";\n\t\tif(state==3)cout<<\"D\";\n\t}\n\tcout<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<int(n); ++i)\n\nint main()\n{\n\tint field[5][5] = {{0}};\n\trep(i, 9){\n\t\tchar str[6];\n\t\tscanf(\"%s\", str);\n\t\tif(i%2){\n\t\t\trep(j, 5){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<2;\n\t\t\t\tfield[i/2+1][j] |= a;\n\t\t\t}\n\t\t}else{\n\t\t\trep(j, 4){\n\t\t\t\tint a = str[j]-'0';\n\t\t\t\tfield[i/2][j] |= a<<1;\n\t\t\t\tfield[i/2][j+1] |= a<<3;\n\t\t\t}\n\t\t}\n\t}\n\n\tputchar('R');\n\tint y=0, x=1;\n\tint pre = 1;\n\tbool right = false;\n\tdo{\n\t\t// printf(\"(%d, %d)\\n\", x, y);\n\t\tpre = (pre+2)%4;\n\t\tint dire = pre;\n\t\tdo{\n\t\t\tdire = (dire + right*2+1)%4;\n\t\t}while(!((field[y][x]>>dire)&1));\n\t\tif(dire == pre)\n\t\t\tright = !right;\n\t\tpre = dire;\n\t\tputchar(\"URDL\"[dire]);\n\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx += dx[dire];\n\t\ty += dy[dire];\n\t}while(y!=0 || x!=0 || right);\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint main(){\n\tchar a[4][5];\n\tchar b[5][4];\n\tint d = 2;\n\tint x = 0, y = 0;\n\tfor(int i = 0; i < 4; i++){\n\t\tscanf(\"%c%c%c%c\\n\", &a[0][i], &a[1][i], &a[2][i], &a[3][i]);\n\t\tscanf(\"%c%c%c%c%c\\n\", &b[0][i], &b[1][i], &b[2][i], &b[3][i], &b[4][i]);\n\t}\n\tscanf(\"%c%c%c%c\", &a[0][4], &a[1][4], &a[2][4], &a[3][4]);\n\n\twhile(d){\n\t\tif(d == 2){\n\t\t\tif(y && b[x][y-1] - '0'){\n\t\t\t\td = 1;\n\t\t\t\ty--;\n\t\t\t\tprintf(\"U\");\n\t\t\t}else if(x == 4){\n\t\t\t\td = 3;\n\t\t\t}else if(a[x][y] - '0'){\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t}else{\n\t\t\t\td = 3;\n\t\t\t}\n\t\t}\n\t\tif(d == 3){\n\t\t\tif(x - 4 && a[x][y] - '0'){\n\t\t\t\td = 2;\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t}else if(y == 4){\n\t\t\t\td = 4;\n\t\t\t}else if(b[x][y] - '0'){\n\t\t\t\ty++;\n\t\t\t\tprintf(\"D\");\n\t\t\t}else{\n\t\t\t\td = 4;\n\t\t\t}\n\t\t}\n\t\tif(d == 4){\n\t\t\tif(y - 4 && b[x][y] - '0'){\n\t\t\t\td = 3;\n\t\t\t\ty++;\n\t\t\t\tprintf(\"D\");\n\t\t\t}else if(x == 0){\n\t\t\t\tif(y == 0){\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\td = 1;\n\t\t\t}else if(a[x-1][y] - '0'){\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t}else{\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\tif(d == 1){\n\t\t\tif(x && a[x-1][y] - '0'){\n\t\t\t\td = 4;\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t}else if(y == 0){\n\t\t\t\tif(x == 0){\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\td = 2;\n\t\t\t}else if(b[x][y-1] - '0'){\n\t\t\t\ty--;\n\t\t\t\tprintf(\"U\");\n\t\t\t}else{\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nnamespace std {\n    bool operator<(const P a, const P b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n#define S 6\n// right, down, left, up\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint const MOD = 1000000007;\n\nint main() {\n    bool board[S][S][4] = {};\n    // rep(i,0,S) board[i][S-1][0] = true; // right\n    // rep(i,0,S) board[S-1][i][1] = true; // down\n    // rep(i,0,S) board[i][0][2]   = true; // left\n    // rep(i,0,S) board[0][i][3]   = true; // up\n\n    rep(i,0,9) {\n        int l, n;\n        if(i % 2 == 0) l = 4;\n        else l = 5;\n        rep(j,0,l) {\n            scanf(\"%1d\", &n);\n            if(n == 1) {\n                if(i % 2 == 0) {\n                    board[i/2][j+1][1] = true;\n                    board[i/2+1][j+1][3] = true;\n                }\n                else {\n                    board[i/2+1][j][0] = true;\n                    board[i/2+1][j+1][2] = true;\n                }\n            }\n        }\n    }\n\n    string d = \"RDLU\";\n    string ret;\n    int dir = 0;\n    int nx = 0, ny = 1;\n    int cas = 1;\n    for(int i=0; i<150; i++) {\n        int x, y;\n        // printf(\"test: board[%d][%d][%d] = %d\\n\", nx, ny, (dir+1)%4, board[nx][ny][(dir+1)%4] ? 1 : 0);\n        x = nx + dx[dir], y = ny + dy[dir];\n        if(board[nx][ny][(dir + 1) % 4] == 0) {\n            // printf(\"case 1: (%d, %d)\\n\", nx, ny);\n            dir = (dir + 1) % 4;\n            nx = nx + dx[dir], ny = ny + dy[dir];\n        }\n        else if(board[nx][ny][dir] == 1) {\n            // printf(\"case 2: (%d, %d)\\n\", nx, ny);\n            if(cas == 1) ret += d[dir];\n            dir = (dir - 1 + 4) % 4;\n            ret += d[dir];\n            cas = 2;\n        }\n        else {\n            ret += d[dir];\n            nx = x, ny = y;\n        }\n        if(nx == 1 && ny == 1 && dir == 2) break;\n        if(nx == 1 && ny == 0 && dir == 3) break;\n    }\n    // printf(\"endx: %d, endy: %d, dir = %d\\n\", nx, ny, dir);\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int dx[4]={1, 0, -1, 0};\nconst int dy[4]={0, 1, 0, -1};\n\nstruct pt{\n    int x, y, d;\n    void move(int dir){\n        x+=dx[dir];\n        y+=dy[dir];\n        d=dir;\n    }\n};\n\nint main()\n{\n    char buf[8];\n    bool h[5][4];\n    bool v[4][5];\n    for(int i=0; i<5; i++){\n        cin.getline(buf, 8);\n        for(int j=0; j<4; j++) h[i][j]=(buf[j]=='1'?true:false);\n        if(i==4) break;\n        cin.getline(buf, 8);\n        for(int j=0; j<5; j++) v[i][j]=(buf[j]=='1'?true:false);\n    }\n    \n    pt pos={0,0,0};\n    do{\n        for(int dd=3; dd<=6; dd++){\n            int next=(pos.d+dd)%4;\n            if(next==0){\n                if(pos.x!=4&&h[pos.y][pos.x]){\n                    pos.move(0);\n                    cout<<'R';\n                    break;\n                }\n            }else if(next==1){\n                if(pos.y!=4&&v[pos.y][pos.x]){\n                    pos.move(1);\n                    cout<<'D';\n                    break;\n                }\n            }else if(next==2){\n                if(pos.x!=0&&h[pos.y][pos.x-1]){\n                    pos.move(2);\n                    cout<<'L';\n                    break;\n                }\n            }else if(next==3){\n                if(pos.y!=0&&v[pos.y-1][pos.x]){\n                    pos.move(3);\n                    cout<<'U';\n                    break;\n                }\n            }\n        }\n    }while(pos.x!=0||pos.y!=0);\n    cout<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nint main(){\n\n\twhile(1){\n\tchar yoko[10][10];\n\tchar tate[10][10];\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tcin>>yoko[i][j];\n\t\t}\n\t\tif(i!=4){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tcin>>tate[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tif(cin.eof())\n\t\tbreak;\n\n\n\t// 0,1,2,3ÅEAºA¶Aã\n\tint angle=0;\n\tint px,py;\n\tpx=py=0;\n\twhile(1){\n\t\tif(angle==0){\n\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\tcout<<\"R\";\n\t\t\t\tpx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ãÖ\n\t\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\telse if(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx--;\n\t\t\t\t\tangle=2;\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// º\n\t\telse if(angle==1){\n\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\tcout<<\"D\";\n\t\t\t\tpy++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse if(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¶\n\t\telse if(angle==2){\n\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\tcout<<\"L\";\n\t\t\t\tpx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª êÎAºÖ\n\t\t\t\tif(py!=4&&tate[py][px]=='1'){\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t\t// ãÖ\n\t\t\t\telse if(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\t\tpy--;\n\t\t\t\t\tangle=3;\n\t\t\t\t\tcout<<\"U\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpx++;\n\t\t\t\t\tangle=0;\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ã\n\t\telse if(angle==3){\n\t\t\tif(py!=0&&tate[py-1][px]=='1'){\n\t\t\t\tcout<<\"U\";\n\t\t\t\tpy--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ºÉÇª³¯êÎA½]\n\t\t\t\tif(px!=0&&yoko[py][px-1]=='1'){\n\t\t\t\t\tcout<<\"L\";\n\t\t\t\t\tangle=2;\n\t\t\t\t\tpx--;\n\t\t\t\t}\n\t\t\t\telse if(px!=4&&yoko[py][px]=='1'){\n\t\t\t\t\tcout<<\"R\";\n\t\t\t\t\tangle=0;\n\t\t\t\t\tpx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpy++;\n\t\t\t\t\tangle=1;\n\t\t\t\t\tcout<<\"D\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(px==0&&py==0)\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<endl;\n\n\t\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nint main() {\n\n    vector<vector<char> > root (9, vector<char>(5));\n\n    char c;\n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 4 + (i % 2); j++) {\n            cin >> c;\n            root[i][j] = c;\n        }\n    }\n\n    cout << \"R\";\n\n    int x = 1;\n    int y = 0;\n    int d = 2;\n    char dirs [] = { 'L', 'U', 'R', 'D', 'L', 'U', 'R', 'D' }; \n\n    while ( x || y ) {\n        bool gone = false;\n        for (int i = -1; i < 3; i++) {\n            switch(dirs[d + i]) {\n                case 'L':\n                    if (x > 0 && root[2 * y][x - 1] == '1') {\n                        x -= 1;\n                        d = 4;\n                        cout << 'L';\n                        gone = true;\n                    }\n                    break;\n                case 'U':\n                    if (y > 0 && root[2 * y - 1][x] == '1') {\n                        y -= 1;\n                        d = 1;\n                        cout << 'U';\n                        gone = true;\n                    }\n                    break;\n                case 'R':\n                    if (x < 4 && root[2 * y][x] == '1') {\n                        x += 1;\n                        d = 2;\n                        cout << 'R';\n                        gone = true;\n                    }\n                    break;\n                case 'D':\n                    if (y < 4 && root[2 * y + 1][x] == '1') {\n                        y += 1;\n                        d = 3;\n                        cout << 'D';\n                        gone = true;\n                    }\n                    break;\n            }\n            if (gone) break;\n        }\n    }\n    cout << endl;\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cstdio>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint dy[4] = {-1,0,1,0};\nint dx[4] = {0,1,0,-1};\nstring ans = \"URDL\";\nbool f[5][5][5];\n\nint main() {\n\n    memset(f,0,sizeof(f));\n\n    rep(i,9) {\n        int y = i/2;\n    \n        if(i%2 == 0) {\n            string t;\n            cin >> t;\n    \n            rep(j,4) {\n                if(t[j] == '1') {\n                    f[y][j][1] = true;\n                    f[y][j+1][3] = true;\n                }\n            }\n        } else {\n            string t;\n            cin >> t;\n    \n            rep(j,5) {\n                if(t[j] == '1') {\n                    f[y+1][j][0] = true;\n                    f[y][j][2] = true;\n                }\n            }\n        }\n    }\n\n    int dy[4] = {-1,0,1,0};\n    int dx[4] = {0,1,0,-1};\n    string ans = \"URDL\";\n    int y = 0, x = 0, dir = 1;\n\n    do {\n        if(f[y][x][(dir+3)%4]) {\n            dir = (dir+3)%4;\n        } else if(f[y][x][dir]) {\n\n        } else if(f[y][x][(dir+1)%4]) {\n            dir = (dir+1)%4;\n        } else if(f[y][x][(dir+2)%4]) {\n            dir = (dir+2)%4;\n        }\n\n\n        y += dy[dir];\n        x += dx[dir];\n        cout << ans[dir];\n    } while(y != 0 || x != 0);\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(count!=0\n\t\t\t\t&&x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nstring vec=\"RULD\";\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4==2){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nvoid move(int,int,char);\nchar det_angle(int,int,char);\n\nchar perm_angle[4] = {'R','U','L','D'};\nint grid[5][5][4] = {0};\n\nint main(){\n\n\tint flag;\n\tfor(int i=0;i<9;i++){\n\t\tif(i%2 == 0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag);\n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"+\";\n\t\t\t\t\tgrid[i/2][j][0]  = 1; //R\n\t\t\t\t\tgrid[i/2][j+1][2]= 1; //L\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tfscanf(stdin,\"%1d\",&flag); \n\t\t\t\t//cout << flag;\n\t\t\t\tif(flag == 1){\n\t\t\t\t\t//cout << \"-\";\n\t\t\t\t\tgrid[i/2][j][3]  = 1; //D\n\t\t\t\t\tgrid[i/2+1][j][1]= 1; //U\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tint x = 0,y =0;\n\tchar angle = 'R';\n\tdo{\n\t\t//\t\tmove(x,y,det_angle(x,y,angle));\n\n\t\tcout << angle;\n\n\t\tif(angle == 'R'){\n\t\t\t++y;\n\t\t}\n\t\telse if(angle == 'U'){\n\t\t\t--x;\n\t\t}\n\t\telse if(angle == 'L'){\n\t\t\t--y;\n\t\t}\n\t\telse if(angle == 'D'){\n\t\t\t++x;\n\t\t}\n\t\tangle = det_angle(x,y,angle);\n\t}\n\twhile(x != 0 || y!= 0);\n\t//cout << 'R';\n\t//move(0,1,'R');\n\tcout << endl;\n}\n\nvoid move(int x,int y,char angle){\n\tif(x == 0 && y== 0){\n\t\tcout << endl;\n\t\t//exit(0);\n\t}\n\n\tcout << angle;\n\n\tif(angle == 'R'){\n\t\t++y;\n\t}\n\telse if(angle == 'U'){\n\t\t--x;\n\t}\n\telse if(angle == 'L'){\n\t\t--y;\n\t}\n\telse if(angle == 'D'){\n\t\t++x;\n\t}\n\t//cout << \"test\" << x <<\" \" << y;\n\t//move(x,y,det_angle(x,y,angle));\n\t//cout << angle << endl; \n}\n\nchar det_angle(int x,int y,char angle){\n\n\t//cout << x << y << \" \" << angle << endl;\n\tint start;\n\tif(angle == 'R'){\n\t\tstart = 5;\n\t}\n\telse if(angle == 'U'){\n\t\tstart = 6;\n\t}\n\telse if(angle == 'L'){\n\t\tstart = 7;\t\n\t}\n\telse if(angle == 'D'){\n\t\tstart = 4;\n\t}\n\t//cout << start << endl;\n\tfor(int i = start;start - i < 4 ;--i){\n\t\tif(grid[x][y][i%4] == 1){\n\t\t\t//cout << \"kettei\" << i <<endl ;\n\t\t\treturn perm_angle[i%4];\n\t\t}\n\t}\n\treturn 'Z';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstruct man{int x,y,d;};\nint main(){\n  string st[9];\n  int i,j,k;\n  for(i=0;i<9;i++) cin >> st[i];\n  bool f=false,mo=false;\n  man m;\n  m.x=0;m.y=0;m.d=0;\n  int c=0;\n  while(c<50){\n    c++;\n    mo=false;\n    if(m.x==0&&m.y==0&&f) break;\n    f=true;\n    //cout << m.x<<\":\"<<m.y<<\":\"<<m.d << endl;\n    if(m.d==0){\n      if(st[m.y*2][m.x]=='1') {\n\tm.x++;\n\tcout << \"R\";\n\tmo=true;\n\t//continue;\n      }\n      if(m.y>0){\n\tif(st[m.y*2-1][m.x]=='1') {\n\t  m.d=3;\n\t  continue;\n\t}\n      }\n      \n      if(st[m.y*2+1][m.x]=='1') {\n\tm.d=1;\n\tcontinue;\n      }\n      //m.d=2;\n      //continue;\n    }\n    if(m.d==1){\n      \n      if(st[m.y*2+1][m.x]=='1') {\n\tm.y++;\n\tcout << \"D\" ;\n\tmo=true;\n\t//continue;\n      }\n      if(m.x<4){\n\tif(st[m.y*2][m.x]=='1') {\n\t  m.d=0;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2][m.x-1]=='1') {\n\tm.d=2;\n\tcontinue;\n      }\n      //m.d=3;\n      //continue;\n    }\n    if(m.d==2){\n      \n      if(st[m.y*2][m.x-1]=='1') {\n\tm.x--;\n\tcout << \"L\" ;\n\tmo=true;\n\t//continue;\n      }\n      if(m.y<4){\n\tif(st[m.y*2+1][m.x]=='1') {\n\t  m.d=1;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2-1][m.x]=='1') {\n\tm.d=1;\n\tcontinue;\n      }\n      //m.d=0;\n      //continue;\n    }\n    if(m.d==3){\n      \n      if(st[m.y*2-1][m.x]=='1') {\n\tm.y--;\n\tcout << \"U\" ;\n\tmo=true;\n\t//continue;\n      }\n      if(m.x>0){\n\tif(st[m.y*2][m.x-1]=='1') {\n\t  m.d=2;\n\t  continue;\n\t}\n      }\n      if(st[m.y*2][m.x]=='1') {\n\tm.d=0;\n\tcontinue;\n      }\n      //m.d=1;\n      //continue;\n    }\n    if(!mo)m.d=(m.d+2)%4;\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF INT_MAX / 3\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef valarray<int> Array;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i];if(i==a.size()-1)cout<<endl;else cout<<\" \";}}\nint gcd(int a,int b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nint lcm(int a,int b){return a==0||b==0?0:a*b/gcd(a,b);}\n\nint a[35];\n\nvoid solve()\n{\n  string ans = \"\";\n  int pre, i, dir = 0, now = 0;\n  int mov[] = {1,5,-1,-5};\n  string c[] = {\"R\",\"D\",\"L\",\"U\"};\n  do\n  {\n    pre = (dir+2)%4;\n    for(i=(pre+1)%4;i!=pre;++i%=4)\n    {\n      if(a[now]>>i&1)\n      {\n        dir = i;\n        break;\n      }\n    }\n    if(i == pre) dir = pre;\n    ans += c[dir];\n    now += mov[dir];\n  }\n  while(now != 0);\n  cout << ans << \"\\n\";\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fill_n(a,35,0);\n  string s; int c;\n  REP(i,9)\n  {\n    cin >> s;\n    c = i/2;\n    if(i%2==0)\n    {\n      REP(j,4) if(s[j]=='1')\n      {\n        a[c*5+j] += 1;\n        a[c*5+j+1] += 4;\n      }\n    }\n    else\n    {\n      REP(j,5) if(s[j]=='1')\n      {\n        a[c*5+j] += 2;\n        a[(c+1)*5+j] += 8;\n      }\n    }\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int field[6][6]={0};\n  string s;\n  for(int i=0; i<5; i++){\n    cin >>s;\n    for(int j=0; j<4; j++){\n      if(s[j] == '1'){\n\tfield[j+1][i]+=4;\n\tfield[j+1][i+1]+=1;\n      }\n    }\n    if(i<4){\n      cin >>s;\n      for(int j=0; j<5; j++){\n\tif(s[j] == '1'){\n\t  field[j][i+1]+=2;\n\t  field[j+1][i+1]+=8;\n\t}\n      }\n    }\n  }\n  int px = 1,py=0,d=2;\n  for(int i=0;; i++){\n    if(d == 1){\n      if(!(field[px][py]&2)){px++;d = 2;}\n      else{\n\tif(field[px][py]&1){cout <<\"U\";d = 8;}\n\telse{cout <<\"U\";py--;}\n      }\n    }\n    else if(d == 2){\n      if(!(field[px][py]&4)){py++;d = 4;}\n      else{\n\tif(field[px][py]&2){cout <<\"R\";d = 1;}\n\telse{cout <<\"R\";px++;}\n      }\n    }\n    else if(d == 4){\n      if(!(field[px][py]&8)){px--;d = 8;}\n      else{\n\tif(field[px][py]&4){cout <<\"D\";d = 2;}\n\telse if(field[px][py]&8){cout <<\"D\";py++;}\n      }\n    }\n    else if(d == 8){\n      if(!(field[px][py]&1)){py--;d = 1;}\n      else{\n\tif(field[px][py]&8){cout <<\"L\";d = 4;}\n\telse{cout <<\"L\";px--;}\n      }\n    }\n    if(px == 1 && py == 0){cout <<endl; break;}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint map[12][12] = {0};\nenum Dir{ RIGHT , DOWN , LEFT , UP };\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nchar d[4] = { 'R' , 'D' , 'L' , 'U'};\n\nint main(){\n\tint x = 2, y = 0, dir = RIGHT;\n\tstring f;\n\n\tfor(int y=0 ; y<9 ; y++){\n\t\tcin >> f;\n\t\tfor(unsigned int x=0 ; x<f.size() ; x++){\n\t\t\tmap[y+1][2*x+((y+1)%2)+1] = f[x] - '0';\n\t\t}\n\t}\n\t\n\twhile( 1 ){\n\t\tif( x==0 && y==2 ) break;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tint nx = x + dx[(dir+1)%4];\n\t\tint ny = y + dy[(dir+1)%4];\n\t\tif( map[ny][nx] == 1 ){\n\t\t\tcout << d[dir];\n\t\t}\n\n\t\tif( map[my][mx] == 0 ){\t\t\n\t\t\tif( map[ny][nx] == 0 ){\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\tnx = x + dx[(dir+1)%4];\n\t\t\t\tny = y + dy[(dir+1)%4];\n\t\t\t\tif( map[ny][nx] == 1 ){\n\t\t\t\t\tcout << d[dir];\n\t\t\t\t}\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}else{\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}\n\t\t}else{\n\t\t\tif( map[ny][nx] == 0 ){\n\t\t\t\tdir = ( dir + 1 ) % 4;\n\t\t\t\tnx = x + dx[(dir+1)%4];\n\t\t\t\tny = y + dy[(dir+1)%4];\n\t\t\t\tif( map[ny][nx] == 1 ){\n\t\t\t\t\tcout << d[dir];\n\t\t\t\t}\n\t\t\t\tx += dx[dir] * 2;\n\t\t\t\ty += dy[dir] * 2;\n\t\t\t}else{\n\t\t\t\tdir = ( dir + 3 ) % 4;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define X first\n#define Y second\n#define WIDTH 8\n#define HEIGHT 8\n\nusing namespace std;\n\nstruct point{\n\tpoint(int x = 0, int y = 0, char dir = 'R'):x(x), y(y), dir(dir){}\n\tint x;\n\tint y;\n\tchar dir;\n};\n\nchar moveMap(vector<string> &map, point &player){\n\tswitch(player.dir){\n\tcase 'R':\n\t\tif(player.y != 0 && map[player.y - 1][player.x + 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y][player.x + 1] == '1'){\n\t\t\tplayer.x += 1;\n\t\t}\n\t\telse if(player.y != 8 && map[player.y + 1][player.x + 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\telse player.dir = 'L';\n\t\tbreak;\n\tcase 'L':\n\t\tif(player.y != 8 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'D';\n\t\t}\n\t\telse if(player.x != 0 && map[player.y][player.x - 1] == '1'){\n\t\t\tplayer.x -= 1;\n\t\t}\n\t\telse if(player.y != 0 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'U';\n\t\t}\n\t\telse player.dir = 'R';\n\t\tbreak;\n\tcase 'U':\n\t\tif(player.x != 0 && map[player.y - 1][player.x - 1] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\telse if(player.y != 1 && map[player.y - 2][player.x] == '1'){\n\t\t\tplayer.y -= 2;\n\t\t}\n\t\telse if(player.x != map[player.y].size() - 1 && map[player.y - 1][player.x] == '1'){\n\t\t\tplayer.y -= 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\telse player.dir = 'D';\n\t\tbreak;\n\tcase 'D':\n\t\tif(player.x != map[player.y].size() - 1 && map[player.y + 1][player.x] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.dir = 'R';\n\t\t}\n\t\telse if(player.y != 7 && map[player.y + 2][player.x] == '1'){\n\t\t\tplayer.y += 2;\n\t\t}\n\t\telse if(player.x != 0 && map[player.y + 1][player.x - 1] == '1'){\n\t\t\tplayer.y += 1;\n\t\t\tplayer.x -= 1;\n\t\t\tplayer.dir = 'L';\n\t\t}\n\t\telse player.dir = 'U';\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn player.dir;\n}\n\nint main(){\n\tstring tmp;\n\twhile(cin >> tmp){\n\t\tif(cin.eof()) break;\n\t\t\n\t\tvector<string> map;\n\t\tmap.push_back(tmp);\n\t\tfor(int i = 1; i < 9; i++){\n\t\t\tcin >> tmp;\n\t\t\tmap.push_back(tmp);\n\t\t}\n\n\t\tpoint player(0, 0, 'R');\n\t\tstring root;\n\t\troot.push_back('R');\n\t\t\n\t\twhile(1){\n\t\t\troot.push_back(moveMap(map, player));\n\t\t\tif(player.x == 0 && player.y == 0) break;\n\t\t}\n\n\t\tfor(int i = 0; i < root.size(); i++){\n\t\t\tcout << root[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint i, j, a[6][6] = {}, b[6][5] = {};\nstring output = \"\";\n\nint right(), left(), up(), down();\n\nint right(){\n\toutput += \"R\";\n\tif(b[i-1][j] == 1){\n\t\ti--;\n\t\tup();\n\t}\n\telse if(a[i][j+1] == 1){\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i][j + 1] == 2) { output += \"R\"; }\n\telse {\n\t\tdown();\n\t}\n\treturn 0;\n}\n\nint left(){\n\toutput += \"L\";\n\tif (b[i][j-1] == 1) {\n\t\tj--;\n\t\tdown();\n\t}\n\telse if (a[i][j-1] == 1) {\n\t\tj--;\n\t\tleft();\n\t}\n\telse if (a[i][j - 1] == 2) { output += \"L\"; }\n\telse {\n\t\ti--;\n\t\tj--;\n\t\tup();\n\t}\n\treturn 0;\n}\n\nint up(){\n\toutput += \"U\";\n\tif (a[i][j] == 1) {\n\t\tleft();\n\t}\n\telse if (a[i][j] == 2) { output = \"L\"; }\n\telse if (b[i-1][j] == 1) {\n\t\ti--;\n\t\tup();\n\t}\n\telse if (a[i][j + 1] == 2) { output = \"U\"; }\n\telse {\n\t\tj++;\n\t\tright();\n\t}\n\treturn 0;\n}\n\nint down(){\n\toutput += \"D\";\n\tif (a[i+1][j+1] == 1) {\n\t\ti++;\n\t\tj++;\n\t\tright();\n\t}\n\telse if (a[i + 1][j + 1] == 2) {  }\n\telse if (b[i + 1][j] == 1) {\n\t\ti++;\n\t\tdown();\n\t}\n\telse if (a[i + 1][j] == 2) { output = \"L\"; }\n\telse {\n\t\ti++;\n\t\tleft();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tstring input, k;\n\tfor(i = 1; i<10;i++){\n\t\tgetline(cin, input);\n\t\tif (input.size() != 4) {\n\t\t\tfor(int j= 0;j<5;j++){\n\t\t\t\tk = input[j];\n\t\t\t\tb[i / 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j = 1;j<5;j++){\n\t\t\t\tk = input[j-1];\n\t\t\t\ta[(i + 1)/ 2][j] = stoi(k);\n\t\t\t}\n\t\t}\n\n\t}\n\n\ta[1][1] = 2;\n\ti = 1;\n\tj = 1;\n\tright();\n\tcout << output << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {-1, 0, 1, 0};\n\nvoid print(int c){\n    if(c == 0) cout << \"L\";\n    else if(c == 1) cout << \"U\";\n    else if(c == 2) cout << \"R\";\n    else cout << \"D\";\n}\n\nint main(){\n\n\n    vector<vector<bool> > a(13, vector<bool> (13, true));\n    for(int i = 0; i < 13; i++){\n        a[i][0] = a[i][12] = false;\n    }\n\n    for(int j = 0; j < 13; j++){\n        a[0][j] = a[12][j] = false;\n    }\n\n    for(int i = 0; i < 9; i++){\n\n        if(i % 2 == 0){\n            int h = i + 2;\n            string s; cin >> s;\n            for(int j = 0; j < 4; j++){\n                int w = j * 2 + 3;\n                if(s[j] == '1'){\n                    a[h][w - 1] = false;\n                    a[h][w] = false;\n                    a[h][w + 1] = false;                    \n                }\n            }\n        }else{\n            int h = i + 2;\n            string s; cin >> s;\n            for(int j = 0; j < 5; j++){\n                int w = j * 2 + 2;\n                if(s[j] == '1'){\n                    a[h - 1][w] = false;\n                    a[h][w] = false;\n                    a[h + 1][w] = false;                    \n                }\n            }\n        }\n    }\n\n    /*for(int i = 0; i < 13; i++){\n        for(int j = 0; j < 13; j++){\n            cout << a[i][j];\n        }\n        cout << endl;\n    }*/\n\n    int s_k = 2;\n    int s_i = 2;\n    int s_j = 2;\n    int k = 2;\n    int i = 2;\n    int j = 2;\n    bool flag = false;\n    while(1){\n\n        if(flag && i == s_i && j == s_j) break;\n        \n        flag = true;\n        for(int h = 0; h < 4; h++){\n\n            int c = (k - 1 + 4 + h) % 4;\n            if(a[i + di[c]][j + dj[c]] == 0 && a[i + 2*di[c]][j + 2*dj[c]] == 0){\n                print(c);\n                i = i + 2*di[c];\n                j = j + 2*dj[c];\n                k = c;\n                break;\n            }\n\n        } \n    \n    }\n    cout << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int X = 1000;\nconst int Y = 10;\nbool g[Y][X][Y][X];\n\nstruct State {\n    int x;\n    int y;\n    int dir;\n};\nint dirx[] = {1, 0, -1, 0};\nint diry[] = {0, 1, 0, -1};\nstring ans = \"\";\n\nvector<int> inputLine() {\n    string s;\n    vector<int> a;\n    cin >> s;\n    for(char c : s) {\n        a.push_back(c - '0');\n    }\n    return a;\n}\n\nstring toString(int dir) {\n    switch(dir) {\n    case 0:\n        return \"R\";\n    case 1:\n        return \"D\";\n    case 2:\n        return \"L\";\n    case 3:\n        return \"U\";\n    }\n}\n\nstruct State at(struct State st) {\n    for(int i=0;i<4;i++) {\n        int ndir = (st.dir + i) % 4;\n        int nx = st.x + dirx[ndir];\n        int ny = st.y + diry[ndir];\n        if(0 <= nx && 0 <= ny && g[st.y][st.x][ny][nx]) {\n            // printf(\"nx: %d, ny: %d, ndir: %d\\n\", nx, ny, ndir);\n            ans += toString(ndir);\n            int nndir = (ndir+3)%4;\n            int nnx = nx + dirx[nndir];\n            int nny = ny + diry[nndir];\n            if(0 <= nnx && 0 <= nny && g[ny][nx][nny][nnx]) {\n                // print(\"dirx: %d, diry: %d\\n\", dirx[ndir\n                // printf(\"nnx: %d, nny: %d, nndir: %d\\n\", nnx, nny, nndir);\n                return (State){nx, ny, nndir};\n            }else {\n                return (State){nx, ny, ndir};\n            }\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> a;\n    for(int i=0;i<9;i++) {\n        a.push_back(inputLine());\n    }\n    for(int i=0;i<Y;i++) {\n        for(int j=0;j<X;j++) {\n            for(int k=0;i<Y;i++) {\n                for(int l=0;j<X;j++) {\n                    g[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n    for(int i=0;i<4;i++) {\n        for(int j=0;j<a[0].size();j++) {\n            if(a[2*i][j] == 1) {\n                g[i][j][i][j+1] = true;\n                g[i][j+1][i][j] = true;\n            }\n        }\n        for(int j=0;j<a[1].size();j++) {\n            if(a[2*i+1][j] == 1) {\n                g[i][j][i+1][j] = true;\n                g[i+1][j][i][j] = true;\n            }\n        }\n    }\n    for(int j=0;j<a[0].size();j++) {\n        if(a[8][j] == 1) {\n            g[4][j][4][j+1] = true;\n            g[4][j+1][4][j] = true;\n        }\n    }\n    auto st = at((State){0, 0, 0});\n    while(st.x != 0 || st.y != 0) {\n        // printf(\"x: %d, y: %d, dir: %d\\n\", st.x, st.y, st.dir);\n        st = at(st);\n        // cout << st.dir << endl;\n    }\n    // printf(\"x: %d, y: %d, dir: %d\\n\", st.x, st.y, st.dir);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<20;i++){\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tcount++;\n\t\tif(count>100)return -1;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(x==0&& y==0){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  bool w[11][11]={{}};\n  for(int i=1;i<=9;i++){\n    for(int j=1+i%2;j<10;j+=2){\n      char c;\n      cin>>c;\n      w[i][j]=c-'0';\n    }\n  }\n  int y=0,x=2;\n  int d=1;\n  int dy[]={-1,0,1,0};\n  int dx[]={0,1,0,-1};\n  do{\n    const char *s=\"URDL\";\n    d=(d+1)%4;\n    while(w[y+dy[d]][x+dx[d]]){\n      cout<<s[(d+3)%4];\n      d=(d+3)%4;\n    }\n    y+=dy[d]*2;\n    x+=dx[d]*2;\n  }while(x);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nusing namespace std;\ntypedef long long  ll;\n\n/** Problem0037 : Path on a Grid **/\nint main()\n{\n\tbool wall[6][6][4]={0};\n\tstring s;\n\tint y=1;\n\trep(k, 9) {\n\t\tcin >> s;\n\t\tif (s.length()==4) {\n\t\t\trep(x, 4) {\n\t\t\t\tif (s[x]=='1') {\n\t\t\t\t\twall[x+1][y-1][3]=true;\n\t\t\t\t\twall[x+1][y][2]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (s.length()==5) {\n\t\t\tREP(x, 1, 6) {\n\t\t\t\tif (s[x-1]=='1') {\n\t\t\t\t\twall[x-1][y][1]=true;\n\t\t\t\t\twall[x][y][0]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty++;\n\t\t}\n\t}\n\twall[0][0][3]=true; wall[0][1][2]=true;\n\t\n\tint x=1, d=1; y=0;\n\tcout << \"R\";\n\twhile (1) {\n\t\tswitch (d) {\n\t\t\tcase 1:\n\t\t\t\tif (wall[x][y][1]) {\n\t\t\t\t\tif (wall[x][y][2]) {\n\t\t\t\t\t\td=0;\n\t\t\t\t\t\tcout << \"U\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty--; d=2;\n\t\t\t\t\t\tcout << \"RU\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x+1][y][3]) {\n\t\t\t\t\tx++; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else if (wall[x][y+1][1]) {\n\t\t\t\t\ty++; x++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else {\n\t\t\t\t\ty++; d=0;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (wall[x][y][3]) {\n\t\t\t\t\tif (wall[x][y][1]) {\n\t\t\t\t\t\td=2;\n\t\t\t\t\t\tcout << \"R\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx++; d=1;\n\t\t\t\t\t\tcout << \"DR\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x][y+1][0]) {\n\t\t\t\t\ty++; d=3;\n\t\t\t\t\tcout << \"D\";\n\t\t\t\t} else if (wall[x-1][y][3]) {\n\t\t\t\t\tx--; y++; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else {\n\t\t\t\t\tx--; d=2;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 0:\n\t\t\t\tif (wall[x][y][0]) {\n\t\t\t\t\tif (wall[x][y][3]) {\n\t\t\t\t\t\td=1;\n\t\t\t\t\t\tcout << \"D\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty++; d=3;\n\t\t\t\t\t\tcout << \"LD\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x-1][y][2]) {\n\t\t\t\t\tx--; d=0;\n\t\t\t\t\tcout << \"L\";\n\t\t\t\t} else if (wall[x][y-1][0]) {\n\t\t\t\t\tx--; y--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else {\n\t\t\t\t\ty--; d=1;\n\t\t\t\t} break;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (wall[x][y][2]) {\n\t\t\t\t\tif (wall[x][y][0]) {\n\t\t\t\t\t\td=3;\n\t\t\t\t\t\tcout << \"L\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx--; d=0;\n\t\t\t\t\t\tcout << \"UL\";\n\t\t\t\t\t}\n\t\t\t\t} else if (wall[x][y-1][1]) {\n\t\t\t\t\ty--; d=2;\n\t\t\t\t\tcout << \"U\";\n\t\t\t\t} else if (wall[x+1][y][2]) {\n\t\t\t\t\tx++; y--; d=1;\n\t\t\t\t\tcout << \"R\";\n\t\t\t\t} else {\n\t\t\t\t\tx++; d=3;\n\t\t\t\t} break;\n\t\t}\n\t\tcout << flush;\n\t\tif (d==2 && x==0 && y==1)\n\t\t\tbreak;\n\t\tif (d==0 && x==0 && y==1)\n\t\t\tbreak;\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define r(i,n) for(int i=0;i<n;++i)\nint f[5][5];\nmain(e,f)\n{\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\tint d=p;\n\t\tdo\n\t\t\td=(d+1)%4;\n\t\twhile(!((f[y][x]>>d)&1));\n\t\tp=d;\n\t\tputchar(\"URDL\"[d]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[d];\n\t\ty+=dy[d];\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool h[100][100]; // setinel\nbool v[100][100];\n\n\nint main(){\n\tstring str, ans = \"\";\n\tchar dir = 'n';\n\tint mx = 1;\n\tint my = 1;\n\n\tint i, j, len;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tfor (j = 0; j < 100; j++) {\n\t\t\th[i][j] = v[i][j] = false;\n\t\t}\n\t}\n\n\ti = j = 1;\n\twhile(cin >> str){\n\t\tif(i == 1) len = str.size();\n\t\tif(str.size() == len){\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\th[i][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\ti++;\n\t\t}else{\n\t\t\tfor (int k = 0; k < str.size(); k++) {\n\t\t\t\tv[j][k+1] = str[k] == '1' ? true : false;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tdo{\n\t\tif (v[my-1][mx] && dir != 'D' && (dir=='R' || !h[my][mx-1])) {\n\t\t\tdir = 'U';\n\t\t\tmy--;\n\t\t}else if (h[my][mx] && dir != 'L' && (dir=='D' || !v[my-1][mx])) {\n\t\t\tdir = 'R';\n\t\t\tmx++;\n\t\t}else if (v[my][mx] && dir != 'U' && (dir=='L' || !h[my][mx])) {\n\t\t\tdir = 'D';\n\t\t\tmy++;\n\t\t}else if (h[my][mx-1] && dir != 'R' && (dir=='U' || !v[my][mx])) {\n\t\t\tdir = 'L';\n\t\t\tmx--;\n\t\t}\n\t\tans += dir;\n\t}while(!(mx == 1 && my == 1));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nchar ver[10][10], hol[10][10];\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst char dir[] = {'U','R','D','L'};\n\nvoid input() {\n  scanf(\"%s\", hol[1]+1);\n  rep(i,4) {\n    scanf(\"%s\", ver[i+1]+1);\n    scanf(\"%s\", hol[i+2]+1);\n  }\n  rep(i,8) rep(j,8) {\n    if (hol[i][j] == '1') hol[i][j] = 1;\n    else hol[i][j] = 0;\n    if (ver[i][j] == '1') ver[i][j] = 1;\n    else ver[i][j] = 0;\n  }\n  // rep(i,8) {\n  //   putchar(' ');\n  //   rep(j,8) printf(\"%2d\", hol[i][j]); puts(\"\");\n  //   rep(j,8) printf(\"%2d\", ver[i][j]); puts(\"\");\n  // }\n}\n\nbool is_end(int x, int y, int d) {\n  return (x == 0 && y == 1 && d == 0) ||\n      (x == 1 && y == 1 && d == 3);\n}\n\nvoid update(int &x, int &y, int &d) {\n  const int bx = x, by = y, bd = d;\n  switch (d) {\n    case 0: {\n      if (hol[y][x]) d = 3;\n      else if (ver[y-1][x+1]) --y;\n      else if (hol[y][x+1]) { ++x; --y; d = 1; }\n      else { d = 2; ++x; }\n      break;\n    }\n    case 1: {\n      if (ver[y][x+1]) d = 0;\n      else if (hol[y+1][x+1]) ++x;\n      else if (ver[y+1][x+1]) { ++x; ++y; d = 2; }\n      else { d = 3; ++y; }\n      break;\n    }\n    case 2: {\n      if (hol[y+1][x]) d = 1;\n      else if (ver[y+1][x]) ++y;\n      else if (hol[y+1][x-1]) { --x; ++y; d = 3; }\n      else { d = 0; --x; }\n      break;\n    }\n    case 3: {\n      if (ver[y][x]) d = 2;\n      else if (hol[y][x-1]) --x;\n      else if (ver[y-1][x]) { --x; --y; d = 0; }\n      else { d = 1; --y; }\n      break;\n    }\n  }\n  if (bx == x && by == y && bd == d) {\n    printf(\"%d %d %d\\n\", x, y, d);\n    assert(false);\n  }\n}\n\nvoid solve() {\n  int x = 1, y = 0, d = 1;\n  string ans = \"R\";\n  do {\n    // printf(\"%d,%d - %d : %s\\n\", x, y, d, ans.c_str());\n    update(x, y, d);\n    ans += dir[d];\n  } while (!is_end(x,y,d));\n  printf(\"%s\\n\", ans.c_str());\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nstring str[1000];\nint len;\nint fie[1001][1001];\nint flag[1001][1001][4];\nint m;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar s[4]={'R','D','L','U'};\nint main(void){\n\tint n=0;\n\twhile(cin >> str[n])n++;\n\tm=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif(str[i][j]=='1'){\n\t\t\t\tif(i%2==0)fie[j*2+2][i+1]=1;\n\t\t\t\tif(i%2==1)fie[j*2+1][i+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint x=2,y=0,dir=0;\n\twhile(1){\n\t\tint nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==1)printf(\"%c\",s[dir]);\n\t\t}\n\t\tnx=x+dx[dir],ny=y+dy[dir];\n\t\tif(nx>=0 && nx<=m*2+2 && ny>=0 && ny<=n+1){\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tx+=dx[dir]*2;\n\t\t\t\ty+=dy[dir]*2;\n\t\t\t\tif(fie[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]]==0){\n\t\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(fie[x+dx[(dir+3)%4]][y+dy[(dir+3)%4]]==0){\n\t\t\t\t\tdir=(dir+3)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}else{\n\t\t\t\t\tdir=(dir+2)%4;\n\t\t\t\t\tx+=dx[dir]*2;\n\t\t\t\t\ty+=dy[dir]*2;\n\t\t\t\t\tprintf(\"%c\",s[(dir+1)%4]);\n\t\t\t\t\tprintf(\"%c\",s[dir]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d %d %d\\n\",x,y,dir,dx[dir],dy[dir]);\n\t\tif(x==0 && y==0)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst char *dat = \"RDLU\";\n\nint w[6][6][4];\n\nint main() {\n    rep (i, 9) {\n        char t;\n        if (i % 2 == 0) {\n            rep (j, 4) {\n                scanf(\" %c\", &t);\n                if (t == '1') w[i/2][j][0] = w[i/2][j+1][2] = 1;\n            }\n        }\n        else {\n            rep (j, 5) {\n                scanf(\" %c\", &t);\n                if (t == '1') w[i/2][j][1] = w[i/2+1][j][3] = 1;\n            }\n        }\n    }\n    int x = 0, y = 0, d = 0;\n    do {\n        rep (i, 4) {\n            const int nd = (d+i) % 4;\n            if (w[y][x][nd]) {\n                putchar(dat[nd]);\n                x += dx[nd];\n                y += dy[nd];\n                d = (nd + 3) % 4;\n                break;\n            }\n        }\n    } while (x != 0 || y != 0);\n    putchar('\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<maphor[0].size()&&-1<j&&j<maphor[0].size()){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<maphor.size()&&-1<j-1&&j-1<maphor[0].size()){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<mapver.size()&&-1<j&&j<mapver[0].size()){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\tint count=0;\n\twhile(1){\n\t\tfor(int i=0;i<5;i++){\n\t\t\tif(i==4)return -1;\n\t\t\tif(count!=0\n\t\t\t\t&&x==0\n\t\t\t\t&& y==0\n\t\t\t\t&&(((v+loop[i])%4)==2 || ((v+loop[i])%4==1))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tif(solve()==-1)return -1;\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<queue>\nusing namespace std;\n\nint main(){\n\tchar stage[9][5] = {};\n\tfor (int i = 0; i < 9; i++){\n\t\tcin >> stage[i];\n\t\tfor (int j = 0; j < 5; j++){\n\t\t\tif (stage[i][j] != 0){\n\t\t\t\tstage[i][j] -= '0';\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int i = 0; i < 9; i++){ for (int j = 0; j < 5; j++) printf(\"%d \", stage[i][j]); puts(\"\"); }\n\n\tint y = 0, x = 0, ny, nx, situ = 1;\n\tint situ_y[4] = { -1, 0, 1, 0 }, situ_x[4] = { 0, 0, 0, -1 };\n\tint np_y[4] = { -2, 0, 2, 0 }, np_x[4] = { 0, 1, 0, -1 };\n\tchar situ_char[4] = { 'U', 'R', 'D', 'L' };\n\tdo{\n\t\tsitu += 3;\n\t\tsitu %= 4;\n\t\t//printf(\"%d,%d  \", x, y);\n\t\tfor (int i = 0; i < 4; i++, situ = (situ + 1) % 4){\n\t\t\tny = y + situ_y[situ];\n\t\t\tnx = x + situ_x[situ];\n\t\t\t//printf(\" %d:%d,%d\", situ, ny, nx);\n\t\t\tif (ny < 0 || 8 < ny || nx < 0 || 4 < nx) continue;\n\t\t\tif (stage[ny][nx] == 1){\n\t\t\t\ty += np_y[situ];\n\t\t\t\tx += np_x[situ];\n\t\t\t\t//printf(\"test\\n\");\n\t\t\t\tprintf(\"%c\", situ_char[situ]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (y != 0 || x != 0);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar*S=\"RDLU\",c;\nint main()\n{\n\tint e[5][5][4]={};\n\tint i,j,x,y,a;\n\tfor(i=0;i<9;++i)\n\t{\n\t\tif(i&1)\n\t\t\tfor(j=0;j<5;++j)\n\t\t\t\tscanf(\" %c\",&c),e[i/2][j][1]=e[i/2+1][j][3]=c-'0';\n\t\telse\n\t\t\tfor(j=0;j<4;++j)\n\t\t\t\tscanf(\" %c\",&c),e[i/2][j][0]=e[i/2][j+1][2]=c-'0';\n\t}\n\tfor(x=y=a=0;;)\n\t{\n\t\tif(e[y][x][(a+3)%4])\n\t\t{\n\t\t\ta=(a+3)%4;\n\t\t\tputchar(S[a]);\n\t\t\tx+=dx[a];\n\t\t\ty+=dy[a];\n\t\t}\n\t\telse if(e[y][x][a])\n\t\t{\n\t\t\tputchar(S[a]);\n\t\t\tx+=dx[a];\n\t\t\ty+=dy[a];\n\t\t}\n\t\telse if(e[y][x][(a+1)%4])\n\t\t{\n\t\t\ta=(a+1)%4;\n\t\t\tputchar(S[a]);\n\t\t\tx+=dx[a];\n\t\t\ty+=dy[a];\n\t\t}\n\t\telse a=(a+2)%4;\n\t\tif(x+y+a==0)break;\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<vector<vector<bool> > > wall(5, vector<vector<bool> >(5, vector<bool>(4, false)));\n\n    for(int i=0; i<5; ++i){\n        for(int j=0; j<4; ++j){\n            char a;\n            cin >> a;\n            if(a == '1')\n                wall[i][j][0] = wall[i][j+1][2] = true;\n        }\n        if(i < 4){\n            for(int j=0; j<5; ++j){\n                char a;\n                cin >> a;\n                if(a == '1')\n                    wall[i][j][1] = wall[i+1][j][3] = true;\n            }\n        }\n    }\n\n    char dir[] = {'R', 'D', 'L', 'U'};\n    int dy[] = {0, 1, 0, -1};\n    int dx[] = {1, 0, -1, 0};\n\n    int y = 0;\n    int x = 0;\n    int d = 0;\n    do{\n        if(wall[y][x][d]){\n            y += dy[d];\n            x += dx[d];\n            cout << dir[d];\n            d += 3;\n            d %= 4;\n        }else{\n            ++ d;\n            d %= 4;\n        }\n    }while(y != 0 || x != 0);\n\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring line[9];\n\nbool check( int x, int y ) {\n    if ( y < 0 || y >= 9 ) return false;\n    if ( y % 2 == 0 ) {\n        if ( x < 0 || x >= 4 ) return false;\n    } else {\n        if ( x < 0 || x >= 5 ) return false;\n    }\n    return true;\n}\n\nvoid solve( int a, int x, int y ) {\n    if ( y % 2 == 0 ) {\n        cout << ( a ? \"R\" : \"L\" );\n    } else {\n        cout << ( a ? \"U\" : \"D\" );\n    }\n\n    if ( y % 2 == 0 ) {\n        if ( a ) {\n            if ( check(x+1,y-1) && line[y-1][x+1] == '1' ) {\n                solve( 1, x+1, y-1 );\n            } else if ( check(x+1,y) && line[y][x+1] == '1' ) {\n                solve( 1, x+1, y );\n            } else if ( check(x+1,y+1) && line[y+1][x+1] == '1' ) {\n                solve( 0, x+1, y+1 );\n            }\n        } else {\n            if ( check(x,y-1) && line[y-1][x] == '1' ) {\n                solve( 1, x, y-1 );\n            } else if ( check(x-1,y) && line[y][x-1] == '1' ) {\n                solve( 0, x-1, y );\n            } else if ( check(x,y+1) && line[y+1][x] == '1' ) {\n                solve( 0, x, y+1 );\n            }\n        }\n    } else {\n        if ( a ) {\n            if ( check(x-1, y-1) && line[y-1][x-1] == '1' ) {\n                solve( 0, x-1, y-1 );\n            } else if ( check(x, y-2) && line[y-2][x] == '1' ) {\n                solve( 1, x, y-2 );\n            } else if ( check(x, y-1) && line[y-1][x] == '1' ) {\n                solve( 0, x, y-1 );\n            }\n        } else {\n            if ( check(x, y+1) && line[y+1][x] == '1' ) {\n                solve( 1, x, y+1 );\n            } else if ( check(x, y+2) && line[y+2][x] == '1' ) {\n                solve( 0, x, y+2 );\n            } else if ( check(x-1, y+1) && line[y+1][x-1] == '1' ) {\n                solve( 0, x-1, y+1 );\n            }\n        }\n    }\n}\n\nint main() {\n    for ( int i = 0; i < 9; i++ ) {\n        cin >> line[i];\n    }\n\n    solve( 1, 0, 0 );\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include<math.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nbool rangeCheck(int row, int col){\n    if(row % 2 == 0){\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 3)return true;\n        else{\n            return false;\n        }\n    }else{\n        if(row >= 0 && row <= 8 && col >= 0 && col <= 4)return true;\n        else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int checkTable[9][5][4],row,col;\n    char array[9][6];\n\n    for(int i = 0; i < 9; i++){\n        for(int k=0; k < 5; k++){\n            for(int p=0;p<4;p++){\n            \tcheckTable[i][k][p] = 0;\n            }\n        }\n    }\n\n    for(int i=0;i < 9; i++){\n        scanf(\"%s\",array[i]);\n    }\n\n    printf(\"R\");\n    char current = 'R';\n\n    checkTable[0][0][1] = 1;\n\n    row = 0,col = 0;\n\n    while(true){\n        switch(current){\n        case 'L':\n            if(rangeCheck(row,col-1)&&checkTable[row][col-1][0] == 0 && array[row][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row][col-1][0] = 1;\n                col = col-1;\n            }else if(rangeCheck(row+1,col)&&checkTable[row+1][col][3] == 0 && array[row+1][col] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col][3] = 1;\n                current = 'D';\n                row = row+1;\n            }else if(rangeCheck(row-1,col)&&checkTable[row-1][col][2] == 0 && array[row-1][col] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col][2] = 1;\n                current = 'U';\n                row = row-1;\n            }else{\n                printf(\"R\");\n                current = 'R';\n            }\n            break;\n        case 'R':\n            if(rangeCheck(row,col+1)&&checkTable[row][col+1][1] == 0 && array[row][col+1] == '1'){\n                printf(\"R\");\n                checkTable[row][col+1][1] = 1;\n                col = col+1;\n            }else if(rangeCheck(row-1,col+1)&&checkTable[row-1][col+1][2] == 0 && array[row-1][col+1] == '1'){\n                printf(\"U\");\n                checkTable[row-1][col+1][2] = 1;\n                current = 'U';\n                row = row-1;\n                col = col+1;\n            }else if(rangeCheck(row+1,col+1)&&checkTable[row+1][col+1][3] == 0 && array[row+1][col+1] == '1'){\n                printf(\"D\");\n                checkTable[row+1][col+1][3] = 1;\n                current = 'D';\n                row = row+1;\n                col = col+1;\n            }else{\n                printf(\"L\");\n                current = 'L';\n            }\n            break;\n        case 'U':\n            if(rangeCheck(row-2,col)&&checkTable[row-2][col][2] == 0 && array[row-2][col] == '1'){\n                printf(\"U\");\n                checkTable[row-2][col][2] = 1;\n                row = row - 2;\n            }else if(rangeCheck(row-1,col-1)&&checkTable[row-1][col-1][0] == 0 && array[row-1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row-1][col-1][0] = 1;\n                current = 'L';\n                row = row-1;\n                col = col-1;\n            }else if(rangeCheck(row-1,col)&&checkTable[row-1][col][1] == 0 && array[row-1][col] == '1'){\n                printf(\"R\");\n                checkTable[row-1][col][1] = 1;\n                current = 'R';\n                row = row-1;\n            }else{\n               printf(\"D\");\n               current = 'D';\n            }\n            break;\n        case 'D':\n            if(rangeCheck(row+2,col)&&checkTable[row+2][col][3] == 0 && array[row+2][col] == '1'){\n                printf(\"D\");\n                checkTable[row+2][col][3] = 1;\n                row = row+2;\n            }else if(rangeCheck(row+1,col)&&checkTable[row+1][col][1] == 0 && array[row+1][col] == '1'){\n                printf(\"R\");\n                checkTable[row+1][col][1] = 1;\n                current = 'R';\n                row = row+1;\n            }else if(rangeCheck(row+1,col-1)&&checkTable[row+1][col-1][0] == 0 && array[row+1][col-1] == '1'){\n                printf(\"L\");\n                checkTable[row+1][col-1][0] = 1;\n                current = 'L';\n                row = row +1;\n                col = col -1;\n            }else{\n            \tprintf(\"U\");\n            \tcurrent = 'U';\n            }\n            break;\n        }\n        if(row == 0 && col == 0)break;\n    }\n\n   printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string> \n#include<vector>\n#include<iostream>\nusing namespace std;\nbool map[20][20][4];\nvector< string > maphor,mapver;\nint xsize,ysize;\nvoid init(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tmap[i][j][k]=0;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid setmap(){\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tif(-1<i&&i<ysize&&-1<j&&j<xsize){\n\t\t\t\tif(maphor[i][j]=='1'){\n\t\t\t\t\tmap[i][j][0]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize&&-1<j-1&&j-1<xsize){\n\t\t\t\tif(maphor[i][j-1]=='1'){\n\t\t\t\t\tmap[i][j][2]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i&&i<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i][j]=='1'){\n\t\t\t\t\tmap[i][j][3]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(-1<i-1&&i-1<ysize-1&&-1<j&&j<xsize){\n\t\t\t\tif(mapver[i-1][j]=='1'){\n\t\t\t\t\tmap[i][j][1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint x=0,y=0;\n\tint v=0;\n\tstring vec=\"RULD\";\n\tint loop[4]={1,0,3,2};\n\tint vx[4]={1,0,-1,0};\n\tint vy[4]={0,-1,0,1};\n\twhile(1){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\t//cout<<vec[(v+loop[i])%4];\n\t\t\tif(x==0&&y==0&&(v+loop[i])%4==2){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(map[y][x][(v+loop[i])%4]==1){\n\t\t\t\tv+=loop[i];\n\t\t\t\tv=v%4;\n\t\t\t\tx+=vx[v];\n\t\t\t\ty+=vy[v];\n\t\t\t\t//cout<<endl;\n\t\t\t\tcout<<vec[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring tmp;\n\tfor(int i=0;cin.eof()!=true;i++){\n\t\tcin>>tmp;\n\t\tif(i%2==0){\n\t\t\tmaphor.push_back(tmp);\n\t\t}else{\n\t\t\tmapver.push_back(tmp);\n\t\t}\n\t}\n\txsize=maphor[0].size()+1;\n\tysize=mapver.size()+1;\n\tinit();setmap();\n\t\n\t/*\n\tfor(int i=0;i<xsize;i++){\n\t\tfor(int j=0;j<ysize;j++){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tcout<<map[i][j][k];\n\t\t\t}\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tsolve();\n\tcout<<endl;\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n//#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nstring s = \"URDL\";\nint dx[4] = { 0, 1,  0, -1};\nint dy[4] = {-1, 0,  1,  0};\n\nsigned main() {\n    string ans = \"\";\n    int f[5][5][4] = {0};\n    string wx[5];\n    string wy[4];\n    rep(i, 0, 9){\n        if(i % 2 == 0){\n            cin >> wx[i / 2];\n        }else{\n            cin >> wy[i / 2];\n        }\n    }\n    f[0][0][0] = 1;\n    int y = 0, x = 0, dir = 0;\n    while(1){\n        rep(i, 0, 4){\n            int tmp = (dir + i) % 4;\n            int ny = y + dy[tmp];\n            int nx = x + dx[tmp];\n            if(!(0 <= ny && ny <= 4 && 0 <= nx && nx <= 4)) continue;\n            if(tmp == 0 && wy[y - 1][x] == '0') continue;\n            if(tmp == 1 && wx[y][x] == '0') continue;\n            if(tmp == 2 && wy[y][x] == '0') continue;\n            if(tmp == 3 && wx[y][x - 1] == '0') continue;\n            if(f[ny][nx][(dir + i + 3) % 4] == true) continue;\n            f[ny][nx][(dir + i + 3) % 4] = true;\n            y = ny;\n            x = nx;\n            dir = (dir + i + 3) % 4;\n            ans += s[tmp];\n            //o(y<<\" \"<<x<<\" \"<<dir<<\" \"<<ny<<\" \"<<nx<<\" \"<<tmp<<\" \"<<s[tmp]);\n            break;\n        }\n        if(f[0][0][2] || f[0][0][3]) break;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 今向いている方向にとっての左から始めて、時計回りに壁を探して、最初にみつけた壁の方向に進む\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct Direction {\n  bool u, d, r, l;\n};\n\nvoid dump_Direction(Direction di) {\n  cout << \"[\" << di.u << di.r << di.d << di.l << \"]\";\n}\n\n\n\nint main() {\n  // ifstream cin(\"../test.txt\");\n  Direction g[5][5];\n  for (int i = 0; i < 5; i++) {\n    for (int j = 0; j < 5; j++) {\n      g[i][j].u = false;\n      g[i][j].d = false;\n      g[i][j].r = false;\n      g[i][j].l = false;\n    }\n  }\n  for (int i = 0; i < 9; i++) {\n    string s;\n    cin >> s;\n    if (i % 2 == 0) {\n      for (int j = 0; j < 4; j++) {\n        int k = i / 2;\n        g[k][j].r = (s[j] == '1');\n        g[k][j+1].l = (s[j] == '1');\n      }\n    } else {\n      for (int j = 0; j < 5; j++) {\n        int k = i / 2;\n        g[k][j].d = (s[j] == '1');\n        g[k+1][j].u = (s[j] == '1');\n      }\n    }\n  }\n  // 表示用\n  // for (int i = 0; i < 5; i++) {\n  //   for (int  j = 0; j < 5; j++) {\n  //     dump_Direction(g[i][j]);\n  //   }\n  //   cout << endl;\n  // }\n\n  int x = 0;\n  int y = 0;\n  int d = 0; // 0: u, 1: r, 2: d, 3: l\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  char c[] = {'U','R','D','L'};\n  while (true) {\n    bool dir[] = {g[y][x].u, g[y][x].r, g[y][x].d, g[y][x].l};\n    // dump_Direction(g[y][x]);\n    int i = 0;\n    for (;i < 4; i++) {\n      if (dir[(i+d)%4]) break;\n    }\n    int j = (i+d)%4;\n    // cout << j;\n    x += dx[j];\n    y += dy[j];\n    cout << c[j];\n    d = (j + 3) % 4;\n    if (!(x|y)) break;\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nint pack(int x, int y) {\n    return x*5+y;\n}\n\nPoint unpack(int p) {\n    return make_pair(p/5, p%5);\n}\n\nbool can(const vector<vector<int> > &v, int x1, int y1, int x2, int y2) {\n    if(x1 < 0 || y1 < 0 || x1 >= 5 || y1 >= 5) return false;\n    if(x2 < 0 || y2 < 0 || x2 >= 5 || y2 >= 5) return false;\n    return v[pack(x1,y1)][pack(x2,y2)];\n}\n\nint main() {\n    vector<vector<int> > v(30, vector<int>(30, 0));\n    for(int i = 0; i < 9; ++i) {\n        string str;\n        cin >> str;\n        for(int j = 0; j < str.size(); ++j) {\n            if(i % 2 == 0) v[pack(j, i/2)][pack(j+1, i/2)] = v[pack(j+1,i/2)][pack(j,i/2)] = str[j]-'0';\n            else v[pack(j, i/2)][pack(j, i/2+1)] = v[pack(j,i/2+1)][pack(j,i/2)] = str[j]-'0';\n        }\n    }\n\n    const char *dirchar = \"RDLU\";\n    const int delta[][2] = {\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\n    };\n    int x = 0, y = 0;\n    int dir = 0;\n    while(true) {\n        cout << dirchar[dir];\n        x += delta[dir][0];\n        y += delta[dir][1];\n        if(x == 0 && y == 0) break;\n\n        int left = (dir+3)%4;\n        int right = (dir+1)%4;\n        if(!can(v, x,y, x+delta[dir][0],y+delta[dir][1])) {\n            if(can(v, x,y, x+delta[left][0],y+delta[left][1])) {\n                dir = left;\n            }\n            else if(can(v, x,y, x+delta[right][0],y+delta[right][1])) {\n                dir = right;\n            }\n            else dir = (dir+2)%4;\n        }\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\nvoid disp_room (vector <vector <int> > room )\n{\n\tint size = room.size();\n\tint len  = room[0].size();\n\tint i, j;\n\t\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < len; ++j){\n\t\t\tcout << setw(2) << room[i][j] << ' ';\n\t\t} // end for\n\t\tcout << endl;\n\t} // end for\n\tcout << endl;\n}\n#define East  1\n#define South 2\n#define West  4\n#define North 8\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.pg\", \"r\", stdin);\n\tstring str = \"\";\n\tvector <string> grid;\n\tint maxlen = 0;\n\n\twhile (getline (cin, str ) ){\n\t\tif (str.empty() ){\n\t\t\tbreak;\n\t\t} // end if\n\t\tint len = str.length();\n\t\tmaxlen = max (maxlen, len );\n\t\tgrid.push_back(str );\n\t} // end while\n\n\tint size = grid.size();\n\tvector <vector <int> > room((size+1)/2+1, vector <int> (maxlen, 0 ) );\n\tint i,j,k;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < grid[i].length(); ++j){\n\t\t\tif (grid[i][j] == '1'){\n\t\t\t\tif (i % 2 == 0){\t// north or south wall\n\t\t\t\t\troom[i/2][j] |= South;\n\t\t\t\t}else{\t\t\t// east or west wall\n\t\t\t\t\troom[i/2+1][j-1] |= East;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\t\n//\tdisp_room (room );\n\n\tfor (i = 0; i < room.size(); ++i){\n\t\tfor (j = 0; j < room[i].size(); ++j){\n\t\t\tif (i == 0){\n\t\t\t\troom[i][j] |= North;\n\t\t\t}else if (i == room.size() - 1){\n\t\t\t\troom[i][j] |= South;\n\t\t\t} // end if\n\t\t\tif (i > 0 && room[i-1][j] & South){\n\t\t\t\troom[i][j] |= North;\n\t\t\t} // end if\n\t\t\tif (j == 0){\n\t\t\t\troom[i][j] |= West;\n\t\t\t}else if (j == room[i].size() - 1){\n\t\t\t\troom[i][j] |= East;\n\t\t\t} // end if\n\t\t\tif (j > 0 && room[i][j-1] & East){\n\t\t\t\troom[i][j] |= West;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n//\tdisp_room (room );\n\n\tint row = 0;\n\tint col = 0;\n\tint dir = East;\n\tint right_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n\tstring res = \"\";\n\tres += 'R';\n\tbool turn = false;\n\tint reach = 0;\n\n\tdo{\n\t\tif (turn || (right_hand & room[row][col]) ){\n\t\t\tturn = false;\n\t\t\t// go faword\n\t\t\tswitch (dir){\n\t\t\t\tcase East:\n\t\t\t\t\tif (!(room[row][col] & East)){ \n\t\t\t\t\t\t++col;// res += 'R';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = North;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\t\t\t\t\tif (!(room[row][col] & South)){\n\t\t\t\t\t \t++row;// res += 'D';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = East;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\t\t\t\t\tif (!(room[row][col] & West)){\n\t\t\t\t\t\t--col;// res += 'L';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = South;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase North:\n\t\t\t\t\tif (!(room[row][col] & North)){\n\t\t\t\t\t\t--row;// res += 'U';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = West;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if  \n\t\t\t\t\tbreak;\n\t\t\t} // end switch\n\t\t}else{\n\t\t\t// turn\n\t\t\tswitch (dir){\n\t\t\t\tcase East:  dir = South; break;\n\t\t\t\tcase South: dir = West; break;\n\t\t\t\tcase West:  dir = North; break;\n\t\t\t\tcase North: dir = East; break;\n\t\t\t} // end switch\n\t\t\tturn = true;\n\t\t} // end if\n\n\t\tright_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n//\t\tcout << '(' << row << ',' << col << ')';\n//\t\tcout << \" dir: \" << dir;\n//\t\tcout << \" res; \" << res << endl; //res[res.length()-1] << endl;\n\t\tif (row == 1 && col == 0){\n\t\t\t++reach;\n\t\t} // end if\n//\t} while(row != 0 || col != 0);// end while\n\t} while (reach < 3);\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N=6;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst string op=\"RDLU\";\nenum{RIGHT=0,DOWN,LEFT,UP};\nint m[N][N];\nbool e[N][N][N];\n\n\nstring solve(){\n  int y=0,x=1,r=RIGHT;\n  string ret=\"\";\n  do{\n    bool a=true;\n    if (!e[y][x][(r+1)%4])r=(r+1)%4;\n    while(e[y][x][r])ret+=op[r],r=(r+3)%4;\n    if (e[y][x][(r+1)%4])ret+=op[r];\n    y+=dy[r];\n    x+=dx[r];\n  }while(y != 0 || x != 1);\n  return ret;\n}\n\nmain(){\n  rep(i,N)rep(j,N)rep(k,4)e[i][j][k]=false;\n  rep(i,5){\n    string tmp;\n    cin>>tmp;\n    rep(j,4)if (tmp[j] == '1')e[i][j+1][DOWN]=e[i+1][j+1][UP]=true;\n    if (i == 4)break;\n    cin>>tmp;\n    rep(j,5)if (tmp[j] == '1')e[i+1][j][RIGHT]=e[i+1][j+1][LEFT]=true;\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[9][9][4],x,y,dir=1;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring s=\"URDL\";\nint main(){\n  r(i,9){\n    if(i%2){\n      r(j,5){\n        scanf(\"%1d\",&x);\n        if(x)a[i/2][j][2]=a[i/2+1][j][0]=1;\n      }\n    }else{\n      r(j,4){\n        scanf(\"%1d\",&x);\n        if(x)a[i/2][j][1]=a[i/2][j+1][3]=1;\n      }\n    }\n  }x=1;\n  while(!(!x&&!y)){\n    cout<<s[dir];\n    if(a[y][x][(dir+3)%4])dir=(dir+3)%4;\n    else if(a[y][x][dir]);\n    else if(a[y][x][(dir+1)%4])dir=(dir+1)%4;\n    else dir=(dir+2)%4;\n    x+=dx[dir];\n    y+=dy[dir];\n  }\n  cout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  bool w[11][11]={{}};\n  for(int i=1;i<=9;i++){\n    for(int j=1+i%2;j<10;j+=2){\n      char c;\n      cin>>c;\n      w[i][j]=c-'0';\n    }\n  }\n  int y=0,x=2;\n  int d=1;\n  int dy[]={-1,0,1,0};\n  int dx[]={0,1,0,-1};\n  do{\n    const char *s=\"URDL\";\n    d=(d+1)%4;\n    while(w[y+dy[d]][x+dx[d]]){\n      cout<<s[(d+3)%4];\n      d=(d+3)%4;\n    }\n    y+=dy[d]*2;\n    x+=dx[d]*2;\n  }while(x||y);\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-10;\n\nint main() {\n\tstring s[16], ans(\"R\");\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tint x = 0, y = 0;\n\tint d = 0; // 0:right, 1:down, 2:left, 3:up\n\tbool flag = false;\n\twhile(1){\n\t\tif(d == 0){\n\t\t\tif(s[y][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x + 1] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\tx += 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\telse if(d == 1){\n\t\t\tif(s[y + 2][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 2;\n\t\t\t}\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y + 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 2){\n\t\t\tif(s[y][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t}\n\t\telse if(d == 3){\n\t\t\tif(y >= 3 && s[y - 2][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 2;\n\t\t\t}\n\t\t\telse if(s[y - 1][x] == '1'){\n\t\t\t\ty -= 1;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y - 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\ty -= 1;\n\t\t\t\tx -= 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\t/*if(x == 3 && y == 3 && flag)\n\t\t\tbreak;\n\t\tif(x == 3 && y == 3){\n\t\t\tflag = true;\n\t\t\t//break;\n\t\t}*/\n\t\tif(x == 0 && y == 0)\n\t\t\tbreak;\n\t}\n\t/*cout << s[3][3] << endl;\n\tcout << d << endl;*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "      }\n      else if(ex[vy][vx-1] == 1) {\n        vx--;\n        direction = 3;\n        cout << \"L\";\n      }\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nvector<pair<int, int>> G[55];\n\nint main() {\n\n  rep(i, 5) {\n    char x;\n    rep(j, 4) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back(i * 5 + j + 1, 2);\n        G[i * 5 + j + 1].emplace_back(i * 5 + j, 0);\n      }\n    }\n\n    if(i == 4) break;\n\n    rep(j, 5) {\n      cin >> x;\n      if(x-'0') {\n        G[i * 5 + j].emplace_back((i + 1) * 5 + j, 3);\n        G[(i + 1) * 5 + j].emplace_back(i * 5 + j, 1);\n      }\n    }\n  }\n\n  string const OP = \"LURD\";\n\n  int y = 0, x = 0, d = 2;\n\n  while(y != 0 || x != 0 || d != 0) {\n    int le = -1, st = -1, ri = -1;\n    for(auto && e: G[y * 5 + x]) {\n      if(e.second == (d + 3) % 4) le = e.second;\n      if(e.second == (d + 1) % 4) ri = e.second;\n      if(e.second == d) st = e.second;\n    }\n    if(le != -1) d = le;\n    else if(st != -1) ;\n    else if(ri != -1) d = ri;\n    y += dy[d], x += dx[d];\n    cout << OP[d];\n  }\n  cout << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6] = {0},a,next_x = 1,next_y = 0,t = 2;\n  for(int i=0; i<5; i++){\n    for(int j=0; j<4; j++){\n      scanf(\"%1d\",&a);\n      field[j+1][i]+=(a<<2);\n      field[j+1][i+1]+=(a<<0);\n    }\n    if(i<4){\n      for(int j=0; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[j][i+1]+=(a<<1);\n\tfield[j+1][i+1]+=(a<<3);\n      }\n    }\n  }\n  for(;;){\n    if(t == 1){\n      if(field[next_x][next_y]&2){\n\tcout <<\"U\";\n\tif(field[next_x][next_y]&1){t = 8;}\n\telse{next_y--;}\n      }\n      else{next_x++;t = 2;}\n    }\n    else if(t == 2){\n      if(field[next_x][next_y]&4){\n\tcout <<\"R\";\n\tif(field[next_x][next_y]&2){t = 1;}\n\telse{next_x++;}\n      }\n      else{next_y++;t = 4;}\n    }\n    else if(t == 4){\n      if(field[next_x][next_y]&8){\n\tcout <<\"D\";\n\tif(field[next_x][next_y]&4){t = 2;}\n\telse{next_y++;}\n      }\n      else{next_x--;t = 8;}\n    }\n    else if(t == 8){\n      if(field[next_x][next_y]&1){\n\tcout <<\"L\";\n\tif(field[next_x][next_y]&8){t = 4;}\n\telse{next_x--;}\n      }\n      else{next_y--;t = 1;}\n    }\n    if(!next_x && !next_y){break;}\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int field[6][6]={0};\n  for(int i=0; i<9; i++){\n    if(i%2 == 0){\n      for(int j=0,a; j<4; j++){\n\tscanf(\"%1d\",&a);\n\tfield[i/2][j+1]+=4*a;\n\tfield[i/2+1][j+1]+=a;\n      }\n    }\n    else{\n      for(int j=0,a; j<5; j++){\n\tscanf(\"%1d\",&a);\n\tfield[i/2+1][j]+=2*a;\n\tfield[i/2+1][j+1]+=8*a;\n      }\n    }\n  }\n  int x=0,y=1,d=2;\n  for(;;){\n    if(d == 1){\n      if(!(field[x][y]&2)){d = 2;y++;}\n      else if(field[x][y]&1){cout <<\"U\";d = 8;}\n      else{cout <<\"U\";x--;}\n    }\n    else if(d == 2){\n      if(!(field[x][y]&4)){d = 4;x++;}\n      else if(field[x][y]&2){cout <<\"R\";d = 1;}\n      else{cout <<\"R\";y++;}\n    }\n    else if(d == 4){\n      if(!(field[x][y]&8)){d = 8;y--;}\n      else if(field[x][y]&4){cout <<\"D\";d = 2;}\n      else{cout <<\"D\";x++;}\n    }\n    else if(d == 8){\n      if(!(field[x][y]&1)){d = 1;x--;}\n      else if(field[x][y]&8){cout <<\"L\";d = 4;}\n      else{cout <<\"L\";y--;}\n    }\n    if(x == 0 && y == 1 && d == 2) break;\n  }\n  cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int f,xyf;\n  char h[5][4],v[4][5];\n  int x,y;\n  cin>>h[0];\n  for(int i=0;i<4;i++){\n    cin>>v[i];\n    cin>>h[i+1];\n  }\n  f=xyf=1;\n  y=0;\n  x=1;cout<<\"R\";\n  while(x!=0||y!=0){\n    if(f==1){\n      if(xyf==1){\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;xyf*=-1;\n\t}\n\telse if(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";\n\t}\n\telse if(v[y][x]=='0'||y==4) xyf*=-1;\n\telse{\n\t  y++;f*=-1;cout<<\"D\";\n\t}\n      }\n      else{\n\tif(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";f*=-1;\n\t}\n\telse if(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";\n\t}\n\telse if(v[y][x]=='0'||y==4) xyf*=-1;\n\telse{\n\t  y++;cout<<\"D\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n    else{\n      if(xyf==1){\n\tif(x<4&&h[y][x]=='1'){\n\t  x++;cout<<\"R\";f*=-1;\n\t}\n\telse if(y<4&&v[y][x]=='1'){\n\t  y++;cout<<\"D\";\n\t}\n\telse if(h[y][x-1]=='0'||x==0) xyf*=-1;\n\telse{\n\t  x--;cout<<\"L\";f*=-1;xyf*=-1;\n\t}\n      }\n      else{\n\tif(x>0&&h[y][x-1]=='1'){\n\t  x--;cout<<\"L\";f*=-1;\n\t}\n\telse if(y>0&&v[y-1][x]=='1'){\n\t  y--;cout<<\"U\";\n\t}\n\telse if(h[y][x]=='0'||x==4) xyf*=-1;\n\telse{\n\t  x++;cout<<\"R\";f*=-1;xyf*=-1;\n\t}\n      }\n    }\n  }\n  cout.flush();\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n#define\tE\t0\n#define\tN\t1\n#define\tW\t2\n#define\tS\t3\n\nusing namespace std;\n\nint wall_v[5][5];\t// wall_v[a][b] : æañ ã©çbÔÚÌÇª é©Ç¤© ([a][4]ÍíÉ0)\nint wall_h[5][5];\t// wall_h[a][b] : æas ¶©çbÔÚÌÇª é©Ç¤© ([a][4]ÍíÉ0)\n\nbool isRightWall(int x,int y,int dir){\n\tif(dir==N)\ty--;\n\tif(dir==W)\tx--;\n\tif(y<0 || 4<y || x<0 || 4<x)\treturn false;\n\n\tif(dir==E)\treturn wall_h[y][x];\n\tif(dir==N)\treturn wall_v[x][y];\n\tif(dir==W)\treturn wall_h[y][x];\n\tif(dir==S)\treturn wall_v[x][y];\n}\n\nbool isForwardWall(int x,int y,int dir){\n\tif(dir==E)\ty--;\n\tif(dir==N)\tx--;\n\tif(y<0 || 4<y || x<0 || 4<x)\treturn false;\n\n\tif(dir==E)\treturn wall_v[x][y];\n\tif(dir==N)\treturn wall_h[y][x];\n\tif(dir==W)\treturn wall_v[x][y];\n\tif(dir==S)\treturn wall_h[y][x];\n}\n\nvoid goRight(int &x,int &y,int &dir){\n\tif(dir==E)\ty++;\n\tif(dir==N)\tx++;\n\tif(dir==W)\ty--;\n\tif(dir==S)\tx--;\n\tdir=(dir+3)%4;\n}\n\nvoid goForward(int &x,int &y,int &dir){\n\tif(dir==E)\tx++;\n\tif(dir==N)\ty--;\n\tif(dir==W)\tx--;\n\tif(dir==S)\ty++;\n}\n\nvoid goLeft(int &x,int &y,int &dir){\n\tif(dir==E)\ty--;\n\tif(dir==N)\tx--;\n\tif(dir==W)\ty++;\n\tif(dir==S)\tx++;\n\tdir=(dir+1)%4;\n}\n\nint main()\n{\n\tfor(int i=0;i<9;i++){\n\t\tchar s[8];\tcin>>s;\n\t\tif(i%2==0){\n\t\t\tfor(int j=0;j<4;j++)\twall_h[i/2][j]=s[j]-'0';\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<5;j++)\twall_v[j][i/2]=s[j]-'0';\n\t\t}\n\t}\n\n\tint x=0,y=0,dir=0;\n\tdo{\n\t\tif(!isForwardWall(x,y,dir)){\n\t\t\tif(!isRightWall(x,y,dir))\tgoRight(x,y,dir);\n\t\t\telse\t\t\t\t\t\tgoForward(x,y,dir);\n\t\t}\n\t\telse\t\t\t\t\t\t\tgoLeft(x,y,dir);\n\n\t\tswitch(dir){\n\t\t\tcase E:\tcout<<'R';\tbreak;\n\t\t\tcase N:\tcout<<'U';\tbreak;\n\t\t\tcase W:\tcout<<'L';\tbreak;\n\t\t\tcase S:\tcout<<'D';\tbreak;\n\t\t}\n\t}while(!(x==0&&y==0));\n\tcout<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nchar dc[]={'R','D','L','U'};\nbool t[6][6][4];\nint flg=0;\nvoid init();\nbool ck(int y,int x,int d){\n\tif(t[y][x][d]==1)return false;\n\tint ny=y+dy[d];\n\tint nx=x+dx[d];\n\tif(t[ny][nx][(d+2)%4]==1)return false;\n\treturn true;\n}\nvoid rec(int y,int x,int d);\nint main(){\n\tinit();\n\t//cout<<\"test\"<<endl;\n\tfor(int i=0;i<=3;i++){\n\t\tfor(int j=1;j<=4;j++){\n\t\t\tcin>>t[i][j][1];\n\t\t}\n\t\tfor(int j=0;j<=4;j++){\n\t\t\tcin>>t[i+1][j][0];\n\t\t}\n\t}\n\tfor(int i=1;i<=4;i++)cin>>t[4][i][1];\n\t//cout<<\"inputend\"<<endl;\n\trec(0,1,0);\n\treturn 0;\n}\nvoid init(){\n\tfor(int i=0;i<6;i++)\n\t\tfor(int j=0;j<6;j++)\n\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\tt[i][j][k]=0;\n}\nvoid rec(int y,int x,int d){\n\t//cout<<y << \" \" <<x<<\" \"<<d<<endl;\n\tflg++;\n\tif(y==0&&x==0){\n\t\tcout<<endl;\n\t\treturn;\n\t}\n\t\n\tint d1=(d+1)%4;\n\tint d2=(d+2)%4;\n\tint d3=(d+3)%4;\n\tif(ck(y,x,d1)){\n\t\t//cout<<dc[d1];\n\t\trec(y+dy[d1],x+dx[d1],d1);\n\t}else if(ck(y,x,d)){\n\t\tcout<<dc[d];\n\t\trec(y+dy[d],x+dx[d],d);\n\t}else if(ck(y,x,d3)){\n\t\tcout<<dc[d3];\n\t\trec(y+dy[d3],x+dx[d3],d3);\n\t}else{\n\t\tcout<<dc[d2];\n\t\trec(y+dy[d2],x+dx[d2],d2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring side[4],Longitudinal[5];\nbool kawa=0;\nvoid righ(int x,int y);\nvoid lef(int x,int y);\nvoid up(int x,int y);\nvoid down(int x,int y);\nvoid serch(int x,int y,int then);\nint main()\n{\n    for(int i=0;i<4;i++)cin>>Longitudinal[i]>>side[i];\n    cin>>Longitudinal[4];\n    serch(0,0,1);\n}\nvoid righ(int x,int y)\n{\n    if(x+1<5&&Longitudinal[y][x]=='1'){\n        cout<<\"R\";\n        serch(x+1,y,0);\n    }\n}\nvoid lef(int x,int y)\n{\n    if(x-1>-1&&Longitudinal[y][x-1]=='1'){\n        cout<<\"L\";\n        serch(x-1,y,2);\n    }\n}\nvoid up(int x,int y)\n{\n    if(y-1>-1&&side[y-1][x]=='1'){\n        cout<<\"U\";\n        serch(x,y-1,3);\n    }\n}\nvoid down(int x,int y)\n{\n    if(y+1<5&&side[y][x]=='1'){\n            cout<<\"D\";\n            serch(x,y+1,1);\n        }\n}\nvoid serch(int x,int y,int then)\n{\n    if(x==0&&y==0){\n        if(kawa==0)kawa=1;\n        else {\n            cout<<endl;\n            exit(0);\n        }\n    }\n    if(then==0){\n        up(x,y);\n        righ(x,y);\n        down(x,y);\n    }\n    else if(then==1){\n        righ(x,y);\n        down(x,y);\n        lef(x,y);\n    }\n    else if(then==2){\n        down(x,y);\n        lef(x,y);\n        up(x,y);\n    }\n    else{\n        lef(x,y);\n        up(x,y);\n        righ(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble eps = 1e-10;\n\nint main() {\n\tstring s[16], ans(\"R\");\n\tfor(int i = 0; i < 9; ++i){\n\t\tcin >> s[i];\n\t}\n\tint x = 0, y = 0;\n\tint d = 0; // 0:right, 1:down, 2:left, 3:up\n\tbool flag = false;\n\twhile(1){\n\t\tif(d == 0){\n\t\t\tif(s[y][x + 1] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\tx += 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x + 1] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\tx += 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x + 1] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\tx += 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'L';\n\t\t\t\td = 2;\n\t\t\t}\n\t\t}\n\t\telse if(d == 1){\n\t\t\tif(s[y + 2][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 2;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'R';\n\t\t\t\ty += 1;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y + 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t\ty += 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'U';\n\t\t\t\td = 3;\n\t\t\t}\n\t\t}\n\t\telse if(d == 2){\n\t\t\tif(s[y][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\tx -= 1;\n\t\t\t}\n\t\t\telse if(y >= 2 && s[y - 1][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 1;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(s[y + 1][x] == '1'){\n\t\t\t\tans += 'D';\n\t\t\t\ty += 1;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t}\n\t\telse if(d == 3){\n\t\t\tif(y >= 3 && s[y - 2][x] == '1'){\n\t\t\t\tans += 'U';\n\t\t\t\ty -= 2;\n\t\t\t}\n\t\t\telse if(s[y - 1][x] == '1'){\n\t\t\t\ty -= 1;\n\t\t\t\tif(x == 0 && y == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tans += 'R';\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(s[y - 1][x - 1] == '1'){\n\t\t\t\tans += 'L';\n\t\t\t\ty -= 1;\n\t\t\t\tx -= 1;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += 'D';\n\t\t\t\td = 1;\n\t\t\t}\n\t\t}\n\t\t/*if(x == 1 && y == 8 && flag)\n\t\t\tbreak;\n\t\tif(x == 1 && y == 8){\n\t\t\tflag = true;\n\t\t\t//break;\n\t\t}*/\n\t\tif(x == 0 && y == 0)\n\t\t\tbreak;\n\t}\n\t/*cout << s[8][3] << endl;\n\tcout << d << endl;*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\nusing namespace std;\n\n#define East  1\n#define South 2\n#define West  4\n#define North 8\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.pg\", \"r\", stdin);\n\tstring str = \"\";\n\tvector <string> grid;\n\tint maxlen = 0;\n\n\twhile (getline (cin, str ) ){\n\t\tif (str.empty() ){\n\t\t\tbreak;\n\t\t} // end if\n\t\tint len = str.length();\n\t\tmaxlen = max (maxlen, len );\n\t\tgrid.push_back(str );\n\t} // end while\n\n\tint size = grid.size();\n\tvector <vector <char> > room((size+1)/2+1, vector <char> (maxlen, 0 ) );\n\tint i,j,k;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < grid[i].length(); ++j){\n\t\t\tif (grid[i][j] == '1'){\n\t\t\t\tif (i % 2 == 0){\t// north or south wall\n\t\t\t\t\troom[i/2][j] |= South;\n\t\t\t\t}else{\t\t\t// east or west wall\n\t\t\t\t\troom[i/2+1][j-1] |= East;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tfor (i = 0; i < room.size(); ++i){\n\t\tfor (j = 0; j < room[i].size(); ++j){\n\t\t\tif (i == 0){\n\t\t\t\troom[i][j] |= North;\n\t\t\t}else if (i == room.size() - 1){\n\t\t\t\troom[i][j] |= South;\n\t\t\t} // end if\n\t\t\tif (i > 0 && room[i-1][j] & South){\n\t\t\t\troom[i][j] |= North;\n\t\t\t} // end if\n\t\t\tif (j == 0){\n\t\t\t\troom[i][j] |= West;\n\t\t\t}else if (j == room[i].size() - 1){\n\t\t\t\troom[i][j] |= East;\n\t\t\t} // end if\n\t\t\tif (j > 0 && room[i][j-1] & East){\n\t\t\t\troom[i][j] |= West;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tint row = 0;\n\tint col = 0;\n\tint dir = East;\n\tint right_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n\tstring res = \"\";\n\tres += 'R';\n\tbool turn = false;\n\tint reach = 0;\n\n\tdo{\n\t\tif (turn || (right_hand & room[row][col]) ){\n\t\t\tturn = false;\n\t\t\t// go faword\n\t\t\tswitch (dir){\n\t\t\t\tcase East:\n\t\t\t\t\tif (!(room[row][col] & East)){ \n\t\t\t\t\t\t++col;// res += 'R';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = North;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase South:\n\t\t\t\t\tif (!(room[row][col] & South)){\n\t\t\t\t\t \t++row;// res += 'D';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = East;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'R';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase West:\n\t\t\t\t\tif (!(room[row][col] & West)){\n\t\t\t\t\t\t--col;// res += 'L';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = South;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'D';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if\n\t\t\t\t\tbreak;\n\t\t\t\tcase North:\n\t\t\t\t\tif (!(room[row][col] & North)){\n\t\t\t\t\t\t--row;// res += 'U';\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'U';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = West;\n\t\t\t\t\t\tif (right_hand & room[row][col]){\n\t\t\t\t\t\t\tres += 'L';\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t\tturn = true;\n\t\t\t\t\t} // end if  \n\t\t\t\t\tbreak;\n\t\t\t} // end switch\n\t\t}else{\n\t\t\t// turn\n\t\t\tswitch (dir){\n\t\t\t\tcase East:  dir = South; break;\n\t\t\t\tcase South: dir = West; break;\n\t\t\t\tcase West:  dir = North; break;\n\t\t\t\tcase North: dir = East; break;\n\t\t\t} // end switch\n\t\t\tturn = true;\n\t\t} // end if\n\n\t\tright_hand = ( (dir << 1) > 8 ? 1 : (dir << 1) );\n\t\tif (row == 1 && col == 0){\n\t\t\t++reach;\n\t\t} // end if\n\t} while (reach < 3);\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint main() {\n  int dx[] = {1,0,-1,0};\n  int dy[] = {0,-1,0,1};\n\n  bool yoko[4][5];\n  bool tate[5][4];\n  REP(i,9) {\n    char x;\n    if (i%2==0)\n      REP(j,4) {\n        cin >> x;\n        yoko[j][i/2] = (x=='1');\n      }\n    else\n      REP(j,5) {\n        cin >> x;\n        tate[j][i/2] = (x=='1');\n      }\n  }\n  int x=0,y=0;\n  int dir = 0;\n  char ss[4] = {'R','U','L','D'};\n  x++;\n  while(true) {\n    cout << ss[dir];\n    if (x==0&&y==0) break;\n    if (dir == 0) {\n      if (y>0&&tate[x][y-1]) {\n        dir = 1;\n        y--;\n      } else if (x<4&&yoko[x][y]) {\n        x++;\n      } else if (y<4&&tate[x][y]) {\n        dir = 3;\n        y++;\n      } else {\n        dir = 2;\n        x--;\n      }\n    } else if (dir == 1) {\n      if (x>0&&yoko[x-1][y]) {\n        dir = 2;\n        x--;\n      } else if (y>0&&tate[x][y-1]) {\n        y--;\n      } else if (x<4&&yoko[x][y]) {\n        dir = 0;\n        x++;\n      } else {\n        dir = 3;\n        y++;\n      }\n    } else if (dir == 2) {\n      if (y<4&&tate[x][y]) {\n        dir = 3;\n        y++;\n      } else if (x>0&&yoko[x-1][y]) {\n        x--;\n      } else if (y>0&&tate[x][y-1]) {\n        dir = 1;\n        y--;\n      } else {\n        dir = 0;\n        x++;\n      }\n    } else if (dir == 3) {\n      if (x<4&&yoko[x][y]) {\n        dir = 0;\n        x++;\n      } else if (y<4&&tate[x][y]) {\n        y++;\n      } else if (x>0&&yoko[x-1][y]) {\n        dir = 2;\n        x--;\n      } else {\n        dir = 1;\n        y--;\n      }\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar f[6][6],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tscanf(\"%s\",f[5]);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=f[5][j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y||x||f[0][0]==6&&p==3);\n\treturn!puts(\"\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>//////////AOJ0037\n                               int\ni,j,w[5][5];char*p,b[1<<7];;   int\nF(int(v)){scanf(\"%s\",b);for(   p=b\n;*p;++p                 ){w[   p-b\n+1-v][j   +v]|=((w[p-   b][j   ]|=\n(*p==49   )<<3-v)&8>>   v)>>   2;}\nreturn(   j+=v          );/*   */}\nmain(){   for(   ;4-F   (0);   F(1\n));for(   p=b,   i=j=   (*b=   3)^\n3;i+=\"\"   \"BA\"          \"BC\"   [*b\n]-66,j=   (*b)[\"ABCB\"]-66+j,   *++\np=\"ULDR   \"[*b],i+j;)for((*    b+=\n1)&=~4;                        !(w\n[i][j]&(1<<*b));(*b+=3)&=3);return\n!puts(b+1);}/*May2018,tw:@siikya*/\n\n"
  },
  {
    "language": "Haskell",
    "code": "import System.IO (isEOF)\n\ndata Orientation = Horizontal | Vertical deriving Eq\ndata Direction = North | South | East | West\ntype Wall = (Int,Int,Orientation)\n\nmain = input >>= return . solve >>= output\n\ninput :: IO [String]\ninput = do\n    quit <- isEOF\n    if quit then return [] else do\n        line <- getLine\n        fmap (line:) input\n\noutput :: [Direction] -> IO ()\noutput = putStrLn . map toLetter\n    where\n    toLetter North = 'U'\n    toLetter South = 'D'\n    toLetter East  = 'R'\n    toLetter West  = 'L'\n\nsolve :: [String] -> [Direction]\nsolve ls = ws `seq` trace ws (1,0) East [East]\n    where\n    ws = walls ls\n\n    trace _  (0,0) _ ds = reverse ds\n    trace ws pos   d ds = trace ws npos nd (nd:ds)\n        where\n        nd = nextDirection ws pos d\n        npos = nextPosition pos nd\n\nwalls :: [String] -> [Wall]\nwalls = concat . zipWith bindLine [(y,o)|y<-[0..],o<-[Horizontal,Vertical]]\n    where\n    bindLine (y,o) cs = bindLine' 0 y o cs\n\n    bindLine' x y o \"\"       =           []\n    bindLine' x y o ('1':cs) = (x,y,o) : bindLine' (x+1) y o cs\n    bindLine' x y o (_:cs)   =           bindLine' (x+1) y o cs\n\nwallExists :: [Wall] -> (Int,Int) -> Direction -> Bool\nwallExists ws (x,y) North = (x,y-1,Vertical) `elem` ws\nwallExists ws (x,y) South = (x,y,Vertical) `elem` ws\nwallExists ws (x,y) East  = (x,y,Horizontal) `elem` ws\nwallExists ws (x,y) West  = (x-1,y,Horizontal) `elem` ws\n\nturnsOrder :: Direction -> [Direction]\nturnsOrder North = [West,North,East,South]\nturnsOrder South = [East,South,West,North]\nturnsOrder East  = [North,East,South,West]\nturnsOrder West  = [South,West,North,East]\n\nnextDirection :: [Wall] -> (Int,Int) -> Direction -> Direction\nnextDirection ws (x,y) d = head $ filter (wallExists ws (x,y)) (turnsOrder d)\n\nnextPosition :: (Int,Int) -> Direction -> (Int,Int)\nnextPosition (x,y) North = (x,y-1)\nnextPosition (x,y) South = (x,y+1)\nnextPosition (x,y) East  = (x+1,y)\nnextPosition (x,y) West  = (x-1,y)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\n\ninGrid :: (Int,Int)->Bool\ninGrid (x,y)\n    | (0<=y&&y<9)&&(even y)&&(0<=x&&x<4) = True\n    | (0<=y&&y<9)&&(odd y) &&(0<=x&&x<5) = True\n    | otherwise                          = False\n\nisWall grid (x,y)\n    | (inGrid (x,y))&&(((grid!!y)!!x)=='1') = True\n    | otherwise                             = False\n\nsolve :: [[Char]]->(Int,Int)->[Char]->[Char]\nsolve grid (i,j) (x:xs)\n    | ((i,j)==(0,0)&&(x=='L'))||\n       (i,j)==(0,1)&&(x=='U')            = (x:xs)\n    --\n    | (x=='R')&&(isWall grid (i+1,j-1))  = solve grid (i+1,j-1) ('U':x:xs)\n    | (x=='R')&&(isWall grid (i+1,j))    = solve grid (i+1,j)   ('R':x:xs)\n    | (x=='R')&&(isWall grid (i+1,j+1))  = solve grid (i+1,j+1) ('D':x:xs)\n    | (x=='R')                           = solve grid (i,j)     ('L':x:xs)\n    --\n    | (x=='L')&&(isWall grid (i,j+1))    = solve grid (i,j+1)   ('D':x:xs)\n    | (x=='L')&&(isWall grid (i-1,j))    = solve grid (i-1,j)   ('L':x:xs)\n    | (x=='L')&&(isWall grid (i,j-1))    = solve grid (i,j-1)   ('U':x:xs)\n    | (x=='L')                           = solve grid (i,j)     ('R':x:xs)\n    --\n    | (x=='D')&&(isWall grid (i,j+1))    = solve grid (i,j+1)   ('R':x:xs)\n    | (x=='D')&&(isWall grid (i,j+2))    = solve grid (i,j+2)   ('D':x:xs)\n    | (x=='D')&&(isWall grid (i-1,j+1))  = solve grid (i-1,j+1) ('L':x:xs)\n    | (x=='D')                           = solve grid (i,j)     ('U':x:xs)\n    --\n    | (x=='U')&&(isWall grid (i-1,j-1))  = solve grid (i-1,j-1)  ('L':x:xs)\n    | (x=='U')&&(isWall grid (i,j-2))    = solve grid (i,j-2)   ('U':x:xs)\n    | (x=='U')&&(isWall grid (i,j-1))    = solve grid (i,j-1)   ('R':x:xs)\n    | (x=='U')                           = solve grid (i,j)     ('D':x:xs)\n\n\nmain = do\n    grid <- replicateM 9 getLine\n    putStrLn $ reverse $ solve grid (0,0) ['R']"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\nmain :: IO ()\nmain = solve <$> replicateM 9 f >>= putStrLn\n  where\n    f = map g <$> getLine\n    g '0' = False\n    g '1' = True\n\nsolve :: [[Bool]] -> String\nsolve mp = f (0, 0) [R]\n  where\n    f (i, j) (R:rs)\n      | i > 0 && mp !! (i-1) !! (j+1) = f (i-1, j+1) (U:R:rs)\n      | j < 3 && mp !! i !! (j+1) = f (i, j+1) (R:R:rs)\n      | i < 8 && mp !! (i+1) !! (j+1) = f (i+1, j+1) (D:R:rs)\n      | otherwise = f (i, j) (L:R:rs)\n    f (i, j) (D:rs)\n      | j < 4 && mp !! (i+1) !! j = f (i+1, j) (R:D:rs)\n      | i < 7 && mp !! (i+2) !! j = f (i+2, j) (D:D:rs)\n      | j > 0 = f (i+1, j-1) (L:D:rs)\n      | otherwise = f (i, j) (U:D:rs)\n    f (0, 0) (L:rs) = concatMap show . reverse $ L:rs\n    f (i, j) (L:rs)\n      | i < 8 && mp !! (i+1) !! j = f (i+1, j) (D:L:rs)\n      | j > 0 && mp !! i !! (j-1) = f (i, j-1) (L:L:rs)\n      | i > 0 && mp !! (i-1) !! j = f (i-1, j) (U:L:rs)\n      | otherwise = f (i, j) (R:L:rs)\n    f (1, 0) (U:rs) = concatMap show . reverse $ U:rs\n    f (i, j) (U:rs)\n      | j > 0 && mp !! (i-1) !! (j-1) = f (i-1, j-1) (L:U:rs)\n      | i > 1 && mp !! (i-2) !! j = f (i-2, j) (U:U:rs)\n      | j < 4 && mp !! (i-1) !! j = f (i-1, j) (R:U:rs)\n      | otherwise = f (i, j) (D:U:rs)\n\ndata Dir = R | D | L | U deriving (Show, Eq)\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad.State\nimport Control.Monad.Reader\nimport Data.Array.IArray\nimport Data.Array.IO\n\ndata Direction = R | L | U | D  deriving (Eq, Show)\ntype Field = Array (Int, Int) [Direction]\ntype IOField = IOArray (Int, Int) [Direction]\ntype Walk a = StateT Direction (StateT (Int, Int) (ReaderT Field IO)) a\n\nmain = do\n  field <- getField\n  flip runReaderT field $ flip evalStateT (0,0) $ evalStateT walkStep R\n\nmodifyArray arr ix f = do\n  e <- readArray arr ix\n  writeArray arr ix (f e)\n\ngetField :: IO Field\ngetField = do\n  field <- newArray ((0,0), (4,4)) []\n  e <- getAssocs field\n  input <- replicateM 9 getLine\n  forM_ [0..3] $ \\i -> do\n    let i' = i*2\n    horizonFill i (input !! i') field\n    verticalFill i (input !! (i'+1)) field\n  horizonFill 4 (input !! 8) field\n  freeze field\n\nhorizonFill :: Int -> String -> IOField -> IO ()\nhorizonFill i flags field = do\n  forM_ [0..3] $ \\j -> do\n    if flags !! j == '1'\n       then modifyArray field (i,j) (R :) >> modifyArray field (i, j+1) (L:)\n       else return ()\n\nverticalFill :: Int -> String -> IOField -> IO ()\nverticalFill i flags field = forM_ [0..4] $ \\j -> do\n  if flags !! j == '1'\n     then modifyArray field (i,j) (D:) >> modifyArray field (i+1 ,j) (U:)\n     else return ()\n\nwalkStep :: Walk ()\nwalkStep = do\n  direction <- getDirection\n  walkTo direction\n  goal <- isGoalNow\n  if goal then endStep\n          else walkStep\n\ngetDirection :: Walk Direction\ngetDirection = do\n  pos <- lift $ get\n  field <- lift $ ask\n  dir <- get\n  return $ gd dir pos field\n\ngd :: Direction -> (Int, Int) -> Field -> Direction\ngd d (x,y) field = gd' priorityList walls\n  where walls = field ! (x,y)\n        priorityList = case d of\n                            L -> [D, L, U, R]\n                            R -> [U, R, D, L]\n                            U -> [L, U, R, D]\n                            D -> [R, D, L, U]\n\ngd' :: [Direction] -> [Direction] -> Direction\ngd' [] nextDs = error \"invalid field\"\ngd' (d:ds) nextDs\n  | d `elem` nextDs = d\n  | otherwise = gd' ds nextDs\n\n\nwalkTo :: Direction -> Walk ()\nwalkTo d = printdir d >> (lift $ modify nextpos) >> put d\n  where nextpos\n            | d == L = \\(x,y) -> (x,y-1)\n            | d == R = \\(x,y) -> (x,y+1)\n            | d == U = \\(x,y) -> (x-1,y)\n            | d == D = \\(x,y) -> (x+1,y)\n\nprintdir :: Direction -> Walk ()\nprintdir d = lift . lift . lift $ putStr.show $ d\n\nisGoalNow :: Walk Bool\nisGoalNow = do\n  (x,y) <- lift get\n  return $ x == 0 && y == 0\n\nendStep :: Walk ()\nendStep = lift.lift.lift $ putStrLn \"\"\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\nblankline = replicate 11 '0'\nhline ws = '0' : '0' : concat [[w, '0'] | w <- ws] ++ ['0']\nvline ws = '0' : concat [[w,'0'] | w <- ws]\n\nf walls = 'R' : f' walls (1, 3) 'R'\nf' _ (1,1) _ = []\nf' walls (y,x) 'R'\n  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'\n  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'\n  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'\n  | otherwise            = 'L' : f' walls (y, x-2) 'L'\nf' walls (y,x) 'D'\n  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'\n  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'\n  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'\n  | otherwise            = 'U' : f' walls (y-2, x) 'U'\nf' walls (y,x) 'L'\n  | walls!(y+1,x) == '1' = 'D' : f' walls (y+2, x) 'D'\n  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'\n  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'\n  | otherwise            = 'R' : f' walls (y, x+2) 'R'\nf' walls (y,x) 'U'\n  | walls!(y,x-1) == '1' = 'L' : f' walls (y, x-2) 'L'\n  | walls!(y-1,x) == '1' = 'U' : f' walls (y-2, x) 'U'\n  | walls!(y,x+1) == '1' = 'R' : f' walls (y, x+2) 'R'\n  | otherwise            = 'D' : f' walls (y+2, x) 'D'\n\n\n\nmain = do\n    ws <- replicateM 9 getLine\n    let ds = blankline : zipWith (\\i t -> (cond hline vline $ odd i) t) [1..9] ws ++ [blankline]\n    let walls = listArray ((0,0),(10,10)) $ concat ds\n    putStrLn $ f walls\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep2(i,n) rep3(i,0,n)\n#define rep3(i,j,n) for((i)=(j) ; (i)<(n) ; (i)++)\n#define pl(format,var) p(format \"\\n\",var)\n#define p(format,var) printf(format,var)\n#define asizeof(array) (sizeof(array)/sizeof(array[0]))\n \n \n#define YMAX 9\n#define XMAX 5\n \nint count=0; //For debugging\n \ntypedef enum {\n    U=0,\n    R,\n    D,\n    L\n} state_t; //状態を表す列挙型\n \n//状態に対応する文字を出力\nvoid printstate(state_t s){\n    switch(s){\n        case L:\n            printf(\"L\");\n            break;\n        case R:\n            printf(\"R\");\n            break;\n        case U:\n            printf(\"U\");\n            break;\n        case D:\n            printf(\"D\");\n            break;\n        default:\n            printf(\"%d\",s);\n            break;\n    }\n}\n \n//RRRRDDDDLLLUUURRDDLURDLURDLURDLURD\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//                     ~ ~~ ~~\n \nint main(){\n    char line[80]; //入力行\n    int i,j; //カウンタ変数\n    int array[YMAX][XMAX]; //入力データ\n    int x,y; //探索先インデックス\n    int px,py; //現在の位置\n    state_t s; //現状態\n    int dir4data[4][2]={\n        {-1,0}, /* U */\n        {0,0}, /* R */\n        {1,0}, /* D */\n        {0,-1} /* L */\n    };\n    int dir4pos[4][2]={\n        {-2,0}, /* U */\n        {0,1}, /* R */\n        {2,0}, /* D */\n        {0,-1} /* L */\n    };\n \n    rep2(i,YMAX){\n        fgets(line, sizeof(line), stdin);\n        rep2(j,XMAX){\n            array[i][j] = line[j] - '0';\n        }\n        if(i%2==0)\n            array[i][j-1] = 0; //ゴミデータが入っているのでゼロクリアしとく\n    }\n     \n    //スタート地点をセット\n    px = py = 0;\n    x = y = 0;\n    s = R;\n     \n    while(s==R || px!=0 || py!=0){\n        //count++; if(count == 35) break;\n        //現在の探索先から各方向を調べる\n        for(i=0,j=(s==U)?L:s-1 ; i<4 ; i++,j++){\n            //方向配列をループさせる\n            if(j>=4)\n                j = 0;\n \n// s = r\n// py,px = 4,3\n// y,x = 4,2\n \n            //次の探索先を計算\n            y = py + dir4data[j][0];\n            x = px + dir4data[j][1];\n             \n            //if(count==22) printf(\"#### y,x = %d,%d\\n\",y,x), printf(\"#### j=%d\\n\",j);\n             \n            //次の探索先が無効か0なら, スキップ\n            if(x<0 || y<0 || x>=XMAX || y>=YMAX || array[y][x]==0){\n                continue;\n            }\n            s = j;\n            py += dir4pos[j][0];\n            px += dir4pos[j][1];\n            printstate(s);\n            break;\n        }\n        /*\n        printf(\"## count:%d s:\",count);\n        printstate(s); printf(\"\\n\");\n        printf(\"## py,px = %d,%d\\n\",py,px);\n        printf(\"## y,x = %d,%d\\n\",y,x);     \n        printf(\"\\n\");\n        */\n    }\n    printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0, i;\n  int dir = R, x = 1, y = 0;\n\n  while (true) {\n    height++;\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+2;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width-2; i++) {\n      wall[i+1][height][U] = wall[i+1][height-1][D] = (str[i] == '1');\n    }\n\n    if (scanf(\"%10000s\\n\", str) == -1) {\n      break;\n    }\n\n    for (i=0; i<width-1; i++) {\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n    }\n  }\n  height++;\n\n  firsttime = true;\n  while (true) {\n    if (!firsttime && \n\t((x == 1 && y == 0) ||\n\t (x == 0 && y == 1) ||\n\t (x == 1 && y == 1)) &&\n\twall[x][y][righthand(dir)]) {\n      putchar(dirchar[dir]);\n      break;\n    }\n\n    if (!wall[x][y][righthand(dir)]) {\n      dir = righthand(dir);\n      x += dx[dir];\n      y += dy[dir];\n    } else if (wall[x][y][dir]) {\n      putchar(dirchar[dir]);\n      dir = lefthand(dir);\n    } else {\n      x += dx[dir];\n      y += dy[dir];\n      putchar(dirchar[dir]);\n    }\n\n    firsttime = false;\n  }\n\n  puts(\"\");\n}"
  },
  {
    "language": "C",
    "code": "char m[99];s[]={0,5,-1,-6},v[]={1,11,-1,-11},x=6,d;main(){scanf(\"%49[^ ]\",m+6);do{for(d=(d+3)%4;m[x+s[d]]-49;d=(d+1)%4);putchar(\"RDLU\"[d]);x+=v[d];}while(x-6);exit(!puts(\" \"));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define X 11\n#define Y 11\n#define R 1\n#define L 2\n#define U 3\n#define D 4\n\nint main(void)\n{\n\tchar brd[X][Y];/*パネル*/\n\tchar in[X][Y];/*パネル*/\n\tint x = 0, y = 0;\n\tint i = 0, j = 0;\n\tint flag[100];\n\tchar ans[4][2];\n\tint k = 1, t = 1;\n\tint r = 0;/*righet*/\n\tint l = 0;/*left*/\n\tint u = 0;/*under*/\n\tint o = 0;/*on*/\n\tfor(i = 0; i < 100; i++)\n\t{\n\t\tflag[i] = 0;\n\t}\n\n\n\tfor(i = 0; i < X; i++)\n\t{\n\t\tfor(j = 0;j <= Y; j++)\n\t\t{\n\t\t\tin[i][j] = '0';\n\t\t\tbrd[i][j] = '0';\n\t\t}\n\t}\n\tfor(i = 0; i <  9; i++)\n\t{\n\t\tscanf(\"%s\", in[i]);\n\t}\n\tfor(i = 1; i < 10; i++)\n\t{\n\t\tfor(j = k+1; j < 10; j += 2 )\n\t\t{\n\t\t\tbrd[i][j] = in[x][y];\n\t\t\ty++;\n\t\t}\n\t\ty = 0;\n\t\tx++;\n\t\tt++;\n\t\tk = t % 2;\n\t}\n/*\n\tfor(i =  0; i <  X; i++)\n\t{\n\t\tfor(j = 0; j < Y; j ++)\n\t\t{\n\t\t\tprintf(\"i=%d j=%d    brd=%c\\n\",i,j,brd[i][j]);\n\t\t}\n\t\tprintf(\" %d\\n\",j);\n\t}\n*/\n\tx = 2;/*j*/\n\ty = 1;/*i*/\n\ti = 0;\n\tflag[i] = R;\n\t\n\twhile(1)\n\t{\n\t\tif(flag[i] == R)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y][x + 2] == '1')\n\t\t\t{\n\t\t\t\tx = x + 2;\n\t\t\t\ty = y;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == L)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y][x-2] == '1')\n\t\t\t{\n\t\t\t\tx = x - 2;\n\t\t\t\ty = y; \n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == U)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y-2;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y-1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == D)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y+2;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t}\n\t\tif(x == 2 && y == 1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(j = 0;j <= i;j++)\n\t{\n\t\tif(flag[j] == R)\n\t\t{\n\t\t\tprintf(\"R\");\n\t\t}\n\t\tif(flag[j] == L)\n\t\t{\n\t\t\tprintf(\"L\");\n\t\t}\n\t\tif(flag[j] == D)\n\t\t{\n\t\t\tprintf(\"D\");\n\t\t}\n\t\tif(flag[j] == U)\n\t\t{\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[p];\n\t\ty+=dy[p];\n\t\t//x+=p?2-p:0;\n\t\t//y+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZE 5\n\nint main(int argc, char *argv[]){\n     int x, y, v[SIZE][SIZE], h[SIZE][SIZE], f;\n     char d, t[SIZE+1];\n     \n     for(y=0; y<SIZE; y++)\n\t  for(x=0; x<SIZE; x++)\n\t       v[x][y]=0, h[x][y]=0;\n\n     while(~scanf(\"%s\",t)){\n\t  for(x=0; x<SIZE-1; x++) h[x][0] = t[x]-'0';\n\t  \n\t  for(y=0; y<SIZE-1; y++){\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE; x++) v[x][y] = t[x]-'0';\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE-1; x++) h[x][y+1] = t[x]-'0';\n\t  }\n\t  \n\t  x=0, y=0, f=0, d='R';\n\t  while(x!=0 || y!=0 || !f){\n\t       f=1;\n\t       \n\t       putchar(d);\n\t       \n\t       switch(d){\n\t       case 'R':\n\t\t    x++;\n\t\t    if(v[x][y-1]) d='U';\n\t\t    else if(h[x][y]) d='R';\n\t\t    else d='D';\n\t\t    break;\n\t       case 'D':\n\t\t    y++;\n\t\t    if(h[x][y]) d='R';\n\t\t    else if(v[x][y]) d='D';\n\t\t    else d='L';\n\t\t    break;\n\t       case 'L':\n\t\t    x--;\n\t\t    if(v[x][y]) d='D';\n\t\t    else if(h[x-1][y]) d='L';\n\t       else d='U';\n\t\t    break;\n\t       case 'U':\n\t\t    y--;\n\t\t    if(h[x-1][y]) d='L';\n\t\t    else if(v[x][y-1]) d='U';\n\t\t    else d='R';\n\t\t    break;\n\t       }\n\t  }\n\n\t  printf(\"\\n\");\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\nint main(void) {\n\tconst char DIR[4] = {'L', 'U', 'R', 'D'};\n\tconst int MOVE[4][2] = {{0,-1}, {-1,0}, {0,1}, {1,0}};\n\tint i, j, n;\n\tint r, c, s, d;\n\tchar buff[128][128];\n\tint elem[128][128][4];\n\t\n\tmemset(buff, 0x00, sizeof(elem));\n\tmemset(elem, 0x00, sizeof(elem));\n\n\tn = 1;\n\twhile(scanf(\"%s\\n\", &buff[n][1]) == 1) n++;\n\t\n\t// 入力値を格子に変換\n\tfor(i=1,s=strlen(&buff[2][1]);i<=n/2;i++) {\n\t\tfor(j=1;j<=s;j++) {\n\t\t\telem[i-1][j-1][0] = buff[i*2-1][j-1]=='1';\t// 左\n\t\t\telem[i-1][j-1][1] = buff[i*2-2][j]=='1';\t// 上\n\t\t\telem[i-1][j-1][2] = buff[i*2-1][j]=='1';\t// 右\n\t\t\telem[i-1][j-1][3] = buff[i*2][j]=='1';\t\t// 下\n//\t\t\tprintf(\"%d %d %d %d\\n\", elem[i-1][j-1][0], elem[i-1][j-1][1], elem[i-1][j-1][2], elem[i-1][j-1][3]);\n\t\t}\n\t}\n\t\n\tr = c = 0;\n\td = 2;\n\tdo {\n\t\tif(elem[r][c][(d+3)%4]==1) {\t// 左\n\t\t\td = (d+3) % 4;\n\t\t} else if(elem[r][c][d]==1) {\t// 正面\n\t\t\t;\n\t\t} else if(elem[r][c][(d+1)%4]==1) {\t// 右\n\t\t\td = (d+1) % 4;\n\t\t} else if(elem[r][c][(d+2)%4]==1) {\t// 背後\n\t\t\td = (d+2) % 4;\n\t\t}\n\t\tr += MOVE[d][0];\n\t\tc += MOVE[d][1];\n\t\tprintf(\"%c\", DIR[d]);\n\t\tif(r==0 && c==0) break;\n\t} while(1);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned shift(unsigned b, int x)\n{\n\treturn x>=0 ? (b>>x) : (b<<-x);\n}\n#define P(x,y) (fp[y]&shift(fb,x))\n#include<stdio.h>\nchar map[9][11];\nint right_wall (int x, int y, int d)\n{\n\tswitch (d) {\n\tcase 0: // R\n\t\tif (x < 4)\n\t\t\treturn map[y*2][x] - '0';\n\t\telse\n\t\t\treturn 0;\n\tcase 1: // D\n\t\tif (y < 4)\n\t\t\treturn map[y*2+1][x] - '0';\n\t\telse\n\t\t\treturn 0;\n\tcase 2: // L\n\t\tif (x > 0)\n\t\t\treturn map[y*2][x-1] - '0';\n\t\telse\n\t\t\treturn 0;\n\tcase 3: // U\n\t\tif (y > 0)\n\t\t\treturn map[y*2-1][x] - '0';\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tstatic const int dx[] = {1, 0, -1, 0};\n\tstatic const int dy[] = {0, 1, 0, -1};\n\tint i, x=0, y=0, d=0;\n\tfor (i = 0; i < 9; i ++)\n\t\tfgets(map[i], 11, stdin);\n\tdo {\n\t\tif (right_wall(x, y, (d+3)%4))\n\t\t\td = (d+3) % 4;\n\t\telse\n\t\t\twhile (!right_wall (x, y, d))\n\t\t\t\td = (d+1) % 4;\n\t\tputchar(\"RDLU\"[d]);\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t} while (x || y);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 11\n\nint main(void){\n  int i,j;\n  int map[M][M];\n  int curx=2,cury=0;\n  int vector=6;\n  char b,d,f,h,\n       a,c,e,g,o;\n  char way[100];\n  char hoge;\n\n  for(i=0;i<M;i++)\n    for(j=0;j<M;j++)\n      map[i][j]=8;\n\n  for(i=1;i<=7;i+=2){\n    scanf(\"%c%c%c%c%c\",\n        &b,&d,&f,&h,&hoge);\n    map[i][2]=b-'0';\n    map[i][4]=d-'0';\n    map[i][6]=f-'0';\n    map[i][8]=h-'0';\n    scanf(\"%c%c%c%c%c%c\",\n        &a,&c,&e,&g,&o,&hoge);\n    map[i+1][1]=a-'0';\n    map[i+1][3]=c-'0';\n    map[i+1][5]=e-'0';\n    map[i+1][7]=g-'0';\n    map[i+1][9]=o-'0';\n  }\n  scanf(\"%c%c%c%c%c\",\n      &b,&d,&f,&h,&hoge);\n  map[9][2]=b-'0';\n  map[9][4]=d-'0';\n  map[9][6]=f-'0';\n  map[9][8]=h-'0';\n\n  map[cury][curx]=2;\n\n  //L:curx--;\n  //R:curx++;\n  //U:cury--;\n  //D:cury++;\n  way[0]='R';\n  for(i=1;(!(cury==2 && curx==2)) || vector!=4;i++)\n    if(vector==6){\n      way[i]='R'; curx+=2;\n      map[cury][curx]=2;\n            if(map[cury+1][curx]!=1){ vector=2; i--;\n      }else if(map[cury][curx+1]!=1){ vector=6;\n      }else if(map[cury-1][curx]!=1){ vector=8; i++; way[i]='U';\n      }else if(map[cury][curx-1]!=1){ vector=4; i++;way[i]='U'; i++;way[i]='L';\n      }\n    }else if(vector==2){\n      way[i]='D'; cury+=2;\n      map[cury][curx]=2;\n            if(map[cury][curx-1]!=1){ vector=4; i--;\n      }else if(map[cury+1][curx]!=1){ vector=2;\n      }else if(map[cury][curx+1]!=1){ vector=6; i++; way[i]='R';\n      }else if(map[cury-1][curx]!=1){ vector=8; i++;way[i]='R'; i++;way[i]='U';\n      }\n    }else if(vector==4){\n      way[i]='L'; curx-=2;\n      map[cury][curx]=2;\n            if(map[cury-1][curx]!=1){ vector=8; i--;\n      }else if(map[cury][curx-1]!=1){ vector=4;\n      }else if(map[cury+1][curx]!=1){ vector=2; i++; way[i]='D';\n      }else if(map[cury][curx+1]!=1){ vector=6; i++;way[i]='D'; i++;way[i]='R';\n      }\n    }else if(vector==8){\n      way[i]='U'; cury-=2;\n      map[cury][curx]=2;\n            if(map[cury][curx+1]!=1){ vector=6; i--;\n      }else if(map[cury-1][curx]!=1){ vector=8;\n      }else if(map[cury][curx-1]!=1){ vector=4; i++; way[i]='L';\n      }else if(map[cury+1][curx]!=1){ vector=2; i++;way[i]='L'; i++;way[i]='D';\n      }\n    }\n  way[i]=0;\n  printf(\"%s\\n\",way);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\n  int i,j;\n  char h_wall[5][4];\n  char v_wall[4][5];\n  int x,y,p;\n  int flag;\n\n  for(i=0;i<9;i++){\n    if(i%2){\n      for(j=0;j<5;j++)scanf(\" %c \",&v_wall[i/2][j]);\n    }else{\n      for(j=0;j<4;j++)scanf(\" %c \",&h_wall[i/2][j]);\n    }\n  }\n\n  x = 0;\n  y = 0;\n  p = 1;\n\n  while(1){\n    if( (x == 0 && y == 0 && p == 0) || (x == 0 && y == 0 && p == 3) )break;\n\n    flag = 0;\n    i = p;\n    while(1){\n      if(i == 1){\n\tif( y > 0 && v_wall[y-1][x] == '1'){\n\t  putchar('U');\n\t  p = 0;\n\t  y--;\n\t  flag = 1;\n\t}\n      }\n\n      if(i == 2){\n\tif( x < 4 && h_wall[y][x] == '1'){\n\t  putchar('R');\n\t  p = 1;\n\t  x++;\n\t  flag = 1;\n\t}\n      }\n      if(i == 3){\n\tif( y < 4 && v_wall[y][x] == '1'){\n\t  putchar('D');\n\t  p = 2;\n\t  y++;\n\t  flag = 1;\n\t}\n      }\n      if(i == 0){\n\tif( x > 0 && h_wall[y][x-1] == '1'){\n\t  putchar('L');\n\t  p = 3;\n\t  x--;\n\t  flag = 1;\n\t}\n      }\n\n      i++;\n      if(i>3)i-=4;\n      if(flag)break;\n    }\n  }\n  putchar('\\n');\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tint y=0,x=0,p=2;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\treturn 0;\n\t\tputchar(\"URDL\"[p]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[p];\n\t\ty+=dy[p];\n\t\t//x+=p?2-p:0;\n\t\t//y+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint main(){\n  int i,j,w[11][11]={0};\n  int x,y,n,d=1,m=0;\n  int X[]={-1, 0, 1, 1, 2, 1, 1, 0,-1,-1,-2,-1};\n  int Y[]={-1,-2,-1,-1, 0, 1, 1, 2, 1, 1, 0,-1};\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&n);\n    for(j=3-(i%2);j<11;j+=2){\n      w[i+1][11-j]=n%10;\n      n/=10;\n    }\n  }\n  y=1;\n  x=2;\n  if(w[1][2]==1){\n    printf(\"R\");\n    while(1){\n      m=0;\n      for(i=0;i<3;i++){\n\tif(w[y+Y[d*3+i]][x+X[d*3+i]]==1){\n\t  x+=X[d*3+i];\n\t  y+=Y[d*3+i];\n\t  d+=i-1;\n\t  m=1;\n\t  break;\n\t}\n      }\n      if(m==0){\n\td+=2;\n      }\n      d+=4;\n      d%=4;\n      if(d==0)printf(\"U\");\n      if(d==1)printf(\"R\");\n      if(d==2)printf(\"D\");\n      if(d==3)printf(\"L\");\n      if(x==2&&y==1)break;\n    }\n    printf(\"\\n\");\n    return 0; \n  }\n}\n\t"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tx=y=5;\n\tfor(j=1;j<=2*y+1;j++)for(i=1;i<=2*x+1;i++)s[i][j]=0;\n\tfor(j=2;j<=2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:3;i<2*x+1;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=4,y=2;x!=2||y!=2;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\treturn 0;\n\t//printf(\"R\");\n\tint y=0,x=0,p=2;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[p];\n\t\ty+=dy[p];\n\t\t//x+=p?2-p:0;\n\t\t//y+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0, i;\n  int dir = R, x = 1, y = 0;\n\n  while (true) {\n    height++;\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+2;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width-2; i++) {\n      wall[i+1][height][U] = wall[i+1][height-1][D] = (str[i] == '1');\n    }\n\n    if (scanf(\"%10000s\\n\", str) == -1) {\n      break;\n    }\n\n    for (i=0; i<width-1; i++) {\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n    }\n  }\n  height++;\n\n  firsttime = true;\n  while (true) {\n    if (!firsttime && \n\t((x == 1 && y == 0) ||\n\t (x == 0 && y == 1) ||\n\t (x == 1 && y == 1)) &&\n\twall[x][y][righthand(dir)]) {\n      putchar(dirchar[dir]);\n      break;\n    }\n\n    if (!wall[x][y][righthand(dir)]) {\n      dir = righthand(dir);\n      x += dx[dir];\n      y += dy[dir];\n    } else if (wall[x][y][dir]) {\n      putchar(dirchar[dir]);\n      dir = lefthand(dir);\n    } else {\n      x += dx[dir];\n      y += dy[dir];\n      putchar(dirchar[dir]);\n    }\n\n    firsttime = false;\n  }\n\n  puts(\"\");\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define R 0\n#define L 1\n#define D 2\n#define U 3\n\nvoid searchfr(int i,int j,char y[5][5],char t[4][6],int *vec){\n    \n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){if(t[j][i]=='1'){\n        printf(\"D\");\n        *vec=U;\n    }\n    }else{\n        printf(\"L\");\n        *vec=L;\n    }\n}\n\n\nvoid searchfl(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n        }\n    }else{\n        \n        printf(\"R\");\n        *vec=R;\n    }\n}\n\nvoid searchfd(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n        }\n    }else{\n        printf(\"D\");\n        *vec=U;\n    }\n}\n\nvoid searchfu(int i,int j,char y[5][5],char t[4][6],int *vec){\n    \n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n        }\n    }else{\n        printf(\"U\");\n        *vec=D;\n    }\n}\n\n\nint main(int argc, const char * argv[]) {\n    char y[5][5],t[4][6];\n    int vec,i,j,k;\n    \n    for(k=0;k<4;k++){\n        scanf(\"%s\",y[k]);\n        scanf(\"%s\",t[k]);\n    }\n    scanf(\"%s\",y[k]);\n    printf(\"R\");\n    i=1;\n    j=0;\n    vec=R;\n    while(i!=0||j!=0){\n    //printf(\"(%d,%d)\\n\",i,j);\n        if(vec==R){\n            searchfr(i,j,y,t,&vec);\n        }\n        else if(vec==L){\n            searchfl(i,j,y,t,&vec);\n        }\n        else if(vec==U){\n            searchfu(i,j,y,t,&vec);\n        }\n        else {\n            searchfd(i,j,y,t,&vec);\n        }\n        \n        switch(vec){\n            case R:\n                i++;\n                break;\n            case L:\n                i--;\n                break;\n            case U:\n                j++;\n                break;\n            case D:\n                j--;\n                break;\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tint y=0,x=0,p=2;\n\tdo{\n\t\tp=(p+2)%4;\n\t\tint d=p;\n\t\tdo\n\t\t\td=(d+1)%4;\n\t\twhile(!((f[y][x]>>d)&1));\n\t\tp=d;\n\t\tputchar(\"URDL\"[d]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar mp[36];int i;\nvoid prt(int d){\n//\tprintf(\"%d %d %d\\t%c\\n\",i,i/6,i%6,\"RDLU\"[d]);\n\tputchar(\"RDLU\"[d]);\n}\nint main(void){\n\tint j,d=0,t[]={1,6,-1,-6};\n\tfor(j=1;j<5;j++)getchar()-'0'?mp[j+6]=8,mp[j]=2:0;\n\tgetchar();\n\tfor(i=1;i<5;i++){\n\t\tfor(j=0;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=1,mp[i*6+1+j]|=4:0;\n\t\tgetchar();\n\t\tfor(j=1;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=2,mp[i*6+6+j]|=8:0;\n\t\tgetchar();\n\t}\n\ti=0;\n\tdo{\n\t\tj=0;\n\t\tmp[i]&1<<d||(i+=j=t[d]);\n\t\tif(i){\n\t\t\tif(mp[i]&1<<(d+1&3)){\n\t\t\t\t!j&&mp[i]&1<<d?d=d+3&3:0;\n\t\t\t\tprt(d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti+=t[d=d+1&3];\n\t\t\t\tif(mp[i]&1<<(d+1&3))prt(d);\n\t\t\t\telse if(i)i+=t[d=d+1&3];\n\t\t\t}\n\t\t}\n\t}while(i);\n//\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define r(i,n) for(i=0;i<n;++i)\nint f[5][5],i,j;\nint main()\n{\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\t_Bool yoko[5][4];\n\t_Bool tate[4][5];\n\tint i, j;\n\tint c;\n\tint muki;\t//0 ue 1 migi 2 sita 3 hidari\n\tint nx, ny;\n\t\n\ti = j = 0;\n\twhile (1) {\n\t\tscanf(\"%d\", &c);\n\t\tfor( j = 3; j >= 0; j--) {\n\t\t\tyoko[i][j] = c % 10;\n\t\t\tc /= 10;\n\t\t}\n\t\tif( i == 4)\n\t\t\tbreak;\n\t\tscanf(\"%d\", &c);\n\t\tfor( j = 4; j >= 0; j--) {\n\t\t\ttate[i][j] = c % 10;\n\t\t\tc /= 10;\n\t\t}\n\t\ti++;\n\t}\n\t\n\tnx = ny = 0;\n\tmuki = 1;\n\twhile( muki != 3 || nx != 0 || ny != 0) {\n\t\tmuki = muki-1 < 0 ? 3 : muki-1;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif( muki == 0 && ny > 0 && tate[ny-1][nx]) {\n\t\t\t\tny--;\n\t\t\t\tprintf(\"U\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( muki == 1 && nx < 4 && yoko[ny][nx]) {\n\t\t\t\tnx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( muki == 2 && ny < 4 && tate[ny][nx]) {\n\t\t\t\tny++;\n\t\t\t\tprintf(\"D\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( muki == 3 && nx > 0 && yoko[ny][nx-1]) {\n\t\t\t\tnx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmuki = ++muki % 4;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0;\n  int dir = R, x = 0, y = 0, i,j,k;\n\n  while (true) {\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+1;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width; i++)\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n\n    if (scanf(\"%10000s\\n\", str) == -1)\n      break;\n\n    for (i=0; i<width; i++)\n      wall[i][height][D] = wall[i][height+1][U] = (str[i] == '1');\n\n    height++;\n  }\n\n  firsttime = true;\n  while (true) {\n    int nextdir;\n\n    if (!firsttime && x == 0 && y == 0)\n      break;\n\n    for (nextdir = lefthand(dir); !wall[x][y][nextdir]; nextdir = righthand(nextdir))\n      ;\n\n    //    printf(\"\\n(%d, %d) %c (%d, %d, %d, %d) \", x, y, dirchar[dir], wall[x][y][0], wall[x][y][1], wall[x][y][2], wall[x][y][3]);\n\n    putchar(dirchar[nextdir]);\n    x += dx[nextdir];\n    y += dy[nextdir];\n    dir = nextdir;\n    firsttime = false;\n  }\n\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum direction {right, down, left, up};\n\nint main() {\n\tchar input[16][16];\n\n\tint ans = 0;\n\tint i, j;\n\tint now = right + 128;\n\tint roop = 0;\n\n\tfor(i = 0; i < 16; i++)\n\t\tfor(j = 0; j < 16; j++)\n\t\t\tinput[i][j] = '0';\n\n\tfor(i = 0; i < 9; i++) {\n\t\tfor(j = 1 - i % 2; j < 9; j += 2)\n\t\t\tscanf(\"%c\", &input[i][j]);\n\n\t\tgetchar();\n\t}\n/*\t\n\t   for(i = 0; i < 16; i++) {\n\t   for(j = 0; j < 16; j++)\n\t   putchar(input[i][j]);\n\t   putchar('\\n');\n\t   }\n*/\t \n\ti = j = 0;\n\n\tdo{\n\t\tswitch(now % 4) {\n\t\t\tcase right:\n\t\t\t\tif(input[i][j + 1] == '1') {\n\t\t\t\t\tif(i > 0 && input[i - 1][j + 2] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\tj += 2;\n\t\t\t\t\tputchar('R');\n\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase down:\n\t\t\t\tif(input[i + 1][j] == '1') {\n\t\t\t\t\tif(input[i + 2][j + 1] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\ti += 2;\n\t\t\t\t\tputchar('D');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase left:\n\t\t\t\tif(j > 0 && input[i][j - 1] == '1') {\n\t\t\t\t\tif(input[i + 1][j - 2] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\tj -= 2;\n\t\t\t\t\tputchar('L');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase up:\n\t\t\t\tif(i > 0 && input[i - 1][j] == '1') {\n\t\t\t\t\tif(j > 0 && input[i - 2][j - 1] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\ti -= 2;\n\t\t\t\t\tputchar('U');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\t\t}\n\t} while(i + j && !(now % 4 == left || now % 4 == up));\n\n\tputchar('\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define RIGHT 0\n#define LEFT 1\n#define UP 2\n#define DOWN 3\n\n#define OK 1\n#define NG 0\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side);\n\n\nint main(){\n\n\tint i,j,map[11][7]={0},x,y,sit,side;\n\n\tfor(i=0;i<4;i++){\n\t\tif(scanf(\"%1d%1d%1d%1d%1d%1d%1d%1d%1d\",&map[i][4])==EOF) break;\n\t}\n\tscanf(\"%1d%1d%1d%1d\",&map[9][1],&map[9][2],&map[9][3],&map[9][4]);\n\tx=0;\n\ty=0;\n\tx++;\n\n\tsit=RIGHT;\n\tside=UP;\n\twhile(x==0 && y==0){\n\t\tswitch(sit){\n\t\t\tcase RIGHT:\n\t\t\t\tif(side==UP){\n\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=LEFT;\n\t\t\t\t\t\t\t\tside=DOWN;\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(side==DOWN){\n\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=RIGHT;\n\t\t\t\t\t\t\t\tside=UP;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(side==LEFT){\n\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=DOWN;\n\t\t\t\t\t\t\t\tside=RIGHT;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(side==RIGHT){\n\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=UP;\n\t\t\t\t\t\t\t\tside=LEFT;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)++;\n\t\t*side=UP;\n\t\t*sit=RIGHT;\n\t\tprintf(\"R\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\t\n}\n\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)--;\n\t\t*side=DOWN;\n\t\t*sit=LEFT;\n\t\tprintf(\"L\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)++;\n\t\t*side=LEFT;\n\t\t*sit=UP;\n\t\tprintf(\"U\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)--;\n\t\t*side=RIGHT;\n\t\t*sit=DOWN;\n\t\tprintf(\"D\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}"
  },
  {
    "language": "C",
    "code": "char*s=\"&+% \",m[99];x=6,d;main(){for(scanf(\"%[^ ]\",m+6);x-6|!d;putchar(\"RDLU\"[d]),x+=s[d]*2-75)for(d--;m[x+s[d&=3]-38]-49;d++);exit(!puts(\"\"));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_UNIT_SIZE 10000\n#define MAX_LINE_LENGTH 1000\n\ntypedef struct {\n    int x, y;\n} vector_t;\n\nvoid complex_mul(const vector_t *v1, const vector_t *v2, vector_t *t) {\n    t->x = v1->x * v2->x - v1->y * v2->y;\n    t->y = v1->x * v2->y + v1->y * v2->x;\n}\n\nchar *bufp[100], *wall[1000], path[10000];\nconst vector_t next_dir[] = {{0, 1}, {1, 0}, {0, -1}};\nconst char dir_char[][3] = {\n    {' ', 'U', ' '}, {'L', ' ', 'R'}, {' ', 'D', ' '}\n};\n\nint main(void) {\n    int W, H, i;\n    int buf_idx, buf_len, path_idx, nx, ny;\n    char *buf;\n    vector_t pos, dir, ndir;\n\n    buf_idx = 0;\n    buf_len = 0;\n    buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n    bufp[buf_idx++] = buf;\n    for (i = 0, W = 0; gets(buf) != NULL; i++) {\n        wall[i] = buf;\n        if (W == 0) W = strlen(buf);\n        buf_len += strlen(buf) + 1;\n        if (buf_len + MAX_LINE_LENGTH > BUF_UNIT_SIZE) {\n            buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n            bufp[buf_idx++] = buf;\n            buf_len = 0;\n        }\n        else {\n            buf += strlen(buf) + 1;\n        }\n    }\n    H = i;\n\n    path_idx = 0;\n    path[path_idx++] = 'R';\n    pos.x = 0;\n    pos.y = 0;\n    dir.x = 1;\n    dir.y = 0;\n    while (1) {\n        for (i = 0; i < 3; i++) {\n            complex_mul(&dir, &next_dir[i], &ndir);\n            if ((pos.y&1) == 0) {\n                ny = pos.y + ndir.y;\n                nx = pos.x + ndir.x + (dir.x > 0)*((ny+2)&1);\n            }\n            else {\n                ny = pos.y + ndir.y + dir.y;\n                nx = pos.x + ndir.x - (ndir.x > 0);\n            }\n            if (nx < 0 || W+(ny&1) <= nx || ny < 0 || H <= ny) continue;\n            if (wall[ny][nx] == '1') break;\n        }\n        pos.x = nx;\n        pos.y = ny;\n        dir.x = ndir.x;\n        dir.y = ndir.y;\n        path[path_idx++] = dir_char[1+dir.y][1+dir.x];\n\n        if ((pos.x == 0 && pos.y == 0 && dir.x == -1) ||\n            (pos.x == 0 && pos.y == 1 && dir.y == -1)) break;\n    }\n\n    path[path_idx] = '\\0';\n    puts(path);\n\n    for (i = 0; i < buf_idx; i++) {\n        free(bufp[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum {\n\tLEFT,\n\tRIGHT,\n\tUP,\n\tDOWN\n};\n\nint iskabe(char[9][6],int,int,int);\nint getleft(int);\nint getright(int);\nvoid move(int*,int*,int);\nvoid printdir(int);\n\nint main(void) {\n\tchar kabe[9][6];\n\tint x,y;\n\tint direction;\n\tint i;\n\tfor(i=0;i<9;i++)scanf(\"%s\",kabe[i]);\n\tx=0;y=0;direction=RIGHT;\n\tmove(&x,&y,direction);\n\twhile(x!=0 || y!=0) {\n\t\tif(iskabe(kabe,x,y,getleft(direction)))\n\t\t\tdirection=getleft(direction);\n\t\telse if(iskabe(kabe,x,y,getright(direction)))\n\t\t\tdirection=getright(direction);\n\t\tmove(&x,&y,direction);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nint iskabe(char kabe[9][6],int x,int y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\tif(x<=0)return 0;\n\t\t\tif(kabe[y*2][x-1]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tif(x>4)return 0;\n\t\t\tif(kabe[y*2][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tif(y<=0)return 0;\n\t\t\tif(kabe[y*2-1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tif(y>4)return 0;\n\t\t\tif(kabe[y*2+1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint getleft(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return DOWN;break;\n\t\tcase RIGHT:return UP;break;\n\t\tcase UP:return LEFT;break;\n\t\tcase DOWN:return RIGHT;break;\n\t}\n\treturn 0;\n}\n\nint getright(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return UP;break;\n\t\tcase RIGHT:return DOWN;break;\n\t\tcase UP:return RIGHT;break;\n\t\tcase DOWN:return LEFT;break;\n\t}\n\treturn 0;\n}\n\nvoid move(int* x,int* y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\t(*x)--;\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\t(*x)++;\n\t\t\tprintf(\"R\");\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\t(*y)--;\n\t\t\tprintf(\"U\");\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\t(*y)++;\n\t\t\tprintf(\"D\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0, i;\n  int dir = R, x = 1, y = 0;\n\n  while (true) {\n    height++;\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+2;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width-2; i++) {\n      wall[i+1][height][U] = wall[i+1][height-1][D] = (str[i] == '1');\n    }\n\n    if (scanf(\"%10000s\\n\", str) == -1) {\n      break;\n    }\n\n    for (i=0; i<width-1; i++) {\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n    }\n  }\n  height++;\n\n  firsttime = true;\n  while (true) {\n    if (!firsttime && \n\t((x == 1 && y == 0) ||\n\t (x == 0 && y == 1) ||\n\t (x == 1 && y == 1)) &&\n\twall[x][y][righthand(dir)]) {\n      putchar(dirchar[dir]);\n      break;\n    }\n\n    if (!wall[x][y][righthand(dir)]) {\n      dir = righthand(dir);\n      x += dx[dir];\n      y += dy[dir];\n    } else if (wall[x][y][dir]) {\n      putchar(dirchar[dir]);\n      dir = lefthand(dir);\n    } else {\n      x += dx[dir];\n      y += dy[dir];\n      putchar(dirchar[dir]);\n    }\n\n    firsttime = false;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nenum {R,D,L,U};\nchar m[9][6];\nchar c[] = { 'R','D','L','U' };\nvoid step(int x,int y,int d)\n{\n  if(x == -1 && y == 1) return;\n  switch(d){\n  case R:\n    if(x >= 4 || m[y*2][x] == '0'){\n      step(x,y+1,D);\n    }else if(y == 0 || m[y*2-1][x+1] == '0'){\n      printf(\"R\");\n      step(x+1,y,R);\n    }else{\n      printf(\"R\");\n      step(x,y,U);\n    }\n    break;\n  case D:\n    if(y >= 5 || m[y*2-1][x] == '0'){\n      step(x-1,y,L);\n    }else if(x == 4 || m[y*2][x] == '0'){\n      printf(\"D\");\n      step(x,y+1,D);\n    }else{\n      printf(\"D\");\n      step(x,y,R);\n    }\n    break;\n  case L:\n    if(x < 0 || m[(y-1)*2][x] == '0'){\n      step(x,y-1,U);\n    }else if(y == 5 || m[y*2-1][x] == '0'){\n      printf(\"L\");\n      step(x-1,y,L);\n    }else{\n      printf(\"L\");\n      step(x,y,D);\n    }\n    break;\n  case U:\n    if(y <= 0 || m[y*2-1][x+1] == '0'){\n      step(x+1,y,R);\n    }else if(x == -1 || m[(y-1)*2][x] == '0'){\n      printf(\"U\");\n      step(x,y-1,U);\n    }else{\n      printf(\"U\");\n      step(x,y,L);\n    }\n    break;\n  }\n}\nint main(){\n  int i;\n  for(i=0;i<9;i++){\n    scanf(\"%s\",m[i]);\n  }\n  step(0,0,R);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define PI 3.14159265358979323\n\n//int calc1(float a,float b,float c,float d,float e,float f,float *x,float *y);\n//void quick(int *,long long,long long);\n//int comp(char *a,char *b);\n\nint main(){\n\t\n\tchar a[9][6];\n\tint x,y,m,i;\n\n\twhile(scanf(\"%s\",a[0])!=EOF){\n\t\tfor(i=1;i<9;i++)\n\t\t\tscanf(\"%s\",a[i]);\n\t\tx=1;\n\t\ty=0;\n\t\tm=1;\n\t\tprintf(\"R\");\n\t\twhile(x!=0||y!=0){\n\t\t\tif(m==0){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tx--;\n\t\t\t\tif(y==4||a[2*y+1][x]=='0'){\n\t\t\t\t\tif(x==0||a[2*y][x-1]=='0'){\n\t\t\t\t\t\tif(y==0||a[2*y-1][x]=='0')\n\t\t\t\t\t\t\tm=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=2;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=3;\n\t\t\t}else if(m==1){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tx++;\n\t\t\t\tif(y==0||a[2*y-1][x]=='0'){\n\t\t\t\t\tif(x==4||a[2*y][x]=='0'){\n\t\t\t\t\t\tif(y==4||a[2*y+1][x]=='0')\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=3;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=2;\n\t\t\t}else if(m==2){\n\t\t\t\tprintf(\"U\");\n\t\t\t\ty--;\n\t\t\t\tif(x==0||a[2*y][x-1]=='0'){\n\t\t\t\t\tif(y==0||a[2*y-1][x]=='0'){\n\t\t\t\t\t\tif(x==4||a[2*y][x]=='0')\n\t\t\t\t\t\t\tm=3;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=1;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=0;\n\t\t\t}else{\n\t\t\t\tprintf(\"D\");\n\t\t\t\ty++;\n\t\t\t\tif(x==4||a[2*y][x]=='0'){\n\t\t\t\t\tif(y==4||a[2*y+1][x]=='0'){\n\t\t\t\t\t\tif(x==0||a[2*y][x-1]=='0')\n\t\t\t\t\t\t\tm=2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\tdo\n\t\t\tp=(p+1)%4;\n\t\twhile(!((f[y][x]>>p)&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\treturn 0; \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZE 5\n\nint main(int argc, char *argv[]){\n     int x, y, v[SIZE][SIZE], h[SIZE][SIZE], f;\n     char d, t[SIZE+1];\n     \n     while(~scanf(\"%s\",t)){\n\t  for(x=0; x<SIZE-1; x++) h[x][0] = t[x]-'0';\n\t  \n\t  for(y=0; y<SIZE-1; y++){\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE; x++) v[x][y] = t[x]-'0';\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE-1; x++) h[x][y+1] = t[x]-'0';\n\t  }\n\t  \n\t  x=0, y=0, f=0, d='R';\n\t  while(x!=0 || y!=0 || !f){\n\t       f=1;\n\t       \n\t       putchar(d);\n\t       \n\t       switch(d){\n\t       case 'R':\n\t\t    x++;\n\t\t    if(y!=0 && v[x][y-1]) d='U';\n\t\t    else if(x!=SIZE-1 && h[x][y]) d='R';\n\t\t    else if(y!=SIZE-1 && v[x][y]) d='D';\n\t\t    else d='L';\n\t\t    break;\n\t       case 'D':\n\t\t    y++;\n\t\t    if(x!=SIZE-1 && h[x][y]) d='R';\n\t\t    else if(y!=SIZE-1 && v[x][y]) d='D';\n\t\t    else if(x!=0 && h[x-1][y]) d='L';\n\t\t    else d='U';\n\t\t    break;\n\t       case 'L':\n\t\t    x--;\n\t\t    if(y!=SIZE-1 && v[x][y]) d='D';\n\t\t    else if(x!=0 && h[x-1][y]) d='L';\n\t\t    else if(y!=0 && v[x][y-1]) d='U';\n\t\t    else d='R';\n\t\t    break;\n\t       case 'U':\n\t\t    y--;\n\t\t    if(x!=0 && h[x-1][y]) d='L';\n\t\t    else if(y!=0 && v[x][y-1]) d='U';\n\t\t    else if(x!=SIZE-1 && h[x][y]) d='R';\n\t\t    else d='D';\n\t\t    break;\n\t       }\n\t  }\n\n\t  printf(\"\\n\");\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n    // printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //  printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t // printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define R 0\n#define L 1\n#define D 2\n#define U 3\n\nvoid searchfr(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){\n        //printf(\"%c\\n\",t[j][i]);\n        if(t[j][i]=='1'){\n            printf(\"D-\");\n            *vec=U;\n        }\n        else{\n            printf(\"L\");\n            *vec=L;\n        }\n    }\n}\n\n\nvoid searchfl(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n        }\n        else{\n            printf(\"R\");\n            *vec=R;\n        }\n    }\n}\n\nvoid searchfd(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n        }\n        else{\n            printf(\"D\");\n            *vec=U;\n        }\n    }\n}\n\nvoid searchfu(int i,int j,char y[5][5],char t[4][6],int *vec){\n    \n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n        }\n        else{\n            printf(\"U\");\n            *vec=D;\n        }\n    }\n}\n\n\nint main(int argc, const char * argv[]) {\n    char y[5][5],t[4][6];\n    int vec,i,j,k;\n    \n    for(k=0;k<4;k++){\n        scanf(\"%s\",y[k]);\n        scanf(\"%s\",t[k]);\n    }\n    scanf(\"%s\",y[k]);\n    printf(\"R\");\n    i=1;\n    j=0;\n    vec=R;\n    while(i!=0||j!=0){\n        //printf(\"(%d,%d)\\n\",i,j);\n        if(vec==R){\n            //printf(\"Rin\\n\");\n            searchfr(i,j,y,t,&vec);\n        }\n        else if(vec==L){\n            searchfl(i,j,y,t,&vec);\n        }\n        else if(vec==U){\n            searchfu(i,j,y,t,&vec);\n        }\n        else {\n            searchfd(i,j,y,t,&vec);\n        }\n        \n        switch(vec){\n            case R:\n                i++;\n                break;\n            case L:\n                i--;\n                break;\n            case U:\n                j++;\n                break;\n            case D:\n                j--;\n                break;\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nchar s[13][7];\nint order[24] = {0, 1, 2, 0, 3, 2, 2, 1, 0, 2, 3, 0,\n                 3, 0, 1, 3, 2, 1, 1, 0, 3, 1, 2, 3};\nint nds[24] = {4, 0, 7, 6, 1, 5, 5, 2, 6, 7, 3, 4,\n               3, 4, 0, 1, 5, 2, 2, 6, 1, 0, 7, 3};\nint ds[8] = {1, 3, 1, 3, 0, 2, 0, 2};\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar ls[8] = {'R', 'L', 'R', 'L', 'U', 'D', 'U', 'D'};\n\nbool doesWallExist(int x, int y, int d){\n    // printf(\"%d, %d, %d, %d, %d: \", x, y, d, x+(dx[d]-1)/2, 2*y+(dy[d]-1)/2);\n    if(s[2*y+dy[d]][x+(dx[d]-1)/2] == '1'){\n        //puts(\"o\");\n        return true;\n    }\n    //puts(\"x\");\n    return false;\n}\n\nint main(){\n    for(int i=0;i<13;i++){\n        for(int j=0;j<7;j++){\n            s[i][j] = '0';\n        }\n    }\n\n    for(int i=2;i<=10;i++){\n        int ub = i%2?5:4;\n        for(int j=0;j<ub;j++){\n            scanf(\"%c\", &s[i][j+1]);\n        }\n        scanf(\"%*c\");\n    }\n\n    int x = 1, y = 1, d = 0;\n    while(!(x == 1 && y == 1 && d != 0)){\n        // printf(\"%d, %d, %d\\n\", x, y, d);\n        putchar(ls[d]);\n        x += dx[ds[d]]; y += dy[ds[d]];\n\n        for(int i=0;i<3;i++){\n            if(doesWallExist(x, y, order[d*3+i])){\n                d = nds[d*3+i];\n                break;\n            }\n        }\n    }\n    puts(\"\");\n\n    /* for(int i=0;i<13;i++){ */\n    /*     for(int j=0;j<7;j++){ */\n    /*         putchar(s[i][j]); */\n    /*     } */\n    /*     puts(\"\"); */\n    /* } */\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int wall[5][5][4];\n    int i, j;\n    int x, y, d;\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n\n    memset(wall, 0, sizeof(wall));\n    for (i = 0; i < 5; i++){\n        char s[8];\n        scanf(\"%s\", s);\n        for (j = 0; j < 4; j++)\n            wall[i][j][0] = wall[i][j + 1][2] = (s[j] == '1');\n        if (i == 4)\n            break;\n        scanf(\"%s\", s);\n        for (j = 0; j < 5; j++)\n            wall[i][j][1] = wall[i + 1][j][3] = (s[j] == '1');\n    }\n    x = y = d = 0;\n    do {\n        putchar(\"RDLU\"[d]);\n        x += dx[d];\n        y += dy[d];\n\n        if (wall[y][x][d + 3 & 3])\n            d = d + 3 & 3;\n        else if (!wall[y][x][d])\n            if (wall[y][x][d + 1 & 3])\n                d = d + 1 & 3;\n            else\n                d = d + 2 & 3;\n    } while (x + y + d);\n    puts(\"\");\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],s[6],i,j,a,y,x,p,b;\nint main()\n{\n\tfor(;i<9;++i,b=!b){\n\t\tscanf(\"%s\",s);\n\t\tfor(j=4+b;j--;)\n\t\t\ta=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y|x|**f==6&p==3);\n\treturn!puts(\"\"); \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid change(int,int);\nint muki = 0,flag = 0;\n\nint main(){\n\tint i,j,x = 0,y = 0,wall_x[4][5],wall_y[5][4];\n\tfor(i = 0;i < 9;i++){\n\t\tif(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n\t\telse for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n\t}\n\tdo{\n\t\tif(muki == 0){\n\t\t\tif(x != 4 && wall_x[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('R');\n\t\t\t\tx++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 1){\n\t\t\tif(y != 4 && wall_y[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('D');\n\t\t\t\ty++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 2){\n\t\t\tif(x != 0 && wall_x[x - 1][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('L');\n\t\t\t\tx--;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 3){\n\t\t\tif(y != 0 && wall_y[x][y - 1] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tputchar('U');\n\t\t\t\ty--;\n\t\t\t}else change(x,y);\n\t\t}\n\t}while(x != 0 || y != 0);\n\tputs(\"\");\n\treturn 0;\n}\n\nvoid change(int x,int y){\n\tint i;\n\tif(!flag){\n\t\tflag = 1;\n\t\tmuki = (muki + 3) % 4;\n\t}\n\telse muki = (muki + 1) % 4;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n\tchar stage[10][10]={};\n\tchar state[2]={};\n\tint x=0,y=0;\n\tint i,j;\n\t\n\t\n\tfor(i=0;i<9;i++)scanf(\"%s\",stage[i]);\n\tstate[0]='R';\n\twhile(1)\n\t{\n\t\tif(state[0]=='R')\n\t\t{\n\t\t\tif(stage[y-1][x+1]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y][x+1]=='1' && x<=3)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+1][x+1]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\tprintf(\"R\");\n\t\t}\n\t\telse if(state[0]=='D')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+2][x]=='1' && y<=6)\n\t\t\t{\n\t\t\t\ty+=2;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y+1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\tprintf(\"D\");\n\t\t}\n\t\telse if(state[0]=='L')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\tprintf(\"L\");\n\t\t}\n\t\telse if(state[0]=='U')\n\t\t{\n\t\t\tif(stage[y-1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-2][x]=='1' && y>=2)\n\t\t\t{\n\t\t\t\ty-=2;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && x<=3)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\tprintf(\"U\");\n\t\t}\n\t\t\n\t\tif(x==0 && y==0)\n\t\t{\n\t\t\tprintf(\"L\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum direction {right, down, left, up};\n\nint main() {\n\tchar input[16][16];\n\n\tint ans = 0;\n\tint i, j;\n\tint now = right + 128;\n\tint roop = 0;\n\n\tfor(i = 0; i < 16; i++)\n\t\tfor(j = 0; j < 16; j++)\n\t\t\tinput[i][j] = '0';\n\n\tfor(i = 0; i < 9; i++) {\n\t\tfor(j = 1 - i % 2; j < 9; j += 2)\n\t\t\tscanf(\"%c\", &input[i][j]);\n\n\t\tgetchar();\n\t}\n/*\t\n\t   for(i = 0; i < 16; i++) {\n\t   for(j = 0; j < 16; j++)\n\t   putchar(input[i][j]);\n\t   putchar('\\n');\n\t   }\n*/\t \n\ti = j = 0;\n\n\tdo{\n\t\tswitch(now % 4) {\n\t\t\tcase right:\n\t\t\t\tif(input[i][j + 1] == '1') {\n\t\t\t\t\tif(i > 0 && input[i - 1][j + 2] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\tj += 2;\n\t\t\t\t\tputchar('R');\n\t\t\t\t}\n\n\t\t\t\telse\n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase down:\n\t\t\t\tif(input[i + 1][j] == '1') {\n\t\t\t\t\tif(input[i + 2][j + 1] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\ti += 2;\n\t\t\t\t\tputchar('D');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase left:\n\t\t\t\tif(j > 0 && input[i][j - 1] == '1') {\n\t\t\t\t\tif(input[i + 1][j - 2] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\tj -= 2;\n\t\t\t\t\tputchar('L');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\n\t\t\tcase up:\n\t\t\t\tif(i > 0 && input[i - 1][j] == '1') {\n\t\t\t\t\tif(j > 0 && input[i - 2][j - 1] == '1')\n\t\t\t\t\t\tnow--;\n\n\t\t\t\t\ti -= 2;\n\t\t\t\t\tputchar('U');\n\t\t\t\t}\n\n\t\t\t\telse \n\t\t\t\t\tnow++;\n\n\t\t\t\tbreak;\n\t\t}\n\t} while(i + j || !(now % 4 == left || now % 4 == up));\n\n\tputchar('\\n');\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint wall[15][15], x, y, way, i, j, anyway;\n\nint main(){\n  for(i = 1;i <= 9;i++){\n    for(j = 1;j <= 5 - (i % 2);j++){\n      scanf(\"%1d\", &wall[i][j]);\n    }\n  }\n  x = 0;\n  y = 0;\n  way = 0;// 0:R, 1:D, 2:L, 3:U\n  anyway = 0;\n  do{\n    if(way == 0){\n      if(!anyway && wall[x * 2][y + 1] == 1){\n\tway = 3;\n\tanyway = 1;\n      }\n      else if(wall[x * 2 + 1][y + 1] == 1){\n\ty++;\n\tanyway = 0;\n\tputchar('R');\n      }\n      else{\n\tway = 1;\n\tanyway = 0;\n      }\n    }\n    if(way == 1){\n      if(!anyway && wall[x * 2 + 1][y + 1] == 1){\n\tway = 0;\n\tanyway = 1;\n      }\n      else if(wall[x * 2 + 2][y + 1] == 1){\n\tx++;\n\tanyway = 0;\n\tputchar('D');\n      }\n      else{\n\tway = 2;\n\tanyway = 0;\n      }\n    }\n    if(way == 2){\n      if(!anyway && wall[x * 2 + 2][y + 1] == 1){\n\tway = 1;\n\tanyway = 1;\n      }\n      else if(wall[x * 2 + 1][y] == 1){\n        y--;\n\tanyway = 0;\n\tputchar('L');\n      }\n      else{\n\tway = 3;\n\tanyway = 0;\n      }\n    }\n    if(way == 3){\n      if(!anyway && wall[x * 2 + 1][y] == 1){\n\tway = 2;\n\tanyway = 1;\n      }\n      else if(wall[x * 2][y + 1] == 1){\n\tx--;\n\tanyway = 0;\n\tputchar('U');\n      }\n      else{\n\tway = 0;\n\tanyway = 0;\n      }\n    }\n  }while(x != 0 || y != 0);\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\tdo\n\t\t\tp=(p+1)%4;\n\t\twhile(!((f[y][x]>>p)&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define R 0\n#define L 1\n#define D 2\n#define U 3\n\nvoid searchfr(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){\n        //printf(\"%c\\n\",t[j][i]);\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n        }\n        else{\n            printf(\"L\");\n            *vec=L;\n        }\n    }\n}\n\n\nvoid searchfl(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n        }\n        else{\n            printf(\"R\");\n            *vec=R;\n        }\n    }\n}\n\nvoid searchfd(int i,int j,char y[5][5],char t[4][6],int *vec){\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n            return;\n        }\n    }\n    if(j!=0){\n        if(t[j-1][i]=='1'){\n            printf(\"U\");\n            *vec=D;\n            return;\n        }\n    }\n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n        }\n        else{\n            printf(\"D\");\n            *vec=U;\n        }\n    }\n}\n\nvoid searchfu(int i,int j,char y[5][5],char t[4][6],int *vec){\n    \n    if(i!=4){\n        if(y[j][i]=='1'){\n            printf(\"R\");\n            *vec=R;\n            return;\n        }\n    }\n    if(j!=4){\n        if(t[j][i]=='1'){\n            printf(\"D\");\n            *vec=U;\n            return;\n        }\n    }\n    if(i!=0){\n        if(y[j][i-1]=='1'){\n            printf(\"L\");\n            *vec=L;\n        }\n        else{\n            printf(\"U\");\n            *vec=D;\n        }\n    }\n}\n\n\nint main(int argc, const char * argv[]) {\n    char y[5][5],t[4][6];\n    int vec,i,j,k;\n    \n    for(k=0;k<4;k++){\n        scanf(\"%s\",y[k]);\n        scanf(\"%s\",t[k]);\n    }\n    scanf(\"%s\",y[k]);\n    printf(\"R\");\n    i=1;\n    j=0;\n    vec=R;\n    while(i!=0||j!=0){\n        //printf(\"(%d,%d)\\n\",i,j);\n        if(vec==R){\n            //printf(\"Rin\\n\");\n            searchfr(i,j,y,t,&vec);\n        }\n        else if(vec==L){\n            searchfl(i,j,y,t,&vec);\n        }\n        else if(vec==U){\n            searchfu(i,j,y,t,&vec);\n        }\n        else {\n            searchfd(i,j,y,t,&vec);\n        }\n        \n        switch(vec){\n            case R:\n                i++;\n                break;\n            case L:\n                i--;\n                break;\n            case U:\n                j++;\n                break;\n            case D:\n                j--;\n                break;\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep2(i,n) rep3(i,0,n)\n#define rep3(i,j,n) for((i)=(j) ; (i)<(n) ; (i)++)\n#define pl(format,var) p(format \"\\n\",var)\n#define p(format,var) printf(format,var)\n#define asizeof(array) (sizeof(array)/sizeof(array[0]))\n\n/*\n[履歴]\n・投下\n\n[メモ3]\n入力データを探索する用のインデックスの他に、\n移動後の位置を表すインデックスを導入してみた。\nんで、両者の対応を紙面上で洗い出して、コードに落とした。\n\n*/\n\n#define YMAX 9\n#define XMAX 5\n\nint count=0; //For debugging\n\ntypedef enum {\n\tU=0,\n\tR,\n\tD,\n\tL\n} state_t; //状態を表す列挙型\n\n//状態に対応する文字を出力\nvoid printstate(state_t s){\n\tswitch(s){\n\t\tcase L:\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\tcase R:\n\t\t\tprintf(\"R\");\n\t\t\tbreak;\n\t\tcase U:\n\t\t\tprintf(\"U\");\n\t\t\tbreak;\n\t\tcase D:\n\t\t\tprintf(\"D\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%d\",s);\n\t\t\tbreak;\n\t}\n}\n\n//RRRRDDDDLLLUUURRDDLURDLURDLURDLURD\n//RRRRDDDDLLLUUURRDDLURULLDDDRRRUUUULLLL\n//                     ~ ~~ ~~\n\nint main(){\n\tchar line[80]; //入力行\n\tint i,j; //カウンタ変数\n\tint array[YMAX][XMAX]; //入力データ\n\tint x,y; //探索先インデックス\n\tint px,py; //現在の位置\n\tstate_t s; //現状態\n\tint dir4data[4][2]={\n\t\t{-1,0}, /* U */\n\t\t{0,0}, /* R */\n\t\t{1,0}, /* D */\n\t\t{0,-1} /* L */\n\t};\n\tint dir4pos[4][2]={\n\t\t{-2,0}, /* U */\n\t\t{0,1}, /* R */\n\t\t{2,0}, /* D */\n\t\t{0,-1} /* L */\n\t};\n\n\t//入力データを読み込む\n\t// 奇数行目の末尾にデータが入ってないが,\n\t// アクセスすることはないので放置\n\trep2(i,YMAX){\n\t\tfgets(line, sizeof(line), stdin);\n\t\trep2(j,XMAX){\n\t\t\tarray[i][j] = line[j] - '0';\n\t\t}\n\t\tif(i%2==0)\n\t\t\tarray[i][j-1] = 0; //ゴミデータが入っているのでゼロクリアしとく\n\t}\n\t\n\t//スタート地点をセット\n\tpx = py = 0;\n\tx = y = 0;\n\ts = R;\n\t\n\twhile(s==R || px!=0 || py!=0){\n\t\t//count++; if(count == 35) break;\n\t\t//現在の探索先から各方向を調べる\n\t\tfor(i=0,j=(s==U)?L:s-1 ; i<4 ; i++,j++){\n\t\t\t//方向配列をループさせる\n\t\t\tif(j>=4)\n\t\t\t\tj = 0;\n\n// s = r\n// py,px = 4,3\n// y,x = 4,2\n\n\t\t\t//次の探索先を計算\n\t\t\ty = py + dir4data[j][0];\n\t\t\tx = px + dir4data[j][1];\n\t\t\t\n\t\t\t//if(count==22) printf(\"#### y,x = %d,%d\\n\",y,x), printf(\"#### j=%d\\n\",j);\n\t\t\t\n\t\t\t//次の探索先が無効か0なら, スキップ\n\t\t\tif(x<0 || y<0 || x>=XMAX || y>=YMAX || array[y][x]==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//探索先と現状態を更新, 状態が移ったのでいったん抜けて新たに探索する\n\t\t\ts = j;\n\t\t\tpy += dir4pos[j][0];\n\t\t\tpx += dir4pos[j][1];\n\t\t\tprintstate(s);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\tprintf(\"## count:%d s:\",count);\n\t\tprintstate(s); printf(\"\\n\");\n\t\tprintf(\"## py,px = %d,%d\\n\",py,px);\n\t\tprintf(\"## y,x = %d,%d\\n\",y,x);\t\t\n\t\tprintf(\"\\n\");\n\t\t*/\n\t}\n\tprintf(\"\\n\");\n  return 0;\n}\n\n/*\n[メモ]\n進行方向を一つの状態とみなす。\nl,r,u,dで状態は四つ。\n\n次状態は、どこに道があるかで決まる。\n\t(現状態) (次状態 左のものほど優先的に採用, なければ一つ右を採用)\n\tlのとき d, l, u, r\n\trのとき u, r, d, l\n\tuのとき l, u, r, d\n\tdのとき r, d, l, u\n\nメモ割り込むよ！--------\nu -1,0\nr 0,1\nd 1,0\nl 0,-1\nこれ配列に。\n状態との対応付けはこう → u=0, r=1, d=2, l=3\n\n現状態から順番に配列の方向にある要素が1かどうかを試す。\n1を見つけたら, そこに進む。\nインデックスの範囲越えには気をつけて。\n\nやること\nv\t配列定義\nv\t定数定義(対応付けのとおりに数値を対応付けさせる)\n\t配列スキャン部分(ループにする)\n\tインデックス範囲越えを入れる\n\t1を見つけたら、そこに進むとか、そのへん。\n\n\t条件分岐はメンドくさい、規則性無いか？\n\t→時計回りだね。\n\t  抽象的なコード書く方がメンドくさそうなんで、直に書いちゃうか。。。\n割り込みおわり--------\n\n点Aに戻ってきたら終了。\n\nある奇数行i番目から直近辿れる偶数行の要素位置\n\tlのとき i番目\n\trのとき i+1番目\n\nある偶数行i番目から直近辿れる奇数行位置\n\t次にlに行く i-1番目\n\t次にrに行く i番目\n\nじゃあコード書くか。\n入力データ処理部分おわり。\n残りはどう書く？\n\n要るのは表示、状態遷移、インデックス更新。\nもっというと\n\t現状態から、どの要素を探索するかを決める\n\t要素を探索し、見つかった方向に対応する状態に遷移。\n\t現座標を遷移後に更新し、遷移後を出力。\n\n[メモ2]\n最悪。\n入力データの解釈の仕方を間違えていた。。。\n2行目からダウンするとき、次に読み込むのは3行目じゃない、「4行目」だ！\n\n修正加えようとしたけど、次から次へと条件分岐が増える増える。\n条件自体の修正も何度も行う行う。。。\nで、わけがわからない。\n\nいったんやり直そうか。\n\n*/"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define DEBUG 0\n\n\ntypedef struct TGrid Grid;\nstruct TGrid {\n    int fRight;\n    int fDown;\n};\n\n/* starting at (1, 1), not (0,0) */ #define XSIZE 6\n#define YSIZE 6\n\nGrid Grids[(XSIZE)*(YSIZE)];\nenum {BadDirection=0, North=1, East=2, South=3, West=4};\nchar Map[5] = {'X', 'U', 'R', 'D', 'L'};\n\n\n\nint right_at(int x, int y){\n   return Grids[x+XSIZE*y].fRight;\n}\n\nint down_at(int x, int y){\n   return Grids[x+XSIZE*y].fDown;\n}\n\nint left_at(int x, int y){\n   return Grids[x-1+XSIZE*y].fRight;\n}\n\nint up_at(int x, int y){\n   return Grids[x+XSIZE*(y-1)].fDown;\n}\n\nvoid cw(int* nx, int *ny, int x, int y){\n    int ux, uy;\n    int vx, vy;\n\n    if(DEBUG)\n        printf(\"(%d, %d) (%d, %d)\\n\", *nx, *ny, x, y);\n\n    ux = *nx - x;\n    uy = *ny - y;\n    /* rotate -pi/2, (0 1), (-1, 0) */\n    vx = -uy;\n    vy = ux;\n    *nx = x + vx;\n    *ny = y + vy;\n\n    if(DEBUG)\n        printf(\"=> (%d, %d) (%d, %d)\\n\", *nx, *ny, x, y);\n}\n\n\nint direction(int dx, int dy, int x, int y){\n    if (dx == x){\n        if(dy < y){\n            return North;\n        }else{\n            return South;\n        };\n    }else{\n        if(dx > x){\n            return East;\n        }else{\n            /*dx < x*/\n            return West;\n        };\n    }\n}\n\nvoid step(int* x, int* y, int* prevx, int* prevy){\n    int i, d;\n    int has_wall;\n    int nextx, nexty;\n    nextx = *prevx;\n    nexty = *prevy;\n\n    if(DEBUG)\n        printf(\"current(%d, %d) prev(%d, %d)\\n\", *x, *y, *prevx, *prevy);\n\n    for(i=0;i<4;i++){\n        cw(&nextx, &nexty, *x, *y);\n        d = direction(nextx, nexty, *x, *y);\n        if(DEBUG)\n            printf(\"trying direction:%c\\n\", Map[d]);\n        switch(d){\n            case North:\n                has_wall = up_at(*x, *y);\n                break;\n            case East:\n                has_wall = right_at(*x, *y);\n                break;\n            case South:\n                has_wall = down_at(*x, *y);\n                break;\n            case West:\n                has_wall = left_at(*x, *y);\n                break;\n            default:\n                break;\n        }\n        if(DEBUG)\n            printf(\"has_wall %d\\n\", has_wall);\n        if(has_wall){\n            printf(\"%c\",Map[d]);\n            break;\n        }\n    }\n\n    *prevx = *x;\n    *prevy = *y;\n    *x = nextx;\n    *y = nexty;\n}\n\n\nvoid set_xy_right(int x, int y, int v){\n        Grids[x+XSIZE*y].fRight = v;\n}\n\nvoid set_xy_down(int x, int y, int v){\n        Grids[x+XSIZE*y].fDown = v;\n}\n\nint load_line(int nth){\n    int i;\n    int x;\n    if(nth%2){\n        scanf(\"%d\", &x);\n        for(i=0;i<4;i++){\n            set_xy_right(4-i,nth/2+1, x%10);\n            x = x/10;\n        }\n\n    }else{\n        scanf(\"%d\", &x);\n        for(i=0;i<5;i++){\n            set_xy_down(5-i,nth/2, x%10);\n            x = x/10;\n        }\n    }\n}\n\nint main(){\n    int x, y;\n    int prevx, prevy;\n    int done, nth;\n    nth = 1;\n\n    while(nth < 10){\n        load_line(nth);\n        nth ++;\n    }\n\n    if(DEBUG){\n        for(y=0;y<YSIZE;y++){\n            for(x=0;x<XSIZE;x++){\n                printf(\"%d\", Grids[x+y*XSIZE].fRight);\n            }\n            printf(\"\\n\");\n            for(x=0;x<XSIZE;x++){\n                printf(\"%d\", Grids[x+y*XSIZE].fDown);\n            }\n            printf(\"\\n\");\n            printf(\"---------\\n\");\n        }\n    }\n\n    x = 1; y = 1;\n    prevx = 1; prevy = 2;\n    step(&x, &y, &prevx, &prevy);\n    while(!(x==1 && y==1)){\n        step(&x, &y, &prevx, &prevy);\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],s[6],i,j,a,y,x,p,b;int main(){for(;i<9;++i,b=!b){scanf(\"%s\",s);for(j=4+b;j--;)a=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;}do{while(!((f[y][x]>>(p=(p+1)%4))&1));x+=p?2-p:0;y+=3-p?p-1:0;putchar(\"DLUR\"[p=(p+2)%4]);}while(y|x|**f*p>9);return!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZE 5\n\nint main(int argc, char *argv[]){\n     int x, y, v[SIZE][SIZE], h[SIZE][SIZE], f;\n     char d, t[SIZE+1];\n     \n     for(y=0; y<SIZE; y++)\n\t  for(x=0; x<SIZE; x++)\n\t       v[x][y]=0, h[x][y]=0;\n\n     while(~scanf(\"%s\",t)){\n\t  for(x=0; x<SIZE-1; x++) h[x][0] = t[x]-'0';\n\t  \n\t  for(y=0; y<SIZE-1; y++){\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE; x++) v[x][y] = t[x]-'0';\n\t       scanf(\"%s\",t);\n\t       for(x=0; x<SIZE-1; x++) h[x][y+1] = t[x]-'0';\n\t  }\n\t  \n\t  x=0, y=0, f=0, d='R';\n\t  while(x!=0 || y!=0 || !f){\n\t       f=1;\n\t       \n\t       putchar(d);\n\t       \n\t       switch(d){\n\t       case 'R':\n\t\t    x++;\n\t\t    if(v[x][y-1]) d='U';\n\t\t    else if(h[x][y]) d='R';\n\t\t    else if(v[x][y]) d='D';\n\t\t    else d='L';\n\t\t    break;\n\t       case 'D':\n\t\t    y++;\n\t\t    if(h[x][y]) d='R';\n\t\t    else if(v[x][y]) d='D';\n\t\t    else if(h[x-1][y]) d='L';\n\t\t    else d='U';\n\t\t    break;\n\t       case 'L':\n\t\t    x--;\n\t\t    if(v[x][y]) d='D';\n\t\t    else if(h[x-1][y]) d='L';\n\t\t    else if(v[x][y-1]) d='U';\n\t\t    else d='R';\n\t\t    break;\n\t       case 'U':\n\t\t    y--;\n\t\t    if(h[x-1][y]) d='L';\n\t\t    else if(v[x][y-1]) d='U';\n\t\t    else if(h[x][y]) d='R';\n\t\t    else d='D';\n\t\t    break;\n\t       }\n\t  }\n\n\t  printf(\"\\n\");\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define RIGHT 0\n#define LEFT 1\n#define UP 2\n#define DOWN 3\n\n#define OK 1\n#define NG 0\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side);\n\n\nint main(){\n\n\tint i,j,map[11][7]={0},x,y,sit,side;\n\n\tfor(i=1;i<9;i+=2){\n\t\tif(scanf(\"%1d%1d%1d%1d%1d%1d%1d%1d%1d\",&map[i][1],&map[i][2],&map[i][3],&map[i][4],&map[i+1][1],&map[i+1][2],&map[i+1][3],&map[i+1][4],&map[i+1][4])==EOF) break;\n\t}\n\tscanf(\"%1d%1d%1d%1d\",&map[9][1],&map[9][2],&map[9][3],&map[9][4]);\n\tx=0;\n\ty=0;\n\tx++;\n\n\tsit=RIGHT;\n\tside=UP;\n\tprintf(\"R\");\n\twhile(x==0 && y==0){\n\t\tswitch(sit){\n\t\t\tcase RIGHT:\n\t\t\t\tif(side==UP){\n\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=LEFT;\n\t\t\t\t\t\t\t\tside=DOWN;\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(side==DOWN){\n\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=RIGHT;\n\t\t\t\t\t\t\t\tside=UP;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(side==LEFT){\n\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=DOWN;\n\t\t\t\t\t\t\t\tside=RIGHT;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(side==RIGHT){\n\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=UP;\n\t\t\t\t\t\t\t\tside=LEFT;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)++;\n\t\t*side=UP;\n\t\t*sit=RIGHT;\n\t\tprintf(\"R\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\t\n}\n\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)--;\n\t\t*side=DOWN;\n\t\t*sit=LEFT;\n\t\tprintf(\"L\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)++;\n\t\t*side=LEFT;\n\t\t*sit=UP;\n\t\tprintf(\"U\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)--;\n\t\t*side=RIGHT;\n\t\t*sit=DOWN;\n\t\tprintf(\"D\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nenum{up,right,down,left};\nchar res[]=\"URDL\";\nint g[5][5][4],i,j,t,d=right;\n\nvoid move(int dir)\n{\n\tputchar(res[dir]);\n\td=dir;\n\tswitch(dir)\n\t{\n\tcase up:i--;break;\n\tcase right:j++;break;\n\tcase down:i++;break;\n\tcase left:j--;break;\n\t}\n}\n\nint main()\n{\n\tfor(i=0;i<9;i++,getchar())\n\t{\n\t\tif(i%2==0)\n\t\t\tfor(j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][right]=g[i/2][j+1][left]=1;\n\t\t\t}\n\t\telse\n\t\t\tfor(j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][down]=g[i/2+1][j][up]=1;\n\t\t\t}\n\t}\n\tfor(i=0,j=0,t=0;!t;)\n\t{\n\t\tswitch(d)\n\t\t{\n\t\tcase up:if(g[i][j][left])\n\t\t\t\t\tmove(left);\n\t\t\t\telse if(g[i][j][up])\n\t\t\t\t\tmove(up);\n\t\t\t\telse\n\t\t\t\t\tmove(right);\n\t\t\t\tbreak;\n\t\tcase right:if(g[i][j][up])\n\t\t\t\t\tmove(up);\n\t\t\t\t   else if(g[i][j][right])\n\t\t\t\t\t   move(right);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(down);\n\t\t\t\tbreak;\n\t\tcase left: if(g[i][j][down])\n\t\t\t\t\t\tmove(down);\n\t\t\t\t   else if(g[i][j][left])\n\t\t\t\t\t   move(left);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(up);\n\t\t\t\tbreak;\n\t\tcase down: if(g[i][j][right])\n\t\t\t\t\t\tmove(right);\n\t\t\t\t   else if(g[i][j][down])\n\t\t\t\t\t   move(down);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(left);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i==0&&j==0)\n\t\t\tputs(\"\"),t=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tchar temp[9][5], map[9][5];\n\tint i, j;\n\tchar direction;\n\t\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tscanf(\"%c\", &temp[i][j]);\n\t\t}\n\t\tgetchar();\n\t}\n\t\n\tmemset(map, 0, sizeof(map));\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tif (i % 2 == 0){\n\t\t\t\t\tif (temp[i][j] == '1'){\n\t\t\t\t\t\tmap[i][j] = map[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\tmap[i][j] = temp[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\tj = 0;\n\tdirection = 'R';\n\tdo {\n\t\tswitch (direction){\n\t\t\tcase 'R':\n\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\tj++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirection = 'L';\n\t\t\t\tj--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'L':\n\t\t\tif (map[i][j - 1] == 1){\n\t\t\t\tj--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirection = 'R';\n\t\t\t\tj++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'D':\n\t\t\tdirection = 'U';\n\t\t\tif (map[i + 2][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti += 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1 && map[i + 1][j - 1] == 1){\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j + 1] == 1){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'U':\n\t\t\tdirection = 'D';\n\t\t\tif (map[i - 2][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti -= 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1 && map[i - 1][j - 1] == 1){\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j + 1] == 1){\n\t\t\t\ti--;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (i + j != 0);\n\tprintf(\"\\n\");\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "char f[6][6],s[6],i,j,a,y,x,p,b;main(){for(;i<9;++i,b=!b){scanf(\"%s\",s);for(j=4+b;j--;)a=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;}do{while(!((f[y][x]>>(p=(p+1)%4))&1));x+=p?2-p:0;y+=3-p?p-1:0;putchar(\"DLUR\"[p=(p+2)%4]);}while(y|x|**f*p>9);puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint a[6][6][4];\n\nint R=0,L=1,U=2,D=3;\n\n// void print(){\n// \tint i,j;\n// \tfor(i=0; i<6; i++){\n// \t\tfor(j=0; j<6; j++){\n// \t\t\tprintf(\"%d\",a[i][j][U]);\n// \t\t}\n// \t\tprintf(\"\\n\");\n// \t}\n// \tprintf(\"\\n\");\n// \tfor(i=0; i<6; i++){\n// \t\tfor(j=0; j<6; j++){\n// \t\t\tprintf(\"%d\",a[i][j][D]);\n// \t\t}\n// \t\tprintf(\"\\n\");\n// \t}\n// \tprintf(\"\\n\");\n// \tfor(i=0; i<6; i++){\n// \t\tfor(j=0; j<6; j++){\n// \t\t\tprintf(\"%d\",a[i][j][R]);\n// \t\t}\n// \t\tprintf(\"\\n\");\n// \t}\n// \tprintf(\"\\n\");\n// \tfor(i=0; i<6; i++){\n// \t\tfor(j=0; j<6; j++){\n// \t\t\tprintf(\"%d\",a[i][j][L]);\n// \t\t}\n// \t\tprintf(\"\\n\");\n// \t}\n// \tprintf(\"\\n\");\n// }\n\nint main(){\n\tint i,j,k,x=0,y=0,d;\n\tchar c;\n\tfor(i=0; i<4; i++){\n\t\tfor(j=0; j<4; j++){\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ta[y][j+1][D]=1;\n\t\t\t\ta[y+1][j+1][U]=1;\n\t\t\t}\n\t\t}\n\t\ty++;\n\t\tscanf(\"%c\",&c);\n\t\tfor(j=0; j<5; j++){\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ta[y][j][R]=1;\n\t\t\t\ta[y][j+1][L]=1;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%c\",&c);\n\t}\n\tfor(i=0; i<4; i++){\n\t\tscanf(\"%c\",&c);\n\t\tif(c=='1'){\n\t\t\ta[4][i+1][D]=1;\n\t\t\ta[5][i+1][U]=1;\n\t\t}\n\t}\n\n\tx=0;\n\ty=0;\n\td=R;\n\twhile(1){\n\t\tif(d==R){\n\t\t\tif(a[y][x][R]){\n\t\t\t\td=U;\n\t\t\t}\n\t\t\telse if(a[y][x+1][D]){\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t\td=D;\n\t\t\t}\n\t\t}\n\t\telse if(d==D){\n\t\t\tif(a[y][x][D]){\n\t\t\t\td=R;\n\t\t\t}\n\t\t\telse if(a[y+1][x][L]){\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\td=L;\n\t\t\t}\n\t\t}\n\t\telse if(d==L){\n\t\t\tif(a[y][x][L]){\n\t\t\t\td=D;\n\t\t\t}\n\t\t\telse if(a[y][x-1][U]){\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\td=U;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(a[y][x][U]){\n\t\t\t\td=L;\n\t\t\t}\n\t\t\telse if(a[y-1][x][R]){\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\td=R;\n\t\t\t}\n\t\t}\n\t\tif(d==R)printf(\"R\");\n\t\telse if(d==L)printf(\"L\");\n\t\telse if(d==U)printf(\"U\");\n\t\telse printf(\"D\");\n\n\t\t//printf(\"  x:%d y:%d\\n\",x,y);\n\t\t// if(x>5||x<0||y>5||y<0){\n\t\t// \tprintf(\"x:%d y:%d\\n\",x,y);\n\t\t// \tbreak;\n\t\t// }\n\n\t\tif(x==1&&y==1&&d==L)break;\n\t\tif(x==0&&y==1&&d==U)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tx=y=5;\n\tfor(j=0;j<2*y;j++)for(i=0;i<2*x;i++)s[i][j]=0;\n\tfor(j=1;j<2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:1;i<2*x;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=3,y=1;x!=1||y!=1;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nchar s[13][7];\nint order[32] = {0, 1, 2, 3, 0, 3, 2, 1, 2, 1, 0, 3, 2, 3, 0, 1,\n                 3, 0, 1, 2, 3, 2, 1, 0, 1, 0, 3, 2, 1, 2, 3, 0};\nint nds[32] = {4, 0, 7, 3, 6, 1, 5, 2, 5, 2, 6, 1, 7, 3, 4, 0,\n               3, 4, 0, 7, 1, 5, 2, 6, 2, 6, 1, 5, 0, 7, 3, 4};\nint ds[8] = {1, 3, 1, 3, 0, 2, 0, 2};\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar ls[8] = {'R', 'L', 'R', 'L', 'U', 'D', 'U', 'D'};\nint i, j;\n\nbool doesWallExist(int x, int y, int d){\n    // printf(\"%d, %d, %d, %d, %d: \", x, y, d, x+(dx[d]-1)/2, 2*y+(dy[d]-1)/2);\n    if(s[2*y+dy[d]][x+(dx[d]-1)/2] == '1'){\n        //puts(\"o\");\n        return true;\n    }\n    //puts(\"x\");\n    return false;\n}\n\nint main(){\n    for(i=0;i<13;i++){\n        for(j=0;j<7;j++){\n            s[i][j] = '0';\n        }\n    }\n\n    for(i=2;i<=10;i++){\n        int ub = i%2?5:4;\n        for(j=0;j<ub;j++){\n            scanf(\"%c\", &s[i][j+1]);\n        }\n        scanf(\"%*c\");\n    }\n\n    bool f = false;\n    int x = 1, y = 1, d = 0;\n    while(!(x == 1 && y == 1 && f)){\n        if(!f){f = true;}\n\n        // printf(\"%d, %d, %d\\n\", x, y, d);\n        putchar(ls[d]);\n        x += dx[ds[d]]; y += dy[ds[d]];\n\n        for(i=0;i<4;i++){\n            if(doesWallExist(x, y, order[d*4+i])){\n                d = nds[d*4+i];\n                break;\n            }\n        }\n    }\n    puts(\"\");\n\n    /* for(int i=0;i<13;i++){ */\n    /*     for(int j=0;j<7;j++){ */\n    /*         putchar(s[i][j]); */\n    /*     } */\n    /*     puts(\"\"); */\n    /* } */\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nenum{up,right,down,left};\nchar *res=\"URDL\";\nint g[5][5][4],i,j,t,d=right;\n\nvoid move(int dir)\n{\n\tputchar(res[dir]);\n\td=dir;\n\tswitch(dir)\n\t{\n\tcase up:i--;break;\n\tcase right:j++;break;\n\tcase down:i++;break;\n\tcase left:j--;break;\n\t}\n}\n\nint main()\n{\n\tfor(i=0;i<9;i++,getchar())\n\t{\n\t\tif(i%2==0)\n\t\t\tfor(j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][right]=g[i/2][j+1][left]=1;\n\t\t\t}\n\t\telse\n\t\t\tfor(j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][down]=g[i/2+1][j][up]=1;\n\t\t\t}\n\t}\n\tfor(i=0,j=0,t=0;!t;)\n\t{\n\t\tswitch(d)\n\t\t{\ns:\t\tcase right:if(g[i][j][up]){move(up);break;}\n\t\tcase down:if(g[i][j][right]){move(right);break;}\n\t\tcase left:if(g[i][j][down]){move(down);break;}\n\t\tcase up:if(g[i][j][left]){move(left);break;}\n\t\tdefault:goto s;\n\t\t}\n\t\tif(i==0&&j==0)\n\t\t\tputs(\"\"),t=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint main(){\n  int i,j,w[11][11]={0};\n  int x,y,n,d=1,m=0;\n  int X[]={-1, 0, 1, 1, 2, 1, 1, 0,-1,-1,-2,-1};\n  int Y[]={-1,-2,-1,-1, 0, 1, 1, 2, 1, 1, 0,-1};\n  for(i=0;i<11;i++){\n    for(j=0;j<11;j++){\n      w[i][j]=2;\n    }\n  }\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&n);\n    for(j=3-(i%2);j<11;j+=2){\n      w[i+1][11-j]=n%10;\n      n/=10;\n    }\n  }\n  for(i=0;i<11;i++){\n    for(j=0;j<11;j++){\n      printf(\"%d\",w[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  y=1;\n  x=4;\n  printf(\"RR\");\n  while(x!=2||y!=1){\n    m=0;\n    for(i=0;i<3;i++){\n      if(w[y+Y[d*3+i]][x+X[d*3+i]]==1){\n\tx+=X[d*3+i];\n\ty+=Y[d*3+i];\n\td+=i-1;\n\tm=1;\n\tbreak;\n      }\n    }\n    if(m==0){\n      d+=2;\n    }\n    d+=4;\n    d%=4;\n    if(d==0)printf(\"U\");\n    if(d==1)printf(\"R\");\n    if(d==2)printf(\"D\");\n    if(d==3)printf(\"L\");\n  }\n  printf(\"\\n\");\n  return 0; \n}\n\t"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tmemset(s,11,sizeof(s));\n\tx=y=5;\n\tfor(j=2;j<=2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:3;i<2*x+1;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=4,y=2;x!=2||y!=2;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n\tint u;\n\tint r;\n\tint d;\n\tint l;\n} cell;\n\nint search_d(cell *c, int d)\n{\n\tint *p = (int *)c;\n\tint i, nd;\n\n\tnd = (d + 2) % 4;\n\tfor (i = 0; i < 3; i++){\n\t\tnd = (nd + 1) % 4;\n\t\tif (p[nd]) return (nd);\n\t}\n}\n\nint main(void)\n{\n\tcell map[8][8];\n\tint i, j;\n\tint d, s;\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {-1, 0, 1, 0};\n\tint nx, ny;\n\n\tmemset(map, 0, sizeof(map)); \n\tfor (i = 0; i < 5; i++){\n\t\tchar s[8];\n\t\tscanf(\"%s\", s);\n\t\tfor (j = 0; j < 4; j++){\n\t\t\tmap[i][j].r = map[i][j + 1].l = s[j] - '0';\n\t\t}\n\t\tif (i == 4) break;\n\t\tscanf(\"%s\", s);\n\t\tfor (j = 0; j < 5; j++){\n\t\t\tmap[i][j].d = map[i + 1][j].u = s[j] - '0';\n\t\t}\n\t}\n\n\ts = d = 1;\n\tnx = ny = 0;\n\tdo {\n\t\td = search_d(&map[ny][nx], d);\n\t\tny += dy[d];\n\t\tnx += dx[d];\n\t\tprintf(\"%c\", \"URDL\"[d]);\n\t} while (nx + ny);\n\tputs(\"\");\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define RIGHT 0\n#define LEFT 1\n#define UP 2\n#define DOWN 3\n\n#define OK 1\n#define NG 0\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side);\n\n\nint main(){\n\n\tint i,j,map[11][7]={0},x,y,sit,side;\n\n\tfor(i=1;i<9;i+=2){\n\t\tif(scanf(\"%1d%1d%1d%1d%1d%1d%1d%1d%1d\",&map[i][1],&map[i][2],&map[i][3],&map[i][4],&map[i+1][1],&map[i+1][2],&map[i+1][3],&map[i+1][4],&map[i+1][5])==EOF) break;\n\t}\n\tscanf(\"%1d%1d%1d%1d\",&map[9][1],&map[9][2],&map[9][3],&map[9][4]);\n\tx=0;\n\ty=0;\n\tx++;\n\n\tsit=RIGHT;\n\tside=UP;\n\tprintf(\"R\");\n\twhile(x!=0 || y!=0){\n\t\tswitch(sit){\n\t\t\tcase RIGHT:\n\t\t\t\tif(side==UP){\n\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=LEFT;\n\t\t\t\t\t\t\t\tside=DOWN;\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(side==DOWN){\n\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=RIGHT;\n\t\t\t\t\t\t\t\tside=UP;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(side==LEFT){\n\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=DOWN;\n\t\t\t\t\t\t\t\tside=RIGHT;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(side==RIGHT){\n\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=UP;\n\t\t\t\t\t\t\t\tside=LEFT;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n\n}\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)++;\n\t\t*side=UP;\n\t\t*sit=RIGHT;\n\t\tprintf(\"R\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\t\n}\n\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)]==1){\n\t\t(*x)--;\n\t\t*side=DOWN;\n\t\t*sit=LEFT;\n\t\tprintf(\"L\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2][(*x)+1]==1){\n\t\t(*y)--;\n\t\t*side=LEFT;\n\t\t*sit=UP;\n\t\tprintf(\"U\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+2][(*x)+1]==1){\n\t\t(*y)++;\n\t\t*side=RIGHT;\n\t\t*sit=DOWN;\n\t\tprintf(\"D\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nvoid ntrim(char*);\nchar** makeLines(int*);\nvoid aruku(char**,int,int,int,int,int,int,char*);\n\n\nint main(void){\n\t\n\tint lineban=1;\n\tchar** lines=makeLines(&lineban);\n\t\n\tint sx=1,sy=1,step=0;int dir=0;int x=0,y=0;\n\tif(lines[2][1]=='1'){sx=1;sy=2;dir=0;}else{sx=1;sy=3;dir=1;}\n\t\n\tchar* path=(char*)calloc(10,sizeof(char));\n\taruku(lines,sx,sy,sx,sy,step,dir,path);\n\t\n\tprintf(\"%s\\n\",path);\n\tfree(path);\n\tfree(lines);\n\nreturn 0;\n}\n\n\nvoid ntrim(char *str) {  \n  char *p;  \n  p=strchr(str,'\\n');  \n  if(p!=NULL) {  \n    *p = '\\0';\n  }  \n}  \n\nchar** makeLines(int *lineban){\n\tchar** line=(char**)calloc(1,sizeof(char*));\n\tchar* s;\n\tsize_t len;\n\tint w=0;\n\tint sz=0;\n\twhile(sz=getline(&s,&len,stdin)>0 && s[0]!='\\n'){\n\t\tline=realloc(line,((*lineban)+5)*sizeof(char*));\n\t\tif((*lineban)==1){line[0]=(char*)calloc(strlen(s)+5,sizeof(char));line[1]=(char*)calloc(strlen(s)+5,sizeof(char));}\n\t\tline[(*lineban)+1]=(char*)calloc(sz+5,sizeof(char));\n\t\tline[0][(*lineban)+1]='0';\n\t\tint pt=1;\n\t\tntrim(s);\n\t\tsprintf(line[(*lineban)+1],\"%c%s%c%c\",'0',s,'0','\\0');\n\t\tif(w<strlen(s)){w=sz;}\n\t\t(*lineban)++;\n\t}\n\tline[0]=realloc(line[0],(w+2)*sizeof(char));\n\tline[1]=realloc(line[1],(w+2)*sizeof(char));\n\tfor(int i=0;i<w+1;i++){line[0][i]='0';line[1][i]='0';}line[0][w+1]='\\0';line[1][w+1]='\\0';\n\n\tline[(*lineban)+1]=(char*)calloc(w+2,sizeof(char));\n\tline[(*lineban)+2]=(char*)calloc(w+2,sizeof(char));\n\t\n\tfor(int i=0;i<w+1;i++){line[(*lineban)+1][i]='0';line[(*lineban)+2][i]='0';}\n\tline[(*lineban)+1][w+1]='\\0';\n\tline[(*lineban)+2][w+1]='\\0';\n\treturn line;\n}\n\nvoid aruku(char** line,int x,int y,int sx,int sy,int step,int dir,char* path){\n\tif(dir==0)strcat(path,\"R\");\n\telse if(dir==3)strcat(path,\"U\");\n\telse if(dir==1)strcat(path,\"D\");\n\telse{ strcat(path,\"L\");}\n\tif(strlen(path)-step<10){path=realloc(path,(strlen(path)+10)*sizeof(char));}\n\t\n\tif(sx==x && sy==y && step>0)return;\n\tswitch(dir){\n\tcase 0:\n\t\tif(line[y-1][x+1]=='1'){x=x+1;y=y-1;dir=3;}\n\t\telse if(line[y][x+1]=='1'){x=x+1;y=y;dir=0;}\n\t\telse if(line[y+1][x+1]=='1'){x=x+1;y=y+1;dir=1;}\n\t\telse{dir=2;}\n\t\tstep++;\n\t\taruku(line,x,y,sx,sy,step,dir,path);\n\t\tbreak;\n\tcase 1:\n\t\tif(line[y+1][x]=='1'){x=x;y=y+1;dir=0;}\n\t\telse if(line[y+2][x]=='1'){x=x;y=y+2;dir=1;}\n\t\telse if(line[y+1][x-1]=='1'){x=x-1;y=y+1;dir=2;}\n\t\telse{dir=3;}\n\t\tstep++;\n\t\taruku(line,x,y,sx,sy,step,dir,path);\n\t\tbreak;\n\tcase 2:\n\t\tif(line[y+1][x]=='1'){x=x;y=y+1;dir=1;}\n\t\telse if(line[y][x-1]=='1'){x=x-1;y=y;dir=2;}\n\t\telse if(line[y-1][x]=='1'){x=x;y=y-1;dir=3;}\n\t\telse{dir=0;}\n\t\tstep++;\n\t\taruku(line,x,y,sx,sy,step,dir,path);\n\t\tbreak;\n\t\n\t\tcase 3:\n\t\tif(line[y-1][x-1]=='1'){x=x-1;y=y-1;dir=2;}\n\t\telse if(line[y-2][x]=='1'){x=x;y=y-2;dir=3;}\n\t\telse if(line[y-1][x]=='1'){x=x;y=y-1;dir=0;}\n\t\telse{dir=1;}\n\t\tstep++;\n\t\taruku(line,x,y,sx,sy,step,dir,path);\n\t\tbreak;\n\t}\n\treturn;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define LEFT 0\n#define RIGHT 1\n#define UP 2\n#define DOWN 3\n\nint main(void){\n\tint wall_s[5][4];\n\tint wall_l[4][5];\n\tint x, y;\n\tint dir;\n\tint i, j;\n\n\t//üÍ\n\tfor(j=0; j<4; j++){\n\t\tfor(i=0; i<4; i++){\n\t\t\tscanf(\"%1d\", &wall_s[j][i]);\n\t\t}\n\t\tfor(i=0; i<5; i++){\n\t\t\tscanf(\"%1d\", &wall_l[j][i]);\n\t\t}\n\t}\n\tfor(i=0; i<4; i++){\n\t\tscanf(\"%1d\", &wall_s[4][i]);\n\t}\n\n\tx = 0;\n\ty = 0;\t\n\tdir = RIGHT;\n\twhile(1){\n\t\tif(dir == RIGHT){\n\t\t\tif(y-1 >= 0 && wall_l[y-1][x] == 1){\n\t\t\t\ty--;\n\t\t\t   \tprintf(\"U\");\n\t\t\t\tdir = UP;\n\t\t\t}else if(x+1 <= 4 && wall_s[y][x] == 1){\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tdir = RIGHT;\n\t\t\t}else if(y+1 <= 4 && wall_l[y][x] == 1){\n\t\t\t\ty++;\n\t\t\t\tprintf(\"D\");\n\t\t\t\tdir = DOWN;\n\t\t\t}else if(x-1 >= 0 && wall_s[y][x-1] == 1){\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tdir = LEFT;\n\t\t\t}\n\t\t}else if(dir == LEFT){\n\t\t\tif(y+1 <= 4 && wall_l[y][x] == 1){\n\t\t\t\ty++;\n\t\t\t   \tprintf(\"D\");\n\t\t\t\tdir = DOWN;\n\t\t\t}else if(x-1 >= 0 && wall_s[y][x-1] == 1){\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tdir = LEFT;\n\t\t\t}else if(y-1 >= 0 && wall_l[y-1][x] == 1){\n\t\t\t\ty--;\n\t\t\t\tprintf(\"U\");\n\t\t\t\tdir = UP;\n\t\t\t}else if(x+1 <= 4 && wall_s[y][x] == 1){\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tdir = RIGHT;\n\t\t\t}\n\t\t}else if(dir == UP){\n\t\t\tif(x-1 >= 0 && wall_s[y][x-1] == 1){\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tdir = LEFT;\n\t\t\t}else if(y-1 >= 0 && wall_l[y-1][x] == 1){\n\t\t\t\ty--;\n\t\t\t\tprintf(\"U\");\n\t\t\t\tdir = UP;\n\t\t\t}else if(x+1 <= 4 && wall_s[y][x] == 1){\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tdir = RIGHT;\n\t\t\t}else if(y+1 <= 4 && wall_l[y][x] == 1){\n\t\t\t\ty++;\n\t\t\t   \tprintf(\"D\");\n\t\t\t\tdir = DOWN;\n\t\t\t}\n\t\t}else if(dir == DOWN){\n\t\t\tif(x+1 <= 4 && wall_s[y][x] == 1){\n\t\t\t\tx++;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tdir = RIGHT;\n\t\t\t}else if(y+1 <= 4 && wall_l[y][x] == 1){\n\t\t\t\ty++;\n\t\t\t   \tprintf(\"D\");\n\t\t\t\tdir = DOWN;\n\t\t\t}else if(x-1 >= 0 && wall_s[y][x-1] == 1){\n\t\t\t\tx--;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tdir = LEFT;\n\t\t\t}else if(y-1 >= 0 && wall_l[y][y-1] == 1){\n\t\t\t\ty--;\n\t\t\t\tprintf(\"U\");\n\t\t\t\tdir = UP;\n\t\t\t}\n\t\t}\n\t\tif(x == 0 && y == 0) break;\n\t\t//printf(\"%d %d\\n\", x, y); fflush(stdout);\n\t}\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tgets(f[5]);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=f[5][j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y||x||f[0][0]==6&&p==3);\n\treturn!puts(\"\"); \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define r(i,n) for(int i=0;i<n;++i)\nint f[5][5];\nint main()\n{\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0, R = 1, D = 2, L = 3;\nchar dirchar[] = \"URDL\";\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0;\n  int dir = R, x = 0, y = 0, i;\n\n  while (true) {\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+1;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width; i++)\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n\n    if (scanf(\"%10000s\\n\", str) == -1)\n      break;\n\n    for (i=0; i<width; i++)\n      wall[i][height][D] = wall[i][height+1][U] = (str[i] == '1');\n\n    height++;\n  }\n\n  firsttime = true;\n  while (true) {\n    int nextdir;\n\n    if (!firsttime && x == 0 && y == 0)\n      break;\n\n    for (nextdir = lefthand(dir); !wall[x][y][nextdir]; nextdir = righthand(nextdir))\n      ;\n\n    putchar(dirchar[nextdir]);\n    x += dx[nextdir];\n    y += dy[nextdir];\n    dir = nextdir;\n    firsttime = false;\n  }\n\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstatic const int  vx[ ] = { 1, 0, -1, 0 }\n               ,  vy[ ] = { 0, 1, 0, -1 };\nstatic const char sn[ ] = { 'R', 'D', 'L', 'U' };\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  char hz[ 5 ][ 8 ]\n     , vc[ 4 ][ 8 ];\n  int x, y, s;\n  int i;\n\n  scanf ( \"%s\", hz[ 0 ] );\n  for ( i = 0; i < 4; ++i )\n  {\n    scanf ( \" %s %s\", vc[ i ], hz[ i + 1 ] );\n  }\n\n  putchar ( 'R' );\n  x = 1; y = 0; s = 0;\n  while ( !!( x | y ) )\n  {\n    //if ( s == 3 ) break ;\n    switch ( s )\n    {\n      case 0:\n        if      ( y > 0 && vc[ y - 1 ][ x ] == '1' ) s += 3;\n        else if ( x < 4 && hz[ y ][ x ]     == '1' ) ;\n        else if ( y < 4 && vc[ y ][ x ]     == '1' ) s += 1;\n        else                                         s += 2;\n        break ;\n      case 1:\n        if      ( x < 4 && hz[ y ][ x ]     == '1' ) s += 3;\n        else if ( y < 4 && vc[ y ][ x ]     == '1' ) ;\n        else if ( x > 0 && hz[ y ][ x - 1 ] == '1' ) s += 1;\n        else                                         s += 2;\n        break ;\n      case 2:\n        if      ( y < 4 && vc[ y ][ x ]     == '1' ) s += 3;\n        else if ( x > 0 && hz[ y ][ x - 1 ] == '1' ) ;\n        else if ( y > 0 && vc[ y - 1 ][ x ] == '1' ) s += 1;\n        else                                         s += 2;\n        break ;\n      case 3:\n        if      ( x > 0 && hz[ y ][ x - 1 ] == '1' ) s += 3;\n        else if ( y > 0 && vc[ y - 1 ][ x ] == '1' ) ;\n        else if ( x < 4 && hz[ y ][ x ]     == '1' ) s += 1;\n        else                                         s += 2;\n        break ;\n    }\n\n    s %= 4;\n    x += vx[ s ]; y += vy[ s ];\n    putchar ( sn[ s ] );\n  }\n  puts ( \"\" );\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nint main(void)\n{\n    char data[10][10];\n    int map[10][10][4];\n    char dir[4] = \"LRDU\";\n    int now;\n    int i, j;\n    memset(data, -1, sizeof(data));\n    memset(map, 0, sizeof(map));\n    for (i = 0; i < 9; i++){\n        scanf(\"%s\", data[i]);\n    }\n    for (i = 0; i < 9; i++){\n        for (j = 0; j < 5; j++){\n            if (i % 2 == 1){\n                if (data[i][j] == '1'){\n                    map[i / 2][j][3] = 1;\n                    map[i / 2 + 1][j][2] = 1;\n                }\n            }\n            else {\n                if (data[i][j] == '1'){\n                    map[i / 2][j][0] = 1;\n                    map[i / 2][j + 1][1] = 1;\n                }\n            }\n        }\n    }\n    i = j = 0;\n    now = 1;\n    do {\n        switch (now){\n          case 0:\n            if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else {\n                j++;\n                now = 1;\n            }\n            break;\n           \n          case 1:\n            if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else {\n                j--;\n                now = 0;\n            }\n            break;\n           \n          case 2:\n            if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else{\n                i--;\n                now = 3;\n            }\n            break;\n           \n          case 3:\n            if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else {\n                i++;\n                now = 2;\n            }\n            break;\n        }\n         \n        printf(\"%c\", dir[now]);\n    } while (i + j != 0);\n     \n    printf(\"n\");\n     \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nenum{up,right,down,left};\nchar res[]=\"URDL\";\nint g[5][5][4],i,j,t,d=right;\n\nvoid dbg()\n{\n\tfor(int i=0;i<9;i++,puts(\"\"))\n\t\tfor(int j=0;j<5;j++)\n\t\t{\n\t\t\tif(i%2==1&&g[i/2][j][down])\n\t\t\t\tputchar('|');\n\t\t\telse if(i%2==0&&g[i/2][j][right])\n\t\t\t\tputchar('_');\n\t\t\telse\n\t\t\t\tputchar(' ');\n\t\t}\n}\n\nvoid move(int dir)\n{\n\tputchar(res[dir]);\n\td=dir;\n\tswitch(dir)\n\t{\n\tcase up:i--;break;\n\tcase right:j++;break;\n\tcase down:i++;break;\n\tcase left:j--;break;\n\t}\n}\n\nint main()\n{\n\tfor(i=0;i<9;i++,getchar())\n\t{\n\t\tif(i%2==0)\n\t\t\tfor(j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][right]=g[i/2][j+1][left]=1;\n\t\t\t}\n\t\telse\n\t\t\tfor(j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][down]=g[i/2+1][j][up]=1;\n\t\t\t}\n\t}\n\tfor(i=0,j=0,t=0;!t;)\n\t{\n\t\tswitch(d)\n\t\t{\n\t\tcase up:if(g[i][j][left])\n\t\t\t\t\tmove(left);\n\t\t\t\telse if(g[i][j][up])\n\t\t\t\t\tmove(up);\n\t\t\t\telse\n\t\t\t\t\tmove(right);\n\t\t\t\tbreak;\n\t\tcase right:if(g[i][j][up])\n\t\t\t\t\tmove(up);\n\t\t\t\t   else if(g[i][j][right])\n\t\t\t\t\t   move(right);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(down);\n\t\t\t\tbreak;\n\t\tcase left: if(g[i][j][down])\n\t\t\t\t\t\tmove(down);\n\t\t\t\t   else if(g[i][j][left])\n\t\t\t\t\t   move(left);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(up);\n\t\t\t\tbreak;\n\t\tcase down: if(g[i][j][right])\n\t\t\t\t\t\tmove(right);\n\t\t\t\t   else if(g[i][j][down])\n\t\t\t\t\t   move(down);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(left);\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i==0&&j==0)\n\t\t\tputs(\"\"),t=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nchar s[13][7];\nint order[24] = {0, 1, 2, 0, 3, 2, 2, 1, 0, 2, 3, 0,\n                 3, 0, 1, 3, 2, 1, 1, 0, 3, 1, 2, 3};\nint nds[24] = {4, 0, 7, 6, 1, 5, 5, 2, 6, 7, 3, 4,\n               3, 4, 0, 1, 5, 2, 2, 6, 1, 0, 7, 3};\nint ds[8] = {1, 3, 1, 3, 0, 2, 0, 2};\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar ls[8] = {'R', 'L', 'R', 'L', 'U', 'D', 'U', 'D'};\nint i, j;\n\nbool doesWallExist(int x, int y, int d){\n    // printf(\"%d, %d, %d, %d, %d: \", x, y, d, x+(dx[d]-1)/2, 2*y+(dy[d]-1)/2);\n    if(s[2*y+dy[d]][x+(dx[d]-1)/2] == '1'){\n        //puts(\"o\");\n        return true;\n    }\n    //puts(\"x\");\n    return false;\n}\n\nint main(){\n    for(i=0;i<13;i++){\n        for(j=0;j<7;j++){\n            s[i][j] = '0';\n        }\n    }\n\n    for(i=2;i<=10;i++){\n        int ub = i%2?5:4;\n        for(j=0;j<ub;j++){\n            scanf(\"%c\", &s[i][j+1]);\n        }\n        scanf(\"%*c\");\n    }\n\n    int x = 1, y = 1, d = 0;\n    while(!(x == 1 && y == 1 && d != 0)){\n        // printf(\"%d, %d, %d\\n\", x, y, d);\n        putchar(ls[d]);\n        x += dx[ds[d]]; y += dy[ds[d]];\n\n        for(i=0;i<3;i++){\n            if(doesWallExist(x, y, order[d*3+i])){\n                d = nds[d*3+i];\n                break;\n            }\n        }\n    }\n    puts(\"\");\n\n    /* for(int i=0;i<13;i++){ */\n    /*     for(int j=0;j<7;j++){ */\n    /*         putchar(s[i][j]); */\n    /*     } */\n    /*     puts(\"\"); */\n    /* } */\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nenum{up,right,down,left};\nchar res[]=\"URDL\";\nint g[5][5][4],i,j,t,d=right;\n\nvoid move(int dir)\n{\n\tputchar(res[dir]);\n\td=dir;\n\tswitch(dir)\n\t{\n\tcase up:i--;break;\n\tcase right:j++;break;\n\tcase down:i++;break;\n\tcase left:j--;break;\n\t}\n}\n\nint main()\n{\n\tfor(i=0;i<9;i++,getchar())\n\t{\n\t\tif(i%2==0)\n\t\t\tfor(j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][right]=g[i/2][j+1][left]=1;\n\t\t\t}\n\t\telse\n\t\t\tfor(j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][down]=g[i/2+1][j][up]=1;\n\t\t\t}\n\t}\n\tfor(i=0,j=0,t=0;!t;)\n\t{\n\t\tif(g[i][j][d]==1)\n\t\t\tmove(d);\n\t\telse\n\t\t{\n\t\t\tswitch(d)\n\t\t\t{\n\t\t\tcase up:if(g[i][j][right])\n\t\t\t\t\t\tmove(right);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(left);\n\t\t\t\t\tbreak;\n\t\t\tcase right:if(g[i][j][up])\n\t\t\t\t\t\tmove(up);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(down);\n\t\t\t\t\tbreak;\n\t\t\tcase left: if(g[i][j][down])\n\t\t\t\t\t\t   move(down);\n\t\t\t\t\t   else\n\t\t\t\t\t\t   move(up);\n\t\t\t\t\tbreak;\n\t\t\tcase down: if(g[i][j][left])\n\t\t\t\t\t\t   move(left);\n\t\t\t\t\t   else\n\t\t\t\t\t\t   move(right);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i==0&&j==0)\n\t\t\tputs(\"\"),t=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\nint\nmain(int argc, char** argv)\n{\n\tchar maze[9][5];\n\tint x, y;\n\tint px, py;\n\tint mx, my;\n\tchar dir;\n\tint i;\n\n\tfor (i = 0; i < 9; ++i)\n\t\tscanf(\"%s\", &maze[i][0]);\n\n\tx = 0, y = 0;\n\tdir = 'R';\n\tprintf(\"%c\", dir);\n\n\tdo\n\t{\n\t\tpx = x + 1, py = y + 1;\n\t\tmx = x - 1, my = y - 1;\n\t\tif (dir == 'R')\n\t\t{\n\t\t\tif (px < 5 && my >= 0 && maze[my][px] == '1')\n\t\t\t{\n\t\t\t\tdir = 'U';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = px;\n\t\t\t\ty = my;\n\t\t\t}\n\n\t\t\telse if (px < 4 && maze[y][px] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = px;\n\t\t\t}\n\n\t\t\telse if (px < 5 && py < 9 && maze[py][px] == '1')\n\t\t\t{\n\t\t\t\tdir = 'D';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = px;\n\t\t\t\ty = py;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tdir = 'L';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'L')\n\t\t{\n\t\t\tif (py < 9 && maze[py][x] == '1')\n\t\t\t{\n\t\t\t\tdir = 'D';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty = py;\n\t\t\t}\n\n\t\t\telse if (mx >= 0 && maze[y][mx] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = mx;\n\t\t\t}\n\n\t\t\telse if (my >= 0 && maze[my][x] == '1')\n\t\t\t{\n\t\t\t\tdir = 'U';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty = my;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tdir = 'R';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'D')\n\t\t{\n\t\t\tif (py < 9 && maze[py][x] == '1')\n\t\t\t{\n\t\t\t\tdir = 'R';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty = py;\n\t\t\t}\n\n\t\t\telse if (y + 2 < 9 && maze[y + 2][x] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty += 2;\n\t\t\t}\n\n\t\t\telse if (mx >= 0 && py < 9 && maze[py][mx] == '1')\n\t\t\t{\n\t\t\t\tdir = 'L';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = mx;\n\t\t\t\ty = py;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tdir = 'U';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'U')\n\t\t{\n\t\t\tif (my >= 0 && mx >= 0 && maze[my][mx] == '1')\n\t\t\t{\n\t\t\t\tdir = 'L';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = mx;\n\t\t\t\ty = my;\n\t\t\t}\n\n\t\t\telse if (y - 2 >= 0 && maze[y - 2][x] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty -= 2;\n\t\t\t}\n\n\t\t\telse if (my >= 0 && maze[my][x] == '1')\n\t\t\t{\n\t\t\t\tdir = 'R';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty = my;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tdir = 'D';\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t}\n\t\t}\n\n\t} while (!(x == 0 && y == 0));\n\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "h#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0, i;\n  int dir = R, x = 1, y = 0;\n\n  while (true) {\n    height++;\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+2;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width-2; i++) {\n      wall[i+1][height][U] = wall[i+1][height-1][D] = (str[i] == '1');\n    }\n\n    if (scanf(\"%10000s\\n\", str) == -1) {\n      break;\n    }\n\n    for (i=0; i<width-1; i++) {\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n    }\n  }\n  height++;\n\n  firsttime = true;\n  while (true) {\n    if (!firsttime && \n\t((x == 1 && y == 0) ||\n\t (x == 0 && y == 1) ||\n\t (x == 1 && y == 1)) &&\n\twall[x][y][righthand(dir)]) {\n      putchar(dirchar[dir]);\n      break;\n    }\n\n    if (!wall[x][y][righthand(dir)]) {\n      dir = righthand(dir);\n      x += dx[dir];\n      y += dy[dir];\n    } else if (wall[x][y][dir]) {\n      putchar(dirchar[dir]);\n      dir = lefthand(dir);\n    } else {\n      x += dx[dir];\n      y += dy[dir];\n      putchar(dirchar[dir]);\n    }\n\n    firsttime = false;\n  }\n\n  puts(\"\");\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tint y=0,x=0,p=2;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[p];\n\t\ty+=dy[p];\n\t\t//x+=p?2-p:0;\n\t\t//y+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "char f[6][6],s[6],i,j,a,y,x,p,b;main(){for(;i<9;++i,b=!b){scanf(\"%s\",s);for(j=4+b;j--;)a=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;}do{while(!((f[y][x]>>(p=(p+1)%4))&1));x+=p?2-p:0;y+=3-p?p-1:0;putchar(\"DLUR\"[p=(p+2)%4]);}while(y|x|**f*p>9);puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],s[6],i,j,a,y,x,p,b;int main(){for(;i<9;++i,b=!b){scanf(\"%s\",s);for(j=4+b;j--;)a=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;}do{while(!((f[y][x]>>(p=(p+1)%4))&1));putchar(\"URDL\"[p]);x+=p?2-p:0;y+=3-p?p-1:0;p=(p+2)%4;}while(y|x|**f==6&p==3);return!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define RIGHT 0\n#define DOWN 1\n#define LEFT 2\n#define UP 3\n\nint main(void){\n  char xy[9][6];\n  int i, dir = RIGHT, px = 0, py = 0;\n\n  for(i = 0; i < 9; i++){\n    scanf(\"%s\", xy[i]);\n  }\n\n  do{\n    switch(dir){\n    case RIGHT:\n      if(py > 0 && xy[py*2-1][px] == '1'){\n\tdir = UP;\n      }else if(px < 4 && xy[py*2][px] == '1'){\n\tdir = RIGHT;\n      }else if(py < 4 && xy[py*2+1][px] == '1'){\n\tdir = DOWN;\n      }else{\n\tdir = LEFT;\n      }\n      break;\n    case DOWN:\n      if(px < 4 && xy[py*2][px] == '1'){\n\tdir = RIGHT;\n      }else if(py < 4 && xy[py*2+1][px] == '1'){\n\tdir = DOWN;\n      }else if(px > 0 && xy[py*2][px-1] == '1'){\n\tdir = LEFT;\n      }else{\n\tdir = UP;\n      }\n      break;\n    case LEFT:\n      if(py < 4 && xy[py*2+1][px] == '1'){\n\tdir = DOWN;\n      }else if(px > 0 && xy[py*2][px-1] == '1'){\n\tdir = LEFT;\n      }else if(py > 0 && xy[py*2-1][px] == '1'){\n\tdir = UP;\n      }else{\n\tdir = RIGHT;\n      }\n      break;\n    case UP:\n      if(px > 0 && xy[py*2][px-1] == '1'){\n\tdir = LEFT;\n      }else if(py > 0 && xy[py*2-1][px] == '1'){\n\tdir = UP;\n      }else if(px < 4 && xy[py*2][px] == '1'){\n\tdir = RIGHT;\n      }else{\n\tdir = DOWN;\n      }\n      break;\n    }\n    \n    switch(dir){\n    case RIGHT:\n      px++;\n      printf(\"R\");\n      break;\n    case DOWN:\n      py++;\n      printf(\"D\");\n      break;\n    case LEFT:\n      px--;\n      printf(\"L\");\n      break;\n    case UP:\n      py--;\n      printf(\"U\");\n      break;\n    }\n  }while(!(px == 0 && py == 0));\n\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef enum {\n\tRIGHT,\n\tDOWN,\n\tLEFT,\n\tUP,\n\tUNDEFINED\n} Direction;\n\nvoid make_destination(\n\t\tint wx[5][4], int wy[4][5], Direction data[5][5][4]) {\n\tint *x1, *y1, *y0, i, j;\n\tDirection *d;\n\n\tx1 = wx[0];\n\ty1 = wy[0];\n\n\td = data[0][0];\n\td[0] = x1[0] ? RIGHT : UNDEFINED;\n\td[1] = y1[0] ? DOWN : UNDEFINED;\n\td[2] = d[3] = UNDEFINED;\n\tfor (i = 0; i < 3; i++) {\n\t\td = data[0][i+1];\n\t\td[0] = x1[i+1] ? RIGHT : UNDEFINED;\n\t\td[1] = y1[i+1] ? DOWN : UNDEFINED;\n\t\td[2] = x1[i] ? LEFT : UNDEFINED;\n\t\td[3] = UNDEFINED;\n\t}\n\td = data[0][4];\n\td[0] = d[3] = UNDEFINED;\n\td[1] = y1[4] ? DOWN : UNDEFINED;\n\td[2] = x1[3] ? LEFT : UNDEFINED;\n\n\tfor (j = 1; j < 4; j++) {\n\t\ty0 = y1;\n\t\tx1 = wx[j];\n\t\ty1 = wy[j];\n\n\t\td = data[j][0];\n\t\td[0] = x1[0] ? RIGHT : UNDEFINED;\n\t\td[1] = y1[0] ? DOWN : UNDEFINED;\n\t\td[2] = UNDEFINED;\n\t\td[3] = y0[0] ? UP : UNDEFINED;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\td = data[j][i+1];\n\t\t\td[0] = x1[i+1] ? RIGHT : UNDEFINED;\n\t\t\td[1] = y1[i+1] ? DOWN : UNDEFINED;\n\t\t\td[2] = x1[i] ? 2: UNDEFINED;\n\t\t\td[3] = y0[i+1] ? UP : UNDEFINED;\n\t\t}\n\t\td = data[j][4];\n\t\td[0] = UNDEFINED;\n\t\td[1] = y1[4] ? DOWN : UNDEFINED;\n\t\td[2] = x1[3] ? LEFT : UNDEFINED;\n\t\td[3] = y0[4] ? UP : UNDEFINED;\n\t}\n\n\ty0 = y1;\n\tx1 = wx[4];\n\n\td = data[4][0];\n\td[0] = x1[0] ? RIGHT : UNDEFINED;\n\td[1] = d[2] = UNDEFINED;\n\td[3] = y0[0] ? UP : UNDEFINED;\n\tfor (i = 0; i < 3; i++) {\n\t\td = data[4][i+1];\n\t\td[0] = x1[i+1] ? RIGHT : UNDEFINED;\n\t\td[1] = UNDEFINED;\n\t\td[2] = x1[i] ? LEFT : UNDEFINED;\n\t\td[3] = y0[i+1] ? UP : UNDEFINED;\n\t}\n\td = data[4][4];\n\td[0] = d[1] = UNDEFINED;\n\td[2] = x1[3] ? LEFT : UNDEFINED;\n\td[3] = y0[4] ? UP : UNDEFINED;\n}\n\nvoid walk(Direction data[5][5][4]) {\n\tint i, x = 1, y = 0;\n\tDirection *ways, move = RIGHT;\n\n\tint destination[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\tint *dest;\n\n\tDirection permutation[4][4] = {\n\t\t{UP, RIGHT, DOWN, LEFT}, {RIGHT, DOWN, LEFT, UP},\n\t\t{DOWN, LEFT, UP, RIGHT}, {LEFT, UP, RIGHT, DOWN}\n\t};\n\tDirection *per;\n\n\tputchar('R');\n\n\twhile (x != 0 || y != 0) {\n\t\tways = data[y][x];\n\t\tper = permutation[move];\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tmove = ways[per[i]];\n\t\t\tif (move == UNDEFINED)\n\t\t\t\tcontinue;\n\t\t\tdest = destination[move];\n\t\t\tbreak;\n\t\t}\n\t\tx += dest[0];\n\t\ty += dest[1];\n\t\tputchar(\"RDLU\"[move]);\n\t}\n\tputchar('\\n');\n}\n\nint main(void) {\n\tchar in[10];\n\tint i, j, wx[5][4], wy[4][5];\n\tDirection data[5][5][4];\n\n\tfor (j = 0; j < 4; j++) {\n\t\tscanf(\"%s \", in);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\twx[j][i] = in[i] - '0';\n\t\t}\n\t\tscanf(\"%s \", in);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\twy[j][i] = in[i] - '0';\n\t\t}\n\t}\n\tscanf(\"%s \", in);\n\tfor (i = 0; i < 4; i++) {\n\t\twx[4][i] = in[i] - '0';\n\t}\n\n\tmake_destination(wx, wy, data);\n\twalk(data);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\nint main(void) {\n\tconst char DIR[4] = {'L', 'U', 'R', 'D'};\n\tconst int MOVE[4][2] = {{0,-1}, {-1,0}, {0,1}, {1,0}};\n\tint i, j, n;\n\tint r, c, s, d;\n\tchar buff[128][128];\n\tint elem[128][128][4];\n\t\n\tmemset(buff, 0x00, sizeof(elem));\n\tmemset(elem, 0x00, sizeof(elem));\n\n\tn = 1;\n\twhile(scanf(\"%s\\n\", &buff[n][1]) == 1) n++;\n\t\n\t// 入力値を格子に変換\n\tfor(i=1,s=strlen(&buff[2][1]);i<=n/2;i++) {\n\t\tfor(j=1;j<=s;j++) {\n\t\t\telem[i-1][j-1][0] = buff[i*2-1][j-1]=='1';\t// 左\n\t\t\telem[i-1][j-1][1] = buff[i*2-2][j]=='1';\t// 上\n\t\t\telem[i-1][j-1][2] = buff[i*2-1][j]=='1';\t// 右\n\t\t\telem[i-1][j-1][3] = buff[i*2][j]=='1';\t\t// 下\n//\t\t\tprintf(\"%d %d %d %d\\n\", elem[i-1][j-1][0], elem[i-1][j-1][1], elem[i-1][j-1][2], elem[i-1][j-1][3]);\n\t\t}\n\t}\n\t\n\tr = c = 0;\n\td = 2;\n\tdo {\n\t\tif(elem[r][c][(d+3)%4]==1) {\t// 左\n\t\t\td = (d+3) % 4;\n\t\t} else if(elem[r][c][d]==1) {\t// 正面\n\t\t\t;\n\t\t} else if(elem[r][c][(d+1)%4]==1) {\t// 右\n\t\t\td = (d+1) % 4;\n\t\t} else if(elem[r][c][(d+2)%4]==1) {\t// 背後\n\t\t\td = (d+2) % 4;\n\t\t}\n\t\tr += MOVE[d][0];\n\t\tc += MOVE[d][1];\n\t\tprintf(\"%c\", DIR[d]);\n\t} while(r!=0 || c!=0);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tint y=0,x=0,p=2;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[p];\n\t\ty+=dy[p];\n\t\treturn 0;\n\t\t//x+=p?2-p:0;\n\t\t//y+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define r(i,n) for(int i=0;i<n;++i)\nint f[5][5];\nint main()\n{\n\tr(i,9){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tif(i%2){\n\t\t\tr(j,5){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<2;\n\t\t\t\tf[i/2+1][j]|=a;\n\t\t\t}\n\t\t}else{\n\t\t\tr(j,4){\n\t\t\t\tint a=s[j]-'0';\n\t\t\t\tf[i/2][j]|=a<<1;\n\t\t\t\tf[i/2][j+1]|=a<<3;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],i,j,a,y,x,p;int main(){for(;i<9;++i){scanf(\"%s\",f[5]);for(j=0;j<4+i%2;++j){a=f[5][j]-48;f[i/2][j]|=a<<(1+i%2);f[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;}}do{while(!((f[y][x]>>(p=(p+1)%4))&1));putchar(\"URDL\"[p]);x+=p?2-p:0;y+=p==3?0:p-1;p=(p+2)%4;}while(y||x||f[0][0]==6&&p==3);return!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n\tint a[4][5], b[4][5];\n\tint x, y, dir, i, j;\n\t\n\t// get the wall data from input\n\t// 'a' is the data about the vertical side wall\n\t// 'b' is the data about the side wall\n\tfor(i=0; i<4+5; i++) {\n\t\tif ((i%2)==0) {\n\t\t\tfor(j=0; j<4; j++) {\n\t\t\t\tscanf(\"%1d\", &a[j][i/2]);\n\t\t\t}\n\t\t}else {\n\t\t\tfor(j=0; j<5; j++) {\n\t\t\t\tscanf(\"%1d\", &b[(i-1)/2][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// set first position\n\tx = 1;\n\ty = 0;\n\tdir = 0;\n\n\t// main loop\n\twhile(1) {\n\t\t\n\t\tswitch(dir) {\n\t\tcase 0: //right\n\t\t\t// if there isnt the right-hand wall, turn right\n\t\t\tif (a[x-1][y]==0) {\n\t\t\t\tdir=1;\n\t\t\t\ty+=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// prevention of buffer-overflow (y>=1)\n\t\t\tif (y==0) x+=1;\n\t\t\telse if (b[y-1][x]==1){\n\t\t\t\t// if there is the front wall, turn left\n\t\t\t\tdir=3;\n\t\t\t\tprintf(\"R\");\n\t\t\t\tbreak;\n\t\t\t}else x+=1;\n\t\t\tprintf(\"R\");\n\t\t\tif (x==5) {\n\t\t\t\t// if x is 5, turn right\n\t\t\t\tdir=1;\n\t\t\t\ty+=1;\n\t\t\t}else if (a[x-1][y]==0) {\n\t\t\t\t// if there isnt the right-hand wall, turn right\n\t\t\t\tdir=1;\n\t\t\t\ty+=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: //down\n\t\t\tif (b[y-1][x-1]==0) {\n\t\t\t\tdir=2;\n\t\t\t\tx-=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (x==5) y+=1;\n\t\t\telse if (a[x-1][y]==1) {\n\t\t\t\tdir=0;\n\t\t\t\tprintf(\"D\");\n\t\t\t\tbreak;\n\t\t\t}else y+=1;\n\t\t\tprintf(\"D\");\n\t\t\tif (y==5) {\n\t\t\t\tdir=2;\n\t\t\t\tx-=1;\n\t\t\t}else if (b[y-1][x-1]==0) {\n\t\t\t\tdir=2;\n\t\t\t\tx-=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: //left\n\t\t\tif (a[x-1][y-1]==0) {\n\t\t\t\tdir=3;\n\t\t\t\ty-=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (y==5) x-=1;\n\t\t\telse if (b[y-1][x-1]==1) {\n\t\t\t\tdir=1;\n\t\t\t\tprintf(\"L\");\n\t\t\t\tbreak;\n\t\t\t}else x-=1;\n\t\t\tprintf(\"L\");\n\t\t\tif (x==0) {\n\t\t\t\tdir=3;\n\t\t\t\ty-=1;\n\t\t\t}else if (a[x-1][y-1]==0) {\n\t\t\t\tdir=3;\n\t\t\t\ty-=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: //up\n\t\t\tif (b[y-1][x]==0) {\n\t\t\t\tdir=0;\n\t\t\t\tx+=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (x==0) y-=1;\n\t\t\telse if (a[x-1][y-1]==1) {\n\t\t\t\tdir=2;\n\t\t\t\tprintf(\"U\");\n\t\t\t\tbreak;\n\t\t\t}else y-=1;\n\t\t\tprintf(\"U\");\n\t\t\tif (y==0) {\n\t\t\t\tdir=0;\n\t\t\t\tx+=1;\n\t\t\t}else if (b[y-1][x]==0) {\n\t\t\t\tdir=0;\n\t\t\t\tx+=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// you are at goal?\n\t\tif ( (x==1)&&(y==0) ) break;\n\t\tif ( (x==0)&&(y==0) ) break;\n\t\tif ( (x==0)&&(y==1) ) break;\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum {\n\tLEFT,\n\tRIGHT,\n\tUP,\n\tDOWN\n};\n\nint iskabe(char[9][6],int,int,int);\nint getleft(int);\nint getright(int);\nvoid move(int*,int*,int);\nvoid printdir(int);\n\nint main(void) {\n\tchar kabe[9][6];\n\tint x,y;\n\tint direction;\n\tint i;\n\tfor(i=0;i<9;i++)scanf(\"%s\",kabe[i]);\n\tx=0;y=0;direction=RIGHT;\n\tmove(&x,&y,direction);\n\twhile(x!=0 || y!=0) {\n\t\tif(iskabe(kabe,x,y,getleft(direction)))\n\t\t\tdirection=getleft(direction);\n\t\telse if(iskabe(kabe,x,y,direction));\n\t\telse if(iskabe(kabe,x,y,getright(direction)))\n\t\t\tdirection=getright(direction);\n\t\telse direction=getright(getright(direction));\n\t\tmove(&x,&y,direction);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nint iskabe(char kabe[9][6],int x,int y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\tif(x<=0)return 0;\n\t\t\tif(kabe[y*2][x-1]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tif(x>4)return 0;\n\t\t\tif(kabe[y*2][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tif(y<=0)return 0;\n\t\t\tif(kabe[y*2-1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tif(y>4)return 0;\n\t\t\tif(kabe[y*2+1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint getleft(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return DOWN;break;\n\t\tcase RIGHT:return UP;break;\n\t\tcase UP:return LEFT;break;\n\t\tcase DOWN:return RIGHT;break;\n\t}\n\treturn 0;\n}\n\nint getright(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return UP;break;\n\t\tcase RIGHT:return DOWN;break;\n\t\tcase UP:return RIGHT;break;\n\t\tcase DOWN:return LEFT;break;\n\t}\n\treturn 0;\n}\n\nvoid move(int* x,int* y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\t(*x)--;\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\t(*x)++;\n\t\t\tprintf(\"R\");\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\t(*y)--;\n\t\t\tprintf(\"U\");\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\t(*y)++;\n\t\t\tprintf(\"D\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z,k){\n\tmemset(s,11,sizeof(s));\n\tx=y=5;\n\tfor(j=1;j<=2*y+1;j++)for(i=1;i<=2*x+1;i++)s[i][j]=0;\n\tfor(j=2;j<=2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:3;i<2*x+1;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=4,y=2;x!=2||y!=2;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tx=!puts(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n\tint u;\n\tint r;\n\tint d;\n\tint l;\n} cell;\n\nint search_d(cell *c, int d)\n{\n\tint *p = (int *)c;\n\tint i, nd;\n\n\tnd = (d + 2) % 4;\n\tfor (i = 0; i < 3; i++){\n\t\tnd = (nd + 1) % 4;\n\t\tif (p[nd]) return (nd);\n\t}\n\treturn (d);\n}\n\nint main(void)\n{\n\tcell map[8][8];\n\tint i, j;\n\tint d;\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {-1, 0, 1, 0};\n\tint nx, ny;\n\n\tmemset(map, 0, sizeof(map)); \n\tfor (i = 0; i < 5; i++){\n\t\tchar s[8];\n\t\tscanf(\"%s\", s);\n\t\tfor (j = 0; j < 4; j++){\n\t\t\tmap[i][j].r = map[i][j + 1].l = s[j] - '0';\n\t\t}\n\t\tif (i == 4) break;\n\t\tscanf(\"%s\", s);\n\t\tfor (j = 0; j < 5; j++){\n\t\t\tmap[i][j].d = map[i + 1][j].u = s[j] - '0';\n\t\t}\n\t}\n\n\td = 1;\n\tnx = ny = 0;\n\tdo {\n\t\td = search_d(&map[ny][nx], d);\n\t\tny += dy[d];\n\t\tnx += dx[d];\n\t\tprintf(\"%c\", \"URDL\"[d]);\n\t} while (nx + ny);\n\tputs(\"\");\n\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[11][11];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tx=y=5;\n\tfor(j=0;j<2*y;j++)for(i=0;i<2*x;i++)s[i][j]=0;\n\tfor(j=1;j<2*y;getchar(),j++)for(i=(j&1)?2:1;i<2*x;i+=2)s[i][j]=getchar()-'0';\n\tputchar('R');\n\tfor(z=0,x=3,y=1;x!=1||y!=1;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define RIGHT 0\n#define LEFT 1\n#define UP 2\n#define DOWN 3\n\n#define OK 1\n#define NG 0\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side);\n\n\nint main(){\n\n\tint i,j,map[11][7]={0},x,y,sit,side;\n\n\tfor(i=1;i<9;i+=2){\n\t\tif(scanf(\"%1d%1d%1d%1d%1d%1d%1d%1d%1d\",&map[i][1],&map[i][2],&map[i][3],&map[i][4],&map[i+1][1],&map[i+1][2],&map[i+1][3],&map[i+1][4],&map[i+1][5])==EOF) break;\n\t}\n\tscanf(\"%1d%1d%1d%1d\",&map[9][1],&map[9][2],&map[9][3],&map[9][4]);\n\tx=0;\n\ty=0;\n\tx++;\n\n\tsit=RIGHT;\n\tside=UP;\n\tprintf(\"R\");\n\twhile(x!=0 || y!=0){\n\t\tswitch(sit){\n\t\t\tcase RIGHT:\n\t\t\t\tif(side==UP){\n\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=LEFT;\n\t\t\t\t\t\t\t\tside=DOWN;\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(side==DOWN){\n\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=RIGHT;\n\t\t\t\t\t\t\t\tside=UP;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(side==LEFT){\n\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=DOWN;\n\t\t\t\t\t\t\t\tside=RIGHT;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(side==RIGHT){\n\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=UP;\n\t\t\t\t\t\t\t\tside=LEFT;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)++;\n\t\t*side=UP;\n\t\t*sit=RIGHT;\n\t\tprintf(\"R\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\t\n}\n\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)]==1){\n\t\t(*x)--;\n\t\t*side=DOWN;\n\t\t*sit=LEFT;\n\t\tprintf(\"L\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2][(*x)+1]==1){\n\t\t(*y)--;\n\t\t*side=LEFT;\n\t\t*sit=UP;\n\t\tprintf(\"U\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+2][(*x)+1]==1){\n\t\t(*y)++;\n\t\t*side=RIGHT;\n\t\t*sit=DOWN;\n\t\tprintf(\"D\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool wall[10000][10000][4];\nchar str[10001];\n\nconst int U = 0;\nconst int R = 1;\nconst int D = 2;\nconst int L = 3;\n\nchar dirchar[] = \"URDL\" ;\nint righthand(int x) {return (x+1)%4;}\nint lefthand(int x) {return (x+3)%4;}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n  bool firsttime = true;\n  int width, height=0;\n  int dir = R, x = 0, y = 0, i,j,k;\n\n  while (true) {\n    scanf(\"%9999s\\n\", str);\n\n    if (firsttime) {\n      width = strlen(str)+1;\n      firsttime = false;\n    }\n\n    for (i = 0; i<width; i++)\n      wall[i][height][R] = wall[i+1][height][L] = (str[i] == '1');\n\n    if (scanf(\"%10000s\\n\", str) == -1)\n      break;\n\n    for (i=0; i<width; i++)\n      wall[i][height][D] = wall[i][height+1][U] = (str[i] == '1');\n\n    height++;\n  }\n\n  firsttime = true;\n  while (true) {\n    int nextdir;\n\n    if (!firsttime && x == 0 && y == 0)\n      break;\n\n    for (nextdir = lefthand(dir); !wall[x][y][nextdir]; nextdir = righthand(nextdir))\n      ;\n\n    //    printf(\"\\n(%d, %d) %c (%d, %d, %d, %d) \", x, y, dirchar[dir], wall[x][y][0], wall[x][y][1], wall[x][y][2], wall[x][y][3]);\n\n    putchar(dirchar[nextdir]);\n    x += dx[nextdir];\n    y += dy[nextdir];\n    dir = nextdir;\n    firsttime = false;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int i,j;\n  int m[6][7],n[7][6],x=1+1,y=0+1,xs=1,ys=0;\n  char s[6];\n  memset(m,0,sizeof(m));\n  memset(n,0,sizeof(n));\n  for(i=0+1;i<4+1;i++){\n    scanf(\"%s\",s);\n    for(j=0+1;j<4+1;j++)\n      m[j][i]=s[j-1]-'0';\n    scanf(\"%s\",s);\n    for(j=0+1;j<5+1;j++)\n      n[j][i]=s[j-1]-'0';\n  }\n  scanf(\"%s\",s);\n  for(j=0+1;j<4+1;j++)\n    m[j][i]=s[j-1]-'0';\n  printf(\"R\");\n  for(i=0;x!=1||y!=1;i++){\n    if(i==100)\n      break;\n    if(xs==1){\n      if(n[x][y-1]){\n\txs=0;\n\tys=-1;\n      }else if(m[x][y]){\n      }else if(n[x][y]){\n\txs=0;\n\tys=1;\n      }\n    }else if(xs==-1){\n      if(n[x][y]){\n\txs=0;\n\tys=1;\n      }else if(m[x-1][y]){\n      }else if(n[x][y-1]){\n\txs=0;\n\tys=-1;\n      }\n    }else if(ys==1){\n      if(m[x][y]){\n\txs=1;\n\tys=0;\n      }else if(n[x][y]){\n      }else if(m[x-1][y]){\n\txs=-1;\n\tys=0;\n      }\n    }else if(ys==-1){\n      if(m[x-1][y]){\n\txs=-1;\n\tys=0;\n      }else if(n[x][y-1]){\n      }else if(m[x][y]){\n\txs=1;\n\tys=0;\n      }\n    }\n    x+=xs;\n    y+=ys;\n    if(xs==1)\n      printf(\"R\");\n    if(xs==-1)\n      printf(\"L\");\n    if(ys==1)\n      printf(\"D\");\n    if(ys==-1)\n      printf(\"U\");\n  }\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n\tchar stage[10][10]={};\n\tchar state[2]={};\n\tint x=0,y=0;\n\tint i,j;\n\t\n\t\n\tfor(i=0;i<9;i++)scanf(\"%s\",stage[i]);\n\tstate[0]='R';\n\twhile(1)\n\t{\n\t\tif((x==0 && y==0 && state[0]!='R') || (x==0 && y==1 && state[0]=='U'))\n\t\t{\n\t\t\tif(state[0]=='U')\n\t\t\t\tprintf(\"U\\n\");\n\t\t\telse printf(\"L\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(state[0]=='R')\n\t\t{\n\t\t\tif(stage[y-1][x+1]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y][x+1]=='1' && x<=3)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+1][x+1]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\tprintf(\"R\");\n\t\t}\n\t\telse if(state[0]=='D')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+2][x]=='1' && y<=6)\n\t\t\t{\n\t\t\t\ty+=2;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y+1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\tprintf(\"D\");\n\t\t}\n\t\telse if(state[0]=='L')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\tprintf(\"L\");\n\t\t}\n\t\telse if(state[0]=='U')\n\t\t{\n\t\t\tif(stage[y-1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-2][x]=='1' && y>=2)\n\t\t\t{\n\t\t\t\ty-=2;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && x<=3)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define RIGHT 0\n#define LEFT 1\n#define UP 2\n#define DOWN 3\n\n#define OK 1\n#define NG 0\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side);\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side);\n\n\nint main(){\n\n\tint i,j,map[11][7]={0},x,y,sit,side;\n\n\tfor(i=1;i<9;i+=2){\n\t\tif(scanf(\"%1d%1d%1d%1d%1d%1d%1d%1d%1d\",&map[i][1],&map[i][2],&map[i][3],&map[i][4],&map[i+1][1],&map[i+1][2],&map[i+1][3],&map[i+1][4],&map[i+1][4])==EOF) break;\n\t}\n\tscanf(\"%1d%1d%1d%1d\",&map[9][1],&map[9][2],&map[9][3],&map[9][4]);\n\tx=0;\n\ty=0;\n\tx++;\n\n\tsit=RIGHT;\n\tside=UP;\n\twhile(x==0 && y==0){\n\t\tswitch(sit){\n\t\t\tcase RIGHT:\n\t\t\t\tif(side==UP){\n\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=LEFT;\n\t\t\t\t\t\t\t\tside=DOWN;\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LEFT:\n\t\t\t\tif(side==DOWN){\n\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=RIGHT;\n\t\t\t\t\t\t\t\tside=UP;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UP:\n\t\t\t\tif(side==LEFT){\n\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveU(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=DOWN;\n\t\t\t\t\t\t\t\tside=RIGHT;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWN:\n\t\t\t\tif(side==RIGHT){\n\t\t\t\t\tif(moveR(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\tif(moveD(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\tif(moveL(&x,&y,map,&sit,&side)==NG){\n\t\t\t\t\t\t\t\tsit=UP;\n\t\t\t\t\t\t\t\tside=LEFT;\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\nint moveR(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)++;\n\t\t*side=UP;\n\t\t*sit=RIGHT;\n\t\tprintf(\"R\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\t\n}\n\nint moveL(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*x)--;\n\t\t*side=DOWN;\n\t\t*sit=LEFT;\n\t\tprintf(\"L\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveU(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)++;\n\t\t*side=LEFT;\n\t\t*sit=UP;\n\t\tprintf(\"U\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}\n\nint moveD(int *x,int *y,int map[11][7],int *sit,int *side){\n\n\tif(map[(*y)*2+1][(*x)+1]==1){\n\t\t(*y)--;\n\t\t*side=RIGHT;\n\t\t*sit=DOWN;\n\t\tprintf(\"D\");\n\t\treturn OK;\n\t}\n\telse{\n\t\treturn NG;\n\t}\n\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum {\n\tLEFT,\n\tRIGHT,\n\tUP,\n\tDOWN\n};\n\nint iskabe(char[9][6],int,int,int);\nint getleft(int);\nint getright(int);\nvoid move(int*,int*,int);\nvoid printdir(int);\n\nint main(void) {\n\tchar kabe[9][6];\n\tint x,y;\n\tint direction;\n\tint i;\n\tfor(i=0;i<9;i++)scanf(\"%s\",kabe[i]);\n\tx=0;y=0;direction=RIGHT;\n\tmove(&x,&y,direction);\n\twhile(x!=0 || y!=0) {\n\t\tif(iskabe(kabe,x,y,getleft(direction)))\n\t\t\tdirection=getleft(direction);\n\t\telse if(iskabe(kabe,x,y,direction));\n\t\telse if(iskabe(kabe,x,y,getright(direction)))\n\t\t\tdirection=getright(direction);\n\t\tmove(&x,&y,direction);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nint iskabe(char kabe[9][6],int x,int y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\tif(x<=0)return 0;\n\t\t\tif(kabe[y*2][x-1]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tif(x>4)return 0;\n\t\t\tif(kabe[y*2][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tif(y<=0)return 0;\n\t\t\tif(kabe[y*2-1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tif(y>4)return 0;\n\t\t\tif(kabe[y*2+1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint getleft(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return DOWN;break;\n\t\tcase RIGHT:return UP;break;\n\t\tcase UP:return LEFT;break;\n\t\tcase DOWN:return RIGHT;break;\n\t}\n\treturn 0;\n}\n\nint getright(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return UP;break;\n\t\tcase RIGHT:return DOWN;break;\n\t\tcase UP:return RIGHT;break;\n\t\tcase DOWN:return LEFT;break;\n\t}\n\treturn 0;\n}\n\nvoid move(int* x,int* y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\t(*x)--;\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\t(*x)++;\n\t\t\tprintf(\"R\");\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\t(*y)--;\n\t\t\tprintf(\"U\");\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\t(*y)++;\n\t\t\tprintf(\"D\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\t//printf(\"ok\\n\");\n\tx++;\n\tsl=1;\n\t//printf(\"s=%d\",s);\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n      // printf(\"tate74=%d\\n\",tate[7][4]);\n\n      break;\n\n    case 2:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n      //printf(\"%d %d\\n\",x+1,y+2);\n      //printf(\"tate74=%d\\n\",tate[7][4]);\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n      //printf(\"x=%d:y=%d\\n\",x,y);\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      // printf(\"x=%d:y=%d\\n\",x,y);\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    //printf(\"sl=%d\\n\",sl);\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n    //printf(\"tate74=%d\\n\",tate[7][4]);\n    //printf(\"\\n\");\n   \n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nenum { R, U, L, D };\n\nint map[5][5][4] = { 0 };\nint x = 0, y = 0, dir = R;\n\nvoid scan();\nvoid print();\nvoid calc();\nint calcDir();\n\nint main() {\n  scan();\n  //print();\n  calc();\n  return 0;\n}\n\nint calcDir() {\n  int i;\n  if (map[y][x][dir] && !map[y][x][(dir + 5) % 4]) return dir;\n  if (map[y][x][(dir + 3) % 4]\n      && !map[y][x][dir]\n      && !map[y][x][(dir + 5) % 4]) return (dir + 3) % 4;\n  if (map[y][x][(dir + 5) % 4]) return (dir + 5) % 4;\n  return (dir + 6) % 4;\n  /*\n  for (i = 0; i < 4; i++) {\n    //printf(\"%d, %d, %d\\n\", x, y, (dir+5-i)%4);\n    if (map[y][x][(dir + 4 - i) % 4]) {\n      if (map[y][x][(dir + 6 - i) % 4]) continue;\n      return (dir + 4 - i) % 4;\n    }\n  }\n  return -1;\n  */\n}\n\nvoid calc() {\n  char c;\n  do {\n    dir = calcDir();\n    switch (dir) {\n      case R:\n\tc = 'R';\n\tx++;\n\tbreak;\n      case U:\n\tc = 'U';\n\ty--;\n\tbreak;\n      case L:\n\tc = 'L';\n\tx--;\n\tbreak;\n      case D:\n\tc = 'D';\n\ty++;\n\tbreak;\n      default:\n\tputs(\"error\");\n\texit(1);\n\tbreak;\n    }\n    putchar(c);\n  } while (x != 0 || y != 0);\n  puts(\"\");\n}\n\nvoid scanEven(int n) {\n  int i = 0;\n  for (i = 0; i < 4; i++) {\n    int w = (getchar() == '1') ? 1 : 0;\n    map[n][i][R] = w;\n    map[n][i+1][L] = w;\n  }\n  getchar();\n}\n\nvoid scanOd(int n) {\n  int i = 0;\n  for (i = 0; i < 5; i++) {\n    int w = (getchar() == '1') ? 1 : 0;\n    map[n][i][D] = w;\n    map[n+1][i][U] = w;\n  }\n  getchar();\n}\n\nvoid scan() {\n  int i = 0;\n  for (i = 0; i < 4; i++) {\n       scanEven(i);\n       scanOd(i);\n  }\n  scanEven(i);\n}\n\nvoid print() {\n  int i, j, k;\n  for (i = 0; i < 5; i++) {\n    for (j = 0; j < 5; j++) {\n      for (k = 0; k < 4; k++) {\n\tprintf(\"%c%d\", k?',':'{', map[i][j][k]);\n      }\n      printf(\"} \");\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n \n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdarg.h>\n#include<malloc.h>\n#include<limits.h>\n\nint move(int *, int *, int *, int wall[12][8]);\n\nint main()\n{\n\tint i, j, x, y, d;\n\tchar buf[9][8]={0};\n\tint wall[12][8]={0};\n\n\tfor(i=0; i<9; i++)\n\t\tscanf(\"%s\", buf[i]);\n\n\tfor(i=2; i<=10; i++){\n\t\tfor(j=1; j<=5; j++){\n\t\t\tif(buf[i-2][j-1] != 0)\n\t\t\t\twall[i][j] = buf[i-2][j-1] - '0';\n\t\t}\n\t}\n\n\tprintf(\"R\");\n\tx = 2, y = 1, d = 2;\t//up:0 left:1 right:2 down:3\n\n\twhile(move(&x, &y, &d, wall));\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\nint move(int *x, int *y, int *d, int wall[12][8])\n{\n\n\tif(*x == 1 && *y == 1)\n\t\treturn 0;\n\n\tif(*d == 0){\n\t\tif(wall[*y*2][*x-1] == 1){\n\t\t\tprintf(\"L\");\n\t\t\t(*x)--, *d = 1;\n\t\t}else if(wall[*y*2-1][*x] == 1){\n\t\t\tprintf(\"U\");\n\t\t\t(*y)--, *d = 0;\n\t\t}else if(wall[*y*2][*x] == 1){\n\t\t\tprintf(\"R\");\n\t\t\t(*x)++, *d = 2;\n\t\t}else{\n\t\t\tprintf(\"D\");\n\t\t\t(*y)++, *d = 3;\n\t\t}\n\t}else if(*d == 1){\n\t\tif(wall[*y*2+1][*x] == 1){\n\t\t\tprintf(\"D\");\n\t\t\t(*y)++, *d = 3;\n\t\t}else if(wall[*y*2][*x-1] == 1){\n\t\t\tprintf(\"L\");\n\t\t\t(*x)--, *d = 1;\n\t\t}else if(wall[*y*2-1][*x] == 1){\n\t\t\tprintf(\"U\");\n\t\t\t(*y)--, *d = 0;\n\t\t}else{\n\t\t\tprintf(\"R\");\n\t\t\t(*x)++, *d = 2;\n\t\t}\n\t}else if(*d == 2){\n\t\tif(wall[*y*2-1][*x] == 1){\n\t\t\tprintf(\"U\");\n\t\t\t(*y)--, *d = 0;\n\t\t}else if(wall[*y*2][*x] == 1){\n\t\t\tprintf(\"R\");\n\t\t\t(*x)++, *d = 2;\n\t\t}else if(wall[*y*2+1][*x] == 1){\n\t\t\tprintf(\"D\");\n\t\t\t(*y)++, *d = 3;\n\t\t}else{\n\t\t\tprintf(\"L\");\n\t\t\t(*x)--, *d = 1;\n\t\t}\n\t}else{\n\t\tif(wall[*y*2][*x] == 1){\n\t\t\tprintf(\"R\");\n\t\t\t(*x)++, *d = 2;\n\t\t}else if(wall[*y*2+1][*x] == 1){\n\t\t\tprintf(\"D\");\n\t\t\t(*y)++, *d = 3;\n\t\t}else if(wall[*y*2][*x-1] == 1){\n\t\t\tprintf(\"L\");\n\t\t\t(*x)--, *d = 1;\n\t\t}else{\n\t\t\tprintf(\"U\");\n\t\t\t(*y)--, *d = 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar mp[36];int i;\nvoid prt(int d){\n//\tprintf(\"%d %d %d\\t%c\\n\",i,i/6,i%6,\"RDLU\"[d]);\n\tputchar(\"RDLU\"[d]);\n}\nint main(void){\n\tint j,d=0,t[]={1,6,-1,-6};\n\tfor(j=1;j<5;j++)getchar()-'0'?mp[j+6]=8,mp[j]=2:0;\n\tgetchar();\n\tfor(i=1;i<5;i++){\n\t\tfor(j=0;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=1,mp[i*6+1+j]|=4:0;\n\t\tgetchar();\n\t\tfor(j=1;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=2,mp[i*6+6+j]|=8:0;\n\t\tgetchar();\n\t}\n\ti=0;\n\tdo{\n\t\tj=0;\n\t\tmp[i]&1<<d||(i+=j=t[d]);\n\t\tif(i){\n\t\t\tif(mp[i]&1<<(d+1&3)){\n\t\t\t\t!j&&mp[i]&1<<d?d=d+3&3:0;\n\t\t\t\tprt(d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti+=t[d=d+1&3];\n\t\t\t\tif(mp[i]&1<<(d+1&3))prt(d);\n\t\t\t\telse if(i)i+=t[d=d+1&3];\n\t\t\t}\n\t\t}\n\t}while(i);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint wall[10][10], x, y, way, i, j;\n\nint main(){\n  for(i = 1;i <= 9;i++){\n    for(j = 0;j < 5 - (i % 2);j++){\n      scanf(\"%1d\", &wall[i][j]);\n    }\n  }\n  x = -1;\n  y = 0;\n  way = 0;// 0:R, 1:D, 2:L, 3:U\n  do{\n    if(way == 0){\n      if(y == 4 || wall[x * 2 + 3][y] == 0){\n\tway = 1;\n\tx++;\n      }\t     \n      else if(x > -1 && wall[x * 2 + 2][y + 1] == 1){\n\tway = 3;\n      }\n      else{\n\ty++;\n\tputchar('R');\n      }\n    }\n\n    else if(way == 1){\n      if(x == 4 || wall[x * 2 + 2][y] == 0){\n\tway = 2;\n\ty--;\n      }\t     \n      else if(y < 4 &&wall[x * 2 + 3][y] == 1){\n\tway = 0;\n      }\n      else{\n\tx++;\n\tputchar('D');\n      }\n    }\n\n    else if(way == 2){\n      if(y == -1 || wall[x * 2 + 1][y] == 0){\n\tway = 3;\n\tx--;\n      }\t     \n      else if(x < 4 &&wall[x * 2 + 2][y] == 1){\n\tway = 1;\n      }\n      else{\n\ty--;\n\tputchar('L');\n      }\n    }\n\n    else if(way == 3){\n      if(x == -1 || wall[x * 2 + 2][y + 1] == 0){\n\tway = 0;\n\ty++;\n      }\t     \n      else if(y > -1 && wall[x * 2 + 1][y] == 1){\n\tway = 2;\n      }\n      else{\n\tx--;\n\tputchar('U');\n      }\n    }\n  }while(x != -1 || y != 0);\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "w[25],i;main(d){for(i<9;i++){if(i&1)for(d=0;d<5;d++)getchar()-'0'?w[i/2*5+d]|=2,w[i/2*5+d+5]|=8:0;else for(d=0;d<4;d++)getchar()-'0'?w[i/2*5+d]|=1,w[i/2*5-~d]|=4:0;getchar();}d=!putchar(82);for(i=1;d|i;d&=3)w[i]&1<<d?i+=\"GKEA\"[d]-70,putchar(\"RDLU\"[d]),w[i]&1<<(d+3&3)&&--d:++d;i=!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nchar wall[9][6],x,y,dir;\n\nint check(int y,int x){\n\tif(y<0 || y>8 || x<0 || wall[y][x]!='1')return 0;\n\telse return 1;\n}\n\nvoid nextdir(){\n\tint i;\n\tfor(i=1;i<4;i++){\n\t\tswitch((dir+i)%4){\n\t\t\tcase 0:\n\t\t\tif(check(y*2,x-1)==1){printf(\"L\");x--;dir=2;return;}\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tif(check(y*2-1,x)==1){printf(\"U\");y--;dir=3;return;}\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tif(check(y*2,x)==1){printf(\"R\");x++;dir=0;return;}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tif(check(y*2+1,x)==1){printf(\"D\");y++;dir=1;return;}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(void){\n\tfor(y=0;y<9;y++)scanf(\"%s\",wall[y]);\n\tx=0,y=0;dir=0;\n\n\twhile(1){\n\t\tnextdir();\n\t\tif(x==0 && y==0)break;\n\t}\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[11][11];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tx=y=5;\n\tfor(j=0;j<2*y;j++)for(i=0;i<2*x;i++)s[i][j]=0;\n\tfor(j=1;j<2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:1;i<2*x;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=3,y=1;x!=1||y!=1;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int i,j;\n  int m[6][7],n[7][6],x=1+1,y=0+1,xs=1,ys=0;\n  char s[6];\n  memset(m,0,sizeof(m));\n  memset(n,0,sizeof(n));\n  for(i=0+1;i<4+1;i++){\n    scanf(\"%s\",s);\n    for(j=0+1;j<4+1;j++)\n      m[j][i]=s[j-1]-'0';\n    scanf(\"%s\",s);\n    for(j=0+1;j<5+1;j++)\n      n[j][i]=s[j-1]-'0';\n  }\n  scanf(\"%s\",s);\n  for(j=0+1;j<4+1;j++)\n    m[j][i]=s[j-1]-'0';\n  printf(\"R\");\n  for(i=0;x!=1||y!=1;i++){\n    if(i==100)\n      break;\n    if(xs==1){\n      if(n[x][y-1]){\n\txs=0;\n\tys=-1;\n      }else if(m[x][y]){\n      }else if(n[x][y]){\n\txs=0;\n\tys=1;\n      }else\n\txs=-1;\n    }else if(xs==-1){\n      if(n[x][y]){\n\txs=0;\n\tys=1;\n      }else if(m[x-1][y]){\n      }else if(n[x][y-1]){\n\txs=0;\n\tys=-1;\n      }else\n\txs=1;\n    }else if(ys==1){\n      if(m[x][y]){\n\txs=1;\n\tys=0;\n      }else if(n[x][y]){\n      }else if(m[x-1][y]){\n\txs=-1;\n\tys=0;\n      }else\n\tys=-1;\n    }else if(ys==-1){\n      if(m[x-1][y]){\n\txs=-1;\n\tys=0;\n      }else if(n[x][y-1]){\n      }else if(m[x][y]){\n\txs=1;\n\tys=0;\n      }else\n\tys=1;\n    }\n    x+=xs;\n    y+=ys;\n    if(xs==1)\n      printf(\"R\");\n    if(xs==-1)\n      printf(\"L\");\n    if(ys==1)\n      printf(\"D\");\n    if(ys==-1)\n      printf(\"U\");\n  }\n  puts(\"\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nenum{up,right,down,left};\nchar res[]=\"URDL\";\nint g[5][5][4],i,j,t,d=right;\n\nvoid move(int dir)\n{\n\tputchar(res[dir]);\n\td=dir;\n\tswitch(dir)\n\t{\n\tcase up:i--;break;\n\tcase right:j++;break;\n\tcase down:i++;break;\n\tcase left:j--;break;\n\t}\n}\n\nint main()\n{\n\tfor(i=0;i<9;i++,getchar())\n\t{\n\t\tif(i%2==0)\n\t\t\tfor(j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][right]=g[i/2][j+1][left]=1;\n\t\t\t}\n\t\telse\n\t\t\tfor(j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&t);\n\t\t\t\tif(t=='1')\n\t\t\t\t\tg[i/2][j][down]=g[i/2+1][j][up]=1;\n\t\t\t}\n\t}\n\tfor(i=0,j=0,t=0;!t;)\n\t{\n\t\tif(g[i][j][d]==1)\n\t\t\tmove(d);\n\t\telse\n\t\t{\n\t\t\tswitch(d)\n\t\t\t{\n\t\t\tcase up:if(g[i][j][left])\n\t\t\t\t\t\tmove(left);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(right);\n\t\t\t\t\tbreak;\n\t\t\tcase right:if(g[i][j][up])\n\t\t\t\t\t\tmove(up);\n\t\t\t\t\telse\n\t\t\t\t\t\tmove(down);\n\t\t\t\t\tbreak;\n\t\t\tcase left: if(g[i][j][down])\n\t\t\t\t\t\t   move(down);\n\t\t\t\t\t   else\n\t\t\t\t\t\t   move(up);\n\t\t\t\t\tbreak;\n\t\t\tcase down: if(g[i][j][right])\n\t\t\t\t\t\t   move(right);\n\t\t\t\t\t   else\n\t\t\t\t\t\t   move(left);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i==0&&j==0)\n\t\t\tputs(\"\"),t=1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tchar temp[9][5], map[9][5];\n\tint i, j;\n\tchar direction;\n\t\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tscanf(\"%c\", &temp[i][j]);\n\t\t}\n\t\tgetchar();\n\t}\n\t\n\tmemset(map, 0, sizeof(map));\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tif (i % 2 == 0){\n\t\t\t\t\tif (temp[i][j] == '1'){\n\t\t\t\t\t\tmap[i][j] = map[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\tmap[i][j] = temp[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 5; j++){\n\t\t\tprintf(\"%d\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\n\ti = 0;\n\tj = 0;\n\tdirection = 'R';\n\tdo {\n\t\tswitch (direction){\n\t\t\tcase 'R':\n\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\tj++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'L':\n\t\t\tif (map[i][j - 1] == 1){\n\t\t\t\tj--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'D':\n\t\t\tif (map[i + 2][j] == 1){\n\t\t\t\ti += 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1 && map[i + 1][j - 1] == 1){\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'U':\n\t\t\tif (map[i - 2][j] == 1){\n\t\t\t\ti -= 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1 && map[i - 1][j - 1] == 1){\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti--;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (i + j != 0);\n\tprintf(\"\\n\");\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define PI 3.14159265358979323\n\n//int calc1(float a,float b,float c,float d,float e,float f,float *x,float *y);\n//void quick(int *,long long,long long);\n//int comp(char *a,char *b);\n\nint main(){\n\t\n\tchar a[9][6];\n\tint x,y,m,i;\n\n\twhile(scanf(\"%s\",a[0])!=EOF){\n\t\tfor(i=1;i<9;i++)\n\t\t\tscanf(\"%s\",a[i]);\n\t\tx=0;\n\t\ty=0;\n\t\tm=1;\n\t\tdo{\n\t\t\tif(m==0){\n\t\t\t\tprintf(\"L\");\n\t\t\t\tx--;\n\t\t\t\tif(y==4||a[2*y+1][x]=='0'){\n\t\t\t\t\tif(x==0||a[2*y][x-1]=='0'){\n\t\t\t\t\t\tif(y==0||a[2*y-1][x]=='0')\n\t\t\t\t\t\t\tm=1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=2;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=3;\n\t\t\t}else if(m==1){\n\t\t\t\tprintf(\"R\");\n\t\t\t\tx++;\n\t\t\t\tif(y==0||a[2*y-1][x]=='0'){\n\t\t\t\t\tif(x==4||a[2*y][x]=='0'){\n\t\t\t\t\t\tif(y==4||a[2*y+1][x]=='0')\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=3;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=2;\n\t\t\t}else if(m==2){\n\t\t\t\tprintf(\"U\");\n\t\t\t\ty--;\n\t\t\t\tif(x==0||a[2*y][x-1]=='0'){\n\t\t\t\t\tif(y==0||a[2*y-1][x]=='0'){\n\t\t\t\t\t\tif(x==4||a[2*y][x]=='0')\n\t\t\t\t\t\t\tm=3;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=1;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=0;\n\t\t\t}else{\n\t\t\t\tprintf(\"D\");\n\t\t\t\ty++;\n\t\t\t\tif(x==4||a[2*y][x]=='0'){\n\t\t\t\t\tif(y==4||a[2*y+1][x]=='0'){\n\t\t\t\t\t\tif(x==0||a[2*y][x-1]=='0')\n\t\t\t\t\t\t\tm=2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t\tm=1;\n\t\t\t}\n\t\t}while(x!=0||y!=0);\n\t\tprintf(\"\\n\");\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define X 11\n#define Y 11\n#define R 1\n#define L 2\n#define U 3\n#define D 4\n\nint main(void)\n{\n\tchar brd[X][Y];/*パネル*/\n\tchar in[X][Y];/*パネル*/\n\tint x = 0, y = 0;\n\tint i = 0, j = 0;\n\tint flag[100];\n\tchar ans[4][2];\n\tint k = 1, t = 1;\n\tint r = 0;/*righet*/\n\tint l = 0;/*left*/\n\tint u = 0;/*under*/\n\tint o = 0;/*on*/\n\tfor(i = 0; i < 100; i++)\n\t{\n\t\tflag[i] = 0;\n\t}\n\n\n\tfor(i = 0; i < X; i++)\n\t{\n\t\tfor(j = 0;j <= Y; j++)\n\t\t{\n\t\t\tin[i][j] = '0';\n\t\t\tbrd[i][j] = '0';\n\t\t}\n\t}\n\tfor(i = 0; i <  9; i++)\n\t{\n\t\tscanf(\"%s\", in[i]);\n\t}\n\tfor(i = 1; i < 10; i++)\n\t{\n\t\tfor(j = k+1; j < 10; j += 2 )\n\t\t{\n\t\t\tbrd[i][j] = in[x][y];\n\t\t\ty++;\n\t\t}\n\t\ty = 0;\n\t\tx++;\n\t\tt++;\n\t\tk = t % 2;\n\t}\n/*\n\tfor(i =  0; i <  X; i++)\n\t{\n\t\tfor(j = 0; j < Y; j ++)\n\t\t{\n\t\t\tprintf(\"i=%d j=%d    brd=%c\\n\",i,j,brd[i][j]);\n\t\t}\n\t\tprintf(\" %d\\n\",j);\n\t}\n*/\n\tx = 2;/*j*/\n\ty = 1;/*i*/\n\ti = 0;\n\tflag[i] = R;\n\t\n\twhile(1)\n\t{\n\t\tif(flag[i] == R)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y][x + 2] == '1')\n\t\t\t{\n\t\t\t\tx = x + 2;\n\t\t\t\ty = y;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == L)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y][x-2] == '1')\n\t\t\t{\n\t\t\t\tx = x - 2;\n\t\t\t\ty = y; \n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == U)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y-2;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y-1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == D)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y+2;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t}\n\t\tif(x == 2 && y == 1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(j = 0;j <= i;j++)\n\t{\n\t\tif(flag[j] == R)\n\t\t{\n\t\t\tprintf(\"R\");\n\t\t}\n\t\tif(flag[j] == L)\n\t\t{\n\t\t\tprintf(\"L\");\n\t\t}\n\t\tif(flag[j] == D)\n\t\t{\n\t\t\tprintf(\"D\");\n\t\t}\n\t\tif(flag[j] == U)\n\t\t{\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nchar wall[9][6],x,y,dir;\n\nint check(int y,int x){\n\tif(y<0 || y>8 || x<0 || wall[y][x]!='1')return 0;\n\telse return 1;\n}\n\nint nextdir(){\n\tint i;\n\tfor(i=1;i<4;i++){\n\t\tswitch((dir+i)%4){\n\t\t\tcase 0:\n\t\t\tif(check(y*2,x-1)==1){printf(\"L\");x--;return 2;}\n\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tif(check(y*2-1,x)==1){printf(\"U\");y--;return 3;}\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tif(check(y*2,x)==1){printf(\"R\");x++;return 0;}\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tif(check(y*2+1,x)==1){printf(\"D\");y++;return 1;}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(void){\n\tfor(y=0;y<9;y++)scanf(\"%s\",wall[y]);\n\tx=0,y=0;dir=0;\n\n\twhile(1){\n\t\tdir=nextdir();\n\t\tif(x==0 && y==0)break;\n\t}\n\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint a[6][6][4];\n\nint R=0,L=1,U=2,D=3;\n\nvoid print(){\n\tint i,j;\n\tfor(i=0; i<6; i++){\n\t\tfor(j=0; j<6; j++){\n\t\t\tprintf(\"%d\",a[i][j][U]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(i=0; i<6; i++){\n\t\tfor(j=0; j<6; j++){\n\t\t\tprintf(\"%d\",a[i][j][D]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(i=0; i<6; i++){\n\t\tfor(j=0; j<6; j++){\n\t\t\tprintf(\"%d\",a[i][j][R]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\tfor(i=0; i<6; i++){\n\t\tfor(j=0; j<6; j++){\n\t\t\tprintf(\"%d\",a[i][j][L]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint i,j,k,x=0,y=0,d;\n\tchar c;\n\tfor(i=0; i<4; i++){\n\t\tfor(j=0; j<4; j++){\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ta[y][j+1][D]=1;\n\t\t\t\ta[y+1][j+1][U]=1;\n\t\t\t}\n\t\t}\n\t\ty++;\n\t\tscanf(\"%c\",&c);\n\t\tfor(j=0; j<5; j++){\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ta[y][j][R]=1;\n\t\t\t\ta[y][j+1][L]=1;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%c\",&c);\n\t}\n\tfor(i=0; i<4; i++){\n\t\tscanf(\"%c\",&c);\n\t\tif(c=='1'){\n\t\t\ta[4][i+1][D]=1;\n\t\t\ta[5][i+1][U]=1;\n\t\t}\n\t}\n\n\tx=0;\n\ty=0;\n\td=R;\n\twhile(1){\n\t\tif(d==R){\n\t\t\tif(a[y][x][R]){\n\t\t\t\td=U;\n\t\t\t}\n\t\t\telse if(a[y][x+1][D]){\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t\td=D;\n\t\t\t}\n\t\t}\n\t\telse if(d==D){\n\t\t\tif(a[y][x][D]){\n\t\t\t\td=R;\n\t\t\t}\n\t\t\telse if(a[y+1][x][L]){\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\td=L;\n\t\t\t}\n\t\t}\n\t\telse if(d==L){\n\t\t\tif(a[y][x][L]){\n\t\t\t\td=D;\n\t\t\t}\n\t\t\telse if(a[y][x-1][U]){\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\td=U;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(a[y][x][U]){\n\t\t\t\td=L;\n\t\t\t}\n\t\t\telse if(a[y-1][x][R]){\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\td=R;\n\t\t\t}\n\t\t}\n\t\tif(d==R)printf(\"R\");\n\t\telse if(d==L)printf(\"L\");\n\t\telse if(d==U)printf(\"U\");\n\t\telse printf(\"D\");\n\n\t\t//printf(\"  x:%d y:%d\\n\",x,y);\n\t\t// if(x>5||x<0||y>5||y<0){\n\t\t// \tprintf(\"x:%d y:%d\\n\",x,y);\n\t\t// \tbreak;\n\t\t// }\n\n\t\tif(x==1&&y==1&&d==L)break;\n\t\tif(x==0&&y==1&&d==U)break;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 0 Problem 0037\n\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint map[13][13];\n\tint i, j;\n\tchar in[6];\n\tint x, y;\n\tchar direc_table1[] = \"URDLURD\";\n\tint direc; \t// 0:ツ右ツ古シツつォ 1:ツ可コツ古シツつォツ　2:ツ債カツ古シツつォ 3:ツ湘」ツ古シツつォ\n\n\tmemset(map, 0, sizeof(map));\n\t\n\tfor (i = 0; i < 9; i++){\n\t\tscanf(\"%s\", in);\n\t\tif (i % 2 == 0){\n\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\tif (in[j] == '1'){\n\t\t\t\t\ty = ((i / 2) + 1) * 2;\n\t\t\t\t\tmap[y][(j + 1) * 2    ] =\n\t\t\t\t\tmap[y][(j + 1) * 2 + 1] =\n\t\t\t\t\tmap[y][(j + 1) * 2 + 2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = 0; j < 5; j++){\n\t\t\t\tif (in[j] == '1'){\n\t\t\t\t\ty = ((i / 2) + 1) * 2;\n\t\t\t\t\tx = (j + 1) * 2;\n\t\t\t\t\tmap[y    ][x] =\n\t\t\t\t\tmap[y + 1][x] =\n\t\t\t\t\tmap[y + 2][x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n//\tfor (i = 0; i < 13; i++){\n//\t\tfor (j = 0; j < 13; j++){\n//\t\t\tif (map[i][j] == 0){\n//\t\t\t\tprintf(\".\");\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tprintf(\"*\");\n//\t\t\t}\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\t\n\tx = y = 2;\n\tdirec = 0;\n\t\n\twhile (1){\n\t\t\n//\t\tprintf(\"(%d,%d)\", x, y);\n\t\t\n\t\tfor (i = direc; i < direc + 4; i++){\n\n//\t\t\tprintf(\"[%c]\", direc_table1[i]);\n\n\t\t\tif (direc_table1[i] == 'U'){\n\t\t\t\tif (map[y - 1][x] != 0){\n\t\t\t\t\tmap[y][x] = map[y - 1][x] = 2;\n\t\t\t\t\ty -= 2;\n\t\t\t\t\tdirec = 3;\n\t\t\t\t\tprintf(\"U\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (direc_table1[i] == 'R'){\n\t\t\t\tif (map[y][x + 1] != 0){\n\t\t\t\t\tmap[y][x] = map[y][x + 1] = 2;\n\t\t\t\t\tx += 2;\n\t\t\t\t\tdirec = 0;\n\t\t\t\t\tprintf(\"R\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (direc_table1[i] == 'D'){\n\t\t\t\tif (map[y + 1][x] != 0){\n\t\t\t\t\tmap[y][x] = map[y + 1][x] = 2;\n\t\t\t\t\ty += 2;\n\t\t\t\t\tdirec = 1;\n\t\t\t\t\tprintf(\"D\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (direc_table1[i] == 'L'){\n\t\t\t\tif (map[y][x - 1] != 0){\n\t\t\t\t\tmap[y][x] = map[y][x - 1] = 2;\n\t\t\t\t\tx -= 2;\n\t\t\t\t\tdirec = 2;\n\t\t\t\t\tprintf(\"L\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (x == 2 && y == 2){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprintf(\"\\n\");\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_UNIT_SIZE 10000\n#define MAX_LINE_LENGTH 1000\n\ntypedef struct {\n    int x, y;\n} vector_t;\n\nvoid complex_mul(const vector_t *v1, const vector_t *v2, vector_t *t) {\n    t->x = v1->x * v2->x - v1->y * v2->y;\n    t->y = v1->x * v2->y + v1->y * v2->x;\n}\n\nchar *bufp[100], *wall[1000], path[10000];\nconst vector_t next_dir[] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\nconst char dir_char[][3] = {\n    {' ', 'U', ' '}, {'L', ' ', 'R'}, {' ', 'D', ' '}\n};\n\nint main(void) {\n    int W, H, i;\n    int buf_idx, buf_len, path_idx, nx, ny;\n    char *buf;\n    vector_t pos, dir, ndir;\n\n    buf_idx = 0;\n    buf_len = 0;\n    buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n    bufp[buf_idx++] = buf;\n    for (i = 0, W = 0; gets(buf) != NULL; i++) {\n        wall[i] = buf;\n        if (W == 0) W = strlen(buf);\n        buf_len += strlen(buf) + 1;\n        if (buf_len + MAX_LINE_LENGTH > BUF_UNIT_SIZE) {\n            buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n            bufp[buf_idx++] = buf;\n            buf_len = 0;\n        }\n        else {\n            buf += strlen(buf) + 1;\n        }\n    }\n    H = i;\n\n    path_idx = 0;\n    path[path_idx++] = 'R';\n    pos.x = 0;\n    pos.y = 0;\n    dir.x = 1;\n    dir.y = 0;\n    while (1) {\n        for (i = 0; i < 3; i++) {\n            complex_mul(&dir, &next_dir[i], &ndir);\n            if ((pos.y&1) == 0) {\n                ny = pos.y + ndir.y;\n                nx = pos.x + ndir.x + (dir.x > 0)*((ny+2)&1);\n            }\n            else {\n                ny = pos.y + ndir.y + dir.y;\n                nx = pos.x + ndir.x - (ndir.x > 0);\n            }\n            if (nx < 0 || W+(ny&1) <= nx || ny < 0 || H <= ny) continue;\n            if (wall[ny][nx] == '1') break;\n        }\n        if (i == 3) {\n            dir.x = - dir.x;\n            dir.y = - dir.y;\n        }\n        else {\n            pos.x = nx;\n            pos.y = ny;\n            dir.x = ndir.x;\n            dir.y = ndir.y;\n        }\n        path[path_idx++] = dir_char[1+dir.y][1+dir.x];\n\n        if ((pos.x == 0 && pos.y == 0 && dir.x == -1) ||\n            (pos.x == 0 && pos.y == 1 && dir.y == -1)) break;\n    }\n\n    path[path_idx] = '\\0';\n    puts(path);\n\n    for (i = 0; i < buf_idx; i++) {\n        free(bufp[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n\nint\nmain(int argc, char** argv)\n{\n\tchar maze[9][5];\n\tint x, y;\n\tint px, py;\n\tint mx, my;\n\tchar dir;\n\tint i;\n\n\tfor (i = 0; i < 9; ++i)\n\t\tscanf(\"%s\", &maze[i][0]);\n\n\tx = 0, y = 0;\n\tdir = 'R';\n\tprintf(\"%c\", dir);\n\n\tdo\n\t{\n\t\tpx = x + 1, py = y + 1;\n\t\tmx = x - 1, my = y - 1;\n\t\tif (dir == 'R')\n\t\t{\n\t\t\tif (px < 5 && maze[y][px] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = px;\n\t\t\t}\n\n\t\t\telse /* (px >= 5 || maze[y][px] == '0') ? */\n\t\t\t{\n\t\t\t\tif (px < 5 && my >= 0 && maze[my][px] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'U';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\tx = px;\n\t\t\t\t\ty = my;\n\t\t\t\t}\n\n\t\t\t\telse if (px < 5 && py < 9 && maze[py][px] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'D';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\tx = px;\n\t\t\t\t\ty = py;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'L')\n\t\t{\n\t\t\tif (mx >= 0 && maze[y][mx] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\tx = mx;\n\t\t\t}\n\n\t\t\telse /* (mx < 0 || maze[y][mx] == '0') ? */\n\t\t\t{\n\t\t\t\tif (x >= 0 && py < 9 && maze[py][x] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'D';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\ty = py;\n\t\t\t\t}\n\n\t\t\t\telse if (x >= 0 && my >= 0 && maze[my][x] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'U';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\ty = my;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'D')\n\t\t{\n\t\t\tif (y + 2 < 9 && maze[y + 2][x] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty += 2;\n\t\t\t}\n\n\t\t\telse /* (y + 2 >= 9 || maze[y + 2][x] == '0') ? */\n\t\t\t{\n\t\t\t\tif (py < 9 && maze[py][x] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'R';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\ty = py;\n\t\t\t\t}\n\n\t\t\t\telse if (py < 9 && mx >= 0 && maze[py][mx] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'L';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\tx = mx;\n\t\t\t\t\ty = py;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (dir == 'U')\n\t\t{\n\t\t\tif (y - 2 >= 0 && maze[y - 2][x] == '1')\n\t\t\t{\n\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\ty -= 2;\n\t\t\t}\n\n\t\t\telse /* (y - 2 < 0 || maze[y - 2][x] == '0') */\n\t\t\t{\n\t\t\t\tif (my >= 0 && mx >= 0 && maze[my][mx] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'L';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\tx = mx;\n\t\t\t\t\ty = my;\n\t\t\t\t}\n\n\t\t\t\telse if (my >= 0 && maze[my][x] == '1')\n\t\t\t\t{\n\t\t\t\t\tdir = 'R';\n\t\t\t\t\tprintf(\"%c\", dir);\n\t\t\t\t\ty = my;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} while (!(x == 0 && y == 0));\n\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "w[25],i;main(d){for(;i<9;i++){if(i&1)for(d=0;d<5;d++)getchar()-'0'?w[i/2*5+d]|=2,w[i/2*5+d+5]|=8:0;else for(d=0;d<4;d++)getchar()-'0'?w[i/2*5+d]|=1,w[i/2*5-~d]|=4:0;getchar();}d=!putchar(82);for(i=1;d|i;d&=3)w[i]&1<<d?i+=\"GKEA\"[d]-70,putchar(\"RDLU\"[d]),w[i]&1<<(d+3&3)&&--d:++d;i=!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define X 11\n#define Y 11\n#define R 1\n#define L 2\n#define U 3\n#define D 4\n\nint main(void)\n{\n\tchar brd[X][Y];/*パネル*/\n\tchar in[X][Y];/*パネル*/\n\tint x = 0, y = 0;\n\tint i = 0, j = 0;\n\tint flag[100];\n\tchar ans[4][2];\n\tint k = 1, t = 1;\n\tfor(i = 0; i < 100; i++)\n\t{\n\t\tflag[i] = 0;\n\t}\n\n\n\tfor(i = 0; i < X; i++)\n\t{\n\t\tfor(j = 0;j <= Y; j++)\n\t\t{\n\t\t\tin[i][j] = '0';\n\t\t\tbrd[i][j] = '0';\n\t\t}\n\t}\n\tfor(i = 0; i <  9; i++)\n\t{\n\t\tscanf(\"%s\", in[i]);\n\t}\n\tfor(i = 1; i < 10; i++)\n\t{\n\t\tfor(j = k+1; j < 10; j += 2 )\n\t\t{\n\t\t\tbrd[i][j] = in[x][y];\n\t\t\ty++;\n\t\t}\n\t\ty = 0;\n\t\tx++;\n\t\tt++;\n\t\tk = t % 2;\n\t}\n\t/*\n\tfor(i =  0; i <  X; i++)\n\t{\n\t\tfor(j = 0; j < Y; j ++)\n\t\t{\n\t\t\tprintf(\"i=%d j=%d    brd=%c\\n\",i,j,brd[i][j]);\n\t\t}\n\t\tprintf(\" %d\\n\",j);\n\t}*/\n\n\t/*-------------------------------------------------------*/\n\tx = 2;/*j*/\n\ty = 1;/*i*/\n\ti = 0;\n\tflag[i] = R;\n\t\n\twhile(1)\n\t{\n\t\tif(flag[i] == R)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y][x + 2] == '1')\n\t\t\t{\n\t\t\t\tx = x + 2;\n\t\t\t\ty = y;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == L)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y][x-2] == '1')\n\t\t\t{\n\t\t\t\tx = x - 2;\n\t\t\t\ty = y; \n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == U)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y-2;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y-1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == D)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y+2;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t}\n\t\tif(x == 2 && y == 1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(j = 0;j <= i;j++)\n\t{\n\t\tif(flag[j] == R)\n\t\t{\n\t\t\tprintf(\"R\");\n\t\t}\n\t\tif(flag[j] == L)\n\t\t{\n\t\t\tprintf(\"L\");\n\t\t}\n\t\tif(flag[j] == D)\n\t\t{\n\t\t\tprintf(\"D\");\n\t\t}\n\t\tif(flag[j] == U)\n\t\t{\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define DEBUG 0\n\n\ntypedef struct TGrid Grid;\nstruct TGrid {\n    int fRight;\n    int fDown;\n};\n\n/* starting at (1, 1), not (0,0) */ #define XSIZE 6\n#define YSIZE 6\n\nGrid Grids[(XSIZE)*(YSIZE)];\nenum {BadDirection=0, North=1, East=2, South=3, West=4};\nchar Map[5] = {'X', 'U', 'R', 'D', 'L'};\n\n\n\nint right_at(int x, int y){\n   return Grids[x+XSIZE*y].fRight;\n}\n\nint down_at(int x, int y){\n   return Grids[x+XSIZE*y].fDown;\n}\n\nint left_at(int x, int y){\n   return Grids[x-1+XSIZE*y].fRight;\n}\n\nint up_at(int x, int y){\n   return Grids[x+XSIZE*(y-1)].fDown;\n}\n\nvoid cw(int* nx, int *ny, int x, int y){\n    int ux, uy;\n    int vx, vy;\n\n    if(DEBUG)\n        printf(\"(%d, %d) (%d, %d)\\n\", *nx, *ny, x, y);\n\n    ux = *nx - x;\n    uy = *ny - y;\n    /* rotate -pi/2, (0 1), (-1, 0) */\n    vx = -uy;\n    vy = ux;\n    *nx = x + vx;\n    *ny = y + vy;\n\n    if(DEBUG)\n        printf(\"=> (%d, %d) (%d, %d)\\n\", *nx, *ny, x, y);\n}\n\n\nint direction(int dx, int dy, int x, int y){\n    if (dx == x){\n        if(dy < y){\n            return North;\n        }else{\n            return South;\n        };\n    }else{\n        if(dx > x){\n            return East;\n        }else{\n            /*dx < x*/\n            return West;\n        };\n    }\n}\n\n\nvoid step(int* x, int* y, int* prevx, int* prevy){\n    int i, d;\n    int has_wall;\n    int nextx, nexty;\n    nextx = *prevx;\n    nexty = *prevy;\n\n    if(DEBUG)\n        printf(\"current(%d, %d) prev(%d, %d)\\n\", *x, *y, *prevx, *prevy);\n\n    for(i=0;i<4;i++){\n        cw(&nextx, &nexty, *x, *y);\n        d = direction(nextx, nexty, *x, *y);\n        if(DEBUG)\n            printf(\"trying direction:%c\\n\", Map[d]);\n        switch(d){\n            case North:\n                has_wall = up_at(*x, *y);\n                break;\n            case East:\n                has_wall = right_at(*x, *y);\n                break;\n            case South:\n                has_wall = down_at(*x, *y);\n                break;\n            case West:\n                has_wall = left_at(*x, *y);\n                break;\n            default:\n                break;\n        }\n        if(DEBUG)\n            printf(\"has_wall %d\\n\", has_wall);\n        if(has_wall){\n            printf(\"%c\",Map[d]);\n            break;\n        }\n    }\n\n    *prevx = *x;\n    *prevy = *y;\n    *x = nextx;\n    *y = nexty;\n}\n\n\nvoid set_xy_right(int x, int y, int v){\n        Grids[x+XSIZE*y].fRight = v;\n}\n\nvoid set_xy_down(int x, int y, int v){\n        Grids[x+XSIZE*y].fDown = v;\n}\n\nint load_line(int nth){\n    int i;\n    int x;\n    if(nth%2){\n        scanf(\"%d\", &x);\n        for(i=0;i<4;i++){\n            set_xy_right(4-i,nth/2+1, x%10);\n            x = x/10;\n        }\n\n    }else{\n        scanf(\"%d\", &x);\n        for(i=0;i<5;i++){\n            set_xy_down(5-i,nth/2, x%10);\n            x = x/10;\n        }\n    }\n}\n\n\nint main(){\n    int x, y;\n    int prevx, prevy;\n    int done, nth;\n    nth = 1;\n\n    while(nth < 10){\n        load_line(nth);\n        nth ++;\n    }\n\n    if(DEBUG){\n        for(y=0;y<YSIZE;y++){\n            for(x=0;x<XSIZE;x++){\n                printf(\"%d\", Grids[x+y*XSIZE].fRight);\n            }\n            printf(\"\\n\");\n            for(x=0;x<XSIZE;x++){\n                printf(\"%d\", Grids[x+y*XSIZE].fDown);\n            }\n            printf(\"\\n\");\n            printf(\"---------\\n\");\n        }\n    }\n\n    x = 1; y = 1;\n    prevx = 1; prevy = 2;\n    step(&x, &y, &prevx, &prevy);\n    while(!(x==1 && y==1)){\n        step(&x, &y, &prevx, &prevy);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \nvoid change(int,int);\nint muki = 0,flag = 0;\n \nint main(){\n    int i,j,x = 0,y = 0,wall_x[4][5],wall_y[5][4];\n    for(i = 0;i < 9;i++){\n        if(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n        else for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n    }\n    do{\n        if(muki == 0){\n            if(x != 4 && wall_x[x][y] == 1){\n                flag = 0;\n                change(x,y);\n                putchar('R');\n                x++;\n            }else change(x,y);\n        }else if(muki == 1){\n            if(y != 4 && wall_y[x][y] == 1){\n                flag = 0;\n                change(x,y);\n                putchar('D');\n                y++;\n            }else change(x,y);\n        }else if(muki == 2){\n            if(x != 0 && wall_x[x - 1][y] == 1){\n                flag = 0;\n                change(x,y);\n                putchar('L');\n                x--;\n            }else change(x,y);\n        }else if(muki == 3){\n            if(y != 0 && wall_y[x][y - 1] == 1){\n                flag = 0;\n                change(x,y);\n                putchar('U');\n                y--;\n            }else change(x,y);\n        }\n    }while(x != 0 || y != 0);\n    puts(\"\");\n    return 0;\n}\n \nvoid change(int x,int y){\n    int i;\n    if(!flag){\n        flag = 1;\n        muki = (muki + 3) % 4;\n    }\n    else muki = (muki + 1) % 4;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tchar temp[9][5], map[9][5];\n\tint i, j;\n\tchar direction;\n\t\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tscanf(\"%c\", &temp[i][j]);\n\t\t}\n\t\tgetchar();\n\t}\n\t\n\tmemset(map, 0, sizeof(map));\n\tfor (i = 0; i < 9; i++){\n\t\tfor (j = 0; j < 4 + i % 2; j++){\n\t\t\tif (i % 2 == 0){\n\t\t\t\t\tif (temp[i][j] == '1'){\n\t\t\t\t\t\tmap[i][j] = map[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\tmap[i][j] = temp[i][j] - '0';\n\t\t\t}\n\t\t}\n\t}\n\t\n\ti = 0;\n\tj = 0;\n\tdirection = 'R';\n\tdo {\n\t\tswitch (direction){\n\t\t\tcase 'R':\n\t\t\tif (map[i][j + 1] == 1){\n\t\t\t\tj++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirection = 'L';\n\t\t\t\tj--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'L':\n\t\t\tif (map[i][j - 1] == 1){\n\t\t\t\tj--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti--;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdirection = 'R';\n\t\t\t\tj++;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'D':\n\t\t\tdirection = 'U';\n\t\t\tif (map[i + 2][j] == 1){\n\t\t\t\tdirection = 'D';\n\t\t\t\ti += 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j] == 1 && map[i + 1][j - 1] == 1){\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i + 1][j + 1] == 1){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'U':\n\t\t\tdirection = 'D';\n\t\t\tif (map[i - 2][j] == 1){\n\t\t\t\tdirection = 'U';\n\t\t\t\ti -= 2;\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j] == 1 && map[i - 1][j - 1] == 1){\n\t\t\t\ti--;\n\t\t\t\tj--;\n\t\t\t\tdirection = 'L';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse if (map[i - 1][j + 1] == 1){\n\t\t\t\ti--;\n\t\t\t\tj++;\n\t\t\t\tdirection = 'R';\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%c\", direction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (i + j != 0);\n\tprintf(\"\\n\");\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z,k){\n\tmemset(s,11,sizeof(s));\n\tx=y=5;\n\tfor(j=1;j<=2*y+1;j++)for(i=1;i<=2*x+1;i++)s[i][j]=0;\n\tfor(j=2;j<=2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:3;i<2*x+1;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=4,y=2;x!=2||y!=2;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\n\tputs(\"\");exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar mp[36];\nint main(void){\n\tint i,j,d=0,t[]={1,6,-1,-6};\n\tfor(j=1;j<5;j++)getchar()-'0'?mp[j+6]=8,mp[j]=2:0;\n\tgetchar();\n\tfor(i=1;i<5;i++){\n\t\tfor(j=0;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=1,mp[i*6+1+j]|=4:0;\n\t\tgetchar();\n\t\tfor(j=1;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=2,mp[i*6+6+j]|=8:0;\n\t\tgetchar();\n\t}\n\ti=1;\n\tputchar('R');\n\tdo{\n\t\tj=0;\n\t\tmp[i]&1<<d||(i+=j=t[d]);\n\t\tif(mp[i]&1<<(d+1&3)){\n\t\t\t!j&&mp[i]&1<<d?d=d+3&3:0;\n\t\t\tputchar(\"RDLU\"[d]);\n\t\t}\n\t\telse{\n\t\t\ti+=t[d=d+1&3];\n\t\t\tif(mp[i]&1<<(d+1&3))putchar(\"RDLU\"[d]);\n\t\t\telse i+=t[d=d+1&3];\n\t\t}\n\t}while(i-1);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\tint d=p;\n\t\tdo\n\t\t\td=(d+1)%4;\n\t\twhile(!((f[y][x]>>d)&1));\n\t\tp=d;\n\t\tputchar(\"URDL\"[d]);\n\t\tint dx[] = {0, 1, 0, -1};\n\t\tint dy[] = {-1, 0, 1, 0};\n\t\tx+=dx[d];\n\t\ty+=dy[d];\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n  int tate[8][4],yoko[8][3];\n  int h,i,j,k,x=0,y=0;\n  for(i=0;i<9;i++){\n    if(i%2==0){\n      scanf(\"%1d%1d%1d%1d\",&yoko[i][0],&yoko[i][1],&yoko[i][2],&yoko[i][3]);\n      yoko[i][4]=0;   \n    }else{  \n      scanf(\"%1d%1d%1d%1d%1d\",&tate[i][0],&tate[i][1],&tate[i][2],&tate[i][3],&tate[i][4]);\n      tate[i][5]=0;\n    }\n  }\n\n  //printf(\"----------------------------------------\\n\");\n       for(k=0;k<=9;k++){\n       if(k%2==0){\n\t //printf(\"%d%d%d%d%d\\n\",yoko[k][0],yoko[k][1],yoko[k][2],yoko[k][3],yoko[k][4]);\n       }else{\n\t //printf(\"%d%d%d%d%d%d\\n\",tate[k][0],tate[k][1],tate[k][2],tate[k][3],tate[k][4],tate[k][5]);\n       }\n       }\n  \n\n \n  int sl=1;\n  printf(\"R\");\n  do{\n   \n    switch(sl){\n    case 1:\n      if(tate[y-1][x+1]==1&&y>0){\n\tx++;\n\ty--;\n\tsl=4;\n      }else if(yoko[y][x+1]==1&&x<3){\n\tx++;\n\tsl=1;\n      }else if(tate[y+1][x+1]==1&&y<8){\n\tx++;\n\ty++;\n\t\n\tsl=2;\n      }\n\n      break;\n\n    case 2:\n      if(yoko[y+1][x]==1&&x<3){\n\ty++;sl=1;\n      }else if(tate[y+2][x]==1&&y<8){\n\ty=y+2;sl=2;\n      }else if(yoko[y+1][x-1]==1&&x>0){\n\ty++;\n\tx--;\n\tsl=3;\n      }\n      break;\n\n\n    case 3:\n       if(tate[y+1][x]==1&&y<8){\n\tsl=2;y++;\n      }else if(yoko[y][x-1]==1&&x>0){\n\tx--;sl=3;\n      }else if(tate[y-1][x]==1&&y>0){\n\ty--;sl=4;\n      }\n      break;\n\n\n    case 4:\n      if(yoko[y-1][x-1]==1&&x>0){\n\tx--;y--;sl=3;\n      }else if(tate[y-2][x]==1&&y>0){\n\ty=y-2;sl=4;\n      }else if(yoko[y-1][x]==1&&x<3){\n\ty--;sl=1;\n      }\n      break;\n\n\n    }\n    if(sl==1)printf(\"R\");\n    if(sl==2)printf(\"D\");\n    if(sl==3)printf(\"L\");\n    if(sl==4)printf(\"U\");\n   \n  }while(x!=0||y!=0);\n  printf(\"\\n\");\n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\treturn !puts(\"\"); \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tchar vx[] = { 0, 1, 0, -1,  0, 1, 0};\n\tchar vy[] = {-1, 0, 1,  0, -1, 0, 1};\n\tchar cx[4][3] = {{0, 0, 0}, {0, 0, -1}, {0, -1, 0}, {-1, 0, 0}};\n\tchar cy[4][3] = {{-1, 0, 0}, {0, 0, 0}, {0, 0, -1}, {0, -1, 0}};\n\tchar cw[] = {3, 0, 1, 2, 3, 0, 1, 2};\n\tchar op[] = \"URDLURDL\";\n\tchar w;\n\tint i, j;\n\tchar map[3][102][102];\n\tint n;\n\tint x, y;\n\t\n\tn = 1;\n\tmemset(map, 0, sizeof(map));\n\twhile (1){\n\t\tfor (i = 0; i < 2; i++){\n\t\t\tif (scanf(\"%s\", map[i][n]) == EOF){\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t\tfor (j = strlen(map[i][n]); j >= 0; j--){\n\t\t\t\tmap[i][n][j + 1] = map[i][n][j];\n\t\t\t}\n\t\t\tmap[i][n][0] = 0;\n\t\t}\n\t\tn++;\n\t}\n\tA:\n\t\n\tx = 2;\n\ty = 1;\n\tw = 0;\n\tprintf(\"R\");\n\twhile (x != 1 || y != 1){\n\t\tfor (i = 0; i < 4; i++){\n\t\t\tif (i == 3 || map[!((w + i) % 2)][y + cy[w][i]][x + cx[w][i]] == '1'){\n\t\t\t\tx += vx[w + i];\n\t\t\t\ty += vy[w + i];\n\t\t\t\tprintf(\"%c\", op[i + w]);\n\t\t\t\tw = cw[i + w];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"\\n\");\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint main(){\n  int i,j,w[11][11]={0};\n  int x,y,n,d=1,m=0;\n  int X[]={-1, 0, 1, 1, 2, 1, 1, 0,-1,-1,-2,-1};\n  int Y[]={-1,-2,-1,-1, 0, 1, 1, 2, 1, 1, 0,-1};\n  for(i=0;i<9;i++){\n    scanf(\"%d\",&n);\n    for(j=3-(i%2);j<11;j+=2){\n      w[i+1][11-j]=n%10;\n      n/=10;\n    }\n  }\n  /*  for(i=0;i<11;i++){\n    for(j=0;j<11;j++){\n      printf(\"%d\",w[i][j]);\n    }\n    printf(\"\\n\");\n    }*/\n  y=1;\n  x=4;\n  printf(\"RR\");\n  if(w[1][2]==1){\n    while(x!=2||y!=1){\n      m=0;\n      for(i=0;i<3;i++){\n\tif(w[y+Y[d*3+i]][x+X[d*3+i]]==1){\n\t  x+=X[d*3+i];\n\t  y+=Y[d*3+i];\n\t  d+=i-1;\n\t  m=1;\n\t  break;\n\t}\n      }\n      if(m==0){\n\td+=2;\n      }\n      d+=4;\n      d%=4;\n      if(d==0)printf(\"U\");\n      if(d==1)printf(\"R\");\n      if(d==2)printf(\"D\");\n      if(d==3)printf(\"L\");\n    }\n    printf(\"\\n\");\n    return 0; \n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define X 11\n#define Y 11\n#define R 1\n#define L 2\n#define U 3\n#define D 4\n\nint main(void)\n{\n\tchar brd[X][Y];/*パネル*/\n\tchar in[X][Y];/*パネル*/\n\tint x = 0, y = 0;\n\tint i = 0, j = 0;\n\tint flag[100];\n\tchar ans[4][2];\n\tint k = 1, t = 1;\n\tint r = 0;/*righet*/\n\tint l = 0;/*left*/\n\tint u = 0;/*under*/\n\tint o = 0;/*on*/\n\tfor(i = 0; i < 100; i++)\n\t{\n\t\tflag[i] = 0;\n\t}\n\n\n\tfor(i = 0; i < X; i++)\n\t{\n\t\tfor(j = 0;j <= Y; j++)\n\t\t{\n\t\t\tin[i][j] = '0';\n\t\t\tbrd[i][j] = '0';\n\t\t}\n\t}\n\tfor(i = 0; i <  9; i++)\n\t{\n\t\tscanf(\"%s\", in[i]);\n\t}\n\tfor(i = 1; i < 10; i++)\n\t{\n\t\tfor(j = k+1; j < 10; j += 2 )\n\t\t{\n\t\t\tbrd[i][j] = in[x][y];\n\t\t\ty++;\n\t\t}\n\t\ty = 0;\n\t\tx++;\n\t\tt++;\n\t\tk = t % 2;\n\t}\n/*\n\tfor(i =  0; i <  X; i++)\n\t{\n\t\tfor(j = 0; j < Y; j ++)\n\t\t{\n\t\t\tprintf(\"i=%d j=%d    brd=%c\\n\",i,j,brd[i][j]);\n\t\t}\n\t\tprintf(\" %d\\n\",j);\n\t}\n*/\n\tx = 2;/*j*/\n\ty = 1;/*i*/\n\ti = 0;\n\tflag[i] = R;\n\t\n\twhile(1)\n\t{\n\t\tif(flag[i] == R)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y][x + 2] == '1')\n\t\t\t{\n\t\t\t\tx = x + 2;\n\t\t\t\ty = y;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == L)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y][x-2] == '1')\n\t\t\t{\n\t\t\t\tx = x - 2;\n\t\t\t\ty = y; \n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == U)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y-1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse if(brd[y-2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y-2;\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t\telse if(brd[y-1][x+1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y - 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t}\n\t\telse if(flag[i] == D)\n\t\t{\n\t\t\ti++;\n\t\t\tif(brd[y+1][x + 1] == '1')\n\t\t\t{\n\t\t\t\tx = x + 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = R;\n\t\t\t}\n\t\t\telse if(brd[y+2][x] == '1')\n\t\t\t{\n\t\t\t\tx = x;\n\t\t\t\ty = y+2;\n\t\t\t\tflag[i] = D;\n\t\t\t}\n\t\t\telse if(brd[y+1][x-1] == '1')\n\t\t\t{\n\t\t\t\tx = x - 1; \n\t\t\t\ty = y + 1;\n\t\t\t\tflag[i] = L;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag[i] = U;\n\t\t\t}\n\t\t}\n\t\tif(x == 2 && y == 1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(j = 0;j <= i;j++)\n\t{\n\t\tif(flag[j] == R)\n\t\t{\n\t\t\tprintf(\"R\");\n\t\t}\n\t\tif(flag[j] == L)\n\t\t{\n\t\t\tprintf(\"L\");\n\t\t}\n\t\tif(flag[j] == D)\n\t\t{\n\t\t\tprintf(\"D\");\n\t\t}\n\t\tif(flag[j] == U)\n\t\t{\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char data[10][10];\n    int map[10][10][4];\n    char dir[4] = \"LRDU\";\n    int now;\n    int i, j;\n    \n    memset(data, -1, sizeof(data));\n    memset(map, 0, sizeof(map));\n    \n    for (i = 0; i < 9; i++){\n        scanf(\"%s\", data[i]);\n    }\n    \n    for (i = 0; i < 9; i++){\n        for (j = 0; j < 5; j++){\n            if (i % 2 == 1){\n                if (data[i][j] == '1'){\n                    map[i / 2][j][3] = 1;\n                    map[i / 2 + 1][j][2] = 1;\n                }\n            }\n            else {\n                if (data[i][j] == '1'){\n                    map[i / 2][j][0] = 1;\n                    map[i / 2][j + 1][1] = 1;\n                }\n            }\n        }\n    }\n    \n    i = j = 0;\n    now = 1;\n    do {\n        switch (now){\n          case 0:\n            if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else {\n                j++;\n                now = 1;\n            }\n            break;\n          \n          case 1:\n            if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else {\n                j--;\n                now = 0;\n            }\n            break;\n          \n          case 2:\n            if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else if (i + 1 < 5 && map[i + 1][j][2] == 1){\n                i++;\n                now = 2;\n            }\n            else if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else{\n                i--;\n                now = 3;\n            }\n            break;\n          \n          case 3:\n            if (j > 0 && map[i][j - 1][0] == 1){\n                j--;\n                now = 0;\n            }\n            else if (i > 0 && map[i - 1][j][3] == 1){\n                i--;\n                now = 3;\n            }\n            else if (j + 1 < 5 && map[i][j + 1][1] == 1){\n                j++;\n                now = 1;\n            }\n            else {\n                i++;\n                now = 2;\n            }\n            break;\n        }\n        \n        printf(\"%c\", dir[now]);\n    } while (i + j != 0);\n    \n    printf(\"\\n\");\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\nint main(void) {\n\tconst char DIR[4] = {'L', 'U', 'R', 'D'};\n\tconst int MOVE[4][2] = {{0,-1}, {-1,0}, {0,1}, {1,0}};\n\tint i, j, n;\n\tint r, c, s, d;\n\tchar buff[128][128];\n\tint elem[128][128][4];\n\t\n\tmemset(buff, 0x00, sizeof(buff));\n\tmemset(elem, 0x00, sizeof(elem));\n\n\tn = 1;\n\twhile(scanf(\"%s\\n\", &buff[n][1]) == 1) n++;\n\t\n\t// 入力値を格子に変換\n\tfor(i=1,s=strlen(&buff[2][1]);i<=n/2;i++) {\n\t\tfor(j=1;j<=s;j++) {\n\t\t\telem[i-1][j-1][0] = buff[i*2-1][j-1]=='1';\t// 左\n\t\t\telem[i-1][j-1][1] = buff[i*2-2][j]=='1';\t// 上\n\t\t\telem[i-1][j-1][2] = buff[i*2-1][j]=='1';\t// 右\n\t\t\telem[i-1][j-1][3] = buff[i*2][j]=='1';\t\t// 下\n//\t\t\tprintf(\"%d %d %d %d\\n\", elem[i-1][j-1][0], elem[i-1][j-1][1], elem[i-1][j-1][2], elem[i-1][j-1][3]);\n\t\t}\n\t}\n\t\n\tr = c = 0;\n\td = 2;\n\tdo {\n\t\tif(elem[r][c][(d+3)%4]==1) {\t// 左\n\t\t\td = (d+3) % 4;\n\t\t} else if(elem[r][c][d]==1) {\t// 正面\n\t\t\t;\n\t\t} else if(elem[r][c][(d+1)%4]==1) {\t// 右\n\t\t\td = (d+1) % 4;\n\t\t} else if(elem[r][c][(d+2)%4]==1) {\t// 背後\n\t\t\td = (d+2) % 4;\n\t\t}\n\t\tr += MOVE[d][0];\n\t\tc += MOVE[d][1];\n\t\tprintf(\"%c\", DIR[d]);\n\t\tif(r==0 && c==0) break;\n\t} while(1);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a,y,x,p;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tdo{\n\t\tdo\n\t\t\tp=(p+1)%4;\n\t\twhile(!((f[y][x]>>p)&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar f[6][6],s[6],i,j,a,y,x,p,b;\nint main()\n{\n\tfor(;i<9;++i,b=!b){\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+b;++j)\n\t\t\ta=s[j]-48,f[i/2][j]|=a<<1+b,f[i/2+b][j+!b]|=a<<3-b*3;\n\t}\n\tdo{\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t\tp=(p+2)%4;\n\t}while(y|x|f[0][0]==6&p==3);\n\treturn!puts(\"\"); \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint f[5][5],i,j,a;\nint main()\n{\n\tfor(;i<9;++i){\n\t\tchar s[6];\n\t\tscanf(\"%s\",s);\n\t\tfor(j=0;j<4+i%2;++j){\n\t\t\ta=s[j]-48;\n\t\t\tf[i/2][j]|=a<<(1+i%2);\n\t\t\tf[i/2+i%2][j+!(i%2)]|=a<<3-i%2*3;\n\t\t}\n\t}\n\tprintf(\"R\");\n\tint y=0,x=1,p=1;\n\tdo{\n\t\tp=(p+2)%4;\n\t\twhile(!((f[y][x]>>(p=(p+1)%4))&1));\n\t\tputchar(\"URDL\"[p]);\n\t\tx+=p?2-p:0;\n\t\ty+=p==3?0:p-1;\n\t}while(y!=0||x!=0||f[0][0]==6&&p==3);\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nenum {\n\tLEFT,\n\tRIGHT,\n\tUP,\n\tDOWN\n};\n\nint iskabe(char[9][6],int,int,int);\nint getleft(int);\nint getright(int);\nvoid move(int*,int*,int);\nvoid printdir(int);\n\nint main(void) {\n\tchar kabe[9][6];\n\tint x,y;\n\tint direction;\n\tint i;\n\tfor(i=0;i<9;i++)scanf(\"%s\",kabe[i]);\n\tx=0;y=0;direction=RIGHT;\n\tmove(&x,&y,direction);\n\twhile(x!=0 || y!=0) {\n\t\tif(iskabe(kabe,x,y,direction));\n\t\telse if(iskabe(kabe,x,y,getleft(direction)))\n\t\t\tdirection=getleft(direction);\n\t\telse if(iskabe(kabe,x,y,getright(direction)))\n\t\t\tdirection=getright(direction);\n\t\tmove(&x,&y,direction);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\nint iskabe(char kabe[9][6],int x,int y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\tif(x<=0)return 0;\n\t\t\tif(kabe[y*2][x-1]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tif(x>4)return 0;\n\t\t\tif(kabe[y*2][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tif(y<=0)return 0;\n\t\t\tif(kabe[y*2-1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tif(y>4)return 0;\n\t\t\tif(kabe[y*2+1][x]=='1')return 1; else return 0;\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint getleft(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return DOWN;break;\n\t\tcase RIGHT:return UP;break;\n\t\tcase UP:return LEFT;break;\n\t\tcase DOWN:return RIGHT;break;\n\t}\n\treturn 0;\n}\n\nint getright(int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:return UP;break;\n\t\tcase RIGHT:return DOWN;break;\n\t\tcase UP:return RIGHT;break;\n\t\tcase DOWN:return LEFT;break;\n\t}\n\treturn 0;\n}\n\nvoid move(int* x,int* y,int dir) {\n\tswitch(dir) {\n\t\tcase LEFT:\n\t\t\t(*x)--;\n\t\t\tprintf(\"L\");\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\t(*x)++;\n\t\t\tprintf(\"R\");\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\t(*y)--;\n\t\t\tprintf(\"U\");\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\t(*y)++;\n\t\t\tprintf(\"D\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar mp[36];int i;\nvoid prt(int d){\n//\tprintf(\"%d %d\\t%c\\n\",i/6,i%6,\"RDLU\"[d]);\n\tputchar(\"RDLU\"[d]);\n}\nint main(void){\n\tint j,d=0,t[]={1,6,-1,-6};\n\tfor(j=1;j<5;j++)getchar()-'0'?mp[j+6]=8,mp[j]=2:0;\n\tgetchar();\n\tfor(i=1;i<5;i++){\n\t\tfor(j=0;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=1,mp[i*6+1+j]|=4:0;\n\t\tgetchar();\n\t\tfor(j=1;j<5;j++)\n\t\t\tgetchar()-'0'?mp[i*6+j]|=2,mp[i*6+6+j]|=8:0;\n\t\tgetchar();\n\t}\n\ti=0;\n\tdo{\n\t\tj=0;\n\t\tmp[i]&1<<d||(i+=j=t[d]);\n\t\tif(mp[i]&1<<(d+1&3)){\n\t\t\t!j&&mp[i]&1<<d?d=d+3&3:0;\n\t\t\tprt(d);\n\t\t}\n\t\telse{\n\t\t\ti+=t[d=d+1&3];\n\t\t\tif(mp[i]&1<<(d+1&3))prt(d);\n\t\t\telse if(i)i+=t[d=d+1&3];\n\t\t}\n\t}while(i);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint w[25],i,d,t[]={1,5,-1,-5};\nint main(void){\n\tfor(i=0;i<9;i++){\n\t\tif(i&1)for(d=0;d<5;d++)getchar()-'0'?w[i/2*5+d]|=2,w[i/2*5+d+5]|=8:0;\n\t\telse for(d=0;d<4;d++)getchar()-'0'?w[i/2*5+d]|=1,w[i/2*5-~d]|=4:0;\n\t\tgetchar();\n\t}\n\td=!putchar('R');\n\tfor(i=1;d|i;d&=3)\n\t\tw[i]&1<<d?i+=t[d],putchar(\"RDLU\"[d]),w[i]&1<<(d+3&3)&&--d:++d;\n\n\ti=!puts(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n\tchar stage[10][10]={};\n\tchar state[2]={};\n\tint x=0,y=0;\n\tint i,j;\n\t\n\t\n\tfor(i=0;i<9;i++)scanf(\"%s\",stage[i]);\n\tstate[0]='R';\n\twhile(1)\n\t{\n\t\tif((x==0 && y==0 && state[0]!='R') || (x==0 && y==1 && state[0]=='U'))\n\t\t{\n\t\t\tif(state[0]=='U')\n\t\t\t\tprintf(\"U\\n\");\n\t\t\telse printf(\"L\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(state[0]=='R')\n\t\t{\n\t\t\tif(stage[y-1][x+1]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y][x+1]=='1' && x<=3)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+1][x+1]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse\n\t\t\t\tstate[0]='L';\n\t\t\tprintf(\"R\");\n\t\t}\n\t\telse if(state[0]=='D')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+2][x]=='1' && y<=6)\n\t\t\t{\n\t\t\t\ty+=2;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y+1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse\n\t\t\t\tstate[0]='U';\n\t\t\tprintf(\"D\");\n\t\t}\n\t\telse if(state[0]=='L')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse\n\t\t\t\tstate[0]='R';\n\t\t\tprintf(\"L\");\n\t\t}\n\t\telse if(state[0]=='U')\n\t\t{\n\t\t\tif(stage[y-1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-2][x]=='1' && y>=2)\n\t\t\t{\n\t\t\t\ty-=2;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && x<=3)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse\n\t\t\t\tstate[0]='D';\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main()\n{\n\tchar stage[10][10]={};\n\tchar state[2]={};\n\tint x=0,y=0;\n\tint i,j;\n\t\n\t\n\tfor(i=0;i<9;i++)scanf(\"%s\",stage[i]);\n\tstate[0]='R';\n\twhile(1)\n\t{\n\t\tif(x==0 && y==0 && state[0]!='R')\n\t\t{\n\t\t\tif(state[0]=='U')\n\t\t\t\tprintf(\"\\n\");\n\t\t\telse printf(\"L\\n\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(state[0]=='R')\n\t\t{\n\t\t\tif(stage[y-1][x+1]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y][x+1]=='1' && x<=3)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+1][x+1]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\tprintf(\"R\");\n\t\t}\n\t\telse if(state[0]=='D')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\telse if(stage[y+2][x]=='1' && y<=6)\n\t\t\t{\n\t\t\t\ty+=2;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y+1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\tprintf(\"D\");\n\t\t}\n\t\telse if(state[0]=='L')\n\t\t{\n\t\t\tif(stage[y+1][x]=='1' && y<=7)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tstate[0]='D';\n\t\t\t}\n\t\t\telse if(stage[y][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && y>=1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\tprintf(\"L\");\n\t\t}\n\t\telse if(state[0]=='U')\n\t\t{\n\t\t\tif(stage[y-1][x-1]=='1' && x>=1)\n\t\t\t{\n\t\t\t\tx--;\n\t\t\t\ty--;\n\t\t\t\tstate[0]='L';\n\t\t\t}\n\t\t\telse if(stage[y-2][x]=='1' && y>=2)\n\t\t\t{\n\t\t\t\ty-=2;\n\t\t\t\tstate[0]='U';\n\t\t\t}\n\t\t\telse if(stage[y-1][x]=='1' && x<=3)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tstate[0]='R';\n\t\t\t}\n\t\t\tprintf(\"U\");\n\t\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid change(int,int);\nint muki = 0,flag = 0;\n\nint main(){\n\tint i,j,x = 0,y = 0,wall_x[4][5],wall_y[5][4];\n\tfor(i = 0;i < 9;i++){\n\t\tif(i % 2 == 0) for(j = 0;j < 4;j++) scanf(\"%1d\",&wall_x[j][i / 2]);\n\t\telse for(j = 0;j < 5;j++) scanf(\"%1d\",&wall_y[j][(i - 1)/ 2]);\n\t}\n\tdo{\n\t\tif(muki == 0){\n\t\t\tif(x != 4 && wall_x[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tchange(x,y);\n\t\t\t\tputchar('R');\n\t\t\t\tx++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 1){\n\t\t\tif(y != 4 && wall_y[x][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tchange(x,y);\n\t\t\t\tputchar('D');\n\t\t\t\ty++;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 2){\n\t\t\tif(x != 0 && wall_x[x - 1][y] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tchange(x,y);\n\t\t\t\tputchar('L');\n\t\t\t\tx--;\n\t\t\t}else change(x,y);\n\t\t}else if(muki == 3){\n\t\t\tif(y != 0 && wall_y[x][y - 1] == 1){\n\t\t\t\tflag = 0;\n\t\t\t\tchange(x,y);\n\t\t\t\tputchar('U');\n\t\t\t\ty--;\n\t\t\t}else change(x,y);\n\t\t}\n\t}while(x != 0 || y != 0);\n\tputs(\"\");\n\treturn 0;\n}\n\nvoid change(int x,int y){\n\tint i;\n\tif(!flag){\n\t\tflag = 1;\n\t\tmuki = (muki + 3) % 4;\n\t}\n\telse muki = (muki + 1) % 4;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_UNIT_SIZE 10000\n#define MAX_LINE_LENGTH 1000\n\ntypedef struct {\n    int x, y;\n} vector_t;\n\nvoid complex_mul(const vector_t *v1, const vector_t *v2, vector_t *t) {\n    t->x = v1->x * v2->x - v1->y * v2->y;\n    t->y = v1->x * v2->y + v1->y * v2->x;\n}\n\nchar *bufp[100], *wall[1000], path[10000];\nconst vector_t next_dir[] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nconst char dir_char[][3] = {\n    {' ', 'U', ' '}, {'L', ' ', 'R'}, {' ', 'D', ' '}\n};\n\nint main(void) {\n    int W, H, i;\n    int buf_idx, buf_len, path_idx, nx, ny;\n    char *buf;\n    vector_t pos, dir, ndir;\n\n    buf_idx = 0;\n    buf_len = 0;\n    buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n    bufp[buf_idx++] = buf;\n    for (i = 0, W = 0; gets(buf) != NULL; i++) {\n        wall[i] = buf;\n        if (W == 0) W = strlen(buf);\n        buf_len += strlen(buf) + 1;\n        if (buf_len + MAX_LINE_LENGTH > BUF_UNIT_SIZE) {\n            buf = (char*)malloc(BUF_UNIT_SIZE * sizeof(char));\n            bufp[buf_idx++] = buf;\n            buf_len = 0;\n        }\n        else {\n            buf += strlen(buf) + 1;\n        }\n    }\n    H = i;\n\n    path_idx = 0;\n    path[path_idx++] = 'R';\n    pos.x = 0;\n    pos.y = 0;\n    dir.x = 1;\n    dir.y = 0;\n    while (1) {\n        for (i = 0; i < 3; i++) {\n            complex_mul(&dir, &next_dir[i], &ndir);\n            if ((pos.y&1) == 0) {\n                ny = pos.y + ndir.y;\n                nx = pos.x + ndir.x + (dir.x > 0)*((ny+2)&1);\n            }\n            else {\n                ny = pos.y + ndir.y + dir.y;\n                nx = pos.x + ndir.x - (ndir.x > 0);\n            }\n            if (nx < 0 || W+(ny&1) <= nx || ny < 0 || H <= ny) continue;\n            if (wall[ny][nx] == '1') break;\n        }\n        if (i == 3) {\n            dir.x = - dir.x;\n            dir.y = - dir.y;\n        }\n        else {\n            pos.x = nx;\n            pos.y = ny;\n            dir.x = ndir.x;\n            dir.y = ndir.y;\n        }\n        path[path_idx++] = dir_char[1+dir.y][1+dir.x];\n\n        if ((pos.x == 0 && pos.y == 0 && dir.x == -1) ||\n            (pos.x == 0 && pos.y == 1 && dir.y == -1)) break;\n    }\n\n    path[path_idx] = '\\0';\n    puts(path);\n\n    for (i = 0; i < buf_idx; i++) {\n        free(bufp[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "w[25],i;main(d){for(;i<9;i++){if(i&1)for(d=0;d<5;d++)getchar()-48?w[i/2*5+d]|=2,w[i/2*5+d+5]|=8:0;else for(d=0;d<4;d++)getchar()-48?w[i/2*5+d]|=1,w[i/2*5-~d]|=4:0;getchar();}d=!putchar(82);for(i=1;d|i;d&=3)w[i]&1<<d?i+=\"GKEA\"[d]-70,putchar(\"RDLU\"[d]),w[i]&1<<(d+3&3)&&--d:++d;i=!puts(\"\");}"
  },
  {
    "language": "C",
    "code": "X[]={1,0,-1,0},Y[]={0,1,0,-1},s[19][19];char *D=\"RDLU\";\nmain(x,y,i,j,z){\n\tmemset(s,11,sizeof(s));\n\tx=y=5;\n\tfor(j=1;j<=2*y+1;j++)for(i=1;i<=2*x+1;i++)s[i][j]=0;\n\tfor(j=2;j<=2*y;getchar(),j++)\n\t\tfor(i=(j&1)?2:3;i<2*x+1;i+=2){\n\t\t\ts[i][j]=getchar()-'0';\n\t\t}\n\tputchar('R');\n\tfor(z=0,x=4,y=2;x!=2||y!=2;){\n\t\tz=(z+3)%4;\n\t\tfor(;!s[x+X[z]][y+Y[z]];z=(z+1)%4);\n\t\tx+=X[z]*2,y+=Y[z]*2;\n\t\tputchar(D[z]);\n\t}\nexit(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol0 0037: Path on a Grid\n// 2017.7.31\n\n#include <stdio.h>\n\nchar *gets(char *);\n\n#define MAX  6\n#define R 0\n#define L 1\n#define U 2\n#define D 3\n\nchar a[MAX][MAX];\nint next[4][4] = {\n\t{1,2,4,8},\n\t{4,8,1,2},\n\t{8,1,2,4},\n\t{2,4,8,1} };\n\nint r, c, last;\n\nvoid move(int k)\n{\n//\tprintf(\"Move (r,c)=(%d,%d), last %d, next %d\\n\", r, c, last, k);\n\tif (k == 1) putchar('U'), r--, last = U;\n\telse if (k == 2) putchar('R'), c++, last = R;\n\telse if (k == 4) putchar('D'), r++, last = D;\n\telse putchar('L'), c--, last = L;\n}\n\nint main()\n{\n\tint i;\n\tchar buf[50];\n\n\tfor (i = 0, r = 0; gets(buf) != NULL; i++) {\n\t\tr = i / 2;\n\t\tif (i & 1) {\n\t\t\tfor (c = 0; c < 5; c++) {\n\t\t\t\tif (buf[c] == '1') \ta[r][c] |= 4, a[r + 1][c] |= 1;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (c = 0; c < 4; c++) {\n\t\t\t\tif (buf[c] == '1') \ta[r][c] |= 2, a[r][c + 1] |= 8;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tfor (r = 0; r < 5; r++) {\n\t\tfor (c = 0; c < 5; c++) printf(\"%d \", a[r][c]);\n\t\tprintf(\"\\n\");\n\t}\n#endif\n\tr = c = 0, last = R;\n\tdo {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (a[r][c] & next[last][i]) {\n\t\t\t\tmove(next[last][i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (r || c);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y+1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ndp[1]=\"R\";\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\ngotoDirection(dirl,x,y);\nSystem.out.print(dirl);\ngotoPath(x,y,dirl);\n}\nelse if(cangoNext(dir,x,y)){\ngotoDirection(dir,x,y);\nSystem.out.print(dir);\ngotoPath(x,y,dir);\n}\nelse if(cangoNext(dirr,x,y)){\ngotoDirection(dirr,x,y);\nSystem.out.print(dirr);\ngotoPath(x,y,dirr);\n}\nelse{\ngotoDirection(dirb,x,y);\nSystem.out.print(dirb);\ngotoPath(x,y,dirb);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tcreateGrid();\n\t\tMan saburou = new Man(Grid.INITIAL_VECTOR, Grid.X_START_POSITION, Grid.Y_START_POSITION);\n\t\tdo{\n\t\t\tsaburou.go();\n\t\t}while(!saburou.goalIn());\n\t}\n\tprivate static void createGrid() throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\t\tfor(int i = 0; i < Grid.getGridXLength(); i++){\n\t\t\tbuf = br.readLine();\n\t\t\tchar[] tmpX = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpX.length; j++){\n\t\t\t\tGrid.setGridX(i, j, tmpX[j] - '0');\n\t\t\t}\n\t\t\tif(i == Grid.getGridYLength())\tbreak;\n\t\t\tbuf=br.readLine();\n\t\t\tchar[] tmpY = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpY.length; j++){\n\t\t\t\tGrid.setGridY(i, j, tmpY[j] - '0');\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Grid{\n\tpublic static final int X_START_POSITION = 0;\n\tpublic static final int Y_START_POSITION = 0;\n\tpublic static final int INITIAL_VECTOR = Man.RIGHT;\n\tpublic static final int WALL_EXIST = 1;\n\tprivate static int[][] gridX = new int[5][4];\n\tprivate static int[][] gridY = new int[4][5];\n\tpublic static void setGridX(int i, int j, int exist) {\n\t\tGrid.gridX[i][j] = exist;\n\t}\n\tpublic static void setGridY(int i, int j, int exist) {\n\t\tGrid.gridY[i][j] = exist;\n\t}\n\tpublic static int getGridXLength() {\n\t\treturn gridX.length;\n\t}\n\tpublic static int getGridYLength() {\n\t\treturn gridY.length;\n\t}\n\tpublic static boolean gridXisWall(int i, int j){\n\t\treturn (gridX[i][j] == WALL_EXIST) ? true : false;\n\t}\n\tpublic static boolean gridYisWall(int i, int j){\n\t\treturn (gridY[i][j] == WALL_EXIST) ? true : false;\n\t}\n}\nclass Man{\n\tpublic static final int UP = 1;\n\tpublic static final int DOWN = 2;\n\tpublic static final int LEFT = 3;\n\tpublic static final int RIGHT = 4;\n\t\n\tprivate int vector;\n\tprivate int x;\n\tprivate int y;\n\tpublic Man(int initialVector, int startX, int startY) {\n\t\tvector = initialVector;\n\t\tx = startX;\n\t\ty = startY;\n\t}\n\t/**\n\t * 前回の移動後に決定した方向へ移動する\n\t */\n\tpublic void go(){\n\t\tswitch(vector){\n\t\tcase UP:\n\t\t\tgoUp();\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tgoDown();\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tgoLeft();\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tgoRight();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/**\n\t * 初期位置に戻ってきているか（ゴールしているか）判定する\n\t * @return\tゴールしているか\n\t */\n\tpublic boolean goalIn(){\n\t\treturn (x == Grid.X_START_POSITION && y == Grid.Y_START_POSITION);\n\t}\n\tprivate void goRight(){\n\t\tx++;\n\t\tSystem.out.print(\"R\");\n\t\t//上方向に進む\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\t//右方向に進む\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\t//下方向に進む\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t}\n\tprivate void goLeft(){\n\t\tx--;\n\t\tSystem.out.print(\"L\");\n\t\t//下方向に進む\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\t//左方向に進む\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\t//上方向に進む\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t}\n\tprivate void goUp(){\n\t\ty--;\n\t\tSystem.out.print(\"U\");\n\t\t//左方向に進む\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\t//上方向に進む\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\t//右方向に進む\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t}\n\tprivate void goDown(){\n\t\ty++;\n\t\tSystem.out.print(\"D\");\n\t\t//右方向に進む\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\t//下方向に進む\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\t//左方向に進む\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t}\n\tprivate boolean findUpWall(){\n\t\tif(y == 0)\treturn false;\n\t\treturn\tGrid.gridYisWall(y - 1,x);\n\t}\n\tprivate boolean findDownWall(){\n\t\tif(y == 4)\treturn false;\n\t\treturn Grid.gridYisWall(y, x);\n\t}\n\tprivate boolean findLeftWall(){\n\t\tif(x == 0)\treturn false;\n\t\treturn Grid.gridXisWall(y, x - 1);\n\t}\n\tprivate boolean findRightWall(){\n\t\tif(x == 4)\treturn false;\n\t\treturn Grid.gridXisWall(y, x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Path on a Grid\npublic class Main{\n\n\tvoid run(){\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\tchar[] ch = {'U','R','D','L'};\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean[][] e = new boolean[25][25];\n\t\tint h = 0, t = 0;\n\t\tfor(int x=0;x<9;x++){\n\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<s.length;j++){\n\t\t\t\tif(s[j]=='0')continue;\n\t\t\t\tif(t==0)e[h*5+j][h*5+j+1] = e[h*5+j+1][h*5+j] = true;\n\t\t\t\telse e[h*5+j][(h+1)*5+j] = e[(h+1)*5+j][h*5+j] = true;\n\t\t\t}\n\t\t\tif(t==1)h++;\n\t\t\tt=(t+1)%2;\n\t\t}\n\t\tint i=0, j=0, d=1;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean con = true;\n\t\twhile(con){\n\t\t\tfor(int k=3;k<=6;k++){\n\t\t\t\tint nd = (d+k)%4;\n\t\t\t\tint ni = i+move[nd][0];\n\t\t\t\tint nj = j+move[nd][1];\n\t\t\t\tif(0<=ni&&ni<5&&0<=nj&&nj<5&&e[i*5+j][ni*5+nj]){\n\t\t\t\t\tsb.append(ch[nd]);\n\t\t\t\t\ti = ni; j = nj; d = nd;\n\t\t\t\t\tif(i==0&&j==0)con = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  static boolean[][] wall = new boolean[9][];\n  static int[] point = {0,0,0};\n\n  public static boolean[] lineSet(String str){\n    boolean[] line = new boolean[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n      if (str.charAt(i) == '0') {\n        line[i] = false;\n      }\n      else {\n        line[i] = true;\n      }\n    }\n    return line;\n  }\n\n  public static void directionR(){\n    if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n    else {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n  }\n  public static void directionD(){\n    if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n    else {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n  }\n  public static void directionL(){\n    if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n    else {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n  }\n  public static void directionU(){\n    if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n    else {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n  }\n\n  public static void direction(){\n    switch(point[2]) {\n      case 0:\n        directionR();\n        break;\n      case 1:\n        directionD();\n        break;\n      case 2:\n        directionL();\n        break;\n      case 3:\n        directionU();\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    for (int i = 0; i < 9; i++) {\n      String str = sc.next();\n      wall[i] = lineSet(str);\n    }\n    while(true) {\n      direction();\n      if (point[0] == 0 && point[1] == 0) {\n        break;\n      }\n    }\n    System.out.println(\"\");\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int size = 9;\n\n        int[][] path = new int[size][size];\n        for (int i = 0; i < size; i++) {\n            String S = sc.next();\n\n            if (i % 2 == 0) {\n                Arrays.fill(path[i], 1);\n\n                for (int j = 0; j < 4; j++) {\n                    int c = Integer.parseInt(S.split(\"\")[j]);\n\n                    path[i][j * 2 + 1] = c;\n                }\n            } else {\n                for (int j = 0; j < 5; j++) {\n                    int c = Integer.parseInt(S.split(\"\")[j]);\n                    path[i][j * 2] = c;\n                }\n            }\n        }\n\n        int[] vx = {-1, 0, 1, 0};\n        int[] vy = {0, -1, 0, 1};\n        List<String> to = new ArrayList<>(Arrays.asList(\"L\", \"U\", \"R\", \"D\"));\n\n        int nx = 0;\n        int ny = 0;\n\n        int dir = 2;\n        StringBuilder move = new StringBuilder();\n\n        while (true) {\n            for (int i = 3; i < 7; i++) {\n                int x = nx + vx[(i + dir) % 4];\n                int y = ny + vy[(i + dir) % 4];\n                int xx = x + vx[(i + dir) % 4];\n                int yy = y + vy[(i + dir) % 4];\n\n                if (!judge(x, y, size)) continue;\n                if (!judge(xx, yy, size)) continue;\n                if (path[y][x] == 0) continue;\n                if (path[yy][xx] == 0) continue;\n\n                nx = xx;\n                ny = yy;\n\n                dir = (i + dir) % 4;\n\n                move.append(to.get(dir));\n                break;\n            }\n            if (nx == 0 && ny == 0) {\n                break;\n            }\n        }\n        System.out.println(move.toString());\n    }\n\n    private static boolean judge(int x, int y, int size) {\n        return 0 <= x && x < size && 0 <= y && y < size;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean next = true;\n\t\twhile(next){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t\t\n\t\t\t\t\tif(x == 1 && y == 1) next = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n    static int[][] grid;\n    static int MAX_HEIGHT = 9;\n    static int MAX_WIDTH = 9;\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tgrid = new int[MAX_HEIGHT][MAX_WIDTH];\n\tString line;\n\tint width, n, pos;\n\tfor (int i = 0; i < 9; i++) {\n\t    line = scan.nextLine();\n\t    width = 0;\n\t    for (int j = 0; j < line.length(); j++) {\n\t\tn = Integer.parseInt(line.substring(j, j+1));\n\t\tif (n == 0) {\n\t\t    continue;\n\t\t}\n\t\tif (i % 2 == 0) {\n\t\t    pos = j * 2;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i][pos+1] = 1;\n\t\t    grid[i][pos+2] = 1;\n\t\t} else {\n\t\t    pos = j*2;\n\t\t    grid[i-1][pos] = 1;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i+1][pos] = 1;\n\t\t}\n\t    }\n\t}\n\tsolve();\n\tSystem.out.println();\n    }\n    \n    static void solve () {\n\tint width = 0, height = 0, direction = 0;\n\tint[] data = new int[2];\n\tint count = 0;\n\twhile (true) {\n\t    data = move(width, height, direction);\n\t    width = data[0];\n\t    height = data[1];\n\t    direction = nextDirection(width, height, direction);\n\t    if (width == 0 && height == 0) {\n\t\tbreak;\n\t    }\n\t}\n    }\n    \n    static int[] move (int width, int height, int direction) {\n\tint[] data = new int[2];\n\tif (direction == 0) {\n\t    data = moveRight(width, height);\n\t} else if (direction == 1) {\n\t    data = moveLeft(width, height);\n\t} else if (direction == 2) {\n\t    data = moveUp(width, height);\n\t} else if (direction == 3) {\n\t    data = moveDown(width, height);\n\t}\n\treturn data;\n    }\n\n    static int[] moveRight (int width, int height) {\n\tint[] data = new int[2];\n\twhile (width+2 < MAX_WIDTH && grid[height][width+2] == 1 && grid[height][width+1] == 1) {\n\t    width+=2;\n\t    System.out.print(\"R\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveLeft (int width, int height) {\n\tint[] data = new int[2];\n\twhile (width-2 >= 0 && grid[height][width-2] == 1 && grid[height][width-1] == 1) {\n\t    width-=2;\n\t    System.out.print(\"L\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveUp (int width, int height) {\n\tint[] data = new int[2];\n\twhile (height-2 >= 0 && grid[height-2][width] == 1 && grid[height-1][width] == 1) {\n\t    height -=2;\n\t    System.out.print(\"U\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveDown (int width, int height) {\n\tint[] data = new int[2];\n\twhile (height+2 < MAX_HEIGHT && grid[height+2][width] == 1 && grid[height+1][width] == 1) {\n\t    height +=2;\n\t    System.out.print(\"D\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int nextDirection (int width, int height, int prevDirection) {\n\tint next = 0;\n\tif (prevDirection == 0 || prevDirection == 1) {\n\t    if (isUp(width, height)) {\n\t\tnext = 2;\n\t    } else if (isDown(width, height)) {\n\t\tnext = 3;\n\t    }\n\t} else if (prevDirection == 2 || prevDirection == 3) {\n\t    if (isRight(width, height)) {\n\t\tnext = 0;\n\t    } else if (isLeft(width, height)) {\n\t\tnext = 1;\n\t    }\n\t}\n\treturn next;\n    }\n\n    static boolean isUp (int width, int height) {\n\tif (height == 0) {\n\t    return false;\n\t}\n\tif (grid[height - 1][width] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n\n    static boolean isDown (int width, int height) {\n\tif (height == MAX_HEIGHT - 1) {\n\t    return false;\n\t}\n\tif (grid[height+1][width] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n    static boolean isRight (int width, int height) {\n\tif (width == MAX_WIDTH - 1) {\n\t    return false;\n\t}\n\tif (grid[height][width + 1] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n    static boolean isLeft (int width, int height) {\n\tif (width == 0) {\n\t    return false;\n\t}\n\tif (grid[height][width - 1] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint times = 0;\n\t\tint[][][] map = new int [5][5][4];\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tm1 = new int[5][4];\n\t\t}\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tfor(int[] m2:m1){\n\t\t\t\tm2 = new int[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(times < 9){\n\t\t\tString str = sc.nextLine();\n\t\t\tif(times % 2 == 0){\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tmap[times/2][i][0] = Integer.parseInt(String.valueOf(str.charAt(i))); // right\n\t\t\t\t}\n\t\t\t\tfor(int i = 1;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][2] = Integer.parseInt(String.valueOf(str.charAt(i-1))); // left\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][1] = Integer.parseInt(String.valueOf(str.charAt(i))); // down\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2+1][i][3] = Integer.parseInt(String.valueOf(str.charAt(i))); // up\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttimes++;\n\t\t}\n\t\t\n\t\tint dir = 0;\n\t\tint x = 1,y = 0;\n\t\tSystem.out.print(\"R\");\n\t\t\n\t\twhile(x != 0 || y != 0){\n\t\t\tif(dir == 0){\n\t\t\t\tif(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 1){\n\t\t\t\tif(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 2){\n\t\t\t\tif(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 3){\n\t\t\t\tif(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean is;\n\t\twhile(true){\n\t\t\tis = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\tis = false;\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is){\n\t\t\t\tvec = (vec + 2) % 4;\n\t\t\t\tSystem.out.print(opr[vec]);\n\t\t\t}\n\t\t\tif(y == 1 && x == 1) break;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic int[][] mv = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\n\tstatic char[] c = { 'U', 'R', 'D', 'L' };\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tboolean[][] e = new boolean[25][25];\n\t\tint h = 0, t = 0;\n\t\tfor (int x = 0; x < 9; x++) {\n\t\t\tchar[] s = br.readLine().toCharArray();\n\t\t\tfor (int j = 0; j < s.length; j++) {\n\t\t\t\tif (s[j] == '0') continue;\n\t\t\t\tif (t == 0) {\n\t\t\t\t\te[h * 5 + j][h * 5 + j + 1] = e[h * 5 + j + 1][h * 5 + j] = true;\n\t\t\t\t} else {\n\t\t\t\t\te[h * 5 + j][(h + 1) * 5 + j] = e[(h + 1) * 5 + j][h * 5 + j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == 1) h++;\n\t\t\tt = (t + 1) % 2;\n\t\t}\n\t\tint i = 0, j = 0, d = 1;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean f = true;\n\t\twhile (f) {\n\t\t\tfor (int k = 3; k <= 6; k++) {\n\t\t\t\tint nd = (d + k) % 4;\n\t\t\t\tint ni = i + mv[nd][0];\n\t\t\t\tint nj = j + mv[nd][1];\n\t\t\t\tif (0 <= ni && ni < 5 && 0 <= nj && nj < 5 && e[i * 5 + j][ni * 5 + nj]) {\n\t\t\t\t\tsb.append(c[nd]); i = ni; j = nj; d = nd;\n\t\t\t\t\tif (i == 0 && j == 0) f = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        doit(args, System.in, System.out);\n    }\n\n    static void doit(String[] args, InputStream in, PrintStream out)\n            throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        List<String> lines = new ArrayList<String>();\n        while (true) {\n            String line = reader.readLine();\n            if (line == null || line.isEmpty()) {\n                break;\n            }\n            lines.add(line);\n        }\n        int width = lines.get(0).length();\n        int height = lines.size() / 2;\n        int[][] nodes = new int[height + 1][width + 1];\n        for (int i = 0; i < lines.size(); i++) {\n            String line = lines.get(i);\n            int y = i / 2;\n            if (i % 2 == 0) {\n                for (int x = 0; x < width; x++) {\n                    if (line.charAt(x) == '1') {\n                        nodes[y][x] |= 1;\n                        nodes[y][x + 1] |= 1 << 2;\n                    }\n                }\n            } else {\n                for (int x = 0; x <= width; x++) {\n                    if (line.charAt(x) == '1') {\n                        nodes[y][x] |= 1 << 1;\n                        nodes[y + 1][x] |= 1 << 3;\n                    }\n                }\n            }\n        }\n        int cx = 0;\n        int cy = 0;\n        int cd = 0;\n        while (true) {\n            int node = nodes[cy][cx];\n            for (int i = 3; i <= 6; i++) {\n                int nd = (cd + i) % 4;\n                int mask = 1 << nd;\n                if ((node & mask) > 0) {\n                    cd = nd;\n                    break;\n                }\n            }\n            if (cd == 0) {\n                cx += 1;\n            } else if (cd == 1) {\n                cy += 1;\n            } else if (cd == 2) {\n                cx -= 1;\n            } else {\n                cy -= 1;\n            }\n            out.print(chars[cd]);\n            if (cx == 0 && cy == 0) {\n                out.println();\n                break;\n            }\n        }\n    }\n\n    private static final char[] chars = { 'R', 'D', 'L', 'U' };\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final char cDir[] = {\n\t\t'U', 'R', 'D', 'L'\n\t};\n\t\n\tpublic static final int pDir[][] = {\n\t\t{0, -1}, {1, 0}, {0, 1}, {-1, 0}\n\t};\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tchar map[][] = new char [9][5];\n\t\tboolean neighbor[][][] = new boolean [5][5][4];\n\t\tint hand[] = {0, 0};\t//現在の座標\n\t\tint iDir = 1;\t\t\t//cDir や pDirに対応している。\n\t\tString answer = new String();\n\t\t\n\t\t//入力処理\n\t\tfor(int i=0; i<9; i++){\n\t\t\tmap[i] = scan.next().toCharArray();\n\t\t}\n\t\t\n\t\t//neighbor初期化\n\t\tfor(int i=0; i<5; ++i){\n\t\t\tfor(int j=0; j<5; ++j){\n\t\t\t\t//Up\n\t\t\t\tneighbor[i][j][0] = 0<=(i*2-1) ? (map[i*2 -1][j] == '1') : false;\n\t\t\t\t//Right\n\t\t\t\tneighbor[i][j][1] = j<(5-1) ? (map[i*2][j] == '1') : false;\n\t\t\t\t//Down\n\t\t\t\tneighbor[i][j][2] = (i*2+1)<9 ? (map[i*2+1][j] == '1') : false;\n\t\t\t\t//Left\n\t\t\t\tneighbor[i][j][3] = 0<=(j-1) ? (map[i*2][j-1] == '1') : false; \n\t\t\t}\n\t\t}\n\t\t\n\t\t//本体\n\t\tint x=0, y=0;\n\t\twhile(true){\n\t\t\t//探索\n\t\t\tx = hand[0]; y = hand[1];\n\t\t\tif(neighbor[y][x][(iDir+3)%4]){\n\t\t\t\tiDir = (iDir+3)%4;\n\t\t\t}else if(neighbor[y][x][(iDir+0)%4]){\n\t\t\t\tiDir = (iDir+0)%4;\n\t\t\t}else if(neighbor[y][x][(iDir+1)%4]){\n\t\t\t\tiDir = (iDir+1)%4;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"×\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//結果処理\n\t\t\thand[0] += pDir[iDir][0];\n\t\t\thand[1] += pDir[iDir][1];\n\t\t\tanswer += cDir[iDir];\n\t\t\t//動いた先が点Aだったらループから抜ける。\n\t\t\tif(hand[0]==0 && hand[1]==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(answer);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n\tprivate static final int R = 0;\n\tprivate static final int L = 1;\n\tprivate static final int U = 2;\n\tprivate static final int D = 3;\n\n\tString w[] = new String[5];\n\tString h[] = new String[4];\n\tint Move,x,y;\n\n\tWall(String w[],String h[]) {\n\t\tfor (int i=0;i<4;i++) {\n\t\t\tthis.w[i] = w[i];\n\t\t\tthis.h[i] = h[i];\n\t\t}\n\t\tthis.w[4] = w[4];\n\t\tthis.Move = R;\n\t\tthis.x = 1;\n\t\tthis.y = 0;\n\t\tSystem.out.print(\"R\");\n\t}\n\n\tvoid Walked() {\n\t\twhile (true) {\n\t\t\tif (this.x==0&&this.y==0) break;\n\t\t\tif (this.Move==R) {\n\t\t\t\twhile (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tif (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n\t\t\t\t\t\tthis.y--;\n\t\t\t\t\t\tthis.x++;\n\t\t\t\t\t\tthis.Move = U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==R) this.Move = D;\n\t\t\t} else if (this.Move==L) {\n\t\t\t\twhile (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tif (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\t\tthis.Move = D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==L) {\n\t\t\t\t\tthis.x++;\n\t\t\t\t\tthis.y--;\n\t\t\t\t\tthis.Move = U;\n\t\t\t\t}\n\t\t\t} else if (this.Move==U) {\n\t\t\t\twhile (this.y>=0&&h[this.y].charAt(this.x)=='1') {\t\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tif (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n\t\t\t\t\t\tthis.x--;\n\t\t\t\t\t\tthis.Move = L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==U) {\n\t\t\t\t\tthis.y++;\n\t\t\t\t\tthis.Move = R;\n\t\t\t\t}\n\t\t\t} else if (this.Move==D) {\n\t\t\t\twhile (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tif (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n\t\t\t\t\t\ty++;\t\t\t\t\t\n\t\t\t\t\t\tthis.Move = R;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==D) {\n\t\t\t\t\tthis.x--;\n\t\t\t\t\tthis.Move = L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\ttry {\n\t\t\tString w[] = new String[5];\n\t\t\tString h[] = new String[4];\n\t\t\tfor (int i=0;i<4;i++) {\n\t\t\t\tw[i] = br.readLine();\n\t\t\t\th[i] = br.readLine();\n\t\t\t}\n\t\t\tw[4] = br.readLine();\n\n\t\t\tWall wall = new Wall(w,h);\n\t\t\twall.Walked();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tGrid[][] grid = new Grid[6][6];\n\t\tfor(int i = 0; i < 36; i++){\n\t\t\tgrid[i/6][i%6] = new Grid();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tString tmp = br.readLine();\n\t\t\t\n\t\t\tif(i%2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].top = true;\n\t\t\t\t\t\t//System.out.println(\"top\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].left = true;\n\t\t\t\t\t\t//System.out.println(\"left\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint currentX = 1;\n\t\tint currentY = 0;\n\t\tfinal int R = 0;\n\t\tfinal int D = 1;\n\t\tfinal int U = 2;\n\t\tfinal int L = 3;\n\t\t\n\t\tint mode = R;\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile(true){\n\t\t\tif(mode == R){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX + 1].left){\n\t\t\t\t\tmode = U;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX + 1].top){\n\t\t\t\t\tcurrentX++;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = D;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"R\");\n\t\t\t}\n\t\t\telse if(mode == D){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY+1][currentX].top){\n\t\t\t\t\tmode = R;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX].left){\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = L;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"D\");\n\t\t\t}\n\t\t\telse if(mode == U){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].top){\n\t\t\t\t\tmode = L;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY - 1][currentX + 1].left){\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = R;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"U\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].left){\n\t\t\t\t\tmode = D;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY][currentX - 1].top){\n\t\t\t\t\tcurrentX--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = U;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"L\");\n\t\t\t}\n\t\t\t\n\t\t\tif(currentX == 1 && currentY == 1 && mode == L){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(currentX == 0 && currentY == 1 && mode == U){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t}\n\n}\n\nclass Grid {\n\tboolean top = false;\n\tboolean left = false;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint[][] mapA = new int[5][4];\n\tint[][] mapB = new int[4][5];\n\tint x, y, d;\n\tboolean flag;\n\t\n\tvoid U(){\n\t\tif(flag==true && y>0 && mapB[y-1][x]==1){\n\t\t\td=0;\n\t\t\ty--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"U\");\n\t\t}\n\t}\n\t\n\tvoid R(){\n\t\tif(flag==true && x<4 && mapA[y][x]==1){\n\t\t\td=1;\n\t\t\tx++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"R\");\n\t\t}\n\t}\n\t\n\tvoid D(){\n\t\tif(flag==true && y<4 && mapB[y][x]==1){\n\t\t\td=2;\n\t\t\ty++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"D\");\n\t\t}\n\t}\n\t\n\tvoid L(){\n\t\tif(flag==true && x>0 && mapA[y][x-1]==1){\n\t\t\td=3;\n\t\t\tx--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"L\");\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<9;i++){\n\t\t\tString s = sc.next();\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}\n\t\t}\n\t\tx = 0;\n\t\ty = 0;\n\t\td = 1;\n\n\t\twhile(true){\n\t\t\tflag = true;\n\t\t\tif(d==0){\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t}else if(d==1){\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t}else if(d==2){\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t}else if(d==3){\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t}\n\t\t\t\n\t\t\tif(x==0 && y==0){\n\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    int[][] mapA = new int[5][4];\n    int[][] mapB = new int[4][5];\n    int x, y, d;\n    boolean flag;\n    void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            System.out.print(\"U\");\n        }\n    }\n    void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            System.out.print(\"R\");\n        }\n    }\n    void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            System.out.print(\"D\");\n        }\n    }\n     \n    void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            System.out.print(\"L\");\n        }\n    }\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n         \n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                System.out.println();\n                break;\n            }\n        }\n    }\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint times = 0;\n\t\tint[][][] map = new int [5][5][4];\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tm1 = new int[5][4];\n\t\t}\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tfor(int[] m2:m1){\n\t\t\t\tm2 = new int[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(times < 9){\n\t\t\tString str = sc.nextLine();\n\t\t\tif(times % 2 == 0){\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tmap[times/2][i][0] = Integer.parseInt(String.valueOf(str.charAt(i))); // right\n\t\t\t\t}\n\t\t\t\tfor(int i = 1;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][2] = Integer.parseInt(String.valueOf(str.charAt(i-1))); // left\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][1] = Integer.parseInt(String.valueOf(str.charAt(i))); // down\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2+1][i][3] = Integer.parseInt(String.valueOf(str.charAt(i))); // up\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttimes++;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tfor(int[] m2:m1){\n\t\t\t\tSystem.out.print(\"{\" + m2[0] + \",\" + m2[1] + \",\" + m2[2] + \",\" + m2[3] + \"}\");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\tint dir = 0;\n\t\tint x = 1,y = 0;\n\t\tSystem.out.print(\"R\");\n\t\t\n\t\twhile(x != 0 || y != 0){\n\t\t\tif(dir == 0){\n\t\t\t\tif(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 1){\n\t\t\t\tif(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 2){\n\t\t\t\tif(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 3){\n\t\t\t\tif(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);;\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint[] dx={0, 1, 0, -1};\n\tint[] dy={-1, 0, 1, 0};\n\n\t// ----\n\tboolean[][] w1=new boolean[5][4];\n\t// |||||\n\tboolean[][] w2=new boolean[4][5];\n\n\tvoid run(){\n\t\tfor(int i=0; i<9; i++){\n\t\t\tboolean[] w;\n\t\t\tif(i%2==0)\n\t\t\t\tw=w1[i/2];\n\t\t\telse\n\t\t\t\tw=w2[i/2];\n\t\t\tString s=sc.nextLine();\n\t\t\tfor(int k=0; k<s.length(); k++){\n\t\t\t\tw[k]=s.charAt(k)=='1';\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint x=0, y=0;\n\t\tint d=1;\n\t\tfor(;;){\n\t\t\tfor(d=(d+3)%4;; d=(d+1)%4){\n\t\t\t\tif(d==0&&up(x, y)){\n\t\t\t\t\tprint(\"U\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==1&&right(x, y)){\n\t\t\t\t\tprint(\"R\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==2&&down(x, y)){\n\t\t\t\t\tprint(\"D\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==3&&left(x, y)){\n\t\t\t\t\tprint(\"L\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx[d];\n\t\t\ty+=dy[d];\n\t\t\tif((x|y)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean up(int x, int y){\n\t\treturn y>0&&w2[y-1][x];\n\t}\n\n\tboolean down(int x, int y){\n\t\treturn y<4&&w2[y][x];\n\t}\n\n\tboolean left(int x, int y){\n\t\treturn x>0&&w1[y][x-1];\n\t}\n\n\tboolean right(int x, int y){\n\t\treturn x<4&&w1[y][x];\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n\n        \tif(direction == 'R'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString di;\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(dir,x,y)){\nSystem.out.print(dir);\ndi=dir;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\nString di=dirr;\n}\nelse{\nSystem.out.print(dirb);\nString di=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final char cDir[] = {\n\t\t'U', 'R', 'D', 'L'\n\t};\n\t\n\tpublic static final int pDir[][] = {\n\t\t{0, -1}, {1, 0}, {0, 1}, {-1, 0}\n\t};\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\tchar map[][] = new char [9][5];\n\t\tboolean neighbor[][][] = new boolean [5][5][4];\n\t\tint hand[] = {0, 0};\t//現在の座標\n\t\tint iDir = 1;\t\t\t//cDir や pDirに対応している。\n\t\tString answer = new String();\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\t//入力処理\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\t//neighbor初期化\n\t\t\tfor(int i=0; i<5; ++i){\n\t\t\t\tfor(int j=0; j<5; ++j){\n\t\t\t\t\t//Up\n\t\t\t\t\tneighbor[i][j][0] = 0<=(i*2-1) ? (map[i*2 -1][j] == '1') : false;\n\t\t\t\t\t//Right\n\t\t\t\t\tneighbor[i][j][1] = j<(5-1) ? (map[i*2][j] == '1') : false;\n\t\t\t\t\t//Down\n\t\t\t\t\tneighbor[i][j][2] = (i*2+1)<9 ? (map[i*2+1][j] == '1') : false;\n\t\t\t\t\t//Left\n\t\t\t\t\tneighbor[i][j][3] = 0<=(j-1) ? (map[i*2][j-1] == '1') : false; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//本体\n\t\t\tint x=0, y=0;\n\t\t\twhile(true){\n\t\t\t\t//探索\n\t\t\t\tx = hand[0]; y = hand[1];\n\t\t\t\tif(neighbor[y][x][(iDir+3)%4]){\n\t\t\t\t\tiDir = (iDir+3)%4;\n\t\t\t\t}else if(neighbor[y][x][(iDir+0)%4]){\n\t\t\t\t\tiDir = (iDir+0)%4;\n\t\t\t\t}else if(neighbor[y][x][(iDir+1)%4]){\n\t\t\t\t\tiDir = (iDir+1)%4;\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"×\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//結果処理\n\t\t\t\thand[0] += pDir[iDir][0];\n\t\t\t\thand[1] += pDir[iDir][1];\n\t\t\t\tanswer += cDir[iDir];\n\t\t\t\t//動いた先が点Aだったらループから抜ける。\n\t\t\t\tif(hand[0]==0 && hand[1]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static void run(){\n        int[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n        char[] ch = {'U','R','D','L'};\n        Scanner sc = new Scanner(System.in);\n        boolean[][] e = new boolean[25][25];\n        int h = 0, t = 0;\n        for(int x=0;x<9;x++){\n            char[] s = sc.next().toCharArray();\n            for(int j=0;j<s.length;j++){\n                if(s[j]=='0')continue;\n                if(t==0)e[h*5+j][h*5+j+1] = e[h*5+j+1][h*5+j] = true;\n                else e[h*5+j][(h+1)*5+j] = e[(h+1)*5+j][h*5+j] = true;\n            }\n            if(t==1)h++;\n            t=(t+1)%2;\n        }\n        int i=0, j=0, d=1;\n        StringBuilder sb = new StringBuilder();\n        boolean con = true;\n        while(con){\n            for(int k=3;k<=6;k++){\n                int nd = (d+k)%4;\n                int ni = i+move[nd][0];\n                int nj = j+move[nd][1];\n                if(0<=ni&&ni<5&&0<=nj&&nj<5&&e[i*5+j][ni*5+nj]){\n                    sb.append(ch[nd]);\n                    i = ni; j = nj; d = nd;\n                    if(i==0&&j==0)con = false;\n                    break;\n                }\n            }\n        }\n        System.out.println(sb);\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        run(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return true;\n        else return walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n    static int[][] grid;\n    static int MAX_HEIGHT = 9;\n    static int MAX_WIDTH = 9;\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tgrid = new int[MAX_HEIGHT][MAX_WIDTH];\n\tString line;\n\tint width, n, pos;\n\tfor (int i = 0; i < 9; i++) {\n\t    line = scan.nextLine();\n\t    width = 0;\n\t    for (int j = 0; j < line.length(); j++) {\n\t\tn = Integer.parseInt(line.substring(j, j+1));\n\t\tif (n == 0) {\n\t\t    continue;\n\t\t}\n\t\tif (i % 2 == 0) {\n\t\t    pos = j * 2;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i][pos+1] = 1;\n\t\t    grid[i][pos+2] = 1;\n\t\t} else {\n\t\t    pos = j*2;\n\t\t    grid[i-1][pos] = 1;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i+1][pos] = 1;\n\t\t}\n\t    }\n\t}\n\tsolve();\n    }\n    \n    static void solve () {\n\tStringBuilder sb = new StringBuilder();\n\tint width = 0, height = 0, direction = 0;\n\tint[] dwidth = {1, 0, -1, 0};\n\tint[] dheight = {0, 1, 0, -1};\n\tString[] textdirection = {\"R\", \"D\", \"L\", \"U\"};\n\t\n\twhile (true) {\n\t    for (int i = 3; i < 7; i++) {\n\t\tint nextwidth = width + dwidth[(i + direction) % 4];\n\t\tint nextheight = height + dheight[(i + direction) % 4];\n\t\tint nextnextwidth = nextwidth + dwidth[(i + direction) % 4];\n\t\tint nextnextheight = nextheight + dheight[(i + direction) % 4];\n\t\tif (!(0 <= nextwidth && nextwidth < MAX_WIDTH && 0 <= nextheight && nextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (!(0 <= nextnextwidth && nextnextwidth < MAX_WIDTH && 0 <= nextnextheight && nextnextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (grid[nextheight][nextwidth] == 0 || grid[nextnextheight][nextnextwidth] == 0) {\n\t\t    continue;\n\t\t}\n\t\twidth = nextnextwidth;\n\t\theight = nextnextheight;\n\t\tdirection = (i + direction) % 4;\n\t\tsb.append(textdirection[direction]);\n\t\tbreak;\n\t    }\n\t    if (width == 0 && height == 0) {\n\t\tbreak;\n\t    }\n\t}\n\tSystem.out.println(sb.toString());\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\tstatic boolean[] ans;\n\tstatic int[][] pass;\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastScanner sc = new FastScanner();\n\t\tpass = new int[9][9];\n\t    for(int i = 0; i < 9; i++){\n\t    \tString s = sc.next();\n            if(i % 2 == 0){\n            \tArrays.fill(pass[i], 1);\n                for(int j = 0; j < 4; j++){\n                \tint c = s.charAt(j) - '0';\n                    pass[i][j * 2 + 1] = c;\n                }\n            }\n            else {\n            \tfor(int j = 0; j < 5; j++){\n            \t\tint c = s.charAt(j) - '0';\n            \t\tpass[i][j * 2] = c;\n                }\n            }\n        }\n\t    solv();\n\t    out.println();\n\t    out.flush();\n\t    \n\t}\n\tstatic void solv() {\n\t\tint [] vx = {-1,0,1,0};\n        int [] vy = {0,-1,0,1};\n        String [] word = {\"L\", \"U\", \"R\", \"D\"};\n        int nowx = 0, nowy = 0;\n        int dir = 2;\n        \n\t    while(true){\n\t        for(int i = 3; i < 7; i++){\n\t            int xx = nowx + vx[(i + dir) % 4];\n\t            int yy = nowy + vy[(i + dir) % 4];\n\t            int xxx = xx + vx[(i + dir) % 4];\n\t            int yyy = yy + vy[(i + dir) % 4];\n\t            if(! isOK(xx, yy, 9)) continue;\n\t            if(! isOK(xxx, yyy, 9)) continue;\n\t            if(pass[yy][xx] == 0) continue;\n\t            if(pass[yyy][xxx] == 0) continue;\n\t            nowx = xxx;\n\t            nowy = yyy;\n\t            dir = (i + dir) % 4;\n\t            out.print(word[dir]);;\n\t            break;\n\t        }\n\t        if(nowx == 0 && nowy == 0){\n\t            break;\n\t        }\n\t    }\n\t}\n\n\tstatic boolean isOK(int x,int y,int mapsize){\n\t\tif(0 <= x && x < mapsize && 0 <= y && y < mapsize){\n\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport jav.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,inty){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&char[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1';\nreturn true;\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1';){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturm;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayList;\n\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                line=br.readLine();for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return true;\n        else return walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n \nclass Main{\nstatic char[][] map=new char[100][100];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif((i%2)==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.println(\"\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nelse if(dir==\"U\"){\nreturn \"L\";\n}\nelse if(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nelse if(dir==\"U\"){\nreturn \"R\";\n}\nelse if(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nelse if(dir==\"U\"){\nreturn \"D\";\n}\nelse if(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y!=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"U\"){\nif(x!=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"L\"){\nif(y!=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x!=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nString di;\nString dirl=turnLeft(d);\nString dirr=turnRight(d);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(d,x,y)){\nSystem.out.print(d);\ndi=d;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\nif(x==0&&y==0){\nreturn;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean next = true;\n\t\twhile(next){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t\tif(x == 1 && y == 1) next = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n    static ArrayList<Character> list=new ArrayList<Character>();\n    \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            //System.out.print(\"U\");\n            list.add('U');\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            //System.out.print(\"R\");\n            list.add('R');\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            //System.out.print(\"D\");\n            list.add('D');\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            //System.out.print(\"L\");\n            list.add('L');\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                for(char ch:list) System.out.print(ch+\"\");\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        //solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX!=0||nY!=0) walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n??????????????????????????¨????(?????????n=0??????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y?????????£???????????¨????(?????????0,0???0???¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n    static ArrayList<Character> list=new ArrayList<Character>();\n    \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            //System.out.print(\"U\");\n            list.add('U');\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            //System.out.print(\"R\");\n            list.add('R');\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            //System.out.print(\"D\");\n            list.add('D');\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            //System.out.print(\"L\");\n            list.add('L');\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                for(char ch:list) System.out.println(ch+\"\");\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(yoko[0].charAt(0) == '0' && tate[0].charAt(0) == '0')break;\n\n        \tif(direction == 'R'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nelse if(dir==\"U\"){\nreturn \"L\";\n}\nelse if(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nelse if(dir==\"U\"){\nreturn \"R\";\n}\nelse if(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nelse if(dir==\"U\"){\nreturn \"D\";\n}\nelse if(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString di;\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(dir,x,y)){\nSystem.out.print(dir);\ndi=dir;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n    private static final int R = 0;\n    private static final int L = 1;\n    private static final int U = 2;\n    private static final int D = 3;\n\n    String w[] = new String[5];\n    String h[] = new String[4];\n    int Move,x,y;\n\n    Wall(String w[],String h[]) {\n        for (int i=0;i<4;i++) {\n            this.w[i] = w[i];\n            this.h[i] = h[i];\n        }\n        this.w[4] = w[4];\n        this.Move = R;\n        this.x = 1;\n        this.y = 0;\n        System.out.print(\"R\");\n    }\n\n    void Walked() {\n        while (true) {\n            if (this.x==0&&this.y==0) break;\n            if (this.Move==R) {\n                while (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"R\");\n                    if (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n                        this.y--;\n                        this.x++;\n                        this.Move = U;\n                        break;\n                    }\n                    this.x++;\n                }\n                if (this.Move==R) this.Move = D;\n            } else if (this.Move==L) {\n                while (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"L\");\n                    if (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                        this.Move = D;\n                        break;\n                    }\n                    this.x--;\n                }\n                if (this.Move==L) {\n                    this.x++;\n                    this.y--;\n                    this.Move = U;\n                }\n            } else if (this.Move==U) {\n                while (this.y>=0&&h[this.y].charAt(this.x)=='1') {    \n                    System.out.print(\"U\");\n                    if (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n                        this.x--;\n                        if (this.x==0&&this.y==0) System.out.print(\"L\");\n                        this.Move = L;\n                        break;\n                    }\n                    this.y--;\n                }\n                if (this.Move==U) {\n                    this.y++;\n                    this.Move = R;\n                }\n            } else if (this.Move==D) {\n                while (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"D\");\n                    if (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n                        this.y++;                    \n                        this.Move = R;\n                        break;\n                    }\n                    this.y++;\n                }\n                if (this.Move==D) {\n                    this.x--;\n                    if (this.x==0&&this.y==0) System.out.print(\"L\");\n                    this.Move = L;\n                }\n            }\n        }\n        System.out.println(\"\");\n    }\n}\nclass Main {\n    public static void main(String args[]) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        try {\n            String w[] = new String[5];\n            String h[] = new String[4];\n            for (int i=0;i<4;i++) {\n                w[i] = br.readLine();\n                h[i] = br.readLine();\n            }\n            w[4] = br.readLine();\n\n            Wall wall = new Wall(w,h);\n            wall.Walked();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tGrid[][] grid = new Grid[6][6];\n\t\tfor(int i = 0; i < 36; i++){\n\t\t\tgrid[i/6][i%6] = new Grid();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tString tmp = br.readLine();\n\t\t\t\n\t\t\tif(i%2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].top = true;\n\t\t\t\t\t\t//System.out.println(\"top\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].left = true;\n\t\t\t\t\t\t//System.out.println(\"left\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint currentX = 1;\n\t\tint currentY = 0;\n\t\tfinal int R = 0;\n\t\tfinal int D = 1;\n\t\tfinal int U = 2;\n\t\tfinal int L = 3;\n\t\t\n\t\tint mode = R;\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile(true){\n\t\t\t//System.out.println(\"mode \"+ mode +\"(x,y)\"+currentX + \" \" + currentY);\n\t\t\tif(mode == R){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX + 1].left){\n\t\t\t\t\tmode = U;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX + 1].top){\n\t\t\t\t\tcurrentX++;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = D;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"R\");\n\t\t\t}\n\t\t\telse if(mode == D){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY+1][currentX].top){\n\t\t\t\t\tmode = R;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX].left){\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = L;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"D\");\n\t\t\t}\n\t\t\telse if(mode == U){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].top){\n\t\t\t\t\tmode = L;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY - 1][currentX + 1].left){\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = R;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"U\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].left){\n\t\t\t\t\tmode = D;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY][currentX - 1].top){\n\t\t\t\t\tcurrentX--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse {\n\t\t\t\t\tmode = U;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"L\");\n\t\t\t}\n\t\t\t\n\t\t\tif(currentX == 1 && currentY == 1 && mode == L){\n\t\t\t\t//if(sb.charAt(sb.length() - 1) != 'L'){\n\t\t\t\tsb.append(\"L\");\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(currentX == 0 && currentY == 1 && mode == U){\n\t\t\t\t//if(sb.charAt(sb.length() - 1) != 'U'){\n\t\t\t\tsb.append(\"U\");\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t}\n\n}\n\nclass Grid {\n\tboolean top = false;\n\tboolean left = false;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif(px==0&&py==0){\nreturn;\n}\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\ngotoDirection(dirb,px,py);\nSystem.out.print(dirb);\ndp[count+1]=dirb;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oi\");\n        \t}\n        \tsb.append(direction);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\ngotoDirection(dirl,x,y);\nSystem.out.print(dirl);\ngotoPath(x,y,dirl);\n}\nelse if(cangoNext(dir,x,y)){\ngotoDirection(dir,x,y);\nSystem.out.print(dir);\ngotoPath(x,y,dir);\n}\nelse if(cangoNext(dirr,x,y)){\ngotoDirection(dirr,x,y);\nSystem.out.print(dirr);\ngotoPath(x,y,dirr);\n}\nelse{\ngotoDirection(dirb,x,y);\nSystem.out.print(dirb);\ngotoPath(x,y,dirb);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n// {U,R,D,L}:{0,1,2,3}\n\npublic class Main {\n    int[] dx = {0,1,0,-1};\n    int[] dy = {-1,0,1,0};\n    String[] direction = {\"U\",\"R\",\"D\",\"L\"};\n\n    void run(){\n        Arc arc = new Arc(5);\n //       arc.printArc();\n        int x = 0, y = 0, d = 2;\n        while (true) {\n            d = arc.getNextP(x,y,d);\n            x = x+dx[d];\n            y = y+dy[d];\n            System.out.print(direction[d]);\n            if (x == 0 && y == 0){\n                System.out.println();\n                break;\n            }\n        }\n    }\n\n    class Arc {\n        int[][] arc;\n        Scanner sc;\n        int size;\n        Arc(int size) {\n            this.size = size;\n            sc = new Scanner(System.in);\n            arc = new int [2*(size+1)+1][size+2];\n            for (int i=0;i<2*(size+1)+1;i++) {\n                for (int j=0;j<size+2;j++) arc[i][j] = 0;\n            }\n            String line;\n            for (int i=2;i<2*size+1;i++) {\n                line = sc.next();\n                if (i%2 == 0) {\n                    for (int j=1;j<size;j++)\n                        arc[i][j] = line.charAt(j-1)-'0';\n                }\n                else {\n                    for (int j=1;j<size+1;j++)\n                        arc[i][j] = line.charAt(j-1)-'0';\n                }\n            }\n        }\n\n        int[] dx = {1,1,1,0};\n        int[] dy = {-1,0,1,0};\n        int getNextP(int x,int y, int d) {\n            for (int i=3;i<7;i++) {\n                if (arc[2*(y+1)+dy[(d+i)%4]][x+dx[(d+i)%4]] == 1) return (d+i)%4;\n            }\n            return -1;\n        }\n        void printArc() {\n            for (int i=0;i<2*(size+1)+1;i++) {\n                for (int j=0;j<size+2;j++) {\n                    System.out.print(arc[i][j] + \" \");\n                }\n                System.out.println();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif((i%2)==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.println(\"\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nelse if(dir==\"U\"){\nreturn \"L\";\n}\nelse if(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nelse if(dir==\"U\"){\nreturn \"R\";\n}\nelse if(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nelse if(dir==\"U\"){\nreturn \"D\";\n}\nelse if(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y!=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"U\"){\nif(x!=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"L\"){\nif(y!=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x!=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nString di;\nString dirl=turnLeft(d);\nString dirr=turnRight(d);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(d,x,y)){\nSystem.out.print(d);\ndi=d;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\nif(x==0&&y==0){\nreturn;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif((sty+1) != 5 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(sty != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//System.out.println(stx+\",\"+sty+\",\");\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n    static ArrayList<Character> list=new ArrayList<Character>();\n    \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            //System.out.print(\"U\");\n            list.add('U');\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            //System.out.print(\"R\");\n            list.add('R');\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            //System.out.print(\"D\");\n            list.add('D');\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            //System.out.print(\"L\");\n            list.add('L');\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                for(char ch:list) System.out.print(ch+\"\");\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        //solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        while(true){\n        if(walkon(walk,1,0))break;}\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static int nX=0, nY=0;\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';nX=x;nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX!=0||nY!=0) return false;\n        else return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n\n        \tif(direction == 'R'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[][];\n\t\tint x, y, d;\n\t\tString st;\n\n\t\ta = new int[15][15];\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tst = sc.next();\n\t\t\tfor (int j = 0; j < st.length(); j++) {\n\t\t\t\ta[i][j] = st.charAt(j) - '0';\n\t\t\t}\n\t\t}\n\t\tx = 2;\n\t\ty = 1;\n\t\td = 1;\n\t\tboolean flag = true;\n\t\twhile (flag || x != 2 || y != 1) {\n\t\t\tflag = false;\n\t\t\tif (d == 1) {\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tif (1 < y && a[(y - 1) * 2 - 1][x - 1] == 1) {\n\t\t\t\t\td = 4;\n\t\t\t\t} else if (a[(y - 1) * 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 2;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t}\n\t\t\t} else if (d == 2) {\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tif (a[(y - 1) * 2][x - 2] == 1) {\n\t\t\t\t\td = 1;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 2] == 1) {\n\t\t\t\t\ty++;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td = 4;\n\t\t\t\t}\n\t\t\t} else if (d == 3) {\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tif (a[(y - 1) * 2 - 1][x - 2] == 1) {\n\t\t\t\t\td = 2;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2 - 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 2] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 4;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tif (1 < x && a[(y - 1) * 2 - 2][x - 2] == 1) {\n\t\t\t\t\td = 3;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 1] == 1) {\n\t\t\t\t\ty--;\n\t\t\t\t} else if (1 < y && a[(y - 1) * 2 - 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n    static ArrayList<Character> list=new ArrayList<Character>();\n    \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            //System.out.print(\"U\");\n            list.add('U');\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            //System.out.print(\"R\");\n            list.add('R');\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            //System.out.print(\"D\");\n            list.add('D');\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            //System.out.print(\"L\");\n            list.add('L');\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                for(char ch:list) System.out.print(ch+\"\");\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n    static int[][] grid;\n    static int MAX_HEIGHT = 9;\n    static int MAX_WIDTH = 9;\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tgrid = new int[MAX_HEIGHT][MAX_WIDTH];\n\tString line;\n\tint width, n, pos;\n\tfor (int i = 0; i < 9; i++) {\n\t    line = scan.nextLine();\n\t    /*\n\t    if (i % 2 == 0) {\n\t\tArrays.fill(grid[i], 1);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t    int c = line.charAt(j) - '0';\n\t\t    grid[i][j * 2 + 1] = c;\n\t\t}\n\t    } else {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t    int c = line.charAt(j) - '0';\n\t\t    grid[i][j * 2] = c;\n\t\t}\n\t    }\n\t    */\n\t    width = 0;\n\t    for (int j = 0; j < line.length(); j++) {\n\t\tn = Integer.parseInt(line.substring(j, j+1));\n\t\tif (n == 0) {\n\t\t    continue;\n\t\t}\n\t\tif (i % 2 == 0) {\n\t\t    pos = j * 2;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i][pos+1] = 1;\n\t\t    grid[i][pos+2] = 1;\n\t\t} else {\n\t\t    pos = j*2;\n\t\t    grid[i-1][pos] = 1;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i+1][pos] = 1;\n\t\t}\n\t    }\n\t}\n\t/*\n\tfor (int i = 0; i < 9; i++) {\n\t    for (int j = 0; j < 9; j++) {\n\t\tSystem.out.print(grid[i][j]);\n\t    }\n\t    System.out.println();\n\t}\n\t*/\n\tsolve();\n\t//System.out.println();\n    }\n    \n    static void solve () {\n\tStringBuilder sb = new StringBuilder();\n\tint width = 0, height = 0, direction = 0;\n\tint[] dwidth = {1, 0, -1, 0};\n\tint[] dheight = {0, 1, 0, -1};\n\tString[] textdirection = {\"R\", \"D\", \"L\", \"U\"};\n\t\n\twhile (true) {\n\t    for (int i = 3; i < 7; i++) {\n\t\tint nextwidth = width + dwidth[(i + direction) % 4];\n\t\tint nextheight = height + dheight[(i + direction) % 4];\n\t\tint nextnextwidth = nextwidth + dwidth[(i + direction) % 4];\n\t\tint nextnextheight = nextheight + dheight[(i + direction) % 4];\n\t\tif (!(0 <= nextwidth && nextwidth < MAX_WIDTH && 0 <= nextheight && nextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (!(0 <= nextnextwidth && nextnextwidth < MAX_WIDTH && 0 <= nextnextheight && nextnextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (grid[nextheight][nextwidth] == 0 || grid[nextnextheight][nextnextwidth] == 0) {\n\t\t    continue;\n\t\t}\n\t\twidth = nextnextwidth;\n\t\theight = nextnextheight;\n\t\tdirection = (i + direction) % 4;\n\t\tsb.append(textdirection[direction]);\n\t\tbreak;\n\t    }\n\t    if (width == 0 && height == 0) {\n\t\tbreak;\n\t    }\n\t}\n\tSystem.out.println(sb.toString());\n\t/*\n\tint[] data = new int[2];\n\tint count = 0;\n\twhile (true) {\n\t    data = move(width, height, direction);\n\t    width = data[0];\n\t    height = data[1];\n\t    direction = nextDirection(width, height, direction);\n\t    if (width == 0 && height == 0) {\n\t\tbreak;\n\t    }\n\t}\n\t*/\n    }\n    \n    static int[] move (int width, int height, int direction) {\n\tint[] data = new int[2];\n\tif (direction == 0) {\n\t    data = moveRight(width, height);\n\t} else if (direction == 1) {\n\t    data = moveLeft(width, height);\n\t} else if (direction == 2) {\n\t    data = moveUp(width, height);\n\t} else if (direction == 3) {\n\t    data = moveDown(width, height);\n\t}\n\treturn data;\n\n    }\n\n    static int[] moveRight (int width, int height) {\n\tint[] data = new int[2];\n\twhile (width+2 < MAX_WIDTH && grid[height][width+2] == 1 && grid[height][width+1] == 1) {\n\t    width+=2;\n\t    System.out.print(\"R\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveLeft (int width, int height) {\n\tint[] data = new int[2];\n\twhile (width-2 >= 0 && grid[height][width-2] == 1 && grid[height][width-1] == 1) {\n\t    width-=2;\n\t    System.out.print(\"L\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveUp (int width, int height) {\n\tint[] data = new int[2];\n\twhile (height-2 >= 0 && grid[height-2][width] == 1 && grid[height-1][width] == 1) {\n\t    height -=2;\n\t    System.out.print(\"U\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int[] moveDown (int width, int height) {\n\tint[] data = new int[2];\n\twhile (height+2 < MAX_HEIGHT && grid[height+2][width] == 1 && grid[height+1][width] == 1) {\n\t    height +=2;\n\t    System.out.print(\"D\");\n\t}\n\tdata[0] = width;\n\tdata[1] = height;\n\treturn data;\n    }\n\n    static int nextDirection (int width, int height, int prevDirection) {\n\tint next = 0;\n\tif (prevDirection == 0 || prevDirection == 1) {\n\t    if (isUp(width, height)) {\n\t\tnext = 2;\n\t    } else if (isDown(width, height)) {\n\t\tnext = 3;\n\t    }\n\t} else if (prevDirection == 2 || prevDirection == 3) {\n\t    if (isRight(width, height)) {\n\t\tnext = 0;\n\t    } else if (isLeft(width, height)) {\n\t\tnext = 1;\n\t    }\n\t}\n\treturn next;\n    }\n\n    static boolean isUp (int width, int height) {\n\tif (height == 0) {\n\t    return false;\n\t}\n\tif (grid[height - 1][width] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n\n    static boolean isDown (int width, int height) {\n\tif (height == MAX_HEIGHT - 1) {\n\t    return false;\n\t}\n\tif (grid[height+1][width] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n    static boolean isRight (int width, int height) {\n\tif (width == MAX_WIDTH - 1) {\n\t    return false;\n\t}\n\tif (grid[height][width + 1] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n\n    static boolean isLeft (int width, int height) {\n\tif (width == 0) {\n\t    return false;\n\t}\n\tif (grid[height][width - 1] == 1) {\n\t    return true;\n\t} else {\n\t    return false;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint[][] grid = new int[5][5]; // G[WFgÌs®ÌæÆ\n\n\tint[][] wallV = new int[4][5];\n\n\tint[][] wallH = new int[5][4];\n\n\n\n\tboolean canDown(int x, int ny) {\n\n\t\tint y = ny;\n\n\t\tif (x < 0 || y < 0 || x > 4 || y > 3) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif (wallV[y][x] == 1) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\tboolean canUp(int x, int ny) {\n\n\t\tint y = ny - 1;\n\n\t\tif (x < 0 || y < 0 || x > 4 || y > 3) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif (wallV[y][x] == 1) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\tboolean canRight(int nx, int y) {\n\n\t\tint x = nx;\n\n\t\tif (x < 0 || y < 0 || x > 3 || y > 4) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif (wallH[y][x] == 1) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\tboolean canLeft(int nx, int y) {\n\n\t\tint x = nx - 1;\n\n\t\tif (x < 0 || y < 0 || x > 3 || y > 4) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif (wallH[y][x] == 1) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tString buffer = sc.nextLine();\n\n\t\tfor (int j = 0; j < 4; j++) {\n\n\t\t\twallH[0][j] = buffer.charAt(j) - '0';\n\n\t\t}\n\n\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tbuffer = sc.nextLine();\n\n\t\t\tfor (int j = 0; j < 5; j++) {\n\n\t\t\t\twallV[i][j] = buffer.charAt(j) - '0';\n\n\t\t\t}\n\n\t\t\tbuffer = sc.nextLine();\n\n\t\t\tfor (int j = 0; j < 4; j++) {\n\n\t\t\t\twallH[i + 1][j] = buffer.charAt(j) - '0';\n\n\t\t\t}\n\n\t\t}\n\n\t\tint x = 0;\n\n\t\tint y = 0;\n\n\t\tint dirc = 0;\n\n\t\tboolean a = true;\n\n\t\tString Ans = \"\";\n\n\t\tfor (; a || !(x == 0 && y == 0);) {\n\n\t\t\ta = false;\n\n//\t\t\tSystem.out.println(Ans);\n\n\t\t\tif (dirc == 0) {\n\n\t\t\t\tif (canUp(x, y)) {\n\n\t\t\t\t\tAns += \"U\";\n\n\t\t\t\t\ty -= 1;\n\n\t\t\t\t\tdirc = 1;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canRight(x, y)) {\n\n\t\t\t\t\tAns += \"R\";\n\n\t\t\t\t\tx += 1;\n\n\t\t\t\t\tdirc = 0;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canDown(x, y)) {\n\n\t\t\t\t\tAns += \"D\";\n\n\t\t\t\t\ty += 1;\n\n\t\t\t\t\tdirc = 3;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canLeft(x, y)) {\n\n\t\t\t\t\tAns += \"L\";\n\n\t\t\t\t\tx -= 1;\n\n\t\t\t\t\tdirc = 2;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (dirc == 1) {\n\n\t\t\t\tif (canLeft(x, y)) {\n\n\t\t\t\t\tAns += \"L\";\n\n\t\t\t\t\tx -= 1;\n\n\t\t\t\t\tdirc = 2;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canUp(x, y)) {\n\n\t\t\t\t\tAns += \"U\";\n\n\t\t\t\t\ty -= 1;\n\n\t\t\t\t\tdirc = 1;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canRight(x, y)) {\n\n\t\t\t\t\tAns += \"R\";\n\n\t\t\t\t\tx += 1;\n\n\t\t\t\t\tdirc = 0;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canDown(x, y)) {\n\n\t\t\t\t\tAns += \"D\";\n\n\t\t\t\t\ty += 1;\n\n\t\t\t\t\tdirc = 3;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (dirc == 2) {\n\n\t\t\t\tif (canDown(x, y)) {\n\n\t\t\t\t\tAns += \"D\";\n\n\t\t\t\t\ty += 1;\n\n\t\t\t\t\tdirc = 3;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canLeft(x, y)) {\n\n\t\t\t\t\tAns += \"L\";\n\n\t\t\t\t\tx -= 1;\n\n\t\t\t\t\tdirc = 2;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canUp(x, y)) {\n\n\t\t\t\t\tAns += \"U\";\n\n\t\t\t\t\ty -= 1;\n\n\t\t\t\t\tdirc = 1;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canRight(x, y)) {\n\n\t\t\t\t\tAns += \"R\";\n\n\t\t\t\t\tx += 1;\n\n\t\t\t\t\tdirc = 0;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (dirc == 3) {\n\n\t\t\t\tif (canRight(x, y)) {\n\n\t\t\t\t\tAns += \"R\";\n\n\t\t\t\t\tx += 1;\n\n\t\t\t\t\tdirc = 0;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canDown(x, y)) {\n\n\t\t\t\t\tAns += \"D\";\n\n\t\t\t\t\ty += 1;\n\n\t\t\t\t\tdirc = 3;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canLeft(x, y)) {\n\n\t\t\t\t\tAns += \"L\";\n\n\t\t\t\t\tx -= 1;\n\n\t\t\t\t\tdirc = 2;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif (canUp(x, y)) {\n\n\t\t\t\t\tAns += \"U\";\n\n\t\t\t\t\ty -= 1;\n\n\t\t\t\t\tdirc = 1;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tSystem.out.println(Ans);\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ndp[1]=\"R\";\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String dir){\nint count=1;\nif(x==0&&y==0){\nreturn;\n}\nString dir=this.dir;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,x,y)){\ngotoDirection(dirl,x,y);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\ngotoPath(x,y,dirl);\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\ngotoPath(x,y,dir);\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\ngotoPath(x,y,dirr);\n}\nelse{\ngotoDirection(dirb,px,py);\nSystem.out.print(dirb);\ndp[count+1]=dirb;\ngotoPath(x,y,dirb);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean is, next = true;\n\t\twhile(next){\n\t\t\tis = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\tis = false;\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t\t\n\t\t\t\t\tif(x == 1 && y == 1) next = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is){\n\t\t\t\tvec = (vec + 2) % 4;\n\t\t\t\tSystem.out.print(opr[vec]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx-1) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oioi\");\n        \t}\n        \tsb.append(direction);\n        \t//System.out.println(stx+\",\"+sty+\",\"+\",\");\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  static boolean[][] wall = new boolean[9][];\n  static int[] point = {0,0,0};\n\n  public static boolean[] lineSet(String str){\n    boolean[] line = new boolean[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n      if (str.charAt(i) == '0') {\n        line[i] = false;\n      }\n      else {\n        line[i] = true;\n      }\n    }\n    return line;\n  }\n\n  public static void moveR(){\n    System.out.print(\"R\");\n    point[1]++;\n    point[2] = 0;\n  }\n  \n  public static void moveD(){\n    System.out.print(\"D\");\n    point[0] += 2;\n    point[2] = 1;\n  }\n  \n  public static void moveL(){\n    System.out.print(\"L\");\n    point[1]--;\n    point[2] = 2;\n  }\n  \n  public static void moveU(){\n    System.out.print(\"U\");\n    point[0] -= 2;\n    point[2] = 3;\n  }\n  \n  public static void directionR(){\n    if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      moveU();\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      moveR();\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      moveD();\n    }\n    else {\n      moveL();\n    }\n  }\n  public static void directionD(){\n    if (point[1] < 4 && wall[point[0]][point[1]]) {\n      moveR();\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      moveD();\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      moveL();\n    }\n    else {\n      moveU();\n    }\n  }\n  public static void directionL(){\n    if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      moveD();\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      moveL();\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      moveU();\n    }\n    else {\n      moveR();\n    }\n  }\n  public static void directionU(){\n    if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      moveL();\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      moveU();\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      moveR();\n    }\n    else {\n      moveD();\n    }\n  }\n\n  public static void direction(){\n    switch(point[2]) {\n      case 0:\n        directionR();\n        break;\n      case 1:\n        directionD();\n        break;\n      case 2:\n        directionL();\n        break;\n      case 3:\n        directionU();\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    for (int i = 0; i < 9; i++) {\n      String str = sc.next();\n      wall[i] = lineSet(str);\n    }\n    while(true) {\n      direction();\n      if (point[0] == 0 && point[1] == 0) {\n        break;\n      }\n    }\n    System.out.println(\"\");\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d == 2)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tGrid[][] grid = new Grid[6][6];\n\t\tfor(int i = 0; i < 36; i++){\n\t\t\tgrid[i/6][i%6] = new Grid();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tString tmp = br.readLine();\n\t\t\t\n\t\t\tif(i%2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].top = true;\n\t\t\t\t\t\t//System.out.println(\"top\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(tmp.charAt(j) == '1'){\n\t\t\t\t\t\tgrid[i/2 + 1][j + 1].left = true;\n\t\t\t\t\t\t//System.out.println(\"left\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint currentX = 1;\n\t\tint currentY = 0;\n\t\tfinal int R = 0;\n\t\tfinal int D = 1;\n\t\tfinal int U = 2;\n\t\tfinal int L = 3;\n\t\t\n\t\tint mode = R;\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile(true){\n\t\t\t//System.out.println(\"mode \"+ mode +\"(x,y)\"+currentX + \" \" + currentY);\n\t\t\tif(mode == R){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX + 1].left){\n\t\t\t\t\tmode = U;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX + 1].top){\n\t\t\t\t\tcurrentX++;\n\t\t\t\t}\n\t\t\t\t//?????????\n\t\t\t\telse if(grid[currentY + 1][currentX + 1].left){\n\t\t\t\t\tmode = D;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmode = L;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"R\");\n\t\t\t}\n\t\t\telse if(mode == D){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY+1][currentX].top){\n\t\t\t\t\tmode = R;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY + 1][currentX].left){\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse if(grid[currentY + 1][currentX - 1].top){\n\t\t\t\t\tmode = L;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmode = U;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"D\");\n\t\t\t}\n\t\t\telse if(mode == U){\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].top){\n\t\t\t\t\tmode = L;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY - 1][currentX + 1].left){\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse if(grid[currentY][currentX + 1].top){\n\t\t\t\t\tmode = R;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmode = D;\n\t\t\t\t\tcurrentX++;\n\t\t\t\t}\n\t\t\t\tsb.append(\"U\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//??´?????????\n\t\t\t\tif(grid[currentY][currentX].left){\n\t\t\t\t\tmode = D;\n\t\t\t\t}\n\t\t\t\t//??´??????\n\t\t\t\telse if(grid[currentY][currentX - 1].top){\n\t\t\t\t\tcurrentX--;\n\t\t\t\t}\n\t\t\t\t//??????\n\t\t\t\telse if(grid[currentY - 1][currentX].left){\n\t\t\t\t\tmode = U;\n\t\t\t\t\tcurrentX--;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmode = R;\n\t\t\t\t\tcurrentY--;\n\t\t\t\t}\n\t\t\t\tsb.append(\"L\");\n\t\t\t}\n\t\t\t\n\t\t\tif(currentX == 1 && currentY == 1 && mode == L){\n\t\t\t\t//if(sb.charAt(sb.length() - 1) != 'L'){\n\t\t\t\tsb.append(\"L\");\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(currentX == 0 && currentY == 1 && mode == U){\n\t\t\t\t//if(sb.charAt(sb.length() - 1) != 'U'){\n\t\t\t\tsb.append(\"U\");\n\t\t\t\t//}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sb);\n\t}\n\n}\n\nclass Grid {\n\tboolean top = false;\n\tboolean left = false;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n\tprivate static final int R = 0;\n\tprivate static final int L = 1;\n\tprivate static final int U = 2;\n\tprivate static final int D = 3;\n\n\tString w[] = new String[5];\n\tString h[] = new String[4];\n\tint Move,x,y;\n\n\tWall(String w[],String h[]) {\n\t\tfor (int i=0;i<4;i++) {\n\t\t\tthis.w[i] = w[i];\n\t\t\tthis.h[i] = h[i];\n\t\t}\n\t\tthis.w[4] = w[4];\n\t\tthis.Move = R;\n\t\tthis.x = 1;\n\t\tthis.y = 0;\n\t\tSystem.out.print(\"R\");\n\t}\n\n\tvoid Walked() {\n\t\twhile (true) {\n\t\t\tif (this.x==0&&this.y==0) break;\n\t\t\tif (this.Move==R) {\n\t\t\t\twhile (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tif (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n\t\t\t\t\t\tthis.y--;\n\t\t\t\t\t\tthis.x++;\n\t\t\t\t\t\tthis.Move = U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==R) this.Move = D;\n\t\t\t} else if (this.Move==L) {\n\t\t\t\twhile (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tif (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\t\tthis.Move = D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==L) {\n\t\t\t\t\tthis.x++;\n\t\t\t\t\tthis.y--;\n\t\t\t\t\tthis.Move = U;\n\t\t\t\t}\n\t\t\t} else if (this.Move==U) {\n\t\t\t\twhile (this.y>=0&&h[this.y].charAt(this.x)=='1') {\t\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tif (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n\t\t\t\t\t\tthis.x--;\n\t\t\t\t\t\tthis.Move = L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==U) {\n\t\t\t\t\tthis.y++;\n\t\t\t\t\tthis.Move = R;\n\t\t\t\t}\n\t\t\t} else if (this.Move==D) {\n\t\t\t\twhile (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tif (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n\t\t\t\t\t\ty++;\t\t\t\t\t\n\t\t\t\t\t\tthis.Move = R;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==D) {\n\t\t\t\t\tthis.x--;\n\t\t\t\t\tthis.Move = L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\ttry {\n\t\t\tString w[] = new String[5];\n\t\t\tString h[] = new String[4];\n\t\t\tfor (int i=0;i<4;i++) {\n\t\t\t\tw[i] = br.readLine();\n\t\t\t\th[i] = br.readLine();\n\t\t\t}\n\t\t\tw[4] = br.readLine();\n\n\t\t\tWall wall = new Wall(w,h);\n\t\t\twall.Walked();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n enum Vec {\n\tR,\n\tU,\n\tL,\n\tD;\n\tVec next() {\n\t return (this == R) ? D : (this == D) ? L\n\t\t : (this == L) ? U : R;\n\t}\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tboolean isKisu = true;\n\tList<boolean[]> gusu = new ArrayList<boolean[]>();\n\tList<boolean[]> kisu = new ArrayList<boolean[]>();\n\twhile (in.hasNextLine()) {\n\n\t isKisu = !isKisu;\n\t char[] str = in.nextLine().toCharArray();\n\t boolean[] bs = new boolean[str.length];\n\t for (int i = 0; i < bs.length; i++) {\n\t\tbs[i] = (str[i] == '1');\n\t }\n\t ((isKisu) ? kisu : gusu).add(bs);\n\t}\n\tMap<Point, Map<Vec, Point>> map = new HashMap<Point, Map<Vec, Point>>();\n\tint ySize = gusu.size();\n\tint xSize = kisu.get(0).length;\n\tfor (int y = 0; y < ySize; y++) {\n\t for (int x = 0; x < xSize; x++) {\n\t\tmap.put(\n\t\t  new Point(x, y),\n\t\t  new EnumMap<Vec, Point>(Vec.class));\n\t }\n\t}\n\t{\n\t int size = gusu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = gusu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (gusu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint r = new Point(x + 1, y);\n\t\t\tmap.get(o).put(Vec.R, r);\n\t\t\tmap.get(r).put(Vec.L, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\t{\n\t int size = kisu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = kisu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (kisu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint d = new Point(x, y + 1);\n\t\t\tmap.get(o).put(Vec.D, d);\n\t\t\tmap.get(d).put(Vec.U, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\tVec next = Vec.R;\n\tPoint posi = new Point(0, 0);\n\tdo {\n\t next = next.next().next().next();\n\t Map<Vec, Point> point = map.get(posi);\n\t while (!point.containsKey(next)) {\n\t\tnext = next.next();\n\t }\n\t System.out.print(next);\n\t posi = point.get(next);\n\t} while (posi.x != 0 || posi.y != 0);\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(sty != 5 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(sty != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//System.out.println(stx+\",\"+sty+\",\");\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tSystem.out.print(i + \" : \");\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\n\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t\t\n\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"ULD\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RUL\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DRU\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LDR\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tcreateGrid();\n\t\tMan saburou = new Man(Grid.INITIAL_VECTOR, Grid.X_START_POSITION, Grid.Y_START_POSITION);\n\t\tdo{\n\t\t\tsaburou.go();\n\t\t}while(!saburou.goalIn());\n\t}\n\tprivate static void createGrid() throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\t\tfor(int i = 0; i < Grid.getGridXLength(); i++){\n\t\t\tbuf = br.readLine();\n\t\t\tchar[] tmpX = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpX.length; j++){\n\t\t\t\tGrid.setGridX(i, j, tmpX[j] - '0');\n\t\t\t}\n\t\t\tif(i == Grid.getGridYLength())\tbreak;\n\t\t\tbuf=br.readLine();\n\t\t\tchar[] tmpY = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpY.length; j++){\n\t\t\t\tGrid.setGridY(i, j, tmpY[j] - '0');\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Grid{\n\tpublic static final int X_START_POSITION = 0;\n\tpublic static final int Y_START_POSITION = 0;\n\tpublic static final int INITIAL_VECTOR = Man.RIGHT;\n\tpublic static final int WALL_EXIST = 1;\n\tprivate static int[][] gridX = new int[5][4];\n\tprivate static int[][] gridY = new int[4][5];\n\tpublic static void setGridX(int i, int j, int exist) {\n\t\tGrid.gridX[i][j] = exist;\n\t}\n\tpublic static void setGridY(int i, int j, int exist) {\n\t\tGrid.gridY[i][j] = exist;\n\t}\n\tpublic static int getGridXLength() {\n\t\treturn gridX.length;\n\t}\n\tpublic static int getGridYLength() {\n\t\treturn gridY.length;\n\t}\n\tpublic static boolean gridXisWall(int i, int j){\n\t\treturn (gridX[i][j] == WALL_EXIST) ? true : false;\n\t}\n\tpublic static boolean gridYisWall(int i, int j){\n\t\treturn (gridY[i][j] == WALL_EXIST) ? true : false;\n\t}\n}\nclass Man{\n\tpublic static final int UP = 1;\n\tpublic static final int DOWN = 2;\n\tpublic static final int LEFT = 3;\n\tpublic static final int RIGHT = 4;\n\t\n\tprivate int vector;\n\tprivate int x;\n\tprivate int y;\n\tpublic Man(int initialVector, int startX, int startY) {\n\t\tvector = initialVector;\n\t\tx = startX;\n\t\ty = startY;\n\t}\n\t/**\n\t * 前回の移動後に決定した方向へ移動する\n\t */\n\tpublic void go(){\n\t\tswitch(vector){\n\t\tcase UP:\n\t\t\tgoUp();\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tgoDown();\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tgoLeft();\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tgoRight();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/**\n\t * 初期位置に戻ってきているか（ゴールしているか）判定する\n\t * @return\tゴールしているか\n\t */\n\tpublic boolean goalIn(){\n\t\treturn (x == Grid.X_START_POSITION && y == Grid.Y_START_POSITION);\n\t}\n\tprivate void goRight(){\n\t\tx++;\n\t\tSystem.out.print(\"R\");\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tvector = LEFT;\n\t}\n\tprivate void goLeft(){\n\t\tx--;\n\t\tSystem.out.print(\"L\");\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tvector = RIGHT;\n\t}\n\tprivate void goUp(){\n\t\ty--;\n\t\tSystem.out.print(\"U\");\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tvector = DOWN;\n\t}\n\tprivate void goDown(){\n\t\ty++;\n\t\tSystem.out.print(\"D\");\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tvector = UP;\n\t}\n\tprivate boolean findUpWall(){\n\t\tif(y == 0)\treturn false;\n\t\treturn\tGrid.gridYisWall(y - 1,x);\n\t}\n\tprivate boolean findDownWall(){\n\t\tif(y == 4)\treturn false;\n\t\treturn Grid.gridYisWall(y, x);\n\t}\n\tprivate boolean findLeftWall(){\n\t\tif(x == 0)\treturn false;\n\t\treturn Grid.gridXisWall(y, x - 1);\n\t}\n\tprivate boolean findRightWall(){\n\t\tif(x == 4)\treturn false;\n\t\treturn Grid.gridXisWall(y, x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[][];\n\t\tint x, y, d;\n\t\tString st;\n\n\t\ta = new int[15][15];\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tst = sc.next();\n\t\t\tfor (int j = 0; j < st.length(); j++) {\n\t\t\t\ta[i][j] = st.charAt(j) - '0';\n\t\t\t}\n\t\t}\n\t\tx = 2;\n\t\ty = 1;\n\t\td = 1;\n\t\tboolean flag = true;\n\t\twhile (flag || x != 2 || y != 1) {\n\t\t\tflag = false;\n\t\t\tif (d == 1) {\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tif (1 < y && a[(y - 1) * 2 - 1][x - 1] == 1) {\n\t\t\t\t\td = 4;\n\t\t\t\t} else if (a[(y - 1) * 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 2;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t}\n\t\t\t} else if (d == 2) {\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tif (a[(y - 1) * 2][x - 2] == 1) {\n\t\t\t\t\td = 1;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 2] == 1) {\n\t\t\t\t\ty++;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td = 4;\n\t\t\t\t}\n\t\t\t} else if (d == 3) {\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tif (a[(y - 1) * 2 - 1][x - 2] == 1) {\n\t\t\t\t\td = 2;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2 - 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 2] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 4;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tif (1 < x && a[(y - 1) * 2 - 2][x - 2] == 1) {\n\t\t\t\t\td = 3;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 1] == 1) {\n\t\t\t\t\ty--;\n\t\t\t\t} else if (1 < y && a[(y - 1) * 2 - 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tSystem.out.print(i + \" : \");\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\n\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t\t\n\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"ULD\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RUL\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DRU\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LDR\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static final int[] dx = {-1, 0, 1, 0};\n    static final int[] dy = {0, -1, 0, 1};\n    static final String[] dirStr = {\"L\", \"U\", \"R\", \"D\"};\n\n    static final int LEFT = 0;\n    static final int UP = 1;\n    static final int RIGHT = 2;\n    static final int DOWN = 3;\n    \n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\tchar[][] map = new char[9][];\n\tfor ( int i = 0; i < 9; i++ ) {\n\t    map[i] = stdin.nextLine().toCharArray();\n\t}\n\n\tint x = 0;\n\tint y = 0;\n\tint direction = RIGHT;\n\t\n\tdo {\n\n\t    if ( !hasLine( direction, map, y, x ) ) {\n\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t    final int nd = ( direction + i + 3 ) % 4;\n\t\t    if ( hasLine( nd, map, y, x ) ) {\n\t\t\tdirection = nd;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    x += dx[direction];\n\t    y += dy[direction];\n\n\t    System.out.print( dirStr[direction] );\n\t    \n\t} while ( x != 0 || y != 0 );\n\t\n\tSystem.out.println();\t\n    }\n\n    static boolean hasLine( int direction, char[][] map, int y, int x ) {\n\t\n\tif ( 0 <= direction && direction < 4 ) {\n\t    final int nx = x + dx[direction];\n\t    final int ny = y + dy[direction];\n\t    \n\t    if ( 0 <= nx && nx <= map[0].length &&\n\t\t 0 <= ny && ny <= map[0].length ) {\n\t\t\n\t\tswitch( direction ) {\n\t\tcase RIGHT:\n\t\t    return map[y * 2][x] == '1';\n\t\tcase DOWN:\n\t\t    return map[y * 2 + 1][x] == '1';\n\t\tcase LEFT:\n\t\t    return map[y * 2][x - 1] == '1';\n\t\tcase UP:\n\t\t    return map[y * 2 - 1][x] == '1';\n\t\tdefault:\n\t\t    return false;\n\t\t}\n\t\t\n\t    } else {\n\t\treturn false;\n\t    }\n\t} else {\n\t    return false;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n    static ArrayList<Character> list=new ArrayList<Character>();\n    \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            //System.out.print(\"U\");\n            list.add('U');\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            //System.out.print(\"R\");\n            list.add('R');\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            //System.out.print(\"D\");\n            list.add('D');\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            //System.out.print(\"L\");\n            list.add('L');\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                for(char ch:list) System.out.print(ch+\"\");\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        //solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');walkon(walk,1,0);\n        while(true){\n        if(walkon(walk,nX,nY))break;}\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static int nX=0, nY=0;\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';nX=x;nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX!=0||nY!=0) return false;\n        else return true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t//1110 start\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint mapsize = 9;\n\t\twhile(sc.hasNext()){\n\t\t\tint [][] pass = new int[mapsize][mapsize];\n\t\t\tfor(int i = 0; i < mapsize; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tif(i % 2 == 0){\n\t\t\t\t\tArrays.fill(pass[i], 1);\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tint c = s.charAt(j) - '0';\n\t\t\t\t\t\tpass[i][j * 2 + 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tint c = s.charAt(j) - '0';\n\t\t\t\t\t\tpass[i][j * 2] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] vx = {-1,0,1,0};\n\t\t\tint [] vy = {0,-1,0,1};\n\t\t\tString [] word = {\"L\", \"U\", \"R\", \"D\"};\n\t\t\tint nowx = 0, nowy = 0;\n\t\t\tint dir = 2;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(true){\n\t\t\t\tfor(int i = 3; i < 7; i++){\n\t\t\t\t\tint xx = nowx + vx[(i + dir) % 4];\n\t\t\t\t\tint yy = nowy + vy[(i + dir) % 4];\n\t\t\t\t\tint xxx = xx + vx[(i + dir) % 4];\n\t\t\t\t\tint yyy = yy + vy[(i + dir) % 4];\n\t\t\t\t\tif(! isOK(xx, yy, mapsize)) continue;\n\t\t\t\t\tif(! isOK(xxx, yyy, mapsize)) continue;\n\t\t\t\t\tif(pass[yy][xx] == 0) continue;\n\t\t\t\t\tif(pass[yyy][xxx] == 0) continue;\n\t\t\t\t\tnowx = xxx;\n\t\t\t\t\tnowy = yyy;\n\t\t\t\t\tdir = (i + dir) % 4;\n\t\t\t\t\tsb.append(word[(dir)]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(nowx == 0 && nowy == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString());\n\t\t}\n\t}\n\t\n\tprivate boolean isOK(int x,int y,int mapsize){\n\t\tif(0 <= x && x < mapsize && 0 <= y && y < mapsize){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Path on a Grid\npublic class Main {\n\n\tvoid run(){\n\t\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\tchar[] ch = {'U','R','D','L'};\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean[][] e = new boolean[25][25];\n\t\tint h = 0, t = 0;\n\t\tfor(int x=0;x<9;x++){\n\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<s.length;j++){\n\t\t\t\tif(s[j]=='0')continue;\n\t\t\t\tif(t==0)e[h*5+j][h*5+j+1] = e[h*5+j+1][h*5+j] = true;\n\t\t\t\telse e[h*5+j][(h+1)*5+j] = e[(h+1)*5+j][h*5+j] = true;\n\t\t\t}\n\t\t\tif(t==1)h++;\n\t\t\tt=(t+1)%2;\n\t\t}\n\t\tint i=0, j=0, d=1;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean con = true;\n\t\twhile(con){\n\t\t\tfor(int k=3;k<=6;k++){\n\t\t\t\tint nd = (d+k)%4;\n\t\t\t\tint ni = i+move[nd][0];\n\t\t\t\tint nj = j+move[nd][1];\n\t\t\t\tif(0<=ni&&ni<5&&0<=nj&&nj<5&&e[i*5+j][ni*5+nj]){\n\t\t\t\t\tsb.append(ch[nd]);\n\t\t\t\t\ti = ni; j = nj; d = nd;\n\t\t\t\t\tif(i==0&&j==0)con = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew AOJ0037().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[][];\n\t\tint x, y, d;\n\t\tString st;\n\n\t\ta = new int[10][10];\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tst = sc.next();\n\t\t\tfor (int j = 0; j < st.length();  j++) {\n\t\t\t\ta[i][j] = st.charAt(j) - '0';\n\t\t\t}\n\t\t}\n\t\tx = 2;\n\t\ty = 1;\n\t\td = 1;\n\t\tboolean flag = true;\n\t\twhile (flag || x != 2 || y != 1) {\n\t\t\tflag = false;\n\t\t\tif (d == 1) {\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tif (1 < y && a[(y - 1) * 2 - 1][x - 1] == 1) {\n\t\t\t\t\td = 4;\n\t\t\t\t} else if (a[(y - 1) * 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 2;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t}\n\t\t\t} else if (d == 2) {\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tif (a[(y - 1) * 2][x - 2] == 1) {\n\t\t\t\t\td = 1;\n\t\t\t\t} else if (a[(y - 1) * 2 + 1][x - 2] == 1) {\n\t\t\t\t\ty++;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty++;\n\t\t\t\t\td = 3;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td = 4;\n\t\t\t\t}\n\t\t\t} else if (d == 3) {\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tif (a[(y - 1) * 2 - 1][x - 2] == 1) {\n\t\t\t\t\td = 2;\n\t\t\t\t} else if (2 < x && a[(y - 1) * 2 - 2][x - 3] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 2] == 1) {\n\t\t\t\t\tx--;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 4;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tif (1 < y && a[(y - 1) * 2 - 2][x - 2] == 1) {\n\t\t\t\t\td = 3;\n\t\t\t\t} else if (2 < y && a[(y - 1) * 2 - 3][x - 1] == 1) {\n\t\t\t\t\ty--;\n\t\t\t\t} else if (1 < y && a[(y - 1) * 2 - 2][x - 1] == 1) {\n\t\t\t\t\tx++;\n\t\t\t\t\ty--;\n\t\t\t\t\td = 1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_UP    = 1;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_DOWN  = 2;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_LEFT  = 4;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_RIGHT = 8;\n\n\tprivate\tstatic\t\t\tBufferedReader\t\tstdin = null;\n\n\tstatic {\n\t\tstdin = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tbyte[][]\tmap = null;\n\n\t\twhile ((map = parseMap()) != null) {\n\t\t\ttraceRoute(map);\n\t\t}\n\t}\n\n\tprivate static void traceRoute(byte[][] map) {\n\t\tint nX   = 0;\n\t\tint nY   = 0;\n\t\tint\tnDir = DIRECT_RIGHT;\n\n\t\twhile (true) {\n\t\t\tint bit = map[nY][nX];\n\n\t\t\tswitch (nDir) {\n\t\t\tcase DIRECT_UP:\n\t\t\t\t{\n\t\t\t\t\tif ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_RIGHT:\n\t\t\t\t{\n\t\t\t\t\tif ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_DOWN:\n\t\t\t\t{\n\t\t\t\t\tif ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_LEFT:\n\t\t\t\t{\n\t\t\t\t\tif ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (nDir) {\n\t\t\tcase DIRECT_UP:\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_RIGHT:\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_DOWN:\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_LEFT:\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (nX == 0 && nY == 0) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static byte[][] parseMap() {\n\t\tbyte[][]\tmap   = null;\n\t\tString\t\tline  = null;\n\t\tint\t\t\tn1    = 0;\n\n\t\tfor (; ; n1++) {\n\t\t\tline = parseStdin();\n\t\t\tif (line == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n1 == 0) {\n\t\t\t\tmap = new byte[5][5];\n\t\t\t}\n\n\t\t\tswitch((n1 % 2)) {\n\t\t\tcase 0:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_RIGHT;\n\t\t\t\t\t\t\tmap[n1 / 2][n2 + 1] |= DIRECT_LEFT;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_DOWN;\n\t\t\t\t\t\t\tmap[n1 / 2 + 1][n2] |= DIRECT_UP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = stdin.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint[][] mapA = new int[5][4];\n\tint[][] mapB = new int[4][5];\n\tint x, y, d;\n\tboolean flag;\n\t\n\tvoid U(){\n\t\tif(flag==true && y>0 && mapB[y-1][x]==1){\n\t\t\td=0;\n\t\t\ty--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"U\");\n\t\t}\n\t}\n\t\n\tvoid R(){\n\t\tif(flag==true && x<4 && mapA[y][x]==1){\n\t\t\td=1;\n\t\t\tx++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"R\");\n\t\t}\n\t}\n\t\n\tvoid D(){\n\t\tif(flag==true && y<4 && mapB[y][x]==1){\n\t\t\td=2;\n\t\t\ty++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"D\");\n\t\t}\n\t}\n\t\n\tvoid L(){\n\t\tif(flag==true && x>0 && mapA[y][x-1]==1){\n\t\t\td=3;\n\t\t\tx--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"L\");\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<9;i++){\n\t\t\tString s = sc.next();\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}\n\t\t}\n\t\tx = 0;\n\t\ty = 0;\n\t\td = 1;\n\n\t\twhile(true){\n\t\t\tflag = true;\n\t\t\tif(d==0){\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t}else if(d==1){\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t}else if(d==2){\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t}else if(d==3){\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t}\n\t\t\t\n\t\t\tif(x==0 && y==0){\n\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main.solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n        public static void main(String[] args){\n                Scanner sc = new Scanner(System.in);\n                boolean[][] map = new boolean[9][];\n                for(int i = 0; i < 9; i++){\n                        String s = sc.nextLine();\n                        boolean[] b = new boolean[s.length()];\n                        for(int j = 0; j < s.length(); j++){\n                                b[j] = s.charAt(j) == '1';\n                        }   \n                        map[i] = b;\n                }   \n                sc.close();\n                int[] x = new int[2];\n                boolean[][][] p = new boolean[5][5][4];\n                for(int i = 0; i < 5; i++){\n                        for(int j = 0; j < 5; j++){\n                                boolean[] b = p[i][j];\n                                b[0] = j < 4 ? map[2*i][j] : false;\n                                b[1] = i < 4 ? map[2*i+1][j] : false;\n                                b[2] = j > 0 ? map[2*i][j-1] : false;\n                                b[3] = i > 0 ? map[2*i-1][j] : false;\n                        }   \n                }   \n                do{ \n                        add(x, Direction.next(p[x[0]][x[1]]));\n                }while(!Arrays.equals(x, new int[2]));\n                System.out.println();\n        }   \n        static void add(int[] a, int[] b){\n                a[0] += b[0];\n                a[1] += b[1];\n        }   \n        static class Direction{\n                static int c = 0;\n                static int[][] v = {{0,1},{1,0},{0,-1},{-1,0}};\n                static String[] s = {\"R\",\"D\",\"L\",\"U\"};\n                static int[] next(boolean[] wall){\n                        int tmp = next(next(next(c)));\n                        while(!wall[tmp]){\n                                tmp = next(tmp);\n                        }   \n                        c = tmp;\n                        System.out.print(s[c]);\n                        return v[c];\n                }   \n                static private int next(int d){\n                        if(++d == 4) d = 0;\n                        return d;\n                }   \n        }   \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nfor(int i=0;i<5;i++){\nfor(int j=0;j<5;j++){\ntimes[i][j]=0;\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(sty != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//System.out.println(stx+\",\"+sty+\",\");\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString di;\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(dir,x,y)){\nSystem.out.print(dir);\ndi=dir;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 11)) line = sc.nextLine();\n\n\t\t\tSystem.out.print(i + \" : \");\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\n\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t\t\n\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"ULD\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RUL\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DRU\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LDR\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px==0py==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder(\"R\");\n\t\tString string;\n\t\tint map[][] = new int[13][13], c = 0; \n\t\tfor(int i = 0; i < 13; i++) Arrays.fill(map[i], 2);\n\t\twhile((string = reader.readLine()) != null){\n\t\t\tif(string.equals(\"\")) break;\n\t\t\tchar ch[] = string.toCharArray();\n\t\t\tif(ch.length % 2 == 0){\n\t\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\t\tmap[c + 2][i * 2 + 1] = ch[i - 1] - '0';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\t\tmap[c + 2][i * 2 + 2] = ch[i] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\tint x = 3, y = 2;\n\t\twhile(true){\n\t\t\tmap[y][x] = 0;\n\t\t\tif(map[y][x + 2] == 1){\n\t\t\t\tx += 2;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"R\");\n\t\t\t}else if(map[y + 1][x + 1] == 1){\n\t\t\t\ty++; x++;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"D\");\n\t\t\t}else if(map[y + 2][x] == 1){\n\t\t\t\ty += 2;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"D\");\n\t\t\t}else if(map[y + 1][x - 1] == 1){\n\t\t\t\ty++; x--;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"L\");\n\t\t\t}else if(map[y][x - 2] == 1){\n\t\t\t\tx -= 2;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"L\");\n\t\t\t}else if(map[y - 1][x - 1] == 1){\n\t\t\t\ty--; x--;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"U\");\n\t\t\t}else if(map[y - 2][x] == 1){\n\t\t\t\ty -= 2;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"U\");\n\t\t\t}else if(map[y - 1][x + 1] == 1){\n\t\t\t\ty--; x++;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t\tsb.append(\"R\");\n\t\t\t}else break;\n\t\t}\n\t\tSystem.out.println(sb);\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n??????????????????????????¨????(?????????n=0??????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y?????????£???????????¨????(?????????0,0???0???¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static final int[] dx = {-1, 0, 1, 0};\n    static final int[] dy = {0, -1, 0, 1};\n\n    static final int LEFT = 0;\n    static final int UP = 1;\n    static final int RIGHT = 2;\n    static final int DOWN = 3;\n    static final String[] dirStr = {\"L\", \"U\", \"R\", \"D\"};\n    \n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\tchar[][] map = new char[9][];\n\tfor ( int i = 0; i < 9; i++ ) {\n\t    map[i] = stdin.nextLine().toCharArray();\n\t}\n\n\tint x = 0;\n\tint y = 0;\n\tint direction = RIGHT;\n\t\n\tdo {\n\n\t    if ( !hasLine( direction, map, y, x ) ) {\n\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t    final int nd = ( direction + i + 3 ) % 4;\n\t\t    if ( hasLine( nd, map, y, x ) ) {\n\t\t\tdirection = nd;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    x += dx[direction];\n\t    y += dy[direction];\n\n\t    System.out.print( dirStr[direction] );\n\t    \n\t} while ( x != 0 || y != 0 );\n\t\n\tSystem.out.println();\t\n    }\n\n    static boolean hasLine( int direction, char[][] map, int y, int x ) {\n\t\n\tif ( 0 <= direction && direction < 4 ) {\n\t    final int nx = x + dx[direction];\n\t    final int ny = y + dy[direction];\n\t    \n\t    if ( 0 <= nx && nx <= map[0].length &&\n\t\t 0 <= ny && ny <= map[0].length ) {\n\t\t\n\t\tswitch( direction ) {\n\t\tcase RIGHT:\n\t\t    return map[y * 2][x] == '1';\n\t\tcase DOWN:\n\t\t    return map[y * 2 + 1][x] == '1';\n\t\tcase LEFT:\n\t\t    return map[y * 2][x - 1] == '1';\n\t\tcase UP:\n\t\t    return map[y * 2 - 1][x] == '1';\n\t\tdefault:\n\t\t    return false;\n\t\t}\n\t\t\n\t    } else {\n\t\treturn false;\n\t    }\n\t} else {\n\t    return false;\n\t}\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    static final int[] dx = {-1, 0, 1, 0};\n    static final int[] dy = {0, -1, 0, 1};\n\n    static final int LEFT = 0;\n    static final int UP = 1;\n    static final int RIGHT = 2;\n    static final int DOWN = 3;\n    static final String[] dirStr = {\"L\", \"U\", \"R\", \"D\"};\n    \n    public static void main(String[] args) {\n\n\tfinal Scanner stdin = new Scanner(System.in);\n\n\tchar[][] map = new char[9][];\n\tfor ( int i = 0; i < 9; i++ ) {\n\t    map[i] = stdin.nextLine().toCharArray();\n\t}\n\n\tint x = 0;\n\tint y = 0;\n\tint direction = -1;\n\t\n\tdo {\n\n\t    if ( !hasLine( direction, map, y, x ) ) {\n\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t    final int nd = ( direction + i + 3 ) % 4;\n\t\t    if ( hasLine( nd, map, y, x ) ) {\n\t\t\tdirection = nd;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    x += dx[direction];\n\t    y += dy[direction];\n\n\t    System.out.print( dirStr[direction] );\n\t    \n\t} while ( x != 0 || y != 0 );\n\t\n\tSystem.out.println();\t\n    }\n\n    static boolean hasLine( int direction, char[][] map, int y, int x ) {\n\t\n\tif ( 0 <= direction && direction < 4 ) {\n\t    final int nx = x + dx[direction];\n\t    final int ny = y + dy[direction];\n\t    \n\t    if ( 0 <= nx && nx <= map[0].length &&\n\t\t 0 <= ny && ny <= map[0].length ) {\n\t\t\n\t\tswitch( direction ) {\n\t\tcase RIGHT:\n\t\t    return map[y * 2][x] == '1';\n\t\tcase DOWN:\n\t\t    return map[y * 2 + 1][x] == '1';\n\t\tcase LEFT:\n\t\t    return map[y * 2][x - 1] == '1';\n\t\tcase UP:\n\t\t    return map[y * 2 - 1][x] == '1';\n\t\tdefault:\n\t\t    return false;\n\t\t}\n\t\t\n\t    } else {\n\t\treturn false;\n\t    }\n\t} else {\n\t    return false;\n\t}\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n     \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            System.out.print(\"U\");\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            System.out.print(\"R\");\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            System.out.print(\"D\");\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            System.out.print(\"L\");\n        }\n    }\n     \n    static void solve(){\n        Scanner sc = new Scanner(System.in);\n         \n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif(px==0&&py==0){\nreturn;\n}\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean next = true;\n\t\twhile(next){\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t\tif(x == 1 && y == 1) next = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n enum Vec {\n\tR,\n\tU,\n\tL,\n\tD;\n\tVec next() {\n\t return (this == R) ? D : (this == D) ? L\n\t\t : (this == L) ? U : R;\n\t}\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tboolean isKisu = true;\n\tList<boolean[]> gusu = new ArrayList<boolean[]>();\n\tList<boolean[]> kisu = new ArrayList<boolean[]>();\n\tboolean hasLine = in.hasNextLine();\n\twhile (hasLine) {\n\t hasLine = in.hasNextLine();\n\t isKisu = !isKisu;\n\t String nextLine = in.nextLine();\n\t if (nextLine.equals(\"end\")) {\n\t\tbreak;\n\t }\n\t char[] str = nextLine.toCharArray();\n\t boolean[] bs = new boolean[str.length];\n\t for (int i = 0; i < bs.length; i++) {\n\t\tbs[i] = (str[i] == '1');\n\t }\n\t ((isKisu) ? kisu : gusu).add(bs);\n\t}\n\tMap<Point, Map<Vec, Point>> map = new HashMap<Point, Map<Vec, Point>>();\n\tint ySize = gusu.size();\n\tint xSize = kisu.get(0).length;\n\tfor (int y = 0; y < ySize; y++) {\n\t for (int x = 0; x < xSize; x++) {\n\t\tmap.put(\n\t\t  new Point(x, y),\n\t\t  new EnumMap<Vec, Point>(Vec.class));\n\t }\n\t}\n\t{\n\t int size = gusu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = gusu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (gusu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint r = new Point(x + 1, y);\n\t\t\tmap.get(o).put(Vec.R, r);\n\t\t\tmap.get(r).put(Vec.L, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\t{\n\t int size = kisu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = kisu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (kisu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint d = new Point(x, y + 1);\n\t\t\tmap.get(o).put(Vec.D, d);\n\t\t\tmap.get(d).put(Vec.U, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\tVec next = Vec.R;\n\tPoint posi = new Point(0, 0);\n\tdo {\n\t next = next.next().next().next();\n\t Map<Vec, Point> point = map.get(posi);\n\t while (!point.containsKey(next)) {\n\t\tnext = next.next();\n\t }\n\t System.out.print(next);\n\t posi = point.get(next);\n\t} while (posi.x != 0 || posi.y != 0);\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport jav.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,inty){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturm;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport jav.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,inty){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n enum Vec {\n\tR,\n\tU,\n\tL,\n\tD;\n\tVec next() {\n\t return (this == R) ? D : (this == D) ? L\n\t\t : (this == L) ? U : R;\n\t}\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tboolean isKisu = true;\n\tList<boolean[]> gusu = new ArrayList<boolean[]>();\n\tList<boolean[]> kisu = new ArrayList<boolean[]>();\n\tboolean hasLine = in.hasNextLine();\n\twhile (hasLine) {\n\t hasLine = in.hasNextLine();\n\t isKisu = !isKisu;\n\t String nextLine = in.nextLine();\n\t if (nextLine.equals(\"end\")) {\n\t\tbreak;\n\t }\n\t char[] str = nextLine.toCharArray();\n\t boolean[] bs = new boolean[str.length];\n\t for (int i = 0; i < bs.length; i++) {\n\t\tbs[i] = (str[i] == '1');\n\t }\n\t ((isKisu) ? kisu : gusu).add(bs);\n\t}\n\tMap<Point, Map<Vec, Point>> map = new HashMap<Point, Map<Vec, Point>>();\n\tint ySize = gusu.size();\n\tint xSize = kisu.get(0).length;\n\tfor (int y = 0; y < ySize; y++) {\n\t for (int x = 0; x < xSize; x++) {\n\t\tmap.put(\n\t\t  new Point(x, y),\n\t\t  new EnumMap<Vec, Point>(Vec.class));\n\t }\n\t}\n\t{\n\t int size = gusu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = gusu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (gusu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint r = new Point(x + 1, y);\n\t\t\tmap.get(o).put(Vec.R, r);\n\t\t\tmap.get(r).put(Vec.L, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\t{\n\t int size = kisu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = kisu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (kisu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint d = new Point(x, y + 1);\n\t\t\tmap.get(o).put(Vec.D, d);\n\t\t\tmap.get(d).put(Vec.U, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\tVec next = Vec.R;\n\tPoint posi = new Point(0, 0);\n\tdo {\n\t next = next.next().next().next();\n\t Map<Vec, Point> point = map.get(posi);\n\t while (!point.containsKey(next)) {\n\t\tnext = next.next();\n\t }\n\t System.out.print(next);\n\t posi = point.get(next);\n\t} while (posi.x != 0 || posi.y != 0);\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n enum Vec {\n\tR,\n\tU,\n\tL,\n\tD;\n\tVec next() {\n\t return (this == R) ? D : (this == D) ? L\n\t\t : (this == L) ? U : R;\n\t}\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tboolean isKisu = true;\n\tList<boolean[]> gusu = new ArrayList<boolean[]>();\n\tList<boolean[]> kisu = new ArrayList<boolean[]>();\n\twhile (in.hasNextLine()) {\n\n\t isKisu = !isKisu;\n\t char[] str = in.nextLine().toCharArray();\n\t boolean[] bs = new boolean[str.length];\n\t for (int i = 0; i < bs.length; i++) {\n\t\tbs[i] = (str[i] == '1');\n\t }\n\t ((isKisu) ? kisu : gusu).add(bs);\n\t}\n\tMap<Point, Map<Vec, Point>> map = new HashMap<Point, Map<Vec, Point>>();\n\tint ySize = gusu.size();\n\tint xSize = kisu.get(0).length;\n\tfor (int y = 0; y < ySize; y++) {\n\t for (int x = 0; x < xSize; x++) {\n\t\tmap.put(\n\t\t  new Point(x, y),\n\t\t  new EnumMap<Vec, Point>(Vec.class));\n\t }\n\t}\n\t{\n\t int size = gusu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = gusu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (gusu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint r = new Point(x + 1, y);\n\t\t\tmap.get(o).put(Vec.R, r);\n\t\t\tmap.get(r).put(Vec.L, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\t{\n\t int size = kisu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = kisu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (kisu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint d = new Point(x, y + 1);\n\t\t\tmap.get(o).put(Vec.D, d);\n\t\t\tmap.get(d).put(Vec.U, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\tVec next = Vec.R;\n\tPoint posi = new Point(0, 0);\n\tdo {\n\t next = next.next().next().next();\n\t Map<Vec, Point> point = map.get(posi);\n\t while (!point.containsKey(next)) {\n\t\tnext = next.next();\n\t }\n\t System.out.print(next);\n\t posi = point.get(next);\n\t} while (posi.x != 0 || posi.y != 0);\n\tSystem.out.println();\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport jav.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,inty){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&char[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturm;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n enum Vec {\n\tR,\n\tU,\n\tL,\n\tD;\n\tVec next() {\n\t return (this == R) ? D : (this == D) ? L\n\t\t : (this == L) ? U : R;\n\t}\n }\n\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tboolean isKisu = true;\n\tList<boolean[]> gusu = new ArrayList<boolean[]>();\n\tList<boolean[]> kisu = new ArrayList<boolean[]>();\n\tboolean hasLine = in.hasNextLine();\n\twhile (hasLine) {\n\t hasLine = in.hasNextLine();\n\t isKisu = !isKisu;\n\t String nextLine = in.nextLine();\n\t if (nextLine.equals(\"end\")) {\n\t\tbreak;\n\t }\n\t char[] str = nextLine.toCharArray();\n\t boolean[] bs = new boolean[str.length];\n\t for (int i = 0; i < bs.length; i++) {\n\t\tbs[i] = (str[i] == '1');\n\t }\n\t ((isKisu) ? kisu : gusu).add(bs);\n\t}\n\tMap<Point, Map<Vec, Point>> map = new HashMap<Point, Map<Vec, Point>>();\n\tint ySize = gusu.size();\n\tint xSize = kisu.get(0).length;\n\tfor (int y = 0; y < ySize; y++) {\n\t for (int x = 0; x < xSize; x++) {\n\t\tmap.put(\n\t\t  new Point(x, y),\n\t\t  new EnumMap<Vec, Point>(Vec.class));\n\t }\n\t}\n\t{\n\t int size = gusu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = gusu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (gusu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint r = new Point(x + 1, y);\n\t\t\tmap.get(o).put(Vec.R, r);\n\t\t\tmap.get(r).put(Vec.L, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\t{\n\t int size = kisu.size();\n\t for (int y = 0; y < size; y++) {\n\t\tint length = kisu.get(y).length;\n\t\tfor (int x = 0; x < length; x++) {\n\t\t if (kisu.get(y)[x]) {\n\t\t\tPoint o = new Point(x, y);\n\t\t\tPoint d = new Point(x, y + 1);\n\t\t\tmap.get(o).put(Vec.D, d);\n\t\t\tmap.get(d).put(Vec.U, o);\n\t\t }\n\t\t}\n\t }\n\t}\n\tVec next = Vec.R;\n\tPoint posi = new Point(0, 0);\n\tdo {\n\t next = next.next().next().next();\n\t Map<Vec, Point> point = map.get(posi);\n\t while (!point.containsKey(next)) {\n\t\tnext = next.next();\n\t }\n\t System.out.print(next);\n\t posi = point.get(next);\n\t} while (posi.x != 0 || posi.y != 0);\n }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oi\");\n        \t}\n        \tsb.append(direction);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport jav.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine;\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir=\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir=\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir=\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir=\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir=\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px==0&&py==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n\npublic class Main {\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_NONE  = 0;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_UP    = 1;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_DOWN  = 2;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_LEFT  = 4;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_RIGHT = 8;\n\n\tprivate\tstatic\t\t\tBufferedReader\t\tstdin = null;\n\tprivate\tstatic\t\t\tArrayList<String>\tplist = null;\n\tprivate\tstatic\t\t\tArrayList<Integer>\tdlist = null;\n\n\tstatic {\n\t\tstdin = new BufferedReader(new InputStreamReader(System.in));\n\t\tplist = new ArrayList<String>();\n\t\tdlist = new ArrayList<Integer>();\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tbyte[][]\tmap = null;\n\n\t\twhile ((map = parseMap()) != null) {\n\t\t\ttraceRoute(map);\n\t\t}\n\t}\n\n\tprivate static void traceRoute(byte[][] map) {\n\t\tint nX    = 0;\n\t\tint nY    = 0;\n\t\tint\tnDir  = DIRECT_RIGHT;\n\t\tint\tnStop = -1;\n\n\t\twhile (true) {\n\t\t\tint bit = map[nY][nX];\n\n\t\t\tif ((bit & nDir) == 0) {\n\t\t\t\tif ((bit & DIRECT_UP) != 0 && nDir != DIRECT_DOWN) {\n\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t}\n\t\t\t\telse if ((bit & DIRECT_DOWN) != 0 && nDir != DIRECT_UP) {\n\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t}\n\t\t\t\telse if ((bit & DIRECT_LEFT) != 0 && nDir != DIRECT_RIGHT) {\n\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t}\n\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0 && nDir != DIRECT_LEFT) {\n\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnDir = DIRECT_NONE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nDir == DIRECT_NONE) {\n\t\t\t\tnStop = plist.size();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString\tpitem  = String.format(\"%d %d\", nX, nY);\n\t\t\t\tint\t\tnIndex = plist.indexOf(pitem);\n\n\t\t\t\tif (nIndex != -1) {\n\t\t\t\t\tnStop = nIndex;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tplist.add(pitem);\n\t\t\t\tdlist.add(nDir);\n\n\t\t\t\tswitch (nDir) {\n\t\t\t\tcase DIRECT_UP:\n\t\t\t\t\tnY--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECT_DOWN:\n\t\t\t\t\tnY++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECT_LEFT:\n\t\t\t\t\tnX--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECT_RIGHT:\n\t\t\t\t\tnX++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int n = 0; n < dlist.size(); n++) {\n\t\t\tswitch (dlist.get(n)) {\n\t\t\tcase DIRECT_UP:\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_DOWN:\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_LEFT:\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_RIGHT:\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int n = nStop - 1; n >= 0; n--) {\n\t\t\tswitch (dlist.get(n)) {\n\t\t\tcase DIRECT_UP:\n\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_DOWN:\n\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_LEFT:\n\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_RIGHT:\n\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n\n\tprivate static byte[][] parseMap() {\n\t\tbyte[][]\tmap   = null;\n\t\tString\t\tline  = null;\n\t\tint\t\t\tn1    = 0;\n\n\t\tfor (; ; n1++) {\n\t\t\tline = parseStdin();\n\t\t\tif (line == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n1 == 0) {\n\t\t\t\tmap = new byte[5][5];\n\t\t\t}\n\n\t\t\tswitch((n1 % 2)) {\n\t\t\tcase 0:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_RIGHT;\n\t\t\t\t\t\t\tmap[n1 / 2][n2 + 1] |= DIRECT_LEFT;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_DOWN;\n\t\t\t\t\t\t\tmap[n1 / 2 + 1][n2] |= DIRECT_UP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = stdin.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\n\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tchar[][] UD=new char[5][4];\n\t\t\tchar[][] LR=new char[4][5];\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tUD[i]=sc.next().toCharArray();\n\t\t\t\tLR[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tUD[4]=sc.next().toCharArray();\n\n\t\t\tchar[][][] root=new char[5][5][4];\n\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\troot[i][j][0]=UD[i][j];\n\t\t\t\troot[i][4][0]='0';\n\n\t\t\t\tif(i==0){\n\t\t\t\t\tfor(int j=0;j<5;j++)\n\t\t\t\t\t\troot[i][j][1]='0';\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0;j<5;j++)\n\t\t\t\t\t\troot[i][j][1]=LR[i-1][j];\n\t\t\t\t}\n\t\t\t\troot[i][0][2]='0';\n\t\t\t\tfor(int j=1;j<5;j++)\n\t\t\t\t\troot[i][j][2]=UD[i][j-1];\n\n\t\t\t\tif(i==4){\n\t\t\t\t\tfor(int j=0;j<5;j++)\n\t\t\t\t\t\troot[i][j][3]='0';\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0;j<5;j++)\n\t\t\t\t\t\troot[i][j][3]=LR[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint px=0,py=0;\n\t\t\tint rotate=0;//0 1 2 3\n\t\t\tdo{\n\t\t\t\tfor(int i=4-1;i>=0;i--){\n\t\t\t\t\tint r=(rotate+i+2)%4;\n\t\t\t\t\tif(root[py][px][r]=='1'){\n\t\t\t\t\t\trotate=r;\n\t\t\t\t\t\tswitch(r){\n\t\t\t\t\t\tcase 0:pr(\"R\");px++;break;\n\t\t\t\t\t\tcase 1:pr(\"U\");py--;break;\n\t\t\t\t\t\tcase 2:pr(\"L\");px--;break;\n\t\t\t\t\t\tcase 3:pr(\"D\");py++;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}while(!(px==0 && py==0));\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\twhile(true){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y == 1 && x == 1) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tSystem.out.print(i + \" : \");\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\tSystem.out.println();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\twhile(true){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y == 1 && x == 1) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tString[] a = new String[5];\n\t\tString[] b = new String[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ta[i] = reader.readLine();\n\t\t\tb[i] = reader.readLine();\n\t\t}\n\t\ta[4] = reader.readLine();\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tchar direction = 'R';\n\t\twhile (true) {\n\n\t\t\tif (direction == 'R') {\n\t\t\t\tif (x > 0 && b[x - 1].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'U';\n\t\t\t\t\tx--;\n\t\t\t\t} else if (y < 4 && a[x].charAt(y) == '1') {\n\t\t\t\t\ty++;\n\t\t\t\t} else if (b[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'D';\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'L';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t} else if (direction == 'D') {\n\t\t\t\tif (y < 4 && a[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'R';\n\t\t\t\t\ty++;\n\t\t\t\t} else if (x < 4 && b[x].charAt(y) == '1') {\n\t\t\t\t\tx++;\n\t\t\t\t} else if (y > 0 && a[x].charAt(y - 1) == '1') {\n\t\t\t\t\tdirection = 'L';\n\t\t\t\t\ty--;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'U';\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t} else if (direction == 'L') {\n\t\t\t\tif (x < 4 && b[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'D';\n\t\t\t\t\tx++;\n\t\t\t\t} else if (y > 0 && a[x].charAt(y - 1) == '1') {\n\t\t\t\t\ty--;\n\t\t\t\t} else if (x > 0 && b[x - 1].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'U';\n\t\t\t\t\tx--;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'R';\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (y > 0 && a[x].charAt(y - 1) == '1') {\n\t\t\t\t\tdirection = 'L';\n\t\t\t\t\ty--;\n\t\t\t\t} else if (x > 0 && b[x - 1].charAt(y) == '1') {\n\t\t\t\t\tx--;\n\t\t\t\t} else if (a[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'R';\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'D';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbuilder.append(direction);\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tSystem.out.println(builder);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);;\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint[] dx={0, 1, 0, -1};\n\tint[] dy={-1, 0, 1, 0};\n\n\t// ----\n\tboolean[][] w1=new boolean[5][4];\n\t// |||||\n\tboolean[][] w2=new boolean[4][5];\n\n\tvoid run(){\n\t\tfor(int i=0; i<9; i++){\n\t\t\tboolean[] w;\n\t\t\tif(i%2==0)\n\t\t\t\tw=w1[i/2];\n\t\t\telse\n\t\t\t\tw=w2[i/2];\n\t\t\tString s=sc.nextLine();\n\t\t\tfor(int k=0; k<s.length(); k++){\n\t\t\t\tw[k]=s.charAt(k)=='1';\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint x=0, y=0;\n\t\tint d=1;\n\t\tfor(;;){\n\t\t\tfor(d=(d+3)%4;; d=(d+1)%4){\n\t\t\t\tif(d==0&&up(x, y)){\n\t\t\t\t\tprint(\"U\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==1&&right(x, y)){\n\t\t\t\t\tprint(\"R\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==2&&down(x, y)){\n\t\t\t\t\tprint(\"D\");\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(d==3&&left(x, y)){\n\t\t\t\t\tprint(\"L\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx[d];\n\t\t\ty+=dy[d];\n\t\t\tif((x|y)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintln(\"\");\n\t}\n\n\tboolean up(int x, int y){\n\t\treturn y>0&&w2[y-1][x];\n\t}\n\n\tboolean down(int x, int y){\n\t\treturn y<4&&w2[y][x];\n\t}\n\n\tboolean left(int x, int y){\n\t\treturn x>0&&w1[y][x-1];\n\t}\n\n\tboolean right(int x, int y){\n\t\treturn x<4&&w1[y][x];\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n    private static final int R = 0;\n    private static final int L = 1;\n    private static final int U = 2;\n    private static final int D = 3;\n\n    String w[] = new String[5];\n    String h[] = new String[4];\n    int Move,x,y;\n\n    Wall(String w[],String h[]) {\n        for (int i=0;i<4;i++) {\n            this.w[i] = w[i];\n            this.h[i] = h[i];\n        }\n        this.w[4] = w[4];\n        this.Move = R;\n        this.x = 1;\n        this.y = 0;\n        System.out.print(\"R\");\n    }\n\n    boolean exception() {\n         if (this.w[0].equals(\"1000\")) {\n            for (int i=0;i<4;i++) {\n                  if (this.w[i+1].equals(\"0000\")&&this.h[i].equals(\"00000\")) continue;\n                  else return false;\n              }\n          } else return false;\n         return true;\n    }\n\n    void Walked() {\n        while (true) {\n            if (this.x==0&&this.y==0) break;\n            if (this.Move==R) {\n                while (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"R\");\n                    if (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n                        this.y--;\n                        this.x++;\n                        this.Move = U;\n                        break;\n                    }\n                    this.x++;\n                }\n                if (this.Move==R) this.Move = D;\n            } else if (this.Move==L) {\n                while (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"L\");\n                    if (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                        this.Move = D;\n                        break;\n                    }\n                    this.x--;\n                }\n                if (this.Move==L) {\n                    this.x++;\n                    this.y--;\n                    this.Move = U;\n                }\n            } else if (this.Move==U) {\n                while (this.y>=0&&h[this.y].charAt(this.x)=='1') {    \n                    System.out.print(\"U\");\n                    if (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n                        this.x--;\n                        this.Move = L;\n                        break;\n                    }\n                    this.y--;\n                }\n                if (this.Move==U) {\n                    this.y++;\n                    this.Move = R;\n                }\n            } else if (this.Move==D) {\n                while (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"D\");\n                    if (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n                        this.y++;                    \n                        this.Move = R;\n                        break;\n                    }\n                    this.y++;\n                }\n                if (this.Move==D) {\n                    this.x--;\n                    this.Move = L;\n                }\n            }\n        }\n        if (exception()) System.out.print(\"L\");\n        System.out.println(\"\");\n    }\n}\nclass Main {\n    public static void main(String args[]) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        try {\n            String w[] = new String[5];\n            String h[] = new String[4];\n            for (int i=0;i<4;i++) {\n                w[i] = br.readLine();\n                h[i] = br.readLine();\n            }\n            w[4] = br.readLine();\n\n            Wall wall = new Wall(w,h);\n            wall.Walked();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tcreateGrid();\n\t\tMan saburou = new Man(Grid.INITIAL_VECTOR, Grid.X_START_POSITION, Grid.Y_START_POSITION);\n\t\tdo{\n\t\t\tsaburou.go();\n\t\t}while(!saburou.goalIn());\n\t\tSystem.out.println();\n\t}\n\tprivate static void createGrid() throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\t\tfor(int i = 0; i < Grid.getGridXLength(); i++){\n\t\t\tbuf = br.readLine();\n\t\t\tchar[] tmpX = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpX.length; j++){\n\t\t\t\tGrid.setGridX(i, j, tmpX[j] - '0');\n\t\t\t}\n\t\t\tif(i == Grid.getGridYLength())\tbreak;\n\t\t\tbuf=br.readLine();\n\t\t\tchar[] tmpY = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpY.length; j++){\n\t\t\t\tGrid.setGridY(i, j, tmpY[j] - '0');\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Grid{\n\tpublic static final int X_START_POSITION = 0;\n\tpublic static final int Y_START_POSITION = 0;\n\tpublic static final int INITIAL_VECTOR = Man.RIGHT;\n\tpublic static final int WALL_EXIST = 1;\n\tprivate static int[][] gridX = new int[5][4];\n\tprivate static int[][] gridY = new int[4][5];\n\tpublic static void setGridX(int i, int j, int exist) {\n\t\tGrid.gridX[i][j] = exist;\n\t}\n\tpublic static void setGridY(int i, int j, int exist) {\n\t\tGrid.gridY[i][j] = exist;\n\t}\n\tpublic static int getGridXLength() {\n\t\treturn gridX.length;\n\t}\n\tpublic static int getGridYLength() {\n\t\treturn gridY.length;\n\t}\n\tpublic static boolean gridXisWall(int i, int j){\n\t\treturn (gridX[i][j] == WALL_EXIST) ? true : false;\n\t}\n\tpublic static boolean gridYisWall(int i, int j){\n\t\treturn (gridY[i][j] == WALL_EXIST) ? true : false;\n\t}\n}\nclass Man{\n\tpublic static final int UP = 1;\n\tpublic static final int DOWN = 2;\n\tpublic static final int LEFT = 3;\n\tpublic static final int RIGHT = 4;\n\t\n\tprivate int vector;\n\tprivate int x;\n\tprivate int y;\n\tpublic Man(int initialVector, int startX, int startY) {\n\t\tvector = initialVector;\n\t\tx = startX;\n\t\ty = startY;\n\t}\n\t/**\n\t * 前回の移動後に決定した方向へ移動する\n\t */\n\tpublic void go(){\n\t\tswitch(vector){\n\t\tcase UP:\n\t\t\tgoUp();\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tgoDown();\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tgoLeft();\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tgoRight();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/**\n\t * 初期位置に戻ってきているか（ゴールしているか）判定する\n\t * @return\tゴールしているか\n\t */\n\tpublic boolean goalIn(){\n\t\treturn (x == Grid.X_START_POSITION && y == Grid.Y_START_POSITION);\n\t}\n\tprivate void goRight(){\n\t\tx++;\n\t\tSystem.out.print(\"R\");\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tvector = LEFT;\n\t}\n\tprivate void goLeft(){\n\t\tx--;\n\t\tSystem.out.print(\"L\");\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tvector = RIGHT;\n\t}\n\tprivate void goUp(){\n\t\ty--;\n\t\tSystem.out.print(\"U\");\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tvector = DOWN;\n\t}\n\tprivate void goDown(){\n\t\ty++;\n\t\tSystem.out.print(\"D\");\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tvector = UP;\n\t}\n\tprivate boolean findUpWall(){\n\t\tif(y == 0)\treturn false;\n\t\treturn\tGrid.gridYisWall(y - 1,x);\n\t}\n\tprivate boolean findDownWall(){\n\t\tif(y == 4)\treturn false;\n\t\treturn Grid.gridYisWall(y, x);\n\t}\n\tprivate boolean findLeftWall(){\n\t\tif(x == 0)\treturn false;\n\t\treturn Grid.gridXisWall(y, x - 1);\n\t}\n\tprivate boolean findRightWall(){\n\t\tif(x == 4)\treturn false;\n\t\treturn Grid.gridXisWall(y, x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif((i%2)==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nelse if(dir==\"U\"){\nreturn \"L\";\n}\nelse if(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nelse if(dir==\"U\"){\nreturn \"R\";\n}\nelse if(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nelse if(dir==\"U\"){\nreturn \"D\";\n}\nelse if(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nString di;\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(dir,x,y)){\nSystem.out.print(dir);\ndi=dir;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\nif(x==0&&y==0){\nreturn;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException,\n\t\t\tIOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tString[] a = new String[5];\n\t\tString[] b = new String[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\ta[i] = reader.readLine();\n\t\t\tb[i] = reader.readLine();\n\t\t}\n\t\ta[4] = reader.readLine();\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tchar direction = 'R';\n\t\twhile (true) {\n\n\t\t\tif (direction == 'R') {\n\t\t\t\tif (x > 0 && b[x - 1].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'U';\n\t\t\t\t\tx--;\n\t\t\t\t} else if (y < 4 && a[x].charAt(y) == '1') {\n\t\t\t\t\ty++;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'D';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t} else if (direction == 'D') {\n\t\t\t\tif (y < 4 && a[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'R';\n\t\t\t\t\ty++;\n\t\t\t\t} else if (x < 4 && b[x].charAt(y) == '1') {\n\t\t\t\t\tx++;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'L';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t} else if (direction == 'L') {\n\t\t\t\tif (x < 4 && b[x].charAt(y) == '1') {\n\t\t\t\t\tdirection = 'D';\n\t\t\t\t\tx++;\n\t\t\t\t} else if (y > 0 && a[x].charAt(y - 1) == '1') {\n\t\t\t\t\ty--;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'U';\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (y > 0 && a[x].charAt(y - 1) == '1') {\n\t\t\t\t\tdirection = 'L';\n\t\t\t\t\ty--;\n\t\t\t\t} else if (x > 0 && b[x - 1].charAt(y) == '1') {\n\t\t\t\t\tx--;\n\t\t\t\t} else {\n\t\t\t\t\tdirection = 'R';\n\t\t\t\t\ty++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbuilder.append(direction);\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tSystem.out.println(builder);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_UP    = 1;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_DOWN  = 2;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_LEFT  = 4;\n\tprivate\tstatic\tfinal\tint\t\t\t\t\tDIRECT_RIGHT = 8;\n\n\tprivate\tstatic\t\t\tBufferedReader\t\tstdin = null;\n\n\tstatic {\n\t\tstdin = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tbyte[][]\tmap = null;\n\n\t\twhile ((map = parseMap()) != null) {\n\t\t\ttraceRoute(map);\n\t\t}\n\t}\n\n\tprivate static void traceRoute(byte[][] map) {\n\t\tint nX   = 0;\n\t\tint nY   = 0;\n\t\tint\tnDir = DIRECT_RIGHT;\n\n\t\twhile (true) {\n\t\t\tint bit = map[nY][nX];\n\n\t\t\tswitch (nDir) {\n\t\t\tcase DIRECT_UP:\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tif ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_RIGHT:\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tif ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_DOWN:\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tif ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIRECT_LEFT:\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tif ((bit & DIRECT_DOWN) != 0) {\n\t\t\t\t\t\tnY++;\n\t\t\t\t\t\tnDir = DIRECT_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_LEFT) != 0) {\n\t\t\t\t\t\tnX--;\n\t\t\t\t\t\tnDir = DIRECT_LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_UP) != 0) {\n\t\t\t\t\t\tnY--;\n\t\t\t\t\t\tnDir = DIRECT_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((bit & DIRECT_RIGHT) != 0) {\n\t\t\t\t\t\tnX++;\n\t\t\t\t\t\tnDir = DIRECT_RIGHT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (nX == 0 && nY == 0) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static byte[][] parseMap() {\n\t\tbyte[][]\tmap   = null;\n\t\tString\t\tline  = null;\n\t\tint\t\t\tn1    = 0;\n\n\t\tfor (; ; n1++) {\n\t\t\tline = parseStdin();\n\t\t\tif (line == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n1 == 0) {\n\t\t\t\tmap = new byte[5][5];\n\t\t\t}\n\n\t\t\tswitch((n1 % 2)) {\n\t\t\tcase 0:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_RIGHT;\n\t\t\t\t\t\t\tmap[n1 / 2][n2 + 1] |= DIRECT_LEFT;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\t{\n\t\t\t\t\tfor(int n2 = 0; n2 < line.length(); n2++) {\n\t\t\t\t\t\tif (line.charAt(n2) == '1') {\n\t\t\t\t\t\t\tmap[n1 / 2][n2]     |= DIRECT_DOWN;\n\t\t\t\t\t\t\tmap[n1 / 2 + 1][n2] |= DIRECT_UP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = stdin.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n\tprivate static final int R = 0;\n\tprivate static final int L = 1;\n\tprivate static final int U = 2;\n\tprivate static final int D = 3;\n\n\tString w[] = new String[5];\n\tString h[] = new String[4];\n\tint Move,x,y;\n\n\tWall(String w[],String h[]) {\n\t\tfor (int i=0;i<4;i++) {\n\t\t\tthis.w[i] = w[i];\n\t\t\tthis.h[i] = h[i];\n\t\t}\n\t\tthis.w[4] = w[4];\n\t\tthis.Move = R;\n\t\tthis.x = this.y = 0;\n\t}\n\n\tvoid Walked() {\n\t\twhile (true) {\n\t\t\tif (this.Move==R) {\n\t\t\t\twhile (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tif (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n\t\t\t\t\t\tthis.y--;\n\t\t\t\t\t\tthis.x++;\n\t\t\t\t\t\tthis.Move = U;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==R) this.Move = D;\n\t\t\t} else if (this.Move==L) {\n\t\t\t\twhile (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tif (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\t\tthis.Move = D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.x--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==L) {\n\t\t\t\t\tthis.x++;\n\t\t\t\t\tthis.y--;\n\t\t\t\t\tthis.Move = U;\n\t\t\t\t}\n\t\t\t} else if (this.Move==U) {\n\t\t\t\twhile (this.y>=0&&h[this.y].charAt(this.x)=='1') {\t\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tif (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n\t\t\t\t\t\tthis.x--;\n\t\t\t\t\t\tthis.Move = L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y--;\n\t\t\t\t}\n\t\t\t\tif (this.Move==U) {\n\t\t\t\t\tthis.y++;\n\t\t\t\t\tthis.Move = R;\n\t\t\t\t}\n\t\t\t} else if (this.Move==D) {\n\t\t\t\twhile (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tif (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n\t\t\t\t\t\ty++;\t\t\t\t\t\n\t\t\t\t\t\tthis.Move = R;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tthis.y++;\n\t\t\t\t}\n\t\t\t\tif (this.Move==D) {\n\t\t\t\t\tthis.x--;\n\t\t\t\t\tthis.Move = L;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.x==0&&this.y==0) break;\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\ttry {\n\t\t\tString w[] = new String[5];\n\t\t\tString h[] = new String[4];\n\t\t\tfor (int i=0;i<4;i++) {\n\t\t\t\tw[i] = br.readLine();\n\t\t\t\th[i] = br.readLine();\n\t\t\t}\n\t\t\tw[4] = br.readLine();\n\n\t\t\tWall wall = new Wall(w,h);\n\t\t\twall.Walked();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                System.out.println(\"aa\");\n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return true;\n        else return walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\nclass Wall {\n    private static final int R = 0;\n    private static final int L = 1;\n    private static final int U = 2;\n    private static final int D = 3;\n\n    String w[] = new String[5];\n    String h[] = new String[4];\n    int Move,x,y;\n\n    Wall(String w[],String h[]) {\n        for (int i=0;i<4;i++) {\n            this.w[i] = w[i];\n            this.h[i] = h[i];\n        }\n        this.w[4] = w[4];\n        this.Move = R;\n        this.x = 1;\n        this.y = 0;\n        System.out.print(\"R\");\n    }\n\n    boolean exception() {\n         if (this.w[0].equals(\"1000\")) {\n              return true;\n        } else return false;\n    }\n\n    void Walked() {\n        while (true) {\n            if (this.x==0&&this.y==0) break;\n            if (this.Move==R) {\n                while (this.x<=3&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"R\");\n                    if (this.y>0&&h[this.y-1].charAt(this.x+1)=='1') {\n                        this.y--;\n                        this.x++;\n                        this.Move = U;\n                        break;\n                    }\n                    this.x++;\n                }\n                if (this.Move==R) this.Move = D;\n            } else if (this.Move==L) {\n                while (this.x>=0&&w[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"L\");\n                    if (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                        this.Move = D;\n                        break;\n                    }\n                    this.x--;\n                }\n                if (this.Move==L) {\n                    this.x++;\n                    this.y--;\n                    this.Move = U;\n                }\n            } else if (this.Move==U) {\n                while (this.y>=0&&h[this.y].charAt(this.x)=='1') {    \n                    System.out.print(\"U\");\n                    if (this.x>0&&w[this.y].charAt(this.x-1)=='1') {\n                        this.x--;\n                        this.Move = L;\n                        break;\n                    }\n                    this.y--;\n                }\n                if (this.Move==U) {\n                    this.y++;\n                    this.Move = R;\n                }\n            } else if (this.Move==D) {\n                while (this.y<=3&&h[this.y].charAt(this.x)=='1') {\n                    System.out.print(\"D\");\n                    if (this.x<=3&&w[this.y+1].charAt(this.x)=='1') {\n                        this.y++;                    \n                        this.Move = R;\n                        break;\n                    }\n                    this.y++;\n                }\n                if (this.Move==D) {\n                    this.x--;\n                    this.Move = L;\n                }\n            }\n        }\n        if (exception()) System.out.print(\"L\");\n        System.out.println(\"\");\n    }\n}\nclass Main {\n    public static void main(String args[]) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        try {\n            String w[] = new String[5];\n            String h[] = new String[4];\n            for (int i=0;i<4;i++) {\n                w[i] = br.readLine();\n                h[i] = br.readLine();\n            }\n            w[4] = br.readLine();\n\n            Wall wall = new Wall(w,h);\n            wall.Walked();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oi\");\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\t\tcreateGrid();\n\t\tMan saburou = new Man(Grid.INITIAL_VECTOR, Grid.MIN_X, Grid.MIN_Y);\n\t\tdo{\n\t\t\tsaburou.go();\n\t\t}while(!saburou.goalIn());\n\t\tSystem.out.println();\n\t}\n\t\n\tprivate static void createGrid() throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\t\tfor(int i = 0; i < Grid.getGridXLength(); i++){\n\t\t\tbuf = br.readLine();\n\t\t\tchar[] tmpX = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpX.length; j++){\n\t\t\t\tGrid.setGridX(i, j, tmpX[j] - '0');\n\t\t\t}\n\t\t\tif(i == Grid.getGridYLength())\tbreak;\n\t\t\tbuf=br.readLine();\n\t\t\tchar[] tmpY = buf.toCharArray();\n\t\t\tfor(int j = 0; j < tmpY.length; j++){\n\t\t\t\tGrid.setGridY(i, j, tmpY[j] - '0');\n\t\t\t}\n\t\t}\n\t}\n}\nclass Man{\n\tpublic static final int UP = 1;\n\tpublic static final int DOWN = 2;\n\tpublic static final int LEFT = 3;\n\tpublic static final int RIGHT = 4;\n\t\n\tprivate int vector;\n\tprivate int x;\n\tprivate int y;\n\tpublic Man(int initialVector, int startX, int startY) {\n\t\tvector = initialVector;\n\t\tx = startX;\n\t\ty = startY;\n\t}\n\t/**\n\t * 前回の移動後に決定した方向へ移動する\n\t */\n\tpublic void go(){\n\t\tswitch(vector){\n\t\tcase UP:\n\t\t\tgoUp();\n\t\t\tbreak;\n\t\tcase DOWN:\n\t\t\tgoDown();\n\t\t\tbreak;\n\t\tcase LEFT:\n\t\t\tgoLeft();\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tgoRight();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tprivate void goRight(){\n\t\tx++;\n\t\tSystem.out.print(\"R\");\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tvector = LEFT;\n\t}\n\tprivate void goLeft(){\n\t\tx--;\n\t\tSystem.out.print(\"L\");\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tvector = RIGHT;\n\t}\n\tprivate void goUp(){\n\t\ty--;\n\t\tSystem.out.print(\"U\");\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tif(findUpWall()){\n\t\t\tvector = UP;\n\t\t\treturn;\n\t\t}\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tvector = DOWN;\n\t}\n\tprivate void goDown(){\n\t\ty++;\n\t\tSystem.out.print(\"D\");\n\t\tif(findRightWall()){\n\t\t\tvector = RIGHT;\n\t\t\treturn;\n\t\t}\n\t\tif(findDownWall()){\n\t\t\tvector = DOWN;\n\t\t\treturn;\n\t\t}\n\t\tif(findLeftWall()){\n\t\t\tvector = LEFT;\n\t\t\treturn;\n\t\t}\n\t\tvector = UP;\n\t}\n\t\n\tprivate boolean findUpWall(){\n\t\tif(y == Grid.MIN_Y)\treturn false;\n\t\treturn\tGrid.gridYisWall(y - 1,x);\n\t}\n\tprivate boolean findDownWall(){\n\t\tif(y == Grid.MAX_Y)\treturn false;\n\t\treturn Grid.gridYisWall(y, x);\n\t}\n\tprivate boolean findLeftWall(){\n\t\tif(x == Grid.MIN_X)\treturn false;\n\t\treturn Grid.gridXisWall(y, x - 1);\n\t}\n\tprivate boolean findRightWall(){\n\t\tif(x == Grid.MAX_X)\treturn false;\n\t\treturn Grid.gridXisWall(y, x);\n\t}\n\t/**\n\t * 初期位置に戻ってきているか（ゴールしているか）判定する\n\t * @return\tゴールしているか\n\t */\n\tpublic boolean goalIn(){\n\t\treturn (x == Grid.MIN_X && y == Grid.MIN_Y);\n\t}\n}\n\nclass Grid{\n\tpublic static final int MIN_X = 0;\n\tpublic static final int MIN_Y = 0;\n\tpublic static final int MAX_X = 4;\n\tpublic static final int MAX_Y = 4;\n\tpublic static final int INITIAL_VECTOR = Man.RIGHT;\n\tpublic static final int WALL_EXIST = 1;\n\tprivate static int[][] gridX = new int[5][4];\n\tprivate static int[][] gridY = new int[4][5];\n\tpublic static void setGridX(int i, int j, int exist) {\n\t\tGrid.gridX[i][j] = exist;\n\t}\n\tpublic static void setGridY(int i, int j, int exist) {\n\t\tGrid.gridY[i][j] = exist;\n\t}\n\tpublic static int getGridXLength() {\n\t\treturn gridX.length;\n\t}\n\tpublic static int getGridYLength() {\n\t\treturn gridY.length;\n\t}\n\tpublic static boolean gridXisWall(int i, int j){\n\t\treturn (gridX[i][j] == WALL_EXIST) ? true : false;\n\t}\n\tpublic static boolean gridYisWall(int i, int j){\n\t\treturn (gridY[i][j] == WALL_EXIST) ? true : false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n    static int[][] grid;\n    static int MAX_HEIGHT = 9;\n    static int MAX_WIDTH = 9;\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tgrid = new int[MAX_HEIGHT][MAX_WIDTH];\n\tString line;\n\tint width, n, pos;\n\tfor (int i = 0; i < 9; i++) {\n\t    line = scan.nextLine();\n\t    width = 0;\n\t    for (int j = 0; j < line.length(); j++) {\n\t\tn = Integer.parseInt(line.substring(j, j+1));\n\t\tif (n == 0) {\n\t\t    continue;\n\t\t}\n\t\tif (i % 2 == 0) {\n\t\t    pos = j * 2;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i][pos+1] = 1;\n\t\t    grid[i][pos+2] = 1;\n\t\t} else {\n\t\t    pos = j*2;\n\t\t    grid[i-1][pos] = 1;\n\t\t    grid[i][pos] = 1;\n\t\t    grid[i+1][pos] = 1;\n\t\t}\n\t    }\n\t}\n\tsolve();\n    }\n    \n    static void solve () {\n\tStringBuilder sb = new StringBuilder();\n\tint width = 0, height = 0, direction = 0;\n\tint[] dwidth = {1, 0, -1, 0};\n\tint[] dheight = {0, 1, 0, -1};\n\tString[] textdirection = {\"R\", \"D\", \"L\", \"U\"};\n\t\n\twhile (true) {\n\t    for (int i = 3; i < 7; i++) {\n\t\tint nextwidth = width + dwidth[(i + direction) % 4];\n\t\tint nextheight = height + dheight[(i + direction) % 4];\n\t\tint nextnextwidth = nextwidth + dwidth[(i + direction) % 4];\n\t\tint nextnextheight = nextheight + dheight[(i + direction) % 4];\n\t\tif (!(0 <= nextwidth && nextwidth < MAX_WIDTH && 0 <= nextheight && nextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (!(0 <= nextnextwidth && nextnextwidth < MAX_WIDTH && 0 <= nextnextheight && nextnextheight < MAX_HEIGHT)) {\n\t\t    continue;\n\t\t}\n\t\tif (grid[nextheight][nextwidth] == 0 || grid[nextnextheight][nextnextwidth] == 0) {\n\t\t    continue;\n\t\t}\n\t\twidth = nextnextwidth;\n\t\theight = nextnextheight;\n\t\tdirection = (i + direction) % 4;\n\t\tsb.append(textdirection[direction]);\n\t\tbreak;\n\t    }\n\t    if (width == 0 && height == 0) {\n\t\tbreak;\n\t    }\n\t}\n\tSystem.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint times = 0;\n\t\tint[][][] map = new int [5][5][4];\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tm1 = new int[5][4];\n\t\t}\n\t\t\n\t\tfor(int[][] m1:map){\n\t\t\tfor(int[] m2:m1){\n\t\t\t\tm2 = new int[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(times < 9){\n\t\t\tString str = sc.nextLine();\n\t\t\tif(times % 2 == 0){\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tmap[times/2][i][0] = Integer.parseInt(String.valueOf(str.charAt(i))); // right\n\t\t\t\t}\n\t\t\t\tfor(int i = 1;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][2] = Integer.parseInt(String.valueOf(str.charAt(i-1))); // left\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2][i][1] = Integer.parseInt(String.valueOf(str.charAt(i))); // down\n\t\t\t\t}\n\t\t\t\tfor(int i = 0;i < 5;i++){\n\t\t\t\t\tmap[times/2+1][i][3] = Integer.parseInt(String.valueOf(str.charAt(i))); // up\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttimes++;\n\t\t}\n\t\t\n\t\tint dir = 0;\n\t\tint x = 1,y = 0;\n\t\tSystem.out.print(\"R\");\n\t\t\n\t\twhile(x != 0 || y != 0){\n\t\t\tif(dir == 0){\n\t\t\t\tif(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 1){\n\t\t\t\tif(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 2){\n\t\t\t\tif(map[y][x][1] == 1){\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(dir == 3){\n\t\t\t\tif(map[y][x][2] == 1){\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][3] == 1){\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(map[y][x][0] == 1){\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint[][] mapA = new int[5][4];\n\tint[][] mapB = new int[4][5];\n\tint x, y, d;\n\tboolean flag;\n\t\n\tvoid U(){\n\t\tif(flag==true && y>0 && mapB[y-1][x]==1){\n\t\t\td=0;\n\t\t\ty--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"U\");\n\t\t}\n\t}\n\t\n\tvoid R(){\n\t\tif(flag==true && x<4 && mapA[y][x]==1){\n\t\t\td=1;\n\t\t\tx++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"R\");\n\t\t}\n\t}\n\t\n\tvoid D(){\n\t\tif(flag==true && y<4 && mapB[y][x]==1){\n\t\t\td=2;\n\t\t\ty++;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"D\");\n\t\t}\n\t}\n\t\n\tvoid L(){\n\t\tif(flag==true && x>0 && mapA[y][x-1]==1){\n\t\t\td=3;\n\t\t\tx--;\n\t\t\tflag = false;\n\t\t\tSystem.out.print(\"L\");\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<9;i++){\n\t\t\tString s = sc.next();\n\t\t\tif(i%2==0){\n\t\t\t\tfor(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n\t\t\t}\n\t\t}\n\t\tx = 0;\n\t\ty = 0;\n\t\td = 1;\n\n\t\twhile(true){\n\t\t\tflag = true;\n\t\t\tif(d==0){\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t}else if(d==1){\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t}else if(d==2){\n\t\t\t\tR();\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t}else if(d==3){\n\t\t\t\tD();\n\t\t\t\tL();\n\t\t\t\tU();\n\t\t\t\tR();\n\t\t\t}\n\t\t\t\n\t\t\tif(x==0 && y==0){\n\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tnew AOJ_0037().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 0037\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final double EPS = 1e-10;\n\tpublic static void main(String[] args) {\n\t\tchar[][] cs = new char[20][1000];\n\t\tfor (int i = 0; i < 20; i++) fill(cs[i], '0');\n\t\t\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tString buf = sc.next();\n\t\t\tfor (int j = 0; j < buf.length(); j++) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tcs[i + 1][j * 2 + 2] = buf.charAt(j);\n\t\t\t\t} else {\n\t\t\t\t\tcs[i + 1][j * 2 + 1] = buf.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tint[] dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n\t\tString[] str = {\"R\", \"D\", \"L\", \"U\"}; \n\t\tint x = 1, y = 1, d = 0;\n\t\twhile (!(x == 1 && y == 1 && d != 0)) {\n\t\t\tif (cs[y + dy[d]][x + dx[d]] == '1') {\n\t\t\t\tx += dx[d] * 2; \n\t\t\t\ty += dy[d] * 2;\n\t\t\t\tSystem.out.print(str[d]);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (cs[y + dy[(d - 1 + 4) % 4]][x + dx[(d - 1 + 4) % 4]] == '1') {\n\t\t\t\t\td = (d - 1 + 4) % 4;\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif(px==0&&py==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\tstatic boolean map[][] = new boolean[11][11];\n\tstatic int x = 1, y = 1, vec = 0;\n\tstatic int dir[] = new int[]{3, 0, 1, 2};\n\tstatic int dx[][] = new int[][]{{1, 0, -1, 0}, {2, 0, -2, 0}};\n\tstatic int dy[][] = new int[][]{{0, 1, 0, -1}, {0, 2, 0, -2}};\n\tstatic String opr[] = new String[]{\"R\", \"D\", \"L\", \"U\"};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tchar str[];\n\t\t\n\t\tint tmp;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tstr = reader.readLine().toCharArray();\n\t\t\tif(i % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2] = true;\n\t\t\t\t\t\tmap[(i / 2) * 2 + 1][(j + 1) * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\ttmp = str[j] - '0';\n\t\t\t\t\tif(tmp == 1){\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2][j * 2 + 1] = true;\n\t\t\t\t\t\tmap[(i / 2 + 1) * 2 + 1][j * 2 + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapp.solve();\n\t\t\n\t\treader.close();\n\t}\n\t\n\tpublic void solve(){\n\t\tint tmp;\n\t\tboolean is, next = true;\n\t\twhile(next){\n\t\t\tis = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttmp = (dir[vec] + i) % 4;\n\t\t\t\tif(map[y + dy[0][tmp]][x + dx[0][tmp]]){\n\t\t\t\t\tis = false;\n\t\t\t\t\ty += dy[1][tmp];\n\t\t\t\t\tx += dx[1][tmp];\n\t\t\t\t\t\n\t\t\t\t\tvec = tmp;\n\t\t\t\t\tSystem.out.print(opr[tmp]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is){\n\t\t\t\tvec = (vec + 2) % 4;\n\t\t\t\tSystem.out.print(opr[vec]);\n\t\t\t}\n\t\t\tif(y == 1 && x == 1) break;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oi\");\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif(px==0&&py==0){\nreturn;\n}\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\ngotoDirection(dirb,px,py);\nSystem.out.print(dirb);\ndp[count+1]=dirb;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif((i%2)==1){\nmap[i][4]=line.charAt(4);\n}\n}\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.println(\"\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nelse if(dir==\"U\"){\nreturn \"L\";\n}\nelse if(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nelse if(dir==\"U\"){\nreturn \"R\";\n}\nelse if(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nelse if(dir==\"U\"){\nreturn \"D\";\n}\nelse if(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y!=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"U\"){\nif(x!=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse if(dir==\"L\"){\nif(y!=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x!=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nString di;\nString dirl=turnLeft(d);\nString dirr=turnRight(d);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\nSystem.out.print(dirl);\ndi=dirl;\n}\nelse if(cangoNext(d,x,y)){\nSystem.out.print(d);\ndi=d;\n}\nelse if(cangoNext(dirr,x,y)){\nSystem.out.print(dirr);\ndi=dirr;\n}\nelse{\nSystem.out.print(dirb);\ndi=dirb;\n}\nif(di==\"R\"){\ny++;\n}\nif(di==\"U\"){\nx--;\n}\nif(di==\"L\"){\ny--;\n}\nif(di==\"D\");{\nx++;\n}\nif(x==0&&y==0){\nreturn;\n}\ngotoPath(x,y,di);\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t\tSystem.out.println(\"pei\");\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t\tSystem.out.println(\"pei\");\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t\tSystem.out.println(\"pei\");\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t\tSystem.out.println(\"pei\");\n        \t\t}\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return true;\n        else return walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nfor(int i=0;i<5;i++){\nfor(int j=0;j<5;i++){\ntimes[i][j]~0;\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\nstatic int[][] times=new int[5][5];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\nfor(int i=0;i<5;i++){\nfor(int j=0;j<5;i++){\ntimes[i][j]=0;\n}\n}\ngotoPath(0,1);\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=1;\ntimes[0][0]=0;\ndp[1]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerFirst(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)==0){\nreturn;\n}\nint t=times[px][py];\nif(t>0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\nreturn;\n}\ncount++;\nPoint np=new Point();\nnp.x=px;\nnp.y=py;\nque.offerFirst(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\tint[][] map = new int[11][11];\n\n\t\tString line = \"\";\n\t\tfor (int i = 0; i < 11; i++) {\n\t\t\tif ((i != 0) && (i != 10)) line = sc.nextLine();\n\n\t\t\tSystem.out.print(i + \" : \");\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i == 0) || (j == 0) || (i == 10) || (j == 10)) {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\n\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ((j % 2) != (i % 2)) map[i][j] = line.charAt((j - 1) / 2) - '0';\n\t\t\t\telse map[i][j] = 0;\n\t\t\t\t\n\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tint x = 2;\n\t\tint y = 0;\n\t\tint v = 1;\n\t\t\n\t\twhile (true) {\n\t\t\tswitch (v) {\n\t\t\tcase 0:\n\t\t\t\tif (map[y][x + 1] == 1) {\n\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\ty = y - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"U\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"UL\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (map[y + 1][x] == 1) {\n\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\tx = x + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y - 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"R\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"RU\");\n\t\t\t\t\t\t\tv = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\ty = y + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (map[y][x - 1] == 1) {\n\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\ty = y + 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y][x + 1] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"D\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"DR\");\n\t\t\t\t\t\t\tv = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv++;\n\t\t\t\t\tx = x - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (map[y - 1][x] == 1) {\n\t\t\t\t\tif (map[y][x - 1] == 0) {\n\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\tx = x - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (map[y + 1][x] == 0) {\n\t\t\t\t\t\t\tSystem.out.print(\"L\");\n\t\t\t\t\t\t\tv = 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSystem.out.print(\"LD\");\n\t\t\t\t\t\t\tv = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tv = 0;\n\t\t\t\t\ty = y - 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x == 2) && (y == 0)) break;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            //break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n\nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n?????????????????????????¨????(?????????n=0?????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y????????£??????????¨????(?????????0,0???0??¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nd.offerLast(p);\nwhile(que.peekFirst!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[25];\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ndp[1]=\"R\";\nSystem.out.print(\"R\");\ngotoPath(0,1,\"R\");\nSystem.out.print(\"\\n\");\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String back(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y,String d){\nif(x==0&&y==0){\nreturn;\n}\nString dir=d;\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nString dirb=back(d);\nif(cangoNext(dirl,x,y)){\ngotoDirection(dirl,x,y);\nSystem.out.print(dirl);\ngotoPath(x,y,dirl);\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ngotoPath(x,y,dir);\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ngotoPath(x,y,dirr);\n}\nelse{\ngotoDirection(dirb,px,py);\nSystem.out.print(dirb);\ngotoPath(x,y,dirb);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"resource\")\n\t\tScanner sc = new Scanner(System.in);\n\t\tint time = 0;\n\t\tint[][][] map = new int[5][5][4];\n\n\t\tfor (int[][] a : map) {\n\t\t\ta = new int[5][4];\n\t\t}\n\n\t\tfor (int[][] a : map) {\n\t\t\tfor (int[] b : a) {\n\t\t\t\tb = new int[4];\n\t\t\t}\n\t\t}\n\n\t\twhile (time < 9) {\n\t\t\tString inputData = sc.nextLine();\n\n\t\t\tif (time % 2 == 0) {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tmap[time / 2][i][0] = Integer.parseInt(String\n\t\t\t\t\t\t\t.valueOf(inputData.charAt(i)));\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i < 5; i++) {\n\t\t\t\t\tmap[time / 2][i][2] = Integer.parseInt(String\n\t\t\t\t\t\t\t.valueOf(inputData.charAt(i - 1)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tmap[time / 2][i][1] = Integer.parseInt(String\n\t\t\t\t\t\t\t.valueOf(inputData.charAt(i)));\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tmap[time / 2 + 1][i][3] = Integer.parseInt(String\n\t\t\t\t\t\t\t.valueOf(inputData.charAt(i)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tint dir = 0;\n\t\tint x = 1, y = 0;\n\n\t\tSystem.out.print(\"R\");\n\n\t\twhile (x != 0 || y != 0) {\n\n\t\t\tif (dir == 0) {\n\t\t\t\tif (map[y][x][3] == 1) {\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\n\t\t\t\t\tSystem.out.print(\"U\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][0] == 1) {\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\n\t\t\t\t\tSystem.out.print(\"R\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][1] == 1) {\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\n\t\t\t\t\tSystem.out.print(\"D\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\n\t\t\t\t\tSystem.out.print(\"L\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (dir == 1) {\n\t\t\t\tif (map[y][x][0] == 1) {\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\n\t\t\t\t\tSystem.out.print(\"R\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][1] == 1) {\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\n\t\t\t\t\tSystem.out.print(\"D\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][2] == 1) {\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\n\t\t\t\t\tSystem.out.print(\"L\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\n\t\t\t\t\tSystem.out.print(\"U\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (dir == 2) {\n\t\t\t\tif (map[y][x][1] == 1) {\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\n\t\t\t\t\tSystem.out.print(\"D\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][2] == 1) {\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\n\t\t\t\t\tSystem.out.print(\"L\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][3] == 1) {\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\n\t\t\t\t\tSystem.out.print(\"U\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\n\t\t\t\t\tSystem.out.print(\"R\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (dir == 3) {\n\t\t\t\tif (map[y][x][2] == 1) {\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tx--;\n\n\t\t\t\t\tSystem.out.print(\"L\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][3] == 1) {\n\t\t\t\t\tdir = 3;\n\t\t\t\t\ty--;\n\n\t\t\t\t\tSystem.out.print(\"U\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (map[y][x][0] == 1) {\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tx++;\n\n\t\t\t\t\tSystem.out.print(\"R\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tdir = 1;\n\t\t\t\t\ty++;\n\n\t\t\t\t\tSystem.out.print(\"D\");\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final char cDir[] = {\n\t\t'U', 'R', 'D', 'L'\n\t};\n\t\n\tpublic static final int pDir[][] = {\n\t\t{0, -1}, {1, 0}, {0, 1}, {-1, 0}\n\t};\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\twhile(scan.hasNext()){\n\t\t\tchar map[][] = new char [9][5];\n\t\t\tboolean neighbor[][][] = new boolean [5][5][4];\n\t\t\tint hand[] = {0, 0};\t//現在の座標\n\t\t\tint iDir = 1;\t\t\t//cDir や pDirに対応している。\n\t\t\tString answer = new String();\n\t\t\t\n\t\t\t//入力処理\n\t\t\tfor(int i=0; i<9; i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\t//neighbor初期化\n\t\t\tfor(int i=0; i<5; ++i){\n\t\t\t\tfor(int j=0; j<5; ++j){\n\t\t\t\t\t//Up\n\t\t\t\t\tneighbor[i][j][0] = 0<=(i*2-1) ? (map[i*2 -1][j] == '1') : false;\n\t\t\t\t\t//Right\n\t\t\t\t\tneighbor[i][j][1] = j<(5-1) ? (map[i*2][j] == '1') : false;\n\t\t\t\t\t//Down\n\t\t\t\t\tneighbor[i][j][2] = (i*2+1)<9 ? (map[i*2+1][j] == '1') : false;\n\t\t\t\t\t//Left\n\t\t\t\t\tneighbor[i][j][3] = 0<=(j-1) ? (map[i*2][j-1] == '1') : false; \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//本体\n\t\t\tint x=0, y=0;\n\t\t\twhile(true){\n\t\t\t\t//探索\n\t\t\t\tx = hand[0]; y = hand[1];\n\t\t\t\tif(neighbor[y][x][(iDir+3)%4]){\n\t\t\t\t\tiDir = (iDir+3)%4;\n\t\t\t\t}else if(neighbor[y][x][(iDir+0)%4]){\n\t\t\t\t\tiDir = (iDir+0)%4;\n\t\t\t\t}else if(neighbor[y][x][(iDir+1)%4]){\n\t\t\t\t\tiDir = (iDir+1)%4;\n\t\t\t\t}else{\n\t\t\t\t\tiDir = (iDir+2)%4;\t//逆戻り\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//結果処理\n\t\t\t\thand[0] += pDir[iDir][0];\n\t\t\t\thand[1] += pDir[iDir][1];\n\t\t\t\tanswer += cDir[iDir];\n\t\t\t\t//動いた先が点Aだったらループから抜ける。\n\t\t\t\tif(hand[0]==0 && hand[1]==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  static boolean[][] wall = new boolean[9][];\n  static int[] point = {0,0,0};\n\n  public static boolean[] lineSet(String str){\n    boolean[] line = new boolean[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n      if (str.charAt(i) == '0') {\n        line[i] = false;\n      }\n      else {\n        line[i] = true;\n      }\n    }\n    return line;\n  }\n\n  public static void directionR(){\n    if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n  }\n  public static void directionD(){\n    if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n    else if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n  }\n  public static void directionL(){\n    if (point[0] < 8 && wall[point[0]+1][point[1]]) {\n      System.out.print(\"D\");\n      point[0] += 2;\n      point[2] = 1;\n    }\n    else if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n  }\n  public static void directionU(){\n    if (point[1] > 0 && wall[point[0]][point[1]-1]) {\n      System.out.print(\"L\");\n      point[1]--;\n      point[2] = 2;\n    }\n    else if (point[0] > 0 && wall[point[0]-1][point[1]]) {\n      System.out.print(\"U\");\n      point[0] -= 2;\n      point[2] = 3;\n    }\n    else if (point[1] < 4 && wall[point[0]][point[1]]) {\n      System.out.print(\"R\");\n      point[1]++;\n      point[2] = 0;\n    }\n  }\n\n  public static void direction(){\n    switch(point[2]) {\n      case 0:\n        directionR();\n        break;\n      case 1:\n        directionD();\n        break;\n      case 2:\n        directionL();\n        break;\n      case 3:\n        directionU();\n    }\n  }\n\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    for (int i = 0; i < 9; i++) {\n      String str = sc.next();\n      wall[i] = lineSet(str);\n    }\n    while(true) {\n      direction();\n      if (point[0] == 0 && point[1] == 0) {\n        break;\n      }\n    }\n    System.out.println(\"\");\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import static color.ImageUtility.*;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.util.ArrayList;\nimport javax.imageio.ImageIO;\n\npublic class Main {\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                line=br.readLine();for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n            }\n            break;\n        }\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch);\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static boolean walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return true;\n        else return walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.awt.*;\nimport java.util.*;\n \nclass Main{\nstatic char[][] map=new char[9][5];\nstatic String[] dp=new String[40];\n//n??????????????????????????¨????(?????????n=0??????¨??????\"\")\nstatic int[][] times=new int[5][5];\n//????????????x,y?????????£???????????¨????(?????????0,0???0???¨??????)\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line;\nfor(int i=0;i<9;i++){\nline=br.readLine();\nfor(int j=0;j<4;j++){\nmap[i][j]=line.charAt(j);\n}\nif(i%2==1){\nmap[i][4]=line.charAt(4);\n}\n}\ngotoPath(0,1);\n}\nstatic String turnLeft(String dir){\nif(dir==\"R\"){\nreturn \"U\";\n}\nif(dir==\"U\"){\nreturn \"L\";\n}\nif(dir==\"L\"){\nreturn \"D\";\n}\nelse{\nreturn \"R\";\n}\n}\nstatic String turnRight(String dir){\nif(dir==\"R\"){\nreturn \"D\";\n}\nif(dir==\"U\"){\nreturn \"R\";\n}\nif(dir==\"L\"){\nreturn \"U\";\n}\nelse{\nreturn \"L\";\n}\n}\nstatic void gotoDirection(String dir,int x,int y){\nif(dir==\"R\"){\ny++;\n}\nif(dir==\"U\"){\nx--;\n}\nif(dir==\"L\"){\ny--;\n}\nelse{\nx++;\n}\n}\nstatic String returntoStart(String dir){\nif(dir==\"R\"){\nreturn \"L\";\n}\nif(dir==\"U\"){\nreturn \"D\";\n}\nif(dir==\"L\"){\nreturn \"R\";\n}\nelse{\nreturn \"U\";\n}\n}\nstatic boolean cangoNext(String dir,int x,int y){\nif(dir==\"R\"){\nif(y+1<=4&&map[2*x][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"U\"){\nif(x-1>=0&&map[2*x-1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nif(dir==\"L\"){\nif(y-1>=0&&map[2*x][y-1]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nelse{\nif(x+1<=4&&map[2*x+1][y]=='1'){\nreturn true;\n}\nelse{\nreturn false;\n}\n}\n}\nstatic void gotoPath(int x,int y){\nPoint p=new Point(x,y);\nint count=0;\ntimes[0][0]=count++;\ndp[count]=\"R\";\nSystem.out.print(\"R\");\nDeque<Point> que=new ArrayDeque<Point>();\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint px=p.x;\nint py=p.y;\nif((px&py)!=0){\nreturn;\n}\nint t=times[px][py];\nif(t!=0){\nfor(int i=t;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ntimes[px][py]=count;\nString dir=dp[count];\nString dirl=turnLeft(dir);\nString dirr=turnRight(dir);\nif(cangoNext(dirl,px,py)){\ngotoDirection(dirl,px,py);\nSystem.out.print(dirl);\ndp[count+1]=dirl;\n}\nelse if(cangoNext(dir,px,py)){\ngotoDirection(dir,px,py);\nSystem.out.print(dir);\ndp[count+1]=dir;\n}\nelse if(cangoNext(dirr,px,py)){\ngotoDirection(dirr,px,py);\nSystem.out.print(dirr);\ndp[count+1]=dirr;\n}\nelse{\nfor(int i=count;i>0;i--){\nString str=dp[i];\nSystem.out.print(returntoStart(str));\n}\npx=0;\npy=0;\n}\ncount++;\nPoint np=new Point(px,py);\nque.offerLast(np);\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[][] mapA = new int[5][4];\n    static int[][] mapB = new int[4][5];\n    static int x, y, d;\n    static boolean flag;\n     \n    static void U(){\n        if(flag==true && y>0 && mapB[y-1][x]==1){\n            d=0;\n            y--;\n            flag = false;\n            System.out.print(\"U\");\n        }\n    }\n     \n    static void R(){\n        if(flag==true && x<4 && mapA[y][x]==1){\n            d=1;\n            x++;\n            flag = false;\n            System.out.print(\"R\");\n        }\n    }\n     \n    static void D(){\n        if(flag==true && y<4 && mapB[y][x]==1){\n            d=2;\n            y++;\n            flag = false;\n            System.out.print(\"D\");\n        }\n    }\n     \n    static void L(){\n        if(flag==true && x>0 && mapA[y][x-1]==1){\n            d=3;\n            x--;\n            flag = false;\n            System.out.print(\"L\");\n        }\n    }\n     \n    static void solve(){\n        \n        try{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String line;\n            while((line=br.readLine())!=null){\n                for(int i=0;i<4;i++) mapA[0][i]=Integer.parseInt(line.charAt(i)+\"\");\n                for(int i=0;i<4;i++){\n                    line=br.readLine();\n                    for(int j=0;j<5;j++)mapB[i][j]=Integer.parseInt(line.charAt(j)+\"\");\n                    line=br.readLine();\n                    for(int j=0;j<4;j++)mapA[i+1][j]=Integer.parseInt(line.charAt(j)+\"\");\n\n                }\n                break;\n            }\n        }catch(Exception e){}\n        Scanner sc = new Scanner(System.in);\n         /*\n        for(int i=0;i<9;i++){\n            String s = sc.next();\n            if(i%2==0){\n                for(int j=0;j<4;j++) mapA[i/2][j] = s.codePointAt(j)-48;\n            }else{\n                for(int j=0;j<5;j++) mapB[i/2][j] = s.codePointAt(j)-48;\n            }\n        }*/\n        x = 0;\n        y = 0;\n        d = 1;\n \n        while(true){\n            flag = true;\n            if(d==0){\n                L();\n                U();\n                R();\n                D();\n            }else if(d==1){\n                U();\n                R();\n                D();\n                L();\n            }else if(d==2){\n                R();\n                D();\n                L();\n                U();\n            }else if(d==3){\n                D();\n                L();\n                U();\n                R();\n            }\n             \n            if(x==0 && y==0){\n                System.out.println();\n                break;\n            }\n        }\n    }\n    \n    static int horW[]=new int[20],verW[]=new int[20];\n    public static void main(String[] args)  {\n        solve(); if(horW[0]==0)return;\n        try{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        ArrayList<Character>walk=new ArrayList<Character>();\n        while((line=br.readLine())!=null){\n            for(int i=0;i<4;i++) horW[i]=Integer.parseInt(line.charAt(i)+\"\");\n            for(int i=0;i<4;i++){\n                \n                line=br.readLine();\n                for(int j=0;j<5;j++)verW[5*i+j]=Integer.parseInt(line.charAt(j)+\"\");\n                line=br.readLine();\n                for(int j=0;j<4;j++)horW[4*(i+1)+j]=Integer.parseInt(line.charAt(j)+\"\");\n                \n            }\n            break;\n        }\n            //System.out.println(\"hW\"+Arrays.toString(horW));\n            //System.out.println(\"vW\"+Arrays.toString(verW));\n        walk.add('R');\n        walkon(walk,1,0);\n        for(char ch : walk) System.out.print(ch+\"\");\n            System.out.println(\"\");\n              \n        }catch(Exception e){}\n    }\n    static void walkon(ArrayList<Character>walk,int x, int y){\n        char preD=walk.get(walk.size()-1);char nextD='1';int nX=x,nY=y;\n        int uW = (y==0)? 0:verW[(y-1)*5+x]; int dW = (y==4)? 0: verW[y*5+x];\n        int rW = (x==4)? 0:horW[x+4*y]; int lW =(x==0)? 0: horW[x-1+4*y];\n        switch(preD){\n            case 'R':\n                if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                break;\n            case 'U':\n                if(lW==1){nextD='L';nX--;}else if(uW==1){nextD='U';nY--;}\n                else if(rW==1){nextD='R';nX++;}\n                break;\n            case 'L':\n                if(dW==1){nextD='D';nY++;}else if(lW==1){nextD='L';nX--;}\n                else if(uW==1){nextD='U';nY--;}break;\n            case 'D':\n                if(rW==1){nextD='R';nX++;}else if(dW==1){nextD='D';nY++;}\n                else if(lW==1){nextD='L';nX--;}break;\n        }\n        walk.add(nextD);\n        if(nX==0&&nY==0)return ;\n        else walkon(walk,nX,nY);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br =\n\t\t\t\tnew BufferedReader(new InputStreamReader(System.in));\n\t\t/*\n\t\t * 1 <= i, j < = 5\n\t\t * horiEdge[i][0] = horiEdge[i][5] = '\\u0000'\n\t\t * vertEdge[0][j] = vertEdge[5][j] = '\\u0000'\n\t\t */\n\t\tchar[][] horiEdge = new char[6][6];\n\t\tchar[][] vertEdge = new char[6][6];\n\t\tfor (int i=1; /* i <= 5 */; i++) {\n\t\t\tchar[] data;\n\n\t\t\tdata = br.readLine().toCharArray();\n\t\t\tfor (int j=1; j <= 4; j++) {\n\t\t\t\thoriEdge[i][j] = data[j-1];\n\t\t\t}\n\n\t\t\tif (i==5) break;\n\n\t\t\tdata = br.readLine().toCharArray();\n\t\t\tfor (int j=1; j <= 5; j++) {\n\t\t\t\tvertEdge[i][j] = data[j-1];\n\t\t\t}\n\t\t}\n\n\t\tWanderer man = new Wanderer();\n\t\tStringBuilder ans = new StringBuilder();\n\t\tdo {\n\t\t\tString temp = man.go(horiEdge, vertEdge);\n\t\t\tans.append(temp);\n\t\t} while ( ! (man.x == 1 && man.y == 1) );\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static final int right = 0;\n\tpublic static final int down = 1;\n\tpublic static final int left= 2;\n\tpublic static final int up = 3;\n\n\tpublic static class Wanderer {\n\t\tint x; // coordinate\n\t\tint y; // coordinate\n\t\tint dir; // direction\n\n\t\tpublic Wanderer() {\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 1;\n\t\t\tthis.dir = right;\n\t\t}\n\n\t\tpublic String go(char[][] horiEdge, char[][] vertEdge) {\n\t\t\tif (dir == right) {\n\t\t\t\tx = x+1;\n\t\t\t\tif (vertEdge[y-1][x] == '1') {\n\t\t\t\t\tdir = up;\n\t\t\t\t} else if (horiEdge[y][x] == '1') {\n\t\t\t\t\tdir = right;\n\t\t\t\t} else if (vertEdge[y][x] == '1') {\n\t\t\t\t\tdir = down;\n\t\t\t\t} else {\n\t\t\t\t\tdir = left;\n\t\t\t\t}\n\t\t\t\treturn \"R\";\n\t\t\t}\n\n\t\t\tif (dir == down) {\n\t\t\t\ty = y+1;\n\t\t\t\tif (horiEdge[y][x] == '1') {\n\t\t\t\t\tdir = right;\n\t\t\t\t} else if (vertEdge[y][x] == '1') {\n\t\t\t\t\tdir = down;\n\t\t\t\t} else if (horiEdge[y][x-1] == '1') {\n\t\t\t\t\tdir = left;\n\t\t\t\t} else {\n\t\t\t\t\tdir = up;\n\t\t\t\t}\n\t\t\t\treturn \"D\";\n\t\t\t}\n\n\t\t\tif (dir == left) {\n\t\t\t\tx = x-1;\n\t\t\t\tif (vertEdge[y][x] == '1') {\n\t\t\t\t\tdir = down;\n\t\t\t\t} else if (horiEdge[y][x-1] == '1') {\n\t\t\t\t\tdir = left;\n\t\t\t\t} else if (vertEdge[y-1][x] == '1') {\n\t\t\t\t\tdir = up;\n\t\t\t\t} else {\n\t\t\t\t\tdir = right;\n\t\t\t\t}\n\t\t\t\treturn \"L\";\n\t\t\t}\n\n\t\t\tif (dir == up) {\n\t\t\t\ty = y-1;\n\t\t\t\tif (horiEdge[y][x-1] == '1') {\n\t\t\t\t\tdir = left;\n\t\t\t\t} else if (vertEdge[y-1][x] == '1') {\n\t\t\t\t\tdir = up;\n\t\t\t\t} else if (horiEdge[y][x] == '1') {\n\t\t\t\t\tdir = right;\n\t\t\t\t} else {\n\t\t\t\t\tdir = down;\n\t\t\t\t}\n\t\t\t\treturn \"U\";\n\t\t\t}\n\n\t\t\treturn \"hoge\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj0037/input.txt\"));\n\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"src/xxxyyyy/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tchar[][] table = new char[9][9];\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tchar[] str = sc.next().toCharArray();\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tfor (int col = 1; col < 9; col += 2)\n\t\t\t\t\ttable[i][col] = str[col / 2];\n\t\t\t} else {\n\t\t\t\tfor (int col = 0; col < 9; col += 2)\n\t\t\t\t\ttable[i][col] = str[col / 2];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(solve(table));\n\n\t}\n\n\tString solve(char[][] table) {\n\t\tint row = 0, col = 0, dir = 0;\n\t\tchar[] dirs = \"RDLU\".toCharArray();\n\t\tint[] dr = { 0, 1, 0, -1 };\n\t\tint[] dc = { 1, 0, -1, 0 };\n\t\tStringBuilder sb = new StringBuilder();\n\t\tdo {\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint next_dir = (dir + i + 3) % 4;\n\t\t\t\tint nr = row + dr[next_dir];\n\t\t\t\tint nc = col + dc[next_dir];\n\t\t\t\tif( !(0 <= nr && nr < 9 && 0 <= nc && nc < 9) ) continue;\n\t\t\t\tif( table[nr][nc] != '1' ) continue;\n\t\t\t\trow = nr + dr[next_dir];\n\t\t\t\tcol = nc + dc[next_dir];\n\t\t\t\tdir = next_dir;\n\t\t\t\tsb.append(dirs[dir]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while( (row | col) != 0);\n\t\treturn sb.toString();\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tprivate static final Scanner scan = new Scanner(System.in);\n\tstatic boolean[][] wall = new boolean[9][];\n\tstatic int[] point = {0, 0, 0};\n\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(int i=0; i<9; i++){\n\t\t\tString str = scan.next();\n\t\t\twall[i] = lineSet(str);\n\t\t}\n\t\twhile(true){\n\t\t\tdirection();\n\t\t\tif(point[0] == 0 && point[1] == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static boolean[] lineSet(String str){\n\t\tboolean[] line = new boolean[str.length()];\n\t\tfor(int i=0; i<str.length(); i++){\n\t\t\tif(str.charAt(i) == '0'){\n\t\t\t\tline[i] = false;\n\t\t\t} else{\n\t\t\t\tline[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn line;\n\t}\n\n\tpublic static void direction(){\n\t\tswitch(point[2]){\n\t\t\tcase 0 :\n\t\t\t\tdirectionR();\n\t\t\t\tbreak;\n\t\t\tcase 1 :\n\t\t\t\tdirectionD();\n\t\t\t\tbreak;\n\t\t\tcase 2 :\n\t\t\t\tdirectionL();\n\t\t\t\tbreak;\n\t\t\tcase 3 :\n\t\t\t\tdirectionU();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static void directionR(){\n\t\t// ????????§????????????????£??????????\n\t\tif(point[0] > 0 && wall[point[0]-1][point[1]]){\n\t\t\tSystem.out.print(\"U\");\n\t\t\tpoint[0] -= 2;\n\t\t\tpoint[2] = 3;\n\t\t// ????????§?????????????£??????????\n\t\t} else if(point[1] < 4 && wall[point[0]][point[1]]){\n\t\t\tSystem.out.print(\"R\");\n\t\t\tpoint[1]++;\n\t\t\tpoint[2] = 0;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] < 8 && wall[point[0]+1][point[1]]){\n\t\t\tSystem.out.print(\"D\");\n\t\t\tpoint[0] += 2;\n\t\t\tpoint[2] = 1;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[1] > 0 && wall[point[0]][point[1]-1]){\n\t\t\tSystem.out.print(\"L\");\n\t\t\tpoint[1]--;\n\t\t\tpoint[2] = 2;\n\t\t}\n\t}\n\n\tpublic static void directionD(){\n\t\t// ????????§?????????????£??????????\n\t\tif(point[1] < 4 && wall[point[0]][point[1]]){\n\t\t\tSystem.out.print(\"R\");\n\t\t\tpoint[1]++;\n\t\t\tpoint[2] = 0;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] < 8 && wall[point[0]+1][point[1]]){\n\t\t\tSystem.out.print(\"D\");\n\t\t\tpoint[0] += 2;\n\t\t\tpoint[2] = 1;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[1] > 0 && wall[point[0]][point[1]-1]){\n\t\t\tSystem.out.print(\"L\");\n\t\t\tpoint[1]--;\n\t\t\tpoint[2] = 2;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] > 0 && wall[point[0]-1][point[1]]){\n\t\t\tSystem.out.print(\"U\");\n\t\t\tpoint[0] -= 2;\n\t\t\tpoint[2] = 3;\n\t\t}\n\t}\n\n\tpublic static void directionL(){\n\t\t// ????????§????????????????£??????????\n\t\tif(point[0] < 8 && wall[point[0]+1][point[1]]){\n\t\t\tSystem.out.print(\"D\");\n\t\t\tpoint[0] += 2;\n\t\t\tpoint[2] = 1;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[1] > 0 && wall[point[0]][point[1]-1]){\n\t\t\tSystem.out.print(\"L\");\n\t\t\tpoint[1]--;\n\t\t\tpoint[2] = 2;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] > 0 && wall[point[0]-1][point[1]]){\n\t\t\tSystem.out.print(\"U\");\n\t\t\tpoint[0] -= 2;\n\t\t\tpoint[2] = 3;\n\t\t// ????????§?????????????£??????????\n\t\t} else if(point[1] < 4 && wall[point[0]][point[1]]){\n\t\t\tSystem.out.print(\"R\");\n\t\t\tpoint[1]++;\n\t\t\tpoint[2] = 0;\n\t\t}\n\t}\n\n\tpublic static void directionU(){\n\t\t// ????????§????????????????£??????????\n\t\tif(point[1] > 0 && wall[point[0]][point[1]-1]){\n\t\t\tSystem.out.print(\"L\");\n\t\t\tpoint[1]--;\n\t\t\tpoint[2] = 2;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] > 0 && wall[point[0]-1][point[1]]){\n\t\t\tSystem.out.print(\"U\");\n\t\t\tpoint[0] -= 2;\n\t\t\tpoint[2] = 3;\n\t\t// ????????§?????????????£??????????\n\t\t} else if(point[1] < 4 && wall[point[0]][point[1]]){\n\t\t\tSystem.out.print(\"R\");\n\t\t\tpoint[1]++;\n\t\t\tpoint[2] = 0;\n\t\t// ????????§????????????????£??????????\n\t\t} else if(point[0] < 8 && wall[point[0]+1][point[1]]){\n\t\t\tSystem.out.print(\"D\");\n\t\t\tpoint[0] += 2;\n\t\t\tpoint[2] = 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\n        Scanner input = new Scanner(System.in);\n        String[] yoko = new String[5];\n        String[] tate = new String[4];\n\n        for(int i = 0 ; i < 5 ; i++){\n        \tif(i != 4){\n        \t\tyoko[i] = input.nextLine();\n        \t\ttate[i] = input.nextLine();\n        \t}else{\n        \t\tyoko[i] = input.nextLine();\n        \t}\n        }\n        int stx = 0;\n        int sty = 0;\n        char direction = 'R';\n        StringBuilder sb = new StringBuilder();\n        while(true){\n        \tif(direction == 'R'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}\n        \t}else if(direction == 'L'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}else if(tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}else{\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}\n        \t}else if(direction == 'U'){\n        \t\tif(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n            \t\t\tstx--;\n            \t\t\tdirection = 'L';\n        \t\t}else if(sty != 0 && tate[sty-1].charAt(stx) == '1'){\n        \t\t\tsty--;\n        \t\t}else if(yoko[sty].charAt(stx) == '1'){\n        \t\t\tstx++;\n        \t\t\tdirection = 'R';\n        \t\t}else{\n        \t\t\tsty++;\n        \t\t\tdirection = 'D';\n        \t\t}\n        \t}else if(direction == 'D'){\n        \t\tif(stx != 4 && yoko[sty].charAt(stx) == '1'){\n         \t\t\tstx++;\n         \t\t\tdirection = 'R';\n        \t\t}else if(sty != 4 && tate[sty].charAt(stx) == '1'){\n        \t\t\tsty++;\n        \t\t}else if(stx != 0 && yoko[sty].charAt(stx-1) == '1'){\n        \t\t\tstx--;\n        \t\t\tdirection = 'L';\n        \t\t}else{\n        \t\t\tsty--;\n        \t\t\tdirection = 'U';\n        \t\t}\n        \t}else{\n        \t\tSystem.out.println(\"oi\");\n        \t}\n        \tsb.append(direction);\n        \t//if(sb.length() < 20)System.out.println(sb+\",\"+stx+\",\"+sty);\n        \tif(stx == 0 && sty == 0)break;\n        }\n        System.out.println(sb.toString());\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int[,] map = new int[11, 7];\n\n            for (int i = 1; i <= 9; i++)\n            {\n                string input = Console.ReadLine();\n\n                if (i % 2 == 1) input = \"00\" + input;\n                else input = \"0\" + input;\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    map[i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int posX = 1, posY = 1;\n            char dir = 'R';\n\n            while (true)\n            {\n                switch (dir)\n                {\n                    case 'R':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'U'; }\n                        else if (map[posY, posX + 1] == 1) { posX++; }\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'D'; }\n                        else { dir = 'L'; }\n                        break;\n                    case 'L':\n                        if (map[posY + 1, posX - 1] == 1) { posY++; posX--; dir = 'D'; }\n                        else if (map[posY, posX - 1] == 1) { posX--; }\n                        else if (map[posY - 1, posX - 1] == 1) { posY--; posX--; dir = 'U'; }\n                        else { dir = 'R'; }\n                        break;\n                    case 'D':\n                        if (map[posY + 1, posX + 1] == 1) { posY++; posX++; dir = 'R'; }\n                        else if (map[posY + 2, posX] == 1) { posY += 2; }\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'L'; }\n                        else { dir = 'U'; }\n                        break;\n                    case 'U':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'L'; }\n                        else if (map[posY - 2, posX] == 1) { posY -= 2; }\n                        else if (map[posY - 1, posX + 1] == 1) { posY--; posX++; dir = 'R'; }\n                        else { dir = 'D'; }\n                        break;\n                }\n                sb.Append(dir);\n\n                if (dir == 'L' && posX == 2 && posY == 1) break;\n                if (dir == 'U' && posX == 1 && posY == 2) break;\n            }\n            Console.WriteLine(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ\n{\n    class Program\n    {\n        private static Dictionary<char, char[]> rooting = new Dictionary<char, char[]>\n        {\n            {'R', \"URDL\".ToCharArray()},\n            {'D', \"RDLU\".ToCharArray()},\n            {'L', \"DLUR\".ToCharArray()},\n            {'U', \"LURD\".ToCharArray()},\n        };\n\n        struct Pair\n        {\n            public int from;\n            public int to;\n\n            public Pair(int @from, int to) : this()\n            {\n                this.@from = @from;\n                this.to = to;\n            }\n        }\n\n        private static HashSet<Pair> walls = new HashSet<Pair>();\n\n        static void Main(string[] args)\n        {\n            string line;\n            bool horizontal = true;\n            int l = 0;\n            while((line = Console.ReadLine()) != null)\n            {\n                int i = 0;\n                foreach(var c in line)\n                {\n                    if (c == '1')\n                    {\n                        walls.Add(new Pair(l / 2 * 5 + i, l / 2 * 5 + (horizontal ? 1 : 5) + i));\n                    }\n                    i++;\n                }\n                l++;\n                horizontal = !horizontal;\n            }\n            char dir = 'R';\n            int point = 1;\n            Console.Write(dir);\n            while(true)\n            {\n                MoveNext(ref point, ref dir);\n                Console.Write(dir);\n                if (point == 0) break;\n            }\n        }\n\n        private static void MoveNext(ref int point, ref char dir)\n        {\n            foreach(var root in rooting[dir])\n            {\n                int next_point = GetNext(point, root);\n                if (next_point == -1) continue;\n                if (!IsWall(point, next_point)) continue;\n                point = next_point;\n                dir = root;\n                return;\n            }\n        }\n\n        private static int GetNext(int point, char root)\n        {\n            switch(root)\n            {\n            case 'R':\n                if (point % 5 == 4) return -1;\n                return point + 1;\n            case 'D':\n                if (point >= 20) return -1;\n                return point + 5;\n            case 'L':\n                if (point % 5 == 0) return -1;\n                return point - 1;\n            default:\n                if (point < 5) return -1;\n                return point - 5;\n            }\n        }\n\n        private static bool IsWall(int point, int nextPoint)\n        {\n            return\n                walls.Contains(new Pair(point, nextPoint)) ||\n                walls.Contains(new Pair(nextPoint, point));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace test\n{\n    class Program\n    {\n        struct Point\n        {\n            public int x;\n            public int y;\n\n            public Point(int x, int y)\n            {\n                this.x = x;\n                this.y = y;\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            List<string> resultList = new List<string>();\n\n            string input;\n            List<string> WallList = new List<string>();\n            while((input = Console.ReadLine()) != null)\n            {\n                WallList.Add(input);\n            }\n\n            Point point = new Point(0, 0);\n            string course = \"R\";\n\n            do\n            {\n                switch (course)\n                {\n                    case \"R\":\n                        if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        break;\n                    case \"L\":\n                        if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        break;\n                    case \"U\":\n                        if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        break;\n                    case \"D\":\n                        if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        break;\n                }\n                resultList.Add(course);\n            }\n            while (point.x != 0 || point.y != 0);\n\n            foreach (string s in resultList)\n            {\n                Console.Write(s);\n            }\n\n        }\n\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass _0037\n{\n    public static void Main()\n    {\n        string hori = \"\", vert = \"00000\";\n        int dir = 0, x = 1, y = 0;\n        for (int i = 0; i < 9; i++)\n        {\n            if (i % 2 == 0) hori += \"0\" + Console.ReadLine() + \"0\";\n            else vert += Console.ReadLine();\n        }\n        vert += \"00000\";\n        Console.Write('R');\n        while (x != 0 || y != 0)\n        {\n            dir = (dir + 4) % 4;\n            switch (dir)\n            {\n                case 0:\n                    if (hori[y * 6 + x + 1] == '1')\n                    {\n                        x += 1;\n                        Console.Write('R');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 1:\n                    if (vert[(y + 1) * 5 + x] == '1')\n                    {\n                        y += 1;\n                        Console.Write('D');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 2:\n                    if (hori[y * 6 + x] == '1')\n                    {\n                        x += -1;\n                        Console.Write('L');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 3:\n                    if (vert[y * 5 + x] == '1')\n                    {\n                        y += -1;\n                        Console.Write('U');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n            }\n        }\n        Console.Write('\\n');\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass _0037\n{\n    public static void Main()\n    {\n        int[] dx = { 1, 0, -1, 0 };\n        int[] dy = { 0, 1, 0, -1 };\n        string hori = \"\", vert = \"00000\";\n        int dir = 0, x = 1, y = 0;\n        for (int i = 0; i < 9; i++)\n        {\n            if (i % 2 == 0) hori += \"0\" + Console.ReadLine() + \"0\";\n            else vert += Console.ReadLine();\n        }\n        vert += \"00000\";\n        Console.Write('R');\n        while (x != 0 || y != 0)\n        {\n            dir = (dir + 4) % 4;\n            switch (dir)\n            {\n                case 0:\n                    if (hori[y * 6 + x + 1] == '1')\n                    {\n                        x += 1;\n                        Console.Write('R');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 1:\n                    if (vert[(y + 1) * 5 + x] == '1')\n                    {\n                        y += 1;\n                        Console.Write('D');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 2:\n                    if (hori[y * 6 + x] == '1')\n                    {\n                        x += -1;\n                        Console.Write('L');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n                case 3:\n                    if (vert[y * 5 + x] == '1')\n                    {\n                        y += -1;\n                        Console.Write('U');\n                        dir--;\n                    }\n                    else dir++;\n                    break;\n            }\n        }\n        Console.Write('\\n');\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int[,] map = new int[11, 7];\n\n            for (int i = 1; i <= 9; i++)\n            {\n                string input = Console.ReadLine();\n\n                if (i % 2 == 1) input = \"00\" + input;\n                else input = \"0\" + input;\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    map[i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int posX = 1, posY = 1;\n            char dir = 'R';\n\n            while (true)\n            {\n                switch (dir)\n                {\n                    case 'R':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'U'; }\n                        else if (map[posY, posX + 1] == 1) posX++;\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'D'; }\n                        else dir = 'L';\n                        break;\n                    case 'L':\n                        if (map[posY + 1, posX - 1] == 1) { posY++; posX--; dir = 'D'; }\n                        else if (map[posY, posX - 1] == 1) posX--;\n                        else if (map[posY - 1, posX - 1] == 1) { posY--; posX--; dir = 'U'; }\n                        else dir = 'R';\n                        break;\n                    case 'D':\n                        if (map[posY + 1, posX + 1] == 1) { posY++; posX++; dir = 'R'; }\n                        else if (map[posY + 2, posX] == 1) posY += 2;\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'L'; }\n                        else dir = 'U';\n                        break;\n                    case 'U':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'L'; }\n                        else if (map[posY - 2, posX] == 1) posY -= 2;\n                        else if (map[posY - 1, posX + 1] == 1) { posY--; posX++; dir = 'R'; }\n                        else dir = 'D';\n                        break;\n                }\n                sb.Append(dir);\n\n                if (dir == 'L' && posX == 2 && posY == 1) break;\n                if (dir == 'U' && posX == 1 && posY == 2) break;\n            }\n            Console.WriteLine(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\t// 何やってるか理解不能。まったくダメ。要作り直し！\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid_h\t= new bool[ 5, 4 ];\n\t\t\tvar\tgrid_v\t= new bool[ 4, 5 ];\n\t\t\n\t\t\tinput_grid( grid_h, grid_v );\n\n\t\t\tint\tx\t= 0;\n\t\t\tint\ty\t= 0;\n\t\t\tint\tdir\t= 0;\n\t\t\tdo {\n\t\t\t\tswitch( dir ) {\n\t\t\t\tcase\t0:\t\t// R\n\t\t\t\t\twhile( true ) {\n\t\t\t\t\t\tif( grid_h[ y, x ] ) {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( y > 0 ) {\n\t\t\t\t\t\t\t\tif( grid_v[ y - 1, x + 1 ] ) {\n\t\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tif( x >= 4 ) {\n\t\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t1:\t\t// D\n\t\t\t\t\twhile( true ) {\n\t\t\t\t\t\tif( grid_v[ y, x ] ) {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( x < 4 - 1 ) {\n\t\t\t\t\t\t\t\tif( grid_h[ y + 1, x ] ) {\n\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tif( y >= 4 ) {\n\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t2:\t\t// L\n\t\t\t\t\twhile( true ) {\n\t\t\t\t\t\tif( grid_h[ y, x ] ) {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( y < 5 - 1 ) {\n\t\t\t\t\t\t\t\tif( grid_v[ y, x ] ) {\n\t\t\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tif( x < 0 ) {\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t3:\t\t// U\n\t\t\t\t\twhile( true ) {\n\t\t\t\t\t\tif( grid_v[ y, x ] ) {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( x > 0 ) {\n\t\t\t\t\t\t\t\tif( grid_h[ y, x - 1 ] ) {\n\t\t\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tif( y < 0 ) {\n\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t} while( (x > 0) || (y > 0) );\n\t\t\tConsole.WriteLine();\n\t\t}\n\n\n\t\tstatic void input_grid( bool[,] grid_h, bool[,] grid_v )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\tstr\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x01 ) {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tgrid_v[ y, x ]\t= (str[ x ] == '1') ? true : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tgrid_h[ y, x ]\t= (str[ x ] == '1') ? true : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Pos\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var map = new bool[9, 5];\n        for (int i = 0; i < 9; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            int jmax;\n            if (i % 2 == 0) jmax = 4;\n            else jmax = 5;\n            for (int j = 0; j < jmax; j++) if (s[j] == '1') map[i, j] = true;\n        }\n        var p = new Pos { x = 0, y = 0 };\n        posRight(map, p);\n        Console.WriteLine();\n    }\n    public static void posRight(bool[,] map, Pos p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny])\n        {\n            Console.Write(\"R\");\n            if (ny + 1 < 5) { p.y++; posRight(map, p); }\n        }\n        else if (nx - 1 >= 0 && map[nx - 1, ny]) { p.x--; posUp(map, p); }\n        else if (nx + 1 < 9 && map[nx + 1, ny]) { p.x++; posDown(map, p); }\n    }\n    public static void posDown(bool[,] map, Pos p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny])\n        {\n            Console.Write(\"D\");\n            if (nx + 2 < 9) { p.x += 2; posDown(map, p); }\n            else if (nx + 1 >= 0 && map[nx + 1, ny]) { p.x++; posRight(map, p); }\n            else if (nx + 1 >= 0 && ny - 1 >= 0 && map[nx + 1, ny - 1]) { p.x++; p.y--; posLeft(map, p); }\n        }\n        else if (nx - 1 >= 0 && map[nx - 1, ny]) { p.x--; posRight(map, p); }\n        else if (nx - 1 >= 0 && ny - 1 >= 0 && map[nx - 1, ny - 1]) { p.x--; p.y--; posLeft(map, p); }\n    }\n    public static void posLeft(bool[,] map, Pos p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny])\n        {\n            Console.Write(\"L\");\n            if (ny - 1 >= 0) { p.y--; posLeft(map, p); }\n        }\n        else if (nx + 1 < 9 && ny + 1 < 5 && map[nx + 1, ny + 1]) { p.x++; p.y++; posDown(map, p); }\n        else if (nx - 1 >= 0 && ny + 1 < 5 && map[nx - 1, ny + 1]) { p.x--; p.y++; posUp(map, p); }\n    }\n    public static void posUp(bool[,] map, Pos p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny])\n        {\n            Console.Write(\"U\");\n            if (nx - 2 >= 0) { p.x -= 2; posUp(map, p); }\n            else if (nx - 1 >= 0 && ny - 1 >= 0 && map[nx - 1, ny - 1]) { p.x--; p.y--; posLeft(map, p); }\n            else if (nx - 1 >= 0 && map[nx - 1, ny]) { p.x--; posRight(map, p); }\n        }\n        else if (nx + 1 >= 0 && ny - 1 >= 0 && map[nx + 1, ny - 1]) { p.x++; p.y--; posLeft(map, p); }\n        else if (nx + 1 >= 0 && map[nx + 1, ny]) { p.x++; posRight(map, p); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid\t= new int[ 20, 20 ];\n\t\t\tinput_grid( grid );\n\n\t\t\tint\tx\t= 10;\n\t\t\tint\ty\t= 10;\n\t\t\tint\tdir\t= 0;\n\n\t\t\tdo {\n\t\t\t\tswitch( dir ) {\n\t\t\t\tcase\t0:\t\t// R\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t1:\t\t// D\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t2:\t\t// L\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t3:\t\t// U\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while( (x != 10) || (y != 10) );\n\t\t\tConsole.WriteLine();\n\t\t}\n\n\n\t\tstatic void input_grid( int[,] grid )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\ts\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x00 ) {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x01;\n\t\t\t\t\t\t\tgrid[ y + 10, x + 11 ]\t|= 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t\tgrid[ y + 11, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n    class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\t//NESW\n\t\t\tvar walls = new bool[5, 5, 4];\n\t\t\tstring line;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tline = cin.ReadLine;\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tvar isWall = line[j] == '1';\n\t\t\t\t\twalls[i, j + 1, 3] = walls[i, j, 1] = isWall;\n\t\t\t\t}\n\t\t\t\tline = cin.ReadLine;\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tvar isWall = line[j] == '1';\n\t\t\t\t\twalls[i + 1, j, 0] = walls[i, j, 2] = isWall;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = cin.ReadLine;\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tvar isWall = line[j] == '1';\n\t\t\t\twalls[4, j + 1, 3] = walls[4, j, 1] = isWall;\n\t\t\t}\n\t\t\t//start explore\n\t\t\tvar dir = 1;\n\t\t\tint x = 0, y = 0;\n\t\t\tvar sb = new StringBuilder();\n\t\t\tvar dirChar = new char[] { 'U', 'R', 'D', 'L' };\n\t\t\tdo {\n\t\t\t\tvar next = nextDir(walls, x, y, dir);\n\t\t\t\tswitch(next) {\n\t\t\t\t\tcase 0: y--; break;\n\t\t\t\t\tcase 1: x++; break;\n\t\t\t\t\tcase 2: y++; break;\n\t\t\t\t\tcase 3: x--; break;\n\t\t\t\t}\n\t\t\t\tdir = next;\n\t\t\t\tsb.Append(dirChar[next]);\n\t\t\t} while(x != 0 || y != 0);\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t\tsb.Clear();\n\t\t}\n\n\t\tpublic int nextDir(bool[,,] walls, int x, int y, int prevDir) {\n\t\t\tvar tmp = (prevDir - 1) & 3;\n\t\t\tfor(int i = 0; i < 3; i++) {\n\t\t\t\tif(walls[y, x, tmp]) return tmp;\n\t\t\t\ttmp = (tmp + 1) & 3;\n\t\t\t}\n\t\t\treturn tmp;\n\t\t}\n\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator = separator;\n\t\t\tthis._stream = stream;\n\t\t\tinputStream = new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count != 0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i < tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i < N; ++i)\n\t\t\t\tret[i] = Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public bool second { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var map = new bool[9, 5];\n        for (int i = 0; i < 9; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            var jmax = i % 2 == 0 ? 4 : 5;\n            for (int j = 0; j < jmax; j++)\n                if (s[j] == '1') map[i, j] = true;\n        }\n        var p = new Po { x = 0, y = 0 };\n        poRight(map, p);\n        Console.WriteLine();\n    }\n    public static void poRight(bool[,] map, Po p)\n    {\n        if (p.x == 0 && p.y == 0)\n            if (p.second) return;\n            else p.second = true;\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"R\");\n        if (nx - 1 >= 0 && ny + 1 < 5 && map[nx - 1, ny + 1]) { p.x--; p.y++; poUp(map, p); }  \n        else if (ny + 1 < 5 && map[nx, ny + 1]) { p.y++; poRight(map, p); }\n        else if (nx + 1 < 9 && ny + 1 < 5 && map[nx + 1, ny + 1]) { p.x++; p.y++; poDown(map, p); }\n        else { poLeft(map, p); }\n    }\n    public static void poDown(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"D\");\n        if (nx + 1 < 9 && map[nx + 1, ny]) { p.x++; poRight(map, p); }\n        else if (nx + 2 < 9 && map[nx + 2, ny]) { p.x += 2; poDown(map, p); }\n        else if (nx + 1 < 9 && ny - 1 >= 0 && map[nx + 1, ny - 1]) { p.x++; p.y--; poLeft(map, p); } \n        else { poUp(map, p); }\n    }\n    public static void poUp(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"U\");\n        if (nx - 1 >= 0 && ny - 1 >= 0 && map[nx - 1, ny - 1]) { p.x--; p.y--; poLeft(map, p); } \n        else if (nx - 2 >= 0 && map[nx - 2, ny]) { p.x -= 2; poUp(map, p); }\n        else if (nx - 1 >= 0  && map[nx - 1, ny ]) { p.x--; poRight(map, p); } \n        else { poDown(map, p); }\n    }\n    public static void poLeft(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"L\");\n        if (nx + 1  < 9  && map[nx + 1, ny ]) { p.x++; poDown(map, p); }\n        else if (ny - 1 >= 0 && map[nx, ny - 1]) { p.y--; poLeft(map, p); }\n        else if (nx - 1 >= 0 && map[nx - 1, ny ]) { p.x--; poUp(map, p); }\n        else { poRight(map, p); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        const string cis = \"LURD\";\n\n        static void Main(string[] args)\n        {\n            string s;\n            var list = new List<string>();\n\n            while ((s = Console.ReadLine()) != null)\n            {\n                list.Add(s);\n            }\n            var vart = new string[list[0].Length+1];\n            var cerl = new string[list[0].Length];\n            var vc = 0;\n            var cc = 0;\n\n            var size = cerl.Length;\n\n            var x = 1;\n            var y = 0;\n\n            var isVertical = true;\n            foreach (var str in list)\n            {\n                if (isVertical)\n                {\n                    vart[vc++] = str;\n                }\n                else\n                {\n                    cerl[cc++] = str;\n                }\n                isVertical = !isVertical;\n            }\n\n            var d = 2;\n\n            var cl = 0;\n\n            do\n            {\n                switch (d)\n                {\n                    case 0: //L\n                        //上を調べる\n                        if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0)\n                        {\n                            d = 1; y--; //上移動\n                        }\n                        else //左\n                            if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y == 0 || y == size + 1)\n                            {\n                                d = 0; x--; Console.Write(\"L\");\n                            }\n                            else\n                                if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0')\n                                {\n                                    d = 3; y++; Console.Write(\"LD\");\n                                }\n                                else\n                                {\n                                    d = 2; x++; Console.WriteLine(\"LDR\");\n                                }\n                        break;\n                    case 1: //U\n                        //右を調べる\n                        if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0' || y == 0)\n                        {\n                            d = 2; x++;\n                        }\n                        else //上\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 1; y--;  Console.Write(\"U\");\n                            }\n                            else //左\n                                if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0')\n                                {\n                                    d = 0; x--; Console.Write(\"UL\");\n                                }\n                                else\n                                {\n                                    d = 3; y++; Console.Write(\"ULD\");\n                                }\n                        break;\n                    case 2: //R\n                        //下を調べる\n                        if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x > size)\n                        {\n                            d = 3; y++;\n                        }\n                        else //下が開いていない\n                        //右を調べる\n                        if(0 < y && y <= size && x <= size && cerl[y-1][x] == '0' || y == 0 || y == size+1)\n                        {\n                            d = 2; x++; Console.Write(\"R\");\n                        }\n                        else //右が開いていない\n                        //上を調べる\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0')\n                            {\n                                d = 1; y--; Console.Write(\"RU\");\n                            }\n                            else\n                            {\n                                d = 0; x--; Console.Write(\"RUL\");\n                            }\n                        break;\n                    case 3: //D\n                        //左を調べる\n                        if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y > size)\n                        {\n                            d = 0; x--;\n                        }\n                        else //下\n                            if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 3; y++; Console.Write(\"D\");\n                            }\n                            else //右\n                                if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0')\n                                {\n                                    d = 2; x++; Console.Write(\"DR\");\n                                }\n                                else\n                                {\n                                    d = 1; y--; Console.Write(\"DRU\");\n                                }\n                                \n                        break;\n                }\n\n                if (cl++ == 100) break;\n            }\n            while (x != 1 || y != 0);\n\n            Console.WriteLine();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s;\n            var list = new List<string>();\n\n            while ((s = Console.ReadLine()) != null)\n            {\n                list.Add(s);\n            }\n            var vart = new string[list[0].Length+1];\n            var cerl = new string[list[0].Length];\n            var vc = 0;\n            var cc = 0;\n\n            var size = cerl.Length;\n\n            var x = 1;\n            var y = 0;\n\n            var isVertical = true;\n            foreach (var str in list)\n            {\n                if (isVertical)\n                {\n                    vart[vc++] = str;\n                }\n                else\n                {\n                    cerl[cc++] = str;\n                }\n                isVertical = !isVertical;\n            }\n\n            var d = 2;\n\n            do\n            {\n                switch (d)\n                {\n                    case 0: //L\n                        //上を調べる\n                        if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0)\n                        {\n                            d = 1; y--; //上移動\n                        }\n                        else //左\n                            if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y == 0 || y == size + 1)\n                            {\n                                d = 0; x--; Console.Write(\"L\");\n                            }\n                            else\n                                if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0')\n                                {\n                                    d = 3; y++; Console.Write(\"LD\");\n                                }\n                                else\n                                {\n                                    d = 2; x++; Console.WriteLine(\"LDR\");\n                                }\n                        break;\n                    case 1: //U\n                        //右を調べる\n                        if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0' || y == 0)\n                        {\n                            d = 2; x++;\n                        }\n                        else //上\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 1; y--;  Console.Write(\"U\");\n                            }\n                            else //左\n                                if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0')\n                                {\n                                    d = 0; x--; Console.Write(\"UL\");\n                                }\n                                else\n                                {\n                                    d = 3; y++; Console.Write(\"ULD\");\n                                }\n                        break;\n                    case 2: //R\n                        //下を調べる\n                        if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x > size)\n                        {\n                            d = 3; y++;\n                        }\n                        else //下が開いていない\n                        //右を調べる\n                        if(0 < y && y <= size && x <= size && cerl[y-1][x] == '0' || y == 0 || y == size+1)\n                        {\n                            d = 2; x++; Console.Write(\"R\");\n                        }\n                        else //右が開いていない\n                        //上を調べる\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0')\n                            {\n                                d = 1; y--; Console.Write(\"RU\");\n                            }\n                            else\n                            {\n                                d = 0; x--; Console.Write(\"RUL\");\n                            }\n                        break;\n                    case 3: //D\n                        //左を調べる\n                        if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y > size)\n                        {\n                            d = 0; x--;\n                        }\n                        else //下\n                            if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 3; y++; Console.Write(\"D\");\n                            }\n                            else //右\n                                if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0')\n                                {\n                                    d = 2; x++; Console.Write(\"DR\");\n                                }\n                                else\n                                {\n                                    d = 1; y--; Console.Write(\"DRU\");\n                                }\n                                \n                        break;\n                }\n            }\n            while (x != 1 || y != 0);\n\n            Console.WriteLine();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid\t= new int[ 20, 20 ];\n\t\t\tinput_grid( grid );\n\n\t\t\tint\tx\t= 10;\n\t\t\tint\ty\t= 10;\n\t\t\tint\tdir\t= 0;\n\n\t\t\tdo {\n\t\t\t\tswitch( dir ) {\n\t\t\t\tcase\t0:\t\t// R\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t1:\t\t// D\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t2:\t\t// L\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t3:\t\t// U\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while( (x != 10) || (y != 10) );\n\t\t\tConsole.WriteLine();\n\t\t}\n\n\n\t\tstatic void input_grid( int[,] grid )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\ts\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x00 ) {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x01;\n\t\t\t\t\t\t\tgrid[ y + 10, x + 11 ]\t|= 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t\tgrid[ y + 11, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Po\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var map = new bool[9, 5];\n        for (int i = 0; i < 9; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            var jmax = i % 2 == 0 ? 4 : 5;\n            for (int j = 0; j < jmax; j++)\n                if (s[j] == '1') map[i, j] = true;\n        }\n        var p = new Po { x = 0, y = 0 };\n        poRight(map, p);\n        Console.WriteLine();\n    }\n    public static void poRight(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"R\");\n        if (nx - 1 >= 0 && ny + 1 < 5 && map[nx - 1, ny + 1]) { p.x--; p.y++; poUp(map, p); }  \n        else if (ny + 1 < 5 && map[nx, ny + 1]) { p.y++; poRight(map, p); }\n        else if (nx + 1 < 9 && ny + 1 < 5 && map[nx + 1, ny + 1]) { p.x++; p.y++; poDown(map, p); }\n    }\n    public static void poDown(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"D\");\n        if (nx + 1 < 9 && map[nx + 1, ny]) { p.x++; poRight(map, p); }\n        else if (nx + 2 < 9 && map[nx + 2, ny]) { p.x += 2; poDown(map, p); }\n        else if (nx + 1 < 9 && ny - 1 >= 0 && map[nx + 1, ny - 1]) { p.x++; p.y--; poLeft(map, p); } \n    }\n    public static void poUp(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"U\");\n        if (nx - 1 >= 0 && ny - 1 >= 0 && map[nx - 1, ny - 1]) { p.x--; p.y--; poLeft(map, p); } \n        else if (nx - 2 >= 0 && map[nx - 2, ny]) { p.x -= 2; poUp(map, p); }\n        else if (nx - 1 >= 0  && map[nx - 1, ny ]) { p.x--; poRight(map, p); } \n    }\n    public static void poLeft(bool[,] map, Po p)\n    {\n        var nx = p.x; var ny = p.y;\n        if (map[nx, ny]) Console.Write(\"L\");\n        if (nx + 1  < 9  && map[nx + 1, ny ]) { p.x++; poDown(map, p); }\n        else if (ny - 1 >= 0 && map[nx, ny - 1]) { p.y--; poLeft(map, p); }\n        else if (nx - 1 >= 0 && map[nx - 1, ny ]) { p.x--; poUp(map, p); }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s;\n            var list = new List<string>();\n\n            while ((s = Console.ReadLine()) != null)\n            {\n                list.Add(s);\n            }\n            var vart = new string[list[0].Length+1];\n            var cerl = new string[list[0].Length];\n            var vc = 0;\n            var cc = 0;\n\n            var size = cerl.Length;\n\n            var x = 1;\n            var y = 0;\n\n            var isVertical = true;\n            foreach (var str in list)\n            {\n                if (isVertical)\n                {\n                    vart[vc++] = str;\n                }\n                else\n                {\n                    cerl[cc++] = str;\n                }\n                isVertical = !isVertical;\n            }\n\n            var d = 2;\n\n            do\n            {\n                switch (d)\n                {\n                    case 0: //L\n                        //上を調べる\n                        if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0)\n                        {\n                            d = 1; y--; //上移動\n                        }\n                        else //左\n                            if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y == 0 || y == size + 1)\n                            {\n                                d = 0; x--; Console.Write(\"L\");\n                            }\n                            else\n                                if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0')\n                                {\n                                    d = 3; y++; Console.Write(\"LD\");\n                                }\n                                else\n                                {\n                                    d = 2; x++; Console.Write(\"LDR\");\n                                }\n                        break;\n                    case 1: //U\n                        //右を調べる\n                        if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0' || y == 0)\n                        {\n                            d = 2; x++;\n                        }\n                        else //上\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 1; y--;  Console.Write(\"U\");\n                            }\n                            else //左\n                                if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0')\n                                {\n                                    d = 0; x--; Console.Write(\"UL\");\n                                }\n                                else\n                                {\n                                    d = 3; y++; Console.Write(\"ULD\");\n                                }\n                        break;\n                    case 2: //R\n                        //下を調べる\n                        if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x > size)\n                        {\n                            d = 3; y++;\n                        }\n                        else //下が開いていない\n                        //右を調べる\n                        if(0 < y && y <= size && x <= size && cerl[y-1][x] == '0' || y == 0 || y == size+1)\n                        {\n                            d = 2; x++; Console.Write(\"R\");\n                        }\n                        else //右が開いていない\n                        //上を調べる\n                            if (0 < x && x <= size && 0 < y && vart[y - 1][x - 1] == '0')\n                            {\n                                d = 1; y--; Console.Write(\"RU\");\n                            }\n                            else\n                            {\n                                d = 0; x--; Console.Write(\"RUL\");\n                            }\n                        break;\n                    case 3: //D\n                        //左を調べる\n                        if (0 < y && y <= size && 0 < x && cerl[y - 1][x - 1] == '0' || y > size)\n                        {\n                            d = 0; x--;\n                        }\n                        else //下\n                            if (0 < x && x <= size && y <= size && vart[y][x - 1] == '0' || x == 0 || x == size+1)\n                            {\n                                d = 3; y++; Console.Write(\"D\");\n                            }\n                            else //右\n                                if (0 < y && y <= size && x <= size && cerl[y - 1][x] == '0')\n                                {\n                                    d = 2; x++; Console.Write(\"DR\");\n                                }\n                                else\n                                {\n                                    d = 1; y--; Console.Write(\"DRU\");\n                                }\n                                \n                        break;\n                }\n            }\n            while (x != 1 || y != 0);\n\n            Console.WriteLine();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class PathOnAGrid\n{\n    static void Main()\n    {\n        var input = Console.In.ReadToEnd()\n            .Split( \n                new[] { '\\r', '\\n' },\n                StringSplitOptions.RemoveEmptyEntries )\n            .Select( x => Array.ConvertAll( x.ToArray(), y => y == '1' ) )\n            .Select( (x, i) => new { v = x, k = i & 1 } )\n            .GroupBy( x => x.k, x => x.v )\n            .Select( x => x.ToArray() )\n            .ToArray();\n        var m =\n            from y in Enumerable.Range( 0, 5 )\n            from x in Enumerable.Range( 0, 5 )\n            select new[]\n            {\n                x < 4 && input[0][y][x],\n                y < 4 && input[1][y][x],\n                x > 0 && input[0][y][x - 1],\n                y > 0 && input[1][y - 1][x],\n            };\n        var map = m.ToArray();\n        var index = new Func<int, int, int>[]\n        {\n            (x, y) => x + y,\n            (x, y) => x + y * 5,\n            (x, y) => x - y,\n            (x, y) => x - y * 5,\n        };\n        var route = Enumerable.Empty<char>();\n        int p = 0, d = 0;\n        do {\n            var head = ( d + 3 ) & 3;\n            var step = Enumerable.Range( 0, 5 )\n                .Select( x => index[d]( p, x ) )\n                .TakeWhile( x => map[x][d] && ( !map[x][head] || x == p ) )\n                .Count();\n\n            route = route.Concat( Enumerable.Repeat( \"RDLU\"[d], step ) );\n            p = index[d]( p, step );\n            d = map[p][head] ? head : ( d + 1 ) & 3;\n        } while ( p != 0 );\n        Console.WriteLine( new string( route.ToArray() ) );\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar map = new bool[9 + 2][];\n\t\t\tmap[0] = map[10] = new bool[7];\n\t\t\tfor (int i = 1; i < 10; i++)\n\t\t\t{\n\t\t\t\tmap[i] = (\"0\" + Console.ReadLine() + (i % 2 == 0 ? \"0\" : \"00\")).Select(c => c == '1').ToArray();\n\t\t\t}\n\n\t\t\tConsole.WriteLine(new string(f(map).ToArray()));\n\t\t}\n\n\t\tstatic IEnumerable<char> f(bool[][] map)\n\t\t{\n\t\t\tyield return 'R';\n\t\t\tint[] ax1 = new int[4] { 0, 0, 0, -1 };\n\t\t\tint[] ay1 = new int[4] { -1, 0, 1, 0 };\n\t\t\tint[] ax2 = new int[4] { 0, 1, 0, -1 };\n\t\t\tint[] ay2 = new int[4] { -2, 0, 2, 0 };\n\t\t\tint x = 2, y = 1, o = 0;\n\t\t\twhile (!(x == 1 && y == 1))\n\t\t\t{\n\t\t\t\tvar flg = false;\n\t\t\t\tfor (int i = o; i < 4 + o; i++)\n\t\t\t\t{\n\t\t\t\t\tint p = i % 4;\n\t\t\t\t\tif (map[y + ay1[p]][x + ax1[p]])\n\t\t\t\t\t{\n\t\t\t\t\t\to = (p + 3) % 4;\n\t\t\t\t\t\tyield return \"URDL\"[p];\n\t\t\t\t\t\tx += ax2[p];\n\t\t\t\t\t\ty += ay2[p];\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flg) break;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid\t= new int[ 20, 20 ];\n\t\t\tinput_grid( grid );\n\n\t\t\tint\tx\t= 10;\n\t\t\tint\ty\t= 10;\n\t\t\tint\tdir\t= 0;\n\n\t\t\tdo {\n\t\t\t\tswitch( dir ) {\n\t\t\t\tcase\t0:\t\t// R\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t1:\t\t// D\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t2:\t\t// L\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase\t3:\t\t// U\n\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\ty--;\n\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\tx++;\n\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\ty++;\n\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while( (x != 10) || (y != 10) );\n\t\t\tConsole.WriteLine();\n\t\t}\n\n\n\t\tstatic void input_grid( int[,] grid )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\ts\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x00 ) {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x01;\n\t\t\t\t\t\t\tgrid[ y + 10, x + 11 ]\t|= 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tif( s[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t\tgrid[ y + 11, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0037\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n\n            List<int>[,] map = new List<int>[5, 5];\n\n            //配列の初期化\n            for (int i = 0 ; i < 5 ; i++)\n            {\n                for (int j = 0 ; j < 5 ; j++)\n                {\n                    map[i, j] = new List<int>();\n                }\n            }\n\n            for (int i = 0 ; i < 9 ; i++)\n            {\n                string line = RSt();\n                for (int j = 0 ; j < line.Length ; j++)\n                {\n                    if (line[j] == '1')\n                    {\n                        if (i % 2 == 0)\n                        {\n                            map[i / 2, j].Add(0);\n                            map[i / 2, j + 1].Add(180);\n                        }\n                        else\n                        {\n                            map[i / 2, j].Add(270);\n                            map[i / 2 + 1, j].Add(90);\n                        }\n                    }\n                }\n            }\n\n            int[] dx = new int[] { 1, 0, -1, 0 };\n            int[] dy = new int[] { 0, -1, 0, 1 };\n            LinkedList<int> res = new LinkedList<int>();\n            res.AddLast(0);\n            int x = 1; int y = 0;\n\n            while (x != 0 || y != 0)\n            {\n                int ingressOrientation = (res.Last.Value + 180) % 360;\n                int next = GetOrientation(ingressOrientation, x, y, map[y, x]);\n                res.AddLast(next);\n                x += dx[next / 90];\n                y += dy[next / 90];\n            }\n\n            string[] directions = new string[] { \"R\", \"U\", \"L\", \"D\" };\n            Console.WriteLine(WAr(res.Select(item => directions[item / 90]),\"\"));\n        }\n\n        private static int GetOrientation(int ingressOrientation, int x, int y, List<int> list)\n        {\n            int next = ingressOrientation;\n            while (true)\n            {\n                next = (next + 270) % 360;\n                if (list.Contains(next)) return next;\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace test\n{\n    class Program\n    {\n        struct Point\n        {\n            public int x;\n            public int y;\n\n            public Point(int x, int y)\n            {\n                this.x = x;\n                this.y = y;\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            List<string> resultList = new List<string>();\n\n            string input;\n            List<string> WallList = new List<string>();\n            while((input = Console.ReadLine()) != null)\n            {\n                WallList.Add(input);\n            }\n\n            Point point = new Point(0, 0);\n            string course = \"R\";\n\n            do\n            {\n                switch (course)\n                {\n                    case \"R\":\n                        if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        break;\n                    case \"L\":\n                        if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        break;\n                    case \"U\":\n                        if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else if (point.y != 0 && WallList[2 * point.y - 1][point.x] == '1')\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        else if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        break;\n                    case \"D\":\n                        if (point.x != 4 && WallList[2 * point.y][point.x] == '1')\n                        {\n                            point.x++;\n                            course = \"R\";\n                        }\n                        else if (point.y != 4 && WallList[2 * point.y + 1][point.x] == '1')\n                        {\n                            point.y++;\n                            course = \"D\";\n                        }\n                        else if (point.x != 0 && WallList[2 * point.y][point.x - 1] == '1')\n                        {\n                            point.x--;\n                            course = \"L\";\n                        }\n                        else\n                        {\n                            point.y--;\n                            course = \"U\";\n                        }\n                        break;\n                }\n                resultList.Add(course);\n            }\n            while (point.x != 0 || point.y != 0);\n\n            foreach (string s in resultList)\n            {\n                Console.Write(s);\n            }\n\n            Console.WriteLine();\n\n        }\n\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\tconst\tint\tR\t= 0x01;\n\t\tconst\tint\tD\t= 0x02;\n\t\tconst\tint\tL\t= 0x04;\n\t\tconst\tint\tU\t= 0x08;\n\t\t\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid\t= new int[ 20, 20 ];\t// 範囲外チェックを省略するため大きめにとる。実際は10,10から使用\n\t\t\tinput_grid( grid );\n\n\t\t\tint[]\tdir_tbl\t\t= { R, D, L, U };\n\t\t\tchar[]\tpath_dir\t= { 'R', 'D', 'L', 'U' }; \n\t\t\tint[,]\tmove\t\t= { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };\n\n\t\t\tint\tdir\t= 0;\n\t\t\tint\tx\t= 10;\n\t\t\tint\ty\t= 10;\n\t\t\tvar\tpath\t= \"\";\n\t\t\tdo {\n\t\t\t\tfor( int i = -1; i <= 2; i++ ) {\n\t\t\t\t\tint\tdir_chk\t= (dir + i) & 0x03;\n\t\t\t\t\tif( (grid[ y, x ] & dir_tbl[ dir_chk ]) == dir_tbl[ dir_chk ] ) {\n\t\t\t\t\t\tdir\t= dir_chk;\n\t\t\t\t\t\tx\t+= move[ dir, 0 ]; \n\t\t\t\t\t\ty\t+= move[ dir, 1 ]; \n\t\t\t\t\t\tpath\t+= path_dir[ dir ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while( (x != 10) || (y != 10) );\n\t\t\tConsole.WriteLine( path );\n\t\t}\n\n\n\t\tstatic void input_grid( int[,] grid )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\tstr\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x00 ) {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tif( str[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= R;\n\t\t\t\t\t\t\tgrid[ y + 10, x + 11 ]\t|= L;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tif( str[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= D;\n\t\t\t\t\t\t\tgrid[ y + 11, x + 10 ]\t|= U;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\nnamespace AOJ0037\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                string input = \"\";\n                int[,] row = new int[6, 7];\n                int[,] column = new int[7, 6];\n\n                for (int i = 0; i < 4; i++)\n                {\n                    input = Console.ReadLine();\n                    for(int j = 0; j < input.Length; j++)\n                    {\n                        row[j + 1, i + 1] = int.Parse(input.Substring(j, 1));\n                    }\n\n                    input = Console.ReadLine();\n                    for (int j = 0; j < input.Length; j++)\n                    {\n                        column[j + 1, i + 1] = int.Parse(input.Substring(j, 1));\n                    }\n                }\n\n                input = Console.ReadLine();\n                for (int j = 0; j < input.Length; j++)\n                {\n                    row[j + 1, 5] = int.Parse(input.Substring(j, 1));\n                }\n\n                int X = 1;\n                int Y = 1;\n                char Dir = 'R';\n                StringBuilder output = new StringBuilder();\n\n                do\n                {\n\n                    switch (Dir)\n                    {\n                        case 'R':\n                            if (column[X, Y - 1] == 1)\n                            {\n                                Y--;\n                                Dir = 'U';\n                            } else\n                            {\n                                if (row[X, Y] == 1)\n                                {\n                                    X++;\n                                }\n                                else\n                                {\n                                    if (column[X, Y] == 1)\n                                    {\n                                        Y++;\n                                        Dir = 'D';\n                                    }\n                                    else\n                                    {\n                                        X--;\n                                        Dir = 'L';\n                                    }\n                                }\n                            }\n                            break;\n\n                        case 'L':\n                            if (column[X, Y] == 1)\n                            {\n                                Y++;\n                                Dir = 'D';\n                            }\n                            else\n                            {\n                                if (row[X-1, Y] == 1)\n                                {\n                                    X--;\n                                }\n                                else\n                                {\n                                    if (column[X, Y - 1] == 1)\n                                    {\n                                        Y--;\n                                        Dir = 'U';\n                                    }\n                                    else\n                                    {\n                                        X++;\n                                        Dir = 'R';\n                                    }\n                                }\n                            }\n                            break;\n\n                        case 'D':\n                            if (row[X, Y] == 1)\n                            {\n                                X++;\n                                Dir = 'R';\n                            }\n                            else\n                            {\n                                if (column[X, Y] == 1)\n                                {\n                                    Y++;\n                                }\n                                else\n                                {\n                                    if (row[X - 1, Y] == 1)\n                                    {\n                                        X--;\n                                        Dir = 'L';\n                                    }\n                                    else\n                                    {\n                                        Y--;\n                                        Dir = 'U';\n                                    }\n                                }\n                            }\n                            break;\n\n                        case 'U':\n                            if (row[X - 1, Y] == 1)\n                            {\n                                X--;\n                                Dir = 'L';\n                            }\n                            else\n                            {\n                                if (column[X, Y-1] == 1)\n                                {\n                                    Y--;\n                                }\n                                else\n                                {\n                                    if (row[X, Y] == 1)\n                                    {\n                                        X++;\n                                        Dir = 'R';\n                                    }\n                                    else\n                                    {\n                                        Y++;\n                                        Dir = 'D';\n                                    }\n                                }\n                            }\n                            break;\n                    }\n\n                    output.Append(Dir);\n                } while (!((X == 1) && (Y == 1)));\n\n\n                Console.WriteLine(output);\n                if (String.IsNullOrEmpty(Console.ReadLine())) break;\n\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int[,] map = new int[11, 7];\n\n            for (int i = 1; i <= 9; i++)\n            {\n                string input = Console.ReadLine();\n\n                if (i % 2 == 1) input = \"00\" + input;\n                else input = \"0\" + input;\n\n                for (int j = 0; j < input.Length; j++)\n                {\n                    map[i, j] = int.Parse(input[j].ToString());\n                }\n            }\n\n            int posX = 1, posY = 1;\n            char dir = 'R';\n\n            while (true)\n            {\n                switch (dir)\n                {\n                    case 'R':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'U'; }\n                        else if (map[posY, posX + 1] == 1) { posX++; }\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'D'; }\n                        else { posX--; dir = 'L'; }\n                        break;\n                    case 'L':\n                        if (map[posY + 1, posX - 1] == 1) { posY++; posX--; dir = 'D'; }\n                        else if (map[posY, posX - 1] == 1) { posX--; }\n                        else if (map[posY - 1, posX - 1] == 1) { posY--; posX--; dir = 'U'; }\n                        else { posX++; dir = 'R'; }\n                        break;\n                    case 'D':\n                        if (map[posY + 1, posX + 1] == 1) { posY++; posX++; dir = 'R'; }\n                        else if (map[posY + 2, posX] == 1) { posY += 2; }\n                        else if (map[posY + 1, posX] == 1) { posY++; dir = 'L'; }\n                        else { posY -= 2; dir = 'U'; }\n                        break;\n                    case 'U':\n                        if (map[posY - 1, posX] == 1) { posY--; dir = 'L'; }\n                        else if (map[posY - 2, posX] == 1) { posY -= 2; }\n                        else if (map[posY - 1, posX + 1] == 1) { posY--; posX++; dir = 'R'; }\n                        else { posY += 2; dir = 'D'; }\n                        break;\n                }\n                sb.Append(dir);\n\n                if (dir == 'L' && posX == 2 && posY == 1) break;\n                if (dir == 'U' && posX == 1 && posY == 2) break;\n            }\n            Console.WriteLine(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace AtCoderCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<string> yoko = new List<string>();\n            List<string> tate = new List<string>();\n            tate.Add(\"00000\");\n            for (int i = 0; i < 9; i++)\n            {\n                if (i % 2 == 0) yoko.Add(\"0\" + Console.ReadLine().ToString() + \"0\");\n                else tate.Add(Console.ReadLine().ToString());\n            }\n            tate.Add(\"00000\");\n            int x = 1;\n            int y = 0;\n            int[] vx = { 1, 0, -1, 0 };\n            int[] vy = { 0, 1, 0, -1 };\n            int muki = 0;\n\n            StringBuilder ans = new StringBuilder();\n            ans.Append('R');\n            while (x != 0 || y != 0)\n            {\n                muki = (4+muki)%4;\n                if (muki == 0)\n                {\n                    if (yoko[y + vy[muki]][x + vx[muki]] == '1')\n                    {\n                        y += vy[muki];\n                        x += vx[muki];\n                        ans.Append('R');\n                        muki--;\n                    }\n                    else muki++;\n                }\n                else if (muki == 2)\n                {\n                    if (yoko[y + vy[muki]][x + vx[muki] + 1] == '1')\n                    {\n                        y += vy[muki];\n                        x += vx[muki];\n                        ans.Append('L');\n                        muki--;\n                    }\n                    else muki++;\n                }\n                else if (muki == 1)\n                {\n                    if (tate[y + vy[muki]][x + vx[muki]] == '1')\n                    {\n                        y += vy[muki];\n                        x += vx[muki];\n                        ans.Append('D');\n                        muki--;\n                    }\n                    else muki++;\n                }\n                else\n                {\n                    if (tate[y + vy[muki]+1][x + vx[muki]] == '1')\n                    {\n                        y += vy[muki];\n                        x += vx[muki];\n                        muki--;\n                        ans.Append('U');\n                    }\n                    else muki++;\n                }\n            }\n            Console.Out.WriteLine(ans.ToString());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace mondai0037\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar\tgrid\t= new int[ 20, 20 ];\n\t\t\tinput_grid( grid );\n\n\t\t\tint\tret_cnt\t= 0;\n\t\t\tint\tx\t= 10;\n\t\t\tint\ty\t= 10;\n\t\t\tint\tdir\t= 0;\n\t\t\tdo {\n\t\t\t\tdo {\n\t\t\t\t\tswitch( dir ) {\n\t\t\t\t\tcase\t0:\t\t// R\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase\t1:\t\t// D\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase\t2:\t\t// L\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y + 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t\tdir\t= 3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase\t3:\t\t// U\n\t\t\t\t\t\tif( ((grid[ y, x ] & grid[ y, x - 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"L\" );\n\t\t\t\t\t\t\tx--;\n\t\t\t\t\t\t\tdir\t= 2;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y - 1, x ]) & 0x02) == 0x02 ) {\n\t\t\t\t\t\t\tConsole.Write( \"U\" );\n\t\t\t\t\t\t\ty--;\n\t\t\t\t\t\t} else if( ((grid[ y, x ] & grid[ y, x + 1 ]) & 0x01) == 0x01 ) {\n\t\t\t\t\t\t\tConsole.Write( \"R\" );\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\tdir\t= 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write( \"D\" );\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\tdir\t= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} while( (x != 10) || (y != 10) );\n\t\t\t\tret_cnt++;\n\t\t\t\tif( ret_cnt == 1 ) {\n\t\t\t\t\tif( (grid[ x, y ] & 0x02) != 0x02 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} while( ret_cnt < 2 );\n\t\t\tConsole.WriteLine();\n\t\t}\n\n\n\t\tstatic void input_grid( int[,] grid )\n\t\t{\n\t\t\tfor( int i = 0; i < 9; i++ ) {\n\t\t\t\tvar\tstr\t= Console.ReadLine();\n\t\t\t\tint\ty\t= i / 2;\n\t\t\t\tif( (i & 0x01) == 0x00 ) {\n\t\t\t\t\tfor( int x = 0; x < 4; x++ ) {\n\t\t\t\t\t\tif( str[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x01;\n\t\t\t\t\t\t\tgrid[ y + 10, x + 11 ]\t|= 0x01;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( int x = 0; x < 5; x++ ) {\n\t\t\t\t\t\tif( str[ x ] == '1' ) {\n\t\t\t\t\t\t\tgrid[ y + 10, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t\tgrid[ y + 11, x + 10 ]\t|= 0x02;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Grid\n{\n    private bool[,,] grid = new bool[5, 5, 4];\n    private readonly int[] dx = { 1, 0, -1, 0 };\n    private readonly int[] dy = { 0, 1, 0, -1 };\n    private int x, y, d;\n    private readonly string sd = \"RDLU\";\n\n    public void MakeGrid()\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            string input = Console.ReadLine();\n            if ((i & 1) == 0)\n            {\n                for (int j = 0; j < 4; j++)\n                {\n                    if (input[j] == '1')\n                    {\n                        grid[i / 2, j, 0] = grid[i / 2, j + 1, 2] = true;\n                    }\n                }\n            }\n            else\n            {\n                for (int j = 0; j < 5; j++)\n                {\n                    if (input[j] == '1')\n                    {\n                        grid[i / 2, j, 1] = grid[i / 2 + 1, j, 3] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    public void Solve()\n    {\n        do\n        {\n            for (int i = 0; i < 4; i++)\n            {\n                int t = (i + d + 3) % 4;\n                if (grid[y, x, t])\n                {\n                    d = t;\n                    x += dx[d];\n                    y += dy[d];\n                    Console.Write(sd[d]);\n                    break;\n                }\n            }\n        } while (!(x == 0 && y == 0));\n        Console.WriteLine();\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Grid grid = new Grid();\n        grid.MakeGrid();\n        grid.Solve();\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ\n{\n    class Program\n    {\n        private static Dictionary<char, char[]> rooting = new Dictionary<char, char[]>\n        {\n            {'R', \"URDL\".ToCharArray()},\n            {'D', \"RDLU\".ToCharArray()},\n            {'L', \"DLUR\".ToCharArray()},\n            {'U', \"LURD\".ToCharArray()},\n        };\n\n        struct Pair\n        {\n            public int from;\n            public int to;\n\n            public Pair(int @from, int to) : this()\n            {\n                this.@from = @from;\n                this.to = to;\n            }\n        }\n\n        private static HashSet<Pair> walls = new HashSet<Pair>();\n\n        static void Main(string[] args)\n        {\n            string line;\n            bool horizontal = true;\n            int l = 0;\n            while((line = Console.ReadLine()) != null)\n            {\n                int i = 0;\n                foreach(var c in line)\n                {\n                    if (c == '1')\n                    {\n                        walls.Add(new Pair(l / 2 * 5 + i, l / 2 * 5 + (horizontal ? 1 : 5) + i));\n                    }\n                    i++;\n                }\n                l++;\n                horizontal = !horizontal;\n            }\n            char dir = 'R';\n            int point = 1;\n            Console.Write(dir);\n            while(true)\n            {\n                MoveNext(ref point, ref dir);\n                Console.Write(dir);\n                if (point == 0) break;\n            }\n            Console.WriteLine();\n        }\n\n        private static void MoveNext(ref int point, ref char dir)\n        {\n            foreach(var root in rooting[dir])\n            {\n                int next_point = GetNext(point, root);\n                if (next_point == -1) continue;\n                if (!IsWall(point, next_point)) continue;\n                point = next_point;\n                dir = root;\n                return;\n            }\n        }\n\n        private static int GetNext(int point, char root)\n        {\n            switch(root)\n            {\n            case 'R':\n                if (point % 5 == 4) return -1;\n                return point + 1;\n            case 'D':\n                if (point >= 20) return -1;\n                return point + 5;\n            case 'L':\n                if (point % 5 == 0) return -1;\n                return point - 1;\n            default:\n                if (point < 5) return -1;\n                return point - 5;\n            }\n        }\n\n        private static bool IsWall(int point, int nextPoint)\n        {\n            return\n                walls.Contains(new Pair(point, nextPoint)) ||\n                walls.Contains(new Pair(nextPoint, point));\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace Volumen0\n{\n    class Program\n    {\n        static void Main()\n        {\n            string line;\n            var x = 1;\n            var y = 0;\n            var isVert = true;\n\n            var dir = 2;\n            var list = new List<string>();\n            while ((line = Console.ReadLine()) != null)\n            {\n                list.Add(line);\n            }\n            var vert = new string[list[0].Length + 1];\n            var hori = new string[list[0].Length];\n            var size = hori.Length;\n            var tmpV = 0;\n            var tmpH = 0;\n            foreach (var v in list)\n            {\n                if (isVert)\n                {\n                    vert[tmpV++] = v;\n                }\n                else\n                {\n                    hori[tmpH++] = v;\n                }\n                isVert = !isVert;\n            }\n\n\n            do\n            {\n                if (dir == 0)\n                {\n                    if (0 < x && x <= size && 0 < y && vert[y - 1][x - 1] == '0' || x == 0)\n                    {\n                        dir = 1;\n                        --y;\n                    }\n                    else if (0 < y && y <= size && 0 < x && hori[y - 1][x - 1] == '0' || y == 0 || y == size + 1)\n                    {\n                        dir = 0;\n                        --x;\n                        Console.Write(\"L\");\n                    }\n                    else if (0 < x && x <= size && y <= size && vert[y][x - 1] == '0')\n                    {\n                        dir = 3;\n                        ++y;\n                        Console.Write(\"LD\");\n                    }\n                    else\n                    {\n                        dir = 2;\n                        ++x;\n                        Console.Write(\"LDR\");\n                    }\n                }\n                else if (dir == 1)\n                {\n                    if (0 < y && y <= size && x <= size && hori[y - 1][x] == '0' || y == 0)\n                    {\n                        dir = 2;\n                        ++x;\n                    }\n                    else if (0 < x && x <= size && 0 < y && vert[y - 1][x - 1] == '0' || x == 0 || x == size + 1)\n                    {\n                        dir = 1;\n                        --y;\n                        Console.Write(\"U\");\n                    }\n                    else if (0 < y && y <= size && 0 < x && hori[y - 1][x - 1] == '0')\n                    {\n                        dir = 0;\n                        --x;\n                        Console.Write(\"UL\");\n                    }\n                    else\n                    {\n                        dir = 3;\n                        ++y;\n                        Console.Write(\"ULD\");\n                    }\n                }\n                else if (dir == 2)\n                {\n                    if (0 < x && x <= size && y <= size && vert[y][x - 1] == '0' || x > size)\n                    {\n                        dir = 3;\n                        ++y;\n                    }\n                    else if (0 < y && y <= size && x <= size && hori[y - 1][x] == '0' || y == 0 || y == size + 1)\n                    {\n                        dir = 2;\n                        ++x;\n                        Console.Write(\"R\");\n                    }\n                    else if (0 < x && x <= size && 0 < y && vert[y - 1][x - 1] == '0')\n                    {\n                        dir = 1;\n                        --y;\n                        Console.Write(\"RU\");\n                    }\n                    else\n                    {\n                        dir = 0;\n                        --x;\n                        Console.Write(\"RUL\");\n                    }\n                }\n                else if (dir == 3)\n                {\n                    if (0 < y && y <= size && 0 < x && hori[y - 1][x - 1] == '0' || y > size)\n                    {\n                        dir = 0;\n                        --x;\n                    }\n                    else if (0 < x && x <= size && y <= size && vert[y][x - 1] == '0' || x == 0 || x == size + 1)\n                    {\n                        dir = 3;\n                        ++y;\n                        Console.Write(\"D\");\n                    }\n                    else if (0 < y && y <= size && x <= size && hori[y - 1][x] == '0')\n                    {\n                        dir = 2;\n                        ++x;\n                        Console.Write(\"DR\");\n                    }\n                    else\n                    {\n                        dir = 1;\n                        --y;\n                        Console.Write(\"DRU\");\n                    }\n                }\n            }\n            while (x != 1 || y != 0);\n            Console.WriteLine();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main()\n        {\n            StringBuilder sb = new StringBuilder();\n\n            string d = \"RDLU\";\n            int[] dx = { 1, 0, -1, 0 };\n            int[] dy = { 0, 1, 0, -1 };\n\n            int[,] width = new int[6, 6];\n            int[,] height = new int[6, 6];\n\n            for (int i = 0; i < 9; i++)\n            {\n                string input = Console.ReadLine();\n\n                if (i % 2 == 0)\n                {\n                    for (int j = 1; j <= 4; j++)\n                    {\n                        width[j, i / 2 + 1] = int.Parse(input[j - 1].ToString());\n                    }\n                }\n                else\n                {\n                    for (int j = 1; j <= 5; j++)\n                    {\n                        height[j, (i + 1) / 2] = int.Parse(input[j - 1].ToString());\n                    }\n                }\n            }\n\n            int x = 1, y = 1;\n            int dir = 0;\n\n            do\n            {\n                switch (dir)\n                {\n                    case 0:\n                        if (height[x, y - 1] == 1) dir--;\n                        else if (width[x, y] == 0 && height[x, y] == 1) dir++;\n                        else if (width[x, y] == 0 && height[x, y] == 0) dir += 2;\n                        break;\n                    case 1:\n                        if (width[x, y] == 1) dir--;\n                        else if (height[x, y] == 0 && width[x - 1, y] == 1) dir++;\n                        else if (height[x, y] == 0 && width[x - 1, y] == 0) dir += 2;\n                        break;\n                    case 2:\n                        if (height[x, y] == 1) dir--;\n                        else if (width[x - 1, y] == 0 && height[x, y - 1] == 1) dir++;\n                        else if (width[x - 1, y] == 0 && height[x, y - 1] == 0) dir += 2;\n                        break;\n                    case 3:\n                        if (width[x - 1, y] == 1) dir--;\n                        else if (height[x, y - 1] == 0 && width[x, y] == 1) dir++;\n                        else if (height[x, y - 1] == 0 && width[x, y] == 0) dir += 2;\n                        break;\n                }\n                dir = (4 + dir) % 4;\n\n                x += dx[dir];\n                y += dy[dir];\n\n                sb.Append(d[dir]);\n\n            } while (x != 1 || y != 1);\n\n            Console.WriteLine(sb);\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "(function(input) {\n  var p = input.replace(/\\n$/, '').split('\\n');\n  var m = [];\n  for (var i = 0; i < p.length; i++) {\n    m.push(p[i].split('').map(Number))\n  }\n  console.log('R' + move(m, 0, 0, 'R'));\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));\n\nfunction move(m, x, y, d) {\n  console.log(m, x, y, d);\n  if (x === 0 && y === 0 && d === 'L') {\n    return '';\n  }\n  if (d === 'R') {\n    if (mm(m, x + 1, y - 1)) {\n      return 'U' + move(m, x + 1, y - 1, 'U');\n    }\n    if (mm(m, x + 1, y)) {\n      return 'R' + move(m, x + 1, y, 'R');\n    }\n    if (mm(m, x + 1, y + 1)) {\n      return 'D' + move(m, x + 1, y + 1, 'D');\n    }\n    return 'L' + move(m, x, y, 'L');\n  }\n  if (d === 'L') {\n    if (mm(m, x, y + 1)) {\n      return 'D' + move(m, x, y + 1, 'D');\n    }\n    if (mm(m, x - 1, y)) {\n      return 'L' + move(m, x - 1, y, 'L');\n    }\n    if (mm(m, x, y - 1)) {\n      return 'U' + move(m, x, y - 1, 'U');\n    }\n    return 'R'+ move(m, x, y, 'R');\n  }\n  if (d === 'D') {\n    if (mm(m, x, y + 1)) {\n      return 'R' + move(m, x, y + 1, 'R');\n    }\n    if (mm(m, x, y + 2)) {\n      return 'D' + move(m, x, y + 2, 'D');\n    }\n    if (mm(m, x - 1, y + 1)) {\n      return 'L' + move(m, x - 1, y + 1, 'L');\n    }\n    return 'U' + move(m, x, y, 'U');\n  }\n  if (d === 'U') {\n    if (mm(m, x - 1, y - 1)) {\n      return 'L' + move(m, x - 1, y - 1, 'L');\n    }\n    if (mm(m, x, y - 2)) {\n      return 'U' + move(m, x, y - 2, 'U');\n    }\n    if (mm(m, x, y - 1)) {\n      return 'R' + move(m, x, y - 1, 'R');\n    }\n    return 'D' + move(m, x, y, 'D');\n  }\n}\n\nfunction mm(m, x, y) {\n  if (y < 0 || y >= m.length) {\n    return 0;\n  }\n  if (x < 0 || x >= m[y].length) {\n    return 0;\n  }\n  return m[y][x] === 1;\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');\nmain();\n\nfunction main(){\n  var x=y=0;\n  var d='R';\n  var route='';\n\n  \n  while(true){\n    var dy = y*2+1;\n    var uy = y*2-1;\n    var ny = y*2;\n    var lx = x-1;\n    var rx = x+1;\n    var nx = x;\n    switch(d){\n    case 'L':\n      if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }else if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      } \n      break;\n    case 'R':\n      if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }else if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      }\n      break;\n    case 'D':\n      if(dy < input.length && +input[dy][nx]){// ↓に行ける\n        d='D';y++;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }\n      break;\n    case 'U':\n      if(uy > 0 && +input[uy][nx]){// ↑に行ける\n        d='U';y--;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }\n      break;\n    default:\n      return;\n    }\n    route+=d;\n    if(!x && !y)\n      break;\n  }\n  console.log(route);\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');\nmain();\n\nfunction main(){\n  var x=y=0;\n  var d='R';\n  var route='';\n\n  while(true){\n    var dy = y*2+1;\n    var uy = y*2-1;\n    var ny = y*2;\n    var lx = x-1;\n    var rx = x+1;\n    var nx = x;\n\n    switch(d){\n    case 'L':\n      if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }else{\n        d='R';x++;\n      }\n      break;\n    case 'R':\n      if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      }else{\n        d='L';x--;\n      }\n      break;\n    case 'D':\n      if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(dy < input.length && +input[dy][nx]){// ↓に行ける\n        d='D';y++;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else{\n        d='U';y--;\n      }\n      break;\n    case 'U':\n      if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else if(uy > 0 && +input[uy][nx]){// ↑に行ける\n        d='U';y--;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else{\n        d='D';y++;\n      }\n      break;\n    default:\n      return;\n    }\n    route+=d;\n    if(!x && !y)\n      break;\n  }\n  console.log(route);\n}"
  },
  {
    "language": "JavaScript",
    "code": "(function(input) {\n  var p = input.replace(/\\n$/, '').split('\\n');\n  var m = [];\n  for (var i = 0; i < p.length; i++) {\n    m.push(p[i].split('').map(Number))\n  }\n  console.log('R' + move(m, 0, 0, 'R'));\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));\n\nfunction move(m, x, y, d) {\n  //console.log(m, x, y, d);\n  if (x === 0 && y === 0 && d === 'L') {\n    return '';\n  }\n  if (d === 'R') {\n    if (mm(m, x + 1, y - 1)) {\n      return 'U' + move(m, x + 1, y - 1, 'U');\n    }\n    if (mm(m, x + 1, y)) {\n      return 'R' + move(m, x + 1, y, 'R');\n    }\n    if (mm(m, x + 1, y + 1)) {\n      return 'D' + move(m, x + 1, y + 1, 'D');\n    }\n    return 'L' + move(m, x, y, 'L');\n  }\n  if (d === 'L') {\n    if (mm(m, x, y + 1)) {\n      return 'D' + move(m, x, y + 1, 'D');\n    }\n    if (mm(m, x - 1, y)) {\n      return 'L' + move(m, x - 1, y, 'L');\n    }\n    if (mm(m, x, y - 1)) {\n      return 'U' + move(m, x, y - 1, 'U');\n    }\n    return 'R'+ move(m, x, y, 'R');\n  }\n  if (d === 'D') {\n    if (mm(m, x, y + 1)) {\n      return 'R' + move(m, x, y + 1, 'R');\n    }\n    if (mm(m, x, y + 2)) {\n      return 'D' + move(m, x, y + 2, 'D');\n    }\n    if (mm(m, x - 1, y + 1)) {\n      return 'L' + move(m, x - 1, y + 1, 'L');\n    }\n    return 'U' + move(m, x, y, 'U');\n  }\n  if (d === 'U') {\n    if (mm(m, x - 1, y - 1)) {\n      return 'L' + move(m, x - 1, y - 1, 'L');\n    }\n    if (mm(m, x, y - 2)) {\n      return 'U' + move(m, x, y - 2, 'U');\n    }\n    if (mm(m, x, y - 1)) {\n      return 'R' + move(m, x, y - 1, 'R');\n    }\n    return 'D' + move(m, x, y, 'D');\n  }\n}\n\nfunction mm(m, x, y) {\n  if (y < 0 || y >= m.length) {\n    return 0;\n  }\n  if (x < 0 || x >= m[y].length) {\n    return 0;\n  }\n  return m[y][x] === 1;\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).trim().split('\\n');\nmain();\n\nfunction main(){\n  var x=y=0;\n  var d='R';\n  var route='';\n\n  while(true){\n    var dy = y*2+1;\n    var uy = y*2-1;\n    var ny = y*2;\n    var lx = x-1;\n    var rx = x+1;\n    var nx = x;\n\n    switch(d){\n    case 'L':\n      if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }else if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      } \n      break;\n    case 'R':\n      if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(dy < input.length && +input[dy][nx]){//↓に行ける\n        d='D';y++;\n      }else if(uy > 0 && +input[uy][nx]){//↑に行ける\n        d='U';y--;\n      }\n      break;\n    case 'D':\n      if(dy < input.length && +input[dy][nx]){// ↓に行ける\n        d='D';y++;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }\n      break;\n    case 'U':\n      if(uy > 0 && +input[uy][nx]){// ↑に行ける\n        d='U';y--;\n      }else if(+input[ny][lx]){// ←に行ける\n        d='L';x--;\n      }else if(+input[ny][nx]){// →に行ける\n        d='R';x++;\n      }\n      break;\n    default:\n      return;\n    }\n    route+=d;\n    if(!x && !y)\n      break;\n  }\n  console.log(route);\n}"
  },
  {
    "language": "Ruby",
    "code": "$wall = $<.each_line.map(&:chomp)\ndef wall?(i, j, di, dj)\n\ti = i * 2 + di\n\tj += dj / 2\n\treturn false if i < 0 or 8 < i or j < 0\n\treturn $wall[i][j] == '1'\nend\n\ni = j = 0\nexit unless wall?(i, j, 0, 1) or wall?(i, j, 1, 0)\n\nlabel = {\n\t[0, 1] => 'R',\n\t[1, 0] => 'D',\n\t[0, -1] => 'L',\n\t[-1, 0] => 'U',\n}\n\nv = [1, 0]\nloop do\n\tcase\n\twhen wall?(i, j, -v[1], v[0])\n\t\tv = [-v[1], v[0]]\n\twhen wall?(i, j, *v)\n\twhen wall?(i, j, v[1], -v[0])\n\t\tv = [v[1], -v[0]]\n\telse\n\t\tv = [-v[0], -v[1]]\n\tend\n\ti += v[0]\n\tj += v[1]\n\tprint label[v]\n\n\tbreak if i.zero? and j.zero?\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n      count += 1\n      break if count > 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "given = $<.readlines.map {|l| l.chomp.chars.map(&:to_i)}\nyoko = 0.step(8, 2).map {|i| given[i]}\ntate = 1.step(8, 2).map {|i| given[i]}.transpose\ndirs = \"LRUD\"\ngo = nil\nroute = \"\"\nf = false\n\nget_yoko = ->(x, y, dir) {\n  if dir == 0\n    if tate[x][y] == 1\n      go.(x, y, 3)\n    elsif x > 0 and yoko[y][x - 1] == 1\n      go.(x, y, 0)\n    elsif y > 0 and tate[x][y - 1] == 1\n      go.(x, y, 2)\n    else\n     go.(x, y, 1)\n    end\n  else\n    if y > 0 and tate[x][y - 1] == 1\n      go.(x, y, 2)\n    elsif x <= 3 and yoko[y][x] == 1\n      go.(x, y, 1)\n    elsif tate[x][y] == 1\n      go.(x, y, 3)\n    else\n      go.(x, y, 0)\n    end\n  end\n}\n\nget_tate = ->(x, y, dir) {\n  if dir == 2\n    if x > 0 and yoko[y][x - 1] == 1\n      go.(x, y, 0)\n    elsif y > 0 and tate[x][y - 1] == 1\n      go.(x, y, 2)\n    elsif yoko[y][x] == 1\n      go.(x, y, 1)\n    else\n      go.(x, y, 3)\n    end\n  else\n    if x <= 3 and yoko[y][x] == 1\n      go.(x, y, 1)\n    elsif y <= 3 and tate[x][y] == 1\n      go.(x, y, 3)\n    elsif x > 0 and yoko[y][x - 1] == 1\n      go.(x, y, 0)\n    else\n      go.(x, y, 2)\n    end\n  end\n}\n\ngo = ->(x, y, dir) {\n  return if x.zero? and y.zero? and f\n  f = true\n  route += dirs[dir]\n  if dir <= 1\n    get_yoko.(x + dir * 2 - 1, y, dir)\n  else\n    get_tate.(x, y + dir * 2 - 5, dir)\n  end\n}\n\ngo.(0, 0, 1)\nputs route\n"
  },
  {
    "language": "Ruby",
    "code": "def solve(y, x, way)\n  if y==0&&x==0&&way==3 then\n    print 'L'\n    return\n  end\n  if y==1&&x==0&&way==2 then\n    print 'U'\n    return\n  end\n  if way==1 then\n    print 'R'\n    if y>0&&$d[y-1][x+1]=='1' then\n      solve(y-1,x+1,2)\n    elsif x<5&&$d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    elsif y<8&&$d[y+1][x+1]=='1' then\n      solve(y+1,x+1,4)\n    elsif x>0&&$d[y][x]=='1' then\n      solve(y,x,3)\n    end\n  elsif way==2 then\n    print 'U'\n    if x>0&&$d[y-1][x-1]=='1' then\n      solve(y-1,x-1,3)\n    elsif y>1&&$d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    elsif x<4&&$d[y-1][x]=='1' then\n      solve(y-1,x,1)\n    elsif y<7&&$d[y][x]=='1' then\n      solve(y,x,4)\n    end\n  elsif way==3 then\n    print 'L'\n    if y<8&&$d[y+1][x]=='1' then\n      solve(y+1,x,4)\n    elsif x>0&&$d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    elsif y>0&&$d[y-1][x]=='1' then\n      solve(y-1,x,2)\n    elsif x<4&&$d[y][x]=='1' then\n      solve(y,x,1)\n    end\n  elsif way==4 then\n    print 'D'\n    if x<4&&$d[y+1][x]=='1' then\n      solve(y+1,x,1)\n    elsif y<7&&$d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    elsif x>0&&$d[y+1][x-1]=='1' then\n      solve(y+1,x-1,3)\n    elsif y>1&&$d[y][x]=='1' then\n      solve(y,x,2)\n    end\n  end\nend\n$d = Array.new(10)\n9.times do |i|\n  $d[i] = gets\nend\nprint 'R'\nsolve(0,1,1)\nputs"
  },
  {
    "language": "Ruby",
    "code": "d=2\nmap=*$<\no=?R\nx,y=1,0\n(u,v=9,9\n(d+=1\nu=x+[0,0,-1,0][d%4]\nv=y+[0,1,0,-1][d%4]\n)until u>=0&&v>=0&&v<9&&map[v][u]==?1\ne=d%4\nx+=[1,0,-1,0][e]\ny+=[0,2,0,-2][e]\no+=\"RDLU\"[e]\nd+=2\n)while [x,y]!=[0,0]\nputs o"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        $stderr.puts @map \n        walk_map\n        results << @result\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      break\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "Even, Odd = 0, 1\nR, D, L, U = (0...4).to_a\nLetter = [\"R\", \"D\", \"L\", \"U\"]\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\nhorizontalWall = Array.new(5+2) {Array.new(4+2, 0)}\nverticalWall = Array.new(4+2) {Array.new(5+2, 0)}\nhorizontalWall[1][1,4] = gets.chomp.chars.map(&:to_i)\nfor i in 1..4 do\n  verticalWall[i][1,5] = gets.chomp.chars.map(&:to_i)\n  horizontalWall[i+1][1,4] = gets.chomp.chars.map(&:to_i)\nend\n\nprint \"R\"\ny = 0\nx = 1\ndirection = R\nwhile ([y, x] != [1, 0]) && ([y, x] != [1, 1]) do\n  case direction\n    when R\n      if verticalWall[y][x+1] == 1\n        direction = (direction - 1) % 4\n      elsif horizontalWall[y+1][x+1] == 0\n        direction = (direction + 1) % 4\n        y += 1\n        x += 1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when L\n      if verticalWall[y][x] == 1\n        direction = (direction - 1) % 4\n      elsif horizontalWall[y][x-1] == 0\n        direction = (direction + 1) % 4\n        y += -1\n        x += -1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when D\n      if horizontalWall[y+1][x] == 1\n        direction = (direction - 1) % 4\n      elsif verticalWall[y+1][x] == 0\n        direction = (direction + 1) % 4\n        y += 1\n        x += -1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when U\n      if horizontalWall[y][x] == 1\n        direction = (direction - 1) % 4\n      elsif verticalWall[y-1][x+1] == 0\n        direction = (direction + 1) % 4\n        y += -1\n        x += 1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n  end\n  print Letter[direction]\nend\nputs \"\""
  },
  {
    "language": "Ruby",
    "code": "def solve(y, x, way)\n  if y==0&&x==0&&way==3 then\n    print 'L'\n    return\n  end\n  if y==1&&x==0&&way==2 then\n    print 'U'\n    return\n  end\n  if way==1 then\n    print 'R'\n    if y>0&&$d[y-1][x+1]=='1' then\n      solve(y-1,x+1,2)\n    elsif x<5&&$d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    elsif y<8&&$d[y+1][x+1]=='1' then\n      solve(y+1,x+1,4)\n    elsif x>0&&$d[y][x]=='1' then\n      solve(y,x,3)\n    end\n  elsif way==2 then\n    print 'U'\n    if x>0&&$d[y-1][x-1]=='1' then\n      solve(y-1,x-1,3)\n    elsif y>1&&$d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    elsif x<4&&$d[y-1][x]=='1' then\n      solve(y-1,x,1)\n    elsif y<7&&$d[y][x]=='1' then\n      solve(y,x,4)\n    end\n  elsif way==3 then\n    print 'L'\n    if y<8&&$d[y+1][x]=='1' then\n      solve(y+1,x,4)\n    elsif x>0&&$d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    elsif y>0&&$d[y-1][x]=='1' then\n      solve(y-1,x,2)\n    elsif x<4&&$d[y][x]=='1' then\n      solve(y,x,1)\n    end\n  elsif way==4 then\n    print 'D'\n    if x<4&&$d[y+1][x]=='1' then\n      solve(y+1,x,1)\n    elsif y<7&&$d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    elsif x>0&&$d[y+1][x-1]=='1' then\n      solve(y+1,x-1,3)\n    elsif y>1&&$d[y][x]=='1' then\n      solve(y,x,2)\n    end\n  end\nend\n$d = Array.new(10)\n9.times do |i|\n  $d[i] = gets\nend\nsolve(0,0,1)\nputs"
  },
  {
    "language": "Ruby",
    "code": "def move_right(m, rs, x, y)\n\tputs \"move_right #{x} #{y} #{rs}\"\n\tif m[y][x] == 1 then\n\t\tx += 1\n\t\trs << \"R\"\n\n\t\tif x < m[y].size then\n\t\t\tmove_right(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x] == 1 then\n\t\tmove_up(m, rs, x, y-1)\n\telse\n\t\tmove_down(m, rs, x, y+1)\n\tend\nend\n\ndef move_left(m, rs, x, y)\n\tputs \"move_left  #{x} #{y} #{rs}\"\n\tif x == 0 && y == 0 then\n\t\trs << \"L\"\n\t\treturn\n\tend\n\n\tif m[y][x] == 1 then\n\t\tx -= 1\n\t\trs << \"L\"\n\n\t\tif x >= 0 then\n\t\t\tmove_left(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x+1] == 1 then\n\t\tmove_up(m, rs, x+1, y-1)\n\telse\n\t\tmove_down(m, rs, x+1, y+1)\n\tend\nend\n\ndef move_down(m, rs, x, y)\n\tputs \"move_down  #{x} #{y} #{rs}\"\n\n\tif m[y][x] == 1 then\n\t\ty += 2\n\t\trs << \"D\"\n\n\t\tif y < m.size then\n\t\t\tmove_down(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y-1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y-1)\n\telse\n\t\tmove_right(m, rs, x, y-1)\n\tend\nend\n\ndef move_up(m, rs, x, y)\n\tputs \"move_up    #{x} #{y} #{rs}\"\n\tif m[y][x] == 1 then\n\t\ty -= 2\n\t\trs << \"U\"\n\n\t\tif y >= 0 then\n\t\t\tmove_up(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y+1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y+1)\n\telse\n\t\tmove_right(m, rs, x, y+1)\n\tend\nend\n\nm = []\n\n9.times {\n\tm.push gets.chomp.split('').map(&:to_i)\n}\n\nx = 0\ny = 0\nrs = \"\"\nmove_right(m, rs, x, y)\n\nputs rs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n        pp @map\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      raise @map if count > 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "a=[?0*6]\nb=a.dup\n5.times{|i|\n  a<<?0+gets[0,4]+?0\n  b<<(i<4?(?0+gets):?0*6)\n}\nc=[a,b]\nx=2\ny=d=1\nprint \"R\"\nwhile x+y!=2\n  case d\n  when 1#R\n  if c[1][y-1][x]==?1\n    y-=1\n    d=0\n    print \"U\"\n  elsif c[0][y][x]==?1\n    x+=1\n    d=1\n    print \"R\"\n  elsif c[1][y][x]==?1\n    y+=1\n    d=2\n    print \"D\"\n  elsif c[0][y][x-1]==?1\n    x-=1\n    d=3\n    print \"L\"\n  end\n  when 2#D\n  if c[0][y][x]==?1\n    x+=1\n    d=1\n    print \"R\"\n  elsif c[1][y][x]==?1\n    y+=1\n    d=2\n    print \"D\"\n  elsif c[0][y][x-1]==?1\n    x-=1\n    d=3\n    print \"L\"\n  elsif c[1][y-1][x]==?1\n    y-=1\n    d=0\n    print \"U\"\n  end\n  when 3#L\n  if c[1][y][x]==?1\n    y+=1\n    d=2\n    print \"D\"\n  elsif c[0][y][x-1]==?1\n    x-=1\n    d=3\n    print \"L\"\n  elsif c[1][y-1][x]==?1\n    y-=1\n    d=0\n    print \"U\"\n  elsif c[0][y][x]==?1\n    x+=1\n    d=1\n    print \"R\"\n  end\n  when 0#U\n  if c[0][y][x-1]==?1\n    x-=1\n    d=3\n    print \"L\"\n  elsif c[1][y-1][x]==?1\n    y-=1\n    d=0\n    print \"U\"\n  elsif c[0][y][x]==?1\n    x+=1\n    d=1\n    print \"R\"\n  elsif c[1][y][x]==?1\n    y+=1\n    d=2\n    print \"D\"\n  end\n  end\nend\nputs\"\""
  },
  {
    "language": "Ruby",
    "code": "H, W = 5, 5\nNone, Wall = 0, 1\nR, D, L, U = (0...4).to_a\nLetter = [\"R\", \"D\", \"L\", \"U\"]\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\nhorizontalWall = Array.new(5+2) {Array.new(4+2, 0)}\nverticalWall = Array.new(4+2) {Array.new(5+2, 0)}\nhorizontalWall[1][1,4] = gets.chomp.chars.map(&:to_i)\nfor i in 1..4 do\n  verticalWall[i][1,5] = gets.chomp.chars.map(&:to_i)\n  horizontalWall[i+1][1,4] = gets.chomp.chars.map(&:to_i)\nend\n\nfrontWall = Array.new(H) {Array.new(W) {Array.new(4, 0)}}\nrightWall = Array.new(H) {Array.new(W) {Array.new(4, 0)}}\nfor i in 0...5 do\n  for j in 0...5 do\n    rightWall[i][j][R] = horizontalWall[i+1][j+1]\n    rightWall[i][j][L] = horizontalWall[i+1][j]\n    rightWall[i][j][U] = verticalWall[i][j+1]\n    rightWall[i][j][D] = verticalWall[i+1][j+1]\n\n    frontWall[i][j][R] = verticalWall[i][j+1]\n    frontWall[i][j][L] = verticalWall[i+1][j+1]\n    frontWall[i][j][U] = horizontalWall[i+1][j]\n    frontWall[i][j][D] = horizontalWall[i+1][j+1]\n  end\nend\n\ny = x = 0\ndirection = R\nwhile true do\n  break if [y, x] == [0, 0] && direction != R\n  if frontWall[y][x][direction] == Wall\n    direction = (direction - 1) % 4\n  else\n    while rightWall[y][x][direction] != Wall do\n      direction = (direction + 1) % 4\n    end\n  end\n  print Letter[direction]\n  y += dy[direction]\n  x += dx[direction]\nend\nputs \"\""
  },
  {
    "language": "Ruby",
    "code": "def solve(y, x, way)\n  if y==0&&x==0&&way==3 then\n    print 'L'\n    return\n  end\n  if y==1&&x==0&&way==2 then\n    print 'U'\n    return\n  end\n  if way==1 then\n    print 'R'\n    if y>0&& $d[y-1][x+1]=='1' then\n      solve(y-1,x+1,2)\n    elsif x<5&& $d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    elsif y<8&& $d[y+1][x+1]=='1' then\n      solve(y+1,x+1,4)\n    elsif x>0&& $d[y][x]=='1' then\n      solve(y,x,3)\n    end\n  elsif way==2 then\n    print 'U'\n    if x>0&& $d[y-1][x-1]=='1' then\n      solve(y-1,x-1,3)\n    elsif y>1&& $d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    elsif x<4&& $d[y-1][x]=='1' then\n      solve(y-1,x,1)\n    elsif y<7&& $d[y][x]=='1' then\n      solve(y,x,4)\n    end\n  elsif way==3 then\n    print 'L'\n    if y<8&& $d[y+1][x]=='1' then\n      solve(y+1,x,4)\n    elsif x>0&& $d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    elsif y>0&& $d[y-1][x]=='1' then\n      solve(y-1,x,2)\n    elsif x<4&& $d[y][x]=='1' then\n      solve(y,x,1)\n    end\n  elsif way==4 then\n    print 'D'\n    if x<4&& $d[y+1][x]=='1' then\n      solve(y+1,x,1)\n    elsif y<7&& $d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    elsif x>0&& $d[y+1][x-1]=='1' then\n      solve(y+1,x-1,3)\n    elsif y>1&& $d[y][x]=='1' then\n      solve(y,x,2)\n    end\n  end\nend\n$d = Array.new(9)\n9.times do |i|\n  $d[i] = gets\nend\nprint 'R'\nsolve(0,1,1)\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    @x = 0\n    @y = 0\n    @width = 9\n    @height = 9\n    @direct = 0\n    @map = []\n    while input = $stdin.gets do \n      @result = \"\"\n      @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      count = 1\n      8.times do \n        if count % 2 == 0  \n          @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n        else\n          @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n        end\n        count += 1\n      end\n      walk_map\n      results << @result\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    @x.upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    @y.upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    @x.downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    @y.downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "def solve(y, x, way)\n  if y==0&&x==0 then\n    print 'L'\n    return\n  end\n  if y==1&&x==0&&way==2 then\n    print 'U'\n    return\n  end\n  if way==1 then\n    print 'R'\n    if y>0&& $d[y-1][x+1]=='1' then\n      solve(y-1,x+1,2)\n    elsif x<4&& $d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    elsif y<8&& $d[y+1][x+1]=='1' then\n      solve(y+1,x+1,4)\n    elsif x>0&& $d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    end\n  elsif way==2 then\n    print 'U'\n    if x>0&& $d[y-1][x-1]=='1' then\n      solve(y-1,x-1,3)\n    elsif y>1&& $d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    elsif x<4&& $d[y-1][x]=='1' then\n      solve(y-1,x,1)\n    elsif y<7&& $d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    end\n  elsif way==3 then\n    print 'L'\n    if y<8&& $d[y+1][x]=='1' then\n      solve(y+1,x,4)\n    elsif x>0&& $d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    elsif y>0&& $d[y-1][x]=='1' then\n      solve(y-1,x,2)\n    elsif x<4&& $d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    end\n  elsif way==4 then\n    print 'D'\n    if x<4&& $d[y+1][x]=='1' then\n      solve(y+1,x,1)\n    elsif y<7&& $d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    elsif x>0&& $d[y+1][x-1]=='1' then\n      solve(y+1,x-1,3)\n    elsif y>1&& $d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    end\n  end\nend\n$d = Array.new(9)\n9.times do |i|\n  $d[i] = gets\nend\nprint 'R'\nsolve(0,1,1)\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    @x = 0\n    @y = 0\n    @direct = 0\n    while input = $stdin.gets do \n      @result = \"\"\n      @map = []\n      count = 1\n      @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      8.times do \n        if count % 2 == 0  \n          @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n        else\n          @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n        end\n        count += 1\n      end\n      @width = @map[0].size\n      @height = @map.size\n      walk_map\n      results << @result\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n    $stderr.puts @map if count > 100000\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      @x = 0\n      @y = 0\n      @direct = 0\n      @result = \"\"\n      @map = []\n      count = 1\n      @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      8.times do \n        if count % 2 == 0  \n          @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n        else\n          @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n        end\n        count += 1\n      end\n      @width = @map[0].size\n      @height = @map.size\n      walk_map\n      results << @result\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n    count += 1\n    $stderr.puts @map if count > 100000\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "m=*$<\no=?R\nx=1\ny=d=0\n(u=v=9\n(d+=1\nv=y+[0,-1,0,1][e=d%4]\nu=x+(e<1?-1:0))until u>=0&&v>=0&&v<9&&m[v][u]==?1\nx+=[-1,0,1,0][e]\ny+=[0,-2,0,2][e]\no+=:LURD[e]\nd+=2)while x+y>0\nputs o"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = []\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @size = count\n    walk_map\n\n    puts @result.join('')\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @map.size-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @map.size-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @map[@y].size-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @map[@y].size-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    @x.step(@map[@y].size-3,2) do |index|\n      if @map[@y][index+1] == \"1\" && @map[@y][index+2] == \"1\"\n        @x += 2\n        @result << \"R\"\n      else\n        break\n      end\n    end\n    check_up_or_down\n  end\n\n  def walk_down\n    @y.step(@map.size-3,2) do |index|\n      if @map[index+1][@x] == \"1\" && @map[index+2][@x] == \"1\"\n        @y += 2\n        @result << \"D\"\n      end\n    end\n    check_right_or_left\n  end\n\n  def walk_left\n    @x.step(2,-2) do |index|\n      if @map[@y][index-1] == \"1\" && @map[@y][index-2] == \"1\"\n        @x -= 2\n        @result << \"L\"\n      else\n        break\n      end\n    end\n    check_up_or_down\n  end\n\n  def walk_up\n    @y.step(2,-2) do |index|\n      if @map[index-1][@x] == \"1\" && @map[index-2][@x] == \"1\"\n        @y -= 2\n        @result << \"U\"\n      end\n    end\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "m = []\n9.times{|i|\n  m[i] = gets.chomp.split(\"\").map(&:to_i)\n}\n\nx = 0\ny = 0\ndirec = 0\nname = [\"R\", \"D\", \"L\", \"U\"]\n\n50.times{\n  print name[direc]\n  if direc == 0\n    if y > 0 && x < 8 && m[y-1][x+1] == 1\n      direc = 3\n      y -= 1\n      x += 1\n    elsif x < 8 && m[y][x+1] == 1\n      x += 1\n    elsif y < 8 && x < 8 && m[y+1][x+1] == 1\n      direc = 1\n      y += 1\n      x += 1\n    else\n      direc = 2\n    end\n  elsif direc == 1\n    if y < 8 && m[y+1][x] == 1\n      direc = 0\n      y += 1\n    elsif y < 7 && m[y+2][x] == 1\n      y += 2\n    elsif y < 8 && x > 0 && m[y+1][x-1] == 1\n      direc = 2\n      y += 1\n      x -= 1\n    else\n      direc = 3\n    end\n  elsif direc == 2\n    if y < 8 && m[y+1][x] == 1\n      direc = 1\n      y += 1\n    elsif x > 0 && m[y][x-1] == 1\n      x -= 1\n    elsif y > 0 && m[y-1][x] == 1\n      direc = 3\n      y -= 1\n    else\n      direc = 0\n    end\n  elsif direc == 3\n    if y > 0 && x > 0 && m[y-1][x-1] == 1\n      direc = 2\n      y -= 1\n      x -= 1\n    elsif y > 1 && m[y-2][x] == 1\n      y -= 2\n    elsif y > 0 && m[y-1][x] == 1\n      direc = 0\n      y -= 1\n    else\n      direc = 1\n    end\n  end\n  break if x == 0 && y == 0 && direc == 0\n}\n\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    @x = 0\n    @y = 0\n    @direct = 0\n    while input = $stdin.gets do \n      @result = \"\"\n      @map = []\n      count = 1\n      @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      8.times do \n        if count % 2 == 0  \n          @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n        else\n          @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n        end\n        count += 1\n      end\n      @width = @map[0].size\n      @height = @map.size\n      walk_map\n      results << @result\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "def move_right(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\tx += 1\n\t\trs << \"R\"\n\n\t\tif x < m[y].size then\n\t\t\tmove_right(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x] == 1 then\n\t\tmove_up(m, rs, x, y-1)\n\telse\n\t\tmove_down(m, rs, x, y+1)\n\tend\nend\n\ndef move_left(m, rs, x, y)\n\tif x == 0 && y == 0 then\n\t\trs << \"L\"\n\t\treturn\n\tend\n\n\tif m[y][x] == 1 then\n\t\tx -= 1\n\t\trs << \"L\"\n\n\t\tif x >= 0 then\n\t\t\tmove_left(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x+1] == 1 then\n\t\tmove_up(m, rs, x+1, y-1)\n\telse\n\t\tmove_down(m, rs, x+1, y+1)\n\tend\nend\n\ndef move_down(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty += 2\n\t\trs << \"D\"\n\n\t\tif y < m.size then\n\t\t\tmove_down(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y-1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y-1)\n\telse\n\t\tmove_right(m, rs, x, y-1)\n\tend\nend\n\ndef move_up(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty -= 2\n\t\trs << \"U\"\n\n\t\tif y >= 0 then\n\t\t\tmove_up(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y+1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y+1)\n\telse\n\t\tif x == 0 && y+1 == 0 then\n\t\t\treturn\n\t\tend\n\t\tmove_right(m, rs, x, y+1)\n\tend\nend\n\nm = []\n\n9.times {\n\tm.push gets.chomp.split('').map(&:to_i)\n}\n\nx = 0\ny = 0\nrs = \"\"\nmove_right(m, rs, x, y)\n\nputs rs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    @x.upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    @y.upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    @x.downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    @y.downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      $stderr.puts pp @map \n      break\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n        pp @map\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      $stderr.puts \"#{@map[0]}\" if count > 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "def move_right(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\tx += 1\n\t\trs << \"R\"\n\n\t\tif x < m[y].size then\n\t\t\tmove_right(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x] == 1 then\n\t\tmove_up(m, rs, x, y-1)\n\telse\n\t\tmove_down(m, rs, x, y+1)\n\tend\nend\n\ndef move_left(m, rs, x, y)\n\tif x == 0 && y == 0 then\n\t\trs << \"L\"\n\t\treturn\n\tend\n\n\tif m[y][x] == 1 then\n\t\tx -= 1\n\t\trs << \"L\"\n\n\t\tif x >= 0 then\n\t\t\tmove_left(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x+1] == 1 then\n\t\tmove_up(m, rs, x+1, y-1)\n\telse\n\t\tmove_down(m, rs, x+1, y+1)\n\tend\nend\n\ndef move_down(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty += 2\n\t\trs << \"D\"\n\n\t\tif y < m.size then\n\t\t\tmove_down(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y-1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y-1)\n\telse\n\t\tmove_right(m, rs, x, y-1)\n\tend\nend\n\ndef move_up(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty -= 2\n\t\trs << \"U\"\n\n\t\tif y >= 0 then\n\t\t\tmove_up(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y+1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y+1)\n\telse\n\t\tif x == 0 && y+1 == 0 then\n\t\t\treturn\n\t\tend\n\t\tmove_right(m, rs, x, y+1)\n\tend\nend\n\nm = []\n\n9.times {\n\tm.push gets.chomp.split('').map(&:to_i)\n}\n\nx = 0\ny = 0\nrs = \"\"\nmove_right(m, rs, x, y)\n\nputs rs"
  },
  {
    "language": "Ruby",
    "code": "$wall = $<.each_line.map(&:chomp)\ndef wall?(i, j, di, dj)\n\ti = i * 2 + di\n\tj += dj / 2\n\treturn false if i < 0 or 8 < i or j < 0\n\treturn $wall[i][j] == '1'\nend\n\nlabel = {\n\t[0, 1] => 'R',\n\t[1, 0] => 'D',\n\t[0, -1] => 'L',\n\t[-1, 0] => 'U',\n}\n\ni, j = v = [0, 1]\nprint 'R'\n\nuntil i.zero? and j.zero?\n\tcase\n\twhen wall?(i, j, -v[1], v[0])\n\t\tv = [-v[1], v[0]]\n\twhen wall?(i, j, *v)\n\twhen wall?(i, j, v[1], -v[0])\n\t\tv = [v[1], -v[0]]\n\telse\n\t\tv = [-v[0], -v[1]]\n\tend\n\ti += v[0]\n\tj += v[1]\n\tprint label[v]\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    @x.step(@height-3,2) do |index|\n      if @map[@y][index+1] == \"1\" && @map[@y][index+2] == \"1\"\n        @x += 2\n        @result << \"R\"\n      else\n        break\n      end\n    end\n    check_up_or_down\n  end\n\n  def walk_down\n    @y.step(@width-3,2) do |index|\n      if @map[index+1][@x] == \"1\" && @map[index+2][@x] == \"1\"\n        @y += 2\n        @result << \"D\"\n      end\n    end\n    check_right_or_left\n  end\n\n  def walk_left\n    @x.step(2,-2) do |index|\n      if @map[@y][index-1] == \"1\" && @map[@y][index-2] == \"1\"\n        @x -= 2\n        @result << \"L\"\n      else\n        break\n      end\n    end\n    check_up_or_down\n  end\n\n  def walk_up\n    @y.step(2,-2) do |index|\n      if @map[index-1][@x] == \"1\" && @map[index-2][@x] == \"1\"\n        @y -= 2\n        @result << \"U\"\n      end\n    end\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "Even, Odd = 0, 1\nR, D, L, U = (0...4).to_a\nLetter = [\"R\", \"D\", \"L\", \"U\"]\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\nhorizontalWall = Array.new(5+2) {Array.new(4+2, 0)}\nverticalWall = Array.new(4+2) {Array.new(5+2, 0)}\nhorizontalWall[1][1,4] = gets.chomp.chars.map(&:to_i)\nfor i in 1..4 do\n  verticalWall[i][1,5] = gets.chomp.chars.map(&:to_i)\n  horizontalWall[i+1][1,4] = gets.chomp.chars.map(&:to_i)\nend\n\nprint \"R\"\ny = 0\nx = 1\ndirection = R\nwhile true do\n  break if [y, x] == [1, 0] && direction == U\n  break if [y, x] == [1, 1] && direction == L\n  case direction\n    when R\n      if verticalWall[y][x+1] == 1\n        direction = (direction - 1) % 4\n      elsif horizontalWall[y+1][x+1] == 0\n        direction = (direction + 1) % 4\n        y += 1\n        x += 1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when L\n      if verticalWall[y][x] == 1\n        direction = (direction - 1) % 4\n      elsif horizontalWall[y][x-1] == 0\n        direction = (direction + 1) % 4\n        y += -1\n        x += -1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when D\n      if horizontalWall[y+1][x] == 1\n        direction = (direction - 1) % 4\n      elsif verticalWall[y+1][x] == 0\n        direction = (direction + 1) % 4\n        y += 1\n        x += -1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n    when U\n      if horizontalWall[y][x] == 1\n        direction = (direction - 1) % 4\n      elsif verticalWall[y-1][x+1] == 0\n        direction = (direction + 1) % 4\n        y += -1\n        x += 1\n      else\n        y += dy[direction]\n        x += dx[direction]\n      end\n  end\n  print Letter[direction]\nend\nputs \"\""
  },
  {
    "language": "Ruby",
    "code": "board = Array.new(6) { Array.new(6) { Array.new 4 } }\n9.times do |i|\n  ws = gets.chomp.each_char.map {|c| c == ?0 ? false : true }\n  if i % 2 == 0\n    ws.each_with_index do |w, j|\n      board[i/2][j+1][3] = board[i/2+1][j+1][1] = true if w\n    end\n  else\n    ws.each_with_index do |w, j|\n      board[i/2+1][j][0] = board[i/2+1][j+1][2] = true if w\n    end\n  end\nend\nx, y, d = 1, 0, 0\nuntil x == 0 && y == 1 && d == 2 || x == 0 && y == 0 && d == 1\n  if board[y][x][(d+3)%4]\n    if board[y][x][d]\n      print %w[R U L D][d]\n      d = (d + 1) % 4\n    else\n      dx, dy = [[1, 0], [0, -1], [-1, 0], [0, 1]][d]\n      x += dx\n      y += dy\n      print %w[R U L D][d]\n    end\n  else\n    d = (d - 1) % 4\n    dx, dy = [[1, 0], [0, -1], [-1, 0], [0, 1]][d]\n    x += dx\n    y += dy\n  end\nend\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n      $stderr.puts @map\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n      count += 1\n      break if count < 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "direcs = [[0, -1], [1, 0], [0, 1], [-1, 0]]\ndnames = %w(U R D L)\n\n### main\n\npl = []\nhorizontal = true\nln = 0\n\nwhile (line =gets)\n  nums = line.chop.split(\"\").map{|s| s.to_i}\n\n  if (horizontal)\n    if pl[ln].nil?\n      pl.push (nums.length + 1).times.map{[0, 0, 0, 0]}\n    end\n\n    for i in (0...nums.length)\n      pl[ln][i][1] = pl[ln][i + 1][3] = nums[i]\n    end\n  else\n    pl.push nums.length.times.map{[0, 0, 0, 0]}\n\n    for i in (0...nums.length)\n      pl[ln][i][2] = pl[ln + 1][i][0] = nums[i]\n    end\n\n    ln += 1\n  end\n\n  horizontal = ! horizontal\nend\n\nx = y = 0\ndir = 1\nrt = \"\"\n\nwhile true\n  dir = (dir + 3) % 4\n  while pl[y][x][dir] == 0\n    dir = (dir + 1) % 4\n  end\n\n  rt += dnames[dir]\n  x += direcs[dir][0]\n  y += direcs[dir][1]\n\n  if x == 0 && y == 0\n    break\n  end\nend\n\nputs rt"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      if count > 1000\n        s = \"\"\n        9.times do |n|\n          s += @map[n].to_s + \"\\n\"\n        end\n        #$stderr.puts s\n        break\n      end\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[@y-1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    @x.upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    @y.upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    @x.downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    @y.downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    @x.upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    @y.upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    @x.downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    @y.downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "c=[[[?0*6]]*2]\n5.times{|i|c<<[?0+gets[0,4]+?0,i<4?(?0+gets):?0*6]}\nx=2\ny=d=1\nr=?R\n[(t,u,d=[[0,0,1,-1,0,3],[1,1,0,0,-1,0],[0,0,0,1,0,1],[1,0,0,0,1,2]].rotate(d).find{|i,j,k|c[y-j][i][x-k]==?1}[3,3]),x+=t,y+=u,r+=\"URDL\"[d]]while x+y>2\nputs r"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n        pp @map\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      if count > 10000\n        s = \"\"\n        9.times do |n|\n          s += @map[n].to_s + \"\\n\"\n        end\n        $stderr.puts s\n      end\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n        pp @map\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      $stderr.puts @map if count > 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "$wall = $<.each_line.map(&:chomp)\ndef wall?(i, j, di, dj)\n\ti = i * 2 + di\n\tj += dj / 2\n\treturn false if i < 0 or 8 < i or j < 0\n\treturn $wall[i][j] == '1'\nend\n\nlabel = {\n\t[0, 1] => 'R',\n\t[1, 0] => 'D',\n\t[0, -1] => 'L',\n\t[-1, 0] => 'U',\n}\n\ni, j = v = [0, 1]\nprint 'R'\n\nuntil i.zero? and j.zero?\n\tcase\n\twhen wall?(i, j, -v[1], v[0])\n\t\tv = [-v[1], v[0]]\n\twhen wall?(i, j, *v)\n\twhen wall?(i, j, v[1], -v[0])\n\t\tv = [v[1], -v[0]]\n\telse\n\t\tv = [-v[0], -v[1]]\n\tend\n\ti += v[0]\n\tj += v[1]\n\tprint label[v]\nend\n\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    @x = 0\n    @y = 0\n    @width = 9\n    @height = 9\n    @direct = 0\n    @map = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @result = \"\"\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        count = 1\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        walk_map\n        results << @result\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0 && @direct == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    @x.upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    @y.upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    @x.downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    @y.downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "def solve(y, x, way)\n  if y==0&&x==0 then\n    print 'L'\n    return\n  end\n  if y==1&&x==0&&way==2 then\n    print 'U'\n    return\n  end\n  if way==1 then\n    print 'R'\n    if y>0&& $d[y-1][x+1]=='1' then\n      solve(y-1,x+1,2)\n    elsif x<4&& $d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    elsif y<8&& $d[y+1][x+1]=='1' then\n      solve(y+1,x+1,4)\n    elsif x>0&& $d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    end\n  elsif way==2 then\n    print 'U'\n    if x>0&& $d[y-1][x-1]=='1' then\n      solve(y-1,x-1,3)\n    elsif y>1&& $d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    elsif x<4&& $d[y-1][x]=='1' then\n      solve(y-1,x,1)\n    elsif y<7&& $d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    end\n  elsif way==3 then\n    print 'L'\n    if y<8&& $d[y+1][x]=='1' then\n      solve(y+1,x,4)\n    elsif x>0&& $d[y][x-1]=='1' then\n      solve(y,x-1,3)\n    elsif y>0&& $d[y-1][x]=='1' then\n      solve(y-1,x,2)\n    elsif x<4&& $d[y][x+1]=='1' then\n      solve(y,x+1,1)\n    end\n  elsif way==4 then\n    print 'D'\n    if x<4&& $d[y+1][x]=='1' then\n      solve(y+1,x,1)\n    elsif y<7&& $d[y+2][x]=='1' then\n      solve(y+2,x,4)\n    elsif x>0&& $d[y+1][x-1]=='1' then\n      solve(y+1,x-1,3)\n    elsif y>1&& $d[y-2][x]=='1' then\n      solve(y-2,x,2)\n    end\n  end\nend\n$d = Array.new(9)\n9.times do |i|\n  $d[i] = gets\nend\nprint 'R'\nsolve(0,1,1)"
  },
  {
    "language": "Ruby",
    "code": "dir = [\"U\", \"R\", \"D\", \"L\"]\nwall = [[0,0,0,0,0]]\n9.times do |i|\n  if i % 2 == 0\n    wall << (\"0\" + gets.chomp + \"0\").split(//).map(&:to_i)\n  else\n    wall << gets.chomp.split(//).map(&:to_i)\n  end\nend\nwall << [0,0,0,0,0]\nroute = []\nposition = Array.new(6){|i|Array.new(6)}\nt, y = 0, 0\nposition[t][y] = 1\nwhile t != 0 or y != 0 or route.size == 0\n  if position[t][y] % 2 == 0\n    if wall[2 * t + position[t][y] - 1][y] == 0\n      position[t + position[t][y] - 1][y] = (position[t][y] + 1) % 4\n      t += position[t][y] - 1\n    else\n      position[t][y] = (position[t][y] - 1) % 4\n      route << dir[position[t][y]]\n    end\n  else\n    if wall[2 * t][y + (3 - position[t][y]) / 2 - 1] == 0\n      position[t][y - position[t][y] + 2] = (position[t][y] + 1) % 4\n      y -= position[t][y] - 2\n    else\n      position[t][y] = (position[t][y] - 1) % 4\n      route << dir[position[t][y]]\n    end\n  end\nend\nputs route.join"
  },
  {
    "language": "Ruby",
    "code": "map = [[0]*7] + readlines.map{|l| [0] + l.chomp.chars.map(&:to_i) + [0] } + [[0]*7]\nx,y = 1,1\nleft = -1\npos = 1\nC = %w(U R D L)\nD = [[-1,0], [0,1], [1,0], [0,-1]]\nE = [-1, 0, 0, 0]\nd = 0\nloop do\n  if map[x+D[d].first][y+D[d].last*(d==1 ? 0 : 1)]==1\n    print C[d]\n    dx,dy = *D[d]\n    d = (d-1) % 4\n    pos = 1\n  elsif map[x+D[(d+1)%4].first][y+D[(d+1)%4].last + E[d]]==1\n    print C[(d+1)%4]\n    dx,dy = *D[(d+1)%4]\n  else\n    print C[(d+2)%4]\n    dx,dy = *D[(d+2)%4]\n    d = (d+1) % 4\n  end\n  x,y = x+dx*2,y+dy\n  break if [x,y]==[1,1]\nend\nputs"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    @result = \"\"\n    @x = 0\n    @y = 0\n    @direct = 0\n    @map = []\n    count = 0\n    while input = $stdin.gets do \n      if count % 2 == 0  \n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      else\n        @map << input.chomp.split('').join(\"0\").split('')\n      end\n      count += 1\n    end\n    @width = @map[0].size\n    @height = @map.size\n    walk_map\n\n    puts @result\n  end\n\n  def walk_map\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      @x = 0\n      @y = 0\n      @direct = 0\n      @result = \"\"\n      @map = []\n      count = 1\n      @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n      8.times do \n        if count % 2 == 0  \n          @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n        else\n          @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n        end\n        count += 1\n      end\n      @width = @map[0].size\n      @height = @map.size\n      walk_map\n      results << @result\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      $stderr.puts @map if count > 100000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Ruby",
    "code": "def move_right(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\tx += 1\n\t\trs << \"R\"\n\n\t\tif x < m[y].size then\n\t\t\tmove_right(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x] == 1 then\n\t\tmove_up(m, rs, x, y-1)\n\telse\n\t\tmove_down(m, rs, x, y+1)\n\tend\nend\n\ndef move_left(m, rs, x, y)\n\tif x == 0 && y == 0 then\n\t\trs << \"L\"\n\t\treturn\n\tend\n\n\tif m[y][x] == 1 then\n\t\tx -= 1\n\t\trs << \"L\"\n\n\t\tif x >= 0 then\n\t\t\tmove_left(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif y != 0 && m[y-1][x+1] == 1 then\n\t\tmove_up(m, rs, x+1, y-1)\n\telse\n\t\tmove_down(m, rs, x+1, y+1)\n\tend\nend\n\ndef move_down(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty += 2\n\t\trs << \"D\"\n\n\t\tif y < m.size then\n\t\t\tmove_down(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y-1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y-1)\n\telse\n\t\tmove_right(m, rs, x, y-1)\n\tend\nend\n\ndef move_up(m, rs, x, y)\n\tif m[y][x] == 1 then\n\t\ty -= 2\n\t\trs << \"U\"\n\n\t\tif y >= 0 then\n\t\t\tmove_up(m, rs, x, y)\n\t\t\treturn\n\t\tend\n\tend\n\n\tif x != 0 && m[y+1][x-1] == 1 then\n\t\tmove_left(m, rs, x-1, y+1)\n\telse\n\t\tmove_right(m, rs, x, y+1)\n\tend\nend\n\nm = []\n\n9.times {\n\tm.push gets.chomp.split('').map(&:to_i)\n}\n\nx = 0\ny = 0\nrs = \"\"\nmove_right(m, rs, x, y)\n\nputs rs"
  },
  {
    "language": "Ruby",
    "code": "d=2\nmap=*$<\no=?R\nx,y=1,0\n(u,v=1,1\n(d+=1\nu=x+[0,0,-1,0][d%4]\nv=y+[0,1,0,-1][d%4]\n)until u>=0&&v>=0&&v<9&&map[v][u]==?1\ne=d%4\nx+=[1,0,-1,0][e]\ny+=[0,2,0,-2][e]\no+=\"RDLU\"[e]\nd+=2\n)while [x,y]!=[0,0]\nputs o"
  },
  {
    "language": "Ruby",
    "code": "d=2\nmap=*$<\no=?R\nx,y=1,0\n(u,v=1,1\n(d+=1\nu=x+[0,0,-1,0][d%4]\nv=y+[0,1,0,-1][d%4]\n)until u>=0&&v>=0&&v<9&&map[v][u]==?1\ne=d%4\nx+=[1,0,-1,0][e]\ny+=[0,2,0,-2][e]\no+=\"RDLU\"[e]\nd+=2\n)while [x,y]!=[0,0]\nprint o"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nclass Grid\n  def initialize\n    results = []\n    while input = $stdin.gets do \n      if /\\d/ =~ input\n        @x = 0\n        @y = 0\n        @direct = 0\n        @result = \"\"\n        @map = []\n        count = 1\n        @map << [\"1\"] + input.chomp.split('').join(\"1\").split('') + [\"1\"]\n        8.times do \n          if count % 2 == 0  \n            @map << [\"1\"] + $stdin.gets.chomp.split('').join(\"1\").split('') + [\"1\"]\n          else\n            @map << $stdin.gets.chomp.split('').join(\"0\").split('')\n          end\n          count += 1\n        end\n        @width = @map[0].size\n        @height = @map.size\n        walk_map\n        results << @result\n        pp @map\n      end\n    end\n\n    results.each do |ans|\n      puts ans\n    end\n  end\n\n  def walk_map\n    count = 0\n    loop do\n      case @direct\n      when 0\n        walk_right\n      when 1\n        walk_down\n      when 2\n        walk_left\n      when 3\n        walk_up\n      end\n      break if @y == 0 && @x == 0\n      count += 1\n      raise pp @map if count > 10000\n    end\n  end\n\n  def check_up_or_down\n    case @direct\n    when 0\n      if @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      elsif @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      else\n        @direct = 2\n      end\n    when 2\n      if @y != @height-1 && @map[@y+1][@x] == \"1\"\n        @direct = 1\n      elsif @y != 0 && @map[@y-1][@x] == \"1\"\n        @direct = 3\n      else\n        @direct = 0\n      end\n    end\n  end\n\n  def check_right_or_left\n    case @direct\n    when 1\n      if @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      elsif @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      else\n        @direct = 3\n      end\n    when 3\n      if @x != 0 && @map[@y][@x-1] == \"1\"\n        @direct = 2\n      elsif @x != @width-1 && @map[@y][@x+1] == \"1\"\n        @direct = 0\n      else\n        @direct = 1\n      end\n    end\n  end\n\n  def walk_right\n    count = 0\n    (@x+1).upto(@width-1) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != 0 && @map[index][@y-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x += step*2 if step > 0\n    @result << \"R\"*step\n    check_up_or_down\n  end\n\n  def walk_down\n    count = 0\n    (@y+1).upto(@height-1) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != @width-1 && @map[index][@x+1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y += step*2 if step > 0\n    @result << \"D\"*step\n    check_right_or_left\n  end\n\n  def walk_left\n    count = 0\n    (@x-1).downto(0) do |index|\n      if @map[@y][index] == \"1\"\n        count += 1\n        if @y != @height-1 && @map[@y+1][index] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @x -= step*2 if step > 0\n    @result << \"L\"*step\n    check_up_or_down\n  end\n\n  def walk_up\n    count = 0\n    (@y-1).downto(0) do |index|\n      if @map[index][@x] == \"1\"\n        count += 1\n        if @x != 0 && @map[index][@x-1] == \"1\"\n          break\n        end\n      else\n        break\n      end\n    end\n    step = count/2\n    @y -= step*2 if step > 0\n    @result << \"U\"*step\n    check_right_or_left\n  end\nend\n\ng = Grid.new"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strings\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar points [5][5][4]bool\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc main() {\n\tfor i := 0; i < 9; i++ {\n\t\ty := i/2\n\t\tif i%2 == 0 {\n\t\t\tscanner.Scan()\n\t\t\tinfo := strings.Split(scanner.Text(), \"\")\n\t\t\tfor k := range info {\n\t\t\t\te, _ := strconv.Atoi(info[k])\n\t\t\t\tif e != 0 {\n\t\t\t\t\tpoints[y][k][1], points[y][k+1][3] = true, true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tscanner.Scan()\n\t\t\tinfo := strings.Split(scanner.Text(), \"\")\n\t\t\tfor k := range info {\n\t\t\t\te, _ := strconv.Atoi(info[k])\n\t\t\t\tif e != 0 {\n\t\t\t\t\tpoints[y][k][2], points[y+1][k][0] = true, true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tx := 1\n\ty := 0\n\tdir := 1\n\tdx := []int{0, 1, 0, -1}\n\tdy := []int{-1, 0, 1, 0}\n\tds := \"URDL\"\n\tfmt.Printf(\"%s\", string(ds[dir]))\n\tfor !(x == 0 && y == 0) {\n\t\tif points[y][x][(dir+3)%4] {\n\t\t\tdir = (dir+3)%4\n\t\t} else if points[y][x][dir] {\n\n\t\t} else if points[y][x][(dir+1)%4] {\n\t\t\tdir = (dir+1)%4\n\t\t} else {\n\t\t\tdir = (dir+2)%4\n\t\t}\n\t\tx += dx[dir]\n\t\ty += dy[dir]\n\t\tfmt.Printf(\"%s\", string(ds[dir]))\n\t}\n\tfmt.Println()\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $x = 2; $y = 1; $dir = 0;\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n echo 'R';\n  while(!($x==1 && $y==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($dir+$i)%4;\n      $d2 = ($d+3)%4;\n      if(($d==0 && $v[$y-1][$x]) || ($d==1 && $h[$y][$x])\n        || ($d==2 && $v[$y][$x]) || ($d==3 && $h[$y][$x-1])) {\n        $x += $stepx[$d2];\n        $y += $stepy[$d2];\n        $dir = $d2;\n        break;\n      }\n    }\n    echo DIRS[$dir];\n  }\n  echo PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  function param($dir,$l,$x,$y) {\n      switch($dir) {\n      case 'R':\n          return Array($x==4,$l[2*$y][$x], $l[2*$y-1][$x]?'U':'D',1,0);\n      case 'D':\n          return Array($y==4,$l[2*$y+1][$x],$l[2*$y][$x]?'R':'L',0,1);\n      case 'L':\n          return Array($x==0,$l[2*$y][$x-1],$l[2*$y+1][$x]?'D':'U',-1,0);\n      case 'U':\n          return Array($y==0,$l[2*$y-1][$x],$l[2*$y][$x-1]?'L':'R',0,-1);\n      }\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  $path = 'R';\n  $dir = 'R';\n  $x = 1;\n  $y = 0;\n\n  while(!($x==0 && $y==0)) {\n      list($a,$b,$d,$vx,$vy) = param($dir,$l,$x,$y);\n      if($a || !$b) {\n          $dir = $d;\n      } else {\n          $path .= $dir;\n          $x += $vx;\n          $y += $vy;\n      }\n  }\n\n  echo $path.\"\\n\";"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $x = 2; $y = 1; $dir = 0;\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  while(!($x==1 && $y==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($dir+$i)%4;\n      $d2 = ($d+3)%4;\n      if(($d==0 && $v[$y-1][$x]) || ($d==1 && $h[$y][$x])\n        || ($d==2 && $v[$y][$x]) || ($d==3 && $h[$y][$x-1])) {\n        $x += $stepx[$d2];\n        $y += $stepy[$d2];\n        $dir = $d2;\n        break;\n      }\n    }\n    echo DIRS[$dir];\n  }\n  echo PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = array('R','D','L','U');\n  $p = array(1,0,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0)\n  $stepy = array(0,1,0,-1)\n\n  function frontIsClear($x,$y,$d,$l) {\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($x,$y,$d,$l) {\n      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])\n          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);\n  }\n\n  function move(&$p,$stepx,$stepy) {\n      if($p[2] == 0 || $p[2] == 2)\n          $p[0] = $p[0] + $stepx[$p[2]];\n      else\n          $p[1] = $p[1] + $stepy[$p[2]];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p[0],$p[1],$p[2],$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p[0],$p[1],$p[2],$p[2],$l))\n              $p[2] = ($p[2]+1) % 4;\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$stepx,$stepy);\n       $path[] = DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $p = array(1,0,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  function frontIsClear($x,$y,$d,$l) {\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($x,$y,$d,$l) {\n      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])\n          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);\n  }\n\n  function move(&$p,$stepx,$stepy) {\n      if($p[2] == 0 || $p[2] == 2)\n          $p[0] = $p[0] + $stepx[$p[2]];\n      else\n          $p[1] = $p[1] + $stepy[$p[2]];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p[0],$p[1],$p[2],$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p[0],$p[1],$p[2],$l))\n              $p[2] = ($p[2]+1) % 4;\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$stepx,$stepy);\n       $path[] = DIRS[$p[2]];\n  }\n\n  echo implode('',$path).PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $x=2; $y=1; $dir=0; $p='R';\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  while(!($x==1 && $y==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($dir+$i)%4;\n      if(($d==0 && $v[$y-1][$x]) || ($d==1 && $h[$y][$x])\n        || ($d==2 && $v[$y][$x]) || ($d==3 && $h[$y][$x-1])) {\n        $d2 = ($d+3)%4;\n        $x += $stepx[$d2];\n        $y += $stepy[$d2];\n        $dir = $d2;\n        break;\n      }\n    }\n    $p.=DIRS[$dir];\n  }\n  echo $p.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $p = array(2,1,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  function check($x,$y,$j,$v,$h) {\n    return ($j==0 && $v[$y-1][$x]) || ($j==1 && $h[$y][$x]) ||\n      ($j==2 && $v[$y][$x]) || ($j==3 && $h[$y][$x-1]);\n  }\n\n  while(!($p[0]==1 && $p[1]==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($p[2]+$i)%4;\n      if(check($p[0],$p[1],$d,$v,$h)==1) {\n        $p[0] += $stepx[($d+3)%4];\n        $p[1] += $stepy[($d+3)%4];\n        $p[2] = ($d+3)%4;\n        break;\n      }\n    }\n    $path[] = DIRS[$p[2]];\n  }\n\n  echo implode('',$path).PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $x=2; $y=1; $dir=0; $p='R';\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  while(!($x==1 && $y==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($dir+$i+3)%4;\n      if(($d==3 && $v[$y-1][$x]) || ($d==0 && $h[$y][$x])\n        || ($d==1 && $v[$y][$x]) || ($d==2 && $h[$y][$x-1])) {\n        $x += $stepx[$d];\n        $y += $stepy[$d];\n        $dir = $d;\n        break;\n      }\n    }\n    $p.=DIRS[$dir];\n  }\n\n  echo $p.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $p = array(2,1,0);\n  $path = 'R';\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  while(!($p[0]==1 && $p[1]==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($p[2]+$i)%4;\n      $d2 = ($d+3)%4;\n      if(($d==0 && $v[$p[1]-1][$p[0]]) || ($d==1 && $h[$p[1]][$p[0]])\n        || ($d==2 && $v[$p[1]][$p[0]]) || ($d==3 && $h[$p[1]][$p[0]-1])) {\n        $p[0] += $stepx[$d2];\n        $p[1] += $stepy[$d2];\n        $p[2] = $d2;\n        break;\n      }\n    }\n    $path .= DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nini_set('display_errors', 1);\n$ud = array();\n$side = array();\n$direction = array('R', 'L', 'D', 'U');\n$cood = array(array(0, 1), array(0, -1), array(1, 0), array(-1, 0));\n$ud[] = str_split(rtrim(fgets(STDIN)));\nfor ($i = 0; $i < 4; $i++) {\n    $side[] = str_split(rtrim(fgets(STDIN)));\n    $ud[] = str_split(rtrim(fgets(STDIN)));\n}\n\n$field = array_fill(0, 5, array_fill(0, 5, array_fill(0, 4, 0)));\nfor ($i = 0; $i < 5; $i++) {\n    for ($j = 0; $j < 5; $j++) {\n        for ($k = 0; $k < 4; $k++) {\n            $field[$i][$j][$k] = $k;\n        }\n        if (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {\n            $field[$i][$j][0] = 3;\n        } elseif (!isset($ud[$i][$j]) || $ud[$i][$j] === '0') {\n            $field[$i][$j][0] = 2;\n        }\n        if (isset($side[$i][$j]) && $side[$i][$j] === '1') {\n            $field[$i][$j][1] = 2; \n        } elseif (!isset($ud[$i][$j - 1]) || $ud[$i][$j - 1] === '0') {\n            $field[$i][$j][1] = 3;\n        }\n        if (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {\n            $field[$i][$j][2] = 0;\n        } elseif (!isset($side[$i][$j]) || $side[$i][$j] === '0') {\n            $field[$i][$j][2] = 1;\n        }\n        if (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {\n            $field[$i][$j][3] = 1;\n        } elseif (!isset($side[$i - 1][$j]) || $side[$i - 1][$j] === '0') {\n            $field[$i][$j][3] = 0;\n        }\n    }\n}\n\n$p = array(0, 0);\n$d = 0;\n$trace = array();\nwhile (true) {\n    $trace[] = $direction[$d];\n    $p[0] += $cood[$d][0];\n    $p[1] += $cood[$d][1];\n    $d = $field[$p[0]][$p[1]][$d];\n    if ($p[0] === 0 && $p[1] === 0) {\n        break;\n    }\n}\n\necho implode('', $trace);\necho PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  function param($dir,$l,$x,$y) {\n      switch($dir) {\n      case 'R':\n          return Array($x==4,$l[2*$y][$x], $l[2*$y-1][$x]?'U':'D',1,0);\n      case 'D':\n          return Array($y==4,$l[2*$y+1][$x],$l[2*$y][$x]?'R':'L',0,1);\n      case 'L':\n          return Array($x==0,$l[2*$y][$x-1],$l[2*$y+1][$x]?'D':'U',-1,0);\n      case 'U':\n          return Array($y==0,$l[2*$y-1][$x],$l[2*$y][$x-1]?'L':'R',0,-1);\n      }\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  $path = 'R';\n  $dir = 'R';\n  $x = 1;\n  $y = 0;\n\n  while(!($x==0 && $y==0)) {\n      list($a,$b,$d,$vx,$vy) = param($dir,$l,$x,$y);\n      if($a || !$b) {\n          $dir = $d;\n      } else {\n          $path .= $dir;\n          $x += $vx;\n          $y += $vy;\n      }\n  }\n\n  echo $path.\"\\n\";"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $p = array(1,0,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  function frontIsClear($x,$y,$d,$l) {\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($x,$y,$d,$l) {\n      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])\n          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);\n  }\n\n  function move(&$p,$stepx,$stepy) {\n      if($p[2] == 0 || $p[2] == 2)\n          $p[0] = $p[0] + $stepx[$p[2]];\n      else\n          $p[1] = $p[1] + $stepy[$p[2]];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p[0],$p[1],$p[2],$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p[0],$p[1],$p[2],$l))\n              $p[2] = ($p[2]+1) % 4;\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$stepx,$stepy);\n       $path[] = DIRS[$p[2]];\n  }\n\n  echo implode('',$path).PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = array('R','D','L','U');\n  $p = array(1,0,0);\n  $path = 'R';\n  $step =  array(array(1,0), array(0,1), array(-1,0), array(0,-1));\n\n  function frontIsClear($p, $l) {\n      list($x,$y,$d) = $p;\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1))\n             || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n             || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1))\n             || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($p,$l) {\n      list($x,$y,$d) = $p;\n      switch($p[2]) {\n      case 0:\n          return $x!=4 && $l[2*$y][$x];\n      case 1:\n          return $y!=4 && $l[2*$y+1][$x];\n      case 2:\n          return $x!=0 && $l[2*$y][$x-1];\n      case 3:\n          return $y!=0 && $l[2*$y-1][$x];\n      }\n  }\n\n  function move(&$p,$step) {\n      $p[0] = $p[0] + $step[$p[2]][0];\n      $p[1] = $p[1] + $step[$p[2]][1];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p,$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p,$l)) {\n              $p[2] = ($p[2]+1) % 4;\n           }\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$step);\n       $path .= DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $p = array(2,1,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  function check($x,$y,$j,$v,$h) {\n    return ($j==0 && $v[$y-1][$x]) || ($j==1 && $h[$y][$x]) ||\n      ($j==2 && $v[$y][$x]) || ($j==3 && $h[$y][$x-1]);\n  }\n\n  while(!($p[0]==1 && $p[1]==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($p[2]+$i)%4;\n      if(check($p[0],$p[1],$d,$v,$h)==1) {\n        $p[0] += $stepx[($d+3)%4];\n        $p[1] += $stepy[($d+3)%4];\n        $p[2] = ($d+3)%4;\n        break;\n      }\n    }\n    $path[] = DIRS[$p[2]];\n  }\n\n  echo implode('',$path).PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = array('R','D','L','U');\n  $p = array(1,0,0);\n  $path = 'R';\n  $step =  array(array(1,0), array(0,1), array(-1,0), array(0,-1));\n\n  function frontIsClear($p, $l) {\n      list($x,$y,$d) = $p;\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1))\n             || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n             || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1))\n             || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($p,$l) {\n      list($x,$y,$d) = $p;\n      switch($p[2]) {\n      case 0:\n          return $x!=4 && $l[2*$y][$x];\n      case 1:\n          return $y!=4 && $l[2*$y+1][$x];\n      case 2:\n          return $x!=0 && $l[2*$y][$x-1];\n      case 3:\n          return $y!=0 && $l[2*$y-1][$x];\n      }\n  }\n\n  function move(&$p,$step) {\n      $p[0] = $p[0] + $step[$p[2]][0];\n      $p[1] = $p[1] + $step[$p[2]][1];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p,$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p,$l)) {\n              $p[2] = ($p[2]+1) % 4;\n           }\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$step);\n       $path .= DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $p = array(1,0,0);\n  $path = 'R';\n  $step1 =  (1,0,-1,0)\n  $step2 = (0,1,0,-1)\n\n  function frontIsClear($p, $l) {\n      list($x,$y,$d) = $p;\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1))\n             || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n             || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1))\n             || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($p,$l) {\n      list($x,$y,$d) = $p;\n      switch($p[2]) {\n      case 0:\n          return $x!=4 && $l[2*$y][$x];\n      case 1:\n          return $y!=4 && $l[2*$y+1][$x];\n      case 2:\n          return $x!=0 && $l[2*$y][$x-1];\n      case 3:\n          return $y!=0 && $l[2*$y-1][$x];\n      }\n  }\n\n  function move(&$p,$step1,$step2) {\n      $p[0] = $p[0] + $step1[0];\n      $p[1] = $p[1] + $step2[1];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p,$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p,$l)) {\n              $p[2] = ($p[2]+1) % 4;\n           }\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$step1,$step2);\n       $path .= DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nini_set('display_errors', 1);\n$ud = array();\n$side = array();\n$direction = array('R', 'L', 'D', 'U');\n$cood = array(array(0, 1), array(0, -1), array(1, 0), array(-1, 0));\n$ud[] = str_split(rtrim(fgets(STDIN)));\nfor ($i = 0; $i < 4; $i++) {\n    $side[] = str_split(rtrim(fgets(STDIN)));\n    $ud[] = str_split(rtrim(fgets(STDIN)));\n}\n\n$field = array_fill(0, 5, array_fill(0, 5, array_fill(0, 4, 0)));\nfor ($i = 0; $i < 5; $i++) {\n    for ($j = 0; $j < 5; $j++) {\n        if (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {\n            $field[$i][$j][0] = 3;\n        } elseif (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {\n            $field[$i][$j][0] = 0;\n        } elseif (isset($side[$i][$j]) && $side[$i][$j] === '1') {\n                $field[$i][$j][0] = 2;\n        } else {\n            $field[$i][$j][0] = 1;\n        }\n        if (isset($side[$i][$j]) && $side[$i][$j] === '1') {\n            $field[$i][$j][1] = 2;\n        } elseif (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {\n            $field[$i][$j][1] = 1;\n        } elseif (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {\n                $field[$i][$j][1] = 3;\n        } else {\n            $field[$i][$j][1] = 0;\n        }\n        if (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {\n            $field[$i][$j][2] = 0;\n        } elseif (isset($side[$i][$j]) && $side[$i][$j] === '1') {\n            $field[$i][$j][2] = 2;\n        } elseif (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {\n            $field[$i][$j][2] = 1;\n        } else {\n            $field[$i][$j][2] = 3;\n        }\n        if (isset($ud[$i][$j - 1]) && $ud[$i][$j - 1] === '1') {\n            $field[$i][$j][3] = 1;\n        } elseif (isset($side[$i - 1][$j]) && $side[$i - 1][$j] === '1') {\n            $field[$i][$j][3] = 3;\n        } elseif (isset($ud[$i][$j]) && $ud[$i][$j] === '1') {\n            $field[$i][$j][3] = 0;\n        } else {\n            $field[$i][$j][3] = 2;\n        }\n    }\n}\n\n$p = array(0, 0);\n$d = 0;\n$trace = array();\nwhile (true) {\n    $trace[] = $direction[$d];\n    $p[0] += $cood[$d][0];\n    $p[1] += $cood[$d][1];\n    $d = $field[$p[0]][$p[1]][$d];\n    if ($p[0] === 0 && $p[1] === 0) {\n        break;\n    }\n}\n\necho implode('', $trace);\necho PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $p = array(1,0,0);\n  $path = array('R');\n  $stepx =  array(1,0,-1,0)\n  $stepy = array(0,1,0,-1)\n\n  function frontIsClear($x,$y,$d,$l) {\n      return ($d == 0 && ($y>0 ? !$l[2*$y-1][$x] : 1)) || ($d == 1 && ($x<4 ? !$l[2*$y][$x] : 1))\n          || ($d == 2 && ($y<4 ? !$l[2*$y+1][$x] : 1)) || ($d == 3 && ($x>0 ? !$l[2*$y][$x-1] : 1));\n  }\n\n  function canMove($x,$y,$d,$l) {\n      return ($d==0 && $x!=4 && $l[2*$y][$x]) || ($d==1 && $y!=4 && $l[2*$y+1][$x])\n          || ($d==2 && $x!=0 && $l[2*$y][$x-1]) || ($d==3 && $y!=0 && $l[2*$y-1][$x]);\n  }\n\n  function move(&$p,$stepx,$stepy) {\n      if($p[2] == 0 || $p[2] == 2)\n          $p[0] = $p[0] + $stepx[$p[2]];\n      else\n          $p[1] = $p[1] + $stepy[$p[2]];\n  }\n\n  for($i=0;$i<9;$i++)\n      $l[] = trim(fgets(STDIN));\n\n  while(true) {\n       if(!frontIsClear($p[0],$p[1],$p[2],$l)){\n          $p[2] = ($p[2]+3) % 4;\n       } else {\n           while(!canMove($p[0],$p[1],$p[2],$p[2],$l))\n              $p[2] = ($p[2]+1) % 4;\n       }\n       if($p == array(0,0,0))\n           break;\n       move($p,$stepx,$stepy);\n       $path[] = DIRS[$p[2]];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "PHP",
    "code": "<?php\n  const DIRS = \"RDLU\";\n  $h[] = \"000000\";\n  $v[] = \"0000000\";\n  for($i=0;$i<4;$i++) {\n      $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n      $v[] = \"0\".trim(fgets(STDIN)).\"0\";\n  }\n  $h[] = \"0\".trim(fgets(STDIN)).\"0\";\n  $v[] = $v[0];\n  $h[] = $h[0];\n\n  $x = 2; $y = 1; $dir = 0;\n  $path = 'R';\n  $stepx =  array(1,0,-1,0);\n  $stepy = array(0,1,0,-1);\n\n  while(!($x==1 && $y==1)) {\n    for($i=0;$i<4;$i++) {\n      $d = ($dir+$i)%4;\n      $d2 = ($d+3)%4;\n      if(($d==0 && $v[$y-1][$x]) || ($d==1 && $h[$y][$x])\n        || ($d==2 && $v[$y][$x]) || ($d==3 && $h[$y][$x-1])) {\n        $x += $stepx[$d2];\n        $y += $stepy[$d2];\n        $dir = $d2;\n        break;\n      }\n    }\n    $path .= DIRS[$dir];\n  }\n\n  echo $path.PHP_EOL;"
  },
  {
    "language": "OCaml",
    "code": "type direction = N | E | W | S\n\ntype state = { dir : direction; pos : int * int }\n\nlet vert (x, y) = y * 5 + x\n\nlet has_edge grid ((x1, y1) as p1) ((x2, y2) as p2) =\n  let v1, v2 = (vert p1), (vert p2) in\n  try grid.(v1).(v2) with Invalid_argument _ -> false\n\nlet set_edge grid ((x1, y1) as p1) ((x2, y2) as p2) =\n  let v1, v2 = (vert p1), (vert p2) in\n  grid.(v1).(v2) <- true;\n  grid.(v2).(v1) <- true\n\nlet load_grid grid =\n  let rec loop i =\n    let line = read_line () in\n    for j = 0 to (String.length line) - 1 do\n      if line.[j] = '1' then\n        set_edge grid\n                 (j, i / 2)\n                 (if i mod 2 = 0 then (j + 1, i / 2) else (j, i / 2 + 1))\n    done;\n    loop (succ i)\n  in\n  try loop 0 with End_of_file -> ()\n\nlet rec forward grid { dir = d; pos = (x, y) as p } =\n  let has_edge_to = has_edge grid (x, y) in\n  match d with\n  | N -> if has_edge_to (x - 1, y) then\n           { dir = W; pos = (x - 1, y) }\n         else if has_edge_to (x, y - 1) then\n           { dir = d; pos = (x, y - 1) }\n         else\n           forward grid { dir = E; pos = p }\n  | E -> if has_edge_to (x, y - 1) then\n           { dir = N; pos = (x, y - 1) }\n         else if has_edge_to (x + 1, y) then\n           { dir = d; pos = (x + 1, y) }\n         else\n           forward grid { dir = S; pos = p }\n  | S -> if has_edge_to (x + 1, y) then\n           { dir = E; pos = (x + 1, y) }\n         else if has_edge_to (x, y + 1) then\n            { dir = d; pos = (x, y + 1) }\n         else\n           forward grid { dir = W; pos = p }\n  | W -> if has_edge_to (x, y + 1) then\n           { dir = S; pos = (x, y + 1) }\n         else if has_edge_to (x - 1, y) then\n           { dir = d; pos = (x - 1, y) }\n         else\n           forward grid { dir = N; pos = p }\n\nlet () =\n  let grid = Array.init 25 (fun _ -> Array.make 25 false) in\n  load_grid grid;\n  let rec loop s =\n    let s = forward grid s in\n    print_char\n      begin\n        match s.dir with\n        | N -> 'U'\n        | E -> 'R'\n        | S -> 'D'\n        | W -> 'L'\n      end;\n    if s.pos = (0, 0) then print_newline ()\n    else loop s\n  in\n  loop { dir = E; pos = (0, 0) }"
  },
  {
    "language": "OCaml",
    "code": "let walk path =\n  let (y_max, x_max) = (Array.length path.(0) + 1, (Array.length path)/2 + 1) in\n  let move (x,y) dir =\n          if dir = \"R\" then (x,y+1)\n          else if dir = \"L\" then (x,y-1)\n          else if dir = \"D\" then (x+1,y)\n          else (x-1, y)\n  in\n  let turn_right dir =\n          if dir = \"R\" then \"D\"\n          else if dir = \"D\" then \"L\"\n          else if dir = \"L\" then \"U\"\n          else \"R\"\n  in\n  let turn_left dir = turn_right dir |> turn_right |> turn_right\n  in\n  let right_is_clear (x,y) dir =\n      if dir = \"R\" && (y = y_max || path.(x*2).(y-1) = 0) then true\n      else if dir = \"L\" && (y = 0 || path.((x-1)*2).(y-1) = 0) then true\n      else if dir = \"D\" && (x = x_max || path.(x*2-1).(y-1) = 0) then true\n      else if dir = \"U\" && (x = 0 || path.(x*2-1).(y) = 0) then true\n      else false\n  in\n  let front_is_clear (x,y) dir =\n      right_is_clear (x,y) (turn_left dir)\n  in\n  let rec loop (x,y) dir turn =\n    if (x,y) = (0,0) then ()\n    else\n      begin\n        if (not turn) && right_is_clear (x,y) dir then\n          begin\n            let d = turn_right dir in\n            loop (x,y) d true\n          end\n        else if front_is_clear (x,y) dir then\n          begin\n            if not turn then print_string dir;\n            loop (move (x,y) dir) dir false\n          end\n        else begin\n            print_string dir;\n            let d = turn_left dir in\n            loop (x,y) d  false end\n        end\n  in\n  loop (move (0,0) \"R\") \"R\" false\n;;\n\nlet to_array s =\n  let n = String.length s in\n  Array.init n (fun x -> String.make 1 s.[x] |> int_of_string)\n;;\n\nlet () =\n  let a = Array.init 9 (fun x -> read_line () |> to_array) in\n  walk a;Printf.printf \"\\n\"\n;;"
  },
  {
    "language": "OCaml",
    "code": "type direction = N | E | W | S\n\ntype state = { dir : direction; pos : int * int }\n\nlet vert (x, y) = y * 5 + x\n\nlet has_edge grid ((x1, y1) as p1) ((x2, y2) as p2) =\n  let v1, v2 = (vert p1), (vert p2) in\n  try grid.(v1).(v2) with Invalid_argument _ -> false\n\nlet set_edge grid ((x1, y1) as p1) ((x2, y2) as p2) =\n  let v1, v2 = (vert p1), (vert p2) in\n  grid.(v1).(v2) <- true;\n  grid.(v2).(v1) <- true\n\nlet load_grid grid =\n  let rec loop i =\n    let line = read_line () in\n    for j = 0 to (String.length line) - 1 do\n      if line.[j] = '1' then\n        set_edge grid\n                 (j, i / 2)\n                 (if i mod 2 = 0 then (j + 1, i / 2) else (j, i / 2 + 1))\n    done;\n    loop (succ i)\n  in\n  try loop 0 with End_of_file -> ()\n\nlet rec forward grid { dir = d; pos = (x, y) as p } =\n  let has_edge_to = has_edge grid (x, y) in\n  match d with\n  | N -> if has_edge_to (x - 1, y) then\n           { dir = W; pos = (x - 1, y) }\n         else if has_edge_to (x, y - 1) then\n           { dir = d; pos = (x, y - 1) }\n         else\n           forward grid { dir = E; pos = p }\n  | E -> if has_edge_to (x, y - 1) then\n           { dir = N; pos = (x, y - 1) }\n         else if has_edge_to (x + 1, y) then\n           { dir = d; pos = (x + 1, y) }\n         else\n           forward grid { dir = S; pos = p }\n  | S -> if has_edge_to (x + 1, y) then\n           { dir = E; pos = (x + 1, y) }\n         else if has_edge_to (x, y + 1) then\n            { dir = d; pos = (x, y + 1) }\n         else\n           forward grid { dir = W; pos = p }\n  | W -> if has_edge_to (x, y + 1) then\n           { dir = S; pos = (x, y + 1) }\n         else if has_edge_to (x - 1, y) then\n           { dir = d; pos = (x - 1, y) }\n         else\n           forward grid { dir = N; pos = p }\n\nlet () =\n  let grid = Array.init 25 (fun _ -> Array.make 25 false) in\n  load_grid grid;\n  let rec loop s =\n    let s = forward grid s in\n    print_char\n      begin\n        match s.dir with\n        | N -> 'U'\n        | E -> 'R'\n        | S -> 'D'\n        | W -> 'L'\n      end;\n    if s.pos = (0, 0) then ()\n    else loop s\n  in\n  loop { dir = E; pos = (0, 0) }"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int UP    = 2;\nconst int DOWN  = 3;\n\nbool isKabe(char[9][6], int, int, int);\nint getLeft(int);\nint getRight(int);\nvoid move(int*, int*, int);\nvoid printDir(int);\n\n\nvoid main()\n{\n    char kabe[9][6];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln().chomp;\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(&x, &y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(char kabe[9][6], int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(int* x, int* y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv,std.string;\n\nvoid main(){\n    bool[9][9] m;\n    foreach(y;0..8){\n        string line=readln.chomp;\n        foreach(x,c;line){\n            m[y*2][1+x*2]=c=='1';\n        }\n        line=readln.chomp;\n        foreach(x,c;line){\n            m[y*2+1][x*2]=c=='1';\n        }\n    }\n    int x,y,dir=6;\n    while(true){\n        final switch(dir){\n            case 2:\n                if(x!=8&&m[y][x+1]){\n                    x+=2;\n                    dir=6;\n                }else if(y!=8&&m[y+1][x]){\n                    y+=2;\n                }else{\n                    x-=2;\n                    dir=4;\n                }\n                break;\n            case 4:\n                if(y!=8&&m[y+1][x]){\n                    y+=2;\n                    dir=2;\n                }else if(x!=0&&m[y][x-1]){\n                    x-=2;\n                }else{\n                    y-=2;\n                    dir=8;\n                }\n                break;\n            case 6:\n                if(y!=0&&m[y-1][x]){\n                    y-=2;\n                    dir=8;\n                }else if(x!=8&&m[y][x+1]){\n                    x+=2;\n                }else{\n                    y+=2;\n                    dir=2;\n                }\n                break;\n            case 8:\n                if(x!=0&&m[y][x-1]){\n                    x-=2;\n                    dir=4;\n                }else if(y!=0&&m[y-1][x]){\n                    y-=2;\n                }else{\n                    x+=2;\n                    dir=6;\n                }\n        }\n        final switch(dir){\n            case 2:'D'.write;break;\n            case 4:'L'.write;break;\n            case 6:'R'.write;break;\n            case 8:'U'.write;break;\n        }\n        if(!x&&!y)break;\n    }\n    writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,\n       std.string,\n       std.conv,\n       std.algorithm;\n\nvoid main() {\n    auto flag = true;\n    int[][] a, b;\n    while(!stdin.eof) {\n        auto input = readln.chomp;\n        if(input.length) {\n            auto arr = function int[](string s) {\n                    int[] ret;\n                    foreach(c; s) {\n                        ret ~= c.to!int - 48;\n                    }\n                    return ret;\n                }(input);\n            if(flag)\n                a ~= arr, flag = !flag;\n            else\n                b ~= arr, flag = !flag;\n        }\n    }\n\n    long h = b.length, w = a[0].length;\n    long x = 0, y = 0;\n    auto d = 'R';\n    while(1) {\n        switch(d) {\n            case 'R':\n                if(x < w && a[y][x])\n                    x++;\n                else if(y - 1 >= 0 && b[y - 1][x])\n                    y--, d = 'U';\n                else\n                    y++, d = 'D';\n                break;\n            case 'U':\n                if(y - 1 >= 0 && b[y - 1][x])\n                    y--;\n                else if(x - 1 >= 0 && a[y][x - 1])\n                    x--, d = 'L';\n                else\n                    x++, d = 'R';\n                break;\n            case 'L':\n                if(x - 1 >= 0 && a[y][x - 1])\n                    x--;\n                else if(y < h && b[y][x])\n                    y++, d = 'D';\n                else\n                    y--, d = 'U';\n                break;\n            case 'D':\n                if(y < h && b[y][x])\n                    y++;\n                else if(x < w && a[y][x])\n                    x++, d = 'R';\n                else\n                    x--, d = 'L';\n                break;\n            default:\n                return;\n        }\n        d.write;\n        if(x == 0 && y == 0)\n            break;\n    }\n    writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,\n       std.string,\n       std.conv,\n       std.algorithm;\n\nvoid main() {\n    auto flag = true;\n    int[][] a, b;\n    while(!stdin.eof) {\n        auto input = readln.chomp;\n        if(input.length) {\n            auto arr = function int[](string s) {\n                    int[] ret;\n                    foreach(c; s) {\n                        ret ~= c.to!int - 48;\n                    }\n                    return ret;\n                }(input);\n            if(flag)\n                a ~= arr, flag = !flag;\n            else\n                b ~= arr, flag = !flag;\n        }\n    }\n\n    long h = b.length, w = a[0].length;\n    long x = 0, y = 0;\n    auto d = 'R';\n    while(1) {\n        switch(d) {\n            case 'R':\n                if(y - 1 >= 0 && b[y - 1][x])\n                    y--, d = 'U';\n                else if(x < w && a[y][x]) {\n                    x++;\n                }\n                else if(y < h && b[y][x])\n                    y++, d = 'D';\n                else\n                    x--, d = 'L';\n                break;\n            case 'U':\n                if(x - 1 >= 0 && a[y][x - 1])\n                    x--, d = 'L';\n                else if(y - 1 >= 0 && b[y - 1][x])\n                    y--;\n                else if(x < w && a[y][x])\n                    x++, d = 'R';\n                else\n                    y++, d = 'D';\n                break;\n            case 'L':\n                if(y < h && b[y][x])\n                    y++, d = 'D';\n                else if(x - 1 >= 0 && a[y][x - 1])\n                    x--;\n                else if(y - 1 >= 0 && b[y - 1][x])\n                    y--, d = 'U';\n                else\n                    x++, d = 'R';\n                break;\n            case 'D':\n                if(x < w && a[y][x])\n                    x++, d = 'R';\n                else if(y < h && b[y][x])\n                    y++;\n                else if(x - 1 >= 0 && a[y][x - 1])\n                    x--, d = 'L';\n                else\n                    y--, d = 'U';\n                break;\n            default:\n                return;\n        }\n        d.write;\n        if(x == 0 && y == 0)\n            break;\n    }\n    writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv,std.string;\n\nvoid main(){\n    bool[9][9] m;\n    foreach(y;0..8){\n        string line=readln.chomp;\n        foreach(x,c;line){\n            m[y*2][1+x*2]=c=='1';\n        }\n        line=readln.chomp;\n        foreach(x,c;line){\n            m[y*2+1][x*2]=c=='1';\n        }\n    }\n    int x,y,dir=6;\n    while(true){\n        final switch(dir){\n            case 2:\n                if(x!=8&&m[y][x+1]){\n                    x+=2;\n                    dir=6;\n                }else if(y!=8&&m[y+1][x]){\n                    y+=2;\n                }else{\n                    dir=4;\n                }\n                break;\n            case 4:\n                if(y!=8&&m[y+1][x]){\n                    y+=2;\n                    dir=2;\n                }else if(x!=0&&m[y][x-1]){\n                    x-=2;\n                }else{\n                    dir=8;\n                }\n                break;\n            case 6:\n                if(y!=0&&m[y-1][x]){\n                    y-=2;\n                    dir=8;\n                }else if(x!=8&&m[y][x+1]){\n                    x+=2;\n                }else{\n                    dir=2;\n                }\n                break;\n            case 8:\n                if(x!=0&&m[y][x-1]){\n                    x-=2;\n                    dir=4;\n                }else if(y!=0&&m[y-1][x]){\n                    y-=2;\n                }else{\n                    dir=6;\n                }\n        }\n        final switch(dir){\n            case 2:'D'.write;break;\n            case 4:'L'.write;break;\n            case 6:'R'.write;break;\n            case 8:'U'.write;break;\n        }\n        if(!x&&!y)break;\n    }\n    writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv,std.string;\n\nvoid main(){\n    bool[9][9] m;\n    foreach(y;0..8){\n        foreach(x,c;readln.chomp){\n            m[y*2][1+x*2]=c=='1';\n        }\n        foreach(x,c;readln.chomp){\n            m[y*2+1][x*2]=c=='1';\n        }\n    }\n    int x,y,dir=6;\n    while(true){\n        final switch(dir){\n            case 2:\n                if(x!=8&&m[y][x+1]){\n                    x+=2;\n                    dir=6;\n                    dir.p;\n                }else if(y!=8&&m[y+1][x]){\n                    y+=2;\n                    dir.p;\n                }else{\n                    dir=4;\n                }\n                break;\n            case 4:\n                if(y!=8&&m[y+1][x]){\n                    y+=2;\n                    dir=2;\n                    dir.p;\n                }else if(x!=0&&m[y][x-1]){\n                    x-=2;\n                    dir.p;\n                }else{\n                    dir=8;\n                }\n                break;\n            case 6:\n                if(y!=0&&m[y-1][x]){\n                    y-=2;\n                    dir=8;\n                    dir.p;\n                }else if(x!=8&&m[y][x+1]){\n                    x+=2;\n                    dir.p;\n                }else{\n                    dir=2;\n                }\n                break;\n            case 8:\n                if(x!=0&&m[y][x-1]){\n                    x-=2;\n                    dir=4;\n                    dir.p;\n                }else if(y!=0&&m[y-1][x]){\n                    y-=2;\n                    dir.p;\n                }else{\n                    dir=6;\n                }\n        }\n        if(!x&&!y)break;\n    }\n    writeln;\n}\n\nvoid p(int dir){\n    final switch(dir){\n        case 2:'D'.write;break;\n        case 4:'L'.write;break;\n        case 6:'R'.write;break;\n        case 8:'U'.write;break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\nimport std.datetime;\n\nvoid main()\n{\n\tauto path = new int[][](5, 5);\n\tauto key = [' ', 'U', 'L', ' ', 'D', ' ', ' ', ' ', 'R'];\n\tauto dx = [0, 0, -1, 0, 0, 0, 0, 0, 1];\n\tauto dy = [0, -1, 0, 0, 1, 0, 0, 0, 0];\n\tforeach (i; 0..5) {\n\t\tauto x = readln.chomp;\n\t\tforeach (j, e; x) {\n\t\t\tif (e == '1') {\n\t\t\t\tpath[i][j] |= 8;\n\t\t\t\tpath[i][j+1] |= 2;\n\t\t\t}\n\t\t}\n\t\tif (i == 4) continue;\n\t\tauto y = readln.chomp;\n\t\tforeach (j, e; y) {\n\t\t\tif (e == '1') {\n\t\t\t\tpath[i][j] |= 4;\n\t\t\t\tpath[i+1][j] |= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint x = 1, \n\t\t\ty = 0, \n\t\t\tdir = 8;\n\twrite(\"R\");\n\twhile (x != 0 || y != 0) {\n\t\tauto d = dir << 1;\n\t\tif (d == 16) d = 1;\n\t\tif (path[y][x] & d) {\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\twrite(key[d]);\n\t\t\tdir = d;\n\t\t\tcontinue;\n\t\t}\n\t\td = dir;\n\t\tif (path[y][x] & d) {\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\twrite(key[d]);\n\t\t\tcontinue;\n\t\t}\n\t\td = dir >> 1;\n\t\tif (d == 0) d = 8;\n\t\tif (path[y][x] & d) {\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\twrite(key[d]);\n\t\t\tdir = d;\n\t\t\tcontinue;\n\t\t}\n\t\td = d >> 1;\n\t\tif (d == 0) d = 8;\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t\twrite(key[d]);\n\t\tdir = d; \n\t}\n\twriteln(\"\");\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst uint LEFT  = 0;\nconst uint RIGHT = 1;\nconst uint UP    = 2;\nconst uint DOWN  = 3;\n\nbool isKabe(char[9][6], int, int, int);\nint getLeft(int);\nint getRight(int);\nvoid move(int*, int*, int);\nvoid printDir(int);\n\n\nvoid main()\n{\n    char kabe[9][6];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln().chomp;\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(&x, &y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(char kabe[9][6], int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(int* x, int* y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\n\nconst int RIGHT = 6;\nconst int DOWN = 2;\nconst int LEFT = 4;\nconst int UP = 8;\n\nvoid main()\n{\n    bool[9][9] sq;\n    foreach (y; 0..8) {\n        foreach (x, c; readln.chomp) {\n            sq[y*2][1+x*2] = (c == '1');\n        }\n        foreach (x, c; readln.chomp) {\n            sq[y*2+1][x*2] = (c == '1');\n        }\n    }\n    int x, y, direction = RIGHT;\n\n    while (true) {\n        final switch(direction) {\n        case DOWN:\n            if (x != 8 && sq[y][x+1]) {\n                x += 2;\n                direction = RIGHT;\n                direction.p_alpha;\n            } else if (y != 8 && sq[y+1][x]) {\n                y += 2;\n                direction.p_alpha;\n            } else {\n                direction = DOWN;\n            }\n            break;\n        case LEFT:\n            if (y != 8 && sq[y+1][x]) {\n                y += 2;\n                direction = RIGHT;\n                direction.p_alpha;\n            } else if (x != 0 && sq[y][x-1]) {\n                x -= 2;\n                direction.p_alpha;\n            } else {\n                direction = UP;\n            }\n            break;\n        case RIGHT:\n            if (y != 0 && sq[y-1][x]) {\n                y -= 2;\n                direction = RIGHT;\n                direction.p_alpha;\n            } else if (x != 8 && sq[y][x+1]) {\n                x += 2;\n                direction.p_alpha;\n            } else {\n                direction = LEFT;\n            }\n            break;\n        case UP:\n            if (x != 0 && sq[y][x-1]) {\n                x -= 2;\n                direction = RIGHT;\n                direction.p_alpha;\n            } else if (y != 0 && sq[y-1][x]) {\n                y -= 2;\n                direction.p_alpha;\n            } else {\n                direction = RIGHT;\n            }\n            break;\n        }\n        if (!x && !y) break;\n    }\n    writeln;\n}\n\nvoid p_alpha(int dir) {\n    final switch(dir) {\n    case 2: 'D'.write; break;\n    case 4: 'L'.write; break;\n    case 6: 'R'.write; break;\n    case 8: 'U'.write; break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,\n       std.string,\n       std.conv,\n       std.algorithm;\n\nvoid main() {\n    auto flag = true;\n    int[][] a, b;\n    while(!stdin.eof) {\n        auto input = readln.chomp;\n        if(input.length) {\n            auto arr = function int[](string s) {\n                    int[] ret;\n                    foreach(c; s) {\n                        ret ~= c.to!int - 48;\n                    }\n                    return ret;\n                }(input);\n            if(flag)\n                a ~= arr, flag = !flag;\n            else\n                b ~= arr, flag = !flag;\n        }\n    }\n\n    long h = b.length, w = a[0].length;\n    long x = 0, y = 0;\n    auto d = 'R';\n    while(1) {\n        switch(d) {\n            case 'R':\n                if(y - 1 >= 0 && b[y - 1][x])\n                    y--, d = 'U';\n                else if(x < w && a[y][x]) {\n                    x++;\n                }\n                else\n                    y++, d = 'D';\n                break;\n            case 'U':\n                if(x - 1 >= 0 && a[y][x - 1])\n                    x--, d = 'L';\n                else if(y - 1 >= 0 && b[y - 1][x])\n                    y--;\n                else\n                    x++, d = 'R';\n                break;\n            case 'L':\n                if(y < h && b[y][x])\n                    y++, d = 'D';\n                else if(x - 1 >= 0 && a[y][x - 1])\n                    x--;\n                else\n                    y--, d = 'U';\n                break;\n            case 'D':\n                if(x < w && a[y][x])\n                    x++, d = 'R';\n                else if(y < h && b[y][x])\n                    y++;\n                else\n                    x--, d = 'L';\n                break;\n            default:\n                return;\n        }\n        d.write;\n        if(x == 0 && y == 0)\n            break;\n    }\n    writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.array, std.algorithm, std.range;\n\nvoid main()\n{\n    bool[4][5][5] m;\n    foreach(i;0..9)\n        foreach(j,b;readln().chomp().map!\"a!='0'\"().array())\n            if(b)\n                foreach(k;0..2)\n                    m[i/2+k*(i%2)][j+k*(1-i%2)][k*2+i%2]=true;\n    string r;\n    int x=0,y=0,d=0;\n    do{\n        foreach(i;-1..2)\n        {\n            auto n = (d+i+4)%4;\n            if(m[y][x][n])\n            {\n                x += [1,0,-1,0][n];\n                y += [0,1,0,-1][n];\n                d=n;\n                r~=\"RDLU\"[n];\n                break;\n            }\n        }\n    }while(x!=0 || y!=0);\n    writeln(r);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst uint LEFT  = 0;\nconst uint RIGHT = 1;\nconst uint UP    = 2;\nconst uint DOWN  = 3;\n\nbool isKabe(char[9][6], int, int, int);\nint getLeft(int);\nint getRight(int);\nvoid move(ref int, ref int, const int);\nvoid printDir(int);\n\n\nvoid main()\n{\n    char kabe[9][6];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln();\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(x, y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(x, y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(char kabe[9][6], int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(ref int x, ref int y, const int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst uint LEFT  = 0;\nconst uint RIGHT = 1;\nconst uint UP    = 2;\nconst uint DOWN  = 3;\n\nbool isKabe(char[9][6], int, int, int);\nint getLeft(int);\nint getRight(int);\nvoid move(ref int, ref int, const int);\nvoid printDir(int);\n\n\nvoid main()\n{\n    char kabe[9][6];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln();\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(x, y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(char kabe[9][6], int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(ref int x, ref int y, const int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int UP    = 2;\nconst int DOWN  = 3;\n\n\nvoid main()\n{\n    string kabe[9];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln().chomp;\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(&x, &y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(string[9] kabe, int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(int* x, int* y, int dir)\n{\n    writeln(\"move\");\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\n/+\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int UP    = 2;\nconst int DOWN  = 3;\n+/\nenum {\n    LEFT,\n    RIGHT,\n    UP,\n    DOWN\n}\n\n\nvoid main()\n{\n    string[9] kabe;\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9) {\n        kabe[i] = readln().chomp;\n        kabe[i].length = 18;\n    }\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (isKabe(kabe, x, y, direction))\n            {}\n        else if (isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(&x, &y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(string[9] kabe, int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x >= 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y >= 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return 0;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return 0;\n}\n\nvoid move(int* x, int* y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        (*x)--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        (*x)++;\n        write(\"R\");\n        break;\n    case UP:\n        (*y)--;\n        write(\"U\");\n        break;\n    case DOWN:\n        (*y)++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.array, std.algorithm, std.range;\n\nvoid main()\n{\n    bool[4][5][5] m;\n    foreach(i;0..9)\n        foreach(j,b;readln().chomp().map!\"a!='0'\"().array())\n            if(b)\n                foreach(k;0..2)\n                    m[i/2+k*(i%2)][j+k*(1-i%2)][k*2+i%2]=true;\n    string r;\n    int x=0,y=0,d=0;\n    do{\n        foreach(i;-1..3)\n        {\n            auto n = (d+i+4)%4;\n            if(m[y][x][n])\n            {\n                x += [1,0,-1,0][n];\n                y += [0,1,0,-1][n];\n                d=n;\n                r~=\"RDLU\"[n];\n                break;\n            }\n        }\n    }while(x!=0 || y!=0);\n    writeln(r);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\n\nconst int LEFT  = 0;\nconst int RIGHT = 1;\nconst int UP    = 2;\nconst int DOWN  = 3;\n\nbool isKabe(string[9], int, int, int);\nint getLeft(int);\nint getRight(int);\nvoid move(int*, int*, int);\nvoid printDir(int);\n\n\nvoid main()\n{\n    string kabe[9];\n    int x, y;\n    int direction;\n\n    foreach (i; 0..9)\n        kabe[i] = readln().chomp;\n    x = 0;\n    y = 0;\n    direction = RIGHT;\n    move(&x, &y, direction);\n    while (x != 0 || y != 0) {\n        if (isKabe(kabe, x, y, getLeft(direction)))\n            direction = getLeft(direction);\n        else if (!isKabe(kabe, x, y, direction) &&\n                 isKabe(kabe, x, y, getRight(direction)))\n            direction = getRight(direction);\n        else\n            direction = getRight(getRight(direction));\n        move(&x, &y, direction);\n    }\n    writeln();\n}\n\n\nbool isKabe(string[9] kabe, int x, int y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        if (x <= 0) return false;\n        return (kabe[y*2][x-1] == '1');\n        break;\n    case RIGHT:\n        if (x > 4) return false;\n        return (kabe[y*2][x] == '1');\n        break;\n    case UP:\n        if (y <= 0) return false;\n        return (kabe[y*2-1][x] == '1');\n        break;\n    case DOWN:\n        if (y > 4) return false;\n        return (kabe[y*2+1][x] == '1');\n        break;\n    }\n    return false;\n}\n\n\nint getLeft(int dir)\n{\n    final switch (dir) {\n    case LEFT: return DOWN; break;\n    case RIGHT: return UP; break;\n    case UP: return LEFT; break;\n    case DOWN: return RIGHT; break;\n    }\n    return -1;\n}\n\n\nint getRight(int dir)\n{\n    final switch (dir) {\n    case LEFT: return UP; break;\n    case RIGHT: return DOWN; break;\n    case UP: return RIGHT; break;\n    case DOWN: return LEFT; break;\n    }\n    return -1;\n}\n\nvoid move(int* x, int* y, int dir)\n{\n    final switch (dir) {\n    case LEFT:\n        x--;\n        write(\"L\");\n        break;\n    case RIGHT:\n        x++;\n        write(\"R\");\n        break;\n    case UP:\n        y--;\n        write(\"U\");\n        break;\n    case DOWN:\n        y++;\n        write(\"D\");\n        break;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if mapp[position[tate]][position[yoko]] == 0:\n        return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print ''.join(result)\n        return True\n    elif mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return True\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return True\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n\nif __name__ == '__main__':\n    mapp = []\n    for i in range(9):\n        mapp.append([int(char) for char in raw_input()])\n    tate = 0\n    yoko = 1\n    result = []\n    xxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "import sys\nn = [input() for i in range(9)]\npath = [[0 for i in range(5)] for j in range(5)]\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 == 0]):\n    for j in range(4):\n        if v[j] == '1':\n            path[i][j] += 1\n            path[i][j+1] += 2\n\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 != 0]):\n    for j in range(5):\n        if v[j] == '1':\n            path[i][j] += 4\n            path[i+1][j] += 8\n\ndur = {'R':(1, 0, 1),\n       'L':(2, 0, -1),\n       'U':(8, -1, 0),\n       'D':(4, 1, 0)}\n\ndur_next = {'R':('U','R','D','L'),\n            'L':('D','L','U','R'),\n            'U':('L','U','R','D'),\n            'D':('R','D','L','U')}\ndef walk():\n    global cx, cy\n    cx = dur[d][2] + cx\n    cy = dur[d][1] + cy\n\ndef next_D():\n    global cx,cy,d,dur\n    for nd in dur_next[d]:\n        if path[cy][cx] & dur[nd][0]:\n            d = nd\n            break\n\ncx = cy = 0\nd = 'R'\nlog = []\n\nwhile 1:\n    log.append(d)\n    walk()\n    if cx == cy == 0:\n        break\n\n    next_D()\n\nprint(''.join(log))"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    z=[]\n    try:\n        while True:\n            z.append(raw_input())\n    except: return z\n\ndef nextpath(p,dir0):\n    for e in [3,0,1,2]:\n        d = (dir0+e)%4\n        if ispath(p,d): return d\n    return None\n\ndef ispath(p,d):\n    y,x = p\n    f=\"0\"\n    try:\n        if   d==0: f = wy[y-1][x]\n        elif d==1: f = wx[y][x]\n        elif d==2: f = wy[y][x]\n        elif d==3: f = wx[y][x-1]\n    except: pass\n    return f==\"1\"\n\ndef f0037():\n    p =[0,0]\n    dp = 1\n    msg = []\n    while True:\n        dp = nextpath(p, dp)\n        p[0]+=[-1,0,1,0][dp]\n        p[1]+=[0,1,0,-1][dp]\n        msg.append(\"URDL\"[dp])\n        if p==[0,0]: break\n    return \"\".join(msg)\n\nz = readdata()\nwx = z[0::2]\nwy = z[1::2]\nprint f0037()"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na='1'\nwhile 1:\n k=k%4+2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=str(k%4);break\n if k%2:x+=[1,-1][(k%4)>1]\n else:y+=[-1,1][(k%4)>0]\n if x+y==0:break\nprint(''.join('URDL'[int(c)]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na=[1]\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=[k%4];break\n if k%2:x+=[1,-1][(k%4)>1]\n else:y+=[-1,1][(k%4)>0]\n if x+y==0:break\nprint(''.join('URDL'[c]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "def go(human): #1:left,2:pro,3:right,4;back\n    if human[2]==0: #human's direction is east\n        if(human[1]*2-1>=0 and wall[human[1]*2-1][human[0]]=='1'):\n            return 3\n        elif (human[0]<=3 and wall[human[1]*2][human[0]]=='1'):\n            return 0\n        elif (human[1]*2+1<=8 and wall[human[1]*2+1][human[0]]=='1'):\n            return 1\n        else:\n            return 2\n    if human[2]==1: #south\n        if(human[0]<=3 and wall[human[1]*2][human[0]]=='1'):\n            return 3\n        elif (human[1]*2+1<=8 and wall[human[1]*2+1][human[0]]=='1'):\n            return 0\n        elif (human[0]-1>=0 and wall[human[1]*2][human[0]-1]=='1'):\n            return 1\n        else:\n            return 2\n    if human[2]==2: #west\n        if(human[1]*2+1<=8 and wall[human[1]*2+1][human[0]]=='1'):\n            return 3\n        elif (human[0]-1>=0 and wall[human[1]*2][human[0]-1]=='1'):\n            return 0\n        elif (human[1]*2-1>=0 and wall[human[1]*2-1][human[0]]=='1'):\n            return 1\n        else:\n            return 2\n    if human[2]==3: #north\n        if(human[0]-1>=0 and wall[human[1]*2][human[0]-1]=='1'):\n            return 3\n        elif (human[1]*2-1>=0 and wall[human[1]*2-1][human[0]]=='1'):\n            return 0\n        elif (human[0]<=3 and wall[human[1]*2][human[0]]=='1'):\n            return 1\n        else:\n            return 2\n\n        # if human[2]==0:\n        #     if(wall[0][human[0]]==1):\n        #         return 2\n        #     elif(wall[1][human[0]]==1):\n        #         return 3\n        #     else:\n        #         return 4\n        # elif human[2]==8:\n        #     if (wall[7][human[0]]==1):\n        #         return 2\n        #     elif()\nwall=[]\nwhile True:\n    try:\n        for i in range(9):\n            wall.append(raw_input())\n    except:\n        break\n\nsolve=\"R\"\nhuman=(1,0,0)\nwhile human[0]!=0 or human[1]!=0:\n    direction=(human[2]+go(human))%4\n    if direction == 0:\n        human=(human[0]+1,human[1],direction)\n        solve+=\"R\"\n    elif direction == 1:\n        human=(human[0],human[1]+1,direction)\n        solve+=\"D\"\n    elif direction == 2:\n        human=(human[0]-1,human[1],direction)\n        solve+=\"L\"\n    else:\n        human=(human[0],human[1]-1,direction)\n        solve+=\"U\"\nprint solve"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print ''.join(result)\n        return True\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return True\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return True\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n\nwhile True:\n    try:      \n        mapp = []\n        for i in range(9):\n            mapp.append([int(char) for char in raw_input()])\n        tate = 0\n        yoko = 1\n        result = []\n        xxx((0,0), 'R')\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    z=[]\n    try:\n        while True:\n            z.append(raw_input())\n    except: return z\n\ndef nextpath(p, dir0):\n    for e in [3,0,1,2]:\n        dp = ispath(p, (dir0+e)%4)\n        if dp!=[]: break\n    return dp\n\ndef ispath(p, dir1):\n    y,x = p\n    dp = []\n    if   dir1==0 and y>0            and wy[y-1][x]==\"1\": dp= 0\n    elif dir1==1 and x<len(wx[0])   and wx[y][x]  ==\"1\": dp = 1\n    elif dir1==2 and y<len(wy[0])-1 and wy[y][x]  ==\"1\": dp = 2\n    elif dir1==3 and x>0            and wx[y][x-1]==\"1\": dp = 3\n    return dp\n\ndef f0037():\n    p =[0,0]\n    dp = 1\n    msg = []\n    while True:\n        dp = nextpath(p, dp)\n        p[0]+=[-1,0,1,0][dp]\n        p[1]+=[0,1,0,-1][dp]\n        msg.append(\"URDL\"[dp])\n        if p==[0,0]: break \n    return msg\n\nz = readdata()\nwx = z[0::2]\nwy = z[1::2]\nmsg = f0037()    \nprint \"\".join(msg)"
  },
  {
    "language": "Python",
    "code": "import sys\ngrid=[line.strip() for line in sys.stdin.readlines()]\nxgrid=[\"0\"+grid[i]+\"0\" for i in xrange(9) if i%2==0]\nygrid=[grid[i] for i in xrange(9) if i%2==1]\nygrid.insert(5,\"0\"*5)\nygrid.insert(0,\"0\"*5)\ngraph=[[None]*5 for i in xrange(5)]\n#0->north 1->east...\nfor y in xrange(5):\n    for x in xrange(5):\n        graph[y][x]=[ygrid[y][x],xgrid[y][x+1],ygrid[y+1][x],xgrid[y][x]]\n\n#right hand ->dir+1\nnx,ny,dir=0,0,1\nDIRECTION=[\"U\",\"R\",\"D\",\"L\",]\ndx=[0,1,0,-1]\ndy=[-1,0,1,0]\nlog=[]\nwhile True:\n    for i in xrange(4):\n        if graph[ny][nx][(dir+1)%4]==\"1\":\n            dir=(dir+1)%4\n            log.append(DIRECTION[dir])\n            nx,ny=nx+dx[dir],ny+dy[dir]\n            break\n        dir=(dir-1)%4\n    if nx==0 and ny==0:break\nprint \"\".join(log)"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "import sys\nn = [input() for i in range(9)]\npath = [[0 for i in range(5)] for j in range(5)]\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 == 0]):\n    for j in range(4):\n        if v[j] == '1':\n            path[i][j] += 1\n            path[i][j+1] += 2\n\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 != 0]):\n    for j in range(5):\n        if v[j] == '1':\n            path[i][j] += 4\n            path[i+1][j] += 8\n\ndur = {'R':(1, 0, 1),\n       'L':(2, 0, -1),\n       'U':(8, -1, 0),\n       'D':(4, 1, 0)}\n\ndur_next = {'R':('U','R','D'),\n            'L':('D','L','U'),\n            'U':('L','U','R'),\n            'D':('R','D','L')}\ndef walk():\n    global cx, cy\n    cx = dur[d][2] + cx\n    cy = dur[d][1] + cy\n\ndef next_D():\n    global cx,cy,d,dur\n    for nd in dur_next[d]:\n        if path[cy][cx] & dur[nd][0]:\n            d = nd\n            break\n\ncx = cy = 0\nd = 'R'\nlog = []\n\nwhile 1:\n    log.append(d)\n    walk()\n    if cx == cy == 0:\n        break\n\n    next_D()\n\nprint(''.join(log))"
  },
  {
    "language": "Python",
    "code": "import sys\ngrid=[line.strip() for line in sys.stdin.readlines()]\nxgrid=[\"0\"+grid[i]+\"0\" for i in xrange(9) if i%2==0]\nygrid=[grid[i] for i in xrange(9) if i%2==1]\nygrid.insert(5,\"0\"*5)\nygrid.insert(0,\"0\"*5)\ngraph=[[None]*5 for i in xrange(5)]\nfor y in xrange(5):\n    for x in xrange(5):\n        graph[y][x]=[ygrid[y][x],xgrid[y][x+1],ygrid[y+1][x],xgrid[y][x]]\nnx,ny,dir=0,0,1\ndi=[\"U\",\"R\",\"D\",\"L\",]\ndx=[0,1,0,-1]\ndy=[-1,0,1,0]\nlog=[]\nwhile True:\n    for i in xrange(4):\n        if graph[ny][nx][(dir+3)%4]==\"1\":\n            dir=(dir+3)%4\n            log.append(di[dir])\n            nx,ny=nx+dx[dir],ny+dy[dir]\n            break\n        dir=(dir+1)%4\n    if nx==0 and ny==0:break\nprint \"\".join(log)"
  },
  {
    "language": "Python",
    "code": "# AOJ 0037: Path on a Grid\n# Python3 2018.6.27 bal4u\n\nnext = [[1,2,4,8],[4,8,1,2],[8,1,2,4],[2,4,8,1]]\ntbl = [[0 for c in range(5)] for r in range(5)]\n\ndef move(k):\n\tglobal r, c, last, ans\n\tif k == 1:\n\t\tr -= 1\n\t\tlast = 2\n\t\tans += 'U'\n\telif k == 2:\n\t\tc += 1\n\t\tlast = 0\n\t\tans += 'R'\n\telif k == 4:\n\t\tr += 1\n\t\tlast = 3\n\t\tans += 'D'\n\telse:\n\t\tc -= 1\n\t\tlast = 1\n\t\tans += 'L'\n\nfor i in range(9):\n\ta = input()\n\tr = i >> 1\n\tif i & 1:\n\t\tfor c in range(5):\n\t\t\tif a[c] == '1':\n\t\t\t\ttbl[r  ][c] |= 4\n\t\t\t\ttbl[r+1][c] |= 1\n\telse:\n\t\tfor c in range(4):\n\t\t\tif a[c] == '1':\n\t\t\t\ttbl[r][c  ] |= 2\n\t\t\t\ttbl[r][c+1] |= 8\n\nans = \"\"\nr, c, last = 0, 0, 0\nwhile True:\n\tfor i in range(4):\n\t\tif tbl[r][c] & next[last][i]:\n\t\t\tmove(next[last][i])\n\t\t\tbreak;\n\tif r == 0 and c == 0: break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "dist = ['D','L','U','R']\ndict = [(0,1),(1,0),(0,-1),(-1,0)]\n\nresult = ''\nsell = [[False]*13]*2\nfor i in xrange(9):\n    l = [False,False]\n    s = raw_input()\n    if len(s) == 4:\n        for j in s:\n            l.append(False)\n            l.append(bool(int(j)))\n        l += [False] * 3\n    else:\n        for j in s:\n            l.append(bool(int(j)))\n            l.append(False)\n        l += [False] * 2\n    sell.append(l)\nsell += [[False]*13]*2\n\nmy = (2,2,0)\n\nwhile(True):\n    if sell[my[0]+dict[my[2]][0]][my[1]+dict[my[2]][1]]:\n        my = (my[0]+dict[my[2]][0]*2,my[1]+dict[my[2]][1]*2,my[2])\n        result += dist[my[2]]\n        if my[0] == 2 and my[1] == 2:\n            break\n        else:\n            my = (my[0],my[1],(my[2]-1)%4)\n    else:\n        my = (my[0],my[1],(my[2]+1)%4)\n\nprint result"
  },
  {
    "language": "Python",
    "code": "def move(position):\n    x = position[0]\n    y = position[1]\n    d = position[2]\n    if d == \"L\":\n        p = \"DLUR\"\n    elif d == \"R\":\n        p = \"URDL\"\n    elif d == \"U\":\n        p = \"LURD\"\n    else:\n        p = \"RDLU\"\n    for i in range(4):\n        if p[i] in grid[y][x]:\n            d = p[i]\n            if d == \"L\":\n                print(\"L\",end=\"\")\n                x -= 1\n                break\n            elif d == \"R\":\n                print(\"R\",end=\"\")\n                x += 1\n                break\n            elif d == \"U\":\n                print(\"U\",end=\"\")\n                y -= 1\n                break\n            else:\n                print(\"D\",end=\"\")\n                y += 1\n                break\n    return [x, y, d]\n\npos = [1,1,\"R\"]\ngrid = [[\"\" for i in range(6)] for j in range(6)]\nfor i in range(9):\n    inp = input()\n    if i%2 == 0:\n        for j in range(4):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"R\"\n                grid[i//2 + 1][j + 2] += \"L\"\n    else:\n        for j in range(5):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"D\"\n                grid[i//2 + 2][j + 1] += \"U\"\nprint(*grid,sep=\"\\n\")\nwhile True:\n    pos = move(pos)\n    if pos[0] == 1 and pos[1] == 1:\n        break\n\n"
  },
  {
    "language": "Python",
    "code": "k = [[1,2,4,8],[4,8,1,2],[8,1,2,4],[2,4,8,1]]\nm = [[0]*5 for _ in range(5)]\n\nfor i in range(9):\n    a = input()\n    if i%2:\n        for j in range(5):\n            if a[j] == '1':\n                m[i//2][j] |= 4\n                m[i//2+1][j] |= 1\n    else:\n        for j in range(4):\n            if a[j] == '1':\n                m[i//2][j] |= 2\n                m[i//2][j+1] |= 8\ny,x,direct = 0,0,0\nans = []\nwhile True:\n    for i in range(4):\n        if m[y][x] & k[direct][i]:\n            d = k[direct][i]\n            if   d == 1: y -= 1; direct = 2\n            elif d == 2: x += 1; direct = 0\n            elif d == 4: y += 1; direct = 3\n            else       : x -= 1; direct = 1\n            ans.append(direct)\n            break\n    if not ( x or y ): break\nprint(\"\".join(\"RLUD\"[e] for e in ans))\n"
  },
  {
    "language": "Python",
    "code": "dist = ['D','L','U','R']\ndict = [(0,1),(1,0),(0,-1),(-1,0)]\n\nresult = ''\nsell = [[False]*13]*2\nfor i in xrange(9):\n    l = [False,False]\n    s = raw_input()\n    if len(s) == 4:\n        for j in s:\n            l.append(False)\n            l.append(bool(int(j)))\n        l += [False] * 3\n    else:\n        for j in s:\n            l.append(bool(int(j)))\n            l.append(False)\n        l += [False] * 2\n    sell.append(l)\nsell += [[False]*13]*2\n\nmy = (2,2,0)\n\nwhile(True):\n    if sell[my[0]+dict[my[2]][0]][my[1]+dict[my[2]][1]]:\n        my = (my[0]+dict[my[2]][0]*2,my[1]+dict[my[2]][1]*2,my[2])\n        if my[0] == 2 and my[1] == 2:\n            break\n        else:\n            my = (my[0],my[1],(my[2]-1)%4)\n            result += dist[my[2]]\n    else:\n        my = (my[0],my[1],(my[2]+1)%4)\n\nprint result"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\nclass Grid:\n    def __init__(self, lines):\n        lines = map((lambda line: list(line)), lines)\n        l = []\n        for i in range(len(lines)):\n            if i % 2 == 0:\n                l.append(intersperse2(lines[i], '+'))\n            else:\n                l.append(intersperse(lines[i], 'x'))\n        l.insert(0, ['0','x','0','x','0','x','0','x','0'])\n        l.append(['0','x','0','x','0','x','0','x','0'])\n        l = map(lambda x: self._outer(x), l)\n        self.grid = l\n\n    def show(self):\n        for l in self.grid:\n            print l\n        return self\n\n    def _outer(self, lis):\n        if lis[0] == '0' or lis[0] == '1':\n            lis.insert(0, 'x')\n        else:\n            lis.insert(0, '0')\n        if lis[-1] == '0' or lis[-1] == '1':\n            lis.append('x')\n        else:\n            lis.append('0')\n        return lis\n\n\nclass Walker:\n    def __init__(self, grid, x, y):\n        self.grid = grid\n        self.x = x\n        self.y = y\n        self.dir = 'R'\n\n    def walk(self):\n        if self.left() == '1':\n            return self.to_left()\n        elif self.ahead() == '1':\n            return self.to_ahead()\n        elif self.right() == '1':\n            return self.to_right()\n        else:\n            return self.to_back()\n\n    def left(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y-1][x]\n        elif d == 'L':\n            return self.grid.grid[y+1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x-1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x+1]\n\n    def ahead(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y][x+1]\n        elif d == 'L':\n            return self.grid.grid[y][x-1]\n        elif d == 'U':\n            return self.grid.grid[y-1][x]\n        else:   # d == 'D'\n            return self.grid.grid[y+1][x]\n\n    def right(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y+1][x]\n        elif d == 'L':\n            return self.grid.grid[y-1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x+1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x-1]\n\n    def to_left(self):\n        d = self.dir\n        if d == 'R':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'L':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'U':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        else:   # d == 'D'\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n\n    def to_ahead(self):\n        d = self.dir\n        if d == 'R':\n            self.x += 2\n            return 'R'\n        elif d == 'L':\n            self.x -= 2\n            return 'L'\n        elif d == 'U':\n            self.y -= 2\n            return 'U'\n        else:   # d == 'D'\n            self.y += 2\n            return 'D'\n\n    def to_right(self):\n        d = self.dir\n        if d == 'R':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'L':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'U':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        else:   # d == 'D'\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n\n    def to_backt(self):\n        d = self.dir\n        if d == 'R':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        elif d == 'L':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        elif d == 'U':\n            self.y -= 2\n            self.dir = 'D'\n            return 'D'\n        else:   # d == 'D'\n            self.y += 2\n            self.dir = 'U'\n            return 'U'\n\n\n\ndef intersperse(lis, s):\n    r = []\n    for a in lis:\n        r.append(a)\n        r.append(s)\n    r.pop()\n    return r\n\ndef intersperse2(lis, s):\n    r = []\n    for a in lis:\n        r.append(s)\n        r.append(a)\n    r.append(s)\n    return r\n\n\n\nlines = sys.stdin.readlines()\nlines = map(lambda x: x.rstrip(\"\\r\\n\"), lines)\ngrid = Grid(lines)\n#grid.show()\nwalker = Walker(grid, 1, 1)\npath = []\nwhile True:\n    path.append(walker.walk())\n    if (walker.x, walker.y) == (1,1):\n        break\nprint ''.join(path)"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na='1'\nwhile 1:\n k=k%4+3\n for i in range(4):\n  k=k+i\n  if g[y][x]&int(2**(k%4)):a+=str(k%4);break\n if k%2:x+=[1,-1][(k%4)>1]\n else:y+=[-1,1][(k%4)>0]\n if x+y==0:break\nprint(''.join('URDL'[int(c)]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ngrid=[line.strip() for line in sys.stdin.readlines()]\nxgrid=[\"0\"+grid[i]+\"0\" for i in xrange(9) if i%2==0]\nygrid=[grid[i] for i in xrange(9) if i%2==1]\nygrid.insert(5,\"0\"*5)\nygrid.insert(0,\"0\"*5)\ngraph=[[None]*5 for i in xrange(5)]\nfor y in xrange(5):\n    for x in xrange(5):\n        graph[y][x]=[ygrid[y][x],xgrid[y][x+1],ygrid[y+1][x],xgrid[y][x]]\nnx,ny,dir=0,0,1\nDIRECTION=[\"U\",\"R\",\"D\",\"L\",]\ndx=[0,1,0,-1]\ndy=[-1,0,1,0]\nlog=[]\nwhile True:\n    for i in xrange(4):\n        if graph[ny][nx][(dir+3)%4]==\"1\":\n            dir=(dir+3)%4\n            log.append(DIRECTION[dir])\n            nx,ny=nx+dx[dir],ny+dy[dir]\n            break\n        dir=(dir+1)%4\n    if nx==0 and ny==0:break\nprint \"\".join(log)"
  },
  {
    "language": "Python",
    "code": "def wall(grid,x,y,d):\n    if d==0:\n        return x<4 and grid[y*2][x]=='1'\n    if d==1:\n        return y<4 and grid[y*2+1][x]=='1'\n    if d==2:\n        return x>0 and grid[y*2][x-1]=='1'\n    if d==3:\n        return y>0 and grid[y*2-1][x]=='1'\n\ndef move(x,y,d):\n    if d==0:\n        return x+1,y,'R'\n    if d==1:\n        return x,y+1,'D'\n    if d==2:\n        return x-1,y,'L'\n    if d==3:\n        return x,y-1,'U'\n\nans=''\nx=y=d=0\ngrid=[raw_input() for i in range(9)]\nwhile x or y or d < 2:\n    d=(d+3)%4\n    while not wall(grid,x,y,d):\n        d=(d+1)%4\n    x,y,c=move(x,y,d)\n    ans=ans+c\nprint ans"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    it=0\n    x=[]\n    y=[]\n    while True:\n        try: tmp = map(int,raw_input())\n        except:\n            return x,y\n        if it%2==0:\n            x.append(tmp)\n        else:\n            y.append(tmp)\n        it +=1\n\ndef nextpath(p, dir0):\n    tmp = ispath(p, (dir0+3)%4)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, dir0)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, (dir0+1)%4)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, (dir0+2)%4)\n    if tmp!=[]: return tmp\n    return tmp\n\ndef ispath(p,dir1):\n    y,x = p\n    if dir1==0:\n        if y>0 and wy[y-1][x]==1: return [-1,0]\n        else: return []\n    elif dir1==1:\n        if x<len(wx[0]) and wx[y][x]==1: return [0,1]\n        else: return []\n    elif dir1==2:\n        if y<len(wy[0])-1 and wy[y][x]==1: return [1,0]\n        else: return []\n    elif dir1==3:\n        if x>0 and wx[y][x-1]==1: return [0,-1]\n        else: return []\n    return []\n\ndef f0037():\n    p =[0,0]\n    direction = 1\n    msg = []\n    while True:\n        dp = nextpath(p, direction)\n        p[0] += dp[0]\n        p[1] += dp[1]\n        if dp == [0,1]:\n            direction = 1\n            msg.append(\"R\")\n        elif dp == [0,-1]:\n            direction = 3\n            msg.append(\"L\")\n        elif dp == [1,0]:\n            direction = 2\n            msg.append(\"D\")\n        elif dp == [-1,0]:\n            direction = 0\n            msg.append(\"U\")\n        if p==[0,0]: break            \n    return msg\n\nwx, wy = readdata()\nmsg = f0037()    \nprint \"\".join(msg)"
  },
  {
    "language": "Python",
    "code": "dist = ['R','D','L','U']\ndict = [(1,0),(0,1),(-1,0),(0,-1)]\n\n\nresult = ''\nsell = [[False]*13]*2\nfor i in xrange(9):\n    l = [False,False]\n    s = raw_input()\n    if len(s) == 4:\n        for j in s:\n            l.append(False)\n            l.append(bool(int(j)))\n        l += [False] * 3\n    else:\n        for j in s:\n            l.append(bool(int(j)))\n            l.append(False)\n        l += [False] * 2\n    sell.append(l)\nsell += [[False]*13]*2\n\nmy = (2,2,0)\n\nwhile(True):\n    if sell[my[0]+dict[my[2]][0],my[1]+dict[my[2]][1]]:\n        my = (my[0]+dict[my[2]][0]*2,my[1]+dict[my[2]][1]*2,my[2])\n        if my[0] == 2 and my[1] == 2:\n            break\n        else:\n            result += dist[my[2]]\n    else:\n        my = (my[0],my[1],(my[2]+1)%4)\nprint result"
  },
  {
    "language": "Python",
    "code": "import sys\nwx=[]\nwy=[]\ni=1\nA=\"0\"\nwx=[A]\nwy=[A]\nfor s in sys.stdin:\n    s=s[:-1]\n    if i: wx.append(A+s+A)\n    else: wy.append(A+s)\n    i=1-i\nwx[0]=A*len(wx[1])\nz=A*len(wy[1])\nwy[0]=z\nwy.append(z)\n\ny = 1\nx = 1\nd = 1\nmsg = \"\"\nwhile 1:\n    A=[3,0,1,2,3,0,1][d:d+4]\n    wall=[wy[y-1][x],wx[y][x],wy[y][x],wx[y][x-1]]\n    for e in A:\n        if wall[e]==\"1\": break\n    d = e\n    y += [-1,0,1,0][d]\n    x += [0,1,0,-1][d]\n    msg += \"URDL\"[d]\n    if [x,y]==[1,1]: break\nprint msg"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na=[1]\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=[k%4];break\n if k%2:x+=1-2*((k%4)>1)\n else:y+=2*((k%4)>0)-1\n if x+y==0:break\nprint(''.join('URDL'[c]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "dist = ['D','L','U','R']\ndict = [(0,1),(1,0),(0,-1),(-1,0)]\n\nresult = ''\nsell = [[False]*13]*2\nfor i in xrange(9):\n    l = [False,False]\n    s = raw_input()\n    if len(s) == 4:\n        for j in s:\n            l.append(False)\n            l.append(bool(int(j)))\n        l += [False] * 3\n    else:\n        for j in s:\n            l.append(bool(int(j)))\n            l.append(False)\n        l += [False] * 2\n    sell.append(l)\nsell += [[False]*13]*2\n\nmy = (2,2,0)\n\nwhile(True):\n    if sell[my[0]+dict[my[2]][0]][my[1]+dict[my[2]][1]]:\n        my = (my[0]+dict[my[2]][0]*2,my[1]+dict[my[2]][1]*2,my[2])\n        result += dist[my[2]]\n        if my[0] == 2 and my[1] == 2:\n            break\n        else:\n            my = (my[0],my[1],(my[2]-1)%4)\n    else:\n        my = (my[0],my[1],(my[2]+1)%4)\n\nprint result"
  },
  {
    "language": "Python",
    "code": "import sys\nwx=[]\nwy=[]\n\ndef readdata():\n    global wx,wy\n    i=1\n    A=\"0\"\n    wx=[\"\"]\n    wy=[\"\"]\n    for s in sys.stdin:\n        s=s[:-1]\n        if i: wx.append(A+s+A)\n        else: wy.append(A+s)\n        i=1-i\n    wx[0]=A*len(wx[1])\n    z=A*len(wy[1])\n    wy[0]=z\n    wy.append(z)\n    return\n\nreaddata()\ny = 1\nx = 1\nd = 1\nmsg = \"\"\nwhile 1:\n    A=[3,0,1,2,3,0,1][d:d+4]\n    wall=[wy[y-1][x],wx[y][x],wy[y][x],wx[y][x-1]]\n    for e in A:\n        if wall[e]==\"1\": break\n    d = e\n    y += [-1,0,1,0][d]\n    x += [0,1,0,-1][d]\n    msg += \"URDL\"[d]\n    if [x,y]==[1,1]: break\nprint msg"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\nimport sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "def wall(grid,x,y,d):\n\t#(0,1,2,3) => (R,D,L,U)\n    if d == 0: return x < 4 and grid[y*2][x] == '1'\n    if d == 1: return y < 4 and grid[y*2+1][x] == '1'\n    if d == 2: return x > 0 and grid[y*2][x-1] == '1'\n    if d == 3: return y > 0 and grid[y*2-1][x] == '1'\n \ndef move(x,y,d):\n    if d == 0: return x+1,y,'R'\n    if d == 1: return x,y+1,'D'\n    if d == 2: return x-1,y,'L'\n    if d == 3: return x,y-1,'U'\n \nans = \"\"\nx=y=d=0\ngrid=[raw_input() for i in range(9)]\nwhile x or y or d < 2:\n    d = (d+3)%4\n    while not wall(grid,x,y,d):\n        d = (d+1)%4\n    x,y,c = move(x,y,d)\n    ans += c\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys\nn = [input() for i in range(9)]\npath = [[0 for i in range(5)] for j in range(5)]\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 == 0]):\n    for j in range(4):\n        if v[j] == '1':\n            path[i][j] += 1\n            path[i][j+1] += 2\n\n\nfor i, v in enumerate([a[1] for a in enumerate(n) if a[0] % 2 != 0]):\n    for j in range(5):\n        if v[j] == '1':\n            path[i][j] += 4\n            path[i+1][j] += 8\n\ndur = {'R':(1, 0, 1),\n       'L':(2, 0, -1),\n       'U':(8, -1, 0),\n       'D':(4, 1, 0)}\n\ndur_next = {'R':('U','R','D'),\n            'L':('D','L','U'),\n            'U':('L','U','R'),\n            'D':('R','D','L')}\ndef walk():\n    global cx, cy\n    cx = dur[d][2] + cx\n    cy = dur[d][1] + cy\n\ndef next_D():\n    global cx,cy,d,dur\n    for nd in dur_next[d]:\n        if path[cy][cx] & dur[nd][0]:\n            d = nd\n            break\n\ncx = cy = 0\nd = 'R'\n\nwhile 1:\n    sys.stdout.write(d)\n    walk()\n    if cx == cy == 0:\n        break\n\n    next_D()"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\n\nboard = [[0 for i in range(11)] for j in range(11)]\nfor i, line in enumerate(f):\n    for j, c in enumerate(line.strip()):\n        board[i + 1][1 + (i + 1) % 2 + j * 2] = int(c)\n\nstep = {(-1, 0 ):'L',(0, -1 ):'U',(1, 0 ):'R',(0, 1):'D'}\n    \n    \nstart = pre_loc = 1 + 1j\nloc = 3 + 1j\nprint('R',end='')\nwhile loc != start:\n    for direct in [(pre_loc - loc) / 2 * 1j ** (i + 1) for i in range(3)]:\n        if board[int(loc.imag + direct.imag)][int(loc.real + direct.real)]:\n            pre_loc = loc\n            loc += direct * 2\n            print(step[(direct.real,direct.imag)],end='')\n            break\nprint()"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na=[1]\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=[k%4];break\n if k%2:x+=1-2*((k%4)>0)\n else:y+=2*((k%4)>0)-1\n if x+y==0:break\nprint(''.join('URDL'[c]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    it=0\n    x=[]\n    y=[]\n    while True:\n        try: tmp = map(int,raw_input())\n        except:\n            return x,y\n        if it%2==0:\n            x.append(tmp)\n        else:\n            y.append(tmp)\n        it +=1\n\ndef nextpath(p, dir0):\n# 0:north, 1:east, 2:south, 3:west\n    tmp = ispath(p, (dir0+3)%4)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, dir0)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, (dir0+1)%4)\n    if tmp!=[]: return tmp\n    tmp = ispath(p, (dir0+2)%4)\n    if tmp!=[]: return tmp\n    return tmp\n\ndef ispath(p,dir1):\n    y,x = p\n    if dir1==0:\n        if y>0 and wy[y-1][x]==1: return [-1,0]\n        else: return []\n    elif dir1==1:\n        if x<len(wx[0]) and wx[y][x]==1: return [0,1]\n        else: return []\n    elif dir1==2:\n        if y<len(wy[0])-1 and wy[y][x]==1: return [1,0]\n        else: return []\n    elif dir1==3:\n        if x>0 and wx[y][x-1]==1: return [0,-1]\n        else: return []\n    return []\n\ndef f0037():\n    p =[0,0]\n    direction = 1\n    msg = []\n    while True:\n        dp = nextpath(p, direction)\n        p[0] += dp[0]\n        p[1] += dp[1]\n        if dp == [0,1]:\n            direction = 1\n            msg.append(\"R\")\n        elif dp == [0,-1]:\n            direction = 3\n            msg.append(\"L\")\n        elif dp == [1,0]:\n            direction = 2\n            msg.append(\"U\")\n        elif dp == [-1,0]:\n            direction = 0\n            msg.append(\"U\")\n        if p==[0,0]: break            \n    return msg\n\nwx, wy = readdata()\nmsg = f0037()    \nprint \"\".join(msg)"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\nimport sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "import sys\n\nloc = [3, 1]\n\ndef print_dir(h):\n\tif h == 0:\n\t\tprint('R', end='')\n\telif h == 1:\n\t\tprint('D', end='')\n\telif h == 2:\n\t\tprint('L', end='')\n\telif h == 3:\n\t\tprint('U', end='')\n\ndir = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nhand = 3\n\nboard = [[0 for _ in range(11)] for _ in range(11)]\nfor i, line in enumerate(sys.stdin):\n\tfor j, c in enumerate(line.strip()):\n\t\tboard[i+1][1 + (i+1)%2 + j*2] = int(c)\n\nprint(\"R\", end='')\n\nwhile loc != [1, 1]:\n\tfor i in range(4):\n\t\tif board[loc[1]+dir[(hand+i)%4][1]][loc[0]+dir[(hand+i)%4][0]] == 1:\n\t\t\tloc[0] += dir[(hand+i)%4][0]*2\n\t\t\tloc[1] += dir[(hand+i)%4][1]*2\n\t\t\tif i == 1:\n\t\t\t\tprint_dir((hand+1)%4)\n\t\t\telif i == 2:\n\t\t\t\tprint_dir((hand+2)%4)\n\t\t\t\thand = (hand+1)%4\n\t\t\telif i == 3:\n\t\t\t\tprint_dir((hand+1)%4)\n\t\t\t\tprint_dir((hand+2)%4)\n\t\t\t\tprint_dir((hand+2)%4)\n\t\t\t\tprint_dir((hand+3)%4)\n\t\t\t\thand = (hand+2)%4\n\t\t\telif i == 0:\n\t\t\t\tprint_dir(hand%4)\n\t\t\t\thand = (hand+3)%4\n\n\t\t\tbreak\n\nprint()"
  },
  {
    "language": "Python",
    "code": "def wall(grid,x,y,d):\n    if d==0: return x<4 and grid[y*2][x]=='1'\n    if d==1: return y<4 and grid[y*2+1][x]=='1'\n    if d==2: return x>0 and grid[y*2][x-1]=='1'\n    if d==3: return y>0 and grid[y*2-1][x]=='1'\n\ndef move(x,y,d):\n    if d==0: return (x+1,y,'R')\n    if d==1: return (x,y+1,'D')\n    if d==2: return (x-1,y,'L')\n    if d==3: return (x,y-1,'U')\n\npath=\"\"\nx=y=d=0\ngrid=[raw_input() for i in range(9)]\nwhile x!=0 or y!=0 or d<2:\n    d=(d+3)%4\n    while not wall(grid,x,y,d):\n        d=(d+1)%4\n    (x,y,c)=move(x,y,d)\n    path+=c\nprint path"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "def xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print ''.join(result)\n        return True\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return True\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return True\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n\nwhile True:\n    try:      \n        mapp = []\n        for i in range(9):\n            mapp.append([int(char) for char in raw_input()])\n        tate = 0\n        yoko = 1\n        result = []\n        xxx((0,0), 'R')\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef read_inputs():\n    inputs = []\n    for i in range(9):\n        try:\n            inputs.append(raw_input())\n        except EOFError:\n            sys.exit()\n    return inputs\n\ndef create_routes(inputs):\n    for y, line in enumerate(inputs):\n        for x, c in enumerate(list(line)):\n            if c == '1':\n                if y % 2 == 0:\n                    dots[y/2][x][\"R\"] = 1\n                    dots[y/2][x+1][\"L\"] = 1\n                else:\n                    dots[y/2][x][\"D\"] = 1\n                    dots[y/2+1][x][\"U\"] = 1\n\ndef move_person(dots):\n    ret, current = \"\", \"R\"\n    x, y = 0, 0\n\n    def find(indexs):\n        dic = (\"R\", \"D\", \"L\", \"U\",)\n        for i in indexs:\n            if dots[y][x][dic[i]]:\n                return dic[i]\n        return \"\"\n\n    while True:\n        ret += current\n        if current == \"R\":\n            x += 1\n            current = find([3, 0, 1, 2])\n        elif current == \"D\":\n            y += 1\n            current = find([0, 1, 2, 3])\n        elif current == \"L\":\n            x -= 1\n            current = find([1, 2, 3, 0])\n        elif current == \"U\":\n            y -= 1\n            current = find([2, 3, 0, 1])\n        else:\n            print \"wrong data\"\n        if x == 0 and y == 0:\n            break\n    return ret\n\ndots = [[{'U': 0, 'D': 0, 'L': 0, 'R': 0} for i in range(5)] for j in range(5)]\n\ninputs = read_inputs()\n\ncreate_routes(inputs)\n\nprint move_person(dots)"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\nclass Grid:\n    def __init__(self, lines):\n        lines = map((lambda line: list(line)), lines)\n        l = []\n        for i in range(len(lines)):\n            if i % 2 == 0:\n                l.append(intersperse2(lines[i], '+'))\n            else:\n                l.append(intersperse(lines[i], 'x'))\n        l.insert(0, ['0','x','0','x','0','x','0','x','0'])\n        l.append(['0','x','0','x','0','x','0','x','0'])\n        l = map(lambda x: self._outer(x), l)\n        self.grid = l\n\n    def show(self):\n        for l in self.grid:\n            print l\n        return self\n\n    def _outer(self, lis):\n        if lis[0] == '0' or lis[0] == '1':\n            lis.insert(0, 'x')\n        else:\n            lis.insert(0, '0')\n        if lis[-1] == '0' or lis[-1] == '1':\n            lis.append('x')\n        else:\n            lis.append('0')\n        return lis\n\n\nclass Walker:\n    def __init__(self, grid, x, y):\n        self.grid = grid\n        self.x = x\n        self.y = y\n        self.dir = 'R'\n\n    def walk(self):\n        if self.left() == '1':\n            return self.to_left()\n        elif self.ahead() == '1':\n            return self.to_ahead()\n        elif self.right() == '1':\n            return self.to_right()\n        else:\n            return self.to_back()\n\n    def left(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y-1][x]\n        elif d == 'L':\n            return self.grid.grid[y+1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x-1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x+1]\n\n    def ahead(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y][x+1]\n        elif d == 'L':\n            return self.grid.grid[y][x-1]\n        elif d == 'U':\n            return self.grid.grid[y-1][x]\n        else:   # d == 'D'\n            return self.grid.grid[y+1][x]\n\n    def right(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y+1][x]\n        elif d == 'L':\n            return self.grid.grid[y-1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x+1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x-1]\n\n    def to_left(self):\n        d = self.dir\n        if d == 'R':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'L':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'U':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        else:   # d == 'D'\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n\n    def to_ahead(self):\n        d = self.dir\n        if d == 'R':\n            self.x += 2\n            return 'R'\n        elif d == 'L':\n            self.x -= 2\n            return 'L'\n        elif d == 'U':\n            self.y -= 2\n            return 'U'\n        else:   # d == 'D'\n            self.y += 2\n            return 'D'\n\n    def to_right(self):\n        d = self.dir\n        if d == 'R':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'L':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'U':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        else:   # d == 'D'\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n\n    def to_back(self):\n        d = self.dir\n        if d == 'R':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        elif d == 'L':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        elif d == 'U':\n            self.y -= 2\n            self.dir = 'D'\n            return 'D'\n        else:   # d == 'D'\n            self.y += 2\n            self.dir = 'U'\n            return 'U'\n\n\n\ndef intersperse(lis, s):\n    r = []\n    for a in lis:\n        r.append(a)\n        r.append(s)\n    r.pop()\n    return r\n\ndef intersperse2(lis, s):\n    r = []\n    for a in lis:\n        r.append(s)\n        r.append(a)\n    r.append(s)\n    return r\n\n\n\nlines = sys.stdin.readlines()\nlines = map(lambda x: x.rstrip(\"\\r\\n\"), lines)\ngrid = Grid(lines)\nwalker = Walker(grid, 1, 1)\npath = []\nwhile True:\n    path.append(walker.walk())\n    if (walker.x, walker.y) == (1,1):\n        break\nprint ''.join(path)"
  },
  {
    "language": "Python",
    "code": "grid = []\nfor i in range(9):\n    grid += [input()]\n\nposition = [0, 0]\ndirection = 'R'\npath = ''\nwhile True:\n    print(direction)\n    if direction == 'R':\n        path += direction\n        position[1] += 1\n        if position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        elif position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        elif position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        else:\n            direction = 'L'\n    elif direction == 'L':\n        path += direction\n        position[1] -= 1\n        if position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        elif position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            direction = 'L'\n        elif position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        else:\n            if position[0] == position[1] == 0:\n                break\n            direction = 'R'\n    elif direction == 'D':\n        path += direction\n        position[0] += 2\n        if position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        elif position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        elif position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            direction = 'L'\n        else:\n            direction = 'U'\n    else:\n        path += direction\n        position[0] -= 2\n        if position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            print('hello')\n            direction = 'L'\n        elif position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        elif position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        else:\n            direction = 'D'\nprint(path)\n\n"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        return print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return 1\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return 1\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return 1\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return 1\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return 1\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return 1\n        \ndef print_result():\n    print ''.join(result)\n    return 1\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n\ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nroad_h = [[0 for i in range(6)] for j in range(7)] #?¨??????????\nroad_v = [[0 for i in range(7)] for j in range(6)] #????????????\nax = ay = 1\nad_list = ['L', 'R', 'U', 'D']\n\nfor i in range(9):\n    line = str(raw_input())\n    if i % 2 == 0:\n        for j in range(4):\n            if line[j] == '1':\n                road_h[1+i/2][1+j] += 1\n    else:\n        for j in range(5):\n            if line[j] == '1':\n                road_v[1+i/2][1+j] += 1\n\nad = 1\nax += 1\nans = 'R'\nwhile True:\n    if ax == 1 and ay == 1:\n        break\n    if ad == 0:     #?????????\n        if road_v[ay][ax]:\n            ay += 1\n            ad = 3\n        elif road_h[ay][ax-1]:\n            ax -= 1\n        elif road_v[ay-1][ax]:\n            ay -= 1\n            ad = 2\n    elif ad == 1:   #?????????\n        if road_v[ay-1][ax]:\n            ay -= 1\n            ad = 2\n        elif road_h[ay][ax]:\n            ax += 1\n        elif road_v[ay][ax]:\n            ay += 1\n            ad = 3\n    elif ad == 2:   #?????????\n        if road_h[ay][ax-1]:\n            ax -= 1\n            ad = 0\n        elif road_v[ay-1][ax]:\n            ay -= 1\n        elif road_h[ay][ax]:\n            ax += 1\n            ad = 1\n    elif ad == 3:   #?????????\n        if road_h[ay][ax]:\n            ax += 1\n            ad = 1\n        elif road_v[ay][ax]:\n            ay += 1\n        elif road_h[ay][ax-1]:\n            ax -= 1\n            ad = 0\n    ans = ans + ad_list[ad]\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N = 5\n    MP = [[[0]*4 for i in range(N)] for j in range(N)]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    ds = \"LURD\"\n    for i in range(N):\n        s = readline().strip()\n        for j in range(N-1):\n            if s[j] == '1':\n                MP[i][j][2] = MP[i][j+1][0] = 1\n        if i < 4:\n            s = readline().strip()\n            for j in range(N):\n                if s[j] == '1':\n                    MP[i][j][3] = MP[i+1][j][1] = 1\n    x = 1; y = 0; cd = 2\n    de = [3, 0, 1, 2]\n    ans = [2]\n    while not x == y == 0:\n        e = MP[y][x]\n        for d in de:\n            if e[cd + d - 4]:\n                cd = (cd + d) % 4\n                ans.append(cd)\n                dx, dy = dd[cd]\n                x += dx; y += dy\n                break\n    write(\"\".join(map(ds.__getitem__, ans)))\n    write(\"\\n\")\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class Coordinate(object):\n    def __init__(self):\n        self.path = [None, None, None, None]\n\n\nclass Maze(object):\n    def __init__(self):\n        self.a = [[Coordinate() for _ in [0]*5] for _ in [0]*5]\n\n    def get_room(self, x, y):\n        return self.a[y][x]\n\n    def set_path(self, pos1, pos2):\n        dir1, dir2 = (0, 2) if pos1[1] == pos2[1] else (1, 3)\n        self.get_room(*pos1).path[dir1] = pos2\n        self.get_room(*pos2).path[dir2] = pos1\n\n    def solve(self):\n        result, x, y, direction = \"R\", 1, 0, 0\n        direction_sign = \"RDLU\"\n\n        while not(x == 0 and y == 0):\n            current = self.get_room(x, y)\n            if current.path[(direction-1)%4]:\n                direction = (direction-1)%4\n            elif current.path[direction]:\n                pass\n            elif current.path[(direction+1)%4]:\n                direction = (direction+1)%4\n            else:\n                direction = (direction+2)%4\n            x, y = current.path[direction]\n            result += direction_sign[direction]\n\n        return result\n\n\nmaze = Maze()\nfor i in range(9):\n    y = i//2\n    dx, dy = (1, 0) if i%2 == 0 else (0, 1)\n    for x, c in enumerate(input()):\n        if c == \"1\":\n            maze.set_path((x, y), (x+dx, y+dy))\n\nprint(maze.solve())\n"
  },
  {
    "language": "Python",
    "code": "grid = []\nfor i in range(9):\n    grid += [input()]\n\nposition = [0, 0]\ndirection = 'R'\npath = ''\nwhile True:\n    print(direction)\n    if direction == 'R':\n        path += direction\n        position[1] += 1\n        if position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        elif position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        elif position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        else:\n            direction = 'L'\n    elif direction == 'L':\n        path += direction\n        position[1] -= 1\n        if position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        elif position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            direction = 'L'\n        elif position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        else:\n            if position[0] == position[1] == 0:\n                break\n            direction = 'R'\n    elif direction == 'D':\n        path += direction\n        position[0] += 2\n        if position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        elif position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n            direction = 'D'\n        elif position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            direction = 'L'\n        else:\n            direction = 'U'\n    else:\n        path += direction\n        position[0] -= 2\n        if position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n            print('hello')\n            direction = 'L'\n        elif position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n            direction = 'U'\n        elif position[1] < 4 and grid[position[0]][position[1]] == '1':\n            direction = 'R'\n        else:\n            direction = 'D'\nprint(path)\n\n"
  },
  {
    "language": "Python",
    "code": "def idx_to_wxy(x, y, idx):\n    return (2 * x + 1 + (idx % 2) * (2 - idx), 2 * y + 1 + (1 - idx % 2) * (1 - idx))\nws = [[0]*11 for _ in range(11)]\nfor i in range(1, 10):\n    if i % 2:\n        ws[i][2], ws[i][4], ws[i][6], ws[i][8] = map(int, list(input()))\n    else:\n        ws[i][1], ws[i][3], ws[i][5], ws[i][7], ws[i][9] = map(int, list(input()))\nx = y = 0\nds = list('RDLU')\nd = 'R'\nwhile True:\n    print(d, end='')\n    idx = ds.index(d)\n    x += (idx % 2) * (2 - idx)\n    y += (1 - idx % 2) * (1 - idx)\n    if x == y == 0:\n        break\n    for i in range(-1, 3):\n        if ws[idx_to_wxy(x, y, (idx + i) % 4)[0]][idx_to_wxy(x, y, (idx + i) % 4)[1]]:\n            d = ds[(idx + i) % 4]\n            break\nprint('')"
  },
  {
    "language": "Python",
    "code": "def move(position):\n    x = position[0]\n    y = position[1]\n    d = position[2]\n    if d == \"L\":\n        p = \"DLUR\"\n    elif d == \"R\":\n        p = \"URDL\"\n    elif d == \"U\":\n        p = \"LURD\"\n    else:\n        p = \"RDLU\"\n    for i in range(4):\n        if p[i] in grid[y][x]:\n            d = p[i]\n            if d == \"L\":\n                print(\"L\",end=\"\")\n                x -= 1\n                break\n            elif d == \"R\":\n                print(\"R\",end=\"\")\n                x += 1\n                break\n            elif d == \"U\":\n                print(\"U\",end=\"\")\n                y -= 1\n                break\n            else:\n                print(\"D\",end=\"\")\n                y += 1\n                break\n    return [x, y, d]\n\npos = [1,1,\"R\"]\ngrid = [[\"\" for i in range(6)] for j in range(6)]\nfor i in range(9):\n    inp = input()\n    if i%2 == 0:\n        for j in range(4):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"R\"\n                grid[i//2 + 1][j + 2] += \"L\"\n    else:\n        for j in range(5):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"D\"\n                grid[i//2 + 2][j + 1] += \"U\"\nwhile True:\n    pos = move(pos)\n    if pos[0] == 1 and pos[1] == 1:\n        break\n\n"
  },
  {
    "language": "Python",
    "code": "def is_wall(x1,y1,x2,y2):\n    if x1<0 or 4<x1 or y1<0 or 4<y1 or x2<0 or 4<x2 or y2<0 or 4<y2:\n        return False\n    elif x1 == x2:\n        if y1>y2: y1,y2 = y2,y1\n        if y2-y1 != 1: return False\n        return (walls[y1*2+1][x1] == \"1\")\n    elif y1 == y2:\n        if x1>x2: x1,x2 = x2,x1\n        if x2-x1 != 1: return False\n        return (walls[y1*2][x1] == \"1\")\n    else: return False\n\ndef nextmove(x,y):\n    lastmove = moves[-1]\n    if lastmove == 3: lastmove = -1\n    if lastmove < -1: lastmove += 4\n    if is_wall(x,y,x+direction[lastmove+1][1],y+direction[lastmove+1][2]):\n        return lastmove+1,x+direction[lastmove+1][1],y+direction[lastmove+1][2]\n\n    if is_wall(x,y,x+direction[lastmove][1],y+direction[lastmove][2]):\n        return lastmove,x+direction[lastmove][1],y+direction[lastmove][2]\n\n    if is_wall(x,y,x+direction[lastmove-1][1],y+direction[lastmove-1][2]):\n        return lastmove-1,x+direction[lastmove-1][1],y+direction[lastmove-1][2]\n\n    if is_wall(x,y,x+direction[lastmove-2][1],y+direction[lastmove-2][2]):\n        return lastmove-2,x+direction[lastmove-2][1],y+direction[lastmove-2][2]\n\ndirection = [[\"R\",1,0],[\"U\",0,-1],[\"L\",-1,0],[\"D\",0,1]]\nwalls = []\nmoves = [0]\nfor _ in range(9):\n    walls.append(input())\nlastx = 1\nlasty = 0\nprint(\"R\", end = \"\")\nwhile True:\n    move,lastx,lasty = nextmove(lastx, lasty)\n    moves.append(move)\n    print(direction[move][0], end = \"\")\n    if lastx == 0 and lasty == 0: break\nprint()"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\nimport sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "path = [[[] for i in range(5)] for i in range(5)]\nfor i in range(9):\n    if i%2 == 0:\n        a = [int(i) for i in list(input())]\n        for j in range(4):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"R\")\n                path[int(i/2)][j+1].append(\"L\")\n    else:\n        a = [int(i) for i in list(input())]\n        for j in range(5):\n            if a[j] == 1:\n                path[int(i/2)][j].append(\"D\")\n                path[int(i/2)+1][j].append(\"U\")\n\nprev = \"R\"\np = \"R\"\nx = 0\ny = 0\nwhile(1):\n    if prev == \"R\":\n        if \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n    elif prev == \"L\":\n        if \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n    elif prev == \"U\":\n        if \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n        elif \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n    elif prev == \"D\":\n        if \"R\" in path[x][y]:\n            y += 1\n            prev = \"R\"\n            p += \"R\"\n        elif \"D\" in path[x][y]:\n            x += 1\n            prev = \"D\"\n            p += \"D\"\n        elif \"L\" in path[x][y]:\n            y -= 1\n            prev = \"L\"\n            p += \"L\"\n        elif \"U\" in path[x][y]:\n            x -= 1\n            prev = \"U\"\n            p += \"U\"\n    if x == 0 and y == 0:\n        break\nprint(p[1:])\n\n\n    \n\n"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print ''.join(result)\n        return True\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return True\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return True\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n\nwhile True:\n    try:      \n        mapp = []\n        for i in range(9):\n            mapp.append([int(char) for char in raw_input()])\n        tate = 0\n        yoko = 1\n        result = []\n        xxx((0,0), 'R')\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "dx, dy, s = [1, 0, -1, 0], [0, 1, 0, -1], 'RDLU'\n\n\ndef f(x, y, d):\n    x -= int(d == 2)\n    y = y * 2 + dy[d]\n    if not(0 <= y < len(a) and 0 <= x < len(a[y])):\n        return False\n    return a[y][x] == '1'\n\na = [raw_input() for i in range(9)]\nx = y = d = 0\nt = ''\nwhile True:\n    x += dx[d]\n    y += dy[d]\n    t += s[d]\n    if x == 0 and y == 0:\n        break\n    for i in [(d + j + 3) % 4 for j in range(3)]:\n        if f(x, y, i):\n            d = i\n            break\n    else:\n        d = (d + 2) % 4\nprint t"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    z=[]\n    try:\n        while True:\n            z.append(raw_input())\n    except: return z\n\ndef nextpath(p,dir0):\n    for e in [3,0,1,2]:\n        d = (dir0+e)%4\n        if ispath(p,d): return d\n    return None\n\ndef ispath(p,d):\n    y,x = p\n    f=\"\"\n    try:\n        if   d==0 and y>0: f = wy[y-1][x]\n        elif d==1 and x<len(wy): f = wx[y][x]\n        elif d==2 and y<len(wx): f = wy[y][x]\n        elif d==3 and x>0: f = wx[y][x-1]\n    except: pass\n    return f==\"1\"\n\ndef f0037():\n    p =[0,0]\n    dp = 1\n    msg = []\n    while True:\n        dp = nextpath(p, dp)\n        p[0] += [-1,0,1,0][dp]\n        p[1] += [0,1,0,-1][dp]\n        msg.append(\"URDL\"[dp])\n        if p==[0,0]: break\n    return \"\".join(msg)\n\nz = readdata()\nwx = z[0::2]\nwy = z[1::2]\nprint f0037()"
  },
  {
    "language": "Python",
    "code": "table = [input() for i in range(9)]\ndef isWall(x,y,dir):\n\t# 右\n    if dir == 0:\n        return x < 4 and table[y][x] == '1'\n    # 下\n    elif dir == 1:\n        return y < 8 and table[y + 1][x] == '1'\n\t# 左\n    elif dir == 2:\n        return x > 0 and table[y][x - 1] == '1'\n\t# 上\n    elif dir == 3:\n        return y > 0 and table[y - 1][x] == '1'\n    \nans = \"\"\nx = y = dir = 0\n\nwhile 1:\n    # 正面の壁\n    dir = (dir + 3) % 4\n    while not isWall(x,y,dir):\n        # 伝う壁\n        dir = (dir + 1) % 4\n    # 移動\n    if dir == 0:\n        x += 1\n        ans += 'R'\n    elif dir == 1:\n        y += 2\n        ans += 'D'\n    elif dir == 2:\n        x -= 1\n        ans += 'L'\n    elif dir == 3:\n        y -= 2\n        ans += 'U'\n    if x == 0 and y == 0:\n        break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x,k=0,1,1\na='1'\nwhile 1:\n k=k%4+2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=str(k%4);break\n if k%2:x+=[1,-1][(k%4)>1]\n else:y+=[-1,1][(k%4)>0]\n if x+y==0:break\nprint(''.join('URDL'[int(c)]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n    \ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na=[1]\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=[k%4];break\n if k%2:x+=1-2*((k%4)>1)\n else:y+=2*((k%4)>0)-1\n if x+y<1:break\nprint(''.join('URDL'[c]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na=[1]\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=[k%4];break\n if k%2:x+=-1**((k%4)>1)\n else:y+=2*((k%4)>0)-1\n if x+y==0:break\nprint(''.join('URDL'[c]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "g=[[0]*5 for _ in[0]*5]\nfor i in range(9):\n e=input()\n for j in range(4+i%2):\n  if int(e[j]):\n   if i%2:g[i//2][j]+=4;g[i//2+1][j]+=1\n   else:r=g[i//2];r[j]+=2;r[j+1]+=8\ny,x=0,1\nk=1\na='1'\nwhile 1:\n k+=2\n for _ in[0]*4:\n  k+=1\n  if g[y][x]&int(2**(k%4)):a+=str(k%4);break\n if k%2:x+=[1,-1][(k%4)>1]\n else:y+=[-1,1][(k%4)>0]\n if x+y==0:break\nprint(''.join('URDL'[int(c)]for c in a))\n"
  },
  {
    "language": "Python",
    "code": "wx=[]\nwy=[]\n\ndef readdata():\n    z=[]\n    try:\n        while True:\n            z.append(raw_input())\n    except: return z\n\ndef nextpath(p, dir0):\n    for e in [3,0,1,2]:\n        dp = ispath(p, (dir0+e)%4)\n        if dp!=[]: break\n    return dp\n\ndef ispath(p, dir1):\n    y,x = p\n    dp = []\n    if   dir1==0 and y>0            and wy[y-1][x]==\"1\": dp= 0\n    elif dir1==1 and x<len(wx[0])   and wx[y][x]  ==\"1\": dp = 1\n    elif dir1==2 and y<len(wy[0])-1 and wy[y][x]  ==\"1\": dp = 2\n    elif dir1==3 and x>0            and wx[y][x-1]==\"1\": dp = 3\n    return dp\n\ndef f0037():\n    p =[0,0]\n    dp = 1\n    msg = []\n    while True:\n        dp = nextpath(p, dp)\n        p[0]+=[-1,0,1,0][dp]\n        p[1]+=[0,1,0,-1][dp]\n        if p==[0,0]: break            \n        msg.append(\"URDL\"[dp])\n    return msg\n\nz = readdata()\nwx = z[0::2]\nwy = z[1::2]\nmsg = f0037()    \nprint \"\".join(msg)"
  },
  {
    "language": "Python",
    "code": "def move(position):\n    x = position[0]\n    y = position[1]\n    d = position[2]\n    if d == \"L\":\n        p = \"DLUR\"\n    elif d == \"R\":\n        p = \"URDL\"\n    elif d == \"U\":\n        p = \"LURD\"\n    else:\n        p = \"RDLU\"\n    for i in range(4):\n        if p[i] in grid[y][x]:\n            d = p[i]\n            if d == \"L\":\n                print(\"L\",end=\"\")\n                x -= 1\n                break\n            elif d == \"R\":\n                print(\"R\",end=\"\")\n                x += 1\n                break\n            elif d == \"U\":\n                print(\"U\",end=\"\")\n                y -= 1\n                break\n            else:\n                print(\"D\",end=\"\")\n                y += 1\n                break\n    return [x, y, d]\n\npos = [1,1,\"R\"]\ngrid = [[\"\" for i in range(6)] for j in range(6)]\nfor i in range(9):\n    inp = input()\n    if i%2 == 0:\n        for j in range(4):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"R\"\n                grid[i//2 + 1][j + 2] += \"L\"\n    else:\n        for j in range(5):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"D\"\n                grid[i//2 + 2][j + 1] += \"U\"\nwhile True:\n    pos = move(pos)\n    if pos[0] == 1 and pos[1] == 1:\n        break\nprint(\"\")\n"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print ''.join(result)\n        return True\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        if kyoto(position, direction): return True\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        if xxx(check_position, direction): return True\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        if xxx(check_position, direction): return True\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        if xxx(check_position, direction): return True\n\nwhile True:\n    try:      \n        mapp = []\n        for i in range(9):\n            mapp.append([int(char) for char in raw_input()])\n        tate = 0\n        yoko = 1\n        result = []\n        xxx((0,0), 'R')\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "def move(position):\n    x = position[0]\n    y = position[1]\n    d = position[2]\n    if d == \"L\":\n        p = \"DLUR\"\n    elif d == \"R\":\n        p = \"URDL\"\n    elif d == \"U\":\n        p = \"LURD\"\n    else:\n        p = \"RDLU\"\n    for i in range(4):\n        if p[i] in grid[y][x]:\n            d = p[i]\n            if d == \"L\":\n                print(\"L\",end=\"\")\n                x -= 1\n                break\n            elif d == \"R\":\n                print(\"R\",end=\"\")\n                x += 1\n                break\n            elif d == \"U\":\n                print(\"U\",end=\"\")\n                y -= 1\n                break\n            else:\n                print(\"D\",end=\"\")\n                y += 1\n                break\n    return [x, y, d]\n\npos = [1,1,\"R\"]\ngrid = [[\"\" for i in range(6)] for j in range(6)]\nfor i in range(9):\n    inp = input()\n    if i%2 == 0:\n        for j in range(4):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"R\"\n                grid[i//2 + 1][j + 2] += \"L\"\n    else:\n        for j in range(5):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"D\"\n                grid[i//2 + 2][j + 1] += \"U\"\nprint(*grid,sep=\"\\n\")\nwhile True:\n    pos = move(pos)\n    if pos[0] == 1 and pos[1] == 1:\n        break\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\nboard = [[0 for i in range(11)] for j in range(11)]\nfor i, line in enumerate(f):\n    for j, c in enumerate(line.strip()):\n        board[i + 1][1 + (i + 1) % 2 + j * 2] = int(c)\n\nstep = {(-1, 0 ):'L',(0, -1 ):'U',(1, 0 ):'R',(0, 1):'D'}\n    \n    \nstart = pre_loc = 1 + 1j\nloc = 3 + 1j\nprint('R',end='')\nwhile loc != start:\n    for direct in [(pre_loc - loc) / 2 * 1j ** (i + 1) for i in range(4)]:\n        if board[int(loc.imag + direct.imag)][int(loc.real + direct.real)]:\n            pre_loc = loc\n            loc += direct * 2\n            print(step[(direct.real,direct.imag)],end='')\n            break\nprint()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nroad_h = [[0 for i in range(6)] for j in range(7)] #?¨??????????\nroad_v = [[0 for i in range(7)] for j in range(6)] #????????????\nax = ay = 1\nad_list = ['L', 'R', 'U', 'D']\n\nfor i in range(9):\n    line = str(raw_input())\n    if i % 2 == 0:\n        for j in range(4):\n            if line[j] == '1':\n                road_h[1+i/2][1+j] += 1\n    else:\n        for j in range(5):\n            if line[j] == '1':\n                road_v[1+i/2][1+j] += 1\n\nad = 1\nax += 1\nans = 'R'\nwhile True:\n    if ax == 1 and ay == 1:\n        break\n    if ad == 0:     #?????????\n        if road_v[ay][ax]:\n            ay += 1\n            ad = 3\n        elif road_h[ay][ax-1]:\n            ax -= 1\n        elif road_v[ay-1][ax]:\n            ay -= 1\n            ad = 2\n        else:\n            ax += 1\n            ad = 1\n    elif ad == 1:   #?????????\n        if road_v[ay-1][ax]:\n            ay -= 1\n            ad = 2\n        elif road_h[ay][ax]:\n            ax += 1\n        elif road_v[ay][ax]:\n            ay += 1\n            ad = 3\n        else:\n            ax -= 1\n            ad = 0\n    elif ad == 2:   #?????????\n        if road_h[ay][ax-1]:\n            ax -= 1\n            ad = 0\n        elif road_v[ay-1][ax]:\n            ay -= 1\n        elif road_h[ay][ax]:\n            ax += 1\n            ad = 1\n        else:\n            ay += 1\n            ad = 3\n    elif ad == 3:   #?????????\n        if road_h[ay][ax]:\n            ax += 1\n            ad = 1\n        elif road_v[ay][ax]:\n            ay += 1\n        elif road_h[ay][ax-1]:\n            ax -= 1\n            ad = 0\n        else:\n            ay -= 1\n            ad = 2\n    ans = ans + ad_list[ad]\nprint ans"
  },
  {
    "language": "Python",
    "code": "mat = [['0', '0', '0', '0', '0']]\nfor i in range(9):\n    if i%2 ==0:\n        tmpc = '0' + input() + '0'\n\n    else:\n        tmpc = input()\n\n    mat.append(list(tmpc))\nmat.append(['0', '0', '0', '0', '0'])\n\npos = [0,1]\nmove = ['R']\nwhile True:\n    mdict = {'U': [2*pos[0], pos[1]], 'R': [2*pos[0]+1, pos[1]+1], 'D': [2*pos[0]+2, pos[1]], 'L': [2*pos[0]+1, pos[1]]}\n    if move[-1] == 'R':\n        belst = ['U', 'R', 'D', 'L']\n\n    elif move[-1] == 'D':\n        belst = ['R', 'D', 'L', 'U']\n\n    elif move[-1] == 'L':\n        belst = ['D', 'L', 'U', 'R']\n\n    else:\n        belst = ['L', 'U', 'R', 'D']\n            \n    for i in belst:\n        if mat[mdict[i][0]][mdict[i][1]] == '1':\n            be = i\n            break\n    \n    if be == 'U':\n        pos[0] -= 1\n    elif be == 'R':\n        pos[1] += 1\n    elif be == 'D':\n        pos[0] += 1\n    else:\n        pos[1] -= 1\n    \n    move.append(be)\n\n    if pos == [0, 0]:\n        break\n\nprint(''.join(move))\n"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\nclass Grid:\n    def __init__(self, lines):\n        lines = map((lambda line: list(line)), lines)\n        l = []\n        for i in range(len(lines)):\n            if i % 2 == 0:\n                l.append(intersperse2(lines[i], '+'))\n            else:\n                l.append(intersperse(lines[i], 'x'))\n        l.insert(0, ['0','x','0','x','0','x','0','x','0'])\n        l.append(['0','x','0','x','0','x','0','x','0'])\n        l = map(lambda x: self._outer(x), l)\n        self.grid = l\n\n    def show(self):\n        for l in self.grid:\n            print l\n        return self\n\n    def _outer(self, lis):\n        if lis[0] == '0' or lis[0] == '1':\n            lis.insert(0, 'x')\n        else:\n            lis.insert(0, '0')\n        if lis[-1] == '0' or lis[-1] == '1':\n            lis.append('x')\n        else:\n            lis.append('0')\n        return lis\n\n\nclass Walker:\n    def __init__(self, grid, x, y):\n        self.grid = grid\n        self.x = x\n        self.y = y\n        self.dir = 'R'\n\n    def walk(self):\n        if self.left() == '1':\n            return self.to_left()\n        elif self.ahead() == '1':\n            return self.to_ahead()\n        elif self.right() == '1':\n            return self.to_right()\n        else:\n            return self.to_back()\n\n    def left(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y-1][x]\n        elif d == 'L':\n            return self.grid.grid[y+1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x-1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x+1]\n\n    def ahead(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y][x+1]\n        elif d == 'L':\n            return self.grid.grid[y][x-1]\n        elif d == 'U':\n            return self.grid.grid[y-1][x]\n        else:   # d == 'D'\n            return self.grid.grid[y+1][x]\n\n    def right(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y+1][x]\n        elif d == 'L':\n            return self.grid.grid[y-1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x+1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x-1]\n\n    def to_left(self):\n        d = self.dir\n        if d == 'R':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'L':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'U':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        else:   # d == 'D'\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n\n    def to_ahead(self):\n        d = self.dir\n        if d == 'R':\n            self.x += 2\n            return 'R'\n        elif d == 'L':\n            self.x -= 2\n            return 'L'\n        elif d == 'U':\n            self.y -= 2\n            return 'U'\n        else:   # d == 'D'\n            self.y += 2\n            return 'D'\n\n    def to_right(self):\n        d = self.dir\n        if d == 'R':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'L':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'U':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        else:   # d == 'D'\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n\n    def to_back(self):\n        d = self.dir\n        if d == 'R':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        elif d == 'L':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        elif d == 'U':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        else:   # d == 'D'\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n\n\n\ndef intersperse(lis, s):\n    r = []\n    for a in lis:\n        r.append(a)\n        r.append(s)\n    r.pop()\n    return r\n\ndef intersperse2(lis, s):\n    r = []\n    for a in lis:\n        r.append(s)\n        r.append(a)\n    r.append(s)\n    return r\n\n\n\nlines = sys.stdin.readlines()\nlines = map(lambda x: x.rstrip(\"\\r\\n\"), lines)\ngrid = Grid(lines)\nwalker = Walker(grid, 1, 1)\npath = []\nwhile True:\n    path.append(walker.walk())\n    if (walker.x, walker.y) == (1,1):\n        break\nprint ''.join(path)"
  },
  {
    "language": "Python",
    "code": "def wall(d, x, y, z):\n    if z == 0: return x < 4 and d[y * 2][x] == '1'\n    if z == 1: return y < 4 and d[y * 2 + 1][x] == '1'\n    if z == 2: return x > 0 and d[y * 2][x - 1] == '1'\n    if z == 3: return y > 0 and d[y * 2 - 1][x] == '1'\ndef move(x, y, z):\n    if z == 0: return (x + 1, y, 'R')\n    if z == 1: return (x, y + 1, 'D')\n    if z == 2: return (x - 1, y, 'L')\n    if z == 3: return (x, y - 1, 'U')\nd = []\np = \"\"\nx = y = z = 0\nfor i in range(9):\n    d.append(raw_input())\nwhile x != 0 or y != 0 or z < 2:\n    z = (z + 3) % 4\n    while not wall(d, x, y, z):\n        z = (z + 1) % 4\n    (x, y, c) = move(x, y, z)\n    p += c\nprint p"
  },
  {
    "language": "Python",
    "code": "import sys\n\nloc = [3, 1]\n\ndef print_dir(h):\n    if h == 0:\n        print('R', end='')\n    elif h == 1:\n        print('D', end='')\n    elif h == 2:\n        print('L', end='')\n    elif h == 3:\n        print('U', end='')\n\ndir = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nhand = 3\n\nboard = [[0 for _ in range(11)] for _ in range(11)]\nfor i, line in enumerate(sys.stdin):\n    for j, c in enumerate(line.strip()):\n        board[i+1][1 + (i+1)%2 + j*2] = int(c)\n\nprint(\"R\", end='')\n\nwhile loc != [1, 1]:\n    for i in range(4):\n        if board[loc[1]+dir[(hand+i)%4][1]][loc[0]+dir[(hand+i)%4][0]] == 1:\n            loc[0] += dir[(hand+i)%4][0]*2\n            loc[1] += dir[(hand+i)%4][1]*2\n            if i == 1:\n                print_dir((hand+1)%4)\n            elif i == 2:\n                print_dir((hand+2)%4)\n                hand = (hand+1)%4\n            elif i == 3:\n                print_dir((hand+3)%4)\n                hand = (hand+2)%4\n            elif i == 0:\n                print_dir(hand%4)\n                hand = (hand+3)%4\n\n            break\n\nprint()"
  },
  {
    "language": "Python",
    "code": "class Board:\n    def __init__(self,m):\n        self.m = m\n        self.x = 0\n        self.y = 0\n        self.d = 'e'\n\n    def dir(self):\n        return self.d\n\n    def is_origin(self):\n        return (self.x==0) and (self.y==0)\n        \n    def north_is_wall(self):\n        if self.y == 0:\n            return False\n        else:\n            if self.m[2*self.y-1][self.x] == '1':\n                return True\n            else:\n                return False\n\n    def east_is_wall(self):\n        if self.x == 4:\n            return False\n        elif m[2*self.y][self.x] == '1':\n            return True\n        else:\n            return False\n    def west_is_wall(self):\n        if self.x == 0:\n            return False\n        elif m[2*self.y][self.x-1] == '1':\n            return True\n        else:\n            return False\n    def south_is_wall(self):\n#        print(\"x={},y={}\".format(self.x,self.y))\n        if self.y == 4:\n            return False\n        elif self.m[2*self.y+1][self.x] == '1':\n            return True\n        else:\n            return False\n\n    def go_north(self):\n        if self.y == 0:\n            raise \"invalid\"\n        else:\n            self.y -= 1\n            self.d = 'n'\n        print(\"U\",end=\"\")\n\n    def go_south(self):\n        if self.y == 5:\n            raise \"invalid\"\n        else:\n            self.y += 1\n            self.d = 's'\n        print(\"D\",end=\"\")\n\n    def go_east(self):\n        if self.x == 4:\n            raise \"go_east\"\n        else:\n            self.x += 1\n            self.d = 'e'\n        print(\"R\",end=\"\")\n\n    def go_west(self):\n        if self.x == 0:\n            raise \"go_west\"\n        else:\n            self.x -= 1\n            self.d = 'w'\n        print(\"L\",end=\"\")\n\n\ndef run(m):\n    b = Board(m)\n    init = True\n    while True:\n        d = b.dir()\n        if d == 'e':\n            if   b.north_is_wall():\n                b.go_north()\n            elif b.east_is_wall():\n                b.go_east()\n            elif b.south_is_wall():\n                b.go_south()\n            else:\n                b.go_west()\n        elif d == 's':\n            if   b.east_is_wall():\n                b.go_east()\n            elif b.south_is_wall():\n                b.go_south()\n            elif b.west_is_wall():\n                b.go_west()\n            else:\n                b.go_north()\n        elif d == 'w':\n            if b.south_is_wall():\n                b.go_south()\n            elif b.west_is_wall():\n                b.go_west()\n            elif b.north_is_wall():\n                b.go_north()\n            else:\n                b.go_east()\n        elif d == 'n':\n            if  b.west_is_wall():\n                b.go_west()\n            elif b.north_is_wall():\n                b.go_north()\n            elif b.east_is_wall():\n                b.go_east()\n            else:\n                b.go_south()\n\n        if (not init) and b.is_origin():\n            print()\n            break\n        init = False\n\nm = []\nfor _ in range(9):\n    m.append(list(input()))\n\nrun(m)\n\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    pipes = [[0 for _ in range(6)]]\n    pipes.extend([list(map(int, '0{0}0'.format(input()))) for _ in range(9)])\n    pipes.extend([[0 for _ in range(6)]])\n    last_dirction = 2\n    x, y = 1, 1\n    while True:\n        next_direction = (last_dirction - 1) % 4\n        while True:\n            if next_direction == 0:\n                nx, ny = x, 2*y - 2\n                if pipes[ny][nx] == 1:\n                    print('U', end='')\n                    x, y = x, y - 1\n                    break\n            elif next_direction == 1:\n                nx, ny = x, 2*y - 1\n                if pipes[ny][nx] == 1:\n                    print('R', end='')\n                    x, y = x + 1, y\n                    break\n            elif next_direction == 2:\n                nx, ny = x, 2*y\n                if pipes[ny][nx] == 1:\n                    print('D', end='')\n                    x, y = x, y + 1\n                    break\n            else:\n                nx, ny = x - 1, 2*y - 1\n                if pipes[ny][nx] == 1:\n                    print('L', end='')\n                    x, y = x - 1, y\n                    break\n            next_direction = (next_direction + 1) % 4\n        last_dirction = next_direction\n        if x == 1 and y == 1:\n            print()\n            break\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0037: Path on a Grid\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\nDIRS = ['R', 'D', 'L', 'U']\nDX = [0, 1, 0, -1]\nDY = [1, 0, -1, 0]\n\nboard = [[[False for _ in range(4)] for __ in range(6)] for ___ in range(6)]\nfor i in range(9):\n    l = 4 + i % 2\n    walls = input().strip()\n    for j in range(4 + i % 2):\n        n = int(walls[j])\n        if n == 1:\n            if i % 2 == 0:\n                board[i//2][j+1][1] = True\n                board[i//2+1][j+1][3] = True\n            else:\n                board[i//2+1][j][0] = True\n                board[i//2+1][j+1][2] = True\n    \nout = \"\"\ndirec = 0\nnx, ny = 0, 1\nwhile True:\n    if (nx == 1 and ny == 0 and direc == 2) or \\\n       (nx == 0 and ny == 0 and direc == 2):\n        break\n    x = nx + DX[direc]\n    y = ny + DY[direc]\n    if not board[nx][ny][(direc+1)%4]:\n        direc = (direc + 1) % 4\n        nx += DX[direc]\n        ny += DY[direc]\n    elif board[nx][ny][direc]:\n        out += DIRS[direc]\n        direc = (direc - 1 + 4) % 4\n    else:\n        out += DIRS[direc]\n        nx = x\n        ny = y\nprint(out)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom sys import stdin, exit\n\n\ndef make_destination(wx, wy):\n    data = [[] for _ in range(5)]\n\n    x1 = wx[0]\n    y1 = wy[0]\n    append = data[0].append\n    append(('R' if x1[0] == '1' else '.') +\n           ('D' if y1[0] == '1' else '.') + '..')\n    for i in range(3):\n        append(('R' if x1[i+1] == '1' else '.') +\n               ('D' if y1[i+1] == '1' else '.') +\n               ('L' if x1[i] == '1' else '.') + '.')\n    append('.' + ('D' if y1[4] == '1' else '.') +\n           ('L' if x1[3] == '1' else '.') + '.')\n\n    for j in range(1, 4):\n        y0 = y1\n        x1 = wx[j]\n        y1 = wy[j]\n        append = data[j].append\n        append(('R' if x1[0] == '1' else '.') +\n               ('D' if y1[0] == '1' else '.') + '.' +\n               ('U' if y0[0] == '1' else '.'))\n        for i in range(3):\n            append(('R' if x1[i+1] == '1' else '.') +\n                   ('D' if y1[i+1] == '1' else '.') +\n                   ('L' if x1[i] == '1' else '.') +\n                   ('U' if y0[i+1] == '1' else '.'))\n        append('.' + ('D' if y1[4] == '1' else '.') +\n               ('L' if x1[3] == '1' else '.') +\n               ('U' if y0[4] == '1' else '.'))\n\n    y0 = y1\n    x1 = wx[4]\n    append = data[4].append\n    append(('R' if x1[0] == '1' else '.') + '..' +\n           ('U' if y0[0] == '1' else '.'))\n    for i in range(3):\n        append(('R' if x1[i+1] == '1' else '.') + '.' +\n               ('L' if x1[i] == '1' else '.') +\n               ('U' if y0[i+1] == '1' else '.'))\n    append('..' + ('L' if x1[3] == '1' else '.') +\n           ('U' if y0[4] == '1' else '.'))\n\n    return data\n\n\ndef walk(data):\n    destination = {'R': (1, 0), 'D': (0, 1), 'L': (-1, 0), 'U': (0, -1)}\n    permutation = {'R': (3, 0, 1, 2), 'D': (0, 1, 2, 3),\n                   'L': (1, 2, 3, 0), 'U': (2, 3, 0, 1)}\n\n    print('R', end='')\n\n    x = 1\n    y = 0\n    move = 'R'\n\n    while x != 0 or y != 0:\n        ways = data[y][x]\n        for per in permutation[move]:\n            m = ways[per]\n            dest = destination.get(m)\n            if dest is not None:\n                break\n        x += dest[0]\n        y += dest[1]\n        move = m\n        print(move, end='')\n    print()\n\n\ndef main():\n    wall = stdin.read().split()\n    walk(make_destination(wall[::2], wall[1::2]))\n    exit(0)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "grid = []\nfor i in range(9):\n    grid += [input()]\n\nposition = [0, 0]\ndirection = 'R'\npath = ''\nwhile True:\n    if direction == 'R':\n        path += direction\n        position[1] += 1\n        if position[1] == 4 or grid[position[0]][position[1]] == '0':\n            if position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n                direction = 'U'\n            elif position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n                direction = 'D'\n            else:\n                direction = 'L'\n    elif direction == 'L':\n        path += direction\n        position[1] -= 1\n        if position[1] == 0 or grid[position[0]][position[1] - 1] == '0':\n            if position[0] < 8 and grid[position[0] + 1][position[1]] == '1':\n                direction = 'D'\n            elif position[0] > 0 and grid[position[0] - 1][position[1]] == '1':\n                direction = 'U'\n            else:\n                if position[0] == position[1] == 0:\n                    break\n                direction = 'R'\n    elif direction == 'D':\n        path += direction\n        position[0] += 2\n        if position[0] == 8 or grid[position[0] + 1][position[1]] == '0':\n            if position[1] < 4 and grid[position[0]][position[1]] == '1':\n                direction = 'R'\n            elif position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n                direction = 'L'\n            else:\n                direction = 'U'\n    else:\n        path += direction\n        position[0] -= 2\n        if position[0] == 0 or grid[position[0] - 1][position[1]] == '0':\n            if position[1] > 0 and grid[position[0]][position[1] - 1] == '1':\n                direction = 'L'\n            elif position[1] < 4 and grid[position[0]][position[1]] == '1':\n                direction = 'R'\n            else:\n                direction = 'D'\nprint(path)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\npoint = [[[0 for i in range(4)] for j in range(5)] for k in range(5)]\nraw = 0\nfor line in sys.stdin:\n    way = list(map(int, line.strip()))\n    if len(way) == 4:\n        for col in range(4):\n            if way[col] == 1:\n                point[raw][col][1] = point[raw][col + 1][3] = 1\n\n    elif len(way) == 5:\n        for col in range(5):\n            if way[col] == 1:\n                point[raw][col][2] = point[raw + 1][col][0] = 1\n        raw += 1\n\ndict = {0:\"U\", 1:\"R\", 2:\"D\", 3:\"L\"}\ncold = [0, 1, 0, -1]\nrawd = [-1, 0, 1, 0]\n\nraw = 0\ncol = 0\nnowd = 1\nans = \"\"\n\nwhile True:\n    for dirc in [(x - 1) % 4 for x in range(nowd, nowd + 4)]:\n        if point[raw][col][dirc] == 1:\n            ans += dict[dirc]\n            raw += rawd[dirc]\n            col += cold[dirc]\n            nowd = dirc\n            break\n    if raw == 0 and col == 0:\n        break\n        \nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\nimport sys\n\n\nclass Grid:\n    def __init__(self, lines):\n        lines = map((lambda line: list(line)), lines)\n        l = []\n        for i in range(len(lines)):\n            if i % 2 == 0:\n                l.append(intersperse2(lines[i], '+'))\n            else:\n                l.append(intersperse(lines[i], 'x'))\n        l.insert(0, ['0','x','0','x','0','x','0','x','0'])\n        l.append(['0','x','0','x','0','x','0','x','0'])\n        l = map(lambda x: self._outer(x), l)\n        self.grid = l\n\n    def show(self):\n        for l in self.grid:\n            print l\n        return self\n\n    def _outer(self, lis):\n        if lis[0] == '0' or lis[0] == '1':\n            lis.insert(0, 'x')\n        else:\n            lis.insert(0, '0')\n        if lis[-1] == '0' or lis[-1] == '1':\n            lis.append('x')\n        else:\n            lis.append('0')\n        return lis\n\n\nclass Walker:\n    def __init__(self, grid, x, y):\n        self.grid = grid\n        self.x = x\n        self.y = y\n        self.dir = 'R'\n\n    def walk(self):\n        if self.left() == '1':\n            return self.to_left()\n        elif self.ahead() == '1':\n            return self.to_ahead()\n        elif self.right() == '1':\n            return self.to_right()\n\n    def left(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y-1][x]\n        elif d == 'L':\n            return self.grid.grid[y+1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x-1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x+1]\n\n    def ahead(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y][x+1]\n        elif d == 'L':\n            return self.grid.grid[y][x-1]\n        elif d == 'U':\n            return self.grid.grid[y-1][x]\n        else:   # d == 'D'\n            return self.grid.grid[y+1][x]\n\n    def right(self):\n        x = self.x\n        y = self.y\n        d = self.dir\n        if d == 'R':\n            return self.grid.grid[y+1][x]\n        elif d == 'L':\n            return self.grid.grid[y-1][x]\n        elif d == 'U':\n            return self.grid.grid[y][x+1]\n        else:   # d == 'D'\n            return self.grid.grid[y][x-1]\n\n    def to_left(self):\n        d = self.dir\n        if d == 'R':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'L':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'U':\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n        else:   # d == 'D'\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n\n    def to_ahead(self):\n        d = self.dir\n        if d == 'R':\n            self.x += 2\n            return 'R'\n        elif d == 'L':\n            self.x -= 2\n            return 'L'\n        elif d == 'U':\n            self.y -= 2\n            return 'U'\n        else:   # d == 'D'\n            self.y += 2\n            return 'D'\n\n    def to_right(self):\n        d = self.dir\n        if d == 'R':\n            self.y += 2\n            self.dir = 'D'\n            return 'D'\n        elif d == 'L':\n            self.y -= 2\n            self.dir = 'U'\n            return 'U'\n        elif d == 'U':\n            self.x += 2\n            self.dir = 'R'\n            return 'R'\n        else:   # d == 'D'\n            self.x -= 2\n            self.dir = 'L'\n            return 'L'\n\n\n\ndef intersperse(lis, s):\n    r = []\n    for a in lis:\n        r.append(a)\n        r.append(s)\n    r.pop()\n    return r\n\ndef intersperse2(lis, s):\n    r = []\n    for a in lis:\n        r.append(s)\n        r.append(a)\n    r.append(s)\n    return r\n\n\n\nlines = sys.stdin.readlines()\nlines = map(lambda x: x.rstrip(\"\\r\\n\"), lines)\ngrid = Grid(lines)\n#grid.show()\nwalker = Walker(grid, 1, 1)\npath = []\nwhile True:\n    path.append(walker.walk())\n    if (walker.x, walker.y) == (1,1):\n        break\nprint ''.join(path)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef iswall(x,y,di):\n  if di == 0: return x<4 and d[2*y][x] == \"1\"\n  if di == 1: return y<4 and d[2*y+1][x] == \"1\"\n  if di == 2: return x>0 and d[2*y][x-1] == \"1\"\n  if di == 3: return y>0 and d[2*y-1][x] == \"1\"\ndef nextdi(x,y,di):\n  di = (di-1) %4\n  while True:\n    if iswall(x,y,di): return di\n    else: di = (di+1) % 4\ndef move(x,y,di):\n  return x+[1,0,-1,0][di],y+[0,1,0,-1][di]\n\nx,y,di,d,s=0,0,0,[],\"\"\nfor i in xrange(9): d.append(raw_input())\nwhile True:\n  di = nextdi(x,y,di)\n  x,y = move(x,y,di)\n  s += [\"R\",\"D\",\"L\",\"U\"][di]\n  if (x,y) == (0,0): break\nprint s"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\nimport sys\n\ndef xxx(position, direction):\n    if direction == 'R' or direction == 'L':\n        if not (0 <= position[tate] <= 8 and 0 <= position[yoko] <= 3):\n            return \n    elif direction == 'U' or direction == 'D':\n        if not (1 <= position[tate] <= 7 and 0 <= position[yoko] <= 4):\n            return\n    if (position[tate] == 0 and position[yoko] == 0) and direction == 'L' or \\\n       (position[tate] == 1 and position[yoko] == 0) and direction == 'U':\n        result.append(direction)\n        print_result()\n    if mapp[position[tate]][position[yoko]] == 1:\n        result.append(direction)\n        kyoto(position, direction)\n    elif mapp[position[tate]][position[yoko]] == 0:\n        return\n\ndef kyoto(position, direction):\n    if direction == 'R':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]+1\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]+1\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]+1\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'L'\n        xxx(check_position, direction)\n    elif direction == 'U':\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-2, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n    elif direction == 'L':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]-1, position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n    elif direction == 'D':\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]\n        direction = 'R'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+2, position[yoko]\n        direction = 'D'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate]+1, position[yoko]-1\n        direction = 'L'\n        xxx(check_position, direction)\n        #????????????????´¢\n        check_position = position[tate], position[yoko]\n        direction = 'U'\n        xxx(check_position, direction)\n        \ndef print_result():\n    print ''.join(result)\n    sys.exit()\n\nmapp = []\nfor i in range(9):\n    mapp.append([int(char) for char in raw_input()])\n\ntate = 0\nyoko = 1\nresult = []\nxxx((0,0), 'R')"
  },
  {
    "language": "Python",
    "code": "def move(position):\n    x = position[0]\n    y = position[1]\n    d = position[2]\n    if d == \"L\":\n        p = \"DLUR\"\n    elif d == \"R\":\n        p = \"URDL\"\n    elif d == \"U\":\n        p = \"LURD\"\n    else:\n        p = \"RDLU\"\n    for i in range(4):\n        if p[i] in grid[y][x]:\n            d = p[i]\n            if d == \"L\":\n                print(\"L\",end=\"\")\n                x -= 1\n                break\n            elif d == \"R\":\n                print(\"R\",end=\"\")\n                x += 1\n                break\n            elif d == \"U\":\n                print(\"U\",end=\"\")\n                y -= 1\n                break\n            else:\n                print(\"D\",end=\"\")\n                y += 1\n                break\n    return [x, y, d]\n\npos = [1,1,\"R\"]\ngrid = [[\"\" for i in range(6)] for j in range(6)]\nfor i in range(9):\n    inp = input()\n    if i%2 == 0:\n        for j in range(4):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"R\"\n                grid[i//2 + 1][j + 2] += \"L\"\n    else:\n        for j in range(5):\n            if inp[j] == \"1\":\n                grid[i//2 + 1][j + 1] += \"D\"\n                grid[i//2 + 2][j + 1] += \"U\"\nwhile True:\n    pos = move(pos)\n    if pos[0] == 1 and pos[1] == 1:\n        break\n\n"
  }
]