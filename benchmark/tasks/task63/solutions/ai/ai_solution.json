[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef enum {\n    UP, RIGHT, DOWN, LEFT\n} Direction;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int grid[MAX_SIZE][MAX_SIZE][4] = {0}; // UP, RIGHT, DOWN, LEFT\n\n    for (int i = 0; i < 4 * n; ++i) {\n        int x, y, dir, val;\n        scanf(\"%d %d %d %d\", &x, &y, &dir, &val);\n        grid[x][y][dir] = val;\n    }\n\n    Point start = {0, 0};\n    Point current = start;\n    Direction dir = RIGHT;\n    bool visited[MAX_SIZE][MAX_SIZE] = {false};\n\n    while (true) {\n        printf(\"(%d,%d)\\n\", current.x, current.y);\n        visited[current.x][current.y] = true;\n\n        // Try to turn right\n        Direction new_dir = (dir + 1) % 4;\n        if (grid[current.x][current.y][new_dir] == 1) {\n            dir = new_dir;\n        } else {\n            // Try to go straight\n            Point next = current;\n            switch (dir) {\n                case UP: next.y++; break;\n                case RIGHT: next.x++; break;\n                case DOWN: next.y--; break;\n                case LEFT: next.x--; break;\n            }\n            if (grid[current.x][current.y][dir] == 0) {\n                current = next;\n            } else {\n                // Turn left\n                dir = (dir - 1 + 4) % 4;\n            }\n        }\n\n        if (current.x == start.x && current.y == start.y && visited[start.x][start.y]) {\n            printf(\"(%d,%d)\\n\", start.x, start.y);\n            break;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:25:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallFollowerMaze {\n    static class Point {\n        int x, y;\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public static List<Point> findPath(int[][] horizontalWalls, int[][] verticalWalls) {\n        int n = horizontalWalls.length;\n        List<Point> path = new ArrayList<>();\n        Point start = new Point(0, 0);\n        path.add(start);\n        \n        Point current = start;\n        int direction = 0;\n        \n        while (true) {\n            int newDirection = (direction + 3) % 4;\n            Point next = tryMove(current, newDirection, horizontalWalls, verticalWalls);\n            \n            if (next != null) {\n                current = next;\n                path.add(current);\n                direction = newDirection;\n            } else {\n                newDirection = direction;\n                next = tryMove(current, newDirection, horizontalWalls, verticalWalls);\n                \n                if (next != null) {\n                    current = next;\n                    path.add(current);\n                } else {\n                    direction = (direction + 1) % 4;\n                }\n            }\n            \n            if (current.x == start.x && current.y == start.y && path.size() > 1) {\n                break;\n            }\n        }\n        \n        return path;\n    }\n    \n    static Point tryMove(Point current, int direction, int[][] horizontalWalls, int[][] verticalWalls) {\n        int n = horizontalWalls.length;\n        int x = current.x, y = current.y;\n        int dx = DIRECTIONS[direction][0], dy = DIRECTIONS[direction][1];\n        \n        if (direction == 0 && y + 1 < n && horizontalWalls[x][y] == 0) {\n            return new Point(x, y + 1);\n        }\n        if (direction == 1 && x + 1 < n && verticalWalls[x][y] == 0) {\n            return new Point(x + 1, y);\n        }\n        if (direction == 2 && y > 0 && horizontalWalls[x][y - 1] == 0) {\n            return new Point(x, y - 1);\n        }\n        if (direction == 3 && x > 0 && verticalWalls[x - 1][y] == 0) {\n            return new Point(x - 1, y);\n        }\n        \n        return null;\n    }\n\n    public static void main(String[] args) {\n        int[][] horizontalWalls = {\n            {0, 1, 1, 0},\n            {1, 0, 0, 1},\n            {0, 1, 1, 0},\n            {1, 0, 0, 1}\n        };\n        \n        int[][] verticalWalls = {\n            {1, 0, 1, 0},\n            {0, 1, 0, 1},\n            {1, 0, 1, 0},\n            {0, 1, 0, 1}\n        };\n        \n        List<Point> path = findPath(horizontalWalls, verticalWalls);\n        \n        for (Point p : path) {\n            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:25:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nenum Direction { UP, RIGHT, DOWN, LEFT };\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nDirection nextDirection(Direction dir, bool wallRight) {\n    if (wallRight) {\n        switch (dir) {\n            case UP: return RIGHT;\n            case RIGHT: return DOWN;\n            case DOWN: return LEFT;\n            case LEFT: return UP;\n        }\n    } else {\n        switch (dir) {\n            case UP: return LEFT;\n            case LEFT: return DOWN;\n            case DOWN: return RIGHT;\n            case RIGHT: return UP;\n        }\n    }\n    return UP;\n}\n\nbool hasWallRight(const vector<string>& grid, Point pos, Direction dir) {\n    int x = pos.x, y = pos.y;\n    switch (dir) {\n        case UP: return (x + 1 < grid.size()) && (grid[x + 1][y] == '1');\n        case RIGHT: return (y + 1 < grid[0].size()) && (grid[x][y + 1] == '1');\n        case DOWN: return (x - 1 >= 0) && (grid[x - 1][y] == '1');\n        case LEFT: return (y - 1 >= 0) && (grid[x][y - 1] == '1');\n    }\n    return false;\n}\n\nbool canMoveForward(const vector<string>& grid, Point pos, Direction dir) {\n    int x = pos.x, y = pos.y;\n    switch (dir) {\n        case UP: return (y - 1 >= 0) && (grid[x][y - 1] == '1');\n        case RIGHT: return (x + 1 < grid.size()) && (grid[x + 1][y] == '1');\n        case DOWN: return (y + 1 < grid[0].size()) && (grid[x][y + 1] == '1');\n        case LEFT: return (x - 1 >= 0) && (grid[x - 1][y] == '1');\n    }\n    return false;\n}\n\nvoid moveForward(Point& pos, Direction dir) {\n    switch (dir) {\n        case UP: pos.y--; break;\n        case RIGHT: pos.x++; break;\n        case DOWN: pos.y++; break;\n        case LEFT: pos.x--; break;\n    }\n}\n\nvector<Point> findPath(const vector<string>& grid, Point start) {\n    vector<Point> path;\n    Direction dir = RIGHT;\n    Point current = start;\n    path.push_back(current);\n\n    do {\n        bool wallRight = hasWallRight(grid, current, dir);\n        dir = nextDirection(dir, wallRight);\n        if (canMoveForward(grid, current, dir)) {\n            moveForward(current, dir);\n            path.push_back(current);\n        }\n    } while (!(current.x == start.x && current.y == start.y));\n\n    return path;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n\n    Point start(0, 0);\n    vector<Point> path = findPath(grid, start);\n\n    for (const auto& p : path) {\n        cout << p.x << \" \" << p.y << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\n// Directions: 0 = North, 1 = East, 2 = South, 3 = West\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint grid[MAX_SIZE][MAX_SIZE][4];\nbool visited[MAX_SIZE][MAX_SIZE];\nint rows, cols;\nint start_x, start_y;\n\nbool is_valid_move(int x, int y, int dir) {\n    return x >= 0 && x < cols && y >= 0 && y < rows && \n           grid[y][x][dir] == 0;\n}\n\nvoid solve_maze() {\n    int x = start_x, y = start_y;\n    int dir = 0;\n    \n    do {\n        visited[y][x] = true;\n        printf(\"(%d,%d) \", x, y);\n        \n        // Try to turn right\n        int right_dir = (dir + 1) % 4;\n        int new_x = x + dx[right_dir];\n        int new_y = y + dy[right_dir];\n        \n        if (is_valid_move(x, y, right_dir)) {\n            x = new_x;\n            y = new_y;\n            dir = right_dir;\n        }\n        // Try to move forward\n        else if (is_valid_move(x, y, dir)) {\n            x += dx[dir];\n            y += dy[dir];\n        }\n        // Turn left\n        else {\n            dir = (dir - 1 + 4) % 4;\n        }\n    } while (x != start_x || y != start_y);\n    \n    printf(\"\\n\");\n}\n\nint main() {\n    // Input grid configuration\n    scanf(\"%d %d\", &rows, &cols);\n    \n    // Read wall configuration for each cell\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < cols; x++) {\n            for (int d = 0; d < 4; d++) {\n                scanf(\"%d\", &grid[y][x][d]);\n            }\n        }\n    }\n    \n    // Input start point\n    scanf(\"%d %d\", &start_x, &start_y);\n    \n    solve_maze();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int _x = 0, int _y = 0) : x(_x), y(_y) {}\n};\n\nclass Maze {\nprivate:\n    vector<vector<int>> horizontal;\n    vector<vector<int>> vertical;\n    int N;\n    vector<Point> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    bool isValidMove(Point current, int dir) {\n        int newDir = (dir + 1) % 4;\n        Point next = {current.x + directions[newDir].x, current.y + directions[newDir].y};\n        \n        if (next.x < 0 || next.x >= N || next.y < 0 || next.y >= N)\n            return false;\n        \n        switch(newDir) {\n            case 0: return !vertical[current.x][current.y];\n            case 1: return !horizontal[current.x][current.y];\n            case 2: return !vertical[next.x][next.y];\n            case 3: return !horizontal[next.x][next.y];\n        }\n        return false;\n    }\n\n    bool canMove(Point current, int dir) {\n        switch(dir) {\n            case 0: return !vertical[current.x][current.y];\n            case 1: return !horizontal[current.x][current.y];\n            case 2: return !vertical[current.x+1][current.y];\n            case 3: return !horizontal[current.x][current.y+1];\n        }\n        return false;\n    }\n\npublic:\n    Maze(int size) : N(size) {\n        horizontal.resize(N+1, vector<int>(N));\n        vertical.resize(N+1, vector<int>(N));\n    }\n\n    void setWalls(vector<vector<int>>& hWalls, vector<vector<int>>& vWalls) {\n        horizontal = hWalls;\n        vertical = vWalls;\n    }\n\n    void findPath() {\n        Point start(0, 0);\n        Point current = start;\n        int dir = 0;\n        vector<Point> path;\n        path.push_back(current);\n\n        while (true) {\n            int tryDir = (dir + 3) % 4;\n            \n            for (int i = 0; i < 4; i++) {\n                int checkDir = (tryDir + i) % 4;\n                if (isValidMove(current, checkDir)) {\n                    if (canMove(current, checkDir)) {\n                        current.x += directions[checkDir].x;\n                        current.y += directions[checkDir].y;\n                        path.push_back(current);\n                        dir = checkDir;\n                        break;\n                    }\n                }\n            }\n\n            if (current.x == start.x && current.y == start.y && path.size() > 1)\n                break;\n        }\n\n        for (auto& p : path) {\n            cout << \"(\" << p.x << \",\" << p.y << \") \";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    int N = 3;\n    Maze maze(N);\n\n    vector<vector<int>> hWalls = {\n        {1, 1, 1},\n        {0, 1, 0},\n        {1, 1, 1}\n    };\n\n    vector<vector<int>> vWalls = {\n        {1, 0, 1},\n        {1, 0, 1},\n        {1, 0, 1}\n    };\n\n    maze.setWalls(hWalls, vWalls);\n    maze.findPath();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MazeSolver {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int[][] grid;\n    private int rows, cols;\n    private boolean[][][] visited;\n\n    public MazeSolver(int[][] grid) {\n        this.grid = grid;\n        this.rows = grid.length;\n        this.cols = grid[0].length;\n        this.visited = new boolean[rows][cols][4];\n    }\n\n    public List<int[]> solve(int startX, int startY) {\n        List<int[]> path = new ArrayList<>();\n        int x = startX, y = startY;\n        int dir = 0; // Start facing right\n\n        do {\n            path.add(new int[]{x, y});\n            int nextDir = (dir + 3) % 4; // Turn right first\n            boolean moved = false;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + DIRECTIONS[nextDir][0];\n                int ny = y + DIRECTIONS[nextDir][1];\n\n                if (isValid(nx, ny) && hasWall(x, y, nextDir)) {\n                    x = nx;\n                    y = ny;\n                    dir = nextDir;\n                    moved = true;\n                    break;\n                }\n                nextDir = (nextDir + 1) % 4; // Try next direction\n            }\n\n            if (!moved) break;\n        } while (x != startX || y != startY || path.size() == 1);\n\n        return path;\n    }\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols;\n    }\n\n    private boolean hasWall(int x, int y, int dir) {\n        switch (dir) {\n            case 0: return grid[x][y] == 1; // Right\n            case 1: return grid[x][y] == 1; // Down\n            case 2: return x > 0 && grid[x-1][y] == 1; // Left\n            case 3: return y > 0 && grid[x][y-1] == 1; // Up\n            default: return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 0, 1},\n            {0, 1, 0},\n            {1, 0, 1}\n        };\n        MazeSolver solver = new MazeSolver(grid);\n        List<int[]> path = solver.solve(0, 0);\n        for (int[] point : path) {\n            System.out.println(\"(\" + point[0] + \", \" + point[1] + \")\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:27:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_path(grid, start):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n    direction = 0  # Start with 'Right'\n    width = len(grid[0])\n    height = len(grid)\n    path = [start]\n    current_position = start\n\n    while True:\n        # Calculate right hand position\n        right_direction = (direction + 1) % 4\n        right_position = (current_position[0] + directions[right_direction][0],\n                          current_position[1] + directions[right_direction][1])\n\n        if (0 <= right_position[0] < height and\n            0 <= right_position[1] < width and\n            grid[right_position[0]][right_position[1]] == 0):\n            \n            # Turn right\n            direction = right_direction\n            current_position = right_position\n\n        else:\n            # Go straight\n            forward_position = (current_position[0] + directions[direction][0],\n                                current_position[1] + directions[direction][1])\n            if (0 <= forward_position[0] < height and\n                0 <= forward_position[1] < width and\n                grid[forward_position[0]][forward_position[1]] == 0):\n                current_position = forward_position\n            else:\n                # Turn left\n                direction = (direction - 1) % 4\n                forward_position = (current_position[0] + directions[direction][0],\n                                    current_position[1] + directions[direction][1])\n                if (0 <= forward_position[0] < height and\n                    0 <= forward_position[1] < width and\n                    grid[forward_position[0]][forward_position[1]] == 0):\n                    current_position = forward_position\n                else:\n                    break\n        \n        path.append(current_position)\n        \n        if current_position == start and len(path) > 1:\n            break\n\n    return path\n\n# Example usage\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\n\nstart_position = (1, 1)\npath = find_path(grid, start_position)\nprint(path)",
    "timestamp": "2025-08-12 23:09:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MazeSolver {\n    static final int[] DX = {0, 1, 0, -1}; // right, down, left, up\n    static final int[] DY = {1, 0, -1, 0}; // right, down, left, up\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 1},\n            {1, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1}\n        };\n\n        List<int[]> path = findPath(grid, 1, 1);\n        for (int[] p : path) {\n            System.out.println(Arrays.toString(p));\n        }\n    }\n\n    private static List<int[]> findPath(int[][] grid, int startX, int startY) {\n        List<int[]> path = new ArrayList<>();\n        int x = startX;\n        int y = startY;\n        int dir = 0; // start by moving right\n\n        do {\n            path.add(new int[] {x, y});\n            // Try to turn right\n            int rightDir = (dir + 1) % 4;\n            int rightX = x + DX[rightDir];\n            int rightY = y + DY[rightDir];\n\n            if (grid[rightX][rightY] == 0) {\n                // If possible, turn right\n                x = rightX;\n                y = rightY;\n                dir = rightDir;\n            } else {\n                // Move forward\n                int forwardX = x + DX[dir];\n                int forwardY = y + DY[dir];\n                if (grid[forwardX][forwardY] == 0) {\n                    x = forwardX;\n                    y = forwardY;\n                } else {\n                    // Turn left if can't go forward\n                    dir = (dir + 3) % 4;\n                }\n            }\n        } while (x != startX || y != startY);\n\n        return path;\n    }\n}",
    "timestamp": "2025-08-12 23:09:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n// Function to check if a position is within the grid\nint isInGrid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\n// Function to return the next direction keeping the wall on the right\nvoid nextMove(int *x, int *y, int *dir, int grid[][5], int n) {\n    // Directions: 0=up, 1=right, 2=down, 3=left\n    // Right turns: +1, Left turns: -1, Straight: 0\n    int directions[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n    \n    // Try turning right first\n    int rightDir = (*dir + 1) % 4;\n    int nx = *x + directions[rightDir][0];\n    int ny = *y + directions[rightDir][1];\n    \n    if (isInGrid(nx, ny, n) && grid[nx][ny] == 0) {\n        *x = nx;\n        *y = ny;\n        *dir = rightDir;\n    } else {\n        // Try moving straight\n        nx = *x + directions[*dir][0];\n        ny = *y + directions[*dir][1];\n        if (isInGrid(nx, ny, n) && grid[nx][ny] == 0) {\n            *x = nx;\n            *y = ny;\n        } else {\n            // Turn left (if straight is not possible)\n            *dir = (*dir + 3) % 4;\n        }\n    }\n}\n\nint main() {\n    int n = 5; // Grid size\n    int grid[5][5] = {\n        {1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 1},\n        {1, 1, 1, 0, 1},\n        {1, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1},\n    };\n    \n    // Starting point A\n    int x = 1, y = 1; // Assuming top-left corner\n    int startX = x, startY = y;\n    \n    int dir = 1; // Initial direction (right)\n    do {\n        printf(\"(%d, %d)\\n\", x, y);\n        nextMove(&x, &y, &dir, grid, n);\n    } while (x != startX || y != startY);\n\n    printf(\"(%d, %d)\\n\", x, y); // Print start/end point\n    \n    return 0;\n}",
    "timestamp": "2025-08-12 23:10:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_path(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n    \n    def can_move(x, y, dx, dy, current_dir):\n        next_x, next_y = x + dx, y + dy\n        \n        if not is_valid(next_x, next_y):\n            return False\n        \n        # Check if wall exists in current direction\n        if current_dir == 0 and grid[x][y][1] == 1:\n            return False\n        elif current_dir == 1 and grid[x][y][2] == 1:\n            return False\n        elif current_dir == 2 and grid[x][y][3] == 1:\n            return False\n        elif current_dir == 3 and grid[x][y][0] == 1:\n            return False\n        \n        return True\n    \n    def solve(x, y):\n        path = [(x, y)]\n        current_dir = 0\n        start_x, start_y = x, y\n        \n        while True:\n            # Try to turn right\n            right_dir = (current_dir - 1) % 4\n            right_dx, right_dy = directions[right_dir]\n            \n            if can_move(x, y, right_dx, right_dy, current_dir):\n                x += right_dx\n                y += right_dy\n                current_dir = right_dir\n            else:\n                # Try to move forward\n                dx, dy = directions[current_dir]\n                if can_move(x, y, dx, dy, current_dir):\n                    x += dx\n                    y += dy\n                else:\n                    # Turn left\n                    current_dir = (current_dir + 1) % 4\n                    continue\n            \n            path.append((x, y))\n            \n            # Check if returned to start\n            if x == start_x and y == start_y and len(path) > 1:\n                break\n        \n        return path\n    \n    return solve(0, 0)",
    "timestamp": "2025-08-12 23:10:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_maze(right_walls, bottom_walls):\n    rows = len(bottom_walls)\n    cols = len(right_walls[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    path = []\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n    dir_idx = 0  # Start facing right\n    x, y = 0, 0  # Start at point A (0,0)\n    \n    while True:\n        if visited[x][y] and (x, y) == (0, 0) and path:\n            path.append((0, 0))\n            return path\n        visited[x][y] = True\n        path.append((x, y))\n        \n        # Check right side for wall\n        right_dir = (dir_idx + 1) % 4\n        dx, dy = directions[right_dir]\n        nx, ny = x + dx, y + dy\n        \n        has_right_wall = False\n        if right_dir == 0:  # Right\n            if y < cols - 1 and right_walls[x][y] == 1:\n                has_right_wall = True\n        elif right_dir == 1:  # Down\n            if x < rows - 1 and bottom_walls[x][y] == 1:\n                has_right_wall = True\n        elif right_dir == 2:  # Left\n            if y > 0 and right_walls[x][y-1] == 1:\n                has_right_wall = True\n        elif right_dir == 3:  # Up\n            if x > 0 and bottom_walls[x-1][y] == 1:\n                has_right_wall = True\n        \n        if has_right_wall:\n            # Move forward\n            dx, dy = directions[dir_idx]\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                x, y = nx, ny\n            else:\n                # Turn left if can't move forward\n                dir_idx = (dir_idx - 1) % 4\n        else:\n            # Turn right and move\n            dir_idx = right_dir\n            dx, dy = directions[dir_idx]\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols:\n                x, y = nx, ny\n            else:\n                # Turn left if can't move\n                dir_idx = (dir_idx - 1) % 4\n\n# Example usage:\nright_walls = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 1, 0]\n]\nbottom_walls = [\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 0, 0]\n]\nprint(solve_maze(right_walls, bottom_walls))",
    "timestamp": "2025-08-12 23:10:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> grid;\nbool visited[100][100][4];\nvector<pair<int, int>> path;\nint n, m;\n\n// Directions: 0 -> right, 1 -> down, 2 -> left, 3 -> up\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool isWall(int x, int y, int dir) {\n    // Checks if there is a wall in the given direction\n    if (dir == 0) return grid[x][y] & 1; // right\n    if (dir == 1) return grid[x][y] & 2; // down\n    if (dir == 2) return grid[x][y] & 4; // left\n    if (dir == 3) return grid[x][y] & 8; // up\n    return false;\n}\n\nvoid walk(int x, int y, int dir) {\n    path.push_back({x, y});\n    visited[x][y][dir] = true;\n\n    while (!(x == path[0].first && y == path[0].second && dir == 0)) {\n        int rightDir = (dir + 1) % 4;\n        int behindDir = (dir + 2) % 4;\n        \n        if (!isWall(x, y, rightDir) && !visited[x][y][rightDir]) {\n            dir = rightDir;\n        } else if (!isWall(x, y, dir) && !visited[x + dx[dir]][y + dy[dir]][dir]) {\n            // Move forward\n        } else {\n            dir = (dir + 3) % 4; // Turn left\n        }\n        \n        x += dx[dir];\n        y += dy[dir];\n\n        path.push_back({x, y});\n        visited[x][y][dir] = true;\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    grid.resize(n, vector<int>(m));\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            cin >> grid[i][j];\n\n    walk(0, 0, 0);\n\n    for (auto &p : path)\n        cout << p.first << \" \" << p.second << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:48:58"
  }
]