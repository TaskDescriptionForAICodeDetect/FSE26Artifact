[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 20\n\nlong long solve(int N, int K, int S, int T, int* A) {\n    long long dp[1 << MAX_N];\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int mask = (1 << MAX_N) - 1; mask >= 0; mask--) {\n            int newMask = mask | A[i];\n            dp[newMask] += dp[mask];\n        }\n    }\n\n    long long result = 0;\n    for (int mask = 0; mask < (1 << N); mask++) {\n        int count = __builtin_popcount(mask);\n        if (count >= 1 && count <= K) {\n            int currAnd = -1, currOr = 0;\n            for (int j = 0; j < N; j++) {\n                if (mask & (1 << j)) {\n                    currAnd &= A[j];\n                    currOr |= A[j];\n                }\n            }\n            if (currAnd == S && currOr == T) {\n                result += dp[mask];\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N, K, S, T;\n    int A[MAX_N];\n\n    scanf(\"%d %d %d %d\", &N, &K, &S, &T);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    printf(\"%lld\\n\", solve(N, K, S, T, A));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint main() {\n    int N, K, S, T;\n    scanf(\"%d %d %d %d\", &N, &K, &S, &T);\n    \n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    long long result = 0;\n    \n    for (int mask = 1; mask < (1 << N); mask++) {\n        int cnt = __builtin_popcount(mask);\n        if (cnt > K) continue;\n        \n        int and_val = ~0;\n        int or_val = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                and_val &= A[i];\n                or_val |= A[i];\n            }\n        }\n        \n        if (and_val == S && or_val == T) {\n            result = (result + 1) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    free(A);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    int S, T;\n    cin >> S >> T;\n\n    vector<vector<int>> dp_and(1 << 16, vector<int>(K + 1, 0));\n    vector<vector<int>> dp_or(1 << 16, vector<int>(K + 1, 0));\n\n    dp_and[0xFFFF][0] = 1; // Initial state: AND of 0 numbers is all bits set (0xFFFF for 16 bits)\n    dp_or[0][0] = 1;        // Initial state: OR of 0 numbers is 0\n\n    for (int num : A) {\n        // Update dp_and: need to process from high to low to avoid overwriting\n        for (int mask = (1 << 16) - 1; mask >= 0; --mask) {\n            for (int k = K; k >= 1; --k) {\n                int new_mask = mask & num;\n                dp_and[new_mask][k] = (dp_and[new_mask][k] + dp_and[mask][k - 1]) % MOD;\n            }\n        }\n        // Update dp_or\n        for (int mask = 0; mask < (1 << 16); ++mask) {\n            for (int k = K; k >= 1; --k) {\n                int new_mask = mask | num;\n                dp_or[new_mask][k] = (dp_or[new_mask][k] + dp_or[mask][k - 1]) % MOD;\n            }\n        }\n    }\n\n    long long result = 0;\n    for (int k = 1; k <= K; ++k) {\n        result = (result + 1LL * dp_and[S][k] * dp_or[T][k]) % MOD;\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:30:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int S = scanner.nextInt();\n        int T = scanner.nextInt();\n        \n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        \n        long[][] dp = new long[K + 1][1 << 18];\n        dp[0][0] = 1;\n        \n        for (int num : A) {\n            for (int k = K; k >= 1; k--) {\n                for (int mask = 0; mask < (1 << 18); mask++) {\n                    if (dp[k - 1][mask] > 0) {\n                        int newMaskAnd = (k == 1) ? num : (mask & num);\n                        int newMaskOr = (k == 1) ? num : (mask | num);\n                        dp[k][newMaskAnd] = (dp[k][newMaskAnd] + dp[k - 1][mask]) % MOD;\n                        dp[k][newMaskOr] = (dp[k][newMaskOr] + dp[k - 1][mask]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        long result = 0;\n        for (int k = 1; k <= K; k++) {\n            result = (result + dp[k][S & T]) % MOD;\n        }\n        \n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:30:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static long countWays(int N, int K, int[] A, int S, int T) {\n        long result = 0;\n        \n        for (int mask = 1; mask <= (1 << N) - 1; mask++) {\n            if (Integer.bitCount(mask) > K) continue;\n            \n            int bitAnd = -1;\n            int bitOr = 0;\n            \n            for (int i = 0; i < N; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    bitAnd &= A[i];\n                    bitOr |= A[i];\n                }\n            }\n            \n            if (bitAnd == S && bitOr == T) {\n                result++;\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int[] A = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        \n        int S = scanner.nextInt();\n        int T = scanner.nextInt();\n        \n        System.out.println(countWays(N, K, A, S, T));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:30:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 20;\nconst int MAX_VAL = (1 << 20);\n\nint main() {\n    int N, K, S, T;\n    cin >> N >> K >> S >> T;\n    \n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    \n    long long ans = 0;\n    \n    for (int mask = 1; mask < (1 << N); mask++) {\n        int cnt = __builtin_popcount(mask);\n        if (cnt > K) continue;\n        \n        int bitAnd = -1;\n        int bitOr = 0;\n        \n        for (int j = 0; j < N; j++) {\n            if (mask & (1 << j)) {\n                bitAnd &= A[j];\n                bitOr |= A[j];\n            }\n        }\n        \n        if (bitAnd == S && bitOr == T) {\n            ans++;\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef count_ways_to_choose_set(N, K, S, T, A):\n    count = 0\n    for r in range(1, K + 1):  # Choose between 1 and K elements\n        for combo in combinations(A, r):\n            bit_and = combo[0]\n            bit_or = combo[0]\n            for num in combo[1:]:\n                bit_and &= num\n                bit_or |= num\n            if bit_and == S and bit_or == T:\n                count += 1\n    return count\n\n# Example usage:\n# N = 3\n# K = 2\n# S = 1\n# T = 5\n# A = [1, 2, 4]\n# print(count_ways_to_choose_set(N, K, S, T, A))  # Output depends on specific input",
    "timestamp": "2025-08-13 11:03:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SubsetFinder {\n    \n    public static int countSubsets(int[] A, int N, int K, int S, int T) {\n        return findSubsets(A, N, K, S, T, 0, 0, 0, 0);\n    }\n    \n    private static int findSubsets(int[] A, int N, int K, int S, int T, int index, int currentCount, int currentAnd, int currentOr) {\n        if (currentCount > K) {\n            return 0;\n        }\n        if (index == N) {\n            return (currentCount > 0 && currentAnd == S && currentOr == T) ? 1 : 0;\n        }\n        \n        // Not include A[index]\n        int exclude = findSubsets(A, N, K, S, T, index + 1, currentCount, currentAnd, currentOr);\n        \n        // Include A[index]\n        int newAnd = (currentCount == 0) ? A[index] : (currentAnd & A[index]);\n        int newOr = (currentOr | A[index]);\n        int include = findSubsets(A, N, K, S, T, index + 1, currentCount + 1, newAnd, newOr);\n        \n        return exclude + include;\n    }\n\n    public static void main(String[] args) {\n        int[] A = {1, 2, 3, 4};\n        int N = 4;\n        int K = 3;\n        int S = 1;\n        int T = 3;\n        System.out.println(countSubsets(A, N, K, S, T)); // Output the result\n    }\n}",
    "timestamp": "2025-08-13 11:03:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint countWays(int A[], int N, int K, int S, int T) {\n    int count = 0;\n    int limit = 1 << N; // Total possible subsets (2^N)\n\n    // Iterate over all possible subsets\n    for (int mask = 1; mask < limit; ++mask) {\n        int set_size = 0;\n        int and_result = -1; // No bits set initially\n        int or_result = 0;\n\n        // Calculate bitwise AND and OR for the current subset\n        for (int i = 0; i < N; ++i) {\n            if (mask & (1 << i)) {\n                set_size++;\n                if (and_result == -1) {\n                    and_result = A[i];\n                } else {\n                    and_result &= A[i];\n                }\n                or_result |= A[i];\n            }\n        }\n\n        // Check if the subset is valid\n        if (set_size <= K && and_result == S && or_result == T) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int N, K, S, T;\n    scanf(\"%d %d %d %d\", &N, &K, &S, &T);\n\n    int A[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int result = countWays(A, N, K, S, T);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:03:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWays(N, K, A, S, T) {\n    function dfs(index, chosen, currAnd, currOr) {\n        if (index === N) {\n            return (chosen > 0 && chosen <= K && currAnd === S && currOr === T) ? 1 : 0;\n        }\n        \n        // Include current element in the set\n        const includeCount = dfs(index + 1, chosen + 1, currAnd & A[index], currOr | A[index]);\n        \n        // Exclude current element from the set\n        const excludeCount = dfs(index + 1, chosen, currAnd, currOr);\n        \n        return includeCount + excludeCount;\n    }\n    \n    return dfs(0, 0, ~0, 0);\n}",
    "timestamp": "2025-08-13 11:03:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_sets(N, K, S, T, A):\n    valid_sets = 0\n    \n    # Try all possible set sizes from 1 to K\n    for set_size in range(1, K + 1):\n        # Generate all combinations of set_size elements\n        for subset in combinations(A, set_size):\n            # Calculate bitwise AND and OR of the subset\n            and_result = subset[0]\n            or_result = subset[0]\n            \n            for num in subset[1:]:\n                and_result &= num\n                or_result |= num\n            \n            # Check if the subset meets the conditions\n            if and_result == S and or_result == T:\n                valid_sets += 1\n    \n    return valid_sets\n\nfrom itertools import combinations\n\n# Read input\nN, K, S, T = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Call the function and print result\nprint(count_sets(N, K, S, T, A))",
    "timestamp": "2025-08-13 11:03:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWays(N, K, A, S, T) {\n    let ways = 0;\n    \n    for (let mask = 1; mask < (1 << N); mask++) {\n        let numCount = 0;\n        let bitAnd = -1;\n        let bitOr = 0;\n        \n        for (let j = 0; j < N; j++) {\n            if (mask & (1 << j)) {\n                numCount++;\n                bitAnd &= A[j];\n                bitOr |= A[j];\n            }\n        }\n        \n        if (numCount >= 1 && numCount <= K && bitAnd === S && bitOr === T) {\n            ways++;\n        }\n    }\n    \n    return ways;\n}",
    "timestamp": "2025-08-13 11:03:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N, K, S, T = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Precompute for each bit position the count of numbers where the bit is set\n    bit_counts = [0] * 60\n    for num in A:\n        for bit in range(60):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n    \n    # Check for each bit in S and T\n    for bit in range(60):\n        s_bit = (S >> bit) & 1\n        t_bit = (T >> bit) & 1\n        \n        if s_bit == 1 and t_bit == 0:\n            print(0)\n            return\n    \n    # Now, for each bit, determine the constraints\n    # For each bit, the possible conditions:\n    # 1. s_bit = 1, t_bit = 1: All selected numbers must have this bit set\n    # 2. s_bit = 0, t_bit = 1: At least one selected number must have this bit set, but not all necessarily\n    # 3. s_bit = 0, t_bit = 0: No selected numbers can have this bit set\n    \n    # Filter numbers that meet the S and T constraints\n    valid_numbers = []\n    for num in A:\n        valid = True\n        for bit in range(60):\n            s_bit = (S >> bit) & 1\n            t_bit = (T >> bit) & 1\n            num_bit = (num >> bit) & 1\n            \n            if s_bit == 1 and num_bit != 1:\n                valid = False\n                break\n            if t_bit == 0 and num_bit != 0:\n                valid = False\n                break\n        if valid:\n            valid_numbers.append(num)\n    \n    M = len(valid_numbers)\n    if M == 0:\n        print(0)\n        return\n    \n    # Now, for bits where s_bit=0 and t_bit=1, we need at least one number with that bit set in the selection\n    # So, for these bits, the selected numbers must have at least one with the bit set\n    \n    # Identify these bits\n    critical_bits = []\n    for bit in range(60):\n        s_bit = (S >> bit) & 1\n        t_bit = (T >> bit) & 1\n        if s_bit == 0 and t_bit == 1:\n            critical_bits.append(bit)\n    \n    if not critical_bits:\n        # No critical bits, any non-empty subset of valid_numbers is fine\n        total = 0\n        for m in range(1, min(K, M) + 1):\n            # C(M, m)\n            # Precompute factorial and inverse factorial modulo MOD\n            MOD = 10**9 + 7\n            max_n = M\n            fact = [1] * (max_n + 1)\n            inv_fact = [1] * (max_n + 1)\n            for i in range(1, max_n + 1):\n                fact[i] = fact[i-1] * i % MOD\n            inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n            for i in range(max_n - 1, -1, -1):\n                inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n            \n            def comb(n, k):\n                if k < 0 or k > n:\n                    return 0\n                return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n            \n            total = 0\n            for m in range(1, min(K, M) + 1):\n                total = (total + comb(M, m)) % MOD\n            print(total)\n            return\n    \n    # For each critical bit, we need at least one number in the selection with that bit set\n    # Use inclusion-exclusion to count the valid subsets\n    \n    # Let's represent the critical bits as a mask\n    # For each number, we can represent which critical bits it has set\n    \n    # Precompute for each number, the mask of critical bits it has\n    masks = []\n    for num in valid_numbers:\n        mask = 0\n        for i, bit in enumerate(critical_bits):\n            if (num >> bit) & 1:\n                mask |= (1 << i)\n        masks.append(mask)\n    \n    total = 0\n    MOD = 10**9 + 7\n    \n    # Precompute factorial and inverse factorial modulo MOD\n    max_n = M\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    # Inclusion-exclusion over the critical bits\n    # We want subsets that cover all critical bits (i.e., the OR of their masks is all 1's)\n    num_critical = len(critical_bits)\n    full_mask = (1 << num_critical) - 1\n    \n    # For each subset of bits, compute the number of numbers that have at least those bits set\n    # Then, inclusion-exclusion\n    for mask in range(1, 1 << num_critical):\n        bits = bin(mask).count('1')\n        current_mask = mask\n        # Count numbers that have all bits in 'mask' set\n        count = 0\n        for m in masks:\n            if (m & mask) == mask:\n                count += 1\n        \n        # The number of non-empty subsets of size <= K with all bits in mask set is sum_{m=1 to min(K, count)} C(count, m)\n        sum_comb = 0\n        for m in range(1, min(K, count) + 1):\n            sum_comb = (sum_comb + comb(count, m)) % MOD\n        \n        if bits % 2 == 1:\n            total = (total + sum_comb) % MOD\n        else:\n            total = (total - sum_comb) % MOD\n    \n    # Now, the answer is the total for mask = full_mask\n    # But we need to adjust for inclusion-exclusion\n    # So, we need to recompute it properly\n    \n    # Alternative approach: inclusion-exclusion over the subsets of critical bits that are not covered\n    # The answer is sum_{S subset of critical bits} (-1)^{|S|} * (number of subsets that do not cover any bit in S)\n    # Which is sum_{S} (-1)^{|S|} * [sum_{m=1 to K} C(count_no_S, m)]\n    # where count_no_S is the count of numbers that do not have any bit in S set\n    \n    total = 0\n    for subset_mask in range(0, 1 << num_critical):\n        bits = bin(subset_mask).count('1')\n        # The bits in subset_mask are the ones we are ensuring are NOT covered\n        # So, count numbers that have none of the bits in subset_mask set\n        required_mask = subset_mask\n        count = 0\n        for m in masks:\n            if (m & required_mask) == 0:\n                count += 1\n        \n        sum_comb = 0\n        for m in range(1, min(K, count) + 1):\n            sum_comb = (sum_comb + comb(count, m)) % MOD\n        \n        if bits % 2 == 0:\n            total = (total + sum_comb) % MOD\n        else:\n            total = (total - sum_comb) % MOD\n    \n    print(total % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 11:04:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n    const [N, K, S, T] = input[0].split(' ').map(Number);\n    const A = input[1].split(' ').map(Number);\n    \n    let count = 0;\n    \n    for (let mask = 1; mask < (1 << N); mask++) {\n        const selected = [];\n        for (let i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                selected.push(A[i]);\n            }\n        }\n        \n        if (selected.length > K) continue;\n        \n        let andResult = selected[0];\n        let orResult = selected[0];\n        \n        for (let i = 1; i < selected.length; i++) {\n            andResult &= selected[i];\n            orResult |= selected[i];\n        }\n        \n        if (andResult === S && orResult === T) {\n            count++;\n        }\n    }\n    \n    console.log(count);\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:04:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint countWays(vector<int>& A, int N, int K, int S, int T) {\n    int count = 0;\n    int totalSets = 1 << N;\n    for (int mask = 1; mask < totalSets; ++mask) {\n        if (__builtin_popcount(mask) <= K) {\n            int bitwiseOR = 0;\n            int bitwiseAND = (1 << 30) - 1;\n            for (int i = 0; i < N; ++i) {\n                if (mask & (1 << i)) {\n                    bitwiseOR |= A[i];\n                    bitwiseAND &= A[i];\n                }\n            }\n            if (bitwiseOR == T && bitwiseAND == S) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N, K, S, T;\n    cin >> N >> K >> S >> T;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    cout << countWays(A, N, K, S, T) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:18"
  }
]