[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar cube[6][4] = {\n    {'R', 'R', 'R', 'R'},  // Top (Red)\n    {'Y', 'Y', 'Y', 'Y'},  // Front (Yellow)\n    {'B', 'B', 'B', 'B'},  // Right (Blue)\n    {'O', 'O', 'O', 'O'},  // Bottom (Orange)\n    {'W', 'W', 'W', 'W'},  // Back (White)\n    {'G', 'G', 'G', 'G'}   // Left (Green)\n};\n\nvoid rotate_U() {\n    char temp[4];\n    memcpy(temp, cube[1], sizeof(temp));\n    memcpy(cube[1], cube[2], sizeof(temp));\n    memcpy(cube[2], cube[4], sizeof(temp));\n    memcpy(cube[4], cube[5], sizeof(temp));\n    memcpy(cube[5], temp, sizeof(temp));\n    \n    char t[4];\n    memcpy(t, cube[0], sizeof(t));\n    cube[0][0] = t[3];\n    cube[0][1] = t[0];\n    cube[0][2] = t[1];\n    cube[0][3] = t[2];\n}\n\nvoid rotate_F() {\n    char temp[4] = {cube[0][2], cube[0][3], cube[2][0], cube[2][1]};\n    cube[0][2] = cube[5][2];\n    cube[0][3] = cube[5][3];\n    cube[2][0] = temp[0];\n    cube[2][1] = temp[1];\n    cube[5][2] = cube[3][2];\n    cube[5][3] = cube[3][3];\n    cube[3][2] = temp[2];\n    cube[3][3] = temp[3];\n    \n    char t[4];\n    memcpy(t, cube[1], sizeof(t));\n    cube[1][0] = t[3];\n    cube[1][1] = t[0];\n    cube[1][2] = t[1];\n    cube[1][3] = t[2];\n}\n\nvoid rotate_R() {\n    char temp[4] = {cube[0][1], cube[0][3], cube[1][1], cube[1][3]};\n    cube[0][1] = cube[4][1];\n    cube[0][3] = cube[4][3];\n    cube[1][1] = temp[0];\n    cube[1][3] = temp[1];\n    cube[4][1] = cube[3][1];\n    cube[4][3] = cube[3][3];\n    cube[3][1] = temp[2];\n    cube[3][3] = temp[3];\n    \n    char t[4];\n    memcpy(t, cube[2], sizeof(t));\n    cube[2][0] = t[3];\n    cube[2][1] = t[0];\n    cube[2][2] = t[1];\n    cube[2][3] = t[2];\n}\n\nvoid rotate_D() {\n    char temp[4];\n    memcpy(temp, cube[1], sizeof(temp));\n    memcpy(cube[1], cube[5], sizeof(temp));\n    memcpy(cube[5], cube[4], sizeof(temp));\n    memcpy(cube[4], cube[2], sizeof(temp));\n    memcpy(cube[2], temp, sizeof(temp));\n    \n    char t[4];\n    memcpy(t, cube[3], sizeof(t));\n    cube[3][0] = t[3];\n    cube[3][1] = t[0];\n    cube[3][2] = t[1];\n    cube[3][3] = t[2];\n}\n\nvoid rotate_B() {\n    char temp[4] = {cube[0][0], cube[0][1], cube[5][0], cube[5][1]};\n    cube[0][0] = cube[2][2];\n    cube[0][1] = cube[2][3];\n    cube[5][0] = temp[0];\n    cube[5][1] = temp[1];\n    cube[2][2] = cube[3][0];\n    cube[2][3] = cube[3][1];\n    cube[3][0] = temp[2];\n    cube[3][1] = temp[3];\n    \n    char t[4];\n    memcpy(t, cube[4], sizeof(t));\n    cube[4][0] = t[3];\n    cube[4][1] = t[0];\n    cube[4][2] = t[1];\n    cube[4][3] = t[2];\n}\n\nvoid rotate_L() {\n    char temp[4] = {cube[0][0], cube[0][2], cube[1][0], cube[1][2]};\n    cube[0][0] = cube[4][0];\n    cube[0][2] = cube[4][2];\n    cube[1][0] = temp[0];\n    cube[1][2] = temp[1];\n    cube[4][0] = cube[3][0];\n    cube[4][2] = cube[3][2];\n    cube[3][0] = temp[2];\n    cube[3][2] = temp[3];\n    \n    char t[4];\n    memcpy(t, cube[5], sizeof(t));\n    cube[5][0] = t[3];\n    cube[5][1] = t[0];\n    cube[5][2] = t[1];\n    cube[5][3] = t[2];\n}\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n    \n    for (int i = 0; i < strlen(S); i++) {\n        switch (S[i]) {\n            case 'U': rotate_U(); break;\n            case 'F': rotate_F(); break;\n            case 'R': rotate_R(); break;\n            case 'D': rotate_D(); break;\n            case 'B': rotate_B(); break;\n            case 'L': rotate_L(); break;\n        }\n    }\n    \n    for (int i = 0; i < 6; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%c\", cube[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char top[2][2];\n    char front[2][2];\n    char right[2][2];\n    char bottom[2][2];\n    char back[2][2];\n    char left[2][2];\n} Cube;\n\nCube cube;\n\nvoid init_cube() {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            cube.top[i][j] = 'R';\n            cube.front[i][j] = 'Y';\n            cube.right[i][j] = 'B';\n            cube.bottom[i][j] = 'O';\n            cube.back[i][j] = 'W';\n            cube.left[i][j] = 'G';\n        }\n    }\n}\n\nvoid rotate_face_clockwise(char face[2][2]) {\n    char temp = face[0][0];\n    face[0][0] = face[1][0];\n    face[1][0] = face[1][1];\n    face[1][1] = face[0][1];\n    face[0][1] = temp;\n}\n\nvoid rotate_U() {\n    rotate_face_clockwise(cube.top);\n    \n    char temp[2];\n    temp[0] = cube.front[0][0];\n    temp[1] = cube.front[0][1];\n    \n    cube.front[0][0] = cube.right[0][0];\n    cube.front[0][1] = cube.right[0][1];\n    \n    cube.right[0][0] = cube.back[0][0];\n    cube.right[0][1] = cube.back[0][1];\n    \n    cube.back[0][0] = cube.left[0][0];\n    cube.back[0][1] = cube.left[0][1];\n    \n    cube.left[0][0] = temp[0];\n    cube.left[0][1] = temp[1];\n}\n\nvoid rotate_F() {\n    rotate_face_clockwise(cube.front);\n    \n    char temp[2];\n    temp[0] = cube.top[1][0];\n    temp[1] = cube.top[1][1];\n    \n    cube.top[1][0] = cube.left[1][1];\n    cube.top[1][1] = cube.left[0][1];\n    \n    cube.left[0][1] = cube.bottom[0][0];\n    cube.left[1][1] = cube.bottom[0][1];\n    \n    cube.bottom[0][0] = cube.right[1][0];\n    cube.bottom[0][1] = cube.right[0][0];\n    \n    cube.right[0][0] = temp[0];\n    cube.right[1][0] = temp[1];\n}\n\nvoid rotate_R() {\n    rotate_face_clockwise(cube.right);\n    \n    char temp[2];\n    temp[0] = cube.top[0][1];\n    temp[1] = cube.top[1][1];\n    \n    cube.top[0][1] = cube.front[0][1];\n    cube.top[1][1] = cube.front[1][1];\n    \n    cube.front[0][1] = cube.bottom[0][1];\n    cube.front[1][1] = cube.bottom[1][1];\n    \n    cube.bottom[0][1] = cube.back[1][0];\n    cube.bottom[1][1] = cube.back[0][0];\n    \n    cube.back[1][0] = temp[0];\n    cube.back[0][0] = temp[1];\n}\n\nvoid rotate_D() {\n    rotate_face_clockwise(cube.bottom);\n    \n    char temp[2];\n    temp[0] = cube.front[1][0];\n    temp[1] = cube.front[1][1];\n    \n    cube.front[1][0] = cube.left[1][0];\n    cube.front[1][1] = cube.left[1][1];\n    \n    cube.left[1][0] = cube.back[1][0];\n    cube.left[1][1] = cube.back[1][1];\n    \n    cube.back[1][0] = cube.right[1][0];\n    cube.back[1][1] = cube.right[1][1];\n    \n    cube.right[1][0] = temp[0];\n    cube.right[1][1] = temp[1];\n}\n\nvoid rotate_B() {\n    rotate_face_clockwise(cube.back);\n    \n    char temp[2];\n    temp[0] = cube.top[0][0];\n    temp[1] = cube.top[0][1];\n    \n    cube.top[0][0] = cube.right[0][1];\n    cube.top[0][1] = cube.right[1][1];\n    \n    cube.right[0][1] = cube.bottom[1][1];\n    cube.right[1][1] = cube.bottom[1][0];\n    \n    cube.bottom[1][1] = cube.left[1][0];\n    cube.bottom[1][0] = cube.left[0][0];\n    \n    cube.left[1][0] = temp[0];\n    cube.left[0][0] = temp[1];\n}\n\nvoid rotate_L() {\n    rotate_face_clockwise(cube.left);\n    \n    char temp[2];\n    temp[0] = cube.top[0][0];\n    temp[1] = cube.top[1][0];\n    \n    cube.top[0][0] = cube.back[1][1];\n    cube.top[1][0] = cube.back[0][1];\n    \n    cube.back[1][1] = cube.bottom[1][0];\n    cube.back[0][1] = cube.bottom[0][0];\n    \n    cube.bottom[1][0] = cube.front[0][0];\n    cube.bottom[0][0] = cube.front[1][0];\n    \n    cube.front[0][0] = temp[0];\n    cube.front[1][0] = temp[1];\n}\n\nvoid apply_rotation(char move) {\n    switch (move) {\n        case 'U': rotate_U(); break;\n        case 'F': rotate_F(); break;\n        case 'R': rotate_R(); break;\n        case 'D': rotate_D(); break;\n        case 'B': rotate_B(); break;\n        case 'L': rotate_L(); break;\n    }\n}\n\nvoid print_development() {\n    // Top\n    for (int i = 0; i < 2; i++) {\n        printf(\"  \");\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.top[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // Left, Front, Right, Back\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.left[i][j]);\n        }\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.front[i][j]);\n        }\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.right[i][j]);\n        }\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.back[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    // Bottom\n    for (int i = 0; i < 2; i++) {\n        printf(\"  \");\n        for (int j = 0; j < 2; j++) {\n            printf(\"%c\", cube.bottom[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    char S[100];\n    scanf(\"%s\", S);\n    \n    init_cube();\n    \n    for (int i = 0; S[i] != '\\0'; i++) {\n        apply_rotation(S[i]);\n    }\n    \n    print_development();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid rotate_face(vector<vector<char>>& face) {\n    vector<vector<char>> temp = face;\n    int n = face.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            face[j][n - 1 - i] = temp[i][j];\n        }\n    }\n}\n\nvoid rotate_adjacent(vector<vector<char>>& up, vector<vector<char>>& front, vector<vector<char>>& down, vector<vector<char>>& back, vector<vector<char>>& left, vector<vector<char>>& right, char move) {\n    vector<char> temp(2);\n    switch (move) {\n        case 'U':\n            temp[0] = front[0][0];\n            temp[1] = front[0][1];\n            front[0][0] = right[0][0];\n            front[0][1] = right[0][1];\n            right[0][0] = back[0][0];\n            right[0][1] = back[0][1];\n            back[0][0] = left[0][0];\n            back[0][1] = left[0][1];\n            left[0][0] = temp[0];\n            left[0][1] = temp[1];\n            rotate_face(up);\n            break;\n        case 'F':\n            temp[0] = up[1][0];\n            temp[1] = up[1][1];\n            up[1][0] = left[1][1];\n            up[1][1] = left[0][1];\n            left[1][1] = down[0][1];\n            left[0][1] = down[0][0];\n            down[0][1] = right[1][0];\n            down[0][0] = right[0][0];\n            right[1][0] = temp[0];\n            right[0][0] = temp[1];\n            rotate_face(front);\n            break;\n        case 'R':\n            temp[0] = up[0][1];\n            temp[1] = up[1][1];\n            up[0][1] = front[0][1];\n            up[1][1] = front[1][1];\n            front[0][1] = down[0][1];\n            front[1][1] = down[1][1];\n            down[0][1] = back[1][0];\n            down[1][1] = back[0][0];\n            back[1][0] = temp[0];\n            back[0][0] = temp[1];\n            rotate_face(right);\n            break;\n        case 'D':\n            temp[0] = front[1][0];\n            temp[1] = front[1][1];\n            front[1][0] = left[1][0];\n            front[1][1] = left[1][1];\n            left[1][0] = back[1][0];\n            left[1][1] = back[1][1];\n            back[1][0] = right[1][0];\n            back[1][1] = right[1][1];\n            right[1][0] = temp[0];\n            right[1][1] = temp[1];\n            rotate_face(down);\n            break;\n        case 'B':\n            temp[0] = up[0][0];\n            temp[1] = up[0][1];\n            up[0][0] = right[0][1];\n            up[0][1] = right[1][1];\n            right[0][1] = down[1][1];\n            right[1][1] = down[1][0];\n            down[1][1] = left[1][0];\n            down[1][0] = left[0][0];\n            left[1][0] = temp[0];\n            left[0][0] = temp[1];\n            rotate_face(back);\n            break;\n        case 'L':\n            temp[0] = up[0][0];\n            temp[1] = up[1][0];\n            up[0][0] = back[0][1];\n            up[1][0] = back[1][1];\n            back[0][1] = down[0][0];\n            back[1][1] = down[1][0];\n            down[0][0] = front[0][0];\n            down[1][0] = front[1][0];\n            front[0][0] = temp[0];\n            front[1][0] = temp[1];\n            rotate_face(left);\n            break;\n    }\n}\n\nint main() {\n    vector<vector<char>> up = {{'r', 'r'}, {'r', 'r'}};\n    vector<vector<char>> front = {{'y', 'y'}, {'y', 'y'}};\n    vector<vector<char>> right = {{'b', 'b'}, {'b', 'b'}};\n    vector<vector<char>> down = {{'o', 'o'}, {'o', 'o'}};\n    vector<vector<char>> back = {{'w', 'w'}, {'w', 'w'}};\n    vector<vector<char>> left = {{'g', 'g'}, {'g', 'g'}};\n\n    string S;\n    cin >> S;\n\n    for (char move : S) {\n        rotate_adjacent(up, front, down, back, left, right, move);\n    }\n\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << up[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << front[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << right[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << down[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << back[i][j];\n        }\n        cout << endl;\n    }\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            cout << left[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RubiksCube2x2 {\n    static class Face {\n        char[][] colors;\n        \n        Face(char color) {\n            colors = new char[2][2];\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < 2; j++) {\n                    colors[i][j] = color;\n                }\n            }\n        }\n        \n        void rotateClockwise() {\n            char temp = colors[0][0];\n            colors[0][0] = colors[1][0];\n            colors[1][0] = colors[1][1];\n            colors[1][1] = colors[0][1];\n            colors[0][1] = temp;\n        }\n        \n        void rotateCounterClockwise() {\n            char temp = colors[0][0];\n            colors[0][0] = colors[0][1];\n            colors[0][1] = colors[1][1];\n            colors[1][1] = colors[1][0];\n            colors[1][0] = temp;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        \n        Face up = new Face('R');\n        Face front = new Face('Y');\n        Face right = new Face('B');\n        Face down = new Face('O');\n        Face back = new Face('W');\n        Face left = new Face('G');\n        \n        for (char move : S.toCharArray()) {\n            switch (move) {\n                case 'U':\n                    char[] temp = {front.colors[0][0], front.colors[0][1]};\n                    front.colors[0][0] = right.colors[0][0];\n                    front.colors[0][1] = right.colors[0][1];\n                    right.colors[0][0] = back.colors[0][0];\n                    right.colors[0][1] = back.colors[0][1];\n                    back.colors[0][0] = left.colors[0][0];\n                    back.colors[0][1] = left.colors[0][1];\n                    left.colors[0][0] = temp[0];\n                    left.colors[0][1] = temp[1];\n                    up.rotateClockwise();\n                    break;\n                case 'F':\n                    temp = new char[]{up.colors[1][0], up.colors[1][1]};\n                    up.colors[1][0] = left.colors[1][1];\n                    up.colors[1][1] = left.colors[0][1];\n                    left.colors[0][1] = down.colors[0][0];\n                    left.colors[1][1] = down.colors[0][1];\n                    down.colors[0][0] = right.colors[1][0];\n                    down.colors[0][1] = right.colors[0][0];\n                    right.colors[0][0] = temp[0];\n                    right.colors[1][0] = temp[1];\n                    front.rotateClockwise();\n                    break;\n                case 'R':\n                    temp = new char[]{up.colors[0][1], up.colors[1][1]};\n                    up.colors[0][1] = front.colors[0][1];\n                    up.colors[1][1] = front.colors[1][1];\n                    front.colors[0][1] = down.colors[0][1];\n                    front.colors[1][1] = down.colors[1][1];\n                    down.colors[0][1] = back.colors[1][0];\n                    down.colors[1][1] = back.colors[0][0];\n                    back.colors[1][0] = temp[0];\n                    back.colors[0][0] = temp[1];\n                    right.rotateClockwise();\n                    break;\n                case 'D':\n                    temp = new char[]{front.colors[1][0], front.colors[1][1]};\n                    front.colors[1][0] = left.colors[1][0];\n                    front.colors[1][1] = left.colors[1][1];\n                    left.colors[1][0] = back.colors[1][0];\n                    left.colors[1][1] = back.colors[1][1];\n                    back.colors[1][0] = right.colors[1][0];\n                    back.colors[1][1] = right.colors[1][1];\n                    right.colors[1][0] = temp[0];\n                    right.colors[1][1] = temp[1];\n                    down.rotateClockwise();\n                    break;\n                case 'B':\n                    temp = new char[]{up.colors[0][0], up.colors[0][1]};\n                    up.colors[0][0] = right.colors[0][1];\n                    up.colors[0][1] = right.colors[1][1];\n                    right.colors[0][1] = down.colors[1][1];\n                    right.colors[1][1] = down.colors[1][0];\n                    down.colors[1][1] = left.colors[1][0];\n                    down.colors[1][0] = left.colors[0][0];\n                    left.colors[1][0] = temp[0];\n                    left.colors[0][0] = temp[1];\n                    back.rotateClockwise();\n                    break;\n                case 'L':\n                    temp = new char[]{up.colors[0][0], up.colors[1][0]};\n                    up.colors[0][0] = back.colors[1][1];\n                    up.colors[1][0] = back.colors[0][1];\n                    back.colors[1][1] = down.colors[0][0];\n                    back.colors[0][1] = down.colors[1][0];\n                    down.colors[0][0] = front.colors[0][0];\n                    down.colors[1][0] = front.colors[1][0];\n                    front.colors[0][0] = temp[0];\n                    front.colors[1][0] = temp[1];\n                    left.rotateClockwise();\n                    break;\n            }\n        }\n        \n        System.out.println(\"..\" + up.colors[0][0] + up.colors[0][1] + \"..\");\n        System.out.println(\"..\" + up.colors[1][0] + up.colors[1][1] + \"..\");\n        System.out.println(left.colors[0][0] + left.colors[0][1] + front.colors[0][0] + front.colors[0][1] + right.colors[0][0] + right.colors[0][1] + back.colors[0][0] + back.colors[0][1]);\n        System.out.println(left.colors[1][0] + left.colors[1][1] + front.colors[1][0] + front.colors[1][1] + right.colors[1][0] + right.colors[1][1] + back.colors[1][0] + back.colors[1][1]);\n        System.out.println(\"..\" + down.colors[0][0] + down.colors[0][1] + \"..\");\n        System.out.println(\"..\" + down.colors[1][0] + down.colors[1][1] + \"..\");\n    }\n}",
    "timestamp": "2025-08-05 21:50:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RubiksCube {\n    private static final String[] INITIAL_COLORS = {\n        \"RRRR\", \"YYYY\", \"BBBB\", \"OOOO\", \"WWWW\", \"GGGG\"\n    };\n\n    private static String[] rotateClockwise(String[] cube, char face) {\n        String[] newCube = cube.clone();\n        switch (face) {\n            case 'U':\n                newCube[0] = cube[0].charAt(2) + cube[0].substring(0, 3);\n                newCube[2] = cube[5].charAt(0) + cube[5].charAt(3) + cube[2].substring(2);\n                newCube[4] = cube[2].charAt(0) + cube[2].charAt(3) + cube[4].substring(2);\n                newCube[5] = cube[4].charAt(0) + cube[4].charAt(3) + cube[5].substring(2);\n                break;\n            case 'F':\n                newCube[1] = cube[1].charAt(2) + cube[1].substring(0, 3);\n                newCube[0] = cube[0].substring(0, 2) + cube[5].substring(2, 4);\n                newCube[2] = cube[5].substring(0, 2) + cube[2].substring(2);\n                newCube[4] = cube[4].substring(0, 2) + cube[0].substring(2, 4);\n                newCube[5] = cube[4].substring(2, 4) + cube[5].substring(2);\n                break;\n            case 'R':\n                newCube[2] = cube[2].charAt(2) + cube[2].substring(0, 3);\n                newCube[0] = cube[0].substring(0, 1) + cube[4].charAt(3) + \n                             cube[0].substring(2, 3) + cube[0].charAt(3);\n                newCube[1] = cube[1].substring(0, 1) + cube[0].charAt(3) + \n                             cube[1].substring(2, 3) + cube[1].charAt(3);\n                newCube[4] = cube[4].substring(0, 3) + cube[1].charAt(3);\n                break;\n            case 'D':\n                newCube[4] = cube[4].charAt(2) + cube[4].substring(0, 3);\n                newCube[2] = cube[2].substring(0, 2) + cube[5].substring(2, 4);\n                newCube[0] = cube[5].substring(0, 2) + cube[0].substring(2);\n                newCube[5] = cube[4].substring(2, 4) + cube[5].substring(2);\n                break;\n            case 'B':\n                newCube[3] = cube[3].charAt(2) + cube[3].substring(0, 3);\n                newCube[0] = cube[5].charAt(3) + cube[0].substring(1, 3) + \n                             cube[5].charAt(2);\n                newCube[2] = cube[2].substring(0, 2) + cube[0].substring(2, 4);\n                newCube[4] = cube[0].charAt(2) + cube[0].charAt(3) + \n                             cube[4].substring(2);\n                newCube[5] = cube[4].substring(2, 4) + cube[5].substring(2);\n                break;\n            case 'L':\n                newCube[5] = cube[5].charAt(2) + cube[5].substring(0, 3);\n                newCube[0] = cube[1].charAt(0) + cube[0].substring(1, 3) + \n                             cube[0].charAt(3);\n                newCube[1] = cube[4].charAt(0) + cube[1].substring(1, 3) + \n                             cube[1].charAt(3);\n                newCube[4] = cube[3].charAt(3) + cube[4].substring(1);\n                break;\n        }\n        return newCube;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String scramble = scanner.nextLine();\n        String[] cube = INITIAL_COLORS.clone();\n\n        for (char rotation : scramble.toCharArray()) {\n            cube = rotateClockwise(cube, rotation);\n        }\n\n        for (String face : cube) {\n            System.out.println(face);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:50:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass RubiksCube {\nprivate:\n    vector<vector<string>> faces;\n\npublic:\n    RubiksCube() {\n        faces = {\n            {\"R\", \"R\", \"R\", \"R\"},  // U (top)\n            {\"Y\", \"Y\", \"Y\", \"Y\"},  // F (front)\n            {\"B\", \"B\", \"B\", \"B\"},  // R (right)\n            {\"O\", \"O\", \"O\", \"O\"},  // D (bottom)\n            {\"W\", \"W\", \"W\", \"W\"},  // B (back)\n            {\"G\", \"G\", \"G\", \"G\"}   // L (left)\n        };\n    }\n\n    void rotateU() {\n        vector<string> temp = faces[1];\n        faces[1] = faces[2];\n        faces[2] = faces[4];\n        faces[4] = faces[5];\n        faces[5] = temp;\n        rotateFaceClockwise(0);\n    }\n\n    void rotateF() {\n        vector<string> temp = {faces[0][2], faces[0][3], faces[2][0], faces[2][1]};\n        faces[0][2] = faces[5][3]; faces[0][3] = faces[5][2];\n        faces[2][0] = faces[0][2]; faces[2][1] = faces[0][3];\n        faces[5][3] = faces[3][1]; faces[5][2] = faces[3][0];\n        faces[3][1] = temp[1]; faces[3][0] = temp[0];\n        rotateFaceClockwise(1);\n    }\n\n    void rotateR() {\n        vector<string> temp = {faces[0][1], faces[0][3], faces[1][1], faces[1][3]};\n        faces[0][1] = faces[4][2]; faces[0][3] = faces[4][0];\n        faces[1][1] = faces[0][1]; faces[1][3] = faces[0][3];\n        faces[4][2] = faces[3][2]; faces[4][0] = faces[3][0];\n        faces[3][2] = temp[1]; faces[3][0] = temp[0];\n        rotateFaceClockwise(2);\n    }\n\n    void rotateD() {\n        vector<string> temp = faces[1];\n        faces[1] = faces[5];\n        faces[5] = faces[4];\n        faces[4] = faces[2];\n        faces[2] = temp;\n        rotateFaceClockwise(3);\n    }\n\n    void rotateB() {\n        vector<string> temp = {faces[0][0], faces[0][1], faces[5][0], faces[5][1]};\n        faces[0][0] = faces[2][2]; faces[0][1] = faces[2][3];\n        faces[5][0] = faces[0][0]; faces[5][1] = faces[0][1];\n        faces[2][2] = faces[3][3]; faces[2][3] = faces[3][2];\n        faces[3][3] = temp[1]; faces[3][2] = temp[0];\n        rotateFaceClockwise(4);\n    }\n\n    void rotateL() {\n        vector<string> temp = {faces[0][0], faces[0][2], faces[1][0], faces[1][2]};\n        faces[0][0] = faces[1][0]; faces[0][2] = faces[1][2];\n        faces[1][0] = faces[3][1]; faces[1][2] = faces[3][3];\n        faces[3][1] = faces[4][1]; faces[3][3] = faces[4][3];\n        faces[4][1] = temp[0]; faces[4][3] = temp[2];\n        rotateFaceClockwise(5);\n    }\n\n    void rotateFaceClockwise(int faceIndex) {\n        string temp = faces[faceIndex][0];\n        faces[faceIndex][0] = faces[faceIndex][2];\n        faces[faceIndex][2] = faces[faceIndex][3];\n        faces[faceIndex][3] = faces[faceIndex][1];\n        faces[faceIndex][1] = temp;\n    }\n\n    void executeRotation(char move) {\n        switch(move) {\n            case 'U': rotateU(); break;\n            case 'F': rotateF(); break;\n            case 'R': rotateR(); break;\n            case 'D': rotateD(); break;\n            case 'B': rotateB(); break;\n            case 'L': rotateL(); break;\n        }\n    }\n\n    void printCube() {\n        for (const auto& face : faces) {\n            for (const auto& color : face) {\n                cout << color << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    string S;\n    cin >> S;\n\n    RubiksCube cube;\n    for (char move : S) {\n        cube.executeRotation(move);\n    }\n\n    cube.printCube();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def rotate_face(face, direction):\n    return [face[2], face[0], face[3], face[1]] if direction == 'cw' else [face[1], face[3], face[0], face[2]]\n\ndef rotate_cube(cube, move):\n    top, front, right, bottom, back, left = cube\n    if move == 'U':\n        top = rotate_face(top, 'cw')\n        front[0], right[0], back[0], left[0] = left[0], front[0], right[0], back[0]\n    elif move == 'F':\n        front = rotate_face(front, 'cw')\n        top[3], right[1], bottom[0], left[2] = left[2], top[3], right[1], bottom[0]\n    elif move == 'R':\n        right = rotate_face(right, 'cw')\n        top[2], back[3], bottom[2], front[3] = front[3], top[2], bottom[2], back[3]\n    elif move == 'D':\n        bottom = rotate_face(bottom, 'cw')\n        front[2], left[2], back[2], right[2] = right[2], front[2], left[2], back[2]\n    elif move == 'B':\n        back = rotate_face(back, 'cw')\n        top[1], left[1], bottom[3], right[3] = right[3], top[1], left[1], bottom[3]\n    elif move == 'L':\n        left = rotate_face(left, 'cw')\n        top[0], back[1], bottom[1], front[0] = back[1], bottom[1], front[0], top[0]\n    return [top, front, right, bottom, back, left]\n\ndef scramble_cube(scramble_sequence):\n    # Initial cube state\n    cube = [\n        ['R', 'R', 'R', 'R'],  # Top (U)\n        ['Y', 'Y', 'Y', 'Y'],  # Front (F)\n        ['B', 'B', 'B', 'B'],  # Right (R)\n        ['O', 'O', 'O', 'O'],  # Bottom (D)\n        ['W', 'W', 'W', 'W'],  # Back (B)\n        ['G', 'G', 'G', 'G']   # Left (L)\n    ]\n\n    for move in scramble_sequence:\n        cube = rotate_cube(cube, move)\n    \n    return cube\n\ndef print_cube(cube):\n    top, front, right, bottom, back, left = cube\n    result = [\n        ' '.join(top),\n        ' '.join(front),\n        ' '.join(right),\n        ' '.join(bottom),\n        ' '.join(back),\n        ' '.join(left)\n    ]\n    return '\\n'.join(result)\n\n# Example usage:\nscramble = \"UFDRBL\"\nscrambled_cube = scramble_cube(scramble)\nprint(print_cube(scrambled_cube))",
    "timestamp": "2025-08-13 07:10:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class RubiksCube {\n    private static final char[][] initialCube = {\n        {'R', 'R', 'R', 'R'}, // Top (U)\n        {'Y', 'Y', 'Y', 'Y'}, // Front (F)\n        {'B', 'B', 'B', 'B'}, // Right (R)\n        {'O', 'O', 'O', 'O'}, // Down (D)\n        {'W', 'W', 'W', 'W'}, // Back (B)\n        {'G', 'G', 'G', 'G'}  // Left (L)\n    };\n\n    private char[][] cube;\n\n    public RubiksCube() {\n        resetCube();\n    }\n\n    private void resetCube() {\n        cube = new char[6][4];\n        for (int i = 0; i < 6; i++) {\n            System.arraycopy(initialCube[i], 0, cube[i], 0, 4);\n        }\n    }\n\n    private void rotateFace(int face) {\n        char temp = cube[face][0];\n        cube[face][0] = cube[face][2];\n        cube[face][2] = cube[face][3];\n        cube[face][3] = cube[face][1];\n        cube[face][1] = temp;\n    }\n\n    private void applyRotation(char rotation) {\n        switch (rotation) {\n            case 'U':\n                rotateFace(0);\n                swapEdges(5, 0, 2, 2, 3, 0, 1, 2);\n                break;\n            case 'F':\n                rotateFace(1);\n                swapEdges(0, 2, 3, 0, 2, 0, 5, 1);\n                break;\n            case 'R':\n                rotateFace(2);\n                swapEdges(0, 1, 4, 0, 1, 3, 2, 1);\n                break;\n            case 'D':\n                rotateFace(3);\n                swapEdges(1, 2, 2, 2, 3, 2, 4, 2);\n                break;\n            case 'B':\n                rotateFace(4);\n                swapEdges(0, 0, 5, 0, 3, 3, 1, 0);\n                break;\n            case 'L':\n                rotateFace(5);\n                swapEdges(0, 3, 1, 3, 3, 1, 4, 3);\n                break;\n        }\n    }\n\n    private void swapEdges(int a, int indexA, int b, int indexB, int c, int indexC, int d, int indexD) {\n        char temp = cube[a][indexA];\n        cube[a][indexA] = cube[b][indexB];\n        cube[b][indexB] = cube[c][indexC];\n        cube[c][indexC] = cube[d][indexD];\n        cube[d][indexD] = temp;\n\n        temp = cube[a][indexA + 1];\n        cube[a][indexA + 1] = cube[b][indexB + 1];\n        cube[b][indexB + 1] = cube[c][indexC + 1];\n        cube[c][indexC + 1] = cube[d][indexD + 1];\n        cube[d][indexD + 1] = temp;\n    }\n\n    public void scramble(String operations) {\n        for (char op : operations.toCharArray()) {\n            applyRotation(op);\n        }\n    }\n\n    public void printCube() {\n        for (char[] face : cube) {\n            System.out.println(new String(face));\n        }\n    }\n\n    public static void main(String[] args) {\n        RubiksCube cube = new RubiksCube();\n        cube.scramble(\"RUR'U'\");\n        cube.printCube();\n    }\n}",
    "timestamp": "2025-08-13 07:11:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n// Define face indices\n#define U 0\n#define F 1\n#define R 2\n#define D 3\n#define B 4\n#define L 5\n\n// Define colors\nchar *initialColors[] = {\"Red\", \"Yellow\", \"Blue\", \"Orange\", \"White\", \"Green\"};\nchar faces[6][2][2];\n\nvoid rotateFaceCW(int face) {\n    char temp = faces[face][0][0];\n    faces[face][0][0] = faces[face][1][0];\n    faces[face][1][0] = faces[face][1][1];\n    faces[face][1][1] = faces[face][0][1];\n    faces[face][0][1] = temp;\n}\n\nvoid rotateU() {\n    rotateFaceCW(U);\n\n    char temp[2];\n    memcpy(temp, faces[F][0], 2);\n    memcpy(faces[F][0], faces[L][0], 2);\n    memcpy(faces[L][0], faces[B][0], 2);\n    memcpy(faces[B][0], faces[R][0], 2);\n    memcpy(faces[R][0], temp, 2);\n}\n\nvoid rotateF() {\n    rotateFaceCW(F);\n\n    char temp[2];\n    temp[0] = faces[U][1][0];\n    temp[1] = faces[U][1][1];\n    \n    faces[U][1][0] = faces[L][1][1];\n    faces[U][1][1] = faces[L][0][1];\n    \n    faces[L][0][1] = faces[D][0][0];\n    faces[L][1][1] = faces[D][0][1];\n    \n    faces[D][0][0] = faces[R][0][0];\n    faces[D][0][1] = faces[R][1][0];\n    \n    faces[R][0][0] = temp[1];\n    faces[R][1][0] = temp[0];\n}\n\nvoid rotateR() {\n    rotateFaceCW(R);\n\n    char temp[2];\n    temp[0] = faces[U][0][1];\n    temp[1] = faces[U][1][1];\n\n    faces[U][0][1] = faces[F][0][1];\n    faces[U][1][1] = faces[F][1][1];\n\n    faces[F][0][1] = faces[D][0][1];\n    faces[F][1][1] = faces[D][1][1];\n\n    faces[D][0][1] = faces[B][1][0];\n    faces[D][1][1] = faces[B][0][0];\n\n    faces[B][0][0] = temp[0];\n    faces[B][1][0] = temp[1];\n}\n\nvoid rotateD() {\n    rotateFaceCW(D);\n\n    char temp[2];\n    memcpy(temp, faces[F][1], 2);\n    memcpy(faces[F][1], faces[R][1], 2);\n    memcpy(faces[R][1], faces[B][1], 2);\n    memcpy(faces[B][1], faces[L][1], 2);\n    memcpy(faces[L][1], temp, 2);\n}\n\nvoid rotateB() {\n    rotateFaceCW(B);\n\n    char temp[2];\n    temp[0] = faces[U][0][0];\n    temp[1] = faces[U][0][1];\n\n    faces[U][0][0] = faces[R][0][1];\n    faces[U][0][1] = faces[R][1][1];\n\n    faces[R][0][1] = faces[D][1][1];\n    faces[R][1][1] = faces[D][1][0];\n\n    faces[D][1][1] = faces[L][1][0];\n    faces[D][1][0] = faces[L][0][0];\n\n    faces[L][1][0] = temp[1];\n    faces[L][0][0] = temp[0];\n}\n\nvoid rotateL() {\n    rotateFaceCW(L);\n\n    char temp[2];\n    temp[0] = faces[U][0][0];\n    temp[1] = faces[U][1][0];\n\n    faces[U][0][0] = faces[B][1][1];\n    faces[U][1][0] = faces[B][0][1];\n\n    faces[B][0][1] = faces[D][1][0];\n    faces[B][1][1] = faces[D][0][0];\n\n    faces[D][0][0] = faces[F][0][0];\n    faces[D][1][0] = faces[F][1][0];\n\n    faces[F][0][0] = temp[0];\n    faces[F][1][0] = temp[1];\n}\n\nvoid applyScramble(char *scramble) {\n    for (int i = 0; i < strlen(scramble); i++) {\n        switch(scramble[i]) {\n            case 'U': rotateU(); break;\n            case 'F': rotateF(); break;\n            case 'R': rotateR(); break;\n            case 'D': rotateD(); break;\n            case 'B': rotateB(); break;\n            case 'L': rotateL(); break;\n        }\n    }\n}\n\nvoid printCube() {\n    for(int i = 0; i < 6; i++) {\n        printf(\"%s:\\n\", initialColors[i]);\n        printf(\"%c %c\\n\", faces[i][0][0], faces[i][0][1]);\n        printf(\"%c %c\\n\\n\", faces[i][1][0], faces[i][1][1]);\n    }\n}\n\nint main() {\n    // Initialize the cube\n    for(int i = 0; i < 6; i++) {\n        for(int j = 0; j < 2; j++) {\n            for(int k = 0; k < 2; k++) {\n                faces[i][j][k] = initialColors[i][0];\n            }\n        }\n    }\n\n    // Sample scramble input\n    char scramble[] = \"UFRBLD\";\n    applyScramble(scramble);\n    printCube();\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:11:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def rotate_face(face, direction):\n    if direction == 'clockwise':\n        return [face[2], face[0], face[3], face[1]]\n    else:\n        return [face[1], face[3], face[0], face[2]]\n\ndef apply_rotation(cube, rotation):\n    new_cube = cube.copy()\n    if rotation == 'U':\n        new_cube['top'] = rotate_face(cube['top'], 'clockwise')\n        temp = cube['front'][0:2]\n        new_cube['front'][0:2] = cube['right'][0:2]\n        new_cube['right'][0:2] = cube['back'][0:2]\n        new_cube['back'][0:2] = cube['left'][0:2]\n        new_cube['left'][0:2] = temp\n    elif rotation == 'F':\n        new_cube['front'] = rotate_face(cube['front'], 'clockwise')\n        temp = [cube['top'][2], cube['top'][3]]\n        new_cube['top'][2:4] = [cube['right'][0], cube['right'][2]]\n        new_cube['right'][0] = cube['bottom'][1]\n        new_cube['right'][2] = cube['bottom'][0]\n        new_cube['bottom'][0:2] = [cube['left'][3], cube['left'][1]]\n        new_cube['left'][1] = temp[0]\n        new_cube['left'][3] = temp[1]\n    elif rotation == 'R':\n        new_cube['right'] = rotate_face(cube['right'], 'clockwise')\n        temp = [cube['top'][1], cube['top'][3]]\n        new_cube['top'][1] = cube['back'][3]\n        new_cube['top'][3] = cube['back'][1]\n        new_cube['back'][1] = cube['bottom'][1]\n        new_cube['back'][3] = cube['bottom'][3]\n        new_cube['bottom'][1] = cube['front'][1]\n        new_cube['bottom'][3] = cube['front'][3]\n        new_cube['front'][1] = temp[0]\n        new_cube['front'][3] = temp[1]\n    elif rotation == 'D':\n        new_cube['bottom'] = rotate_face(cube['bottom'], 'clockwise')\n        temp = cube['front'][2:4]\n        new_cube['front'][2:4] = cube['left'][2:4]\n        new_cube['left'][2:4] = cube['back'][2:4]\n        new_cube['back'][2:4] = cube['right'][2:4]\n        new_cube['right'][2:4] = temp\n    elif rotation == 'B':\n        new_cube['back'] = rotate_face(cube['back'], 'clockwise')\n        temp = [cube['top'][0], cube['top'][1]]\n        new_cube['top'][0:2] = [cube['left'][2], cube['left'][0]]\n        new_cube['left'][0] = cube['bottom'][3]\n        new_cube['left'][2] = cube['bottom'][2]\n        new_cube['bottom'][2:4] = [cube['right'][1], cube['right'][3]]\n        new_cube['right'][1] = temp[1]\n        new_cube['right'][3] = temp[0]\n    elif rotation == 'L':\n        new_cube['left'] = rotate_face(cube['left'], 'clockwise')\n        temp = [cube['top'][0], cube['top'][2]]\n        new_cube['top'][0] = cube['front'][0]\n        new_cube['top'][2] = cube['front'][2]\n        new_cube['front'][0] = cube['bottom'][0]\n        new_cube['front'][2] = cube['bottom'][2]\n        new_cube['bottom'][0] = cube['back'][2]\n        new_cube['bottom'][2] = cube['back'][0]\n        new_cube['back'][0] = temp[1]\n        new_cube['back'][2] = temp[0]\n    return new_cube\n\ndef solve_rubiks_cube(operations):\n    initial_cube = {\n        'top': ['r', 'r', 'r', 'r'],\n        'front': ['y', 'y', 'y', 'y'],\n        'right': ['b', 'b', 'b', 'b'],\n        'bottom': ['o', 'o', 'o', 'o'],\n        'back': ['w', 'w', 'w', 'w'],\n        'left': ['g', 'g', 'g', 'g']\n    }\n    \n    for op in operations:\n        initial_cube = apply_rotation(initial_cube, op)\n    \n    return initial_cube\n\n# Read input\noperations = input().strip()\nresult = solve_rubiks_cube(operations)\n\n# Print result\nfor face in ['top', 'front', 'right', 'bottom', 'back', 'left']:\n    print(''.join(result[face]))",
    "timestamp": "2025-08-13 07:12:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    # Initialize the cube faces\n    cube = {\n        'U': [['r']*2 for _ in range(2)],  # Up (Red)\n        'D': [['o']*2 for _ in range(2)],  # Down (Orange)\n        'F': [['y']*2 for _ in range(2)],  # Front (Yellow)\n        'B': [['w']*2 for _ in range(2)],  # Back (White)\n        'L': [['g']*2 for _ in range(2)],  # Left (Green)\n        'R': [['b']*2 for _ in range(2)]   # Right (Blue)\n    }\n    \n    # Define rotation mappings for each face\n    def rotate_face(face):\n        # Rotate the face itself clockwise\n        face[0][0], face[0][1], face[1][1], face[1][0] = face[1][0], face[0][0], face[0][1], face[1][1]\n    \n    def U():\n        rotate_face(cube['U'])\n        # Adjust the adjacent faces\n        temp = [cube['F'][0][0], cube['F'][0][1]]\n        cube['F'][0][0], cube['F'][0][1] = cube['R'][0][0], cube['R'][0][1]\n        cube['R'][0][0], cube['R'][0][1] = cube['B'][0][0], cube['B'][0][1]\n        cube['B'][0][0], cube['B'][0][1] = cube['L'][0][0], cube['L'][0][1]\n        cube['L'][0][0], cube['L'][0][1] = temp[0], temp[1]\n    \n    def F():\n        rotate_face(cube['F'])\n        temp = [cube['U'][1][0], cube['U'][1][1]]\n        cube['U'][1][0], cube['U'][1][1] = cube['L'][1][1], cube['L'][0][1]\n        cube['L'][1][1], cube['L'][0][1] = cube['D'][0][1], cube['D'][0][0]\n        cube['D'][0][1], cube['D'][0][0] = cube['R'][0][0], cube['R'][1][0]\n        cube['R'][0][0], cube['R'][1][0] = temp[0], temp[1]\n    \n    def R():\n        rotate_face(cube['R'])\n        temp = [cube['U'][0][1], cube['U'][1][1]]\n        cube['U'][0][1], cube['U'][1][1] = cube['F'][0][1], cube['F'][1][1]\n        cube['F'][0][1], cube['F'][1][1] = cube['D'][0][1], cube['D'][1][1]\n        cube['D'][0][1], cube['D'][1][1] = cube['B'][1][0], cube['B'][0][0]\n        cube['B'][1][0], cube['B'][0][0] = temp[0], temp[1]\n    \n    def D():\n        rotate_face(cube['D'])\n        temp = [cube['F'][1][0], cube['F'][1][1]]\n        cube['F'][1][0], cube['F'][1][1] = cube['L'][1][0], cube['L'][1][1]\n        cube['L'][1][0], cube['L'][1][1] = cube['B'][1][0], cube['B'][1][1]\n        cube['B'][1][0], cube['B'][1][1] = cube['R'][1][0], cube['R'][1][1]\n        cube['R'][1][0], cube['R'][1][1] = temp[0], temp[1]\n    \n    def B():\n        rotate_face(cube['B'])\n        temp = [cube['U'][0][0], cube['U'][0][1]]\n        cube['U'][0][0], cube['U'][0][1] = cube['R'][0][1], cube['R'][1][1]\n        cube['R'][0][1], cube['R'][1][1] = cube['D'][1][1], cube['D'][1][0]\n        cube['D'][1][1], cube['D'][1][0] = cube['L'][1][0], cube['L'][0][0]\n        cube['L'][1][0], cube['L'][0][0] = temp[0], temp[1]\n    \n    def L():\n        rotate_face(cube['L'])\n        temp = [cube['U'][0][0], cube['U'][1][0]]\n        cube['U'][0][0], cube['U'][1][0] = cube['B'][0][1], cube['B'][1][1]\n        cube['B'][0][1], cube['B'][1][1] = cube['D'][1][0], cube['D'][0][0]\n        cube['D'][1][0], cube['D'][0][0] = cube['F'][0][0], cube['F'][1][0]\n        cube['F'][0][0], cube['F'][1][0] = temp[0], temp[1]\n    \n    # Map each move to its corresponding function\n    moves = {\n        'U': U,\n        'F': F,\n        'R': R,\n        'D': D,\n        'B': B,\n        'L': L\n    }\n    \n    S = input().strip()\n    for move in S:\n        moves[move]()\n    \n    # Print the development diagram\n    print(\"\".join(cube['U'][0] + cube['U'][1]))\n    print(\"\".join(cube['F'][0] + cube['F'][1]))\n    print(\"\".join(cube['R'][0] + cube['R'][1]))\n    print(\"\".join(cube['D'][0] + cube['D'][1]))\n    print(\"\".join(cube['B'][0] + cube['B'][1]))\n    print(\"\".join(cube['L'][0] + cube['L'][1]))\n\nsolve()",
    "timestamp": "2025-08-13 07:12:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid rotateFace(vector<char>& face) {\n    char temp = face[0];\n    face[0] = face[2];\n    face[2] = face[3];\n    face[3] = face[1];\n    face[1] = temp;\n}\n\nvoid rotateCube(vector<vector<char>>& cube, char operation) {\n    vector<char> temp;\n    switch (operation) {\n        case 'U':\n            rotateFace(cube[0]);\n            temp = {cube[1][0], cube[1][1]};\n            cube[1][0] = cube[2][0];\n            cube[1][1] = cube[2][1];\n            cube[2][0] = cube[5][2];\n            cube[2][1] = cube[5][3];\n            cube[5][2] = cube[4][0];\n            cube[5][3] = cube[4][1];\n            cube[4][0] = temp[0];\n            cube[4][1] = temp[1];\n            break;\n        case 'F':\n            rotateFace(cube[1]);\n            temp = {cube[0][2], cube[0][3]};\n            cube[0][2] = cube[4][3];\n            cube[0][3] = cube[4][1];\n            cube[4][3] = cube[3][0];\n            cube[4][1] = cube[3][1];\n            cube[3][0] = cube[2][2];\n            cube[3][1] = cube[2][0];\n            cube[2][2] = temp[0];\n            cube[2][0] = temp[1];\n            break;\n        case 'R':\n            rotateFace(cube[2]);\n            temp = {cube[0][1], cube[0][3]};\n            cube[0][1] = cube[5][1];\n            cube[0][3] = cube[5][3];\n            cube[5][1] = cube[3][1];\n            cube[5][3] = cube[3][3];\n            cube[3][1] = cube[1][1];\n            cube[3][3] = cube[1][3];\n            cube[1][1] = temp[0];\n            cube[1][3] = temp[1];\n            break;\n        case 'D':\n            rotateFace(cube[3]);\n            temp = {cube[1][2], cube[1][3]};\n            cube[1][2] = cube[4][2];\n            cube[1][3] = cube[4][3];\n            cube[4][2] = cube[5][0];\n            cube[4][3] = cube[5][1];\n            cube[5][0] = cube[2][2];\n            cube[5][1] = cube[2][3];\n            cube[2][2] = temp[0];\n            cube[2][3] = temp[1];\n            break;\n        case 'B':\n            rotateFace(cube[4]);\n            temp = {cube[0][0], cube[0][1]};\n            cube[0][0] = cube[2][0];\n            cube[0][1] = cube[2][3];\n            cube[2][0] = cube[3][2];\n            cube[2][3] = cube[3][3];\n            cube[3][2] = cube[5][2];\n            cube[3][3] = cube[5][0];\n            cube[5][2] = temp[0];\n            cube[5][0] = temp[1];\n            break;\n        case 'L':\n            rotateFace(cube[5]);\n            temp = {cube[0][0], cube[0][2]};\n            cube[0][0] = cube[1][0];\n            cube[0][2] = cube[1][2];\n            cube[1][0] = cube[3][0];\n            cube[1][2] = cube[3][2];\n            cube[3][0] = cube[4][1];\n            cube[3][2] = cube[4][3];\n            cube[4][1] = temp[0];\n            cube[4][3] = temp[1];\n            break;\n    }\n}\n\nint main() {\n    vector<vector<char>> cube = {\n        {'r', 'r', 'r', 'r'}, // Top (U)\n        {'y', 'y', 'y', 'y'}, // Front (F)\n        {'b', 'b', 'b', 'b'}, // Right (R)\n        {'o', 'o', 'o', 'o'}, // Bottom (D)\n        {'w', 'w', 'w', 'w'}, // Back (B)\n        {'g', 'g', 'g', 'g'}  // Left (L)\n    };\n\n    string operations;\n    cin >> operations;\n\n    for (auto op : operations) {\n        rotateCube(cube, op);\n    }\n\n    for (auto face : cube) {\n        for (auto color : face) {\n            cout << color;\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:34"
  }
]