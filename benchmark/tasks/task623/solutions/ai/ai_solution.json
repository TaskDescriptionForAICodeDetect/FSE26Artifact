[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_VERTICES 100\n\nvoid topologicalSortUtil(int graph[MAX_VERTICES][MAX_VERTICES], int V, int v, bool visited[], int stack[], int* stackIndex) {\n    visited[v] = true;\n\n    for (int i = 0; i < V; i++) {\n        if (graph[v][i] && !visited[i]) {\n            topologicalSortUtil(graph, V, i, visited, stack, stackIndex);\n        }\n    }\n\n    stack[(*stackIndex)++] = v;\n}\n\nvoid topologicalSort(int graph[MAX_VERTICES][MAX_VERTICES], int V) {\n    bool visited[MAX_VERTICES] = {false};\n    int stack[MAX_VERTICES];\n    int stackIndex = 0;\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            topologicalSortUtil(graph, V, i, visited, stack, &stackIndex);\n        }\n    }\n\n    for (int i = stackIndex - 1; i >= 0; i--) {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n\n    int graph[MAX_VERTICES][MAX_VERTICES] = {0};\n\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = 1;\n    }\n\n    topologicalSort(graph, V);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\ntypedef struct Graph {\n    int numVertices;\n    Node** adjLists;\n    int* visited;\n    int* inDegree;\n} Graph;\n\nNode* createNode(int v) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n\nGraph* createGraph(int vertices) {\n    Graph* graph = malloc(sizeof(Graph));\n    graph->numVertices = vertices;\n    graph->adjLists = malloc(vertices * sizeof(Node*));\n    graph->visited = malloc(vertices * sizeof(int));\n    graph->inDegree = calloc(vertices, sizeof(int));\n\n    for (int i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int src, int dest) {\n    Node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n    graph->inDegree[dest]++;\n}\n\nvoid topologicalSort(Graph* graph) {\n    int* queue = malloc(graph->numVertices * sizeof(int));\n    int front = 0, rear = 0;\n\n    for (int i = 0; i < graph->numVertices; i++) {\n        if (graph->inDegree[i] == 0) {\n            queue[rear++] = i;\n        }\n    }\n\n    while (front < rear) {\n        int current = queue[front++];\n        printf(\"%d \", current);\n\n        Node* temp = graph->adjLists[current];\n        while (temp != NULL) {\n            int adjVertex = temp->vertex;\n            graph->inDegree[adjVertex]--;\n            if (graph->inDegree[adjVertex] == 0) {\n                queue[rear++] = adjVertex;\n            }\n            temp = temp->next;\n        }\n    }\n\n    free(queue);\n}\n\nint main() {\n    int vertices, edges;\n    scanf(\"%d %d\", &vertices, &edges);\n    Graph* graph = createGraph(vertices);\n\n    for (int i = 0; i < edges; i++) {\n        int src, dest;\n        scanf(\"%d %d\", &src, &dest);\n        addEdge(graph, src, dest);\n    }\n\n    topologicalSort(graph);\n\n    for (int i = 0; i < graph->numVertices; i++) {\n        Node* temp = graph->adjLists[i];\n        while (temp != NULL) {\n            Node* toFree = temp;\n            temp = temp->next;\n            free(toFree);\n        }\n    }\n    free(graph->adjLists);\n    free(graph->visited);\n    free(graph->inDegree);\n    free(graph);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> topologicalSort(int V, vector<vector<int>>& adj) {\n    vector<int> inDegree(V, 0);\n    for (int u = 0; u < V; ++u) {\n        for (int v : adj[u]) {\n            inDegree[v]++;\n        }\n    }\n\n    queue<int> q;\n    for (int u = 0; u < V; ++u) {\n        if (inDegree[u] == 0) {\n            q.push(u);\n        }\n    }\n\n    vector<int> topoOrder;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        topoOrder.push_back(u);\n\n        for (int v : adj[u]) {\n            if (--inDegree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    return topoOrder;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> adj(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n    }\n\n    vector<int> result = topologicalSort(V, adj);\n    for (int u : result) {\n        cout << u << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TopologicalSort {\n    private int V;\n    private LinkedList<Integer> adj[];\n\n    TopologicalSort(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new LinkedList<>();\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].add(w);\n    }\n\n    void topologicalSortUtil(int v, boolean visited[], Stack<Integer> stack) {\n        visited[v] = true;\n        Integer i;\n\n        for (Integer neighbor : adj[v]) {\n            if (!visited[neighbor])\n                topologicalSortUtil(neighbor, visited, stack);\n        }\n\n        stack.push(v);\n    }\n\n    void topologicalSort() {\n        Stack<Integer> stack = new Stack<>();\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        for (int i = 0; i < V; i++)\n            if (!visited[i])\n                topologicalSortUtil(i, visited, stack);\n\n        while (!stack.empty())\n            System.out.print(stack.pop() + \" \");\n    }\n\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        TopologicalSort g = new TopologicalSort(V);\n\n        for (int i = 0; i < E; i++) {\n            int src = scanner.nextInt();\n            int dest = scanner.nextInt();\n            g.addEdge(src, dest);\n        }\n\n        g.topologicalSort();\n    }\n}",
    "timestamp": "2025-08-05 22:21:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TopologicalSort {\n    private int V;\n    private List<List<Integer>> adj;\n\n    public TopologicalSort(int vertices) {\n        V = vertices;\n        adj = new ArrayList<>(V);\n        for (int i = 0; i < V; i++) {\n            adj.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adj.get(u).add(v);\n    }\n\n    public List<Integer> topologicalSort() {\n        boolean[] visited = new boolean[V];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, stack);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        while (!stack.isEmpty()) {\n            result.add(stack.pop());\n        }\n\n        return result;\n    }\n\n    private void dfs(int v, boolean[] visited, Stack<Integer> stack) {\n        visited[v] = true;\n\n        for (int neighbor : adj.get(v)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, visited, stack);\n            }\n        }\n\n        stack.push(v);\n    }\n\n    public static void main(String[] args) {\n        TopologicalSort graph = new TopologicalSort(6);\n        graph.addEdge(5, 2);\n        graph.addEdge(5, 0);\n        graph.addEdge(4, 0);\n        graph.addEdge(4, 1);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 1);\n\n        List<Integer> order = graph.topologicalSort();\n        System.out.println(\"Topological Order: \" + order);\n    }\n}",
    "timestamp": "2025-08-05 22:22:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nclass Graph {\nprivate:\n    int V;\n    vector<vector<int>> adj;\n    \n    void topologicalSortUtil(int v, vector<bool>& visited, stack<int>& Stack) {\n        visited[v] = true;\n        \n        for (int u : adj[v]) {\n            if (!visited[u]) {\n                topologicalSortUtil(u, visited, Stack);\n            }\n        }\n        \n        Stack.push(v);\n    }\n\npublic:\n    Graph(int vertices) {\n        V = vertices;\n        adj.resize(V);\n    }\n    \n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n    \n    void topologicalSort() {\n        stack<int> Stack;\n        vector<bool> visited(V, false);\n        \n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                topologicalSortUtil(i, visited, Stack);\n            }\n        }\n        \n        while (!Stack.empty()) {\n            cout << Stack.top() << \" \";\n            Stack.pop();\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    Graph g(6);\n    g.addEdge(5, 2);\n    g.addEdge(5, 0);\n    g.addEdge(4, 0);\n    g.addEdge(4, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 1);\n    \n    g.topologicalSort();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef topological_sort(V, edges):\n    in_degree = [0] * V\n    adj_list = defaultdict(list)\n    \n    for u, v in edges:\n        adj_list[u].append(v)\n        in_degree[v] += 1\n    \n    zero_in_degree_queue = deque([v for v in range(V) if in_degree[v] == 0])\n    topological_order = []\n    \n    while zero_in_degree_queue:\n        node = zero_in_degree_queue.popleft()\n        topological_order.append(node)\n        \n        for neighbor in adj_list[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                zero_in_degree_queue.append(neighbor)\n    \n    if len(topological_order) == V:\n        print(topological_order)\n    else:\n        print(\"Graph is not a DAG\")\n\n# Example usage:\nV = 6\nedges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]\ntopological_sort(V, edges)",
    "timestamp": "2025-08-13 10:12:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class TopologicalSort {\n\n    public static List<Integer> topologicalSort(int V, List<List<Integer>> adj) {\n        Stack<Integer> stack = new Stack<>();\n        boolean[] visited = new boolean[V];\n        \n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, stack, adj);\n            }\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (!stack.isEmpty()) {\n            result.add(stack.pop());\n        }\n        \n        return result;\n    }\n\n    private static void dfs(int v, boolean[] visited, Stack<Integer> stack, List<List<Integer>> adj) {\n        visited[v] = true;\n        \n        for (int i : adj.get(v)) {\n            if (!visited[i]) {\n                dfs(i, visited, stack, adj);\n            }\n        }\n        \n        stack.push(v);\n    }\n\n    public static void main(String[] args) {\n        int V = 6;\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        adj.get(5).add(2);\n        adj.get(5).add(0);\n        adj.get(4).add(0);\n        adj.get(4).add(1);\n        adj.get(2).add(3);\n        adj.get(3).add(1);\n        \n        List<Integer> sortedVertices = topologicalSort(V, adj);\n        for (int vertex : sortedVertices) {\n            System.out.print(vertex + \" \");\n        }\n    }\n}",
    "timestamp": "2025-08-13 10:12:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_VERTICES 1000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\ntypedef struct Graph {\n    int numVertices;\n    Node** adjLists;\n    int* indegree;\n} Graph;\n\nNode* createNode(int v) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n\nGraph* createGraph(int vertices) {\n    Graph* graph = malloc(sizeof(Graph));\n    graph->numVertices = vertices;\n    graph->adjLists = malloc(vertices * sizeof(Node*));\n    graph->indegree = malloc(vertices * sizeof(int));\n\n    for (int i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->indegree[i] = 0;\n    }\n\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int src, int dest) {\n    Node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n    graph->indegree[dest]++;\n}\n\nvoid topologicalSort(Graph* graph) {\n    int* sortedVertices = malloc(graph->numVertices * sizeof(int));\n    int topIndex = 0;\n    int* stack = malloc(graph->numVertices * sizeof(int));\n    int stackIndex = -1;\n\n    for (int i = 0; i < graph->numVertices; i++) {\n        if (graph->indegree[i] == 0) {\n            stack[++stackIndex] = i;\n        }\n    }\n\n    while (stackIndex >= 0) {\n        int currentVertex = stack[stackIndex--];\n        sortedVertices[topIndex++] = currentVertex;\n\n        Node* adjList = graph->adjLists[currentVertex];\n        while (adjList != NULL) {\n            int adjVertex = adjList->vertex;\n            graph->indegree[adjVertex]--;\n            if (graph->indegree[adjVertex] == 0) {\n                stack[++stackIndex] = adjVertex;\n            }\n            adjList = adjList->next;\n        }\n    }\n\n    for (int i = 0; i < topIndex; i++) {\n        printf(\"%d \", sortedVertices[i]);\n    }\n    printf(\"\\n\");\n\n    free(sortedVertices);\n    free(stack);\n}\n\nint main() {\n    int vertices, edges;\n    scanf(\"%d %d\", &vertices, &edges);\n\n    Graph* graph = createGraph(vertices);\n\n    for (int i = 0; i < edges; i++) {\n        int src, dest;\n        scanf(\"%d %d\", &src, &dest);\n        addEdge(graph, src, dest);\n    }\n\n    topologicalSort(graph);\n\n    for (int i = 0; i < vertices; i++) {\n        free(graph->adjLists[i]);\n    }\n    free(graph->adjLists);\n    free(graph->indegree);\n    free(graph);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:12:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.graph = defaultdict(list)\n        self.V = vertices\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def topological_sort_util(self, v, visited, stack):\n        visited[v] = True\n        \n        for i in self.graph[v]:\n            if not visited[i]:\n                self.topological_sort_util(i, visited, stack)\n        \n        stack.append(v)\n\n    def topological_sort(self):\n        visited = [False] * self.V\n        stack = []\n        \n        for i in range(self.V):\n            if not visited[i]:\n                self.topological_sort_util(i, visited, stack)\n        \n        return stack[::-1]\n\ndef main():\n    # Number of vertices\n    V = int(input())\n    \n    # Number of edges\n    E = int(input())\n    \n    # Create graph\n    graph = Graph(V)\n    \n    # Add edges\n    for _ in range(E):\n        u, v = map(int, input().split())\n        graph.add_edge(u, v)\n    \n    # Perform topological sort\n    result = graph.topological_sort()\n    \n    # Print result\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:13:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef topological_sort(vertices, edges):\n    graph = defaultdict(list)\n    in_degree = [0] * vertices\n    \n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n    \n    queue = deque()\n    for i in range(vertices):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    top_order = []\n    while queue:\n        u = queue.popleft()\n        top_order.append(u)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    if len(top_order) != vertices:\n        return []\n    return top_order\n\n# Example usage:\n# vertices = 4\n# edges = [[0, 1], [0, 2], [1, 3], [2, 3]]\n# print(topological_sort(vertices, edges))",
    "timestamp": "2025-08-13 10:13:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvoid topologicalSortUtil(int v, const vector<vector<int>>& adj, vector<bool>& visited, stack<int>& Stack) {\n    visited[v] = true;\n\n    for (int i : adj[v]) {\n        if (!visited[i])\n            topologicalSortUtil(i, adj, visited, Stack);\n    }\n\n    Stack.push(v);\n}\n\nvoid topologicalSort(int V, const vector<vector<int>>& adj) {\n    stack<int> Stack;\n    vector<bool> visited(V, false);\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i])\n            topologicalSortUtil(i, adj, visited, Stack);\n    }\n\n    while (!Stack.empty()) {\n        cout << Stack.top() << \" \";\n        Stack.pop();\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> adj(V);\n\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n    }\n\n    topologicalSort(V, adj);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:36"
  }
]