[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ListBuffer\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new java.util.Scanner(System.in)\n\n    val Vs, Es = sc.nextInt()\n    val E = Array.fill[Boolean](Vs, Vs)(false)\n    (0 until Es) foreach { _ =>\n      val u, v = sc.nextInt()\n      E(u)(v) = true\n    }\n    val visited = new Array[Boolean](Vs)\n\n    val topologicalSorted = new ListBuffer[Int]()\n    // 全ての頂点からスタートし, uから繋がっている全てのvについて探索, 帰ってくるタイミングで\n    def dfs(u: Int): Unit =\n      if (!visited(u)) { // 訪れていない時\n        visited(u) = true // 訪れた.\n        (0 until Vs) foreach { v => // 全ての頂点について\n          if (E(u)(v)) { // 辺が繋がっているv\n            dfs(v) // vについてdfs\n          } // 辺が繋がっていない頂点には移動しない.\n        }\n        topologicalSorted.prepend(u)\n      } // 訪れているなら何もしない.\n\n    (0 until Vs) foreach dfs\n\n    topologicalSorted.foreach(println)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ListBuffer\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new java.util.Scanner(System.in)\n\n    val Vs, Es = sc.nextInt()\n    val E = Array.fill[Boolean](Vs, Vs)(false)\n    (0 until Es) foreach { _ =>\n      val u, v = sc.nextInt()\n      E(u)(v) = true\n    }\n    val visited = new Array[Boolean](Vs)\n\n    val topologicalSorted = new ListBuffer[Int]()\n    // 全ての頂点からスタートし, uから繋がっている全てのvについて探索, 帰ってくるタイミングで\n    def dfs(u: Int): Unit =\n      if (!visited(u)) { // 訪れていない時\n        visited(u) = true // 訪れた.\n        (0 until Vs) foreach { v => // 全ての頂点について\n          if (E(u)(v)) { // 辺が繋がっているv\n            dfs(v) // vについてdfs\n          } // 辺が繋がっていない頂点には移動しない.\n        }\n        topologicalSorted.prepend(u)\n      } // 訪れているなら何もしない.\n\n    (0 until Vs) foreach dfs\n\n    topologicalSorted.foreach(println)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n\n  case class Edge(v: Int)\n\n  def main(args: Array[String]): Unit = {\n    val sc = new java.util.Scanner(System.in)\n    val V, E = sc.nextInt()\n    val G = Array.fill(V+1)(List[Edge]())\n    val Dim = Array.fill(V+1)(0)\n    (0 until E) foreach { _ =>\n      val u, v = sc.nextInt()\n      G(u+1) ::= Edge(v+1)\n      Dim(v+1) += 1\n    }\n\n    def topologicalSort(V: Int, E: Int, G: Array[List[Edge]], Dim: Array[Int]): List[Int] = {\n      val visit = new Array[Boolean](V+1)\n\n      def loop(stack: List[Int], sorted: List[Int]): List[Int] =\n        if (stack.nonEmpty) {\n          val u = stack.head\n          if (u < 0) {\n            loop(stack.tail, -u :: sorted)\n          } else if (!visit(u)) {\n            visit(u) = true\n            loop(G(u).foldLeft(-u :: stack.tail)((stack, edge) =>\n              if (!visit(edge.v)) {\n                edge.v :: stack\n              } else stack), sorted)\n          } else loop(stack.tail, sorted)\n        } else sorted\n\n      def eachRoot(s: Int, sorted: List[Int]): List[Int] =\n        if (s <= V) {\n          if (Dim(s) == 0) eachRoot(s + 1, loop(s :: Nil, Nil) ::: sorted)\n          else eachRoot(s + 1, sorted)\n        } else sorted\n\n      eachRoot(1, Nil)\n    }\n\n    println(topologicalSort(V, E, G, Dim).map(_ - 1).mkString(\"\\n\"))\n  }\n\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ListBuffer\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new java.util.Scanner(System.in)\n\n    val Vs, Es = sc.nextInt()\n    val E = Array.fill[Boolean](Vs, Vs)(false)\n    (0 until Es) foreach { _ =>\n      val u, v = sc.nextInt()\n      E(u)(v) = true\n    }\n    val visited = new Array[Boolean](Vs)\n\n    val topologicalSorted = new ListBuffer[Int]()\n    // 全ての頂点からスタートし, uから繋がっている全てのvについて探索, 帰ってくるタイミングで\n    def dfs(u: Int): Unit =\n      if (!visited(u)) { // 訪れていない時\n        visited(u) = true // 訪れた.\n        (0 until Es) foreach { v => // 全ての頂点について\n          if (E(u)(v)) { // 辺が繋がっているv\n            dfs(v) // vについてdfs\n          }\n        }\n        topologicalSorted.prepend(u)\n      }\n\n    (0 until Vs) foreach dfs\n\n    println(topologicalSorted)\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.ListBuffer\n\nobject Main {\n\n  def main(args: Array[String]): Unit = {\n    val sc = new java.util.Scanner(System.in)\n\n    val Vs, Es = sc.nextInt()\n    val E = Array.fill[Boolean](Vs, Vs)(false)\n    (0 until Es) foreach { _ =>\n      val u, v = sc.nextInt()\n      E(u)(v) = true\n    }\n    val visited = new Array[Boolean](Vs)\n\n    val topologicalSorted = new ListBuffer[Int]()\n    // 全ての頂点からスタートし, uから繋がっている全てのvについて探索, 帰ってくるタイミングで\n    def dfs(u: Int): Unit =\n      if (!visited(u)) { // 訪れていない時\n        visited(u) = true // 訪れた.\n        (0 until Es) foreach { v => // 全ての頂点について\n          if (E(u)(v)) { // 辺が繋がっているv\n            dfs(v) // vについてdfs\n          }\n        }\n        topologicalSorted.prepend(u)\n      }\n\n    (0 until Vs) foreach dfs\n\n    println(topologicalSorted)\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint n;\nconst int MAX_V = 10010;\n\nvector<vector<int>> G(MAX_V);\nbool visited[MAX_V];\nint indeg[MAX_V];\nlist<int> out;\n\nvoid bfs(int s){\n    queue<int> que;\n    que.push(s);\n    visited[s] = true;\n\n    while(que.size()){\n        int cv = que.front(); que.pop();\n        out.push_back(cv);\n        for(int i=0; i<G[cv].size(); i++){\n            int nv = G[cv][i];\n            indeg[nv]--;\n            if(indeg[nv] == 0 && !visited[nv]){\n                visited[nv] = true;\n                que.push(nv);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<n; i++){\n        for(int j=0; j<G[i].size(); j++){\n            int v = G[i][j];\n            indeg[v]++;\n        }\n    }\n\n    for(int i=0; i<n; i++){\n        if(indeg[i] == 0 && !visited[i]) bfs(i);\n    }\n\n    for(auto i:out){\n        cout << i << endl;\n    }\n}\n\nint main(){\n    int m; cin>>n>>m;\n    for(int i=0; i<m; i++){\n        int s, t; cin>>s>>t;\n        G[s].emplace_back(t);\n    }\n\n    tsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\n#define fast() ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n\ntemplate <typename T>\nstruct edge\n{\n    int src, to;\n    T cost;\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    edge &operator=(const int &x)\n    {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T>\nusing Edges = vector<edge<T>>;\n\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T>>;\n\ntemplate <typename T>\nusing UnweightedGraph = vector<vector<T>>;\n\ntemplate <typename T>\nusing Matrix = vector<vector<T>>;\n\n// Tarjan's algorithm\n// G is a DAG.\n\nvoid visit(const UnweightedGraph<int> &G, int u, vector<bool> &used, vector<int> &ans)\n{\n    if (used[u] == false)\n    {\n        used[u] = true;\n        for (auto &v : G[u])\n        {\n            visit(G, v, used, ans);\n        }\n        ans.emplace_back(u);\n    }\n}\n\nvector<int> topological_sort(const UnweightedGraph<int> &G)\n{\n    const int N = G.size();\n\n    vector<bool> used(N, false);\n    vector<int> ans;\n    for (int u = 0; u < N; u++)\n    {\n        visit(G, u, used, ans);\n    }\n\n    reverse(ans.begin(), ans.end());\n\n    return ans;\n}\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    UnweightedGraph<int> G(V);\n\n    for (int i = 0; i < E; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n    }\n\n    auto d = topological_sort(G);\n\n    for (int i = 0; i < V; i++)\n    {\n        cout << d[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nvoid topological_sort(vector<vector<int>> G, vector<int>& ans) {\n    vector<bool> seen(G.size());\n\n    function<void(int)> visit;\n    visit = [&](auto key) {\n        if (seen[key])\n            return;\n        seen[key] = true;\n        for (auto x : G[key]) {\n            if (seen[x]) {\n                continue;\n            }\n            visit(x);\n        }\n        ans.push_back(key);\n    };\n\n    for (int i = 0; i < G.size(); ++i) {\n        visit(i);\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    vector<int> ans;\n    topological_sort(G, ans);\n    for (auto it = ans.rbegin(); it != ans.rend(); ++it) {\n        cout << *it << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF = 1e9, MOD = 1e9 + 7, ohara = 1e6 + 10;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define rep(i, n) for (int(i) = 0; (i) < (int)(n); (i)++)\n#define rrep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrrep(i, a, b) for (int i = (a); i >= (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout << (x) << endl\n\nll n, cnt, ans, a[ohara], b[ohara], c, d, tmp, tmpp, m, h, w, x, y, sum, pos, k;\nld doua;\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"), s;\nbool fl, used[ohara];\nstruct edge\n{\n    int to, cost;\n};\nvector<int> res;\nvector<int> g[ohara];\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nvoid dfs(int u)\n{\n    if (used[u])\n        return;\n    used[u] = true;\n    for (auto &i : g[u])\n        dfs(i);\n    res.push_back(u);\n}\n\nvoid tsort()\n{\n    rep(i, n) dfs(i);\n    reverse(all(res));\n}\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> m;\n    rep(i, m)\n    {\n        cin >> a[i] >> b[i];\n        g[a[i]].push_back(b[i]);\n    }\n    tsort();\n    //ans.size() == v ならソート成功。そうでなければ閉路が存在\n    for (int i : res)\n        Cout(i);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, sum[2000000], ans, dp[5000][5000], a[2000000], b[2000000];\nstring str;\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ -1,0 } ,{ 0,-1 } };\nstruct Edge { LL from, cost; };\nvector<Edge>vec[1000000];\nvector<Pll>v;\nmap<string, LL>ma;\nset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nvector<int>topological(vector<vector<bool> >E)\n{\n\tint n = (int)E.size();\n\tvector<bool>V(n);\n\tvector<int>R;\n\tfor (int i = 0; i<n; i++) {\n\t\tint c = -1;\n\t\tfor (int j = 0; j<n&&c == -1; j++)if (!V[j]) {\n\t\t\tbool f = true;\n\t\t\tfor (int k = 0; k<n&&f; k++)\n\t\t\t\tif (!V[k] && E[k][j])\n\t\t\t\t\tf = false;\n\t\t\tif (f)c = j;\n\t\t}\n\t\tif (c == -1)\n\t\t\treturn vector<int>();\n\t\tV[c] = true;\n\t\tR.push_back(c);\n\t}\n\treturn R;\n}\n\nint main() {\n\tcin >> n >> m;\n\tvector<vector<bool>>v(n, vector<bool>(n));\n\trep(i, m) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tv[x][y] = 1;\n\t}\n\tvector<int> an=topological(v);\n\trep(i,an.size())\n\tcout << an[i] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntypedef vector<ll> Edges;\ntypedef vector<Edges> Graph;\n\n// トポロジカルソートで最長パスの長さを求めるやつ\n// 返り値はトポロジカルソート不可能な場合（ループがある場合）-1\n// それ以外は最長パスの長さ\n// 配列tsには「頂点iを終点とする最長のパスの長さ」が入る\n\nconst ll V_MAX = 101010; // !! SHOULD BE EDITTED !!\nvector<ll> ts(V_MAX, -1);\n\nint topologicalSortLength(Graph &G){\n\tll V = G.size();\n\tvector<ll> indeg(V, 0);\n\tqueue<ll> qu;\n\n\tREP(i, V){\n\t\tREP(j, G[i].size()){\n\t\t\tindeg[G[i][j]]++;\n\t\t}\n\t}\n\tREP(i, V){\n\t\tif(!indeg[i]) qu.push(i);\n\t}\n\n\tll depth = 0;\n\twhile(!qu.empty()){\n\t\tll s = qu.size();\n\t\tREP(i, s){\n\t\t\tll now = qu.front();qu.pop();\n\t\t\tts[now] = depth;\n\t\t\tREP(j, G[now].size()){\n\t\t\t\tll next = G[now][j];\n\t\t\t\tindeg[next]--;\n\t\t\t\tif(!indeg[next]) qu.push(next);\n\t\t\t}\n\t\t}\n\t\tdepth++;\n\t}\n\n\tREP(i, V){\n\t\tif(ts[i] == -1) return -1;\n\t}\n\treturn depth;\n}\n\n// 普通のトポロジカルソート\n// 返り値はトポロジカルソート不可能な場合（ループがある場合）false，それ以外 true\n// tsには順番が入ります\n// V_MAX と tsを上からコピーしてくるのを忘れない\nbool topologicalSort(Graph &G){\n\tll V = G.size();\n\tvector<ll> indeg(V, 0);\n\tqueue<ll> qu;\n\n\tREP(i, V){\n\t\tREP(j, G[i].size()){\n\t\t\tindeg[G[i][j]]++;\n\t\t}\n\t}\n\tREP(i, V){\n\t\tif(!indeg[i]) qu.push(i);\n\t}\n\n\tll idx = 0;\n\twhile(!qu.empty()){\n\t\tll s = qu.size();\n\t\tREP(i, s){\n\t\t\tll now = qu.front();qu.pop();\n\t\t\tts[now] = idx;\n\t\t\tidx++;\n\t\t\tREP(j, G[now].size()){\n\t\t\t\tll next = G[now][j];\n\t\t\t\tindeg[next]--;\n\t\t\t\tif(!indeg[next]) qu.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (idx == V);\n}\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll V, E;\n    cin >> V >> E;\n    Graph G(V);\n    REP(i, E){\n    \tll s, t;\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n\n    topologicalSort(G);\n    vector<pll> P(V);\n    REP(i, V) P[i].first = ts[i], P[i].second = i;\n    sort(P.begin(), P.end());\n\n    REP(i, V){\n    \tcout << P[i].second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define RFOR(i, a, b) for (int i = (b)-1, i##_min = (a); i >= i##_min; --i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\nusing namespace std;\nusing i64 = int64_t;\nusing u64 = uint64_t;\nusing vi = vector<int>;\nusing vl = vector<i64>;\nusing vd = vector<double>;\nusing pi = pair<int, int>;\nusing pl = pair<i64, i64>;\nusing pd = pair<double, double>;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\nvector<vi> G;\nlist<int> out;\nvector<bool> visited;\nvi indeg;\n\ntemplate <typename T>\nvoid print(vector<T> &v) {\n  REP(i, v.size()) {\n    if (i) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  visited[s] = true;\n  while (!q.empty()) {\n    auto u = q.front();\n    q.pop();\n    out.push_back(u);\n    for (auto &&v : G[u]) {\n      indeg[v]--;\n      if (indeg[v] == 0 && !visited[v]) {\n        visited[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  auto n = G.size();\n  for (auto &&uv : G) {\n    for (auto &&v : uv) indeg[v]++;\n  }\n  REP(u, n) if (indeg[u] == 0 && !visited[u]) bfs(u);\n  for (auto it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int n, m, s, t;\n  cin >> n >> m;\n  G.resize(n);\n  visited.resize(n, false);\n  indeg.resize(n);\n  REP(i, m) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  tsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<vector<int>> Graph;\n\nclass Topological_Sort{\n    Graph G;\n    public:vector<int> order;\n    vector<bool> visited;\n    void dfs(int v){\n        if(visited[v]) return;\n        visited[v]=true;\n        for(auto &to:G[v]){\n            dfs(to);\n        }\n        order.push_back(v);\n        return;\n    };\n    Topological_Sort(Graph &g) : G(g) {\n        visited = vector<bool>(G.size());\n        for(int i=0;i<G.size();i++) dfs(i);\n        reverse(order.begin(), order.end());\n    };\n};\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    Graph G(N);\n    for(int i=0;i<M;i++){\n        int s,t;\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    Topological_Sort TS(G);\n    for(auto o:TS.order){\n        cout<<o<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include <list>\n#define _GLIBCXX_DEBUG // check []\n#define DIVISOR 1000000007\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int64_t, int64_t> pII;\n\ntemplate<typename T>\nvoid cins(vector<T>& arr) { for(T& e: arr) cin >> e; }\n\n#ifdef DEBUG\n#define debug(fmt, ...) \\\n    printf(\"[debug: %s] \" fmt, __func__, __VA_ARGS__)\n#else\n#define debug(fmt, ...)\n#endif\n\nstatic vector<bool> check;\nvoid dfs(vector<vector<int>>& graph, int node, vector<int>& out) {\n    check[node] = true;\n    for(int elem: graph[node]) {\n        if(check[elem]) continue;\n        dfs(graph, elem, out);\n    }\n    out.push_back(node);\n}\n\nint main(void) {\n    int vs, es;\n    cin >> vs >> es;\n    vector<vector<int>> graph(vs);\n    check.resize(vs);\n    fill(check.begin(), check.end(), false);\n    for(int i = 0; i < es; i++) {\n        int src, dst;\n        cin >> src >> dst;\n        graph[src].push_back(dst);\n    }\n\n    vector<int> ans;\n    for(int i = 0; i < vs; i++) {\n        if(!check[i]) dfs(graph, i, ans);\n    }\n\n    reverse(ans.begin(), ans.end());\n    for(int elem: ans) {\n        cout << elem << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = (1 << 30) - 1;\nconst ll INF64 = ((ll)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint gcd(int x, int y) { return y ? gcd(y, x % y) : x; }\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\nint lcm(int x, int y) { return x / gcd(x, y) * y; }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint v, e;\n\tcin >> v >> e;\n\n\tvector<int> inDegree(v);\n\tvector<vector<int>> g(v);\n\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\n\t\tg[s].emplace_back(t);\n\t\tinDegree[t]++;\n\t}\n\n\tqueue<int> que;\n\tfor (int i = 0; i < inDegree.size(); i++) {\n\t\tif (inDegree[i] == 0) {\n\t\t\tque.emplace(i);\n\t\t}\n\t}\n\n\tvector<int> ans;\n\twhile (!que.empty()) {\n\t\tint now = que.front(); que.pop();\n\t\tans.emplace_back(now);\n\n\t\tfor (auto i : g[now]) {\n\t\t\tinDegree[i]--;\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\tque.emplace(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (auto v : ans) {\n\t\tcout << v << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nint n;\nint in_degree[100009];\nvector<int> N[100009];\n\n\nvoid topological_sort(){\n    queue<int> Q;\n    for(int i=0;i<n;i++){\n        if(in_degree[i]==0){\n            Q.push(i);\n        }\n    }\n    while(!Q.empty()){\n        int fr=Q.front();Q.pop();\n        cout << fr << endl;\n        for(int i=0;i<N[fr].size();i++){\n            in_degree[N[fr][i]]--;\n            if(in_degree[N[fr][i]]==0){\n                Q.push(N[fr][i]);\n            }\n        }\n    }\n\n}\n\nint main(){\n    int e, s, t;\n    cin >> n >> e;\n    for(int i=0;i<e;i++){\n        cin >> s >> t;\n        N[s].push_back(t);\n        in_degree[t]++;\n    }\n    topological_sort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int> > G;\nint *color;\nvector<int> L;\n\nvoid visit(int u);\n\nvoid toporogical_sort(int s) {\n    color[s] = 1;\n    for (int i = 0; i < G[s].size(); i++) {\n        int u = G[s][i];\n        if (color[u] == 0) {\n            visit(u);\n        }\n    }\n    L.push_back(s);\n}\n\nvoid visit(int u) {\n    color[u] = 1;\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if (color[v] == 0) {\n            visit(v);\n        }\n    }\n    L.push_back(u);\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    G.resize(n);\n    int a, b;\n    for (int i = 0; i < m; i++) {\n        cin >> a >> b;\n        G[a].push_back(b);\n    }\n\n    color = new int[n];\n    for (int i = 0; i < n; i++)\n        color[i] = 0;\n    for (int i = 0; i < n; i++) {\n        if (color[i] == 0) \n            toporogical_sort(i);\n    }\n\n    for (int i = n-1; i >= 0; i--)\n        cout << L[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i < (int)b; i++)\n#define all(v) v.begin(), v.end()\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n//'A' = 65, 'Z' = 90, 'a' = 97, 'z' = 122\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    int in[n] = {};\n    rep(i, 0, m) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n        in[t]++;\n    }\n\n    vector<int> ans;\n    queue<int> que;\n    rep(i, 0, n) {\n        if (in[i] == 0) {\n            que.push(i);\n            ans.push_back(i);\n        }\n    }\n    while (!que.empty()) {\n        int now = que.front();\n        que.pop();\n        for (auto next : g[now]) {\n            in[next]--;\n            if (in[next] == 0) {\n                que.push(next);\n                ans.push_back(next);\n            }\n        }\n    }\n\n    for (auto i : ans) cout << i << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define IO ios::sync_with_stdio(0) , cin.tie(0) , cout.tie(0)\n#define F first\n#define S second \ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> tpi;\ntypedef pair<pii,pii> qpi;\nconst int INF = 2e9;\nconst int MAX = 1e5;\nconst int MV = 1e5;\nint MA = -INF , MI = INF;\n\nint n , m;\nvector<int> ans , adj[MAX+10];\nint in[MAX+10];\nbool vis[MAX+10];\nqueue<int> qu;\n\nint32_t main()\n{\n\tIO;\n\tcin >> n >> m;\n\n\twhile(m--)\n\t{\n\t\tint u , v;\n\t\tcin >> u >> v;\n\t\tin[v]++;\n\t\tadj[u].push_back(v);\n\t}\n\n\tfor(int i=0 ; i<n ; i++)\n\t{\n\t\tif( in[i] == 0 )\n\t\t\tqu.push(i) , vis[i] = 1;\n\t}\n\n\twhile( ans.size() < n )\n\t{\n\t\tint v = qu.front();\n\t\tqu.pop();\n\t\tans.push_back(v);\n\t\t\n\t\tfor(int u : adj[v])\n\t\t{\n\t\t\tif( !vis[u] )\n\t\t\t{\n\t\t\t\tin[u]--;\n\t\t\t\tif( in[u] == 0 )\n\t\t\t\t\tqu.push(u) , vis[u] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tfor(int u : ans)\n\t\tcout << u << \"\\n\";\n\tcout << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int inf = 0x3f3f3f3f;\nconstexpr ll linf = 0x3f3f3f3f3f3f3f3fLL;\n\nint v, e;\nvector<int> g[10000];\nbool visited[10000];\nvector<int> ans;\n\nvoid dfs(int now)\n{\n    if (visited[now]) return;\n    visited[now] = true;\n    for (auto &nxt: g[now]) {\n        dfs(nxt);\n    }\n    ans.emplace_back(now);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> v >> e;\n    for (int i = 0; i < e; i++) {\n        int s, t; cin >> s >> t;\n        g[s].emplace_back(t);\n    }\n    for (int i = 0; i < v; i++) dfs(i);\n    reverse(ans.begin(), ans.end());\n    for (auto &x: ans) cout << x << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> topological_sort(int **g, int n)\n{\n\tdeque<int> q;\n\tunordered_map<int, int> m;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint d = 0;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (g[j][i])\n\t\t\t\td++;\n\t\t}\n\n\t\tm[i] = d;\n\n\t\tif (!d)\n\t\t\tq.push_back(i);\n\t}\n\n\tvector<int> vs;\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop_front();\n\n\t\tvs.push_back(v);\n\n\t\tvector<int> adj;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (g[v][i]) {\n\t\t\t\tm[i]--;\n\t\t\t\tif (!m[i])\n\t\t\t\t\tq.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((int)vs.size() != n)\n\t\tthrow \"cycle detected!\";\n\n\treturn vs;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, m, x, y;\n\n\tcin >> n >> m;\n\t\n\tint **g = new int*[n];\n\tfor (int i = 0; i < n; i++)\n\t\tg[i] = new int[n];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tg[i][j] = 0;\n\t}\t\t\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x >> y;\n\t\tg[x][y] = 1;\n\t}\t\t\n\n\tauto vs = topological_sort(g, n);\n\n\tfor (const auto& v : vs)\n\t\tcout << v << \"\\n\";\n\n\tfor (int i = 0; i < n; i++)\n\t\tdelete[] g[i];\n\n\tdelete[] g;\t\t\t\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nconst int MAX = 100000;\nvector<int> G[MAX];\nlist<int> out;\nvector<bool> visited;\n\nvoid dfs(int u){\n    visited[u] = true;\n    for (auto v :G[u]) {\n        if (!visited[v])dfs(v);\n    }\n    out.push_front(u);\n}\nint main(){\n    //freopen(\"in\", \"r\", stdin);\n    int v,e;\n    cin >> v >> e;\n    for (int i = 0; i < e; ++i) {\n        int s,t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    visited.resize(v);\n    for (int i = 0; i < v; ++i) {\n        if (!visited[i])dfs(i);\n    }\n    for (auto item :out) cout << item << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint v ,e;\nint sta[10001];\nvector <int> gin[10001],gout[10001],ans;\nqueue <int> Q;\n\nvoid toporogical_sort(){\n  for(int i=0;i<v;i++)\n    if(!gin[i].size())Q.push(i);\n  \n  while(!Q.empty()) {\n    int t = Q.front(); Q.pop();\n    ans.push_back(t);\n \n    for(int i=0;i<gout[t].size();i++){\n      int nx = gout[t][i];\n      int size = gin[nx].size();\n      for(int j=0;j<size;j++)\n\tif(gin[nx][j] == t){\n\t  gin[nx].erase(gin[nx].begin()+j);\n\t  break;\n\t}\n      if(!gin[nx].size()) Q.push(nx);\n    }\n  }\n}\n \n \nint main() {\n  cin >> v >> e;\n   for(int i=0;i<e;i++) {\n    int s,t;\n    cin >> s >> t;\n    gin[s].push_back(t);\n    gout[t].push_back(s);\n   }\n  toporogical_sort();\n  for(int i=ans.size()-1;i>=0;i--) cout << ans[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\nusing namespace std;\n\nstatic const int MAX = 100000;\nint n, e, indeg[MAX];\nvector<int> v[MAX];\nlist<int> out;\nbool color[MAX];\n\nvoid bfs(int u){\n  queue<int> Q;\n  Q.push(u);\n\n  while ( !Q.empty() ){\n    int top = Q.front(); Q.pop(); color[top] = true;\n    out.push_back(top);\n    for ( int i = 0; i < v[top].size(); i++){\n      int t = v[top][i];\n      indeg[t] --;\n      if ( !color[t] && indeg[t] == 0){\n        Q.push(t);\n      }\n    }\n  }\n}\n\nvoid topological_sort(){\n  for ( int i = 0; i < n; i++){\n    if ( !color[i] && indeg[i] == 0){\n      bfs(i);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> e;\n  int s, t;\n  for ( int i = 0; i < n; i++){ indeg[i] = 0;  color[i] = false;}\n  for ( int i = 0; i < e; i++){\n    cin >> s >> t;\n    v[s].push_back(t);\n    indeg[t] ++;\n  }\n\n  topological_sort();\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++){\n    cout << *it << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, N) for (int i = 0; i < (int)N; i++)\n\nstack<int> topologicalSort(vector<vector<int>>adjacentList)  {\n  int V = adjacentList.size();\n  stack<int> sorted;\n  vector<bool> visited(V, false);\n\n  function<void (int)> dfs = [&](int i) {\n    if(visited[i]) return;\n    visited[i] = true;\n    for(int nn: adjacentList[i]) dfs(nn);\n    sorted.push(i);\n  };\n\n  for(int i = 0; i < V; i++) dfs(i);\n\n  return sorted;\n}\n\nint main () {\n  int V, E;\n  cin >> V >> E;\n\n  vector<vector<int>> adjacentList(V, vector<int>());\n\n  REP(i,E) {\n    int s, t;\n    cin >> s >> t;\n    adjacentList[s].push_back(t);\n  }\n\n  stack<int> sorted = topologicalSort(adjacentList);\n\n  while(!sorted.empty()) {\n    cout << sorted.top() << endl;\n    sorted.pop();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100] = {};\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver* solver;\n  solver = new Solver;\n  solver->solve();\n  delete solver;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// DFS algorithm\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool dfs(vector<vector<int>> &A, vector<int> &U, vector<int> &R, int c)\n{\n        if (U[c] == 2)\n                return true;\n        if (U[c] == 1)\n                return false;\n        U[c] = 1;\n        for (auto a: A[c])\n                if (!dfs(A, U, R, a))\n                        return false;\n        U[c] = 2;\n        R.push_back(c);\n        return true;\n}\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n        }\n        vector<int> U(V), R;\n        bool ok = true;\n        for (int i = 0; i < V && ok; i++)\n                if (!U[i])\n                       ok = dfs(A, U, R, i);\n        if (!ok) {\n                cout << \"Found cyclic path\" << endl;\n                return 0;\n        }\n        reverse(R.begin(), R.end());\n        for (auto r: R)\n                cout << r << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list> \nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N, indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor(int i = 0; i < G[i].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v] --;\n\t\t\tif(indeg[v] == 0 && V[v] == false) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor(int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v =  G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tif(indeg[u] == 0 && ! V[u]) bfs(u);\n\t}\n\t\n\tfor(list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++) {\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n    \n    tsort();\n    \n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(int i = 0; i < n; ++i) for(auto &e : g[i]) ++in[e.dst];\n    for(int i = 0; i < n; ++i){\n        if(in[i] || vis[i]) continue;\n        vis[i] = true; res.push_back(i);\n        queue<int> q;\n        q.push(i);\n        while(!q.empty()) {\n            int p = q.front(); q.pop();\n            for(auto &e : g[p]){\n                int np = e.dst;\n                --in[np];\n                if(in[np] || vis[np]) continue;\n                vis[np] = true;\n                q.push(np);\n                res.push_back(np);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    if(ord.size() != n) while(1);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing Graph = vector<vector<int> >;\nvector<bool> seen;\nvector<int> order;\nvector<int> indeg;\n\nvoid bfs(const Graph &G, int u){\n  queue<int> q;\n  q.push(u);\n  while(!q.empty()){\n    int v = q.front(); q.pop();\n    seen[v] = true;\n    order.push_back(v);\n    for(int nv : G[v]){\n      indeg[nv]--;\n      if(seen[nv]) continue;\n      if(indeg[nv] != 0) continue;\n      q.push(nv);\n    }\n  }\n}\n\nint main(){\n  int n, e; cin >> n >> e;\n\n  indeg.assign(n, 0);\n  Graph G(n);\n  rep(i, e){\n    int s, t; cin >> s >> t;\n    G[s].push_back(t);\n    indeg[t]++;\n  }\n\n  seen.assign(n, false);\n  order.clear();\n  rep(i, n){\n    if(indeg[i] == 0 && !seen[i]) bfs(G, i);\n  }\n\n  rep(i, n) cout << order[i] << endl;\n\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m;\n\nconst int MAXN = 10010;\nint par[MAXN],sz[MAXN];\nvector<int> comps,orders,grf[MAXN],rev_grf[MAXN];\nbool visited[MAXN];\n\nint findcc(int x){\n    return (x==par[x]) ? x : par[x]=findcc(par[x]);\n}\nbool unite(int a,int b){\n    a = findcc(a);\n    b = findcc(b);\n    if(a==b){return false;}\n    if( sz[a]<sz[b]){ swap(a,b);}\n    par[b] = a;\n    sz[a]+=sz[b];\n    return true;\n}\n\nvoid dfs(int u){\n    visited[u]=true;\n    for(auto nbr: grf[u]){\n        if(!visited[nbr]){\n            dfs(nbr);\n        }\n    }\n    orders.push_back(u);\n}\n\nvoid dfs2(int u){\n    visited[u]=true;\n    comps.push_back(u);\n    for(auto nbr: rev_grf[u]){\n        if(!visited[nbr]){\n            dfs2(nbr);\n        }\n    }\n}\n\nvoid init()\n{\n    for(int i=0; i<n; i++){\n        par[i]=i; sz[i]=1;\n    }\n    memset(visited,false,sizeof visited);\n    for(int i=0; i<n; i++){\n        if(!visited[i]){\n            dfs(i);\n        }\n    }\n    memset(visited,false,sizeof visited);\n    \n    while(!orders.empty()){\n        int x = orders.back(); orders.pop_back();\n        if(!visited[x]){\n            comps.clear();\n            dfs2(x);\n            for(auto c: comps){\n                unite(x,c);\n            }\n        }\n    }\n}\n\nvoid top_sort()\n{\n    memset(visited,false,sizeof visited);\n    for(int i=0; i<n; i++){\n        if(!visited[i]){\n            dfs(i);\n        }\n    }\n    for(int i=n-1; i>=0; i--){\n        cout<< orders[i] <<\"\\n\";\n    }   \n}\n\nint main() {\n    // freopen(\"./input.txt\",\"r\",stdin);\n    // freopen(\"./output.txt\",\"w\",stdout);\n\n    cin>>n>>m;\n    for(int i=0; i<m; i++){\n        int x,y; cin>>x>>y;\n        grf[x].push_back(y);\n        rev_grf[y].push_back(x);\n    }\n    top_sort();\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define FOR(i,a,b) for (int i=(a),for_##i##_max=(b);i<=(for_##i##_max);++i)\n#define RFOR(i,a,b) for (int i=(a),rfor_##i##_min=(b);i>=(rfor_##i##_min);--i)\n#define REP(i,n) for (int i=0,rep_##i##_len=(n);i<(rep_##i##_len);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nnamespace { // Basics\n\ntemplate<typename T>\nvoid chmin(T &x, T y) {\n  x = std::min(x, y);\n}\n\ntemplate<typename T>\nvoid chmax(T &x, T y) {\n  x = std::max(x, y);\n}\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto minimum = static_cast<T const &(*)(T const &, T const &)>(std::min);\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto maximum = static_cast<T const &(*)(T const &, T const &)>(std::max);\n\ntemplate<typename T>\nint cmp3(T lhs, T rhs) { return (lhs == rhs) ? 0 : (lhs > rhs) ? 1 : -1; }\n\ntemplate<typename T>\n__attribute__((unused))\nT constexpr infty = std::numeric_limits<T>::max / 3;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<int> = 1'100'100'100;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<long long int> = 100'500'400'300'200'100LL;\n\nusing lli = long long int;\nusing ld = long double;\n\n} // namespace\nnamespace { // Graph Basics\n\ntemplate<typename WeightT>\nstruct edge {\n  int from, to;\n  WeightT weight;\n  edge(int s, int d, WeightT w): from(s), to(d), weight(w) {}\n};\n\ntemplate<typename WeightT>\nbool\noperator< (edge<WeightT> const &lhs, edge<WeightT> const &rhs) {\n  if (lhs.weight != rhs.weight) {\n    return lhs.weight < rhs.weight;\n  } else if (lhs.from != rhs.from) {\n    return lhs.from < rhs.from;\n  }\n  return lhs.to < rhs.to;\n}\n\ntemplate<typename WeightT>\nusing edges = std::vector<edge<WeightT> >;\n\ntemplate<typename WeightT>\nusing adjacency_list = std::vector<edges<WeightT> >;\n\ntemplate<typename WeightT>\nvoid\nadd_undir_edge(adjacency_list<WeightT> &G, int u, int v, WeightT w) {\n  G[u].emplace_back(u, v, w);\n  G[v].emplace_back(v, u, w);\n}\n\ntemplate<typename WeightT>\nadjacency_list<WeightT>\ninverse_graph(adjacency_list<WeightT> const &G) {\n  size_t const n = G.size();\n  adjacency_list<WeightT> F(n);\n  for (auto &&es: G) for (auto &&e: es) {\n    F[e.to].emplace_back(e.to, e.from, e.weight);\n  }\n  return F;\n}\n\ntemplate <typename WeightT>\nedges<WeightT>\nall_edges(adjacency_list<WeightT> const &G) {\n  auto const E = std::accumulate(begin(G), end(G), 0,\n      [](auto x, auto vec) { return x + vec.size(); });\n  edges<WeightT> es;\n  es.reserve(E);\n  for (auto &&vec: G) {\n    std::copy(begin(vec), end(vec), std::back_inserter(es));\n  }\n  return es;\n}\n\n} // namespace\ntemplate<typename WeightT>\nstd::vector<size_t> kahn_tsort(adjacency_list<WeightT> const &G) {\n  std::vector<size_t> ideg(G.size(), 0);\n  for (size_t u = 0; u < G.size(); ++u) for (auto &&e : G[u]) { ++ideg[e.to]; }\n\n  std::stack<size_t> stk;\n  for (size_t u = 0; u < G.size(); ++u) {\n    if (ideg[u] == 0) { stk.push(u); }\n  }\n\n  std::vector<size_t> vec;\n  while (!stk.empty()) {\n    size_t r = stk.top(); stk.pop();\n    vec.push_back(r);\n    for (auto &&e : G[r]) {\n      --ideg[e.to];\n      if (ideg[e.to] == 0) { stk.push(e.to); }\n    }\n  }\n  return vec;\n}\n\nusing namespace std;\n\nusing Graph = adjacency_list<nullptr_t>;\n\nint main() {\n  int n, m; cin >> n >> m;\n  Graph G(n);\n  REP(i, m) {\n    int s, t; cin >> s >> t;\n    G[s].emplace_back(s, t, nullptr);\n  }\n  auto const nodes = kahn_tsort(G);\n  for (auto &&u : nodes) {\n    cout << u << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*     *******************Bismillahir Rahmanir Rahim************************\n                          MD. ASFAKUL GHANI!\n                          *ProMAGFAT*!\n SECRET_warning :)->FAT   CSE-25!\n                          JAHANGIRNAGAR UNIVERSITY!\n                          Dhaka,Bangladesh!\n*/\n\n#include <bits/stdc++.h>\n#include <set>\nusing namespace std;\n\n#define           fasterIO ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define           Im int main()\n#define           ll long long\n#define           sc scanf\n#define           pf printf\n#define           rn0 return 0\n#define           rn return\n#define           f0(i,n) for(ll i=0;i<n;i++)\n#define           f1(i,n) for(ll i=1;i<=n;i++)\n#define           f2(i,n) for(ll i=n-1;i>=0;i--)\n#define           pi 2*acos(0.0)\n#define           modulo 1000003\n#define           dd double\n#define           PI 3.14159265358979\n#define           pi 2*acos(0.0)\n#define           p_b push_back\n#define           ps push\n\n/*\nll for_binarySearch(ll a,ll b,ll aa[],ll x){while(a<=b){ll mid=(a+b)/2;if(aa[mid]==x) return 1;else if(aa[mid] > x) b=mid-1;else a=mid+1;}return -1;}\nll for_gcd(ll a,ll b){if(a==0) return b;else return for_gcd(b%a,a);}\nll for_prime(ll x){for (ll i=2;i*i<=x;i++){if(x%i==0) return 0;}return 1;}\nvoid for_swap(char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;}\nll for_big_mod(ll b,ll p,ll m){if(p==0) return 1;else if(p%2==0){ll k=for_big_mod(b,p/2,m);return (k*k)%m;}else return ((b%m)*(for_big_mod(b,p-1,m)))%m;}\nll for_josephus(ll n,ll k){if(n==1) return 1;return (for_josephus(n-1,k)+k-1)%n+1;}\nll for_gcdExtended(ll a,ll b,ll *x,ll *y){if(a==0){*x=0;*y=1;return b;}ll x1,y1;ll gcd=for_gcdExtended(b%a,a,&x1,&y1);*x=y1-(b/a)*x1;*y=x1;return gcd;}\n*/\n\nvoid debug1()\n{\n    cout << \"***\" << endl;\n}\n\nvoid debug11(ll n)\n{\n    cout << n << endl;\n}\n\nll m,n;\nvector <ll> v1[101010];\nll in_dg[101010];\n\nvoid FAT_topSort()\n{\n    //memset(in_dg,0,sizeof(in_dg));\n\n    for (ll i = 0; i < n; i += 1){\n        vector <ll> ::iterator it;\n        for (it = v1[i].begin(); it != v1[i].end(); it += 1){\n            in_dg[*it] += 1;\n        }\n    }\n    queue <ll> q1;\n    for (ll i = 0; i < n; i += 1){\n        if (in_dg[i]==0) q1.ps(i);\n    }\n    vector <ll> v2;\n    ll cnt = 0;\n    while (!q1.empty()){\n        ll u = q1.front();\n        q1.pop();\n        v2.p_b(u);\n        vector <ll> ::iterator it;\n        for (it = v1[u].begin(); it != v1[u].end(); it += 1){\n            //in_dg[*it] -= 1;\n            if (--in_dg[*it]==0) q1.ps(*it);\n        }\n        cnt += 1;\n    }\n\n    for (ll i = 0; i < v2.size(); i += 1){\n        cout << v2[i] << endl;\n    }\n    rn;\n}\n\nIm\n{\n    /*#ifdef FAT\n       freopen(\"input.txt\",\"w\",stdin);\n    #endif // FAT*/\n\n    fasterIO;\n\n    cin>>n>>m;\n\n    for (ll i = 0; i < m; i += 1){\n        ll u,v;\n        cin>>u>>v;\n        v1[u].p_b(v);\n    }\n\n    FAT_topSort();\n\n   // main();\n\n    rn0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\nvector<int>G[MAX]; //辺の情報\nlist<int>out; //出力の順序\nbool V[MAX]; //そのノードに対して処理をしたか\nint N; //ノードの数\nint indeg[MAX]; //ノードの入次数\n\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n  \n}\n\nvoid tsort(){\n\n  for(int i=0;i<N;i++){\n    indeg[i]=0;\n  }\n\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for(int u=0;u<N;u++)\n    if(indeg[u]==0&&!V[u]) bfs(u);\n\n  for(list<int>::iterator it=out.begin();it!=out.end();it++){\n    cout<<*it<<endl;\n  }\n\n}\n\nint main(){\n  int s,t,M;\n  cin>>N>>M;\n\n  for(int i=0;i<N;i++) V[i]=false;\n\n  for(int i=0;i<M;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\nusing namespace std;\n\nbool topological_sort(const vector< vector<int> >& g, vector<int>& res){\n    const int v = (int)g.size();\n    res.clear();\n\n    vector<int> deg(v, 0);\n    for(int i = 0 ; i < v ; ++i){\n        for(auto to : g[i]){\n            ++deg[to];\n        }\n    }\n\n    vector<int> st;\n    for(int i = 0 ; i < v ; ++i){\n        if(deg[i] == 0){\n            st.emplace_back(i);\n        }\n    }\n\n    while(!st.empty()){\n        int k = st.back();\n        st.pop_back();\n        res.emplace_back(k);\n        for(auto to : g[k]){\n            --deg[to];\n            if(deg[to] == 0){\n                st.emplace_back(to);\n            }\n        }\n    }\n\n    return (int)res.size() == v;\n}\n\n#include<iostream>\n#include<cassert>\n\ntemplate<typename T>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector< vector<int> > g(v);\n    for(int i = 0 ; i < e ; ++i){\n        int u, v;\n        cin >> u >> v;\n        g[u].emplace_back(v);\n    }\n    \n    vector<int> ans;\n    assert(topological_sort(g, ans));\n\n    for(int i = 0 ; i < v ; ++i){\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint A[10100][10100],indeg[10100];\nint s,t,V,E;\nbool flag[10100]={false};\nqueue<int> Q;\nvector<int> ans;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid bfs(int a){\n    Q.push(a);\n    flag[a]=true;\n\n    while(!Q.empty()){\n        int u=Q.front();\n        Q.pop();\n        ans.push_back(u);\n\n        for(int i=0;i<V;++i){\n            if(A[u][i]!=0){\n                --indeg[i];\n                if(indeg[i]==0 && flag[i]==false){\n                    flag[i]=true;\n                    Q.push(i);\n                }\n            }\n        }\n    }\n\n}\n\nvoid tp_srt(){\n    cin>>V>>E;\n\n    Fill(A,0);\n    Fill(flag,false);\n\n    \n    for(int i=0;i<E;++i){\n        cin>>s>>t;\n        A[s][t]=1;\n    }\n    \n    for(int i=0;i<V;++i){\n        indeg[i]=0;\n        for(int j=0;j<V;++j){\n            indeg[i]+=A[j][i];\n        }\n    }\n    \n    for(int i=0;i<V;++i){\n        if(indeg[i]==0 && flag[i]==false){\n            bfs(i);\n        }\n    }\n}\n\nint main(){\n    \n    tp_srt();\n\n    for(int i=0;i<ans.size();++i){\n        cout<<ans[i]<<\"\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\ntypedef pair<int,int> mypair;\nint pass = 0;\nvoid dfs(vector<vector<int > > g,vector<mypair>& used,int s){\n\tauto it= lower_bound(used.begin(),used.end(),mypair(1,s));\n\t(*it).first = 0;\n\t//cout<<s<<\"   \"<<(*it).second<<endl;\n\tpass++;\n\t//auto it = lower_bound(g[s].begin(),g[s].end(),s);\n\t//int k = (int)(it-g[s].begin());\n\t//for(int i=k;g[s].size();i++ ){\n\trep(i,g[s].size()){\n\tif(used[g[s][i]].first)\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back((*it).second);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<mypair> used;\n\tfor(int i=0;i<v;i++)\tused.push_back(mypair(1,i));\n\tauto it = lower_bound(used.begin(),used.end(),mypair(1,0));\n\t//rep(i,v){\n\t//if(used[i]){\n\twhile(pass<=v-1){\n\t\t// int i = it-used.begin();\n\t\tdfs(g,used,(*it).second);\n\t\t\n\t/*cout<<(*it).second<<endl;\n\trep(i,v)if(used[i].first)cout<<used[i].second<<' ';\n\tcout<<endl;*/\n\tsort(used.begin(),used.end());\n\tauto it = lower_bound(used.begin(),used.end(),mypair(1,0));\n\t//\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\t/*rep(i,e){\n\tsort(g[i].begin(),g[i].end());\n\t}*/\n\t/*rep(i,e){\n\t\trep(j,g[i].size()){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <stack>\n#define N 100001\n#define WHITE 0\n#define GRAY 1\n\nusing namespace std;\n\nint color[N];\nvector<int> G[N];\nlist<int> L;\nstack<int> S;\n\nvoid dfs (int u, int V) {\n  color[u] = GRAY;\n  S.push(u);\n\n  while (S.size()) {\n    bool flag = false;\n\n    for (int i = 0; i < G[S.top()].size(); i++) {\n      int v = G[S.top()][i];\n\n      if (color[v] == WHITE) {\n        S.push(v);\n        color[v] = GRAY;\n        flag = true;\n        break;\n      }\n    }\n\n    if (!flag) {\n      L.push_front(S.top());\n      S.pop();\n    }\n  }\n}\n\nvoid dfs_init (int V) {\n  for (int i = 0; i < V; i++) {\n    if (color[i] == WHITE) {\n      dfs(i, V);\n    }\n  }\n}\n\nint main () {\n  int V, E, u, v;\n  \n  cin >> V >> E;\n\n  for (int i = 0; i < E; i++) {\n    cin >> u >> v;\n    G[u].push_back(v);\n  }\n\n  dfs_init(V);\n\n  for (list<int>::iterator it = L.begin(); it != L.end(); it++)\n    cout << *it << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// using\ntemplate<typename Label, typename Weight>\nusing Graph = std::unordered_map<Label, std::unordered_map<Label, Weight>>;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> topological_sort(const Graph<int, int>& reverse, int current, unordered_set<int>& unvisited) {\n  vector<int> result = {current};\n  unvisited.erase(current);\n  if(reverse.count(current)) for(const auto& e: reverse.at(current)) {\n    if(unvisited.count(e.first)) {\n      auto add = topological_sort(reverse, e.first, unvisited);\n      result.insert(begin(result), begin(add), end(add));\n    }\n  }\n  return result;\n}\nvector<int> topological_sort(const Graph<int, int>& g) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  Graph<int, int> reverse;\n  for(const auto& list: g) for(const auto& e: list.second) {\n    reverse[e.first][list.first] = e.second;\n    unvisited.insert(list.first);\n    unvisited.insert(e.first);\n  }\n  while(!unvisited.empty()) {\n    auto add = topological_sort(reverse, *begin(unvisited), unvisited);\n    result.insert(end(result), begin(add), end(add));\n  }\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph<int, int> g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nconst int INF = (1<<30)-1;\nconst long long LINF = (1LL<<62)-1;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int v, e;\n  cin >> v >> e;\n  vector<vector<int>> to(v);\n  vector<int> ideg(v);\n  rep(i, e) {\n    int s, t;\n    cin >> s >> t;\n    to[s].push_back(t);\n    ideg[t]++;\n  }\n  stack<int> st;\n  rep(i, v) {\n    if (!ideg[i])\n      st.push(i);\n  }\n  vector<int> ts;\n  while (!st.empty()) {\n    int idx = st.top();\n    st.pop();\n    ts.push_back(idx);\n    for (auto next : to[idx]) {\n      ideg[next]--;\n      if (!ideg[next])\n        st.push(next);\n    }\n  }\n  for (auto e : ts)\n    cout << e << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nint V, E;\nbool redge[10000][10000];\n\nvector<int> join(vector<int> lhs, vector<int> rhs) {\n  auto res(lhs);\n  res.insert(end(res), begin(rhs), end(rhs));\n  return res;\n}\n\nbool memo[10000];\nvector<int> topological_sort(int u) {\n  if(memo[u]) return {};\n  memo[u] = true;\n  vector<int> res = {u};\n  for(int v = 0; v < V; ++v) if(redge[u][v]) res = join(topological_sort(v), res);\n  return res;\n}\n\nint main() {\n  cin >> V >> E;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    redge[v][u] = true;\n  }\n  for(int i = 0; i < V; ++i) for(const auto& v: topological_sort(i)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "from collections import defaultdict, deque\n\nV, E = map(int, input().split())\nG = defaultdict(list)\n\nfor i in range(E):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nans = deque([])\nvisited = defaultdict(bool)\ndef visit(v):\n    if visited[v]: return\n    visited[v] = True\n    for k in G[v]:\n        visit(k)\n    ans.appendleft(v)\n\nfor v in range(V):\n    visit(v)\n\nprint('\\n'.join(map(str, ans)))"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\nusing namespace std;\nconst int MAX = 10000;\nconst int INF = 100000;\nint n;\nvector<int> G[MAX];\nbool book[MAX];\nint indeg[MAX];\nlist<int> L;\nvoid breathFSearch(int s)\n{\n\tqueue<int> Q;\n\tQ.push(s);\n\tbook[s] = true;\n\twhile (!Q.empty())\n\t{\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tL.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (!indeg[v] && !book[v])\n\t\t\t{\n\t\t\t\tbook[v] = true;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid topologicalSort()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tif (!book[i] && !indeg[i])\n\t\t\tbreathFSearch(i);\n}\nint main()\n{\n\tint m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tindeg[v]++;\n\t}\n\ttopologicalSort();\n\tfor (list<int>::iterator it = L.begin(); it != L.end(); it++)\n\t\tcout << *it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nconst int MAX_V=1e5+1;\n\nvector<int> edge[MAX_V];\nstack<int> ans;\n\nbool used[MAX_V];\n\nvoid visit(int now){\n\tif(used[now])return;\n\tused[now]=true;\n\tfor(int i=0;i<edge[now].size();i++){\n\t\tvisit(edge[now][i]);\n\t}\n\tans.push(now);\n}\n\nint main(){\n\tfill(used,used+MAX_V,false);\n\tint V,E;\n\tcin>>V>>E;\n\tfor(int i=0;i<E;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tedge[a].push_back(b);\n\t}\n\tfor(int i=0;i<V;i++)if(!used[i])visit(i);\n\twhile(!ans.empty()){\n\t\tcout<<ans.top()<<endl;\n\t\tans.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\nusing namespace std;\n\nvector <int> edges[10000];\nint incoming[10000];\nint order[10000];\nint cur_count;\n\nvoid dfs(int cur){\n    for(int i = 0; i < edges[cur].size(); i++){\n        if(order[edges[cur][i]] == 0){\n            dfs(edges[cur][i]);\n        }\n    }\n    order[cur] = cur_count;\n    cur_count --;\n    return;\n}\n\nint main(){\n    int N;\n    int M;\n    cin >> N >> M;\n    cur_count = N - 1;\n    for(int i = 0; i < M; i++){\n        int s;\n        int t;\n        cin >> s >> t;\n        edges[s].push_back(t);\n        incoming[t] ++;\n    }\n    vector <int> sources;\n    for(int i = 0; i < N; i++){\n        if(incoming[i] == 0){\n            sources.push_back(i);\n        }\n    }\n    for(int i = 0; i < sources.size(); i++){\n        dfs(sources[i]);\n    }\n\n    for(int i = 0; i < N; i++){\n        cout << order[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define llINF (long long) 9223372036854775807\n#define loINF (long) 2147483647\n#define shINF (short) 32767\n#define SORT(c) sort((c).begin(),(c).end())\n\nusing namespace std;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\n\n// グラフのdfs\nVI sorted_ver;\nVI used;\nVVI edge;\n\nlong dfs(long node){\n\tif (used[node] == 1) return (-1);\n\tif (used[node] == 2) return 0;\n\tused[node] = 1;\n\tREP(i,edge[node].size()) {\n\t\tif(dfs(edge[node][i]) == (-1)) return (-1);\n\t}\n\tused[node] = 2;\n\tsorted_ver.push_back(node);\n\treturn 0;\n}\n\nint main(void){\n\tlong V,E;\n\tcin >> V >> E;\n\tsorted_ver = VI(0);\n\tused = VI(V,0);\n\tedge = VVI(V,VI(0));\n\n\tREP(i,E){\n\t\tlong s,t;\n\t\tcin >> s >> t;\n\t\tedge[s].push_back(t);\n\t}\n\n\tREP(i,V){\n\t\tif (used[i] != 2) {\n\t\t\tif (dfs(i) == (-1)) {\n\t\t\t\tcout << \"CYCLE EXIST\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#ifdef DEBUG\n\t\tdump2d_arr(edge);\n\t\tdump1d_arr(sorted_ver);\n\t#endif\n\tRREP(i,sorted_ver.size()-1) cout << sorted_ver[i] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define itn ll\n#define int ll\n//const int INF = 100100100;\nconst int INF = (1LL<<32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\n\nstatic const int MAX = 100000;\n\nbool V[MAX];\nvector<int> G[MAX];\nlist<int> out;\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.pb(u);\n\t\trep(i, G[u].size()) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 and !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid tsort() {\n\trep(i, N) indeg[i] = 0;\n\trep(u, N) {\n\t\trep(j, G[u].size()) {\n\t\t\tint v = G[u][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\trep(u, N) {\n\t\tif (!V[u] and indeg[u]==0) {\n\t\t\tbfs(u);\n\t\t}\n\t}\n\tfor (auto l : out) {\n\t\tcout << l << '\\n';\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tint e;\n\tcin >> N >> e;\n\trep(i, N) V[i] = false;\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].pb(t);\n\t}\n\ttsort();\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate<typename T>\nstd::vector<int> topological_sort(const Graph<T> &graph) {\n    Graph<T> g = graph;\n    int n = g.size();\n    std::vector<int> res;\n    std::queue<int> que;\n    std::vector<int> in(n);\n    std::vector<bool> used(n, false);\n    for(int i=0;i<n;++i) {\n        for(int j=0;j<(int)(g[i].size());++j) {\n            in[g[i][j].to]++;\n        }\n    }\n    for(int i=0;i<n;++i) {\n        if(in[i] == 0) que.push(i);\n    }\n    if((int)(que.size()) == 0) res.push_back(-1);\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        if(used[now]) {\n            res.clear();\n            res.push_back(-1);\n            break;\n        }\n        used[now] = true;\n        res.push_back(now);\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            if(in[next] == 1) {\n                que.push(next);\n        }\n            in[next]--;\n        }\n    }\n    return res;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  Graph<int> g(n);\n  for(int i=0;i<m;++i) {\n    int u, v; cin >> u >> v;\n    g[u].push_back(Edge<int>(u, v, 1));\n  }\n  auto ans = topological_sort(g);\n  for(int i=0;i<n;++i) {\n    cout << ans[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// verified\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_A&lang=jp\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass DAG {\npublic:\n    DAG(const vector<vector<int>> &edges)\n    : tsort_done(false), acyc(false) {\n        V = edges.size();\n        E.resize(V);\n        for(int i = 0; i < V; ++i) {\n            for(int to : edges[i]) {\n                E[i].push_back(to);\n            }\n        }\n    }\n\n    bool tsort() {\n        vector<int> indeg(V, 0);\n        for(int i = 0; i < V; ++i) {\n            for(int to : E[i]) ++indeg[to];\n        }\n\n        queue<int> done;\n        for(int i = 0; i < V; ++i) {\n            if(indeg[i] == 0) done.push(i);\n        }\n\n        while(!done.empty()) {\n            int cur = done.front();\n            done.pop();\n            order.push_back(cur);\n            for(int to : E[cur]) {\n                --indeg[to];\n                if(indeg[to] == 0) done.push(to);\n            }\n        }\n\n        tsort_done = true;\n        acyc = (order.size() == V);\n        return acyc;\n    }\n\n    int longest_path() {\n        if(!tsort_done) tsort();\n        if(!acyc) return -1;\n\n        dp.resize(V);\n        for(int i = 0; i < V; ++i) {\n            int cur = order[i];\n            for(int to : E[cur]) {\n                dp[to] = max(dp[to], dp[cur] + 1);\n            }\n        }\n\n        return *max_element(begin(dp), end(dp));\n    }\n\n    bool acyclic() {\n        if(!tsort_done) tsort();\n        return acyc;\n    }\n\n    int operator[](int i) {\n        if(!tsort_done) tsort();\n        return order[i];\n    }\n\nprivate:\n    int V;\n    vector<vector<int>> E;\n    vector<int> order;\n    bool tsort_done;\n    bool acyc;\n    vector<int> dp;\n};\n\n\n\n#include <iostream>\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> edges(V);\n    while(E--) {\n        int s,t;\n        cin >> s >> t;\n        edges[s].push_back(t);\n    }\n\n    DAG dag(edges);\n    dag.tsort();\n    vector<int> res(V);\n    for(int i=0; i<V; ++i) res[i] = dag[i];\n    for(int i=0; i<V; ++i) {\n        cout << res[i] << endl;\n    }\n}\n\n\n\n// function only\nbool tsort(vector<int> &order, const vector<vector<int>> &edges) {\n    int V = edges.size();\n\n    vector<int> indeg(V, 0);\n    for(int i = 0; i < V; ++i) {\n        for(int to : edges[i]) ++indeg[to];\n    }\n\n    queue<int> done;\n    for(int i = 0; i < V; ++i) {\n        if(indeg[i] == 0) done.push(i);\n    }\n\n    while(!done.empty()) {\n        int cur = done.front();\n        done.pop();\n        order.push_back(cur);\n        for(int to : edges[cur]) {\n            --indeg[to];\n            if(indeg[to] == 0) done.push(to);\n        }\n    }\n\n    return order.size() == V;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//トポロジカルソート,tarjan\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=int64_t;\n#define FOR(i,a,b) for(int64_t i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nstruct Edge {\n    ll st,tr;\n    Edge(ll s, ll t)\n        : st(s), tr(t)\n    {}\n};\nstruct Node{\n    vector<Edge> edges;\n};\nusing Graph = vector<Node>;\n\n//各nodeをdfs\nvector<ll> tsort_tarjan(Graph& g){\n    auto num = g.size();\n    enum class State { NEW, ACTIVE, FINISHED };\n    vector<State> state(num, State::NEW); \n    vector<ll> res(num);\n    function<bool(int)> dfs = [&](ll v){\n        state[v]=State::ACTIVE;\n        for(const auto& e : g[v].edges){\n            auto w = e.tr; //接続するnodeをdfsしていく\n            if (state[w] == State::ACTIVE) return false;\n            else if (state[w] == State::NEW) if (!dfs(w)) return false;\n        }\n        state[v]=State::FINISHED;\n        res.push_back(v);\n        //ここで処理すると逆順に処理できる\n        return true;\n    };\n    for (ll n=0;n<num;++n) {\n        if(state[n]==State::NEW && !dfs(n)) return {}; //空を返す\n    }\n    std::reverse(res.begin(),res.end());\n    return res;\n}\n\nint main() {\n    //aoj_grl_4_b\n    ll vn, en; cin>>vn>>en; //頂点数,辺の数\n    Graph graph(vn);\n    REP(i,en){\n        ll s,t; cin>>s>>t;\n        graph.at(s).edges.emplace_back(s,t);\n    }\n\n    auto ord = tsort_tarjan(graph);\n    for(const auto& o:ord){\n        cout<<o<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\nusing edge_set = unordered_set<int>;\n\nint main() {\n\n    int V, E;\n    cin >> V >> E;\n\n    int count = 0;\n    pair<int, int> order[V];\n    edge_set indeg[V], outdeg[V];\n\n    for (int i = 0; i < V; i++) {\n        order[i].second = i;\n    }\n\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        indeg[t].insert(s);\n        outdeg[s].insert(t);\n    }\n\n    queue<int> que;\n\n    for (int i = 0; i < V; i++) {\n        if (indeg[i].empty()) {\n            que.push(i);\n        }\n    }\n\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (int v : outdeg[u]) {\n            indeg[v].erase(u);\n            if (indeg[v].empty()) {\n                que.push(v);\n            }\n        }\n        order[u].first = ++count;\n    }\n\n    //count < |V| なら閉路がある\n\n    sort(order, order + V);\n\n    for (int i = 0; i < V; i++) {\n        cout << order[i].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i])\n                        continue;\n                S.push(i);\n                U[i] = true;\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        L.push_back(c);\n                        for (auto a: A[c]) {\n                                if (--B[a] == 0 && !U[a]) {\n                                        S.push(a);\n                                        U[a] = true;\n                                }\n                        }\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n#define MAX_V (10010)\n\nvector<int> G[MAX_V];\nint indeg[MAX_V];\nbool arrived[MAX_V];\nvector<int> ans;\n\nvoid bfs( int s ) {\n    queue<int> Q;\n    Q.push( s );\n    \n    while ( !Q.empty() ) {\n\tint v = Q.front(); Q.pop();\n\tans.push_back( v );\n\tfor ( int i = 0; i < G[v].size(); i++ ) {\n\t    int t = G[v][i];\n\t    indeg[t]--;\n\t    if ( indeg[t] == 0 && !arrived[t] ) {\n\t\tarrived[t] = true;\n\t\tQ.push( t );\n\t    }\n\t}\n    }\n}\n\n\nint main()\n{\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    \n    for ( int i = 0; i < E; i++ ) {\n\tint s, t;\n\tscanf(\"%d %d\", &s, &t);\n\tG[s].push_back( t );\n        indeg[t]++;\n    }\n\n    for ( int i = 0; i < V; i++ ) {\n\tif ( !arrived[i] && indeg[i] == 0 ) {\n\t    arrived[i] = true;\n\t    bfs( i );\n\t}\n    }\n\n    for ( int i = 0; i < ans.size(); i++ ) {\n\tprintf(\"%d\\n\", ans[i] );\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<list>\nusing namespace std;\nvector<int> v[10000];\nint dep[10000];\nint n,m;\nvoid solve() {\n\tqueue<int>q;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (v[i].empty()) {\n\t\t\tq.push(i);\n\t\t\tdep[i] = 1;\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint k = q.front();\n\t\tq.pop();\n\t\tcout << k << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (dep[i]) continue;\n\t\t\tfor (vector<int>::iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t\tif (*it == k) {\n\t\t\t\t\tv[i].erase(it);\n\t\t\t\t\tif (v[i].empty()) {\n\t\t\t\t\t\tq.push(i);\n\t\t\t\t\t\tdep[i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void) {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tv[b].push_back(a);\n\t}\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/* topological_sort_DFS.cpp\n\n    verified: AOJ GRL_4_B Topological Sort\n    http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=ja\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int to;\n};\nusing Graph = vector<vector<Edge>>;\n\n/* topo_sort(G): グラフG をトポロジカルソート\n    返り値: トポロジカルソートされた頂点番号\n    計算量: O(|E|+|V|)\n    返り値のサイズがグラフより小さければ閉路が存在する\n    （大きなグラフではスタックオーバーフローの可能性があるので、dfsではなくbfsの方が良い）\n */\nvoid dfs(const Graph &G, int v, vector<bool> &used, vector<int> &ans) {\n    used[v] = true;\n    for (auto e : G[v]) {\n        if (!used[e.to]) {\n            dfs(G, e.to, used, ans);\n        }\n    }\n    ans.push_back(v);  // 帰りがけにpush_back\n}\nvector<int> topo_sort(const Graph &G) {  // bfs\n    vector<int> ans;\n    int n = (int)G.size();\n    vector<bool> used(n, false);\n    for (int v = 0; v < n; v++) {\n        if (!used[v]) dfs(G, v, used, ans);\n    }\n    reverse(ans.begin(), ans.end());  // 逆向きなのでひっくり返す\n    return ans;\n}\n\nint main() {\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n    vector<int> s(E), t(E);\n    for (int i = 0; i < E; i++) {\n        cin >> s.at(i) >> t.at(i);\n    }\n\n    Graph G(V);\n    for (int i = 0; i < E; i++) {\n        G[s[i]].push_back({t[i]});\n    }\n    vector<int> sorted = topo_sort(G);\n\n    for (auto v : sorted) {\n        cout << v << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\n//struct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n__attribute__((constructor))\nvoid init(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout<<fixed<<setprecision(15);\n}\n// random_device rd;\n// mt19937 mt(rd());\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/dynamic_bitset.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n// #include <boost/math/tools/minima.hpp>\n// using boost::math::tools::brent_find_minima;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<256>> cdouble;\n// typedef mp::cpp_int cint;\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\ntemplate<typename T=long long>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T=long long>using pqueue =__gnu_pbds::priority_queue<T, less<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0);\n#define output2(v) for(auto j:v)output(j);\n#define _output(v) do{bool f=0;rep(i,v.size()){cout<<(f?\" \":\"\");f=1;cout<<v[i];}cout<<\"\\n\";}while(0)\n#define _output2(v) rep(j,v.size()){_output(v[j]);}\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n//#define MOD 998244353LL\n#define MOD 1000000007LL\n#define endl \"\\n\"\nauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ntemplate<typename T=lint>inline T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<typename T=lint>inline T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<typename T=lint>inline T add(T a,T b){return a+b;}\ntemplate<typename T=lint>inline T minq(T a,T b){return min(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\nvector<lint> depth(lint start,vector<vector<lint>>G){\n\tauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\n\tvector<lint>memo(G.size());\n\tauto f=Y([&](auto f,lint v,lint p)->lint{\n\t\tlint mx=0;\n\t\tfor(auto t:G[v]){\n\t\t\tif(t==p)continue;\n\t\t\tmx=max(mx,f(f,t,v));\n\t\t}\n\t\treturn memo[v]=mx+1;\n\t});\n\tf(start,-1);\n\treturn memo;\n}\nvector<lint>hld(lint start,vector<vector<lint>>G){\n\tauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\n\tvector<lint>depth(G.size());\n\tauto f=Y([&](auto f,lint v,lint p)->lint{\n\t\tlint mx=0;\n\t\tfor(auto t:G[v]){\n\t\t\tif(t==p)continue;\n\t\t\tmx=max(mx,f(f,t,v));\n\t\t}\n\t\treturn depth[v]=mx+1;\n\t});\n\tf(start,-1);\n\treturn depth;\n}\nvector<lint>tsort(vector<vector<lint>>G){\n\tauto Y=[&](auto f){return[&](auto... args){return f(f, args...);};};\n\tvector<bool> visited(G.size(),0);\n\tvector<bool> start(G.size(),1);\n\tfor(lint i=0;i<(lint)G.size();i++)for(lint j=0;j<(lint)G[i].size();j++){\n\t\tstart[G[i][j]]=0;\n\t}\n\tvector<lint>res;\n\tres.reserve(G.size());\n\tauto f=Y([&](auto f,lint v)->void{\n\t\tif(visited[v])return;\n\t\tfor(auto t:G[v])f(f,t);\n\t\tres.push_back(v);\n\t\tvisited[v]=1;\n\t});\n\tfor(lint i=0;i<(lint)G.size();i++)if(start[i])f(i);\n\treverse(res.begin(),res.end());\n\treturn res;\n}\nint main(){\n\tlint n,m;\n\tcin>>n>>m;\n\tmat g(n);\n\trep(i,m){\n\t\tlint s,t;\n\t\tcin>>s>>t;\n\t\tg[s].push_back(t);\n\t}\n\tauto v=tsort(g);\n\trep(i,n){\n\t\tcout<<v[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define FOR(i, a, b) for(int i = a; i < (int)b; ++i)\n\ntypedef long long ll;\n\nconst int Inf = 1e9;\nconst double EPS = 1e-9;\nconst int MAX = 100001;\n\nvoid bfs(int);\n\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nint lcm(int a, int b) {\n    return a * b / gcd(a, b);\n}\n\nint bitCount(long bits) {\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nvector<int> g[MAX];\nbool visited[MAX];\nint entry[MAX];\nlist<int> out;\nint v;\n\nvoid tsort() {\n    rep (i, v) entry[i] = 0;\n    rep (i, v) {\n        rep (j, g[i].size()) {\n            int c = g[i][j];\n            entry[c]++;\n        }\n    }\n    rep (i, v) {\n        if (entry[i] == 0 && !visited[i]) bfs(i);\n    }\n\n    for (auto iter = out.begin(); iter != out.end(); iter++) {\n        cout << *iter << endl;\n    }\n\n}\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n    while (!q.empty()) {\n        int t = q.front();\n        q.pop();\n        out.push_back(t);\n        rep (i, g[t].size()) {\n            int u = g[t][i];\n            entry[u]--;\n            if (entry[u] == 0 && !visited[u]) {\n                q.push(u);\n                visited[u] = true;\n            }\n        }\n    }\n\n}\n\nint main() {\n    int e;\n    cin >> v >> e;\n    rep (i, v) visited[i] = false;\n    rep (i, e) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n    tsort();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <utility>\n#include <numeric>\n#include <iomanip>\n#include <cctype>\n#include <cmath>\n#include <assert.h>\n#include <cstdlib>\n#include <list>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n    return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    s << \"[\";\n    for (int i = 0; i < v.size(); i++) s << (i == 0 ? \"\" : \", \") << v[i];\n    s << \"]\";\n    return s;\n}\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing Weight = int;\n\n// ??????????????????\nstruct Edge {\n    int from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(int to) : from(-1), to(to), weight(-1) {}\n    Edge(int from, int to) : from(from), to(to), weight(-1) {}\n    Edge(int from, int to, Weight weight) : from(from), to(to), weight(weight) {}\n\n    bool operator<(const Edge& e) const {\n        return (weight != e.weight) ? (weight < e.weight) : (from < e.from);\n    }\n    bool operator>(const Edge& e) const {\n        return (weight != e.weight) ? (weight > e.weight) : (from > e.from);\n    }\n};\n\nusing Arc = Edge;\nusing Graph = vector<vector<Edge>>;\nusing DGraph = vector<vector<Arc>>;\n\nusing Tree = Graph;\n\n// ?????????????????????????????¨????????????????????????!\nusing GArray = vector<Weight>;\nusing GMatrix = vector<GArray>;\n\n// ??????4????????¢??°???????????°??????????????????????????§?????§?????????\nvoid add_edge(Graph& g, int u, int v, Weight w = -1) {\n    g[u].push_back(Edge(u, v, w));\n    g[v].push_back(Edge(v, u, w));\n}\n\nvoid add_arc(DGraph& dg, int u, int v, Weight w = -1) {\n    dg[u].push_back(Arc(u, v, w));\n}\n\nconst int GM_INF = (1LL << 25);\n\nvoid init_gmatrix(GMatrix& gm) {\n    for (int u = 0; u < gm.size(); u++) {\n        for (int v = 0; v < gm[u].size(); v++) {\n            gm[u][v] = GM_INF;\n        }\n    }\n}\n\nvoid add_edge(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n    gm[v][u] = w;\n}\n\nvoid add_arc(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n}\n\nnamespace TSort {\n    const int MAX_V = 1000010;\n\n    DGraph dgraph;\n    list<int> nodes;\n\n    array<bool, MAX_V> used;\n    array<int, MAX_V> indeg;\n\n    void bfs(int s) {\n        queue<int> que;\n        que.push(s);\n        used[s] = true;\n\n        while (!que.empty()) {\n            int v = que.front(); que.pop();\n            nodes.push_back(v);\n\n            for (Arc a : dgraph[v]) {\n                indeg[a.to]--;\n                if (indeg[a.to] == 0 && !used[a.to]) {\n                    used[a.to] = true;\n                    que.push(a.to);\n                }\n            }\n        }\n    }\n\n    list<int>& tsort(DGraph& dg) {\n        dgraph = dg;\n        nodes.clear();\n        used.fill(false);\n        indeg.fill(0);\n\n        for (int v = 0; v < dgraph.size(); v++) {\n            for (Arc a : dgraph[v]) {\n                indeg[a.to]++;\n            }\n        }\n\n        for (int v = 0; v < dgraph.size(); v++) {\n            if (indeg[v] == 0 && !used[v]) {\n                bfs(v);\n            }\n        }\n        return nodes;\n    }\n};\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n\n    DGraph dgraph(v);\n\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b;\n        add_arc(dgraph, a, b);\n    }\n\n    auto nodes = TSort::tsort(dgraph);\n    for (int node : nodes) {\n        cout << node << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < N; u++)\n\t\tif (indeg[u] == 0 && !V[u]) bfs(u);\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//using Graph = vector<vector<edge>>;\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n)         for(int i = 0; i < (int)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define erep(i,container) for (auto i : container)\n#define irep(i, n)        for(int i = n-1; i >= (int)0; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n//#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvector(name,typ,m,n)vector<vector<typ> > name(m,vector<typ> (n))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\": \"\n#define res resize\n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n#define ssum(a) accumulate(a,0ll) \n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n//typedef long long T;\nll ceil(ll a,ll b){\n    return ((a+b-1)/b);\n}\nconst int INF = 1000000000;\nconst ll INF64 = 9223372036854775807ll;\nconst ll MOD = 1000000007ll;\nconst dou pi=3.141592653589793;\n//mapは、if関数などで覗いただけで構成されるので注意しよう！\n//std::vector<vector<int>> g;\n\n\n//std::vector<std::set<int>> g;\n\nstd::vector<int> c;\nstd::set<int> al;\nvoid topological(int p,std::vector<std::vector<int>> &g,std::vector<int> &ans){\n    ans.pb(p);\n    al.erase(p);\n    erep(i,g[p]){\n         c[i]--;\n         if(c[i]==0){\n             topological(i,g,ans);\n         }\n    }\n    //return;\n}\nstd::vector<int> topo(std::vector<std::vector<int>> &g){\n    std::vector<int> ans;\n    rep(i,g.size())al.insert(i);\n    c.resize(g.size());\n    rep(i,g.size()){\n        erep(j,g[i]){\n            c[j]++;\n        }\n    }\n    rep(i,g.size()){\n        if(c[i]==0&&al.find(i)!=al.end()){\n            topological(i,g,ans);\n        }\n    }\n    return ans;\n}\n\n\nint main(){\n    //std::vector<int> ans;\n    std::vector<std::vector<int> > g;\n    int v,e;\n    std::cin >> v>>e;\n    g.resize(v);\n    //std::vector<int>c(n);\n    rep(i,e){\n        int a,b;\n        std::cin >> a>>b;\n        g[a].pb(b);\n    }\n    std::vector<int> ans=topo(g);\n    \n    erep(i,ans){\n        std::cout << i << std::endl;\n    }\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX=10000;\n\ntypedef long long ll;\n\nint V, E;\nvector<int> adj[MAX];\nvector<int> ans;\nint indeg[MAX], color[MAX];\n\nvoid bfs(int s){\n  queue<int> Q;\n  Q.push(s);\n  color[s]=1;\n  while(Q.empty()==false){\n    int u=Q.front(); Q.pop();\n    ans.push_back(u);\n    for(int i=0;i<adj[u].size();i++){\n      int v=adj[u][i];\n      indeg[v]--;\n      if(indeg[v]==0 && color[v]==0){\n        color[v]=1;\n        Q.push(v);\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> V >> E;\n  //initialize\n  for(int i=0;i<V;i++){\n    indeg[i]=0;\n    color[i]=0;\n  }\n  for(int i=0;i<E;i++){\n    int s, t; cin >> s >> t;\n    adj[s].push_back(t);\n    indeg[t]++;\n  }\n  //topological sort\n  for(int u=0;u<V;u++){\n    if(indeg[u]==0 && color[u]==0) bfs(u);\n  }\n  for(int i=0;i<ans.size();i++) cout << ans[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INFLL=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvector<int> graph[10000],ans;\nbool done[10000];\n\nvoid topo_dfs(int v){\n    if(done[v]) return;\n    done[v]=true;\n    for(auto u:graph[v]) topo_dfs(u);\n    ans.push_back(v);\n}\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n    \n    rep(i,0,v) topo_dfs(i);\n    \n    reverse(ans.begin(),ans.end());\n    \n    for(auto x:ans) cout << x << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Topological Sort\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nqueue<int> Q;\nlist<int> out;\nbool V[MAX] = {};\nint indeg[MAX] = {};\nint N;\n\nvoid bfs(int u) {\n    while(!Q.empty()) Q.pop();\n    int v;\n    Q.push(u);\n    V[u] = true;\n    while(!Q.empty()) {\n        v = Q.front();\n        Q.pop();\n        out.push_back(v);\n        for(auto i : G[v]) {\n            indeg[i]--;\n            if(indeg[i] == 0) {\n                Q.push(i);\n                V[i] = true;\n            }\n        }\n    }\n}\n\nvoid topologivalSort() {\n    for(int i = 0; i < N; i++) {\n        if(indeg[i] == 0 && !V[i]) bfs(i);\n    }\n}\n\nint main() {\n    int M, s, t;\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    topologivalSort();\n\n    for(auto itr = out.begin(); itr != out.end(); itr++) cout << *itr << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10000\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\nint i ,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \nint z;\n  for(z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\nint i,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\nint i ;\n  for(i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define inf 10e17\n#define rep(i,n) for(long long i=0; i<n; i++)\n#define repr(i,n,m) for(long long i=m; i<n; i++)\n#define mod 1000000007\n#define sorti(x) sort(x.begin(), x.end())\n#define sortd(x) sort(x.begin(), x.end(), std::greater<long long>())\n#define debug(x) std::cerr << (x) << std::endl;\n#define roll(x) for (auto&& itr : x) { cerr << (itr) << \" \"; }\n\ntemplate <class T> inline void chmax(T &ans, T t) { if (t > ans) ans = t;}\ntemplate <class T> inline void chmin(T &ans, T t) { if (t < ans) ans = t;}\n\nusing Graph = vector<vector<int>>; // グラフ\n\n// トポロジカルソートする\nvoid rec(int v, vector<vector<int>> const &G, vector<bool> &seen, vector<int> &order) {\n  seen[v] = true;\n  for (auto next : G[v]) {\n    if (seen[next]) continue; // 既に訪問済みなら探索しない\n    rec(next, G, seen, order);\n  }\n  order.push_back(v);\n}\n\nint main() {\n  int v,e;\n  cin >> v >> e;\n  vector<vector<int>> g(v);\n  rep(i, e) {\n    int a,b;\n    cin >> a >> b;\n    g[a].push_back(b);\n  }\n\n  vector<bool> seen(v, 0);\n  vector<int> order;\n  rep(i, v) {\n    if (seen[i]) continue;\n    rec(i, g, seen, order);\n  }\n\n  reverse(order.begin(), order.end());\n\n  for (auto itr : order) cout << itr << \"\\n\";\n  cout << flush;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<tuple>\n#include<list>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define INF (ll)1e9+7\n#define LLINF (ll)1e30\n// #define int ll\nusing namespace std;\nconst int MAX =100000;\nconst int MOD = 1e9 +7;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid  tsort(){\n    for(int i=0;i<N;i++){\n        indeg[i]=0;\n    }\n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            int v= G[u][i];\n            indeg[v]++;\n        }\n    }\n    for(int u=0;u<N;u++){\n        if(indeg[u]==0 && !V[u]) bfs(u);\n    }\n    for(list<int>::iterator it=out.begin();it !=out.end();it++){\n        cout<<*it<<endl;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int s,t,M;\n    cin>>N>>M;\n    rep(i,N) V[i]=false;\n    rep(i,M){\n        cin>>s>>t;\n        G[s].pb(t);\n    }\n    tsort(); \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*     *******************Bismillahir Rahmanir Rahim************************\n                          MD. ASFAKUL GHANI!\n                          *ProMAGFAT*!\n SECRET_warning :)->FAT   CSE-25!\n                          JAHANGIRNAGAR UNIVERSITY!\n                          Dhaka,Bangladesh!\n*/\n\n#include <bits/stdc++.h>\n#include <set>\nusing namespace std;\n\n#define           fasterIO ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define           Im int main()\n#define           ll long long\n#define           sc scanf\n#define           pf printf\n#define           rn0 return 0\n#define           rn return\n#define           f0(i,n) for(ll i=0;i<n;i++)\n#define           f1(i,n) for(ll i=1;i<=n;i++)\n#define           f2(i,n) for(ll i=n-1;i>=0;i--)\n#define           pi 2*acos(0.0)\n#define           modulo 1000003\n#define           dd double\n#define           PI 3.14159265358979\n#define           pi 2*acos(0.0)\n#define           p_b push_back\n#define           ps push\n\n/*\nll for_binarySearch(ll a,ll b,ll aa[],ll x){while(a<=b){ll mid=(a+b)/2;if(aa[mid]==x) return 1;else if(aa[mid] > x) b=mid-1;else a=mid+1;}return -1;}\nll for_gcd(ll a,ll b){if(a==0) return b;else return for_gcd(b%a,a);}\nll for_prime(ll x){for (ll i=2;i*i<=x;i++){if(x%i==0) return 0;}return 1;}\nvoid for_swap(char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;}\nll for_big_mod(ll b,ll p,ll m){if(p==0) return 1;else if(p%2==0){ll k=for_big_mod(b,p/2,m);return (k*k)%m;}else return ((b%m)*(for_big_mod(b,p-1,m)))%m;}\nll for_josephus(ll n,ll k){if(n==1) return 1;return (for_josephus(n-1,k)+k-1)%n+1;}\nll for_gcdExtended(ll a,ll b,ll *x,ll *y){if(a==0){*x=0;*y=1;return b;}ll x1,y1;ll gcd=for_gcdExtended(b%a,a,&x1,&y1);*x=y1-(b/a)*x1;*y=x1;return gcd;}\n*/\n\nvoid debug1()\n{\n    cout << \"***\" << endl;\n}\n\nvoid debug11(ll n)\n{\n    cout << n << endl;\n}\n\nll m,n;\nvector <ll> v1[101010];\nll in_dg[101010];\n\nvoid FAT_topSort()\n{\n    memset(in_dg,0,sizeof(in_dg));\n\n    for (ll i = 0; i < n; i += 1){\n        vector <ll> ::iterator it;\n        for (it = v1[i].begin(); it != v1[i].end(); it += 1){\n            in_dg[*it] += 1;\n        }\n    }\n    queue <ll> q1;\n    for (ll i = 0; i < n; i += 1){\n        if (in_dg[i]==0) q1.ps(i);\n    }\n    vector <ll> v2;\n    ll cnt = 0;\n    while (!q1.empty()){\n        ll u = q1.front();\n        q1.pop();\n        v2.p_b(u);\n        vector <ll> ::iterator it;\n        for (it = v1[u].begin(); it != v1[u].end(); it += 1){\n            //in_dg[*it] -= 1;\n            if (--in_dg[*it]==0) q1.ps(*it);\n        }\n        cnt += 1;\n    }\n\n    for (ll i = 0; i < v2.size(); i += 1){\n        cout << v2[i] << endl;\n    }\n    rn;\n}\n\nIm\n{\n    /*#ifdef FAT\n       freopen(\"input.txt\",\"w\",stdin);\n    #endif // FAT*/\n\n    //fasterIO;\n\n    cin>>n>>m;\n\n    for (ll i = 0; i < m; i += 1){\n        ll u,v;\n        cin>>u>>v;\n        v1[u].p_b(v);\n    }\n\n    FAT_topSort();\n\n   // main();\n\n    rn0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstatic const long long FAR = (1LL << 31);\nstatic const int N = 100;\n\nint n, m;\nbool visited[N];\nint p[N];\n\nvector<int> G[N];\nvector<int> sorted;\n\nvoid bs(int i) {\n\tqueue<int> q; q.push(i);\n\tvisited[i] = true;\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tvisited[u] = true;\n\t\tsorted.push_back(u);\n\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v = G[u][i];\n\t\t\tp[v]--;\n\t\t\tif (p[v] == 0 && !visited[v]){\n\t\t\t\tq.push(v);\n\t\t\t\tvisited[v] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ts(){\n\tfor (int i = 0; i < n; ++i){\n\t\tvisited[i] = false;\n\t\tp[i] = 0;\n\t}\n\n\tfor (int u = 0; u < n; ++u) {\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tp[v]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i){\n\t\tif (p[i] == 0 && !visited[i]) bs(i);\n\t}\n\n\tfor (int i = 0; i < sorted.size(); ++i) cout << sorted[i] << endl;\n}\n\nint main() {\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\n\tts();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define EPS (1e-7)\n#define INF (1 << 30)\n#define LLINF (1LL << 60)\n#define PI (acos(-1))\n#define MOD (1000000007)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\nvector<vector<int>> g(10001);\nvector<bool> seen(10001, false);\nvector<int> ans;\n\nvoid dfs(int v)\n{\n    if (seen[v])\n    {\n        return;\n    }\n    seen[v] = true;\n    for (auto next : g[v])\n    {\n        dfs(next);\n    }\n    ans.push_back(v);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E;\n    cin >> V >> E;\n    for (int i = 0; i < E; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n    for (int i = 0; i < V; i++)\n    {\n        dfs(i);\n    }\n    reverse(ALL(ans));\n    for (auto a : ans)\n    {\n        cout << a << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int v, e;\n  cin >> v >> e;\n  vvt<int> edge(v);\n  vt<int> in(v, 0);\n  rep(i, 0, e) {\n    int s, t;\n    cin >> s >> t;\n    edge[s].push_back(t);\n    in[t]++;\n  }\n\n  queue<int> que;\n  rep(i, 0, v) {\n    if(in[i] == 0) que.push(i);\n  }\n\n  vt<int> ans;\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    ans.push_back(p);\n\n    for(auto &nxt : edge[p]) {\n      in[nxt]--;\n      if(in[nxt] == 0) que.push(nxt);\n    }\n  }\n\n  rep(i, 0, v) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(a, b, c, NAME, ...) NAME\n#define rep(...) GET_MACRO(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define rep2(i, a) rep3 (i, 0, a)\n#define rep3(i, a, b) for (int i = (a); i < (b); i++)\n#define repr(...) GET_MACRO(__VA_ARGS__, repr3, repr2)(__VA_ARGS__)\n#define repr2(i, a) repr3 (i, 0, a)\n#define repr3(i, a, b) for (int i = (b) - 1; i >= (a); i--)\n#define chmin(a, b) ((b) < a && (a = (b), true))\n#define chmax(a, b) (a < (b) && (a = (b), true))\nusing namespace std;\ntypedef long long ll;\n \nstruct Toposort {\n    vector<vector<int>> g;\n    vector<int> ord, indeg;\n    Toposort(int n) : g(n), ord(n), indeg(n) {}\n    void add(int u, int v) {\n        g[u].push_back(v);\n    }\n    void build() {\n        for (auto &v : g) for (int w : v) indeg[w]++;\n        queue<int> q;\n        rep (i, g.size()) if (indeg[i] == 0) q.push(i);\n        int k = 0;\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            ord[k++] = v;\n            for (int w : g[v]) {\n                indeg[w]--;\n                if (indeg[w] == 0) q.push(w);\n            }\n        }\n    }\n};\n \ntemplate<class T>\nostream &operator <<(ostream &os, const vector<T> &v) {\n    rep (i, v.size()) {\n        if (i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nint main() {\n    int n, m;\n    cin >> n >> m;\n    Toposort ts(n);\n    rep (i, m) {\n        int u, v;\n        cin >> u >> v;\n        ts.add(u, v);\n    }\n    ts.build();\n    for (auto v : ts.ord) {\n        cout << v << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstack<int> st;\n\nvoid topologicalSort(vector<int> *a, int u, bool *check){\n    if(check[u])return;\n\n    check[u] = true;\n    int i;\n    for(i=0;i<a[u].size();i++){\n        topologicalSort(a,a[u][i],check);\n    }\n\n    st.push(u);\n\n    return;\n}\n\nint main(){\n    int i,s,t,V,E;\n\n    scanf(\"%d %d\",&V,&E);\n    vector<int> a[10000];\n    bool check[10000];\n\n    for(i=0;i<V;i++){\n        check[i] = false;\n    }\n\n    for(i=0;i<E;i++){\n        scanf(\"%d %d\",&s,&t);\n        a[s].push_back(t);\n    }\n\n    for(i=0;i<V;i++){\n        topologicalSort(a,i,check);\n    }\n\n    while(!st.empty()){\n        printf(\"%d\\n\",st.top());\n        st.pop();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(int i = 0; i < n; ++i) for(auto &e : g[i]) in[e.dst]++;\n    for(int i = 0; i < n; ++i){\n        if(in[i] == 0 && !vis[i]) {\n            vis[i] = true;res.push_back(i);\n            queue<int> q;\n            q.push(i);\n            while(!q.empty()) {\n                int p = q.front(); q.pop();\n                for(auto &e : g[p]){\n                    int np = e.dst;\n                    in[np]--;\n                    if(in[np] == 0 && !vis[np]){\n                        vis[np] = true;\n                        q.push(np);\n                        res.push_back(np);\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    assert((int)ord.size() == n);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \nusing namespace std;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1LL << 60;\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int>in(n);\n\tvector<int>e[101010];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\te[x].pb(y);\n\t\tin[y]++;\n\t}\n\n\tstack<int>st;\n\tfor (int i = 0; i < n; i++)if (!in[i])st.push(i);\n\n\tvector<int>ans;\n\twhile (st.size()) {\n\t\tint i = st.top();\n\t\tst.pop();\n\t\tans.pb(i);\n\t\tfore(x, e[i]) {\n\t\t\tin[x]--;\n\t\t\tif (!in[x])st.push(x);\n\t\t}\n\t}\n\n\tif (ans.size() != n)puts(-1);\n\telse {\n\t\tfore(x, ans)puts(x);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10005\n\nint n, m, cnt[N];\n\nvector<int> to[N];\n\nsigned main(void)\n{\n\tcin >> n >> m;\n\t\n\tmemset(cnt, 0, sizeof(cnt));\n\t\n\tfor (int u, v; m--; )\n\t{\n\t\tcin >> u >> v;\n\t\tto[u].push_back(v); ++cnt[v];\n\t}\n\t\n\tqueue<int> que;\n\t\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!cnt[i])que.push(i);\n\t\t\n\twhile (!que.empty())\n\t{\n\t\tint u = que.front(); que.pop();\n\t\t\n\t\tcout << u << endl;\n\t\t\n\t\tfor (auto v : to[u])\n\t\t\tif (--cnt[v] == 0)\n\t\t\t\tque.push(v);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;}\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;}\n    return false;\n}\n\nstruct TopologicalSort{\n    vector<vector<int>> G;\n    vector<int> used,indeg,order;\n    TopologicalSort(int n):G(n),used(n,0),indeg(n,0){}\n    void add_edge(int u,int v){\n        G[u].push_back(v);\n        ++indeg[v];\n    }\n    void bfs(int s){\n        queue<int> que;\n        que.emplace(s);\n        used[s]=1;\n        while(!que.empty()){\n            int v=que.front(); que.pop();\n            order.emplace_back(v);\n            for (auto u:G[v]){\n                --indeg[u];\n                if (indeg[u]==0&&!used[u]){\n                    used[u]=1;\n                    que.emplace(u);\n                }\n            }\n        }\n    }\n    vector<int> build(){\n        rep(i,G.size()) if (indeg[i]==0&&!used[i]) bfs(i);\n        return order;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V,E; cin >> V >> E;\n    TopologicalSort T(V);\n    rep(i,E){\n        int s,t; cin >> s >> t;\n        T.add_edge(s,t);\n    }\n    vector<int> ans=T.build();\n    rep(i,V) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n//グラフの隣接リスト\nmap<int, vector<int>> g;\n//頂点の入次数を管理\nint h[100010];\n\nint main()\n{\n  //頂点数v、辺の数e\n  int v, e;\n  cin >> v >> e;\n  REP(i, e) {\n    int s, t;\n    cin >> s >> t;\n    g[s].push_back(t);\n    h[t]++;\n  }\n\n  //入次数が0の頂点の集合\n  stack<int> st;\n  REP(i, v) if(h[i] == 0) st.push(i);\n\n  vi ans;\n  \n  while(st.size()) { //stがなくなるまでループ\n    //stの集合のから一つ取り出す\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--; //隣接する頂点の入次数をマイナス1\n      //これによって入次数が0になればstに追加\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  for(int i: ans) cout << i << endl; //ans.size() == v であればトポロジカルソートができた -> 閉路なし\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//トポソの唯一性\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\n \nint main(){\n \n    int n, m; cin >> n >> m;\n    vector<vector<int> > adj(n);\n    vector<int> d(n, 0);                           //入次数\n    for(int i = 0; i < m; i++){\n        int a, b; cin >> a >> b;                   //a->bへ有向辺\n        d[b]++;\n        adj[a].push_back(b);\n    }\n \n    queue<int> q;\n \n    //入次数が0の頂点queueに入れる\n    for(int i = 0; i < n; i++){\n        if(d[i] == 0) q.push(i);                    \n    }\n \n    vector<int> ans;\n \n    while(!q.empty()){\n \n        int v = q.front();\n        q.pop();\n        ans.push_back(v);\n \n        //vから伸びている有向辺をなめる\n        for(int i = 0; i < (int)adj[v].size(); i++){\n            d[adj[v][i]]--;\n            //辺を取り除いた後に入次数が0になったら\n            if(d[adj[v][i]] == 0) q.push(adj[v][i]);\n        }\n \n    }\n \n    for(int i = 0; i < (int)ans.size(); i++) cout << ans[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\nusing namespace std;\n\n#define FAST cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)\n#define pb push_back\n#define pf pop_front\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll MAX_N = 10 * 1000 + 24;\n\nint n, m;\nint d[MAX_N];\nvector<int> G[MAX_N], vec;\ndeque<int> dq;\n\nint main() {\n  FAST;\n  cin>>n>>m;\n  int u, v;\n  for (int i = 0; i < m; i++) {\n    cin>>u>>v;\n    G[u].pb(v);\n    d[v]++;\n  }\n  for (int i = 0; i < n; i++) {\n    if (d[i] == 0) {\n      dq.pb(i);\n      vec.pb(i);\n    }\n  }\n  while (dq.size()) {\n    for (int j = 0; j < G[dq[0]].size(); j++) {\n      u = G[dq[0]][j];\n      d[u]--;\n      if (d[u] == 0) {\n        dq.pb(u);\n        vec.pb(u);\n      }\n    }\n    dq.pf();\n  }\n  for (int i = 0; i < n; i++) {\n    cout<<vec[i]<<\"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing graph = vector<vector<int>>;\n\nvector<int> topological_sort(const graph& g) {\n\tconst int n = g.size();\n\tvector<int> in(n), st, res;\n\tfor (int i = 0; i < n; ++i) for (auto to : g[i]) ++in[to];\n\tfor (int i = 0; i < n; ++i) if (in[i] == 0) st.push_back(i);\n\twhile (!st.empty()) {\n\t\tint v = st.back(); st.pop_back();\n\t\tres.push_back(v);\n\t\tfor (auto to : g[v]) {\n\t\t\t--in[to];\n\t\t\tif (in[to] == 0) st.push_back(to);\n\t\t}\n\t}\n\tassert(count(in.begin(), in.end(), 0) == n);\n\treturn res;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tgraph G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\tauto ids = topological_sort(G);\n\tfor (auto id : ids) {\n\t\tprintf(\"%d\\n\", id);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#include<climits>\n#include<sstream>\nusing namespace std;\n#define maxn 10010\nstruct Node{\n    int x,y,val,pre;\n};\nNode g[100010];\nint gh[maxn],du[maxn];\nint n,m;\nstack<int> s;\n\nint main(){\n    int i,j;\n    cin>>n>>m;\n    memset(gh,-1,sizeof gh);\n    memset(du,0,sizeof du);\n    for(i=0;i<m;i++){\n        cin>>g[i].x>>g[i].y;\n        g[i].pre=gh[g[i].x];\n        gh[g[i].x]=i;\n\n        du[g[i].y]++;\n    }\n    for(i=0;i<n;i++)\n        if(du[i]==0)\n            s.push(i);\n    while(!s.empty()){\n        int t=s.top();\n        s.pop();\n        cout<<t<<endl;\n        j=gh[t];\n        while(j!=-1){\n            int yy=g[j].y;\n            du[yy]--;\n            if(!du[yy]) s.push(yy);\n            j=g[j].pre;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\ndouble h, w, n, m, k, s, t, q, last, cnt[10000], a[10000], sum, ans[10000];\nstring str, ss;\nbool f;\nchar c;\nint di[4][2] = { {1,0},{-1,0} ,{0,1},{0,-1} };\nstruct Edge { int to, cost; };\nvector<Edge>vec[50000];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\n\nvoid add_edge(int a, int b, int w = 1) {\n\tvec[a].emplace_back(Edge{ b,w });\n}\n\nvector<int> kosaraju() {\n\tint sz = 0; \n    vector<Edge> rg[50000];\n\tvector<int> stk, cmp(n, -1), added(n), visited(n), ord(n);\n\trep(i, n) {\n\t\tsz += vec[i].size();\n\t\tfor (const Edge &e : vec[i])\n\t\t\trg[e.to].push_back(Edge{ (int)i, e.cost });\n\t}\n\tstk.resize(n + sz); sz = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (visited[i]) continue;\n\t\tint s = 0; stk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1]; \n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : vec[v]) {\n\t\t\t\tint dst = e.to;\n\t\t\t\tif (!visited[dst]) { stk[s++] = dst; pushed = true; }\n\t\t\t}\n\t\t\tif (pushed) continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) { added[t] = true; ord[n - ++sz] = t; }\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1) continue;\n\t\tint s = 0; stk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s]; cmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint d = e.to;\n\t\t\t\tif (cmp[d] == -1) stk[s++] = d;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\nvector<int> tsort() {\n\tenum { YET, VISITED, DONE };\n\tvector<int> res, flg(n, YET);\n\tstatic const function<bool(int)> dfs = [&](int v) {\n\t\tflg[v] = VISITED;\n\t\tfor (auto &e : vec[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (flg[w] != DONE && (flg[w] == VISITED || !dfs(w))) return false;\n\t\t}\n\t\tflg[v] = DONE;\n\t\tres.push_back(v);\n\t\treturn true;\n\t};\n\tfor (int i = 0; i < n; ++i)\n\t\tif (flg[i] == YET && !dfs(i)) return{};\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nint main() {\n\tcin >> n>>m;\n\trep(i, m) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x, y);\n\t}\n\tvector<int>cm = tsort();\n\trep(i, n)\n\t\tcout << cm[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\nusing namespace std;\n\nvoid BFS(vector<int> verVal[], vector<bool> &color, list<int> &sortVers, vector<int> &indeg, int subScript) {\n\tqueue<int> bfsQ;\n\tbfsQ.push(subScript);\n\tcolor[subScript] = true;\n\n\twhile (!bfsQ.empty()) {\n\t\tint curVerVal = bfsQ.front(); \n\t\tbfsQ.pop();\n\n\t\tsortVers.push_back(curVerVal);\n\n\t\tfor (int i = 0; i < verVal[curVerVal].size(); i++) {\n\t\t\tint outVerVal = verVal[curVerVal][i];\n\t\t\tindeg[outVerVal]--;\n\t\t\tif (indeg[outVerVal] == 0 && !color[outVerVal]) {\n\t\t\t\tcolor[outVerVal] = true;\n\t\t\t\tbfsQ.push(outVerVal);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlist<int> TopologicalSort(vector<int> verVal[], int verNum) {\n\n\tlist<int> sortVers;\n\tvector<bool> color(verNum);\n\tvector<int> indeg(verNum);\n\n\t//Initialie\n\tfor (int i = 0; i < color.size(); i++)\n\t\tcolor[i] = false;\n\tfor (int i = 0; i < indeg.size(); i++)\n\t\tindeg[i] = 0;\n\tfor (int first = 0; first < verNum; first++) {\n\t\tfor (int second = 0; second < verVal[first].size(); second++) {\n\t\t\tint outVerVal = verVal[first][second];\n\t\t\tindeg[outVerVal]++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < verNum; i++)\n\t\tif (indeg[i] == 0 && !color[i]) {\n\t\t\tBFS(verVal, color, sortVers, indeg, i);\n\t\t}\n\n\treturn sortVers;\n}\n\nint main() {\n\n\tvector<int> verVal[10000];\n\tint verNum, edgeNum;\n\tcin >> verNum >> edgeNum;\n\n\tfor (int i = 0; i < edgeNum; i++) {\n\t\tint first, second;\n\t\tcin >> first >> second;\n\t\tverVal[first].push_back(second);\n\t}\n\n    list<int> sortVers = TopologicalSort(verVal, verNum);\n\n\tfor (list<int>::iterator it = sortVers.begin(); it != sortVers.end(); it++)\n\t\tcout << *it << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n  V[u] = true;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!V[v]) {\n      dfs(v);\n  }\n  out.push_front(u);\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (!V[i]) {\n      dfs(i);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\nvector<int> tsort(int v, vector<int> g[], bool zero_index = false) {\n  vector<int> ret;\n\n  int start = zero_index ? 0 : 1;\n  int end = zero_index ? v : v + 1;\n  int degree[end];\n  memset(degree, 0, sizeof(degree));\n\n  for (int from = start; from < end; from++) {\n    for (int i = 0; i < g[from].size(); i++) {\n      int to = g[from][i];\n      degree[to]++;\n    }\n  }\n\n  stack<int> root;\n\n  for (int i = start; i < end; i++) {\n    if (degree[i] == 0) {\n      root.push(i);\n    }\n  }\n\n  while (!root.empty()) {\n    int from = root.top();\n    root.pop();\n\n    ret.push_back(from);\n\n    for (int i = 0; i < g[from].size(); i++) {\n      int to = g[from][i];\n      degree[to]--;\n\n      if (degree[to] == 0) {\n        root.push(to);\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int v, e;\n  int s, t;\n  cin >> v >> e;\n\n  vector<int> g[v];\n\n  for (int i = 0; i < e; i++) {\n    cin >> s >> t;\n\n    g[s].push_back(t);\n  }\n\n  vector<int> ans = tsort(v, g, true);\n\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = init; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nvector<int> graph[10000];\n\nint h[100000];\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    rep(i, E)\n    {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        h[t]++;\n    }\n\n    stack<int> st;\n\n    rep(i, V) if (h[i] == 0) st.push(i);\n\n    vector<int> ans;\n\n    while (st.size())\n    {\n        int i = st.top();\n        st.pop();\n        ans.push_back(i);\n\n        for (auto e : graph[i])\n        {\n            h[e]--;\n\n            if (h[e] == 0)\n                st.push(e);\n        }\n    }\n\n    for (int i : ans)\n        cout << i << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n\n\nint topological_sort(vector<int> &in_degree,vector<vector<int> > &dag, vector<int> &sorted){\n    int n = dag.size();\n    if(sorted.size() == n) return 0;\n    for(int i=0;i<n;i++){\n        if(in_degree[i] == 0){\n            sorted.push_back(i);\n            in_degree[i]--;\n            for(auto x: dag[i]) in_degree[x]--;\n        }\n    }\n    return 0;\n}\nint main(){\n    int n,e; cin >> n >> e;\n    vector<int> in_degree(n);\n    for(int i=0;i<n;i++) in_degree[i] = 0;\n    vector<vector<int> > dag(n);\n    vector<int> sorted;\n    for(int i=0;i<e;i++){\n        int f,t; cin >> f >> t;\n        dag[f].push_back(t);\n        in_degree[t]++;\n    }\n \n    for(int i=0;i<n;i++) topological_sort(in_degree, dag, sorted);\n    for(int i=0;i<n;i++) cout << sorted[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nvoid rec(int n,vector<int>& visited,vector<int>& job,vector<vector<int>>& G){\n    if(visited[n]) return;\n    visited[n] = 1;\n    for(auto next:G[n]){\n        rec(next,visited,job,G);\n    }\n    job.push_back(n);\n}\nvoid solve(){\n    int V,E; cin >> V >> E;\n    vector<vector<int>> G(V);\n    for(int i = 0; i < E;i++){\n        int s,t; cin >> s >> t;\n//        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    vector<int> job,visited(V);\n    for(int i = 0; i < V;i++){\n        //if(visited[i]) continue;\n        rec(i,visited,job,G);\n    }\n    for(auto J:job){\n        cout << J << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n\tV[u] = true;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!V[v])dfs(v);\n\t}\n\tout.push_front(u);\n}\n\nint main() {\n\tint s, t, M;\n\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++)V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!V[i])dfs(i);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tcout << *it << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n\tV[u] = true;\n\tfor(int i = 0; i < G[u].size(); i++){\n\t\tint v = G[u][i];\n\t\tif(!V[v]) dfs(v);\n\t}\n\tout.push_front(u);\n}\n\nint main(){\n\tint s, t, M;\n\n\tcin >> N >> M;\n\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(!V[i]) dfs(i);\n\t}\n\n\tfor(list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tcout << *it << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nvi topological_sort(const vvi &lst) {\n\tvi ret = {};\n\tint n = lst.size();\n\tvi cnt(n);\n\tLoop(a, n) {\n\t\tForeach(b, lst[a]) {\n\t\t\tcnt[b]++;\n\t\t}\n\t}\n\tset<int> st;\n\tLoop(a, n) {\n\t\tif (cnt[a] == 0) st.insert(a);\n\t}\n\twhile (st.size()) {\n\t\tauto itr = st.begin(); st.erase(itr);\n\t\tint a = *itr;\n\t\tret.push_back(a);\n\t\tForeach(b, lst[a]) {\n\t\t\tcnt[b]--;\n\t\t\tif (cnt[b] == 0) st.insert(b);\n\t\t}\n\t}\n\tif (ret.size() != n) return {};\n\telse return ret;\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvvi lst(n);\n\tLoop(_, m) {\n\t\tint a, b; cin >> a >> b;\n\t\tlst[a].push_back(b);\n\t}\n\tvi seq = topological_sort(lst);\n\tForeach(a, seq) {\n\t\tcout << a << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tset<int>orphan;\n\t\tfor(int i=0;i<V;i++)orphan.insert(i);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t),orphan.erase(s),orphan.erase(t);\n\t\t//for(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\n\t\t\tfor(i=0;i<order.size();i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t//}\n\t\tFOR(u,orphan)printf(\"%d\\n\",*u); //孤立した頂点が存在するデータがあるので注意\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cstdio>\n#include<utility>\n#include<set>\n#include<list>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define REP(i, n) FOR(i, 0, n - 1)\n#define NREP(i, n) FOR(i, 1, n)\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<pii, pii>;\nconst ll dx[4] = { 0,1,0,-1 };\nconst ll dy[4] = { -1, 0, 1,0 };\nconst ll INF = 1e9 + 7;\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nvoid mul(ll a, ll b) {\n\ta = a * b % INF;\n}\ndouble mysqrt(double x) {\n\tdouble l = 0, r = x;\n\tfor (int i = 0; i < 64; ++i) {\n\t\tdouble m = (l + r) / 2.0;\n\t\tif (m*m < x)l = m;\n\t\telse r = m;\n\t}\n\treturn l;\n}\n///////////////////////////////////////\n\n//DAG(有向無閉路グラフ)<=>トポロジカルソートができる\n//方法１\n//入次数が0の頂点があればその頂点をソート後の結果に追加しその頂点と隣接した頂点の\n//入次数を-1するこれを入次数が0の頂点がなくなるまで繰り返すO(V+E)\n//方法２\n//すべての点から深さ優先探索を行いその帰りかけ順がトポロジカルソートの結果\nvector<int>g[100010];//グラフの隣接リスト\nint h[100010];//頂点の入次数を管理\nint main() {\n\tint v, e; cin >> v >> e;\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t\th[t]++;\n\t}\n\tstack<int>st;\n\tREP(i, v)if (h[i] == 0)st.push(i);\n\t//ソートされた後のグラフ\n\tvector<int>ans;\n\twhile (st.size()) {\n\t\tint i = st.top(); st.pop();\n\t\tans.push_back(i);\n\t\tfor (auto j : g[i]) {\n\t\t\th[j]--;\n\t\t\tif (h[j] == 0)st.push(j);\n\t\t}\n\t}\n\tfor (int i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n/* macro */\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n#define revrep(i,a,b) for(int i = a; i > b; i--)\n//#define int long long\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define all(v) (v).begin(), (v).end()\n#define each(s,itr) for(auto (itr) = s.begin(); (itr) != s.end(); (itr)++)\n#define sum(v) accumulate(all(v), (0LL))\n#define Sort(v) sort(all(v))\n\n\n/* constant */\n//const int inf = 100100100100100100;\nconst int mod = 998244353;\nint dx[8]={1,0,-1,0,-1,1,-1,1};\nint dy[8]={0,1,0,-1,-1,-1,1,1};\n\n\n/* io_method */\nint input(){int tmp;cin >> tmp;return tmp;}\nstring raw_input(){string tmp;cin >> tmp;return tmp;}\nstring readline(){string s;getline(cin, s);return s;}\ntemplate<class T> void printx(T n){cout << n;}\ntemplate<class T, class U> void printx(pair<T, U> p){cout << \"(\" << p.first << \",\" << p.second << \")\";}\ntemplate<class T> void printx(vector<T> v){cout << \"{\";rep(i,0,v.size()){printx(v[i]);if(i != v.size()-1)printx(\",\");}cout << \"}\";}\ntemplate<class T> void print(T n){printx(n);cout << endl;}\ntemplate<class T> void print(set<T> s){cout << \"{\";each(s, e){if(e != s.begin()) printx(\",\");printx(*e);}cout << \"}\" << endl;}\ntemplate<class T, class U> void print(map<T, U> mp){cout << \"{\";each(mp, e){cout << \"(\" << e -> first << \",\" << e -> second << \")\";}cout << \"}\" << endl;}\n\n\n/* general_method */\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvector<int> cs(vector<int> arr){vector<int> tmp;if(arr.size() == 0) return tmp;tmp.push_back(arr[0]);rep(i,1,arr.size()){tmp.push_back(tmp.back() + arr[i]);}return tmp;}\n\n/* math_library */\nint gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b);}\nint lcm(int a, int b){ return a * b / gcd(a,b);}\nint ceil(int a, int b){ if(a % b == 0) return a/b; else return a/b + 1;}\nint digitlen(int n){int t = n;int cnt = 0;while(t){cnt++;t /= 10;}return cnt;}\nbool isprime(int n){if(n < 2) return false;if(n % 2 == 0 || n % 3 == 0 || n % 5 == 0) return false;for(int i = 7; i * i < n + 1; i += 2){if(n % i == 0) return false;}return true;}\nint mod_pow(int x, int n, int m){if(n== 0) return 1;int res = mod_pow(x*x%m,n/2,m);if(n&1) res = res*x%m;return res;}\nint digitsum(int n){int ret = 0;while(n){ret += n % 10;n /= 10;}return ret;}\n\n\n\n/* main */\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, e; cin >> n >> e;\n\n    vector<vector<int> > edges(n);\n    vector<int> indig(n,0);\n\n    rep(i,0,e){\n        int f,t; cin >>  f >> t;\n        edges[f].push_back(t);\n        indig[t]++;\n    }\n\n    stack<int> noindigstk;\n    rep(i,0,n){\n        if(indig[i] == 0) noindigstk.push(i); \n    }\n    \n    vector<int> ans;\n\n    while(not noindigstk.empty()){\n\n        int v = noindigstk.top();\n        noindigstk.pop();\n        ans.push_back(v);\n\n        rep(i,0,edges[v].size()){\n\n            indig[edges[v][i]]--;\n            if(indig[edges[v][i]] == 0) noindigstk.push(edges[v][i]);\n\n        }\n\n    }\n\n    for(int e: ans){\n        print(e);\n    }\n\n\n\n\n\n\n\n    \n\n\n\n\n    \n\n\n\n\n\n\n\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, char, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nconst ll mod = 1000000007;\n\nstatic const ll INF = 1e15;\n\ntypedef ll Weight;\nstruct Edge {\n\tint from, to;\n\tWeight weight;\n\tEdge(int src, int dst) :\n\t\tfrom(src), to(dst), weight(0) { }\n\n\tEdge(int src, int dst, Weight weight) :\n\t\tfrom(src), to(dst), weight(weight) { }\n};\nbool operator < (const Edge& e, const Edge& f) {\n\treturn e.weight != f.weight ? e.weight > f.weight :\n\te.from != f.from ? e.from < f.from : e.to < f.to;\n}\n\nstruct UndirectionalCompare {\n\tbool operator() (const Edge& e, const Edge& f) const {\n\t\tif (min(e.from, e.to) != min(f.from, f.to))\n\t\t\treturn min(e.from, e.to) < min(f.from, f.to);\n\t\treturn max(e.from, e.to) < max(f.from, f.to);\n\t}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\ntypedef set<Edge, UndirectionalCompare> Edgeset;\n\nstruct topoloricalSort_runnner {\n\tbool visit(const Graph& g, int v, vector<int>& order, vector<int>& color) {\n\t\tcolor[v] = 1;\n\t\tfor (auto e : g[v]) {\n\t\t\tif (color[e.to] == 2) continue;\n\t\t\tif (color[e.to] == 1) return false;\n\t\t\tif (!visit(g, e.to, order, color)) return false;\n\t\t}\n\t\torder.push_back(v); color[v] = 2;\n\t\treturn true;\n\t}\n\t\n\tbool topologicalSort(const Graph& g, vector<int>& order) {\n\t\tint n = g.size();\n\t\tvector<int> color(n);\n\t\trep(u, n) if (!color[u] && !visit(g, u, order, color))\n\t\t\treturn false;\n\t\treverse(order.begin(), order.end());\n\t\treturn true;\n\t}\n};\n\nint main(void)\n{\n\tint v, e;\n\tcin >> v >> e;\n\n\tGraph g(v);\n\trep(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back({s,t,0});\n\t}\n\ttopoloricalSort_runnner runner;\n\tvector<int> order;\n\tif (runner.topologicalSort(g, order)) {\n\t\tfor (auto o : order) {\n\t\t\tcout << o << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<cmath>\n#include<sstream>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#define rep(i,n) for(int i = 0;i<n;i++)\n#define Rep(i,n) for(int i = 1;i<=n;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define mult(a,b) (((a)*(b))%MOD)\n#define se second\n#define INF 1300000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\n\nvector<int> G[100000];\nint V,E;\nvector<int> order;\nbool visited[100000];\n\nvoid dfs(int now){\n    visited[now]=1;\n    rep(i,G[now].size()){\n        if(!visited[G[now][i]]){\n            dfs(G[now][i]);\n        }\n    }\n    order.pb(now);\n    return;\n}\n\nint main(){\n    cin>>V>>E;\n    rep(i,E){\n        int a,b;\n        cin>>a>>b;\n        G[a].pb(b);\n    }\n    rep(i,V){\n        if(!visited[i])\n            dfs(i);\n    }\n    reverse(order.begin(),order.end());\n    rep(i,V){\n        cout<<order[i]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\nusing namespace std;\nconst int INF=INT_MAX;\n\nvector< int > G[100000];\nlist< int > out;\nbool V[100000];\nint N;\nint indeg[100000];\n\nvoid bfs(int s){\n    queue< int > q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        out.push_back(u);\n        REP(i,G[u].size()){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    REP(i,N){\n        indeg[i]=0;\n    }\n\n    REP(u,N){\n        REP(i,G[u].size()){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    REP(u,N) if(indeg[u]==0&&!V[u]) bfs(u);\n\n    for(auto it=out.begin();it!=out.end();++it) printf(\"%d\\n\",*it);\n}\n\nint main(){\n    int s,t,M;\n\n    scanf(\"%d%d\",&N,&M);\n\n    REP(i,N) V[i]=false;\n\n    REP(i,M){\n        scanf(\"%d%d\",&s,&t);\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int s){\n\tV[s]=true;\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tint v=G[s][i];\n\t\tif(!V[v])dfs(v);\n\t}\n\tout.push_front(s);\n}\n\nint main(){\n\tint s,t,M;\n\tcin>>N>>M;\n\tfor (int i = 0; i < N; ++i) {V[i]=false;}\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t}\n\tfor (int u = 0; u < N; ++u) {\n\t\t\t//?¨?????????????????????????????????\\?¬???°?????????????????????list?????\\?????????\n\t\t\tif(!V[u])dfs(u);}\n\tfor (list<int>::iterator it=out.begin();it !=out.end();it++) {\n\t\tcout<<*it<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX (10000)\nusing namespace std;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  \n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v]){\n\tV[v] = true;\n\tq.push(v);\n      }\n    }\n  }\n\n}\n\nvoid tsort() {\n  for ( int i = 0; i< N; i++) {\n    indeg[i] = 0;\n  }\n\n  for ( int u = 0; u < N; u++) {\n    for ( int i = 0; i< G[u].size(); i++){\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for ( int u = 0; u < N ; u++) {\n    if(indeg[u] == 0 && !V[u]) {\n      bfs(u);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nmain()\n{\n  int s, t, M;\n  cin >> N >> M;\n  for(int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n  for(int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  \n  tsort();\n\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing LL=long long;\n\nconst int INF = 1'000'000'000;\nconst long long INFLL = 1'000'000'000'000'000'000;\n\nusing Weight=int;\nstruct Edge {\n\tint to; Weight cost;\n\tEdge(int _to, Weight _cost) :to(_to), cost(_cost) {}\n};\nbool operator>(const Edge& e1, const Edge& e2) { return e1.cost > e2.cost; }\nstruct Edge2 { int u, v; Weight cost; };\nusing Graph=vector<vector<Edge>>;\n\n\nvector<int> TopologicalSort(const Graph& graph) {\n\tint V = graph.size();\n\tvector<bool> visited(V);\n\tvector<int> ret;\n\tfunction<void(int)> dfs = [&](int u) {\n\t\tif (visited[u])return;\n\t\tvisited[u] = true;\n\t\tfor (auto& i : graph[u])dfs(i.to);\n\t\tret.push_back(u);\n\t};\n\tfor (int i = 0; i < V; i++)dfs(i);\n\treverse(ret.begin(), ret.end());\n\treturn ret;\n}\n\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tGraph g(v);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].emplace_back(t, 1);\n\t}\n\tfor (auto aa : TopologicalSort(g))\n\t\tcout << aa << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\n\n#define MAX_N 500000\n#define INF 1145141919\n\nvector<int>G[MAX_N];\nlist<int> out;\nbool V[MAX_N];\nint N, M, b, c[MAX_N], d;\nint indeg[MAX_N];\nqueue<int>Q;\n\nvoid bfs(int s) {\n\tQ.push(s);\n\tV[s] = true;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front(); Q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && V[v] == false) { V[v] = true; Q.push(v); }\n\t\t}\n\t}\n}\n\nvoid Tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor (int u = 0; u < N; u++) {\n\t\tif (indeg[u] == 0 && V[u] == false) {\n\t\t\tbfs(u);\n\t\t}\n\t}\n\tb = 0; d = 0;\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t\tc[b] = *it;\n\t\tif (b >= 1) {\n\t\t\tfor (int i = 0; i < G[c[b - 1]].size(); i++) {\n\t\t\t\tif (G[c[b - 1]][i] == c[b]) {\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t\td = 1;\n\t\t\tF:;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\t//cout << d << endl;\n}\n\nint main() {\n\tint s, t;\n\tfor (int i = 0; i < MAX_N; i++) { G[i].clear(); }\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\tTsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> visited;\nvector<int> ans;\nvector<int> deg;\nint v;\n\nvoid topologicalOrder() {\n  queue<int> q;\n  for (int i = 0; i < v; i++) {\n    if (deg[i] == 0) q.push(i);\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    ans.push_back(x);\n    for (auto y : adj[x]) {\n      if (visited[y] == 0) {\n        deg[y]--;\n        if (deg[y] == 0) {\n          visited[y] = 1;\n          q.push(y);\n        }\n      }\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int e;\n  cin >> v >> e;\n  adj.resize(v);\n  visited.resize(v);\n  deg.resize(v);\n  for (int i = 0; i < e; i++) {\n    int a, b;\n    cin >> a >> b;\n    adj[a].push_back(b);\n    deg[b]++;\n  }\n  topologicalOrder();\n  for (auto i : ans) {\n    cout << i << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nVI G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        out.PB(u);\n        REP(i, G[u].size()) {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v]) {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort() {\n    REP(i, N) indeg[i] = 0;\n    REP(u, N) {\n        REP(i, G[u].size()) {\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    REP(u, N) if (indeg[u] == 0 && !V[u]) bfs(u);\n    REPI(it, out) cout << *it << endl;\n}\n\nint main(void) {\n    int M;\n    cin >> N >> M;\n    REP(i, N) V[i] = false;\n    REP(i, M) {\n        int s, t;\n        cin >> s >> t;\n        G[s].PB(t);\n    }\n    tsort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nbool visit(const vector<vi>& g, int v, vector<int>& order, vector<int>& color) {\n    color[v] = 1;\n    for (int u : g[v]) {\n        if (color[u]==2) continue;\n        if (color[u]==1) return false;\n        if (!visit(g, u, order, color)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n}\n\n// ?????????????????????????????????\n// ???????????? true ???????????????????????????(false ?????´????????????)\nbool TopologicalSort(const vector<vi>& g, vector<int>& order) {\n    int n = g.size();\n    vector<int> color(n);\n    for (int u = 0; u < n; u++) if (!color[u] && !visit(g, u, order, color)) return false;\n    reverse(order.begin(), order.end());\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E;\n    cin >> V >> E;\n    vector<vi> G(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    vector<int> order;\n    assert(TopologicalSort(G, order));\n    for (int el : order) cout << el << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n    V[u] = true;\n    for(int i=0; i<G[u].size(); i++){\n        int v = G[u][i];\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s, t, M;\n    \n    cin >> N >> M;\n    \n    for(int i=0; i<N; i++) V[i] = false;\n    \n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    for(int i=0; i<N; i++){\n        if(!V[i]) dfs(i);\n    }\n    \n    for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int> > xs(n);\n    vector<int> ys(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        xs[a].push_back(b);\n        ys[b]++;\n    }\n    vector<int> que;\n    for (int i = 0; i < n; i++) {\n        if (ys[i] == 0) {\n            que.push_back(i);\n        }\n    }\n    vector<int> zs(n);\n    for (int i = 0; i < n; i++) {\n        int p = que[i];\n        zs[p] = i;\n        cout << p << endl;\n        // cout << i << \":\" << p << \", \";\n        for (int j = 0; j < (int)xs[p].size(); j++) {\n            int e = xs[p][j];\n            ys[e]--;\n            if (ys[e] == 0) {\n                que.push_back(e);\n            }\n        }\n    }\n    // for (int i = 0; i <= m; i++) {\n        // int x, y;\n        // cin >> x >> y;\n        // if (zs[x] > zs[y]) {\n            // puts(\"1\");\n        // } else {\n            // puts(\"-1\");\n        // }\n    // }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll v,e;\n    cin>>v>>e;\n    VEC2(g,v,0);\n    vector<ll> deg(v);\n    FOR(i,0,e){\n      ll in1,in2;\n      cin>>in1>>in2;\n      g[in1].push_back(in2);\n      deg[in2]++;\n    }\n    deque<ll> q;\n    FOR(i,0,v){\n      if(deg[i] == 0) q.push_back(i);\n    }\n    vector<ll> ans;\n    while(!q.empty()){\n      ll x = q.front();\n      ans.push_back(x);\n      q.pop_front();\n      FOR(i,0,g[x].size()){\n        deg[g[x][i]]--;\n        if(deg[g[x][i]] == 0) q.push_back(g[x][i]);\n      }\n    }\n\n    FOR(i,0,v){\n      cout<<ans[i]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n// O(|E| + |V|)\n\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass TopologicalSort {\n#define MAX_V 10001\nprivate:\n\n  struct Edge {\n    int to;\n    Edge(int to): to(to) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n  TopologicalSort(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to) {\n    G[from].push_back(Edge(to));\n  }\n\n  vector<int> Solve() {\n    int k = 0;\n    vector<int> ord(V), in(V);\n    for (int i = 0; i < V; i++) {\n      for (auto &e : G[i]) {\n        in[e.to]++;\n      }\n    }\n    queue<int> q;\n    for (int i = 0; i < V; i++) {\n      if (in[i] == 0) {\n        q.push(i);\n      }\n    }\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      ord[k++] = v;\n      for (auto &e : G[v]) {\n        if (--in[e.to] == 0) {\n          q.push(e.to);\n        }\n      }\n    } \n\n    return (*max_element(in.begin(), in.end()) == 0)? ord : vector<int>();\n  }\n};\n\n#include <iostream>\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  TopologicalSort ts(V);\n\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    ts.AddEdge(s, t);\n  }\n\n  vector<int> ans = ts.Solve();\n\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\ntypedef pair<int,int> mypair;\nint pass = 0;\nvoid dfs(vector<vector<int > > g,vector<mypair>& used,int s){\n\tauto it= lower_bound(used.begin(),used.end(),mypair(1,s));\n\t(*it).first = 0;\n\t//cout<<s<<\"   \"<<(*it).second<<endl;\n\tpass++;\n\t//auto it = lower_bound(g[s].begin(),g[s].end(),s);\n\t//int k = (int)(it-g[s].begin());\n\t//for(int i=k;g[s].size();i++ ){\n\trep(i,g[s].size()){\n\tif(used[g[s][i]].first)\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back((*it).second);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<mypair> used;\n\tfor(int i=0;i<v;i++)\tused.push_back(mypair(1,i));\n\tauto it = lower_bound(used.begin(),used.end(),mypair(1,0));\n\t//rep(i,v){\n\t//if(used[i]){\n\twhile(pass<=v-1){\n\t\t// int i = it-used.begin();\n\t\tdfs(g,used,(*it).second);\n\t\t\n\t/*cout<<(*it).second<<endl;\n\trep(i,v)if(used[i].first)cout<<used[i].second<<' ';\n\tcout<<endl;*/\n\tsort(used.begin(),used.end());\n\tauto it = lower_bound(used.begin(),used.end(),mypair(1,0));\n\t//\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\t/*rep(i,e){\n\tsort(g[i].begin(),g[i].end());\n\t}*/\n\t/*rep(i,e){\n\t\trep(j,g[i].size()){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//..verified against AOJ GRL_4_B\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Graph {\nprivate:\n  int V;\n  int E;\n  vector <vector <int>> adj;\npublic:\n  Graph(int n, int m);\n  void addEdge(int s, int t);\n  void topologicalSort();\n};\n\nGraph::Graph(int n, int m) {\n  this->V = n;\n  this->E = m;\n  adj.resize(n);\n}\n\nvoid Graph::addEdge(int s, int t) {\n  adj[s].push_back(t);\n}\n\nvoid Graph::topologicalSort() {\n  vector <int> order;\n  vector <int> deg(V, 0);\n  for (int u = 0; u < V; u++) {\n    for (int v : adj[u]) {\n      deg[v]++;\n    } \n  }\n  queue <int> from;\n  for (int u = 0; u < V; u++) {\n    if (deg[u] == 0) {\n      from.push(u);\n    } \n  } \n  while (!from.empty()) {\n    int u = from.front();\n    from.pop();\n    order.emplace_back(u);\n    for (int v : adj[u]) {\n      if (deg[v] == 1) {\n        from.push(v);\n      }\n      deg[v]--;\n    } \n  }\n  if ((int) order.size() != V) { //Cycle present\n    //TODO\n  }\n  \n  for (int node : order) cout << node << \" \";\n  cout << endl;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n, m);\n  int s, t;\n  for (int i = 0; i < m; i++) {\n    cin >> s >> t;\n    g.addEdge(s, t);\n  } \n  g.topologicalSort();\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < V; i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < edge[ans[i]].size(); j++) {\n            int t = edge[ans[i]][j];\n            state[t]--;\n            if (state[t] == 0) ans.push_back(t);\n        }\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nint MAX_N=10050;\nint n;\nvvin edge(MAX_N);\nvin indegree(MAX_N);\n\n//頂点番号0,1,...,n-1\nvin topological_sort(){\n    vin sorted;\n    queue<int> q;\n    rep(i,n)if(!indegree[i])q.push(i);\n    while(q.size()){\n        auto p=q.front();q.pop();\n        sorted.push_back(p);\n        for(auto e:edge[p]){\n            indegree[e]--;\n            if(!indegree[e])q.push(e);\n        }\n    }\n    return sorted;\n}\n\nint main(){\n    int m;cin>>n>>m;\n    int s,t;\n    rep(i,m){\n        cin>>s>>t;\n        edge[s].push_back(t);\n        indegree[t]++;\n    }\n    vin ans=topological_sort();\n    rep(i,n)cout<<ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define int long long\n#define vec(a,n) vector<int> (a)((n));\n#define Vec(a,n) vector<string> (a)((n));\n#define twovec(a,n,m) vector<vector<int>> a(n,vector<int>(m,0));\n#define Twovec(a,n,m) vector<vector<double>> a(n,vector<double>(m,0));\n#define P pair<int,int>\n#define All(a) (a).begin(),(a).end()\n#define Sort(a) sort(All(a));\n#define Reverse(a) reverse(All(a));\n#define PQ(n) priority_queue<P,vector<P>,greater<P>> (n)\n#define pq(n) priority_queue<int> (n)\n#define print(a) cout << (a) << endl\n#define printD(a) cout << setprecision(15) << (a) << endl;\nusing namespace std;\nint max_int = 2147483647;\nint prime = 10e9+7;\nvoid Debug(auto a);\nint nibul(auto a,auto b);\nint nibuu(auto a,auto b);\nvoid input(vector<auto>& a,int n);\ndouble PI = 3.14159265358979;\nint n;\n\nstruct Edge{\n    int from,to,cost;\n    bool operator<(const Edge& another) const{\n        return cost < another.cost;\n    }\n    bool operator>(const Edge& another) const{\n        return cost > another.cost;\n    }\n};\n\nclass dGrapf{\n    vector<vector<P>> grapf;\n    vector<int> d;\n    bool loop = false;\n    public:\n    dGrapf(int n){\n        this->grapf.resize(n);\n        this->d.resize(grapf.size(),max_int);\n    }\n    dGrapf(){\n        this->grapf.resize(10e6);\n        this->d.resize(grapf.size(),max_int);\n    }\n    /* 辺の元、先、コストの順\n     */\n    void edge(int parent,int child,int weight=1){\n        P p = P(child,weight);\n        grapf[parent].push_back(p);\n    }\n    void dijkstra(int n){\n        d[n] = 0;\n        PQ(que);\n        que.emplace(0,n);\n        while(!que.empty()){\n            P p = que.top();\n            que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(P e: grapf[v]){\n                if(d[e.first] > d[v]+e.second){\n                    d[e.first] = d[v]+e.second;\n                    que.emplace(d[e.first],e.first);\n                }\n            }\n        }\n    }\n    void bellmanford(int n){\n        fill(d.begin(), d.end(), max_int);\n        d[n] = 0;\n        bool update = true;\n        int cnt = 0;\n        while(update){\n            update = false;\n            REP(i,grapf.size()){\n                REP(j,grapf[i].size()){\n                    if(d[i] != max_int && d[grapf[i][j].first] > d[i] + grapf[i][j].second){\n                        d[grapf[i][j].first] = d[i] + grapf[i][j].second;\n                        update = true;\n                    }\n                }\n            }\n            cnt++;\n            if(cnt > grapf.size()){\n                loop = true;\n                return;\n            }\n        }\n    }\n    vector<int> topological_sort(){\n        vector<int> indeg(grapf.size(),0);\n        REP(i,grapf.size()){\n            for(auto v:grapf[i]){\n                indeg[v.first]++;\n            }\n        }\n        queue<int> que;\n        REP(i,indeg.size()){\n            if(indeg[i] == 0){\n                que.push(i);\n            }\n        }\n        vector<int> ans;\n        while(!que.empty()){\n            int u = que.front();\n            que.pop();\n            ans.push_back(u);\n            for(auto v:grapf[u]){\n                indeg[v.first]--;\n                if(indeg[v.first] == 0) que.push(v.first);\n            }\n        }\n        if(ans.size() != grapf.size()) loop = true;\n        return ans;\n    }\n\n    void print_AOJ(){\n        (loop)? print(1):print(0);\n    }\n    void De(){\n        REP(i,grapf.size()){\n            cout << \"{\";\n            for(P p:grapf[i]){\n                cout << \"{\" << p.first << \",\" << p.second << \"}\";\n            }\n            cout << \"}\\n\";\n        }\n        Debug(d);\n    }\n};\n\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int v,e;\n    cin >> v >> e;\n    dGrapf g(v);\n    REP(i,e){\n        int s,t,d;\n        cin >> s >> t;\n        g.edge(s,t,-1);\n    }\n    vector<int> a = g.topological_sort();\n    for(auto i:a){\n        print(i);\n    }\n\n    return 0;\n}\n\nvoid Debug(auto a){\n    cout << \"{ \";\n    for(auto b: a){\n        cout << b << \" \";\n    }\n    cout << \"}\" << endl;\n}\n\n//key以上の初めてのitr\nint nibul(auto a,auto b){return lower_bound(All(a),b) - a.begin();}\n//key以下の最後のitr\nint nibuu(auto a,auto b){return upper_bound(All(a),b) - a.begin()-1;}\n\nvoid input(vector<auto>& a,int n){\n    REP(i,n){\n        cin >> a[i];\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "package GRL_4;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayDeque<Integer> ans=topological_sort(e,0);\n\t\twhile(!ans.isEmpty()){\n\t\t\tSystem.out.println(ans.poll());\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayDeque<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayDeque<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// topological sort with dfs algorithm\n// reference Programming Contest Challenge Book Second Edition\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/1/GRL_4_B\n\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate<typename T> struct edge {\n  int to;\n\n  edge(int to_) : to(to_) {}\n};\n\ntemplate<typename T,template <typename ELEM> class C> struct Topological_Sort {\n  vector<vector<C<T>>> G;\n  vector<bool> used;\n  int V;//0,...,|V|-1\n  T INF;\n\n  Topological_Sort (int V_) {\n    init(V_);\n  }\n\n  void init(int V_) {\n    V = V_;\n\n    G.clear();\n    G.resize(V);\n  }\n\n  void add_edge(int from,int to) {\n    G[from].push_back(C<T>(to));\n  }\n\n  bool dfs (int i,set<int> pars,vector<int> &sorted) {\n    pars.insert(i);\n    used[i] = true;\n\n    rep(j,(int)G[i].size()) {\n      if (!used[G[i][j].to]) {\n        if(dfs(G[i][j].to,pars,sorted)) {\n          return true;\n        }\n      } else {\n        if (pars.find(G[i][j].to) != pars.end())  {\n          return true;\n        }\n      }\n    }\n\n    pars.erase(i);\n    sorted.push_back(i);\n    return false;\n  }\n\n  bool topological_sort (vector<int> &sorted) { // 成功ならtrue 失敗ならfalseを返す\n    used.clear();\n    used.resize(V,false);\n\n    sorted.clear();\n\n    rep (i,V) {\n      if (!used[i] && dfs(i,set<int>(),sorted)) {\n        return false;;\n      }\n    }\n\n    reverse(sorted.begin(),sorted.end());\n\n    return true;\n  }\n\n};\n\nusing ll = long long;\n\nint main() {\n  ll V,E;\n  cin >> V >> E;\n  Topological_Sort<ll,edge> ts(V);\n  rep(i,E) {\n    ll s,t;\n    cin >> s >> t;\n    ts.add_edge(s,t);\n  }\n\n  vector<int> ans;\n\n  ts.topological_sort(ans);\n\n  for (auto v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#define N 10000\nusing namespace std;\n\nint inNum[N]={0};\nint V,E;\nvector<int> M[N];\nvector<bool> visited(N,0);\nvoid topology(){\n    queue<int> Q;\n    vector<int> ans;\n    for(int i=0;i<V;i++){\n        if(inNum[i]==0) Q.push(i);\n    }\n    while(!Q.empty()){\n        int node=Q.front();\n        Q.pop();\n        visited[node]=true;\n        ans.push_back(node);\n        for(int i=0;i<M[node].size();i++){\n            inNum[M[node][i]]--;\n            if(!visited[M[node][i]] && inNum[M[node][i]]==0){\n                Q.push(M[node][i]);\n            }\n        }\n\n    }\n    if(ans.size()<V){\n        printf(\"Wrong\\n\");\n        return;\n    }else{\n        for(int i=0;i<ans.size();i++){\n            printf(\"%d\\n\",ans[i]);\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&V,&E);\n    for(int i=0;i<V;i++){\n        inNum[i]=0;\n    }\n    int s,t;\n    for(int i=0;i<E;i++){\n        scanf(\"%d%d\",&s,&t);\n        inNum[t]++;\n        M[s].push_back(t);\n    }\n\n    topology();\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector <int> res, graph[10000];\nbool visited[10000];\n\nvoid dfs(int v){\n  visited[v] = true;\n  for(int u : graph[v]){\n    if(!visited[u]){\n      dfs(u);\n    }\n  }\n  res.push_back(v);\n}\n\nvoid topological_sort(int n){\n  for(int i = 0; i < n; i++){\n    if(!visited[i]){\n      dfs(i);\n    }\n  }\n  reverse(res.begin(), res.end());\n}\n\nint main(){\n  int n, m, i, x, y;\n  cin >> n >> m;\n  while(m--){\n    cin >> x >> y;\n    graph[x].push_back(y);\n  }\n  topological_sort(n);\n  for(int x : res){\n    cout << x << \" \";\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao in 2019.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define INF 10e16\n#define MOD 1000000007\n#define  mod 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\n//using Int=int_fast64_t;\ntypedef long long int ll;\ntypedef pair<ll,ll>Pll;\ntypedef pair<int,int>Pin;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[8]={-1,0,1,0,1,1,-1,-1};\nint dy[8]={0,-1,0,1,1,-1,1,-1};\nchar dir[4]={'u','l','d','r'};\nll cmp1(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//--------------------------------------------------------------------------\nvector<int>G[100001];\nlist<int> out;\nbool V[100001];\nint N;\nint indeg[100001];\n\nvoid bfs(int s){\n    queue<int>q;\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        out.pb(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0;i<N;i++){\n        indeg[i]=0;\n    }\n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            indeg[G[u][i]]++;\n        }\n    }\n    for(int u=0;u<N;u++){\n        if(indeg[u]==0&&!V[u])bfs(u);\n    }\n    for(list<int>::iterator it=out.begin();it!=out.end();it++){\n        cout<<*it<<endl;\n    }\n}\n//---------------------------------------------------------------------------\nint main(){//問題をちゃんと見ろ!!!!!!!!!!!!!!!!!      llか??????????        memset()!!!!!!!!!!!!       ペナを減らせ!!!!!!!!!!!!!\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    int s,t,M;\n    cin>>N>>M;\n    for(int i=0;i<N;i++)V[i]=0;\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].pb(t);\n    }\n    tsort();\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nconst double EPS = 1e-10;\nusing namespace std;\n#define COUT(v) cout<<(v)<<endl\n#define CIN(n)  int(n);cin >> (n)\n#define LCIN(n) LL(n);cin >> (n)\n#define SCIN(n) string(n);cin >> (n)\n#define YES(n) cout<<((n)? \"YES\" : \"NO\")<<endl\n#define Yes(n) cout<<((n)? \"Yes\" : \"No\")<<endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) <<endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define P pair<LL,LL>\n#define I vector<int>\n#define pb(v) push_back(v)\n#define V vector\n#define rt return\n#define rmsame(a) sort(ALL(a)),a.erase(unique(ALL(a)), a.end())\n#define ENDL cout<<endl\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\ntypedef string::const_iterator State;\nclass PalseError {};\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(LL a,LL b,LL c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(LL a,LL b){\n        from = a;\n        to = b;\n    }\n};\n\n\n\nint main(){\n    int N,M;cin >> N >> M;\n    vector<vector<Edge>> Edges(N);\n    vector<int> deg(N, 0);//入力字数\n    for(int a = 0;a < M;a++){\n        int b,c;cin >> b  >> c;\n        deg[c]++;\n     //   b--;\n     //   c--;\n        Edges.at(b).push_back(Edge(b,c));\n    }\n    queue<int> S;\n    vector<int> L;\n    for(int a = 0;a < N;a++){\n        if(deg[a]==0)S.push(a);\n    }\n    vector<bool> flag(N,true);\n    while(!S.empty()){\n        int n = S.front();S.pop();\n        L.push_back(n);\n        for(auto e : Edges.at(n)){\n            deg[e.to]--;\n            if(deg[e.to] == 0)S.push(e.to);\n        }\n        flag.at(n)=false;\n    }\n    \n    for(int a = 0;a < N;a++){\n        if(flag.at(a)){\n            cout<<\"DAGではない\"<<endl;\n            return 0;\n        }\n    }\n    \n    for(int a = 0;a < L.size();a++){\n        COUT(L.at(a));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> topological_sort(const vector<vector<int>> &G) {\n  const int N = G.size();\n  vector<int> indeg(N, 0);\n  for(auto &&vs : G) {\n    for(int v : vs) {\n      indeg[v]++;\n    }\n  }\n  queue<int> Q;\n  for(int i = 0; i < N; ++i) {\n    if(indeg[i] == 0) Q.push(i);\n  }\n  vector<int> ret;\n  while(!Q.empty()) {\n    int v = Q.front(); Q.pop();\n    ret.push_back(v);\n    for(int u : G[v]) {\n      indeg[u]--;\n      if(indeg[u] == 0) Q.push(u);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  int V, E; cin >> V >> E;\n  vector<vector<int>> G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t; cin >> s >> t;\n    G[s].push_back(t);\n  }\n  for(auto &&v : topological_sort(G)) {\n    cout << v << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nint main(){\n  int v, e;\n  cin >> v >> e;\n  vector<int> g[v];\n  vector<int> h(v);\n  rep(i,e){\n    int a, b;\n    cin >> a >> b;\n    g[a].push_back(b);\n    h[b]++;\n  }\n  queue<int> que;\n  rep(i,v) if(h[i] == 0) que.push(i);\n  vector<int> ans;\n  while(!que.empty()) {\n    int p = que.front(); que.pop();\n    ans.push_back(p);\n    for(auto i : g[p]) {\n      h[i]--;\n      if(h[i] == 0) que.push(i);\n    }\n  }\n  rep(i,v) cout << ans[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <queue>\n#define V_MAX 10000\n#define E_MAX 100000\nusing namespace std;\n\nint V,E;\nbool check[V_MAX+1];//頂点が探索済みかどうか保管\nqueue<int> G[V_MAX+1];//隣接リスト\nvector<int> TO;\n\nvoid dfs(int num){\n\tif(check[num] == true)return;\n\tcheck[num] = true;\n\twhile(!G[num].empty()){\n\t\tdfs(G[num].front());G[num].pop();\n\t}\n\tTO.push_back(num);\n\treturn;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < V;i++)check[i] = false;\n\tint vs,ve;\n\tfor(int i = 0;i < E;i++){\n\t\tcin >>vs >>ve;\n\t\tG[vs].push(ve);\n\t}\n\tfor(int i = 0;i < V;i++)dfs(i);\n\twhile(!TO.empty()){cout <<TO.back() <<endl;TO.pop_back();}\n\treturn;\n}\n\nint main(){\n\tcin >>V >>E;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\nstruct Node {\n\tbool flag = true;\n\tvector<int> c;\n};\n\nlist<int> out;\n\nvoid dfs(vector<Node>& v, int n)\n{\n\tv[n].flag = false;\n\tfor (int i = 0; i < v[n].c.size(); i++)\n\t{\n\t\tif (v[v[n].c[i]].flag) dfs(v, v[n].c[i]);\n\t}\n\tout.push_front(n);\n}\n\nvoid topologicalSort(vector<Node>& v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (v[i].flag) dfs(v, i);\n\t}\n}\n\nint main(void)\n{\n\tint V, E, s, t;\n\tcin >> V >> E;\n\tvector<Node> v(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> s >> t;\n\t\tv[s].c.push_back(t);\n\t}\n\n\ttopologicalSort(v);\n\n\tfor (int i = 0; i < V; i++) {\n\t\tcout << out.front() << endl;\n\t\tout.pop_front();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <math.h>\n#include <set>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n ; i++)\n#define pb push_back\nstatic const int MAX = 100000;\nstatic const int INF = 1000000;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint main(void){\n  int V,E; cin >> V >> E;\n  vector<int> list[MAX]; int into[V];\n  int a,b;\n  rep(i,V){\n    into[i] = 0;\n  }\n  rep(i,E){\n    cin >> a >> b;\n    list[a].pb(b);\n    into[b] += 1;\n  }\n  queue<int> Q;\n  rep(i,V){\n    if (into[i] == 0) Q.push(i);\n  }\n\n  while(!Q.empty()){\n      cout << Q.front() << endl;\n\n      //cout << endl;\n\n      rep(i,list[Q.front()].size()){\n        into[list[Q.front()][i]] -= 1;\n        if(into[list[Q.front()][i]] == 0) Q.push(list[Q.front()][i]);\n      }\n\n\n      Q.pop();\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>adj[10010];\nint vis[10010];\nint cnt=0,flag;\nstack<int>st;\nvoid dfs(int s)\n{\n    int i,j,u;\n    vis[s]=1;\n    for(i=0;i<adj[s].size();i++)\n    {\n        u=adj[s][i];\n        if(vis[u]==0)\n        {\n            dfs(u);\n        }\n    }\n    vis[s]=2;\n    st.push(s);\n}\nvoid cl()\n{\n    for(int i=0;i<=10000;i++)\n    {\n        vis[i]=0;\n    }\n}\nint main()\n{\n    int n,m,a,b,i,u;\n    cin>>n>>m;\n    for(i=1;i<=m;i++)\n    {\n        cin>>a>>b;\n        adj[a].push_back(b);\n    }\n    cl();\n    for(i=n-1;i>=0;i--)\n    {\n        if(vis[i]==0)\n        {\n            dfs(i);\n        }\n    }\n\n        while(!st.empty())\n        {\n            u=st.top();\n            printf(\"%d\\n\",u);\n            st.pop();\n        }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <list>\nusing namespace std;\nint V,E;\nvector<int> G[100000];\nint visited[10000];\nint L[100000];\nint s=0;\nvoid visit(int n){\n  if(visited[n]==0){\n    visited[n]=1;\n    for(int i=0;i<G[n].size();i++){\n      visit(G[n][i]);\n    }\n    L[s++]=n;\n  }\n}\nvoid topological(){\n  for(int i=V-1;i>=0;i--){\n    visit(i);\n  }\n}\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int s,t;\n    scanf(\"%d %d\",&s,&t);\n    G[s].push_back(t);\n  }\n  topological();\n  for(int i=V-1;i>=0;i--)printf(\"%d\\n\",L[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntemplate<typename T> using v = vector<T>;\ntemplate<typename T> using pq = priority_queue<T>;\ntemplate<typename T> using minpq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T, typename K> using ump = unordered_map<T, K>;\nconst ll dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst ll mod = 1000000007;\nconst ll inf = ll(1e9);\nconst ll e5 = ll(1e5);\nconst ll ll_inf = ll(1e9) * ll(1e9);\n\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n#define repr(i, n) for(ll i = n - 1; i >= 0; i--)\n#define repone(i, n) for(ll i = 1; i <= (ll)(n); i++)\n#define each(i, mp) for(auto& i:mp)\n#define eb emplace_back\n#define F first\n#define S second\n#define all(obj) (obj).begin(), (obj).end()\n\ntemplate<class T>\nvoid dumplist_debug(T list) {\n#ifdef MY_DEBUG\n    each(e, list) cout << e << \" \";\n    printf(\"\\n\");\n#endif\n}\n\nll inl() {\n    ll x;\n    cin >> x;\n    return (x);\n}\n\nstring ins() {\n    string x;\n    cin >> x;\n    return x;\n}\n\n/* ------------- ANSWER ------------- */\n/* ---------------------------------- */\n\nclass DAG {\nprivate:\n    ll v, e;\n    vvl table;\n    vl in_d; // 頂点の入力次数\npublic:\n    // v: 頂点数\n    // e: 辺の数\n    DAG(ll v, ll e) {\n        this->v = v;\n        this->e = e;\n        table.resize(v);\n        in_d.resize(v);\n    }\n\n    void add(ll from, ll to) {\n        table[from].eb(to);\n        in_d[to]++;\n    }\n\n    // O(v + e)\n    vl sort() {\n        stack<ll> st; // 入力次数が0の頂点集合\n\n        dumplist_debug(in_d);\n        rep(i, v) if (in_d[i] == 0) st.push(i);\n        vl ans; // ソート後のグラフ\n\n        while (!st.empty()) {\n            ll i = st.top();\n            st.pop();\n            ans.eb(i);\n            each(j, table[i]) {\n                in_d[j]--;\n                if (in_d[j] == 0) st.push(j);\n            }\n        }\n\n        return ans;\n    }\n};\n\nint main() {\n#ifdef MY_DEBUG\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wmissing-noreturn\"\n    while (true) {\n#pragma clang diagnostic pop\n#endif\n        ll v, e;\n        cin >> v >> e;\n        DAG dag(v, e);\n        rep(i, e) {\n            ll s = inl(), t = inl();\n            dag.add(s, t);\n        }\n        vl ans = dag.sort();\n        each(m, ans) cout << m << endl;\n\n#ifdef MY_DEBUG\n    }\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// topological sort (breadth first search)\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <utility>\n\nconst int N = 10010;\nconst int M = 100010;\n\nstruct Edge {\n\tint to, next;\n} es[M];\n\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint in[N], queue[N]; // in-degree, queue for BFS\n\ninline void add(int u, int v) {\n\tint i = ++SIZE;\n\tes[i].to = v;\n\tes[i].next = h[u];\n\th[u] = i; \n}\n\nvoid run() {\n\tint n, m, x, y;\n\tscanf(\"%d%d\", &n, &m);\n\tmemset(h, 0, sizeof(h));\n\tmemset(in, 0, sizeof(in));\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tin[y] += 1;\n\t}\n\tint front = 0, back = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (in[i] == 0)\n\t\t\tqueue[back++] = i;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tfor (int i = h[x]; i != 0; i = es[i].next) {\n\t\t\tint y = es[i].to;\n\t\t\tin[y] -= 1;\n\t\t\tif (in[y] == 0)\n\t\t\t\tqueue[back++] = y;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d\\n\", queue[i]);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<iostream>\nusing namespace std;\n\nint s,t,V,E;\nbool flag[10100]={false};\nvector<int> A[10100];\nlist<int> ans;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid dfs(int u){\n    flag[u]=true;\n    for(int i=0;i<A[u].size();++i){\n        int v=A[u][i];\n        if(flag[v]==false){\n            dfs(v);\n        }\n    }\n    ans.push_front(u);\n}\n\nvoid tp_srt(){\n    for(int i=0;i<V;++i){\n        if(flag[i]==false) dfs(i);\n    }\n}\n\nint main(){\n    cin>>V>>E;\n    Fill(flag,false);\n    for(int i=0;i<E;++i){\n        cin>>s>>t;\n        A[s].push_back(t);\n    }\n\n    tp_srt();\n\n    for(list<int>::iterator i=ans.begin();i!=ans.end();++i){\n        cout<<*i<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define enld endl //* missspell check\nconst ll INF = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n\nstruct TopologicalSort{\n    vector<vll> G; //* DAG\n    TopologicalSort(ll N){ G.resize(N); }\n    void add_edge(ll a, ll b) { G[a].push_back(b); }\n    bool visit_by_dfs(vll &order, vll &color, ll v) {\n        //* color[v] meaning: 0: unvisited, 1: pre-visit, 2: post-visit\n        //! return false if this graph has a cycle\n        color[v] = 1; //* pre-visit this vertex\n        for(auto u: G[v]) {\n            if(color[u] == 2) continue; //* this vertex is done (already put in order)\n            if(color[u] == 1) return false; //* re-visit this vertex means a cycle\n            if(!visit_by_dfs( order, color, u)) return false; //* a cycle detected further\n        }\n        order.push_back(v);\n        color[v] = 2;\n        return true;\n    }\n    bool sort(vll &order) {\n        //! return false if this graph has a cycle\n        ll n = G.size();\n        vll color(n, 0);\n        REP(u, n) if( !color[u] && !visit_by_dfs(order, color, u)) return false;   \n        reverse(order.begin(), order.end()); \n        return true;\n    }\n};\n\nint main(){\n    ll N, M; cin >> N >> M;\n    TopologicalSort st(N);\n    REP(_, M){\n        ll u, v; cin >> u >> v;\n        st.add_edge(u, v);\n    }\n    vll order;\n    st.sort(order);\n    REP(i, N) cout<< order[i] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define IOS ios::sync_with_stdio(false), cin.tie(0)\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define ALL(x) (x).begin(), (x).end()\n#define dump(x) cout << (x) << endl\n#define LMAX 9223372036854775807LL\n#define LMIN -9223372036854775807LL\nusing ll = int64_t;\ntemplate<typename T>\nusing vec = vector<T>;\nusing P = pair<ll, ll>;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n\tfill((T *)array, (T *)(array + N), val);\n}\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//ll pas[5001][5002];\n\nvec<ll> ans, tmp;\nstack<ll> st;\nvec<ll> g[114514];\nll h[114514];\n\nsigned main(){\n\tIOS;\n\tll V, E;\n\tcin >> V >> E;\n\tREP(i, E){\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t\th[t]++;\n\t}\n\tREP(i, V){\n\t\tif(h[i] == 0)st.push(i);\n\t}\n\twhile(!st.empty()){\n\t\tll i = st.top();\n\t\tst.pop();\n\t\tans.push_back(i);\n\t\tfor(auto& j : g[i]){\n\t\t\th[j]--;\n\t\t\tif(h[j] == 0)st.push(j);\n\t\t}\n\t}\n\tfor(auto& i : ans)dump(i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<set<int> > in,out;\n  vector<int> sorted;\n  TSort(){V = 0;}\n  TSort(int V){\n    in.resize(V);\n    out.resize(V);\n    this->V = V;\n  }\n  \n  void add_edge(int from,int to){\n    assert(from < V && to < V);\n    assert(out[from].count(to) == 0);\n    assert(in[to].count(from) == 0);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  void sort(){\n    sorted.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n\n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      sorted.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n\n    for(int i=0;i<V;i++) if(!in[i].empty()) sorted.clear(); // exist loop\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n\n  A.sort();\n  \n  for(int i=0;i<n;i++)cout<<A.sorted[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\tfor(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\nif(V!=order.size())return 1;\n\t\t\tfor(i=0;i<V;i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[10010];\nvector<int> L;\nint temporary[10010], permanent[10010];\n\nvoid dfs(int v)\n{\n    if (temporary[v]) return;\n    if (permanent[v]) return;\n    temporary[v]=true;\n    for(auto& u: G[v]) dfs(u);\n    permanent[v]=true;\n    L.push_back(v);\n}\n\nint main()\n{\n    int V, E; cin>>V>>E;\n    for(int i=0; i<E; ++i) {\n        int s, t; cin>>s>>t;\n        G[s].push_back(t);\n    }\n\n    for(int i=0; i<V; ++i) {\n        if (permanent[i] || temporary[i]) continue;\n        dfs(i);\n    }\n\n    cout<<L.size()<<endl;\n    for(int i=V-1; i>=0; --i) cout<<L[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, N) for (int i = 0; i < (int)N; i++)\n\nvector<vector<int>> adjacentList;\nvector<bool> visited;\nstack<int> sorted;\n\nvoid visit(int i) {\n  if(visited[i]) return;\n  visited[i] = true;\n  for(int nn: adjacentList[i]) {\n    visit(nn);\n  }\n  sorted.push(i);\n}\n\nint main () {\n  int V, E;\n  cin >> V >> E;\n\n  adjacentList = vector<vector<int>>(V, vector<int>());\n  visited = vector<bool>(V, false);\n\n  REP(i,E) {\n    int s, t;\n    cin >> s >> t;\n    adjacentList[s].push_back(t);\n  }\n\n  REP(i, V) visit(i);\n\n  while(!sorted.empty()) {\n    cout << sorted.top() << endl;\n    sorted.pop();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass TSort\n{\npublic:\n  int solve();\n  void dfs( vector<vector<int>>& adj, vector<bool>& vd, vector<int>& rt, int u );\n};\n\nint TSort::solve()\n{\n  int nv, ne;\n  cin >> nv >> ne;\n\n  vector<vector<int>> adj(nv, vector<int>(nv, 0));\n  vector<bool> visited(nv, false);\n  vector<int> ret;\n\n  for ( auto i = 0; i < ne; ++i )\n    {\n      int s, t;\n      cin >> s >> t;\n      adj[s][t] = 1;\n    }\n\n  for ( auto i = 0; i < nv; ++i )\n    {\n      if ( ! visited[i] )\n        dfs( adj, visited, ret, i );\n    }\n\n  for ( auto i = 0; i < nv; ++i )\n    cout << ret[nv - 1 - i] << endl;\n  \n  return 0;\n}\n\nvoid TSort::dfs( vector<vector<int>>& adj, vector<bool>& vd, vector<int>& rt, int u )\n{\n  vd[u] = true;\n\n  int nv = adj.size();\n  \n  for ( auto v = 0; v < nv; ++v )\n    {\n      if ( vd[v] == false && adj[u][v] == 1 )\n        {\n          dfs( adj, vd, rt, v );\n        }\n    }\n\n  rt.push_back( u );\n}\n\nint main()\n{\n  TSort ts;\n\n  ts.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n    V[u] = true;\n    for(int i=0; i<G[u].size(); i++){\n        int v = G[u][i];\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> N >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    for(int i=0; i<N; i++){\n        if(!V[i]) dfs(i);\n    }\n    \n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int, int> P;\n\n\nclass Topological_Sort {\nprivate:\n\tint n;\n\tvvi G;\n\tvi visited;\npublic:\n\tdeque<int> ret;\n\tTopological_Sort(vvi A) {\n\t\tG = A;\n\t\tn = G.size();\n\t\tvisited.resize(n);\n\t\tfill(visited.begin(), visited.end(), 0);\n\t\tmainf();\n\t}\n\tvoid mainf() {\n\t\tLoop(i, n) {\n\t\t\tif (visited[i] == 0) dfs(i);\n\t\t}\n\t}\n\tbool dfs(int a) {\n\t\tif (visited[a] == 1) {\n\t\t\tret.clear();\n\t\t\treturn -1;\n\t\t}\n\t\telse if (visited[a] == 0) {\n\t\t\tvisited[a] = 1;\n\t\t\tLoop(j, G[a].size()) {\n\t\t\t\tif (dfs(G[a][j])) return -1;\n\t\t\t}\n\t\t\tvisited[a] = 2;\n\t\t\tret.push_front(a);\n\t\t}\n\t\treturn 0;\n\t}\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvvi A(n);\n\tLoop(i, m) {\n\t\tint s, t; cin >> s >> t;\n\t\tA[s].push_back(t);\n\t}\n\tTopological_Sort ts(A);\n\tLoop(i, ts.ret.size()) {\n\t\tcout << ts.ret[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//GRL_4B\n#include <iostream>\n#include<algorithm>\n#include <vector>\n#include <queue>\n#include <list>\nusing namespace std;\n \nstatic const int MAX=100000;\nstatic const int INF=(1<<29);\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n queue<int> q;\n q.push(s);\n V[s]=true;\n while(!q.empty()){\n  int u=q.front(); q.pop();\n  out.push_back(u);\n  for(int i=0;i<G[u].size();i++){\n   int v=G[u][i];\n   indeg[v]--;\n   if(indeg[v]==0 && !V[v]){\n    V[v]=true;\n    q.push(v);\n   }\n  }\n }\n}\n\nvoid tsort(){\n for(int i=0;i<N;i++) indeg[i]=0;\n for(int u=0;u<N;u++){\n  for(int i=0;i<G[u].size();i++){\n   int v=G[u][i];\n   indeg[v]++;\n  }\n }\n for(int u=0;u<N;u++)\n  if(indeg[u]==0 && !V[u]) bfs(u);\n for(list<int>::iterator it=out.begin();it!=out.end();it++){\n  cout<<*it<<endl;\n }\n}\n\nint main(){\n int s,t,M;\n cin>>N>>M;\n for(int i=0;i<N;i++) V[i]=false;\n for(int i=0;i<M;i++){\n  cin>>s>>t;\n  G[s].push_back(t);\n }\n tsort();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 10000;\nint n, DAG[MAX][MAX], color[MAX], indeg[MAX];\nvector<int> v;\n// queue<int> q;\n\nvoid bfs(int s);\n\nvoid topologicalSort(){\n  for(int i=0;i<n;i++){\n    color[i] = 0;\n  }\n  for(int i=0;i<n;i++){\n    if(color[i] == 0 && indeg[i] == 0){\n      bfs(i);\n    }\n  }\n}\n\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  color[s] = 1;\n\n  while(!q.empty()){\n    int u = q.front(); q.pop();\n    v.push_back(u);\n\n    for(int i=0;i<n;i++){\n      if(DAG[u][i] == 1){\n        indeg[i]--;\n        if(indeg[i] == 0 && color[i] == 0){\n          q.push(i);\n          color[i] = 1;\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  int e;\n  cin >> n >> e;\n  int s, t;\n  for(int i=0;i<e;i++){\n    cin >> s >> t;\n    DAG[s][t] = 1;\n    indeg[t]++;\n  }\n\n  topologicalSort();\n\n  for(int i=0;i<n;i++) cout << v[i] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <list>\n\nconst int MAX = 100000;\nconst int MOD = 1e9 + 7;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing ll = long long int;\nusing namespace std;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u)\n{\n    V[u] = true;\n    for(int i = 0; i < G[u].size(); i++)\n    {\n        int v = G[u][i];\n        if(!V[v]) dfs(v);\n    }\n\n    out.push_front(u);\n}\n\n\nint main()\n{\n    int s, t, M;\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++)\n        V[i] = false;\n\n    for(int i = 0; i < M; i++)\n    {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n        if(!V[i]) dfs(i);\n\n    for(auto it = out.begin(); it != out.end(); it++)\n        cout << *it << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[100];\nint in[100];\nbool used[100];\nint main() {\n\tint v, e; scanf(\"%d%d\", &v, &e);\n\trep(i, e) {\n\t\tint s, t; scanf(\"%d%d\", &s, &t);\n\t\tE[s].push_back(t);\n\t\tin[t]++;\n\t}\n\tlist<int>ls;\n\tqueue<int>que;\n\trep(i, v) {\n\t\tif (!used[i] && !in[i])que.push(i);\n\t\twhile (!que.empty()) {\n\t\t\tint p = que.front(); que.pop();\n\t\t\tused[p] = true; ls.push_back(p);\n\t\t\tfor (int u : E[p]) {\n\t\t\t\tin[u]--;\n\t\t\t\tif (!used[u] && !in[u])que.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i : ls) {\n\t\tprintf(\"%d\\n\", i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#define N 10000\nusing namespace std;\n\nlist<int> l;\nbool color[N]={false};\nvector<int> adj[N];\nint n;\n\nvoid topo(int k){\n\tfor(int i=0;i<adj[k].size();i++){\n\t\tif(!color[adj[k][i]])topo(adj[k][i]);\n\t}\n\tif(!color[k])l.push_front(k);\n\tcolor[k]=true;\n}\n\nint main(void){\n\tint u,v;\n\tint e;\n\tcin>>n>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!color[i])topo(i);\n\t}\n\tfor(list<int>::iterator it=l.begin();it!=l.end();it++)cout<<*it<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 0);\n\n    for (int i = 0; i < E; i++) {\n        state[edge[i].second]++;\n    }\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 0) {\n                ans.push_back(i);\n                for (int j = 0; j < E; j++) {\n                    if (edge[j].first == i) state[edge[j].second]--;\n                }\n                state[i]--;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e16;\nconst ll mod = 1000000007;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ntemplate<class T> inline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint ctoi(char c) {\n  if (c >= '0' && c <= '9') {\n    return c - '0';\n  }\n  return 0;\n}\nll factorial(ll n) {\n  if (n == 1) {\n    return 1;\n  }\n  ll ans = factorial(n-1);\n  return ans*n;\n}\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\nll lcm(ll a, ll b) {\n  return (a/gcd(a, b))*b;\n}\nbool is_prime(ll n) {\n  for (ll i = 2; i*i <= n; i++) {\n    if (n%i == 0) return false;\n  }\n  return n != 1;\n}\nll mod_pow(ll x, ll n, ll mod) {\n  if (n == 0) return 1;\n  ll res = mod_pow(x*x%mod, n/2, mod);\n  if (n & 1) res = res * x % mod;\n  return res;\n}\n\nconst ll MAX = 10000;\nvector <bool> color(MAX);\nvector <ll> indeg(MAX);\nvector <vector <ll>> v(MAX, vector <ll> ());\nqueue <ll> q;\nvector <ll> res;\n\nvoid bfs(ll n) {\n  q.push(n);\n  color.at(n) = 0;\n  while (!q.empty()) {\n    ll j = q.front(); q.pop();\n    res.push_back(j);\n    rep(k, v.at(j).size()) {\n      ll tmp = v.at(j).at(k);\n      indeg.at(tmp)--;\n      if (indeg.at(tmp)==0 && color.at(tmp)) {\n        color.at(tmp) = 0;\n        q.push(tmp);\n      }\n    }\n  }\n  return;\n}\n\nvoid tsort(ll n) {\n  rep(i, n) {\n    color.at(i) = 1;\n    indeg.at(i) = 0;\n  }\n  rep(i, n) {\n    rep(j, v.at(i).size()) {\n      ll tmp = v.at(i).at(j);\n      indeg.at(tmp)++;\n    }\n  }\n  rep(i, n) {\n    if (indeg.at(i)==0 && color.at(i)) {\n      bfs(i);\n    }\n  }\n  rep(i, res.size()) {\n    cout << res.at(i) << endl;\n  }\n  return;\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  rep(i, m) {\n    ll s, t;\n    cin >> s >> t;\n    v.at(s).push_back(t);\n  }\n  tsort(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\nvector<int> topologicalSort(const Graph &G){\n\tint n = G.size();\n\tvector<int> in(n),ret;\n\tqueue<int> que;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int to : G[i]) in[to]++;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(!in[i]) que.push(i);\n\t}\n\twhile(!que.empty()){\n\t\tint v = que.front(); que.pop();\n\t\tret.push_back(v);\n\t\tfor(int to : G[v]){\n\t\t\tin[to]--;\n\t\t\tif(!in[to]) que.push(to);\n\t\t}\n\t}\n\treturn ret;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tGraph G(n);\n\tfor(int i = 0;i < m;i++){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\tauto topo = topologicalSort(G);\n\tfor(int v : topo) cout << v << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a)-1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a)-1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cerr << C << endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, e) (s.find(e) != s.end())\n#define EB emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nclass TopologicalSort {\nprivate:\n    vector <bool> is;\n    vector <vector <int>> g;\n    vector <int> tsort;\n    void dfs(int now) {\n        if (is[now]) return;\n        is[now] = true;\n        for (auto &&el:g[now]) {\n            dfs(el);\n        }\n        tsort.emplace_back(now);\n    }\npublic:\n    TopologicalSort() {}\n    TopologicalSort(vector <vector <int>> graph) {\n        g = graph;\n        is.resize(g.size());\n    }\n    vector <int> sort() {\n        for (int i = 0; i < g.size(); i++) {\n            dfs(i);\n        }\n        reverse(tsort.begin(), tsort.end());\n        return tsort;\n    }\n};\n\nint main(void) {\n    int V, E;\n    VII graph;\n    cin >> V >> E;\n    graph.resize(V);\n    REP(i, E) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        graph[a].EB(b);\n    }\n    TopologicalSort ts(graph);\n    auto ans = ts.sort();\n    FORE(el, ans) cout << el << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n#include <numeric>\nusing namespace std;\n#define rep(i,a,b) for(int64_t i=(a);i<(b);++i) // a ≦ i < b \n#define Rrep(i,a,b) for(int64_t i=(a);i>=(b);--i) // reverse repeat. a から b まで減少．\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend() //逆イテレータ\n#define RANGE(a,b,c) (a).begin()+(b),(a).begin()+(c) // [b,c) イテレータ\n#define INF 1000000000000000\n#define MOD 1000000007\nusing PII = pair<int64_t, int64_t>;\nusing VI = vector<int64_t>;\nusing VVI = vector<VI>;\nusing VS = vector<string>;\nusing VP = vector<PII>;\nusing i64 = int64_t;\ntemplate<typename T> void invec(vector<T> &A){for(T& a:A) cin >> a;}\n\nvoid topsort(int v, const VVI &G, vector<bool> &seen, VI &order){\n    seen[v] = true;\n    for(int nv : G[v]){\n        if (seen[nv]) continue;\n        topsort(nv, G, seen, order);\n    }\n    order.push_back(v);\n}\n\nint main() {\ncin.tie(0);\nios::sync_with_stdio(false);\n\nint V, E; cin >> V >> E;\nVVI G(V);\nrep(_, 0, E){\n    int s, t;  cin >> s >> t;\n    G[s].push_back(t);\n}\n\nvector<bool> seen(V, 0);\nVI order; // トポロジカルソート順。\nrep(v, 0, V){\n    if (seen[v]) continue;\n    topsort(v, G, seen, order);\n}\nreverse(ALL(order));\n\nfor(int i: order) cout << i << \"\\n\";\n\nreturn 0;\n}\n// コンテスト前はtemplate振り返り。\n// 書いて考える．場合分け．情報整理．\n// 問題文から考える。自分ができることから考える。\n// 単純に分かる量から．愚直解を実装して研究．\n// 境界，出力文字列 チェック．行末にスペース入れない．\n// 可読性優先．高速化次点．\n// まずは全探索，分割，次にDP(小さい問題から大きな問題)\n// 制限を見る．境界に注意．求めたい量の変域．動かせる量．\n// 偶奇，逆から，ソート，出現回数，出現位置，DP， 余事象，包除\n// データ構造． 問題の特徴量．単調性→二分探索。逆から考える。\n// 存在判定：構成方法，入力の特徴\n// 構築問題。極端解を試す。\n// 例外を十分に含む一般化．想像力の限界\n// 小さい系から例示\n// 代数的処理．前処理によるクエリ高速化．\n// 始めは過剰に例示・場合分けしてもいい．各場合を確実に対処．\n// 自明な例から処理，除外．\n// 小数のときは，精度の設定する．doubel 変数に数値を入力するときは 123. とする．\n// コーナーケース。境界値。数表出力プログラム作る\n// 実行エラー：vector添え字超え．0割り．\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n\tfor (const auto &e : vec) os << e << (&e == &vec.back() ? \"\" : \" \");\n\treturn os;\n}\n\n#ifdef _DEBUG\ntemplate <class T>\nvoid dump(const char* str, T &&h) { cerr << str << \" = \" << h << \"\\n\"; };\ntemplate <class Head, class... Tail>\nvoid dump(const char* str, Head &&h, Tail &&... t) {\n\twhile (*str != ',') cerr << *str++; cerr << \" = \" << h << \"\\n\";\n\tdump(str + (*(str + 1) == ' ' ? 2 : 1), t...);\n}\n#define DMP(...) dump(#__VA_ARGS__, __VA_ARGS__)\n#else \n#define DMP(...) ((void)0)\n#endif\n\nclass topological_sort {\nprivate:\n\tint V;\n\tvector<vector<int>> edges;\n\tvector<int> in;\npublic:\n\ttopological_sort(int n) :V(n), edges(n), in(n) {}\n\ttopological_sort(vector<vector<int>> &edges) :V(edges.size()), in(edges.size()) { this->edges = edges; }\n\n\tvoid add_edge(int from, int to) { edges[from].emplace_back(to); }\n\n\tvector<int> build() {\n\n\t\tfor (int i = 0; i < V; i++) for (const auto &e : edges[i]) in[e]++;\n\t\tvector<int> used(V), res;\n\t\tres.reserve(V);\n\n\t\tqueue<int> que;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (in[i] == 0 && !used[i]) {\n\t\t\t\tused[i] = 1;\n\t\t\t\tque.emplace(i);\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tDMP(now, in);\n\t\t\tque.pop();\n\t\t\tres.emplace_back(now);\n\t\t\tfor (const auto &e : edges[now]) {\n\t\t\t\tin[e]--;\n\t\t\t\tif (in[e] == 0) {\n\t\t\t\t\tif (used[e]) return vector<int>(); // unable to sort\n\t\t\t\t\tused[e] = 1;\n\t\t\t\t\tque.emplace(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n};\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, e;\n\tcin >> n >> e;\n\n\tvector<vector<int>> edges(n);\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tedges[s].emplace_back(t);\n\t}\n\n\ttopological_sort ts(edges);\n\tauto ans = ts.build();\n\tfor (const auto &e : ans) cout << e << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nusing VL=vector<ll>;\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\nconst long long INF =  999999999;\n\ntemplate <typename T>\nvector<T> topologicalsort(vector<vector<T>> g,T v){\n  T h[v];\n  fill(h,h+v,0);\n  //頂点は0~N-１と番号付けられていることに注意\n  REP(i,g.size()){\n    REP(j,g[i].size()){\n      h[g[i][j]]++;\n    }\n  }\n  \n  stack <T> st;\n  REP(i,v)if(h[i]==0)st.push(i);\n\n  vector<T> ans;\n  while(st.size()){\n    T s=st.top();st.pop();\n    ans.push_back(s);\n    REP(i,g[s].size()){\n      h[g[s][i]]--;\n      if(h[g[s][i]]==0)st.push(g[s][i]);\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n  vector<vector<ll>> g(N);\n  ll s,t;\n  REP(i,M){\n    scanf(\"%lld %lld\",&s,&t);\n    g[s].push_back(t);\n  }\n  vector <ll> ans;\n  ans=topologicalsort(g,N);\n  REP(i,ans.size()){\n    cout << ans[i]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\n#include<list>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst int MAX=100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint n;\nint indeg[MAX];\n\nvoid bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\tV[s]=true;\n\tint u,v;\n\t\n\twhile(!q.empty())\n\t{\n\t\tu=q.front();q.pop();\n\t\tout.push_back(u);\n\t\tfor(int i=0;i<G[u].size();i++)\n\t\t{\n\t\t\tv=G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(!V[v]&&indeg[v]==0)\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nvoid topologicalsort()\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tindeg[i]=0;\n\t\tV[i]=false;\n\t}\n\t\n\tfor(int u=0;u<n;u++)\n\t{\n\t\tfor(int i=0;i<G[u].size();i++)\n\t\t{\n\t\t\tindeg[G[u][i]]++;\n\t\t}\n\t}\n\t\n\tfor(int u=0;u<n;u++)if(!V[u]&&indeg[u]==0)bfs(u);\n\t\n\tfor(auto it:out)cout<<it<<endl;\n\t\n\treturn;\n}\n\nint main()\n{\n\tint m;cin>>n>>m;\n\tint s,t;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t}\n\ttopologicalsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 頂点数、変数\nint v, e;\nconst int MAX_N = 10010;\n// 隣接リスト\nvector<int> g[MAX_N];\nbool used[MAX_N];\n// トポロジカルソートされた数列\nvector<int> ans;\n\nvoid dfs(int u) {\n  if(used[u]) return;\n  used[u] = true;\n  for(auto& i: g[u]) dfs(i);\n  // 帰りがけ順で追加\n  ans.push_back(u);\n}\n\nvoid tsort() {\n  for(int i=0; i<v; ++i) dfs(i);\n  reverse(ans.begin(), ans.end());\n}\n\nsigned main(void)\n{\n  cin >> v >> e;\n  for(int i=0; i<e; ++i) {\n    int s, t;\n    cin >> s >> t;\n    g[s].push_back(t);\n  }\n\n  tsort();\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\ntemplate<typename T>\nclass TopologicalSort {\nprivate:\n    map<T, bool> is;\n    map<T, vector<T>> g;\n    vector<T> tsort;\n\tmap<T, long long> inCnt;\n    void dfs(T now) {\n        if (is[now]) return;\n\t\tis[now] = true;\n        for (auto &&el : g[now]) {\n            dfs(el);\n        }\n        tsort.emplace_back(now);\n    }\npublic:\n    TopologicalSort() {}\n\tTopologicalSort(const vector<T>& vec) {\n\t\tfor (auto &&el : vec) {\n\t\t\tg[el].resize(0);\n\t\t\tis[el] = false;\n\t\t\tinCnt[el] = 0;\n\t\t}\n\t}\n    vector<T> dfsTsort() {\n        for (auto &&el : g) {\n            dfs(el.first);\n        }\n        reverse(tsort.begin(), tsort.end());\n        return tsort;\n    }\n\tvoid addEdge(T src, T dst) {\n\t\tg[src].emplace_back(dst);\n\t\tinCnt[dst]++;\n\t}\n\tvector<T> bfsTsort() {\n\t\tqueue<T> q;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second == 0) {\n\t\t\t\tq.push(el.first);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tT now = q.front(); q.pop();\n\t\t\ttsort.emplace_back(now);\n\t\t\tfor (auto &&el : g[now]) {\n\t\t\t\tif (--inCnt[el] == 0) q.push(el);\n\t\t\t}\n\t\t}\n\t\tbool endFlag = true;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second) endFlag = false;\n\t\t}\n\t\treturn (endFlag ? tsort : vector<T>());\n\t}\n};\n\nint main(void) {\n\tint V, E;\n\tcin >> V >> E;\n\tVI v(V);\n\tiota(ALL(v), 0);\n\tTopologicalSort<int> t(v);\n\tREP(_, E) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\t\tt.addEdge(s, d);\n\t}\n\tauto ans = t.bfsTsort();\n\tFORE(el, ans) cout << el << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <cassert>\n#include <iomanip>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <functional>\n#include <fstream>\n#include <numeric>\n\n#define FOR(i, a, n) for(int i=(a);i<(n); ++i)\n#define FOE(i, a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\n#define IS_BIT_ON(bit, i) (bit & (1 << i))\n#define BIT_ON(bit, i) (bit |= (1 << i))\n#define BIT_OFF(bit, i) (bit &= ~(1 << i))\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a) { return std::vector<T>(a); }\n\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) { return std::vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }    // C++14\ntemplate<typename T, typename V>\ntypename std::enable_if<std::is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\n\ntemplate<typename T, typename V>\ntypename std::enable_if<std::is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for (auto &e:t) fill_v(e, v); }\n\ntemplate<class T>\ninline T ceil(T a, T b) { return (a + b - 1) / b; }\n\nvoid print() { std::cout << std::endl; }\n\ntemplate<class Head, class... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n    std::cout << head;\n    if (sizeof...(tail) != 0) { std::cout << \" \"; }\n    print(std::forward<Tail>(tail)...);\n}\n\ntemplate<class T>\nvoid print(std::vector<T> &v) {\n    for (auto &a : v) {\n        std::cout << a;\n        if (&a != &v.back()) { std::cout << \" \"; }\n    }\n    std::cout << std::endl;\n}\n\ntemplate<class T>\nvoid print(std::vector<std::vector<T>> &vv) { for (auto &v : vv) { print(v); }}\n\nvoid debug() { std::cerr << std::endl; }\n\ntemplate<class Head, class... Tail>\nvoid debug(Head &&head, Tail &&... tail) {\n    std::cerr << head;\n    if (sizeof...(tail) != 0) { std::cerr << \" \"; }\n    print(std::forward<Tail>(tail)...);\n}\n\ntemplate<class T>\nvoid debug(std::vector<T> &v) {\n    for (auto &a : v) {\n        std::cerr << a;\n        if (&a != &v.back()) { std::cerr << \" \"; }\n    }\n    std::cerr << std::endl;\n}\n\ntemplate<class T>\nvoid debug(std::vector<std::vector<T>> &vv) { for (auto &v : vv) { print(v); }}\n\ninline bool inside(long long y, long long x, long long H, long long W) { return 0 <= y and y < H and 0 <= x and x < W; }\n\ntemplate<class T>\ninline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\ntemplate<class T>\ninline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\ntemplate<typename T>\nT &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate<typename T>\nT &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T>\ninline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int) v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = {0, -1, 0, 1, 1, -1, -1, 1}, dx8 = {1, 0, -1, 0, 1, 1, -1, -1};\n\n\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n\n\nclass TopologicalSort {\n    const int N;                           // ノード数\n    std::vector<std::vector<int>> graph;   // グラフ\n    std::vector<bool> used;                // 使用済みノード\n    std::vector<int> indeg;                // 入次数\n\npublic:\n    std::vector<int> result; // ソート結果\n\npublic:\n    TopologicalSort(unsigned int num_node) : N(num_node) {\n        this->graph.resize(num_node);\n        this->indeg.resize(num_node, 0);\n        this->used.resize(num_node, false);\n    }\n\n    // u -> vのedgeを追加\n    void add_directed_edge(int u, int v) {\n        assert(u != v);\n        if (u == v) {\n            return;\n        }\n        this->graph[u].emplace_back(v);\n    }\n\n    // O(V + E)\n    bool sort() {\n        // すべてのノードの入次数を算出\n        for (int u = 0; u < this->N; ++u) {\n            for (int v : this->graph[u]) {\n                this->indeg[v]++;\n            }\n        }\n\n        for (int u = 0; u < this->N; ++u) {\n            if (this->indeg[u] == 0 and not this->used[u]) {\n                bfs(u);\n            }\n        }\n\n        return (int)this->result.size() == this->N;\n    }\n\n    // グラフの有向パスのうち最長のものの長さ\n    // ソート結果が一意なら返り値はN - 1になり，元のグラフはハミルトン路を含むグラフである\n    int longest_distance() {\n        int ans = 0;\n        std::vector<int> distance(this->N, 0);\n        for (int u : this->result) {\n            for (int v : this->graph[u]) {\n                distance[v] = std::max(distance[v], distance[u] + 1);\n                ans = std::max(ans, distance[v]);\n            }\n        }\n\n        return ans;\n    }\n\nprivate:\n    void bfs(const int s) {\n        std::queue<int> que;\n        que.push(s);\n        this->used[s] = true;\n        while (not que.empty()) {\n            const int u = que.front();\n            que.pop();\n            this->result.emplace_back(u);\n\n            for (int v : this->graph[u]) {\n                this->indeg[v]--;\n                if (this->indeg[v] == 0 and not this->used[v]) {\n                    this->used[v] = true;\n                    que.push(v);\n                }\n            }\n        }\n    }\n};\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n\n    TopologicalSort ts(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        ts.add_directed_edge(s, t);\n    }\n    ts.sort();\n\n    for (int i = 0; i < V; ++i) {\n        cout << ts.result[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// topological sort (breadth first search)\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <utility>\n\nconst int N = 10010;\nconst int M = 100010;\n\nstruct Edge {\n\tint to, next;\n} es[M];\n\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint vis[N], queue[N]; // for calculating shortest path\nint ans[N], end = 0;\n\ninline void add(int u, int v) {\n\tint i = ++SIZE;\n\tes[i].to = v;\n\tes[i].next = h[u];\n\th[u] = i; \n}\n\nvoid bfs(int s) {\n\tint front = 0, back = 0;\n\tqueue[back++] = s;\n\tvis[s] = 1;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tfor (int i = h[x]; i != 0; i = es[i].next) {\n\t\t\tint y = es[i].to;\n\t\t\tif (!vis[y]) {\n\t\t\t\tqueue[back++] = y;\n\t\t\t\tvis[y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tend -= back;\n\tfor (int i = 0; i < back; i++)\n\t\tans[end + i] = queue[i];\n}\n\nvoid run() {\n\tint n, m, x, y;\n\tscanf(\"%d%d\", &n, &m);\n\tmemset(h, 0, sizeof(h));\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t}\n\tend = n;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++)\n\t\tif (!vis[i]) bfs(i);\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d\\n\", ans[i]);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing D = double;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_num(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define RALL(qpqpq)           (qpqpq).rbegin(),(qpqpq).rend()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define RFOR(i,tptpt,ypypy)  for(LL i=(tptpt);i>=(ypypy);i--)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\n//https://www.slideshare.net/hcpc_hokudai/topological-sort-69581002\n//コード例は24ページ\n\n\nvector<int> tsort_kahn(const vector<vector<int>>& g) {\n\tconst int V = g.size();\n\tvector<int> indeg(V, 0);\n\tstack<int> S;\n\n\tfor (auto& u_out_edges : g) {\n\t\tfor (auto& v : u_out_edges) {\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (indeg[i] == 0) {\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tvector <int>ans;\n\twhile (S.size() > 0) {\n\t\tint u = S.top(); S.pop();\n\t\tans.emplace_back(u);\n\t\tfor (auto& v : g[u]) {\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0)S.push(v);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint v, e;\n\tcin >> v >> e;\n\tvector<vector<int>>vv(v);\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tvv[s].emplace_back(t);\n\t}\n\tvector<int> ans = tsort_kahn(vv);\n\tREP(i, v) {\n\t\tcout << ans[i] << endl;\n\t}\n\t//system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v] ) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for ( int i = 0; i < N; i++ )\n    indeg[i] = 0;\n\n  for ( int u = 0; u < N; u++ )\n    for ( int i = 0; i < N; i++ ) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n\n  for ( int u = 0; u < N; u++ )\n    if ( indeg[u] == 0 && !V[u] ) bfs(u);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define rep(i,n) FOR(i,0,n)\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define vint vector<int>\n#define vdouble vector<double>\n#define vstring vector<string>\nusing namespace std;\n\n#include<map>\n#include<set>\n#include<queue>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int MAX_N = 1000000;\n\n\nclass Edge{\npublic:\n\tint from, to, cost;\n\tEdge(int from = 0, int to = 0, int cost = 0) :\n\t\tfrom(from), to(to), cost(cost){}\n\n\tbool operator < (const Edge &e) const{\n\t\treturn cost < e.cost;\n\t}\n\tbool operator >(const Edge &e) const{\n\t\treturn cost > e.cost;\n\t}\n\n};\n\nstatic const int INFTY = (1 << 21);\n\nclass Node{\npublic:\n\tvector<Edge> edges;\n\tint count;\n\tNode(){\n\t\tcount = 0;\n\t}\n};\n\nclass Graph{\npublic:\n\tvector<Node> nodes;\n\tGraph(int n) {\n\t\trep(i, n) { Node n;  nodes.push_back(n); }\n\t}\n};\n\n\nint main() {\n\n\tint V, E;\n\tcin >> V >> E;\n\n\tGraph G(V);\n\trep(i, E){\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\tEdge e(from, to, 0);\n\t\tG.nodes[from].edges.push_back(e);\n\t\tG.nodes[to].count += 1;\n\t}\n\n\tqueue<int> Q;\n\trep(i, V){\n\t\tif (G.nodes[i].count == 0){ \n\t\t\tQ.push(i); \n\t\t\tcout << i << endl;\n\t\t}\n\t}\n\n\twhile (!Q.empty()){\n\t\tint i = Q.front(); Q.pop();\n\t\tfor (auto e : G.nodes[i].edges){\n\t\t\tG.nodes[e.to].count -= 1;\n\t\t\tif (G.nodes[e.to].count == 0){\n\t\t\t\tQ.push(e.to);\n\t\t\t\tcout << e.to << endl;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <list>\nusing namespace std;\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAXV = 10005;\nconst int MAXE = 100005;\n\nstruct Edge {\n\tint to, next;\n\tEdge() { next = -1; }\n} edge[MAXE];\n\nlist<int> ans;\nint head[MAXE];\nint indegree[MAXV];\nbool vis[MAXV];\nint cnt;\n\nvoid bfs(int u)\n{\n\tqueue<int> q;\n\tvis[u] = true;\n\tq.push(u);\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tans.push_back(u);\n\t\tfor (int i = head[u]; i != NIL; i = edge[i].next)\n\t\t{\n\t\t\tu = edge[i].to;\n\t\t\tif (!vis[u] && --indegree[u] == 0)\n\t\t\t{\n\t\t\t\tvis[u] = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nvoid topologicalSort(int n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tvis[i] = false;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (indegree[i] == 0 && !vis[i])\n\t\t\tbfs(i);\n\t}\n}\n\nvoid add(int u, int v)\n{\n\tedge[cnt].to = v;\n\tedge[cnt].next = head[u];\n\thead[u] = cnt++;\n}\n\n\nint main(void)\n{\n\t\n\tint V, E, s, t;\n\tscanf(\"%d%d\", &V, &E);\n\tcnt = 0;\n\tmemset(head, NIL, sizeof(int) * (E + 1));\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d%d\", &s, &t);\n\t\t++indegree[t];\n\t\tadd(s, t);\n\t}\n\ttopologicalSort(V);\n\tfor (list<int>::iterator it = ans.begin(); it != ans.end(); ++it)\n\t\tprintf(\"%d\\n\", *it);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct topological_sort{\n    vector<vector<int>> graph;\n    vector<bool> done,open;\n    vector<int> res;\n    bool success;\n    topological_sort(vector<vector<int>> &graph):graph(graph),done(graph.size()),open(graph.size()),success(true){\n        int size=graph.size();\n        vector<int> in(size);\n        for(int i=0; i<size; ++i) for(int j:graph[i]) ++in[j];\n        priority_queue<int,vector<int>,greater<int>> que;\n        for(int i=0; i<size; ++i) if(!in[i]) que.push(i);\n        while(!que.empty()){\n            int x=que.top();\n            que.pop();\n            res.push_back(x);\n            for(int y:graph[x]){\n                --in[y];\n                if(!in[y]) que.push(y);\n            }\n        }\n        if(res.size()!=size) success=false;\n    }\n};\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<int>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n    topological_sort ts(graph);\n    rep(i,0,v) cout << ts.res[i] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\n\nvector<int> tsort(Graph G, int start, int end) {\n  vector<int> ret;\n\n  int degree[end];\n  memset(degree, 0, sizeof(degree));\n\n  for (int from = start; from < end; from++) {\n    for (int i = 0; i < G[from].size(); i++) {\n      int to = G[from][i];\n      degree[to]++;\n    }\n  }\n\n  stack<int> root;\n\n  for (int i = start; i < end; i++) {\n    if (degree[i] == 0) {\n      root.push(i);\n    }\n  }\n\n  while (!root.empty()) {\n    int from = root.top();\n    root.pop();\n\n    ret.push_back(from);\n\n    for (int i = 0; i < G[from].size(); i++) {\n      int to = G[from][i];\n      degree[to]--;\n\n      if (degree[to] == 0) {\n        root.push(to);\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n\n  Graph G(V);\n\n  int s, t;\n\n  for (int i = 0; i < E; ++i) {\n    cin >> s >> t;\n\n    G[s].push_back(t);\n  }\n\n  vector<int> res = tsort(G, 0, V);\n\n  for (int i = 0; i < res.size(); ++i) {\n    cout << res[i] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <random>\n#include <chrono>\n#include <queue>\n#include <ctime>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n#define fs first\n#define sc second\n#define INF 1000000000\n#define MOD 1000000007\n#define EPS 0.00000001\n\n\n\nint main() {\n    int V, E; cin >> V >> E;\n    vector<vector<int>> to(V);\n    vector<int> Nyuji(V);\n    for(int i=0; i<E; i++){\n        int s, t; cin >> s >> t;\n        to[s].push_back(t);\n        Nyuji[t]++;\n    }\n    \n    vector<PII> S;\n    for(int i=0; i<V; i++){\n        if(Nyuji[i]==0) S.push_back({i, 1});\n    }\n    \n    vector<int> ans;\n    int done = 0;\n    while(S.size()){\n        PII p = S.back();\n        done++;\n        ans.push_back(p.fs);\n        S.pop_back();\n        for(int t:to[p.fs]){\n            Nyuji[t]--;\n            if(Nyuji[t]==0){\n                S.push_back({t, p.sc+1});\n            }\n        }\n    }\n    \n    if(done!=V){\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    for(int a:ans) cout << a << endl;\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <list>\n#include <queue>\n\nusing namespace std;\n#define MAX 1000000\n#define INF (INT_MAX/2)\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n  queue<int> que;\n  que.push(s);\n  V[s] = true;\n  while(!que.empty()){\n    int u = que.front(); que.pop();\n    out.push_back(u);\n    for(int i = 0; i < G[u].size(); i++){\n      int v = G[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n        V[v] = true;\n        que.push(v);\n      }\n    }\n  }\n}\n\nvoid topological_sort(){\n  for(int i = 0; i < N; i++){\n    indeg[i] = 0;\n  }\n\n  for(int u = 0; u < N; u++){\n    for(int i = 0; i < G[u].size(); i++) indeg[G[u][i]]++;\n  }\n\n  for(int u = 0; u < N; u++) if(indeg[u] == 0 && !V[u]) bfs(u);\n\n  for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n    cout << *it << endl;\n  }\n}\n\nint main(void){\n  ios_base::sync_with_stdio(0);\n  int s, t, M;\n  cin >> N >> M;\n\n  for(int i = 0; i < N; i++) V[i] = false;\n\n  for(int i = 0; i < M; i++){\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  topological_sort();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nvector<int> tsort(int v, vector<int> g[], bool zero_index = false) {\n  vector<int> ret;\n\n  int start = zero_index ? 0 : 1;\n  int end = zero_index ? v : v + 1;\n  int degree[end];\n  memset(degree, 0, sizeof(degree));\n\n  for (int from = start; from < end; from++) {\n    for (int i = 0; i < g[from].size(); i++) {\n      int to = g[from][i];\n      degree[to]++;\n    }\n  }\n\n  stack<int> root;\n\n  for (int i = start; i < end; i++) {\n    if (degree[i] == 0) {\n      root.push(i);\n    }\n  }\n\n  while (!root.empty()) {\n    int from = root.top();\n    root.pop();\n\n    ret.push_back(from);\n\n    for (int i = 0; i < g[from].size(); i++) {\n      int to = g[from][i];\n      degree[to]--;\n\n      if (degree[to] == 0) {\n        root.push(to);\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int v, e;\n  int s, t;\n  cin >> v >> e;\n\n  vector<int> g[v];\n\n  for (int i = 0; i < e; i++) {\n    cin >> s >> t;\n\n    g[s].push_back(t);\n  }\n\n  vector<int> ans = tsort(v, g, true);\n\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(i,n) for(auto &i:n)\n\nint n, m, a, b;\nvi e[10000];\n\nvi tsort(int v, vi *e) {\n\tstack<int> st;\n\tint ny[v] = {0};\n\trep(i,v) each(j,e[i]) ny[j]++;\n\trep(i,v) {\n\t\tif (ny[i]) continue;\n\t\tst.push(i);\n\t}\n\tvi res;\n\twhile (!st.empty()) {\n\t\tint ne = st.top(); st.pop();\n\t\tres.push_back(ne);\n\t\teach(j,e[ne]) if (--ny[j]==0) st.push(j);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m;\n\trep(i,m) {\n\t\tcin >> a >> b;\n\t\te[a].push_back(b);\n\t}\n\tvi r = tsort(n,e);\n\trep(i,n) cout << r[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\nclass TopologicalSort {\n    const unsigned int N;               // ノード数\n    const vector<vector<int>> graph;    // グラフ\n    vector<bool> used;                  // 使用済みノード\n    vector<int> indeg;                  // 入次数\n\npublic:\n    vector<int> result;\n\npublic:\n    TopologicalSort(unsigned int num_node, const vector<vector<int>> &graph) : N(num_node), graph(graph){\n        this->indeg.assign(num_node, 0);\n        this->used.assign(num_node, false);\n    }\n\n    bool sort() {\n        for (int u = 0; u < N; ++u) {\n            for (int v : graph[u]) {\n                indeg[v]++;\n            }\n        }\n\n        for (int u = 0; u < N; ++u) {\n            if (indeg[u] == 0 and not used[u]) {\n                bfs(u);\n            }\n        }\n\n        return this->result.size() == N;\n    }\n\nprivate:\n    void bfs(int s) {\n        queue<int> que;\n        que.push(s);\n        used[s] = true;\n        while (not que.empty()) {\n            int u = que.front();\n            que.pop();\n            result.emplace_back(u);\n\n            for (int v : graph[u]) {\n                indeg[v]--;\n                if (indeg[v] == 0 and not used[v]) {\n                    used[v] = true;\n                    que.push(v);\n                }\n            }\n        }\n    }\n};\n\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> graph(V);\n    FOR(_, 0, E) {\n        int s, t;\n        cin >> s >> t;\n        graph[s].emplace_back(t);\n    }\n\n    TopologicalSort ts(V, graph);\n    ts.sort();\n    FOE(v, ts.result) {\n        print(v);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ITNOA\n#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pb push_back\nconst long long INF=1e9+10,MAX=2e5+1e4,MOD=1e9+7,MAXL=25;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef pair<pii,ll> piii;\nvoid OUT(long double o,int x){\n\t cout<<fixed<<setprecision(x)<<o;\n\t return;\n}\nll a[MAX],d[MAX];\nvector<int> v[MAX],k[MAX];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n,m,t=0,p=0;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tk[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i].size()==0)\n\t\t\ta[t++]=i;\n\t\td[i]=v[i].size();\n\t}\n\twhile(p<t){\n\t\tfor(int i:k[a[p]]){\n\t\t\td[i]--;\n\t\t\tif(d[i]==0)\n\t\t\t\ta[t++]=i;\n\t\t}\n\t\tp++;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcout<<a[i]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n\nint main() {\n    using VertexId = std::uint32_t;\n    using EdgeId = std::uint64_t;\n\n    auto n = VertexId(0);\n    auto m = EdgeId(0);\n    std::cin >> n >> m;\n\n    auto adjacency_list = std::vector<std::vector<VertexId>>(n, std::vector<VertexId>());\n\n    auto in_edge_num = std::vector<VertexId>(n, VertexId(0));\n\n    for (auto i_ = 0; i_ < m; ++i_) {\n        auto source = VertexId(0);\n        auto target = VertexId(0);\n        std::cin >> source >> target;\n\n        adjacency_list[source].emplace_back(target);\n        in_edge_num[target]++;\n    }\n\n    auto sorted_vertex = std::vector<VertexId>();\n    const auto invalid_vertex = std::numeric_limits<VertexId>::max();\n\n    auto q = std::queue<VertexId>();\n    for (auto i = 0; i < n; ++i) {\n        if (in_edge_num[i] == 0) q.emplace(i);\n    }\n\n    while (!q.empty()) {\n        const auto v = q.front();\n        q.pop();\n\n        in_edge_num[v] = invalid_vertex;\n\n        sorted_vertex.emplace_back(v);\n\n        for (const auto& target_from_v : adjacency_list[v]) {\n            if (in_edge_num[target_from_v] != invalid_vertex) {\n                in_edge_num[target_from_v]--;\n\n                if (in_edge_num[target_from_v] == 0) q.emplace(target_from_v);\n            }\n        }\n    }\n\n    for (const auto& v : sorted_vertex) {\n        std::cout << v << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Edge {\n  int from, to;\n  Edge(int from, int to) : from(from), to(to) {}\n};\n\nvector<vector<Edge>> ReadDirectedGraph(\n    int n, int m, bool is_one_indexed=false) {\n  vector<vector<Edge>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int v1, v2;\n    cin >> v1 >> v2;\n    if (is_one_indexed) {\n      v1--;\n      v2--;\n    }\n    graph[v1].push_back(Edge({v1, v2}));\n  }\n  return graph;\n}\n\nvector<int> TopologicalSort(const vector<vector<Edge>>& graph) {\n  int n = graph.size();\n  vector<int> in(n);\n  for (int v = 0; v < n; v++) {\n    for (const auto& edge : graph[v]) {\n      in[edge.to]++;\n    }\n  }\n\n  deque<int> queue;\n  for (int v = 0; v < n; v++) {\n    if (in[v] == 0) queue.push_back(v);\n  }\n\n  vector<int> vs;\n  while (!queue.empty()) {\n    int v = queue.front();\n    queue.pop_front();\n    vs.push_back(v);\n    for (const auto& edge : graph[v]) {\n      in[edge.to]--;\n      if (in[edge.to] == 0) queue.push_back(edge.to);\n    }\n  }\n\n  if (vs.size() < n) return vector<int>();\n  return vs;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n  auto graph = ReadDirectedGraph(n, m);\n  auto vs = TopologicalSort(graph);\n  for (int v : vs) {\n    cout << v << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nvector<int>E[10000];\nint in[10000];\nbool used[10000];\nint main() {\n\tint v, e; scanf(\"%d%d\", &v, &e);\n\trep(i, e) {\n\t\tint s, t; scanf(\"%d%d\", &s, &t);\n\t\tE[s].push_back(t);\n\t\tin[t]++;\n\t}\n\tlist<int>ls;\n\tqueue<int>que;\n\trep(i, v) {\n\t\tif (!used[i] && !in[i])que.push(i);\n\t\twhile (!que.empty()) {\n\t\t\tint p = que.front(); que.pop();\n\t\t\tused[p] = true; ls.push_back(p);\n\t\t\tfor (int u : E[p]) {\n\t\t\t\tin[u]--;\n\t\t\t\tif (!used[u] && !in[u])que.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i : ls) {\n\t\tprintf(\"%d\\n\", i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef long long ll;\nvector<vector<int> >  g,gv;\nvector<int>t;\nvector<bool>flag;\nvector<int>cmp;\nint cnt = 0;\nint p = 0;\nvoid dfs(int i){\n    if(flag[i])return;\n    flag[i] = true;\n    for(auto x:g[i]){\n        dfs(x);\n    }\n    t[i] = cnt;\n    cnt++;\n}\nvoid redfs(int i){\n    if(flag[i])return;\n    flag[i] = true;\n    for(auto x:gv[i]){\n        redfs(x);\n    }\n    cmp[i] = p;\n}\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    g.resize(n);\n    gv.resize(n);\n    t.resize(n);\n    flag.resize(n);\n    cmp.resize(n);\n    for(int i=0;i<m;i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].push_back(t);\n        gv[t].push_back(s);\n    }\n    for(int i=0;i<n;i++){\n        dfs(i);\n    }\n    vector<pair<int,int> >v;\n    for(int i=0;i<n;i++){\n        v.push_back(make_pair(t[i],i));\n        flag[i] = 0;\n    }\n    sort(v.rbegin(),v.rend());\n    for(int i=0;i<n;i++){\n        cout << v[i].second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\n#define MK make_pair\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nclass Topological_Sort{\nprivate:\n    ll v;\n    vector<vector<ll>> E;\n    vector<ll> count;\n    \npublic:\n    Topological_Sort(ll v):v(v){\n        E.resize(v);\n        count.resize(v,0);\n    }\n    \n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n        count[to]++;\n    }\n    \n    vector<ll> sort(){\n        vector<ll> c=count;\n        vector<ll> ret;\n        for(int i=0;i<v;i++){\n            if(c[i]==0){ret.push_back(i);}\n        }\n        for(int i=0;i<ret.size();i++){\n            for(int t=0;t<E[ret[i]].size();t++){\n                ll to=E[ret[i]][t];\n                c[to]--;\n                if(c[to]==0){ret.push_back(to);}\n            }\n        }\n        return ret;\n    }\n};\n\n\n\nint main(){\n    ll v,e;\n    cin>>v>>e;\n    Topological_Sort T(v);\n    for(int i=0;i<e;i++){\n        ll s,t;\n        cin>>s>>t;\n        T.add_edge(s,t);\n    }\n    vector<ll> a=T.sort();\n    assert(a.size()==v);\n    for(int i=0;i<a.size();i++){\n        cout<<a[i]<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvector<vector<int>>G;\nlist<int>out;\nvector<bool>V;\nint N;\n\nvoid dfs(int u) {\n\tV[u] = true;\n\trep(i, 0, G[u].size()) {\n\t\tint v = G[u][i];\n\t\tif (!V[v])dfs(v);\n\t}\n\tout.push_back(u);\n}\n\nsigned main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\tV = vector<bool>(N, false); G = vector<vector<int>>(N, vector<int>());\n\trep(i, 0, M) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\trep(i, 0, N) {\n\t\tif (!V[i])dfs(i);\n\t}\n\teach(it, out)cout << *it << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, e, t1, t2;\nvector <int> v[100005];\nbool vis[100005];\ndeque <int> order;\n\nvoid dfs(int node) {\n\tvis[node] = 1;\n\tfor (int i : v[node]) {\n\t\tif (!vis[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\torder.push_front(node);\n}\n\nint main() {\n\tcin >> n >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tcin >> t1 >> t2;\n\t\tv[t1].push_back(t2);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!vis[i]) dfs(i);\n\t}\n\twhile (!order.empty()) {\n\t\tt1 = order.front();\n\t\tcout << t1 << endl;\n\t\torder.pop_front();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TopologicalSort {\n   vector<int> used, indeg, res;\n   vector<set<int>> G;\n\n   TopologicalSort() {}\n   TopologicalSort(int n):G(n), used(n, 0), indeg(n, 0) {}\n\n   void add_edge(int s, int t) {\n      G[s].emplace(t);\n      indeg[t]++;\n   }\n\n   void bfs(int s) {\n      queue<int> que;\n      que.emplace(s);\n      used[s] = 1;\n      while(!que.empty()) {\n         int v = que.front(); que.pop();\n         res.emplace_back(v);\n         for(int u:G[v]) {\n            indeg[u]--;\n            if(indeg[u] == 0 && !used[u]) {\n               used[u] = 1;\n               que.emplace(u);\n            }\n         }\n      }\n   }\n\n   vector<int> build() {\n      int n = G.size();\n      for(int i=0; i<n; ++i) if(indeg[i] == 0 && !used[i]) bfs(i);\n\n      return res;\n   }\n};\n\nint main() {\n   int V, E; cin >> V >> E;\n   TopologicalSort tp(V);\n   for(int i=0; i<E; ++i) {\n      int u, v; cin >> u >> v;\n      tp.add_edge(u, v);\n   }\n   auto res = tp.build();\n   for(int i=0; i<V; ++i) cout << res[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst long MAX=100000;\n\nvector<int> G[MAX];\nlist<int> ou;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n\tqueue<int> que;\n\tque.push(s);\n\tV[s]=true; //?¨???????\n\t\n\twhile( !que.empty() ){\n\t\tint u=que.front();\n\t\tque.pop();\n\t\tou.push_back(u); //????????¨????????????????????????\n\t\t\n\t\tfor(int i=0; i<G[u].size(); ++i){\n\t\t\tint v=G[u][i]; //u?????????????????????????????????????????????\n\t\t\tindeg[v]--; //????¬???°???????????????\n\t\t\t\n\t\t\tif(indeg[v]==0 && !V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tque.push(v);\t\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n//topological sort\nvoid tsort(){\n\tfor(int i=0; i<N; ++i) indeg[i]=0;\n\t\n\tfor(int i=0; i<N; ++i){\n\t\tfor(int j=0; j<G[i].size(); ++j){\n\t\t\tint k=G[i][j];\n\t\t\tindeg[k]++;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<N; ++i){\n\t\tif(indeg[i]==0 && !V[i]) bfs(i);\t\n\t}\n\t\n\tfor(list<int>::iterator it=ou.begin(); it!=ou.end(); ++it){\n\t\tcout << *it << endl;\t\n\t}\n}\n\nint main(){\n\tlong M;\n\tscanf(\" %d %ld\", &N, &M);\n\t\n\tfor(int i=0; i<N; ++i) V[i]=false;\n\t\n\tfor(long i=0; i<M; ++i){\n\t\tint s, t;\n\t\tscanf(\" %d %d\", &s, &t);\n\t\tG[s].push_back(t); //??????????????????\t\t\n\t}\t\n\t\n\ttsort();\n}"
  },
  {
    "language": "C++",
    "code": "// https://www.youtube.com/watch?v=UWbGRhF3Ozw\n// https://atcoder.jp/contests/abc139/submissions/7330266\n// https://qiita.com/drken/items/23a4f604fa3f505dd5ad#4-3-dag-%E3%81%AE%E3%83%88%E3%83%9D%E3%83%AD%E3%82%B8%E3%82%AB%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nclass DAG {\n  private:\n    ll v, e;\n    vector<vector<ll>> table;\n    vector<ll> in_d; // 頂点の入力次数\n    vector<ll> head;\n\n  public:\n    // v: 頂点数\n    // e: 辺の数\n    DAG(ll v) : v(v) {\n        table.resize(v);\n        in_d.resize(v);\n        e = 0;\n    }\n\n    void add(ll from, ll to) {\n        table[from].emplace_back(to);\n        in_d[to]++;\n        e++;\n    }\n\n    // O(v + e)\n    vl sort() {\n        stack<ll> st; // 入力次数が0の頂点集合\n        for(int i = 0; i < v; i++) {\n            if(in_d[i] == 0) {\n                st.push(i);           // stack\n                head.emplace_back(i); // head\n            }\n        }\n        vl ans; // ソート後のグラフ\n\n        while(!st.empty()) {\n            ll in = st.top();\n            st.pop();\n            ans.emplace_back(in);\n            for(auto &j : table[in]) {\n                in_d[j]--;\n                if(in_d[j] == 0)\n                    st.push(j);\n            }\n        }\n\n        return move(ans);\n    }\n\n    ll get_longest_path(void) {\n        vector<bool> seen(v), calc(v);\n        vector<ll> d(v, 0);\n        auto dfs = [&](auto &&f, ll now) -> ll {\n            if(seen[now]) {\n                if(!calc[now])\n                    return -1;\n                return d[now];\n            }\n            seen[now] = true;\n            d[now] = 1;\n            for(auto &t : table[now]) {\n                ll res = f(f, t);\n                if(res == -1)\n                    return -1;\n                d[now] = max(res + 1, d[now]);\n            }\n            calc[now] = true;\n            return d[now];\n        };\n\n        ll ans = 0;\n        for(int i = 0; i < v; i++) {\n            ll tmp = dfs(dfs, i);\n            if(tmp == -1) {\n                return -1;\n            }\n            ans = max(tmp, ans);\n        }\n        return ans;\n    }\n};\n\nint main(void) {\n    int V, E;\n    cin >> V >> E;\n    vector<int> s(E);\n    vector<int> t(E);\n    auto dag = DAG(V);\n    for(int i = 0; i < E; i++) {\n        cin >> s[i] >> t[i];\n        dag.add(s[i], t[i]);\n    }\n    auto ans = dag.sort();\n    for(int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n    for(int i=0; i<N; i++){\n        for(int j=0; j<G[i].size(); j++){\n            int v = G[i][j];\n            indeg[v]++;\n        }\n    }\n    for(int u=0; u<N; u++){\n        if(indeg[u]==0 && !V[u]) bfs(u);\n    }\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 10005;\nint V, E, s, t;\nint indeg[MAX];\nvector<int> G[MAX];\nqueue<int> S;//用于记录入度为0且未访问过的结点\n\nvoid bfs(int u)\n{\n    for(int i=0; i<G[u].size(); i++)\n    {\n        if(!indeg[G[u][i]]) continue;\n        indeg[G[u][i]]--;\n        if(!indeg[G[u][i]])\n        {\n            S.push(G[u][i]);\n        }\n    }\n}\n\nvoid topologicalSort()\n{\n    int u;\n    while(!S.empty())\n    {\n        u = S.front(); S.pop();\n        printf(\"%d\\n\", u);\n        bfs(u);//将u的邻接点的入度减一，若为0则入栈\n    }\n}\n\nint main()\n{\n    memset(indeg, 0, sizeof(indeg));\n    scanf(\"%d %d\", &V, &E);\n    for(int i=0; i<E; i++)\n    {\n        scanf(\"%d %d\", &s, &t);\n        indeg[t]++;\n        G[s].push_back(t);\n    }\n    for(int i=0; i<V; i++)\n    {\n        if(!indeg[i])\n            S.push(i);\n    }\n    topologicalSort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<queue>\n#include<stdio.h>\nusing namespace std;\nstruct Node {\n\t//int id;\n\tint indegree;\n\tlist<int> next;\n};\nNode graph[10002];\nint visit[10002];\nint n, m;\nqueue<int> answer;\nvoid bfs(int beginNodeId) {\n\tqueue<int> Q;\n\tQ.push(beginNodeId);\n\twhile (!Q.empty()) {\n\t\tint id = Q.front(); Q.pop();\n\t\tvisit[id] = 1;\n\t\tanswer.push(id);\n\n\t\tlist<int>::iterator it = graph[id].next.begin();\n\t\tfor (it; it != graph[id].next.end(); it++) {\n\t\t\tint nextid = *it;\n\t\t\tgraph[nextid].indegree--;\n\t\t\tif (graph[nextid].indegree == 0 && visit[nextid] == 0) {\n\t\t\t\tQ.push(nextid);\n\t\t\t}\n\t\t}\n\t}\n\n}\nvoid topologicalSort() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (graph[i].indegree == 0 && visit[i]==0) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tint a, b;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tgraph[a].next.push_back(b);\n\t\tgraph[b].indegree++;\n\t}\n\ttopologicalSort();\n\twhile (!answer.empty()) {\n\t\tint ans = answer.front(); answer.pop();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_V = 10000;\nconst int MAX_E = 100000;\nvector<deque<int> > G(MAX_E);\nvector<int> L;  // トポロジカルソートした結果を蓄積する空リスト.\ndeque<int> S;   // 入力辺を持たないすべてのノードの集合.\nmap<int, int> inCount;\n\n// 各頂点から, トポロジカルソート を行い, 頂点の並び順を保存.\n// https://ja.wikipedia.org/wiki/トポロジカルソート\n// @param : 特に無し.\n// @return : 特に無し.\nvoid topologicalSort(){\n    \n    // 1. キュー S が 空になるまで, ループ.\n    while(!S.empty()){\n\n        // 2. S からノード n を削除.\n        int n = S.front();\n        S.pop_front();\n        \n        // 3. L に n を追加.\n        L.push_back(n);\n\n        while(!G[n].empty()){\n            // 4. 辺 e (n -> m)をグラフから削除.\n            int m = G[n].front();\n            G[n].pop_front();\n            inCount[m]--;\n            // printf(\"n=%d m=%d\\n\", n, m);\n            // 5. m がその他の入力辺を持っていなければ, m を S に追加.\n            if(inCount[m] == 0) S.push_back(m);\n        }\n    }\n    \n    // 6. グラフに辺が残っている場合は, 閉路があり DAG でないので中断.\n    // 本問では, 考慮しなくて良さそう.\n    \n    return;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    for(int i = 0; i < E; i++){\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n        inCount[t]++; // 各頂点への入力辺の本数を保存.\n    }\n    \n    // 2. 辺の数が, 0本の場合, 頂点を S に追加.\n    // テストケース: in10.txt対応用.\n    // if(E == 0) for(int i = 0; i < V; i++) S.push_back(i);\n    // -> 入力情報に, 必ずしも, 頂点情報が与えらるとは, 限らないので注意.\n    // -> ex. テストケース: in15.txt で, 頂点 13 が 出力されなかった.\n    // -> 以下のロジックへ修正.\n    for(int i = 0; i < V; i++) if(inCount[i] == 0) S.push_back(i);\n    \n    // 3. トポロジカルソートを行う.\n    topologicalSort();\n    \n    // 4. 出力 ～ 後処理.\n    for(int i = 0; i < L.size(); i++) printf(\"%d\\n\", L[i]);\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n\tint num,E,from,to,table[10000],tmp;\n\tvector<int> V[10000];\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < 10000; i++)table[i] = 0;\n\n\tscanf(\"%d %d\",&num,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\ttable[to]++;\n\t}\n\n\tfor(int i = 0; i < num; i++){\n\t\tif(table[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\t\tprintf(\"%d\\n\",tmp);\n\t\tfor(int i = 0; i < V[tmp].size(); i++){\n\t\t\ttable[V[tmp][i]]--;\n\t\t\tif(table[V[tmp][i]] == 0){\n\t\t\t\tQ.push(V[tmp][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                glaph[j].flag = 1;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            glaph[i].flag = 1;\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing Graph = vector<vector<int>>;\n\nvoid dfs(int v, const Graph &G, vector<int> &res, vector<int> &used)\n{\n    used[v] = 1;\n    for (auto to : G[v])\n        if (used[to] == 0)\n        {\n            dfs(to, G, res, used);\n        }\n    res.push_back(v);\n}\n\nvector<int> topo_sort(const Graph &G)\n{\n    int V = G.size();\n    vector<int> ide(V);\n    for (int i = 0; i < V; i++)\n    {\n        for (auto to : G[i])\n        {\n            ide[to]++;\n        }\n    }\n    vector<int> res;\n    vector<int> used(V);\n    for (int i = V - 1; i >= 0; i--)\n    {\n        if (ide[i] == 0)\n        {\n            dfs(i, G, res, used);\n        }\n    }\n    if (res.size() == 0)\n        res = {-1};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    while (E--)\n    {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n    auto ret = topo_sort(g);\n    for (int i = 0; i < V; i++)\n        cout << ret[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(40) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,n,a) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\n\n\nconst static int MAX_V = 10000;\nvector<int> G[MAX_V];\nint topologicalV[MAX_V];\nint used[MAX_V];\nint remain;\n\nvoid dfs(int v) {\n\tif (used[v])return;\n\tif (G[v].size() == 0) {\n\t\ttopologicalV[remain] = v;\n\t\tremain--;\n\t\tused[v] = true;\n\t\treturn;\n\t}\n\trep(i, G[v].size()) {\n\t\tif (!used[G[v][i]]) {\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n\ttopologicalV[remain] = v;\n\tused[v] = true;\n\tremain--;\n}\n\n//AOJ GRL_5\nint main() {\n\tint v,e; put v >> e;\n\trep(i, e) {\n\t\tint from; put from;\n\t\tint to; put to;\n\t\tG[from].push_back(to);\n\t}\n\tremain = v-1;\n\trep(i, v) {\n\t\tdfs(i);\t\t\n\t}\n\trep(i, v) {\n\t\tcout <<\ttopologicalV[i] << endl;\n\t}\n\nEND:\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=10005;\n\nint n,m;\nbool vis[maxn];\nvector<int>G[maxn];\nvector<int>ans;\n\nvoid dfs(int u) {\n    vis[u]=1;\n    for (int v:G[u])\n        if (!vis[v]) dfs(v);\n    ans.pb(u);\n}\n\nint main() {\n    cin>>n>>m;\n    for (int i=0;i<m;i++) {\n        int u,v; cin>>u>>v;\n        G[u].pb(v);\n    }\n    for (int i=0;i<n;i++)\n        if (!vis[i]) dfs(i);\n    for(auto it=ans.rbegin(); it!=ans.rend();it++) cout <<　*it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Vertex {\n    bool is_visit = false;\n    int in_degree = 0;\n    vector<int> link;\n};\n\nclass TopologicalSort {\nprivate:\n    int n;\n    vector<Vertex> graph;\n    queue<int> Q;\n    vector<int> out;\n\npublic:\n    TopologicalSort() {};\n\n    TopologicalSort(int n)\n    {\n        this->n = n;\n        graph.resize(n);\n        int edge;\n        cin >> edge;\n        int s, t;\n        for (int e = 0; e < edge; e++)\n        {\n            cin >> s >> t;\n            graph[s].link.push_back(t);\n            graph[t].in_degree++;\n        }\n    }\n\n    void bfs(int root)\n    {\n        Q.push(root);\n        graph[root].is_visit = true;\n\n        while(!Q.empty())\n        {\n            int u = Q.front();\n            Q.pop();\n\n            out.push_back(u);\n\n            for(int v : graph[u].link)\n            {\n                graph[v].in_degree--;\n                if(graph[v].in_degree == 0 && !graph[v].is_visit)\n                {\n                    graph[v].is_visit = true;\n                    Q.push(v);\n                }\n            }\n        }\n    }\n\n    void topologicalSort()\n    {\n        for(int u = 0; u < n; u++)\n        {\n            if(graph[u].in_degree == 0 && !graph[u].is_visit)\n                bfs(u);\n        }\n    }\n\n    void print()\n    {\n        for(int ans : out)\n            cout << ans << endl;\n    }\n};\n\nint main()\n{\n    int n;\n     cin >> n;\n     TopologicalSort topologicalSort(n);\n     topologicalSort.topologicalSort();\n     topologicalSort.print();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nint main() {\n  int V, E;\n  scanf(\"%d%d\", &V, &E);\n  std::vector<std::vector<int>> edges(V, std::vector<int>());\n  std::vector<int> cs(V, 0);\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    edges[s].push_back(t);\n    cs[t]++;\n  }\n  std::vector<int> todo;\n  for (int v = 0; v < V; v++)\n    if (cs[v] == 0)\n      todo.push_back(v);\n  while (todo.size()) {\n    auto s = todo.back();\n    todo.pop_back();\n    printf(\"%d\\n\", s);\n    for (auto&& t : edges[s]) {\n      cs[t]--;\n      if (cs[t] == 0)\n        todo.push_back(t);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\nusing namespace std;\n\nstruct SCC{\n    vector<vector<int> > g,rg;\n    vector<int> vs,cmp,used;\n    SCC(int v):g(v),rg(v),cmp(v,-1),used(v,0){}\n    \n    void add_edge(int src,int dst){\n        g[src].pb(dst);\n        rg[dst].pb(src);\n    }\n    void dfs(int v){\n        used[v]=true;\n        rep(i,g[v].size()){\n            if(!used[g[v][i]]) dfs(g[v][i]);\n        }\n        vs.pb(v);\n    }\n    void rdfs(int v,int k){\n        used[v]=true;\n        cmp[v]=k;\n        rep(i,rg[v].size()){\n            if(!used[rg[v][i]]) rdfs(rg[v][i],k);\n        }\n    }\n    int scc(){\n        fill(used.begin(),used.end(),0);\n        vs.clear();\n        rep(i,used.size()){\n            if(!used[i]) dfs(i);\n        }\n        fill(used.begin(),used.end(),0);\n        int k=0;\n        for(int i=vs.size()-1;i>=0;--i){\n            if(!used[vs[i]]) rdfs(vs[i],k++);\n        }\n        return k;\n    }\n};\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    SCC scc(v);\n    int s,t;\n    rep(i,e){\n        cin>>s>>t;\n        scc.add_edge(s,t);\n    }\n    scc.scc();\n    rep(i,v) cout<<scc.cmp[i]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int s) {\n  V[u] = true;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!V[v]) {\n      dfs(v);\n  }\n  out.push_front(u);\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (!V[i]) {\n      dfs(i);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool flag;\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        flag = 0;\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            q.push(j);\n            glaph[j].count--;\n            if (glaph[j].count == 0 && !glaph[j].flag) {\n                cout << j << endl;\n                glaph[j].flag = 1;\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            glaph[i].flag = 1;\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topologicalSort(const vector<vector<int>> &G){\n    vector<int> res, visited(G.size());\n    auto dfs = [&](auto &&dfs, int cur) {\n        if(visited[cur]++) return;\n        for(auto &to : G[cur]) {\n            if(!visited[to]) dfs(dfs, to);\n        }\n        res.emplace_back(cur);\n    };\n    for(int i = 0; i < G.size(); ++i) {\n        dfs(dfs, i);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for(int i = 0; i < E; ++i) {\n        int a, b;\n        cin >> a >> b;\n        G[a].emplace_back(b);\n    }\n    auto list = topologicalSort(G);\n    for(auto &p : list) cout << p << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <list>\nusing namespace std;\n\nconst int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nlist<int> sorted;\nbool V[MAX_V];\nint v, e;\nint indeg[MAX_V];\n\nvoid bfs(int s) {\n    queue<int> que; que.push(s);\n    V[s] = true;\n\n    while (!que.empty()) {\n        int u = que.front(); que.pop();\n        sorted.push_back(u);\n        for (auto i = 0; i < G[u].size(); i++) {\n            int ver = G[u][i]; indeg[ver]--;\n            if (indeg[ver] == 0 && !V[ver]) {\n                V[ver] = true;\n                que.push(ver);\n            }\n        }\n    }\n}\n\nvoid topologicalSort() {\n    for (int i = 0; i < v; i++) {\n        indeg[i] = 0;\n    }\n\n    for (int u = 0; u < v; u++) {\n        for (auto i = 0; i < G[u].size(); i++) {\n            int ver = G[u][i];\n            indeg[ver]++;\n        }\n    }\n\n    for (int u = 0; u < v; u++) {\n        if (indeg[u] == 0 && !V[u]) bfs(u);\n    }\n}\n\n\n\n\nint main(void) {\n    cin >> v >> e;\n    for (int i = 0; i < v; i++) {\n        V[i] = false;\n    }\n\n    int s, t;\n    for (int i = 0; i < e; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    topologicalSort();\n\n    for (auto it = sorted.begin(); it != sorted.end(); it++) {\n        cout << *it << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\nvector<int> tpsort_Kahn(const Graph &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.emplace_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    int s, t;\n    rep(i,0,E) {\n        cin >> s >> t;\n        G[s].pb(Edge(t,1));\n    }\n    vector<int> ans = tpsort_Kahn(G);\n    rep(i,0,ans.size()) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 100000\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\nvector<int>  g[MAX_V];\n\nvoid dfs(vector<bool>& used,int s){\n\tused[s] = false;\n\trep(i,g[s].size() ){\n\tif(used[g[s][i]])\t{\n\t\tdfs(used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back(s);\n\treturn;\n}\nvoid\ttsort(int v){\n\tvector<bool> used(v,true);\n\trep(i,v){\n\tif(used[i]){\n\tdfs(used,i);\n\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\t//vector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\ttsort(v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N,M; //頂点と辺の数\nvector<vector<int>> G; //グラフ\nvector<int> h; //入次数\nvector<int> l_depth; //最大経路長\nvector<int> ans; //答えを格納\n\nvoid input(){\n  cin>>N>>M;\n  G.resize(N);\n  h.resize(N, 0);\n  int f,t;\n  for(int i=0; i<M; i++){\n    cin>>f>>t;\n    //f--; t--;\n    G[f].push_back(t);\n    h[t]++;\n  }\n}\n\nvoid topoBFS(){   \n  queue<int> unchecked;\n  for(int i=0; i<N; i++){\n    if(h[i]==0){\n      unchecked.push(i);\n      l_depth[i] = 0;\n    }\n  }\n  while(!unchecked.empty()){\n    int current = unchecked.front();\n    unchecked.pop();\n    ans.push_back(current);\n\n    for(int next: G[current]){\n      h[next]--;\n      l_depth[next] = max(l_depth[next], l_depth[current]+1); //最長経路長\n      if(h[next]==0){\n        unchecked.push(next);\n      }\n    }\n  }\n}\n\nint main(){\n  input();\n\n  l_depth.resize(N, -1);\n  topoBFS();\n\n  bool isDAG = ans.size()==N; //DAGであるかどうか\n  if(isDAG){\n    for(int x: ans){\n      cout<<x<<endl;\n    }\n  }else{\n    cout<<\"DAGではない\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector <int> res, graph[10000];\nbool visited[10000];\n\nvoid dfs(int v){\n  visited[v] = true;\n  for(int u : graph[v]){\n    if(!visited[u]){\n      dfs(u);\n    }\n  }\n  res.push_back(v);\n}\n\nvoid topological_sort(int n){\n  for(int i = 0; i < n; i++){\n    if(!visited[i]){\n      dfs(i);\n    }\n  }\n  reverse(res.begin(), res.end());\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n, m, i, x, y;\n  cin >> n >> m;\n  while(m--){\n    cin >> x >> y;\n    graph[x].push_back(y);\n  }\n  topological_sort(n);\n  for(int x : res){\n    cout << x << \" \";\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long int ll;\n\n#define all(x) x.begin(),x.end()\n\nconst ll mod = 1e9+7;\nconst ll INF = 1e9;\nconst ll MAXN = 1e9;\n\nvector<int> toporogical_sort(const vector<vector<int> > g){\n\tint n = g.size();\n\tvector<int> in_degree(n,0);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tin_degree[g[i][j]]++;\n\t\t}\n\t}\n\n\tvector<int> res;\n\tstack<int> S;\n\tfor(int i = 0; i < n; i++){\n\t\tif(in_degree[i]==0) S.push(i);\n\t}\n\n\twhile(!S.empty()){\n\t\tint p = S.top();\n\t\tS.pop();\n\t\tres.push_back(p);\n\t\tfor(int i = 0; i < g[p].size(); i++){\n\t\t\tin_degree[g[p][i]]--;\n\t\t\tif(in_degree[g[p][i]]==0) S.push(g[p][i]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint V,E;\n\tcin>>V>>E;\n\tvector<vector<int> > g(V,vector<int>());\n\tfor(int i = 0; i < E; i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t}\n\n\tvector<int> t_sort = toporogical_sort(g);\n\tfor(int i = 0; i < t_sort.size(); i++){\n\t\tcout << t_sort[i] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& vec) { for (auto &vi: vec) os << vi << \" \"; return os; }\n\nusing Graph = vector<vector<int>>;\nvector<vector<int>> tsort(Graph &g) {\n    int n = g.size(), k = 0;\n    vector<int> indeg(n), que, nxt;\n    for (int u = 0; u < n; u++) for (int v: g[u]) ++indeg[v];\n    vector<vector<int>> dist(n);\n    for (int v = 0; v < n; v++) if (indeg[v] == 0) que.emplace_back(v);\n    while (!que.empty()) {\n        for (int u: que) {\n            dist[k].emplace_back(u);\n            for (int v: g[u]) if (--indeg[v] == 0) nxt.emplace_back(v);\n        }\n        swap(que, nxt); nxt.clear(); k++;\n    }\n    if (*max_element(indeg.begin(), indeg.end()) != 0) return {};\n    return dist.resize(k), dist;\n}\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    while (E--) {\n        int s, t; cin >> s >> t;\n        g[s].emplace_back(t);\n    }\n    for (auto &vec: tsort(g)) for (int v: vec) cout << v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\nusing namespace std;\n#define MAX 10000\n#define WHITE 0\n#define BLACK 2\n\nint n,e;\nint col[MAX];\n\n\nint main(){\n    vector<int> P[MAX];\n    int s,t;\n    cin>>n>>e;\n    for(int i=0;i<e;i++){\n        cin>>s>>t;\n        P[t].push_back(s);\n    }\n    for(int i=0;i<n;i++) col[i]=WHITE;\n\n    bool fin=false;\n    bool end;\n    while(fin==false){\n        fin=true;\n        for(int i=0;i<n;i++){\n            end=true;\n            if(col[i]==WHITE){\n                fin=false;\n                if(!P[i].empty()){\n                    for(int j=0;j<P[i].size();j++){\n                        int a = P[i][j];\n                        if(col[a]==WHITE) end=false;\n                    }\n                }\n                if(end==true){\n                    cout<<i<<endl;\n                    col[i]=BLACK;\n                    i=0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nclass Vertex{\n  int connection;\n  int name;\n  list<Vertex*> v_list;\n  Vertex(int n):connection(0),name(n){}\n  friend class Graph;\n};\n\nclass Graph{\n  vector<Vertex*> graph;\npublic:\n  Graph(int size){\n    graph.resize(size);\n    for(int i=0;i<size;i++){\n      graph[i]=new Vertex(i);\n    }\n  }\n\n  ~Graph(){\n    for(int i=0;i<(int)graph.size();i++){\n      delete graph[i];\n    }\n  }\n\n  void addEdge(int from,int to){\n    graph[from]->v_list.push_back(graph[to]);\n    graph[to]->connection++;\n  }\n\n  void topo(){\n    Vertex *v;\n    queue<Vertex*> q;\n    vector<Vertex*> vec;\n\n    for(int i=0;i<(int)graph.size();i++){\n      if(graph[i]->connection==0) q.push(graph[i]);\n    }\n\n    while(!q.empty()){\n      v=q.front();\n      q.pop();\n      vec.push_back(v);\n      for(list<Vertex*>::iterator it=v->v_list.begin();it!=v->v_list.end();it++){\n\tVertex* w=*it;\n\tif((--w->connection)==0){\n\t  q.push(w);\n\t}\n      }\n    }\n\n    for(int i=0;i<(int)vec.size();i++){\n      cout<<vec[i]->name<<endl;\n    }\n\n  }\n\n};\n\nint main(){\n  int v=0;\n  int e=0;\n  cin>>v>>e;\n  Graph graph(v);\n  for(int i=0;i<e;i++){\n    int from,to;\n    cin>>from>>to;\n    graph.addEdge(from,to);\n  }\n  graph.topo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <climits>\n#include <iterator>\n#include <iomanip>\n#include <stack>\n#include <bitset>\n#include <functional>\nusing namespace std;\n//typedef std::pair<std::string,double> P;\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n//グラフの隣接リスト\nVI g[100010];\n//頂点の入次数を管理\nint h[100010];\nsigned main(void) {\n\n\t//頂点数v, 辺の数e\n\tint v, e;\n\tcin >> v >> e;\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t); //sからtに向かう辺\n\n\t\th[t]++;\n\t}\n\tstack<int> st;\n\n\tREP(i, v) if (h[i] == 0)st.push(i);\n    \n\t//ソートされた後のグラフ\n\tVI ans;\n\t\n\twhile (st.size()) {\n\t\t//stの集合から一つ取り出す\n\t\tint i = st.top(); st.pop();\n\n\t\tans.push_back(i);\n\n\t\tfor (auto& j : g[i]) {\n\t\t\t//隣接する頂点の入次数をマイナス1\n\t\t\th[j]--;\n\t\t\t//これによって入次数が0になればstに追加\n\t\t\tif (h[j] == 0)st.push(j);\n\t\t}\n\t}\n\n\tfor (auto i : ans) cout << i << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list> \nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N, indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t    int v = G[u][i];\n\t\t    indeg[v]--;\n            if(indeg[v] == 0 && !V[v]) {\n            \tV[v] = true;\n            \tq.push(v);\n            }\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor(int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v =  G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tif(indeg[u] == 0 && ! V[u]) bfs(u);\n\t}\n\t\n\tfor(list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++) {\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n    \n    tsort();\n    \n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstatic const int MAX = 10000;\nstatic const int WHITE = 0;\nstatic const int BLACK = 1;\n\nint n, e;\nint indeg[MAX], color[MAX];\nvector<int> L[MAX];\nvector<int> vec;\n\nvoid bfs(int u) {\n\tqueue<int> Q;\n\tQ.push(u);\n\tcolor[u] = BLACK;\n\twhile (!Q.empty()) {\n\t\tint uu = Q.front();\n\t\tQ.pop();\n\t\tvec.push_back(uu);\n\t\tfor (int i = 0; i < L[uu].size(); i++) {\n\t\t\tint v = L[uu][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0) {\n\t\t\t\tcolor[v] = BLACK;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid TopoligicalSort() {\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (color[i] == WHITE && indeg[i] == 0) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> e;\n\tint s, t;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcolor[i] = WHITE;\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int i = 0; i < e; i++)\t{\n\t\tcin >> s >> t;\n\t\tindeg[t]++;\n\t\tL[s].push_back(t);\n\t}\n\n\tTopoligicalSort();\n\n\tfor (int i = 0; i < n; i++)\t{\n\t\tcout << vec[i] << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MaxV = 10000;\n\nvector<int> AdjL[MaxV];\nint InDegree[MaxV];\nqueue<int> Q;\n\nint main() {\n\tint V, E;\n\tint s, t;\n\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; i++) {\n\t\tInDegree[i] = 0;\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tAdjL[s].push_back(t);\n\t\tInDegree[t]++;\n\t}\n\tfor (int i = 0; i < V; i++) {\n\t\tif (InDegree[i] == 0) {\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\twhile (Q.empty() == false) {\n\t\ts = Q.front();\n\t\tQ.pop();\n\t\tcout << s << endl;\n\t\tfor (unsigned int i = 0; i < AdjL[s].size(); i++) {\n\t\t\tt = AdjL[s][i];\n\t\t\tif (--InDegree[t] == 0) {\n\t\t\t\tQ.push(t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_A&lang=jp\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\nconstexpr int INF = 1 << 28;\nusing EdgeList = vector<vector<int>>;\n// ?????£?????????????????°?????? E ????????£????????????????§£(Tarjan's algorithm)\n// O(N + M) N: ????????°, M: ?????°\nvector<vector<int>> strongly_connected_components_tarjan(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    stack<int> stk;\n    vector<bool> on_stack(N);\n    vector<vector<int>> scc;    \n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        stk.push(now);\n        on_stack[now] = true;\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(int nxt : E[now]) {\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(on_stack[nxt]) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            } \n        }\n        if(ord[now] == low[now]) {\n            scc.push_back({});\n            while(true) {\n                int v = stk.top(); stk.pop();\n                scc.back().push_back(v);\n                on_stack[v] = false;\n                if(v == now) break;\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return scc;\n}\n// ????????°?????????????????????????????????????????????\nbool detect_cycle_tarjan(const EdgeList &E) {\n    auto scc = strongly_connected_components_tarjan(E);\n    bool res = false;\n    for(auto &g : scc) res |= g.size() > 1;\n    return res;\n}\n// ????????°?????? E ????????£????????????????§£(?????¬)\n// O(N + M) N: ????????°, M: ?????°\n// -> ??????????????????????????????????????????????????????????????£????????????0 ??? root\nvector<int> strongly_connected_components_ant(const EdgeList &E) {\n    int N = E.size();\n    EdgeList rE(N); rep(i, N) for(int nxt : E[i]) rE[nxt].push_back(i); // ??????    \n    vector<char> used(N);\n    vector<int> vs; // DFS??°????????????\n    vector<int> topological_no(N);\n    function<void(int)> dfs = [&] (int v) {\n        used[v] = true;\n        for(int nxt : E[v]) if(not used[nxt]) dfs(nxt);\n        vs.push_back(v);\n    };\n    function<void(int, int)> rdfs = [&] (int v, int k) {\n        topological_no[v] = k;\n        used[v] = true;\n        for(int nxt : rE[v]) if(not used[nxt]) rdfs(nxt, k);\n    };\n    rep(v, N) if(not used[v]) dfs(v);\n    fill(begin(used), end(used), false);\n    int k = 0;\n    for(int i = vs.size() - 1; i >= 0; i--) if(not used[vs[i]]) rdfs(vs[i], k++);\n    return topological_no;\n}\n// ????????°?????????????????????????????????????????????\nbool detect_cycle_ant(const EdgeList &E) {\n    auto scc = strongly_connected_components_ant(E);\n    set<int> found;\n    for(int v : scc) {\n        if(found.count(v)) return true;\n        found.insert(v);\n    }\n    return false;\n}\nint main() {\n    int N, M; cin >> N >> M;\n    EdgeList E(N);\n    rep(i, M) {\n        int a, b; cin >> a >> b;\n        E[a].push_back(b);\n    }\n    auto scc1 = strongly_connected_components_tarjan(E);\n    reverse(begin(scc1), end(scc1));\n    vector<int> ans1;\n    {\n        for(vector<int> g : scc1) {\n            sort(begin(g), end(g));\n            for(int a : g) ans1.push_back(a);\n        }\n    }\n    auto scc2 = strongly_connected_components_ant(E);\n    vector<int> ans2(N);\n    {\n        vector<pair<int, int>> P(N);\n        rep(i, N) P[i] = make_pair(scc2[i], i);\n        sort(begin(P), end(P));\n        rep(i, N) ans2[i] = P[i].second;\n    }\n    assert(ans1 == ans2);\n    for(int a : ans1) cout << a << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <fstream>\n#include <cmath>\n#include <iomanip>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <deque>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <unordered_map>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\nstatic const int INFTY = (1<<29);\n\nvector <int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while (! q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for (int i=0;i<G[u].size();i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 and !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for (int i=0;i<N;i++){\n        indeg[i] = 0;\n    }\n    for (int u=0;u<N;u++){\n        for (int i=0;i<G[u].size();i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    for (int u=0;u<N;u++){\n        if (indeg[u] == 0 and !V[u]){\n            bfs(u);\n        }\n    }\n    for (list<int>::iterator it= out.begin();it != out.end();it++){\n        cout << *it << endl;\n    }\n\n}\n\nint main() {\n   \n\n    int s,t,M;\n    cin >> N >> M;\n    for (int i=0;i<N;i++) V[i] = false;\n\n    for (int i=0;i<M;i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nbool pairCompare(const P& p1, const P& p2)\n{\n    if(p1.second == p2.second) return p1.first < p2.first;\n    return p1.second < p2.second;\n}\n\nvoid step(vector<P>& d, vector< vector<int> >& edges, int node)\n{\n    queue<int> Q;\n    Q.push(node);\n    while(!Q.empty())\n    {\n        node = Q.front();\n        Q.pop();\n        for(int v : edges[node])\n        {\n            if(d[v].second < d[node].second + 1){\n                d[v].second = d[node].second + 1;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nvoid topological_sort(vector<P>& d, vector< vector<int> >& edges)\n{\n    int n = d.size();\n    for(int i=0;i<n;++i)\n    {\n        if(d[i].second == 0) step(d, edges, i);\n    }\n    sort(d.begin(), d.end(), pairCompare);\n}\n\nint main()\n{\n    int N, M, s, t;\n    cin >> N >> M;\n    vector< vector<int> > edges(N);\n    vector<P> d(N);\n    for(int i=0;i<M;++i)\n    {\n        cin >> s >> t;\n        edges[s].push_back(t);\n    }\n    for(int i=0;i<N;++i)\n    {\n        d[i] = make_pair(i, 0);\n    }\n    topological_sort(d, edges);\n    for(int i=0;i<N;++i)\n    {\n        cout << d[i].first << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\nusing namespace std;\n\nqueue<int> S;// ??\\???????????????????????¨???????????????\nvector<int> in[N];// ??\\??????\nvector<int> out[N];// ?????????\nvector<int> G[N];// ??\\?????????????????????????????\\???\n\nvoid init(int V){// ?????°??????????????°\n  for(int i=0;i<V;i++)in[i].clear();\n  for(int i=0;i<V;i++){\n    out[i]=G[i];\n    for(int j=0;j<G[i].size();j++)\n      in[G[i][j]].push_back(i);\n  }\n  for(int i=0;i<V;i++)\n    if(!in[i].size())S.push(i);\n}\n\nvector<int> Topological_Sort(int V){\n  vector<int> res;\n  while(!S.empty()){\n    int pos=S.front(); S.pop();\n    res.push_back(pos);\n    for(int i=0;i<out[pos].size();i++){\n      int nx=out[pos][i];\n      if(in[nx].size()==1)S.push(nx);\n      for(int j=0;j<in[nx].size();j++)\n\tif(pos==in[nx][j]){\n\t  in[nx].erase(in[nx].begin()+j);\n\t  break;\n\t}\n      out[pos].erase(out[pos].begin()+i);\n      i--;\n    }\n  }\n  for(int i=0;i<V;i++)\n    if(in[i].size()||out[i].size())\n      res.clear();\n  return res;\n}\n\nint main(){\n  int v,e,s,t;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  init(v);\n  vector<int> ans=Topological_Sort(v);\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <list>\nusing namespace std;\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAXV = 10005;\nconst int MAXE = 100005;\n\nstruct Edge {\n\tint to, next;\n} edge[MAXE];\n\nlist<int> ans;\nint head[MAXE];\nint indegree[MAXV];\nbool vis[MAXV];\nint cnt;\n\nvoid bfs(int u)\n{\n\tqueue<int> q;\n\tvis[u] = true;\n\tq.push(u);\n\twhile (!q.empty())\n\t{\n\t\tu = q.front();\n\t\tq.pop();\n\t\tans.push_back(u);\n\t\tfor (int i = head[u]; i != NIL; i = edge[i].next)\n\t\t{\n\t\t\tu = edge[i].to;\n\t\t\tif (!vis[u] && --indegree[u] == 0)\n\t\t\t{\n\t\t\t\tvis[u] = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nvoid topologicalSort(int n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t\tvis[i] = false;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (indegree[i] == 0 && !vis[i])\n\t\t\tbfs(i);\n\t}\n}\n\nvoid add(int u, int v)\n{\n\tedge[cnt].to = v;\n\tedge[cnt].next = head[u];\n\thead[u] = cnt++;\n}\n\n\nint main(void)\n{\n\t\n\tint V, E, s, t;\n\tscanf(\"%d%d\", &V, &E);\n\tcnt = 0;\n\tmemset(head, NIL, sizeof(int) * (E + 1));\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d%d\", &s, &t);\n\t\t++indegree[t];\n\t\tadd(s, t);\n\t}\n\ttopologicalSort(V);\n\tfor (list<int>::iterator it = ans.begin(); it != ans.end(); ++it)\n\t\tprintf(\"%d\\n\", *it);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=(m); i<(int)(n); i++)\n#define RREP(i,m,n) for(int i=(int)(n-1); i>=m; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define fi first\n#define se second\n#define debug(...) {cerr<<\"[L\"<<__LINE__<<\"] \"; _debug(__VA_ARGS__);}\n\ntemplate<typename T>\nstring join(const vector<T>&v, string del=\", \"){ stringstream s;\n    for(auto x : v) s << del << x; return s.str().substr(del.size());\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<T>&v){\n    if(v.size()) o << \"[\" << join(v) << \"]\"; return o;\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<vector<T> >&vv){\n    int l = vv.size();\n    if(l){ o<<endl; rep(i,l) o << (i==0 ? \"[ \" : \",\\n  \" ) << vv[i] << (i==l-1 ? \" ]\" : \"\"); }\n    return o;\n}\ninline void _debug(){cerr<<endl;}\ntemplate<class First, class... Rest>\nvoid _debug(const First& first, const Rest&... rest){cerr<<first<<\" \";_debug(rest...);}\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst double PI = (1*acos(0.0));\nconst double EPS = 1e-9;\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst ll mod = 1e9 + 7;\n\ninline void finput(string filename) {\n    freopen(filename.c_str(), \"r\", stdin);\n}\n\nint V,E;\nvvi g;\nvi tsort(){\n    vi indeg(V, 0);\n    stack<int> S;\n    rep(i,V) for(auto v : g[i]) indeg[v]++;\n    rep(i,V) if(indeg[i] == 0) S.push(i);\n\n    vi res;\n    while(S.size()>0){\n        int v = S.top(); S.pop();\n        res.emplace_back(v);\n        for(auto u : g[v]){\n            indeg[u]--;\n            if(indeg[u] == 0) S.push(u);\n        }\n    }\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    // finput(\"./input\");\n    cin >> V >> E;\n    g = vvi(V);\n    rep(i,E){\n        int s,t; cin >> s >> t;\n        g[s].push_back(t);\n    }\n    vi ans = tsort();\n    rep(i,V){\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\t//for(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\nif(V!=order.size())return 1;\n\t\t\tfor(i=0;i<V;i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t//}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif __GNUC__\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\nclass DGraph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n\n    DGraph(size_t n = 1) :n(n), vertex_to(n), vertex_from(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[(size_t)from].emplace_back(to);\n        vertex_from[(size_t)to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n        vertex_from.resize(_n);\n    }\n};\n\nvector<int> topological_sort(const DGraph& graph) {\n    const int n = graph.n;\n    vector<int> result; result.reserve(n);\n    vector<int> start; start.reserve(n);\n    vector<int> sync(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = graph.vertex_from[i].size();\n        if (x == 0)\n            start.push_back(i);\n        else\n            sync[i] = x;\n    }\n\n    function<void(int)> dfs = [&](int idx) {\n        result.push_back(idx);\n        for (int to : graph.vertex_to[idx]) {\n            if (0 < sync[to])\n                --sync[to];\n            else\n                dfs(to);\n        }\n    };\n    for (int s : start) dfs(s);\n    return result;\n}\n\n\n\nint main() {\n    ll m, n, kei;\n\n    scanner >> n >> m;\n\n    DGraph graph(n);\n    repeat(i, m) {\n        int a, b;\n        scanner >> a >> b;\n        graph.connect(a, b);\n    }\n\n    auto ans = topological_sort(graph);\n\n    printer.join(ALL(ans));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nstd::vector<int> tsort(const Graph &g) {\n  int n = g.size(), k = 0;\n  std::vector<int> ord, in(n);\n  ord.reserve(n);\n  for (auto &es : g) {\n    for (auto &e : es) in[e.dst]++;\n  }\n  std::queue<int> q;\n  rep(i, n) if (in[i] == 0) q.push(i);\n  while (q.size()) {\n    int v = q.front();\n    q.pop();\n    ord.emplace_back(v);\n    for (auto &e : g[v])\n      if (--in[e.dst] == 0) q.push(e.dst);\n  }\n  return ord.size() == n ? ord : std::vector<int>();\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int s, t;\n    cin >> s >> t;\n    g.addArc(s, t);\n  }\n  vi v = tsort(g);\n  for (auto &x : v) cout << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)\n#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)\n#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)\n#define RREP(i, n) for (decltype(n) i = (n) - 1; i >= 0; i--)\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nusing namespace std;\n\n// N, E, S, W\nconst int dx[4] = { 1, 0, -1, 0};\nconst int dy[4] = { 0, 1, 0, -1};\n\nusing LL = long long int;\nusing LD = long double;\n\nconst int INF = (1 << 30) - 1;\nconst LL INF64 = ((LL)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nusing pii = pair<int, int>;\nusing pll = pair<LL, LL>;\nusing pdd = pair<double, double>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<LL>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\n//==============================================\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint v, e;\n\tcin >> v >> e;\n\n\tvvi G(v);\n\tvi indeg(v);\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\n\n\tvi ans;\n\tqueue<int> q;\n\tREP(i, v) {\n\t\tif (indeg[i] == 0) q.push(i);\n\t}\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\n\t\tans.push_back(u);\n\n\t\tfor (int v : G[u]) {\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0) q.push(v);\n\t\t}\n\t}\n\n\tfor (int a : ans) cout << a << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<pair<int, int>, int> PP;\nconst ll INFL = 1LL << 60;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst int MAX = 300000;\nint GCD(int a, int b) { return b ? GCD(b, a % b) : a; }\n\n//------------------------------------------------------------------------------------------------------------------------------\n\nvector<vector<int>> G;\nvector<int> ans;\nbool visit[10000];\nvoid dfs(int v) {\n    visit[v] = 1;\n    for (auto nv : G[v]) {\n        if (visit[nv]) {\n            continue;\n        }\n        dfs(nv);\n    }\n    ans.push_back(v);\n}\n\nint main(void) {\n    int V, E;\n    cin >> V >> E;\n    G.resize(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    for (int i = 0; i < V; i++) {\n        if (!visit[i]) {\n            dfs(i);\n        }\n    }\n    reverse(ans.begin(), ans.end());\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<list>\n#define NMAX 10005\nusing namespace std;\nshort n;\nlist<short> result;\nvector<short> Graphics[NMAX];\nint inDegree[NMAX];\nbool state[NMAX];\n\nvoid bfs(short index){\n    queue<short> temp;\n    temp.push(index);\n    state[index] = true;\n    while(!temp.empty()){\n        short nowNode = temp.front();\n        temp.pop();\n        result.push_back(nowNode);\n        int maxSize = Graphics[nowNode].size();\n        for(int i = 0;i<maxSize;i++){\n            short nextNode = Graphics[nowNode][i];\n            inDegree[nextNode]--;\n            if(!inDegree[nextNode] && !state[nextNode]){\n                state[nextNode] = true;\n                temp.push(nextNode);\n            }\n        }\n    }\n}\n\nvoid topo(){\n    for(short i =0;i<n;i++)\n        if(!inDegree[i]&&!state[i])\n            bfs(i);\n    for(auto it:result)\n        printf(\"%d\\n\", it);\n}\n\nint main(){\n    int edge;\n    short out, in;\n    scanf(\"%hd%d\", &n, &edge);\n    while(edge--){\n        scanf(\"%hd%hd\", &out, &in);\n        Graphics[out].push_back(in);\n        inDegree[in]++;\n    }\n\ttopo();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\nusing namespace std;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nint indeg[10005];\n\nvector<int> tsort()\n{\n    stack<int> S;\n    REP(i,V) if(indeg[i]==0) S.push(i);\n\n    vector<int> res;\n    while(!S.empty()){\n        int v=S.top(); S.pop();\n        res.push_back(v);\n        for(auto u:G[v]){\n            indeg[u]--;\n            if(indeg[u]==0) S.push(u);\n        }\n    }\n    return res;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n        indeg[b]++;\n    }\n\n    vector<int> ans=tsort();\n    REP(i,ans.size()) cout<<ans[i]<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n\nstruct TopologicalSort {\n    int n;\n    std::vector<std::vector<int>> G;\n    std::vector<int> indeg;\n    TopologicalSort(int n) : n(n), G(n, std::vector<int>()), indeg(n) {}\n    void addEdge(int from, int to) {\n        G[from].push_back(to);\n        indeg[to]++;\n    }\n    std::vector<int> getSorted() {\n        std::vector<int> stk, ret;\n        for (int i = 0; i < n; i++) { if (indeg[i] == 0) { stk.push_back(i); }}\n        while (!stk.empty()) {\n            int i = stk.back();\n            stk.pop_back();\n            ret.push_back(i);\n            for (int j = 0; j < G[i].size(); j++) {\n                if (--indeg[G[i][j]] == 0) { stk.push_back(G[i][j]); }\n            }\n        }\n        return ret;\n    }\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    TopologicalSort ts(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        ts.addEdge(s, t);\n    }\n    vector<int> ans = ts.getSorted();\n    for (int i = 0; i < V; i++) { cout << ans[i] << endl; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#define V_MAX 10000\n#define E_MAX 100000\nusing namespace std;\n\nint V,E;\nbool check[V_MAX+1],visited[V_MAX+1];\nqueue<int> G[V_MAX+1];//隣接リスト\nqueue<int> order;\nlist<int> TO,TO_tmp;//最後だけでなく先頭にも要素が追加できる点でやはりlistがベストな選択\n\nvoid bfs(){\n\twhile(!order.empty()){\n\t\tint num = order.front();order.pop();\n\t\tif(visited[num])return;visited[num] = true;\n\t\tTO_tmp.push_back(num);\n\t\twhile(!G[num].empty()){\n\t\t\tif(!check[G[num].front()]){\n\t\t\t\torder.push(G[num].front());\n\t\t\t\tcheck[G[num].front()] = true;\n\t\t\t}\n\t\t\tG[num].pop();\n\t\t}\n\t}\n\twhile(!TO_tmp.empty()){\n\t\tTO.push_front(TO_tmp.back());\n\t\tTO_tmp.pop_back();\n\t}\n}\n\n\nvoid solve(){\n\tfor(int i = 0;i < V;i++){check[i] = false;visited[i] = false;}\n\tint vs,ve;\n\tfor(int i = 0;i < E;i++){\n\t\tcin >>vs >>ve;\n\t\tG[vs].push(ve);\n\t}\n\tfor(int i = 0;i < V;i++){order.push(i);bfs();}\n\twhile(!TO.empty()){cout <<TO.front() <<endl;TO.pop_front();}\n\treturn;\n}\n\nint main(){\n\tcin >>V >>E;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nstatic const int MAX = 10000;\n\nusing namespace std;\nint V,E;\nvector<int> G[MAX];\nvector<int> ans;\nbool used[MAX]; //訪問済みかどうか\nint indeg[MAX]; //各点の入次数\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    used[s]=true;\n    while(!q.empty())\n    {\n        int u=q.front(); q.pop();\n        ans.push_back(u);\n        for(int i=0;i<G[u].size();i++)\n        {\n            int k = G[u][i];\n            indeg[k]--;\n            if(indeg[k]==0 && !used[k])\n            {\n                used[k]=true;\n                q.push(k);\n            }\n        }\n    }\n}\n\nvoid topological()\n{\n    for(int u=0;u<V;u++)\n    {\n        if(indeg[u]==0 && !used[u])\n        {\n            bfs(u);\n        }\n    }\n}\n\nint main(){\n    cin>>V>>E;\n    fill(indeg,indeg+MAX,0);\n    fill(used,used+MAX,0); //訪問済み=true\n    for(int i=0;i<E;i++){\n        int s,t;\n        cin>>s>>t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n    topological();\n    for(int i=0;i<V;i++)\n    {\n        cout<<ans[i]<<\"\\n\";\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nstd::vector<int> tsort(const Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    std::vector<int> res, flg(n, YET);\n    static const std::function<bool(int)> dfs = [&](int v) {\n        flg[v] = VISITED;\n        for (auto &e : g[v]) {\n            int w = e.dst;\n            if(flg[w] == DONE) continue;\n            if(flg[w] == VISITED || !dfs(e.dst)) return false;\n        }\n        flg[v] = DONE;\n        res.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i)\n        if (flg[i] == YET && !dfs(i)) return {};\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define V vector<long long>\n#define VV vector<vector<long long>>\n#define rep(i,n) for(ll (i)=0;(i)<(n);++(i))\nusing namespace std;\n\nVV g;\nvector<bool> used;\nV topo;\n\nvoid dfs(ll now){\n    if(used[now])return;\n    used[now]=true;\n    for(ll to:g[now]){\n        dfs(to);\n    }\n    topo.push_back(now);\n}\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    g.assign(n, V());\n    rep(i,m){\n        ll x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n    }\n    used.assign(n, false);\n    rep(i,n)dfs(i);\n    reverse(topo.begin(), topo.end());\n    rep(i,n)cout<<topo[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10005;\nint N, M, used[MAX_N], deg_in[MAX_N], cmp[MAX_N];\nvector<vector<int>> G(MAX_N);\n\nint bfs(int s, int cnt){\n    queue<int> q; q.push(s);\n    used[s] = 1; cmp[cnt++] = s;\n\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        for(int v : G[u]){\n            deg_in[v]--;\n            if(deg_in[v]==0){\n                used[v] = 1; cmp[cnt++] = v;\n                q.push(v);\n            }\n        }\n    }\n    return cnt;\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    cin >> N >> M;\n    for(int i=0;i<M;i++){\n        int a, b; cin >> a >> b;\n        G[a].push_back(b); deg_in[b]++;\n    }\n\n    int cnt = 0;\n    for(int i=0;i<N;i++){\n        if(used[i]==0 && deg_in[i]==0) cnt = bfs(i, cnt);\n    }\n\n    for(int i=0;i<N;i++) cout << cmp[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nconst long MAX=100000;\n \nvector<int> G[MAX];\nlist<int> ou;\nbool V[MAX];\nint N;\nint indeg[MAX];\n \nvoid bfs(int s){\n    queue<int> que;\n    que.push(s);\n    V[s]=true; //?¨???????\n     \n    while( !que.empty() ){\n        int u=que.front();\n        que.pop();\n        ou.push_back(u); //????????¨????????????????????????\n         \n        for(int i=0; i<G[u].size(); ++i){\n            int v=G[u][i]; //u?????????????????????????????????????????????\n            indeg[v]--; //????¬???°???????????????\n             \n            if(indeg[v]==0 && !V[v]){\n                V[v]=true;\n                que.push(v);    \n            }\n        }\n    }       \n}\n \n//topological sort\nvoid tsort(){\n    for(int i=0; i<N; ++i) indeg[i]=0;\n     \n    for(int i=0; i<N; ++i){\n        for(int j=0; j<G[i].size(); ++j){\n            int k=G[i][j];\n            indeg[k]++;\n        }\n    }\n     \n    for(int i=0; i<N; ++i){\n        if(indeg[i]==0 && !V[i]) bfs(i);    \n    }\n     \n    for(list<int>::iterator it=ou.begin(); it!=ou.end(); ++it){\n        cout << *it << endl;    \n    }\n}\n \nint main(){\n    long M;\n    scanf(\" %d %ld\", &N, &M);\n     \n    for(int i=0; i<N; ++i) V[i]=false;\n     \n    for(long i=0; i<M; ++i){\n        int s, t;\n        scanf(\" %d %d\", &s, &t);\n        G[s].push_back(t); //??????????????????     \n    }   \n     \n    tsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 414514\nset<int> G[MAX];\nint indeg[MAX];\nbool V[MAX];\nvector<int> p;\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  V[s]=1;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    p.push_back(u);\n    for(int v:G[u]){\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n\tV[v]=1;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(int n){\n  memset(V,0,sizeof(V));\n  memset(indeg,0,sizeof(indeg));\n  for(int u=0;u<n;u++)\n    for(int v:G[u])\n      indeg[v]++;\n  for(int u=0;u<n;u++)\n    if(indeg[u]==0&&!V[u]) bfs(u);\n\n  if((int)p.size()!=n){\n    cout<<-1<<endl;\n    return;\n  }\n  for(int i=0;i<n;i++)\n    cout<<p[i]+1<<\" \\n\"[i==n-1];\n}\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].insert(t);\n  }\n  tsort(n);\n  return 0;\n}\n\n/*\nverified on 2017/04/28\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist <int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n\tqueue<int> q;\n\tq.push(s);\n\tV[s]=true;\n\twhile(q.size()){\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor(int i=0;i<G[u].size();i++){\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v]==0 && !V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tmemset(indeg,0,sizeof(indeg));\n\tfor(int u=0;u<N;u++){\n\t\tfor(int i=0;i<G[u].size();i++){\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor(int u=0;u<N;u++){\n\t\tif(indeg[u]==0 && !V[u])bfs(u);\n\t}\n\tfor(list<int>::iterator it=out.begin();it!=out.end();it++){\n\t\tcout << *it << endl;\n\t}\n}\n\nint main(void){\n\tint s,t,M;\n\tscanf(\"%d %d\",&N,&M);\n\tmemset(V,false,sizeof(V));\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// トポロジカルソート : 深さ優先探索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<list>\n\nusing namespace std;\n\nconst int MAX = 10000;\n\n// 各辺のつながりを格納する動的配列\nvector<int> G[MAX];\n// 訪問情報を保持する配列\nbool V[MAX];\n// トポロジカルソートの結果を格納するリスト\nlist<int> out;\n\nint N;\n\nvoid dfs(int u);\n\nint main(void)\n{\n\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++)\n    {\n        // 配列の初期化\n        V[i] = false;\n    }\n\n    for(int i = 0; i < M; i++)\n    {\n        cin >> s >> t;\n\n        // 各辺のつながりを記憶する\n        G[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n    {\n        if( !V[i] )\n        {\n            // 頂点を順番に訪れる\n            dfs(i);\n        }\n    }\n\n    // 結果の表示\n    // トポロジカルソートの結果の表示\n    for(list<int>::iterator it = out.begin(); it != out.end(); it++)\n    {\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\n// トポロジカルソートを実施するためのメソッド\n// u : 訪問する頂点\nvoid dfs(int u)\n{\n    // 訪問情報を記録\n    V[u] = true;\n\n    for(unsigned int i = 0; i < G[u].size(); i++ )\n    {\n        // 接続先の頂点No.の格納\n        int v = G[u][i];\n\n        if( !V[v] )\n        {\n            // 接続している頂点を順番に訪れる\n            dfs(v);\n        }\n    }\n\n    // 入力辺が無くなった頂点をトポロジカルキューに追加する\n    out.push_front(u);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, m, n) for (int i = (m); i < (int)(n); i++)\n#define REPS(i, m, n) for (int i = (m); i <= (int)(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define reps(i, n) for (int i = 0; i <= (int)(n); i++)\n#define rrep(i, x) for (int i = ((int)(x)-1); i >= 0; i--)\n#define rreps(i, x) for (int i = (int)(x); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int inf = INT_MAX;\nconst ll INF = 1LL << 60;\nconst ll mod = 1e9 + 7;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A, size_t N, typename T> void Fill(A (&array)[N], const T &val) { fill( (T*)array, (T*)(array+N), val ); }\n\nint V, E;\nvector<int> g[100010];\nbool used[100010];\nvector<int> ans;\n\nvoid dfs(int u) {\n    if (used[u]) return;\n    used[u] = true;\n    for (int i : g[u]) dfs(i);\n    ans.pb(u);\n}\n\nvoid tsort() {\n    rep(i, V) dfs(i);\n    reverse(all(ans));\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> V >> E;\n    rep(i, E) {\n        int s, t;\n        cin >> s >> t;\n        g[s].pb(t);\n    }\n\n    tsort();\n\n    for (int i : ans) cout << i << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int         num, E, from, to, table[10000], tmp;\n    vector<int> V[10000];\n    queue<int>  Q;\n\n    for (int i = 0; i < 10000; i++) table[i] = 0;\n\n    scanf(\"%d %d\", &num, &E);\n\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d %d\", &from, &to);\n        V[from].push_back(to);\n        table[to]++;\n    }\n\n    for (int i = 0; i < num; i++) {\n        if (table[i] == 0) {\n            Q.push(i);\n        }\n    }\n\n    while (!Q.empty()) {\n        tmp = Q.front();\n        Q.pop();\n        printf(\"%d\\n\", tmp);\n        for (int i = 0; i < V[tmp].size(); i++) {\n            table[V[tmp][i]]--;\n            if (table[V[tmp][i]] == 0) {\n                Q.push(V[tmp][i]);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\t//for(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\n\t\t\tfor(i=0;i<order.size();i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t//}\n\t\tFOR(u,g)printf(\"%d\\n\",u->first); //孤立した頂点が存在するデータがあるので注意\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nclass Edge{\npublic:\n  int from, to, rev;\n  Int cost, lim;\n  Edge(int from, int to, Int cost, int lim = -1, Int rev = -1):\n    from(from),to(to),cost(cost),lim(lim),rev(rev){}\n};\n\n\nclass Graph{\npublic:\n  int n;\n  int m;\n  vector<vector<Edge>> edge;\n  Graph(int n = 0):n(n),m(0){\n    edge = vector<vector<Edge>>(n);\n  }\n  void add_edge(int from, int to, int cost = 1, int lim = -1)\n  {\n    if(lim == -1){\n      edge[from].push_back(Edge(from, to, cost));\n      return;\n    }\n    edge[from].push_back(Edge(from, to, cost, lim, edge[to].size()));\n    edge[to].push_back(Edge(to, from, -cost, 0, edge[from].size() - 1));\n  }\n};\n\nGraph g;\nvector<int> topo;\nvector<int> come(10800, 0);\nvoid dfs(int x){\n  if(come[x])return;\n  come[x] = true;\n  for(auto e: g.edge[x]){\n    dfs(e.to);\n  }\n  topo.push_back(x);\n}\nint n, m, u, v;\nint main(){\n  cin >> n >> m;\n  g = Graph(n);\n  for(int i = 0;i < m;i++){\n    cin >> u >> v;\n    g.add_edge(v, u, 1);\n  }\n  for(int i = 0;i < n;i++){\n    dfs(i);\n  }\n  for(int i = 0;i < n;i++)cout << topo[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (dfs) ------ //\nbool tsort(Graph &g, vector<int> &ord) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    vector<int> color(n, YET);\n    static const function<bool(int)> dfs = [&](int v) {\n        color[v] = VISITED;\n        for (Edge &e : g[v]) {\n            if (color[e.dst] == DONE) continue;\n            if (color[e.dst] == VISITED) return false;\n            if (!dfs(e.dst)) return false;\n        }\n        color[v] = DONE; ord.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i) if (color[i] == YET && !dfs(i)) return false;\n    reverse(ord.begin(), ord.end());\n    return true;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord;\n    if (tsort(g, ord)) {\n        for (int i = 0; i < V; i++) cout << ord[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    if(V == 2){\n        cout << 1 << endl << 0 << endl;\n        return 0\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <queue>\n\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <functional>\n\n#include <list>\n\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define INF 1<<29\n#define ALEN(ARR) (sizeof(ARR) / sizeof((ARR)[0]))\n#define MP make_pair\n#define mp make_pair\n#define pb push_back\n#define PB push_back\n#define _DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define _DDEBUG(x,y) cout<<#x<<\": \"<<x<<\", \"<<#y<<\": \"<<y<<endl\n#define ll long long\n#define ull unsigned long long\n#define MOD 1000000007\n\n// topological sort p345\n// ??????????????°??£?????????\n// bfs \n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nvector<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n\tV[u] = true;\n\tfor(auto &v : G[u]) {\n\t\tif( !V[v] ) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\tout.push_back(u);\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.precision(16);\n\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tREP(i, N) {\n\t\tV[i] = false;\n\t}\n\n\tREP(i, M) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\tREP(i, N) {\n\t\tif( !V[i] ) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\n#if DEBUG\n\tcout << \"** RESULT **\" << endl; // debug\n#endif\n\n\treverse(out.begin(), out.end());\n\tREP(i, N) {\n\t\tcout << out[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v, e;\nbool edge[10010][10010];\nbool visited[10010];\nstack<int> st;\n\nvoid dfs(int now){\n    visited[now]=true;\n    for(int i=0; i<v; i++){\n        if(edge[now][i] && !visited[i]){\n            dfs(i);\n        }\n    }\n    st.push(now);\n    return ;\n}\n\nint main(void){\n    cin >> v >> e;\n    for(int i=0; i<v; i++){\n        visited[i]=false;\n        for(int j=0; j<v; j++){\n            edge[i][j]=false;\n        }\n    }\n    \n    \n    for(int i=0; i<e; i++){\n        int s, t;\n        cin >> s >> t;\n        edge[s][t]=true;\n    }\n    \n    for(int i=0; i<v; i++){\n        if(!visited[i]){\n            dfs(i);\n        }\n    }\n    while(!st.empty()){\n        cout << st.top() << \"\\n\";\n        st.pop();\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V = 10000;\n\nint V, E;\nvi G[MAX_V];\nint deg[MAX_V];\nbool used[MAX_V];\n\nvoid solve() {\n   queue<int> que;\n\n   for (int i = 0; i < V; i++) {\n       if (deg[i] == 0) que.push(i);\n   }\n\n   while (!que.empty()) {\n       int v = que.front(); que.pop();\n       cout << v << endl;\n\n       for (auto to : G[v]) {\n           deg[to]--;\n\n           if (deg[to] == 0) que.push(to);\n       }\n   }\n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n\n        G[s].push_back(t);\n    }\n\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            deg[to]++;\n        }\n    }\n\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct StronglyConnectedComponentDecomposition {\n    vector<vector<int>> graph, igraph, sccbucket;\n    vector<int> vs, sccid;\n    int nscc;\n    void dfs(int v) {\n        sccid[v] = 0;\n        for (int u : graph[v]) {\n            if (sccid[u] == -1) dfs(u);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k) {\n        sccid[v] = k;\n        for (int u : igraph[v]) {\n            if (sccid[u] == -1) rdfs(u, k);\n        }\n    }\n    void sccd() {\n        sccid.assign(graph.size(), -1);\n        for (int v = 0; v < (int)graph.size(); ++v) {\n            if (sccid[v] == -1) dfs(v);\n        }\n        sccid.assign(graph.size(), -1);\n        nscc = 0;\n        while (!vs.empty()) {\n            int v = vs.back(); vs.pop_back();\n            if (sccid[v] == -1) rdfs(v, nscc++);\n        }\n        sccbucket.resize(nscc);\n        for (int v = 0; v < (int)graph.size(); ++v) {\n            sccbucket[sccid[v]].push_back(v);\n        }\n    }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    StronglyConnectedComponentDecomposition sccd;\n    sccd.graph.resize(V);\n    sccd.igraph.resize(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        sccd.graph[s].push_back(t);\n        sccd.igraph[t].push_back(s);\n    }\n    sccd.sccd();\n\n    for (auto& b : sccd.sccbucket) {\n        for (int v : b) cout << v << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100];\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> topological_sort(const vector<vector<int>> &G) {\n  const int N = G.size();\n  vector<int> indeg(N, 0);\n  for(auto &&vs : G) {\n    for(int v : vs) {\n      indeg[v]++;\n    }\n  }\n  queue<int> Q;\n  for(int i = 0; i < N; ++i) {\n    if(indeg[i] == 0) Q.push(i);\n  }\n  vector<int> ret;\n  while(!Q.empty()) {\n    int v = Q.front(); Q.pop();\n    ret.push_back(v);\n    for(int u : G[v]) {\n      indeg[u]--;\n      if(indeg[u] == 0) Q.push(u);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  int V, E; cin >> V >> E;\n  vector<vector<int>> G(V);\n  for(int i = 0; i < V; ++i) {\n    int s, t; cin >> s >> t;\n    G[s].push_back(t);\n  }\n  for(auto &&v : topological_sort(G)) {\n    cout << v << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nint n, m;\n\nvector<vector<int>> g; // 各頂点から辺で結ばれる頂点の集合を記録\nvector<int> indeg; // 各頂点の入次数を記録\nvector<bool> sorted; // 各頂点についてソート済みか否かを判定\nvector<int> t; // ソート結果を記録\n\nvoid bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    while (not q.empty()) {\n        int cur = q.front();\n        q.pop();\n        t.push_back(cur);\n        sorted[cur] = true;\n        for (int adj : g[cur]) {\n            indeg[adj]--;\n            if (sorted[adj] == false && indeg[adj] == 0) {\n                q.push(adj);\n            }\n        }\n    }\n}\n\nvoid topological_sort() {\n    rep(i, n) {\n        if (sorted[i] == false && indeg[i] == 0) {\n            bfs(i);\n        }\n    }\n    rep(i, n) {\n        cout << t[i] << endl;\n    }\n}\n\nint main() {\n    cin >> n;\n    cin >> m;\n    g.resize(n);\n    indeg.resize(n);\n    sorted.resize(n, false);\n    rep(i, m) {\n        int s, t;\n        cin >> s;\n        cin >> t;\n        g[s].push_back(t); // 頂点sは頂点tに対して辺をもつ\n        indeg[t]++; // tの入次数を1増やす\n    }\n    topological_sort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rept(i,n) for(int (i)=0;(i)<=(int)(n);(i)++)\n#define reps(i,s,n) for(int (i)=(s);(i)<(int)(n);(i)++)\n#define repst(i,s,n) for(int (i)=(s);(i)<=(int)(n);(i)++)\n#define repr(i,n) for(int (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln \"\\n\"\n#define show(x) cout << #x << \" = \" << x ln\n#define dbg(x) cout<<#x\"=\"<<x ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ??????????????????????????????????????????( ^??^)??????????????????????????????????????????\n\n// ????????°????????°?????\\?¬???°\nint v, e, in[100000];\n// ??\\?¬???°0???????????????????????\\????????????\nqueue<int> S;\n// ????????£??\\?????????\nmat V(100000);\n// ??????\nvi ans;\n\nint main() {\n\tcin >> v >> e;\n\trep(i,e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tV[a].pb(b);\n\t\tin[b]++;\n\t}\n\t\n\t// ??\\?¬???°0??????????????????\n\trep(i,v) if (in[i]==0) S.push(i);\n\twhile (!S.empty()) {\n\t\tint u = S.front(); S.pop();\n\t\tans.pb(u);\n\t\t// u?????????????¢???????????????§??°?????????????¶?????????£??\\????????¨??????????????\\?¬???°???1?????????\n\t\trep(i,V[u].size()) {\n\t\t\tin[i]--;\n\t\t\t// ????????????????????£?????\\?¬???°???0????????£?????????????????°S?????????\n\t\t\tif (in[i]==0) S.push(i);\n\t\t}\n\t}\n\trep(i,v) cout << ans[i] << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector<vector<int> > G;\nvector<int> INDEG;\nvector<int> COLOR;\n\nvoid topo() {\n  for (int i = 0; i < G.size(); i++) {\n    for (int j = 0; j < G[i].size(); j++) {\n      INDEG[G[i][j]]++;\n    }\n  }\n\n  int u;\n  queue<int> Q;\n\n  while (true) {\n    u = -1;\n\n    for (int i = 0; i < INDEG.size(); i++) {\n      if (INDEG[i] == 0 && COLOR[i] == -1) {\n        u = i;\n        break;\n      }\n    }\n\n    if (u == -1) break;\n    Q.push(u);\n    COLOR[u] = 1;\n\n    for (int i = 0; i < G[u].size(); i++) {\n      INDEG[G[u][i]]--;\n    }\n  }\n\n  while (!Q.empty()) {\n    cout << Q.front() << endl;\n    Q.pop();\n  }\n}\n    \nint main() {\n  int v, e; cin >> v >> e;\n\n  G.resize(v, vector<int>());\n  INDEG.resize(v, 0);\n  COLOR.resize(v, -1);\n\n  for (int i = 0; i < e; i++) {\n    int s, t; cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  topo();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\n\nusing namespace std;\n\n\nstatic const int MAX = 10000;\n\n\nvector<int> graph[MAX];\nvector<int> sorted;\nvector<int> in_edges(MAX, 0);\nvector<bool> discovered(MAX, false);\nqueue<int> visiting;\nint V, E;\n\n\nvoid bfs(int start)\n{\n    visiting.push(start);\n    discovered[start] = true;\n\n    while (!visiting.empty()) {\n        int now = visiting.front();\n        visiting.pop();\n\n        sorted.push_back(now);\n\n        for (vector<int>::iterator it = graph[now].begin(); it != graph[now].end(); ++it) {\n            in_edges[*it]--;\n            if (!discovered[*it] && in_edges[*it] == 0) {\n                visiting.push(*it);\n                discovered[*it] = true;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    cin >> V >> E;\n\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        in_edges[t]++;\n    }\n\n    for (int i = 0; i < V; i++)\n        if (!discovered[i] && in_edges[i] == 0)\n            bfs(i);\n\n    for (vector<int>::iterator it = sorted.begin(); it != sorted.end(); ++it) {\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 隣接リストで表現された有向グラフ\n\n// Weightをdoubleにすると、桁数が多いとき1e9のように表示されることに注意\n\n#include<algorithm>\n#include<functional>\n#include<memory>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<vector>\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 比較演算子\nbool operator==(const Edge& lhs, const Edge& rhs) {return lhs.from==rhs.from && lhs.to==rhs.to && lhs.weight==rhs.weight;}\n\n// 隣接行列 O(|V|^2 + |E|)\nstd::vector<std::vector<Vertex>> adjacent_matrix(const Graph& G) {\n  std::vector<std::vector<Vertex>> A(G.size(), std::vector<Vertex>(G.size(), 0));\n  for(const auto& list: G) for(const auto& e: list) ++A[e.from][e.to];\n  return A;\n}\n\n// 逆辺 O(1)\nEdge reverse(const Edge& e) {\n  return {e.to, e.from, e.weight};\n}\n\n// 逆辺からなるグラフ O(|V| + |E|)\nGraph reverse(const Graph& G) {\n  Graph H(G.size());\n  for(auto& list: G) for(auto& e: list) H[e.to].push_back({e.to, e.from, e.weight});\n  return H;\n}\n\n// 帰りがけ順 O(|V| + |E|)\nstd::vector<Vertex> postorder(const Graph& G) {\n  std::vector<bool> used(G.size());\n  std::vector<Vertex> order;\n  std::function<void(Vertex)> dfs = [&](Vertex v) {\n    used[v] = true;\n    for(const auto& e: G[v]) if(!used[e.to]) dfs(e.to);\n    order.emplace_back(v);\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!used[v]) dfs(v);\n  return order;\n}\n\n// トポロジカルソート O(|V| + |E|)\n//   逆辺にしてから帰りがけ順を求める\n//   ※逆辺にせずに帰りがけ順を求めて, その結果を reverse しても良い O(|V| log |V| + |E|)\nstd::vector<Vertex> topological_order(const Graph& G) {\n  return postorder(reverse(G));\n}\n// トポロジカルソート O(|V| + |E|)\n//   サイクルが存在する場合は空 vector を返す\nstd::vector<Vertex> Kahn(const Graph& G) {\n  std::vector<Vertex> order;\n  std::vector<int> indeg(G.size());\n  for(const auto& E: G) for(const auto& e: E) ++indeg[e.to];\n  std::queue<Vertex> q;\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] == 0) q.emplace(v);\n  while(!q.empty()) {\n    for(const auto& e: G[q.front()]) if(--indeg[e.to] == 0) q.emplace(e.to);\n    order.emplace_back(q.front());\n    q.pop();\n  }\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] != 0) return {};\n  return order;\n}\n\n// 連結成分ごとに分解 O(|V|)\n// ※無向グラフのみ\nstd::vector<std::vector<Vertex>> connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> cc;\n  std::vector<bool> used(G.size());\n  std::function<void(int)> dfs = [&](int v) {\n    cc.back().push_back(v);\n    used[v] = true;\n    for(const auto& e: G[v]) if(!used[e.to]) dfs(e.to);\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!used[v]) {\n    cc.push_back(std::vector<Vertex>());\n    dfs(v);\n  }\n  return cc;\n}\n\n// すべての連結成分に対して関節点と橋を列挙 O(|V| + |E|)\n// ※無向グラフのみ\n// ※articulationには同じ頂点が複数個入る可能性があり、その個数は「分割後の成分数 - 1」個\nvoid Tarjan(const Graph& G, std::vector<Vertex>& articulation, std::vector<Edge>& bridge) {\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  std::function<void(Vertex,Vertex)> dfs = [&](Vertex cur, Vertex pre) {\n    num[cur] = low[cur] = ++timer;\n    for(const auto& e: G[cur]) if(e.to != pre) {\n      if(num[e.to]) {\n        low[cur] = std::min(low[cur], num[e.to]);\n      } else {\n        dfs(e.to, cur);\n        low[cur] = std::min(low[cur], low[e.to]);\n        if(cur == pre) if(num[cur]+1 < num[e.to]) articulation.push_back(cur);\n        if(cur != pre) if(num[cur] <= low[e.to])  articulation.push_back(cur);\n        if(num[cur] < low[e.to])                  bridge.push_back(e);\n      }\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v, v);\n}\n\n// 二重辺連結成分分解 O(|V| + |E|)\n// ※無向グラフのみ\n// ※戻り値は選択\nauto bridge(const Graph& G) {\n  std::stack<Vertex> roots, S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size());\n  std::vector<Edge> bridge;\n  std::vector<std::vector<Vertex>> bcc;\n  int timer = 0;\n  // Tarjan\n  std::function<void(const Edge&)> dfs = [&](const Edge& cur) {\n    num[cur.to] = ++timer;\n    S.push(cur.to); inS[cur.to] = true;\n    roots.push(cur.to);\n    for(const auto& nex: G[cur.to]) {\n      if(!num[nex.to]) dfs(nex);\n      else if(nex.to != cur.from && inS[nex.to]) while(num[roots.top()] > num[nex.to]) roots.pop();\n    }\n    if(roots.top() == cur.to) {\n      bridge.push_back(cur);\n      bcc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto v = S.top(); S.pop(); inS[v] = false;\n        bcc.back().push_back(v);\n        if(v == cur.to) break;\n      }\n      roots.pop();\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) {\n    dfs({v, v});\n    bridge.pop_back();\n  }\n//   return bridge;\n  return bcc;\n}\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\n// 単一始点最短経路 O(|V| |E|)\n// ※重みを-1倍したグラフに適用すると元のグラフの最長経路を得られる\nstd::vector<Weight> BellmanFord(const Graph& G, Vertex s, Weight INF = 1e18) {\n  std::vector<Weight> d(G.size(), INF);\n  d[s] = 0;\n  for(auto k = 0; k < G.size(); ++k) for(Vertex v = 0; v < G.size(); ++v) for(const auto& e: G[v]) {\n    if(d[e.to] > d[e.from] + e.weight) {\n      d[e.to] = d[e.from] + e.weight;\n      if(k == G.size()-1) d[e.to] = -INF;\n    }\n  }\n  return d;\n}\n\n// 単一始点最短経路 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nstd::vector<Weight> Dijkstra(const Graph& G, Vertex s) {\n  std::vector<Weight> d(G.size(), -1);\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge,Edge)>> q([](Edge lhs, Edge rhs){return lhs.weight > rhs.weight;});\n  q.push({s, s, 0});\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(d[cur.to] != -1) continue;\n    d[cur.to] = cur.weight;\n    for(const auto& nex: G[cur.to]) if(d[nex.to] == -1) q.push({cur.to, nex.to, cur.weight + nex.weight});\n  }\n  return d;\n}\n\n// 単一始点最短経路に含まれ得る辺の列挙 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nGraph shortest_DAG(const Graph& G, Vertex s) {\n  Graph H(G.size());\n  auto d = Dijkstra(G, s);\n  for(const auto& E: G) for(const auto& e: E) if(d[e.from] + e.weight == d[e.to]) H[e.from].emplace_back(e);\n  return H;\n}\n\n// 単一始点最短経路の個数 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nstd::vector<int> shortest_path_number(const Graph& G, Vertex s) {\n  std::vector<int> dp(G.size());\n  dp[s] = 1;\n  auto d = Dijkstra(G, s);\n  for(const auto& E: G) for(const auto& e: E) if(d[e.from] + e.weight == d[e.to]) dp[e.to] += dp[e.from];\n  return dp;\n}\n\n// 2頂点間最短経路 O(|E| + |V|^3)\n// ※INF+INFがオバーフローを起こさないよう注意\nstd::vector<std::vector<Weight>> WarshallFloyd(const Graph& G, Weight INF = 1e9) {\n  std::vector<std::vector<Weight>> d(G.size(), std::vector<Weight>(G.size(), INF));\n  for(Vertex i = 0; i < G.size(); ++i) d[i][i] = 0;\n  for(const auto& list: G) for(const auto& e: list) d[e.from][e.to] = std::min(d[e.from][e.to], e.weight);\n  for(Vertex i = 0; i < G.size(); ++i) for(Vertex j = 0; j < G.size(); ++j) for(Vertex k = 0; k < G.size(); ++k) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n  return d;\n}\n\n// すべての u-v パスに対して u の直後に訪れる頂点の最小値/最大値 O(|V| log |V| + |V| |E|)\n// ※有向グラフの迂回路判定に利用(ARC092F)\nstd::vector<std::vector<std::vector<Vertex>>> follower(Graph G) {\n  for(auto& E: G) sort(begin(E), end(E), [](const auto& l, const auto& r) {return l.to < r.to;});\n  std::vector<std::vector<std::vector<Vertex>>> ok(2, std::vector<std::vector<Vertex>>(G.size(), std::vector<Vertex>(G.size(), -1)));\n  std::function<void(int, Vertex, Vertex)> dfs = [&](auto b, auto r, auto v) {\n    for(const auto& e: G[v]) if(ok[b][r][e.to] == -1) {\n      ok[b][r][e.to] = ok[b][r][e.from];\n      dfs(b, r, e.to);\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) for(auto b: {0, 1}) ok[b][v][v] = v;\n  for(Vertex r = 0; r < G.size(); ++r) for(auto i = 0; i < G[r].size(); ++i) for(auto b: {0, 1}) {\n    auto x = (b==0) ? i : G[r].size()-1-i;\n    auto v = G[r][x].to;\n    if(ok[b][r][v] == -1) {\n      ok[b][r][v] = x;\n      dfs(b, r, v);\n    }\n  }\n  return ok;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n//   int V, E;\n//   cin >> V >> E;\n//   Graph G(V);\n//   for(int i = 0; i < E; ++i) {\n//     int s, t;\n//     cin >> s >> t;\n//     G[s].push_back({s, t, 0});\n//     G[t].push_back({t, s, 0});\n//   }\n  // GRL_3_A\n  // GRL_3_B\n//   vector<int> cut_vertex;\n//   vector<Edge> bridge;\n//   for(auto S: connected_component(G)) lowlink(G, S.front(), S.front(), cut_vertex, bridge);\n//   // Articulation vertex\n//   set<int> S(begin(cut_vertex), end(cut_vertex));\n//   for(auto v: S) cout << v << endl;\n//   // Bridge\n//   for(auto& e: bridge) if(e.from > e.to) swap(e.from, e.to);\n//   set<Edge, function<bool(Edge,Edge)>> S(begin(bridge), end(bridge), [](Edge lhs, Edge rhs){\n//     if(lhs.from != rhs.from) return lhs.from < rhs.from;\n//     if(lhs.to != rhs.to) return lhs.to < rhs.to;\n//     return lhs.weight < rhs.weight;\n//   });\n//   for(auto e: S) cout << e.from << \" \" << e.to << endl;\n  // GRL_3_C\n//   auto scc = strongly_connected_component(G);\n//   vector<int> group(G.size());\n//   for(int i = 0; i < scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n//   int Q;\n//   cin >> Q;\n//   for(int i = 0; i < Q; ++i) {\n//     int u, v;\n//     cin >> u >> v;\n//     cout << (group[u] == group[v] ? 1 : 0) << endl;\n//   }\n\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back({s, t, 0});\n  }\n//   GRL_4_B\n  for(auto v: Kahn(G)) cout << v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nvector<unordered_set<int>> redge;\n// bool redge[10000][10000];\n\n// bool memo[10000];\nunordered_set<int> memo;\nvoid topological_sort(int u) {\n//   if(memo[u]) return;\n//   memo[u] = true;\n//   for(int v = 0; v < V; ++v) if(redge[u][v]) topological_sort(v);\n  if(memo.count(u)) return;\n  memo.insert(u);\n  for(int v: redge[u]) topological_sort(v);\n  cout << u << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  redge.resize(V);\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    redge[v].insert(u);\n//     redge[v][u] = true;\n  }\n  for(int i = 0; i < V; ++i) topological_sort(i);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stack>\n#include<vector>\n#define VMAX 10000\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\nusing namespace std;\n\nint n;\nvector<int> adj[VMAX];\nstack<int> ts;\nint color[VMAX];\n\nvoid dfs(int u) {\n    color[u] = GRAY;\n\n    for (int j=0; j<adj[u].size(); j++) {\n        int v = adj[u][j];\n        if (color[v]!=BLACK) {\n            dfs(v);\n        }\n    }\n\n    color[u] = BLACK;\n    ts.push(u);\n}\n\nvoid topologicalSort() {\n    int u;\n\n    for (int j=0; j<n; j++) {\n        if (color[j]!=BLACK) {\n            dfs(j);\n        }\n    }\n\n    while(!ts.empty()) {\n        int n = ts.top();\n        ts.pop();\n        printf(\"%d\\n\", n);\n    }\n\n}\n\nint main() {\n    int s, t, E;\n\n    scanf(\"%d %d\", &n, &E);\n\n    for (int i=0; i<n; i++) {\n        color[i] = WHITE;\n    }\n\n    for (int i=0; i<E; i++) {\n        scanf(\"%d %d\", &s, &t);\n        adj[s].push_back(t);\n    }\n\n    topologicalSort();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(int i = 0; i < n; ++i) for(auto &e : g[i]) in[e.dst]++;\n    for(int i = 0; i < n; ++i){\n        if(in[i] || vis[i]) continue;\n        vis[i] = true; res.push_back(i);\n        queue<int> q; q.push(i);\n        while(!q.empty()) {\n            int p = q.front(); q.pop();\n            for(auto &e : g[p]){\n                int np = e.dst;\n                in[np]--;\n                if(in[np] || vis[np]) continue;\n                vis[np] = true;\n                q.push(np);\n                res.push_back(np);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    assert((int)ord.size() == n);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nconst int V_MAX = 1000;\n\nint main() {\n\tint v, e;\n\tint table[V_MAX] = { 0 };\n\tvector<int> edge[V_MAX];\n\tvector<int> ans;\n\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tedge[s].push_back(t);\n\t\ttable[t]++;\n\t}\n\t\n\tfor (int i = 0; i < v; i++) {\n\t\tif (table[i] == 0) {\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < ans.size();i++) {\n\t\tvector<int> e = edge[ans[i]];\n\t\tfor (int j = 0; j < e.size(); j++) {\n\t\t\tif (--(table[e[j]]) == 0) {\n\t\t\t\tans.push_back(e[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (vector<int>::iterator it = ans.begin(); it != ans.end(); it++) {\n\t\tprintf(\"%d\\n\", *it);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> grh(n);\n  vector<int> cnt(n);\n  for (int i = 0; i < m; i++) {\n    int s, t;\n    cin >> s >> t;\n    grh[s].push_back(t);\n    cnt[t]++;\n  }\n  stack<int> stk;\n  for (int i = 0; i < n; i++) {\n    if (cnt[i] == 0) {\n      stk.push(i);\n    }\n  }\n  while (!stk.empty()) {\n    int crr = stk.top();\n    stk.pop();\n    printf(\"%d\\n\", crr);\n    for(auto nxt : grh[crr]) {\n      cnt[nxt]--;\n      if (cnt[nxt] == 0) {\n        stk.push(nxt);\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\nstatic const int WHITE = 0;\nstatic const int BLACK  =2;\n\nvector<int> G[MAX];                     //隣接リスト G[i]にはi番目の頂点から向かう頂点が格納されている\nint colors[MAX] = {WHITE};              //色\nint inDegrees[MAX] = {0};               //入次数\nlist<int> orders;                        //頂点の順番格納\n\nvoid bfs(int v);\n\n//トポロジカルソート\nvoid topologicalSort(int vNumber){\n\n    //色と入次数の初期化\n    for(int i=0;i<vNumber;i++){\n        colors[i] = WHITE;\n        inDegrees[i] = 0;\n    }\n\n    //inDegreeをそれぞれ格納\n    for(int i=0;i<vNumber;i++){\n        for(int j=0;j<G[i].size();j++){\n            int v = G[i][j];\n            inDegrees[v]++;\n        }\n    }\n\n\n    //各頂点から行う\n    for(int i=0;i<vNumber;i++){\n\n        //すでに順番が決まっていない\n        //かつ、入次数がゼロの場合\n        if(colors[i] != BLACK  &&  inDegrees[i]  == 0){\n            bfs(i);\n        }\n    }\n\n}\n\n//幅優先探索\nvoid bfs(int v){\n\n    //順番確定\n    colors[v] = BLACK;\n\n    //頂点vを含む集合の更新\n    queue<int> Q;\n    Q.push(v);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        orders.push_back(u);\n\n\n        for(int i=0;i<G[u].size();i++){\n            //辺の削除\n            int to = G[u][i];\n            inDegrees[to]--;\n\n            //uからの向かう頂点が浮いていた場合\n            if(inDegrees[to] == 0 && colors[to] !=BLACK){\n                colors[to] = BLACK;\n                Q.push(to);\n            }\n        }\n    }\n\n}\n\nvoid print(){\n    for(auto it=orders.begin(); it!= orders.end();it++){\n        printf(\"%d\\n\",*it);\n    }\n}\n\nint main() {\n\n    int V; scanf(\"%d\", &V);\n    int E; scanf(\"%d\", &E);\n\n    int s, t;\n    for(int i=0;i<E;i++){\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n    }\n\n    topologicalSort(V);\n\n    print();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\n\nclass TopologicalSort {\npublic:\n  TopologicalSort(int V): V(V), G(V, vector<int>(0)), indeg(V, 0) {}\n\n  void addEdge(int s, int t) {\n    G[s].push_back(t);\n    indeg.at(t)++;\n  }\n\n  vector<int> getSorted() {\n    return vs;\n  }\n\n  bool sort() {\n    queue<int> Q;\n    vector<bool> done(V, false);\n\n    for (int i=0; i<V; i++) {\n      if (indeg.at(i) == 0) {\n        Q.push(i);\n        while (Q.size()) {\n          int v = Q.front();Q.pop();\n          if (done.at(v)) continue;\n          done.at(v) = true;\n          vs.push_back(v);\n          for (auto u: G[v]) {\n            if (--indeg.at(u) == 0) Q.push(u);\n          }\n        }\n      }\n    }\n\n    return vs.size() == V;\n  }\n\nprivate:\n  int V;\n  vector<vector<int> > G;\n  vector<int> indeg;\n  vector<int> vs;\n};\n\n\n#define MAX_E 100001\nint V, E;\nint S[MAX_E], T[MAX_E];\n\n\nvoid input() {\n  int s, t;\n  cin >> V >> E;\n  for (int i=0; i<E; i++) {\n    cin >> S[i] >> T[i];\n  }\n}\n\nvoid solve() {\n  TopologicalSort ts(V);\n  for (int i=0; i<E; i++) ts.addEdge(S[i], T[i]);\n  ts.sort();\n  for (auto v: ts.getSorted()) cout << v << endl;\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int MAX=10002;\nint V,E;\nint indeg[MAX]={0},inq[MAX]={0};\nvector<int> out,G[MAX];\nvoid bfs(int s){\n\tqueue<int> Q;\n\tQ.push(s);\n\tinq[s]=1;\n\twhile (!Q.empty()){\n\t\tint u=Q.front();\n\t\tout.push_back(u);\n\t\tQ.pop();\n\t\tfor(int i=0;i<G[u].size();i++){\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(!indeg[v] && !inq[v]){\n\t\t\t\tQ.push(v);\n\t\t\t\tinq[v]=1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid topologicalSort(){\n\tfor(int i=0;i<V;i++){\n\t\tif(!indeg[i]&&!inq[i])\n\t\t\tbfs(i);\n\t}\n}\nint main(){\n\tcin>>V>>E;\n\tint s,t;\n\tfor(int i=0;i<E;i++){\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\ttopologicalSort();\n\tfor(int i=0;i<V;i++){\n\t\tcout<<out[i]<<endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int MAX = 100000;\nconst int INF = 1<<29;\nvector<int> G[MAX];\nlist<int> out;\nint n;\nbool V[MAX];\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    r(i,G[u].size()){\n      int v=G[u][i];\n      indeg[v]--;\n      if(!indeg[v]&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid Tsort(){\n  r(i,n)indeg[i]=0;\n  r(u,n)r(i,G[u].size())indeg[G[u][i]]++;\n  r(u,n)if(!indeg[u]&&!V[u])bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    cout<<*it<<endl;\n}\nint main(){\n  int s,t,m;\n  cin>>n>>m;\n  r(i,n){\n    V[i]=false;\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  Tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// VI tsort(VVI g) {\n//   int n = g.size();\n//   vector<bool> used(n, false);\n//   vector<int> ans;\n//\n//   function<void(int)> dfs = [&](int u) {\n//     if(used[u]) return;\n//     used[u] = true;\n//     for(auto& i: g[u]) dfs(i);\n//     ans.push_back(u);\n//   };\n//\n//   for(int i=0; i<n; ++i) dfs(i);\n//   reverse(ans.begin(), ans.end());\n//   return ans;\n// }\n\nVI tsort(VVI g) {\n  const int n = g.size();\n  VI h(n, 0);\n  REP(i, n) for(int j: g[i]) h[j]++;\n\n  stack<int> st;\n  REP(i, n) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  return ans;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  VVI g(n, VI(0));\n  REP(i, m) {\n    int a, b;\n    cin >> a >> b; a--, b--;\n    g[a].PB(b);\n    g[b].PB(a);\n  }\n\n  VI ans = tsort(g);\n  for(int i: ans) cout << i+1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <cmath>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\ntypedef vector<vector<int>> Graph;\nconst int WHITE = 0;\nconst int GRAY  = 1;\nconst int BLACK = 2;\n\nvoid dfs(Graph &G, int v, vector<int> &state, vector<int> &ord)\n{\n    // cerr << \"IN : \" << v << endl;\n    state[v] = GRAY;\n\n    for (auto u : G[v]) {\n        if (state[u] != WHITE) continue;\n        dfs(G, u, state, ord);\n    }\n\n    state[v] = BLACK;\n    ord.push_back(v);\n    // cerr << \"OUT : \" << v << endl;\n}\n\nvector<int> tsort(Graph &G)\n{\n    vector<int> ord, state(G.size(), WHITE);\n    \n    for (int i=0; i<G.size(); i++) {\n        if (state[i] == WHITE) {\n            dfs(G, i, state, ord);\n        }\n    }\n\n    reverse(ord.begin(), ord.end());\n    return ord;\n}\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph G(V);\n    rep(i, E) {\n        int A, B;\n        cin >> A >> B;\n        G[A].push_back(B);\n    }\n\n    vector<int> ans = tsort(G);\n    for (auto i : ans) cout << i << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  //if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100] = {};\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define Graph vector< vector<int> >\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\n\nint N, M;\nGraph G(100010);\nvector<int> indeg(100010, 0), out;\nvector<bool> seen(100010, false);\n\n\nvoid dfs(int u){\n    queue<int> que;\n    que.push(u);\n\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        seen[v] = true;\n        out.push_back(v);\n\n        rep(i, G[v].size()){\n            int v2 = G[v][i];\n            // if(seen[v2]) continue;\n            indeg[v2]--;\n            if(indeg[v2] == 0) que.push(v2);\n        }\n\n    }\n}\n\nint main(){\n    cin >> N >> M;\n\n    rep(i, M){\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    rep(u, N){\n        if(!seen[u] && indeg[u] == 0) dfs(u);\n    }\n\n    rep(i, N){\n        cout << out[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\nbool used[10000];\nvector<int> vs;\nvector<int> ans;\nvector<int> es[10000];\nvector<int> res[10000];\n\nvoid add_edge(int u, int v) {\n    es[u].push_back(v);\n    res[v].push_back(u);\n}\n\nvoid dfs1(int v) {\n    used[v] = true;\n    for (int i=0; i<es[v].size(); i++) {\n        int u = es[v][i];\n        if (!used[u]) dfs1(u);\n    }\n    vs.push_back(v);\n}\n\nvoid dfs2(int v) {\n    used[v] = true;\n    for (int i=0; i<res[v].size(); i++) {\n        int u = res[v][i];\n        if (!used[u]) dfs2(u);\n    }\n    ans.push_back(v);\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i=0; i<m; i++) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        add_edge(a, b);\n    }\n\n    fill(used, used+n, false);\n    for (int i=0; i<n; i++) {\n        if (!used[i]) dfs1(i);\n    }\n\n    fill(used, used+n, false);\n    for (int i=vs.size()-1; i>=0; i--) {\n        if (!used[vs[i]]) dfs2(vs[i]);\n    }\n\n    for (int i=0; i<ans.size(); i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nclass ans\n{\npublic:\n    int a,i;\n};\nint s[10001],chk[10001];\nans num[10001];\nint dfs(int n)\n{\n    if(chk[n]>0)\n        return chk[n];\n    else if(s[n]==n) return chk[n]=1;\n    else return chk[n]=dfs(s[n])+1;\n}\nbool cmp(ans a,ans b)\n{\n    return a.i>b.i;\n}\nint main()\n{\n    int v,e,x,y;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0;i<=v;i++) {s[i]=i;num[i].a=i;}\n    for(int i=0;i<e;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        s[x]=y;\n    }\n    for(int i=0;i<v;i++)\n    {\n        if(chk[i]==0)\n        dfs(i);\n    }\n    for(int i=0;i<v;i++) num[i].i=chk[i];\n    sort(num,num+v,cmp);\n    for(int i=0;i<v;i++) printf(\"%d\\n\",num[i].a);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\n// hasparent\nset<int> hp;\n// children,parent\nmap<int,set<int>> c;\nmap<int,set<int>> p;\n// topsort seq\nvector<int> t;\n\nint main(){\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    int a,b;cin>>a>>b;\n    c[a].insert(b);\n    p[b].insert(a);\n  }\n  for(int i=0;i<v;i++){\n    if(p[i].empty())hp.insert(i);\n  }\n  while(hp.size()){\n    int o=*hp.begin();\n    t.push_back(o);\n    hp.erase(hp.begin());\n    for(auto h:c[o]){\n      p[h].erase(o);\n      if(p[h].empty())hp.insert(h);\n    }\n  }\n  copy(t.begin(),t.end(),ostream_iterator<int>(cout,\"\\n\"));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> tsort(const Graph &g){\n    int n = g.size();\n    vector<int> ord(n), indeg(n);\n    for(auto &es : g) for(auto &e : es) indeg[e.dst]++;\n    queue<int> q;\n    for(int i = 0; i < n; ++i) if (indeg[i] == 0) q.push(i);\n    int k = 0;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        ord[k++] = v;\n        for(auto &e : g[v]) {\n            indeg[e.dst]--;\n            if(indeg[e.dst] == 0) q.push(e.dst);\n        }\n    }\n    return ord;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rept(i,n) for(int (i)=0;(i)<=(int)(n);(i)++)\n#define reps(i,s,n) for(int (i)=(s);(i)<(int)(n);(i)++)\n#define repst(i,s,n) for(int (i)=(s);(i)<=(int)(n);(i)++)\n#define repr(i,n) for(int (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln \"\\n\"\n#define show(x) cout << #x << \" = \" << x ln\n#define dbg(x) cout<<#x\"=\"<<x ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ??????????????????????????????????????????( ^??^)??????????????????????????????????????????\n\n// ????????°????????°?????\\?¬???°\nint v, e, in[100000];\n// ??\\?¬???°0???????????????????????\\????????????\nqueue<int> S;\n// ????????£??\\?????????\nmat V(100000);\n// ??????\nvi ans;\n\nint main() {\n\tcin >> v >> e;\n\trep(i,e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tV[a].pb(b);\n\t\tin[b]++;\n\t}\n\t\n\t// ??\\?¬???°0??????????????????\n\trep(i,v) if (in[i]==0) S.push(i);\n\twhile (!S.empty()) {\n\t\tint u = S.front(); S.pop();\n\t\tans.pb(u);\n\t\t// u?????????????¢???????????????§??°?????????????¶?????????£??\\????????¨??????????????\\?¬???°???1?????????\n\t\teach(i,V[u]) {\n\t\t\tin[i]--;\n\t\t\t// ????????????????????£?????\\?¬???°???0????????£?????????????????°S?????????\n\t\t\tif (in[i]==0) S.push(i);\n\t\t}\n\t}\n\trep(i,v) cout << ans[i] << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\n#define MOD 1000000007\n#define SIZE 100005\n\nusing namespace std;\ntypedef pair<int,int> P;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nbool used[10005];\nvector<int> ans;\n\nvoid dfs(int v){\n    used[v]=true;\n    for(auto u:G[v]){\n        if(!used[u]) dfs(u);\n    }\n    ans.push_back(v);\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n    }\n    REP(i,V){\n        if(!used[i]) dfs(i);\n    }\n    reverse(ALL(ans));\n    REP(i,V) cout<<ans[i]<<endl;\n    \n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <queue>\n\nusing namespace std;\n\nint cnt = 0;\nint cntp = 0;\n\nqueue<int> source;\nvector<int> pre;\nvector<int> in;\n\nclass Edge{\npublic:\n  int v;\n  int w;\n  Edge(int vi,int wi):v(vi),w(wi){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    int E;\n    vector<forward_list<int>> adj_list;\n    Graph(int v,int e):V(v),E(e){\n        adj_list.resize(V);\n        pre.resize(V);\n        in.resize(V);\n        for(int i = 0; i < V;i++) {pre[i] = -1;in[i] = 0;}\n    }\n    void addEdge(int v,int w){\n        adj_list[v].push_front(w);\n    }\n};\n\nint main(){\n    int V,E,v,w;\n    scanf(\"%d %d\",&V,&E);\n    Graph G(V,E);\n    for(int i = 0; i < E;i++){\n        scanf(\"%d %d\",&v,&w);\n        G.addEdge(v,w);\n        in[w]++;\n    }\n\n    for(int i = 0; i < V;i++){\n        if(!in[i]) source.push(i);\n    }\n    while(!source.empty()){\n        int j = source.front();\n        pre[j] = 0;\n        printf(\"%d\\n\",j);\n        source.pop();\n        for(auto a = G.adj_list[j].begin();a!=G.adj_list[j].end();++a){\n            int v = *a;\n            if(pre[v] == -1){\n               if(--in[v] == 0)\n                    source.push(v);\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\n\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front();q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\nvoid tsort(){\n    for(int i=0;i<N;i++){\n        indeg[i] = 0;\n    }\n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0;u<N;u++){\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n    for(list<int>::iterator it = out.begin();it!=out.end();it++){\n        cout << *it << endl;\n    }\n}\nint main(){\n    int s,t,M;\n    cin >> N >> M;\n    for(int i=0;i<N;i++) V[i] = false;\n    for(int i=0;i<M;i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#define N 10000\nusing namespace std;\n\nlist<int> l;\nbool color[N]={false};\nvector<int> adj[N];\nint n;\n\nvoid topo(int k){\n\tfor(int i=0;i<adj[k].size();i++){\n\t\tif(!color[adj[k][i]])topo(adj[k][i]);\n\t}\n\tl.push_front(k);\n\tcolor[k]=true;\n}\n\nint main(void){\n\tint u,v;\n\tint e;\n\tcin>>n>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\t// ??£??\\???????????????\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!color[i])topo(i);\n\t}\n\tfor(list<int>::iterator it=l.begin();it!=l.end();it++)cout<<*it<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/** \n * @brief Topological Sort\n * O(v + e)\n */\n\n#define int long long\nconst int INF = 1 << 29;\nconst int N = 1e5 + 10;\n\nvector<int> g[N];\nint n, m;\nint deg[N];\nbool viisted[N];\n\n\nint32_t main(){\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++){\n    int x, y;\n    cin >> x >> y;\n    g[x].push_back(y);\n    deg[y]++;\n  }\n  queue<int> Q;\n  for (int i = 0; i < n; i++){\n    if (deg[i] == 0)\n      Q.push(i);\n  }\n  vector<int> ret;\n  while (!Q.empty()){\n    int u = Q.front();\n    Q.pop();\n    ret.push_back(u);\n    for (auto it : g[u]){\n      if (--deg[it] == 0)\n        Q.push(it);\n    }\n  }\n  // topological ordering\n  for (auto it : ret)\n    cout << it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iomanip>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\n#define first fi\n#define second se\nconst int MAX=100000;\nconst int inf=1e9;\nvi G[MAX];\nlist<int> out;\nbool V[MAX];\nint indeg[MAX];\nint v,e;\nvoid bfs(int s)\n{\n  queue<int> q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty())\n  {\n    int u=q.front();q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++)\n    {\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0 && !V[v])\n      {\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid tsort()\n{\n  for(int i=0;i<v;i++)\n  {\n    indeg[i]=0;\n  }\n  for(int u=0;u<v;u++)\n  {\n    for(int i=0;i<G[u].size();i++)\n    {\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n  for(int u=0;u<v;u++)\n  {\n    if(indeg[u]==0 && !V[u]) bfs(u);\n  }\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n  {\n    cout << *it << endl;\n  }\n}\nint main(void)\n{\n  cin >> v >> e;\n  for(int i=0;i<v;i++)\n  {\n    V[i]=false;\n  }\n  for(int i=0;i<e;i++)\n  {\n    int s,t;\n    cin >> s>> t;\n    G[s].push_back(t);\n  }\n  tsort();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <climits>\n#include <iterator>\n#include <iomanip>\n#include <stack>\n#include <bitset>\n#include <functional>\nusing namespace std;\n//typedef std::pair<std::string,double> P;\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n//グラフの隣接リスト\nVI g[100010];\n//頂点の入次数を管理\nint h[100010];\nsigned main(void) {\n\n\t//頂点数v, 辺の数e\n\tint v, e;\n\tcin >> v >> e;\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t); //sからtに向かう辺\n\n\t\th[t]++;\n\t}\n\tstack<int> st;\n\n\tREP(i, v) if (h[i] == 0)st.push(i);\n    \n\t//ソートされた後のグラフ\n\tVI ans;\n\t\n\twhile (st.size()) {\n\t\t//stの集合から一つ取り出す\n\t\tint i = st.top(); st.pop();\n\n\t\tans.push_back(i);\n\n\t\tfor (auto& j : g[i]) {\n\t\t\t//隣接する頂点の入次数をマイナス1\n\t\t\th[j]--;\n\t\t\t//これによって入次数が0になればstに追加\n\t\t\tif (h[j] == 0)st.push(j);\n\t\t}\n\t}\n\n\tfor (auto i : ans) cout << i << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nint main(){\n\tll n,m; cin >> n >> m;\n\tvvl G(n);\n\tvl indeg(n,0);\n\trep(i,m){\n\t\tll u,v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tindeg[v]++;\n\t}\n\tqueue<ll> q;\n\trep(i,n){\n\t\tif(!indeg[i]) q.push(i);\n\t}\n\tvl ans;\n\twhile(!q.empty()){\n\t\tll u = q.front(); q.pop();\n\t\tans.push_back(u);\n\t\tfor(auto v : G[u]){\n\t\t\tindeg[v]--;\n\t\t\tif(!indeg[v]) q.push(v);\n\t\t}\n\t}\n\tfor(auto i : ans) cout << i << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[10010];\nvector<int> L;\nint temporary[10010], permanent[10010];\n\nvoid dfs(int v)\n{\n    if (temporary[v]) return;\n    if (permanent[v]) return;\n    temporary[v]=true;\n    for(auto& u: G[v]) dfs(u);\n    permanent[v]=true;\n    L.push_back(v);\n}\n\nint main()\n{\n    int V, E; cin>>V>>E;\n    for(int i=0; i<E; ++i) {\n        int s, t; cin>>s>>t;\n        G[s].push_back(t);\n    }\n\n    for(int i=0; i<V; ++i) {\n        if (permanent[i] || temporary[i]) continue;\n        dfs(i);\n    }\n\n    cout<<L.size()<<endl;\n    for(int i=V-1; i>=0; --i) cout<<L[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]) {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0;i<N;i++){\n        indeg[i] = 0;\n    }\n\n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0;u<N;u++){\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n    for(list<int>::iterator it=out.begin();it!=out.end();it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s, t, M;\n    cin >> N >> M;\n    \n    for(int i=0;i<N;i++) V[i] = false;\n    for(int i=0;i<M;i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstatic const long long FAR = (1LL << 29);\nstatic const int N = 100;\n\nint n, m;\nbool visited[N];\nint p[N];\n\nvector<int> G[N];\nvector<int> sorted;\n\nvoid bs(int i) {\n\tqueue<int> q; q.push(i);\n\tvisited[i] = true;\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tvisited[u] = true;\n\t\tsorted.push_back(u);\n\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v = G[u][i];\n\t\t\tp[v]--;\n\t\t\tif (p[v] == 0 && !visited[v]){\n\t\t\t\tq.push(v);\n\t\t\t\tvisited[v] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ts(){\n\tfor (int i = 0; i < n; ++i){\n\t\tvisited[i] = false;\n\t\tp[i] = 0;\n\t}\n\n\tfor (int u = 0; u < n; ++u) {\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tp[v]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i){\n\t\tif (p[i] == 0 && !visited[i]) bs(i);\n\t}\n\n\tfor (int i = 0; i < sorted.size(); ++i) cout << sorted[i] << endl;\n}\n\nint main() {\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\n\tts();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <list>\n#include <algorithm>\nusing namespace std;\nconst int maxx = 100010;\nconst int INF = 1 << 30;\n\nvector<int>G[maxx];\nlist<int>out;\nbool flag[maxx];\nint n;\nint indeg[maxx];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && flag[v] == 0) {\n\t\t\t\tflag[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < n; i++) {\n\t\tindeg[i] = 0;\n\t\tflag[i] = false;\n\t}\n\n\tfor (int u = 0; u < n; u++) {\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\n\tfor (int u = 0; u < n; u++) {\n\t\tif (indeg[u] == 0 && flag[u] == 0)\n\t\t\tbfs(u);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tprintf(\"%d\\n\", *it);\n}\nint main()\n{\n\tint s, t, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector<vector<int> > V;\nint vnum = 0;\nint e = 0;\nint color[10000];\nint indeg[10000];\n\n\nvoid bfs(int s){\n    queue<int> Q;\n    Q.push(s);\n    color[s] = 1;\n    \n    while(!Q.empty()){\n        int u = Q.front();\n        Q.pop();\n        \n        cout << u << endl;\n        \n        for(int v = 0; v < V[u].size(); v++){\n            indeg[V[u][v]]--;\n            if(indeg[V[u][v]] == 0 && color[V[u][v]] == 0){\n                color[V[u][v]] = 1;\n                Q.push(V[u][v]);\n            }\n        }\n    }\n}\n\nvoid topologicalSort() {\n    for(int i = 0; i < vnum; i++) {\n        color[i] = 0;\n        indeg[i] = 0;\n    }\n    \n    for(int i = 0; i < vnum; i++){\n        for(int j = 0; j < V[i].size(); j++){\n            indeg[V[i][j]] += 1;\n        }\n    }\n    \n    for(int u = 0; u < vnum; u++){\n        if(indeg[u] == 0 && color[u] == 0) {\n            bfs(u);\n        }\n    }\n}\n\n\n\n\nint main(void){\n    // Your code here!\n    cin >> vnum >> e;\n    V.resize(vnum);\n    \n    int s, t;\n    for(int i = 0; i < e; i++){\n        cin >> s >> t;\n        V[s].push_back(t);\n    }\n    \n    topologicalSort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\nusing Graph =  vector< vector<Edge> >;\n\n// calc topological sort\n// O(V+E)\nbool topo_sort(const Graph& G, VI& order){\n  int N = G.size();\n  VI color(N, 0);\n  \n  function<bool(int)> visit = [&](int v)->bool{\n\tcolor[v] = 1;\n\tfor(const auto& e: G[v]){\n\t  if(color[e.to] == 2) continue;\n\t  if(color[e.to] == 1) return false;\n\t  if(!visit(e.to)) return false;\n\t}\n\torder.push_back(v);\n\tcolor[v] = 2;\n\treturn true;\n  };\n\n  for(int u=0;u<N;++u)\n\tif(!color[u] && !visit(u))\n\t  return false;\n  reverse(begin(order), end(order));\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  REP(i,E){\n\tint s, t;\n\tcin >> s >> t;\n\tG[s].EB(t);\n  }\n  VI order(V);\n  topo_sort(G, order);\n  REP(i,V) cout << order[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    \n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    \n    while ( !q.empty() ) {\n        \n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n        \n        for ( int i = 0; i <G[u].size(); i++ ) {\n            \n            int v = G[u][i];\n            indeg[v]--;\n            \n            if ( indeg[v] == 0 && !V[v]) {\n                \n                V[v] = true;\n                q.push(v);\n                \n            }\n            \n        }\n        \n    }\n    \n}\n\nvoid tsort() {\n    \n    for( int i= 0; i<N; i++) {\n        \n        indeg[i] = 0;\n        \n    }\n    \n    for ( int u = 0; u < N; u++ ) {\n        \n        for ( int i= 0; i < G[u].size(); i++ ) {\n            \n            int v = G[u][i];\n            indeg[v]++;\n            \n        }\n            \n    }\n    \n    for ( int u= 0; u < N; u++ ) {\n        \n        if ( indeg[u] == 0 && !V[u] ) {\n            \n            bfs(u);\n            \n        }\n        \n    }\n    \n    for ( list<int>::iterator it = out.begin(); it != out.end(); it++ ) {\n        \n        cout << *it << endl;\n        \n    }\n\n}\n\nint main() {\n    \n    int s, t, M;\n    cin >> N >> M;\n    \n    for ( int i= 0; i<N; i++ ) {\n        \n        V[i] = false;\n        \n    }\n    for ( int i= 0;i<M; i++ ) {\n        \n        cin >> s >> t;\n        G[s].push_back(t);\n        \n    }\n    \n    tsort();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region kyomukyomupurin\n\n/**\n *    author  : 𝒌𝒚𝒐𝒎𝒖𝒌𝒚𝒐𝒎𝒖𝒑𝒖𝒓𝒊𝒏\n *    created : 2020-07-23 18:17:30\n **/\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing int64 = long long;\n/*\ntemplate <class T>\ninline void eraque(std::vector<T>& vec) {\n  vec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n  return;\n}\n\ntemplate <class T>\ninline int lower_position(const std::vector<T>& vec, T val) {\n  return static_cast<int>(std::distance(vec.begin(), std::lower_bound(vec.begin(), vec.end(), val)));\n}\n\ntemplate <class T>\ninline int upper_position(const std::vector<T>& vec, T val) {\n  return static_cast<int>(std::distance(vec.begin(), std::upper_bound(vec.begin(), vec.end(), val)));\n}\n\ntemplate<class T>\ninline std::string to_binary(T n) {\n  assert(n > 0);\n  std::string ret = \"\";\n  while (n) ret += (n & 1) ? '1' : '0', n >>= 1;\n  std::reverse(ret.begin(), ret.end());\n  return ret;\n}\n\ntemplate <class T>\ninline void println(T val) {\n  std::cout << val << '\\n';\n}\n\ntemplate <class T>\nusing binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\n\ntemplate <class Tuple, std::size_t... Is>\nvoid tuple_out(std::ostream& os, const Tuple& tp, std::index_sequence<Is...>) {\n  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";\n}\n\ntemplate <class... Args>\nstd::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& tp) {\n  tuple_out(os, tp, std::index_sequence_for<Args...>{});\n  return os;\n}\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\n  int n = 0;\n  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T, class Compare>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {\n  int n = 0;\n  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T, class U, class Compare>\nstd::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {\n  int n = 0;\n  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\n  return os << (n ? \"}\" : \"{}\");\n}\n\ntemplate <class T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& vec) {\n  for (T& e : vec) is >> e;\n  return is;\n}\n\ntemplate <class T, class U>\nstd::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\n  return is >> p.first >> p.second;\n}\n\ntemplate <class Tuple, std::size_t... Is>\nvoid tuple_in(std::istream& is, Tuple& tp, std::index_sequence<Is...>) {\n  ((is >> std::get<Is>(tp)), ...);\n}\n\ntemplate <class... Args>\nstd::istream& operator>>(std::istream& is, std::tuple<Args...>& tp) {\n  tuple_in(is, tp, std::index_sequence_for<Args...>{});\n  return is;\n}\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out() { std::cerr << '\\n'; }\n\ntemplate <class Head, class... Tail>\nvoid debug_out(Head&& head, Tail&&... tail) {\n  std::cerr << head;\n  if (sizeof...(Tail) != 0) std::cerr << \", \";\n  debug_out(std::forward<Tail>(tail)...);\n}\n\n#pragma endregion kyomukyomupurin\n*/\ntemplate <class T>\nclass graph {\n public:\n  graph(int n) : n_(n) { data_.resize(n_); }\n  struct edge {\n    int from, to;\n    T cost;\n  };\n  int n_;\n  std::vector<std::vector<int>> data_;\n  std::vector<edge> edges_;\n\n  virtual void add(int from, int to, T cost) = 0;\n};\n\ntemplate <class T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  forest(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    assert(id < n_ - 1);\n    data_[from].emplace_back(id);\n    data_[to].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n};\n\ntemplate <class T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  digraph(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    data_[from].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n_);\n    for (auto& e : edges_) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <class T>\nclass undigraph : public graph<T> {\n public:\n  using graph<T>::n_;\n  using graph<T>::data_;\n  using graph<T>::edges_;\n\n  undigraph(int n) : graph<T>(n) {}\n\n  void add(int from, int to, T cost = 1) {\n    int id = edges_.size();\n    data_[from].emplace_back(id);\n    data_[to].emplace_back(id);\n    edges_.push_back({from, to, cost});\n  }\n};\n\n\nclass TopologicalSort {\n public:\n  TopologicalSort(int node_size) : node_size_(node_size) { Initialize(); }\n\n  void AddEdge(int from, int to) {\n    graph_[from].emplace_back(to);\n    ++level_[to];\n  }\n\n  void Sort() {\n    std::queue<int> que;\n    for (int i = 0; i < node_size_; ++i) {\n      if (level_[i] == 0) que.push(i);\n    }\n    while (!que.empty()) {\n      int top = que.front();\n      que.pop();\n      result_.emplace_back(top);\n      for (int next : graph_[top]) {\n        if (--level_[next] == 0) que.push(next);\n      }\n    }\n  }\n\n  // use after Sort()!\n  bool IsDAG() {\n    return all_of(level_.begin(), level_.end(), [](int x) { return x == 0; });\n  }\n\n  int operator[](int position) const { return result_[position]; }\n\n private:\n  int node_size_;\n  std::vector<std::vector<int>> graph_;\n  std::vector<int> level_;\n  std::vector<int> result_;\n\n  void Initialize() {\n    graph_.resize(node_size_);\n    level_.assign(node_size_, 0);\n  }\n};\n\ntemplate <class T>\nstd::vector<int> topological_sort(const digraph<T>& g) {\n  std::vector<int> lev(g.n_, 0);\n  std::vector<int> res;\n  for (auto e : g.edges_) ++lev[e.to];\n  std::queue<int> que;\n  for (int i = 0; i < g.n_; ++i) {\n    if (lev[i] == 0) que.emplace(i);\n  }\n  while (!que.empty()) {\n    int cur = que.front(); que.pop();\n    res.emplace_back(cur);\n    for (int id : g.data_[cur]) {\n      auto& e = g.edges_[id];\n      int nxt = e.from ^ e.to ^ cur;\n      if (--lev[nxt] == 0) que.emplace(nxt);\n    }\n  }\n  if (std::all_of(lev.begin(), lev.end(), [](int e){ return e == 0; })) {\n    return res;\n  } else {\n    return {};\n  }\n}\n\nvoid GRL_4_B() {\n  int n, m; cin >> n >> m;\n  digraph<int> g(n);\n  for (int i = 0; i < m; ++i) {\n    int s, t; cin >> s >> t;\n    g.add(s, t);\n  }\n  vector<int> ts = topological_sort(g);\n  for (int e : ts) cout << e << '\\n';\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  GRL_4_B();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nclass Graph1 {\npublic:\n\t// ------Basics ------ //\n\tstatic const int INF = 2147483647;\n\tint V, E; vector<vector<int> > G;\n\tGraph1() : V(0), E(0), G(vector<vector<int> >()) {}\n\tGraph1(int v) : V(v), E(0), G(vector<vector<int> >(v)) {}\n\tGraph1(vector<vector<int> > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\tint size() { return V; }\n\tvoid add1(int v1, int v2) { G[v1].push_back(v2); E++; }\n\tvoid add2(int v1, int v2) { add1(v1, v2); add1(v2, v1); }\n\tfriend bool operator==(const Graph1& g1, const Graph1& g2) { return g1.G == g2.G; }\n\tfriend bool operator!=(const Graph1& g1, const Graph1& g2) { return g1.G != g2.G; }\n\tvector<int> operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tvector<int> tsort() {\n\t\tint n = G.size();\n\t\tvector<int> ret, vis(n);\n\t\tfunction<bool(int)> dfs = [&](int v) {\n\t\t\tvis[v] = true;\n\t\t\tfor (auto &e : G[v]) if (!vis[e] && !dfs(e)) return false;\n\t\t\tret.push_back(v);\n\t\t\treturn true;\n\t\t};\n\t\tfor (int i = 0; i < n; i++) if (!vis[i] && !dfs(i)) return {};\n\t\treverse(ret.begin(), ret.end());\n\t\treturn ret;\n\t}\n};\nint V, E, s, t;\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tGraph1 G(V);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tG.add1(s, t);\n\t}\n\tvector<int> v = G.tsort();\n\tfor(int i = 0; i < v.size(); i++) cout << v[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n\tint num,E,from,to,table[10000],tmp;\n\tvector<int> V[10000];\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < 10000; i++)table[i] = 0;\n\n\tscanf(\"%d %d\",&num,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\ttable[to]++;\n\t}\n\n\tfor(int i = 0; i < num; i++){\n\t\tif(table[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\t\tprintf(\"%d\\n\",tmp);\n\t\tfor(int i = 0; i < V[tmp].size(); i++){\n\t\t\ttable[V[tmp][i]]--;\n\t\t\tif(table[V[tmp][i]] == 0){\n\t\t\t\tQ.push(V[tmp][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// トポロジカルソート : 深さ優先探索\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<list>\n\nusing namespace std;\n\nconst int MAX = 10000;\n\n// 各辺のつながりを格納する動的配列\nvector<int> G[MAX];\n// 訪問情報を保持する配列\nbool V[MAX];\n// トポロジカルソートの結果を格納するリスト\nlist<int> out;\n\nint N;\n\nvoid dfs(int u);\n\nint main(void)\n{\n\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++)\n    {\n        // 配列の初期化\n        V[i] = false;\n    }\n\n    for(int i = 0; i < M; i++)\n    {\n        cin >> s >> t;\n\n        // 各辺のつながりを記憶する\n        G[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n    {\n        if( !V[i] )\n        {\n            // 頂点を順番に訪れる\n            dfs(i);\n        }\n    }\n\n    // 結果の表示\n    // トポロジカルソートの結果の表示\n    for(list<int>::iterator it = out.begin(); it != out.end(); it++)\n    {\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\n// トポロジカルソートを実施するためのメソッド\n// u : 訪問する頂点\nvoid dfs(int u)\n{\n    // 訪問情報を記録\n    V[u] = true;\n\n    for(unsigned int i = 0; i < G[u].size(); i++ )\n    {\n        // 接続先の頂点No.の格納\n        int v = G[u][i];\n\n        if( !V[v] )\n        {\n            // 接続している頂点を順番に訪れる\n            dfs(v);\n        }\n    }\n\n    // 入力辺が無くなった頂点をトポロジカルキューに追加する\n    out.push_front(u);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\n\nclass TopologicalSort {\npublic:\n  int n;\n  vector< vector<int> > G;\n  vector<bool> used;\n  vector<int> indeg;\n  vector<int> out;\n\n  TopologicalSort(int _n): n(_n), G(n), used(n), indeg(n), out(0) {}\n\n  void bfs(int start) {\n    queue<int> q;\n    q.push(start);\n    while (!q.empty()) {\n      int cur = q.front(); q.pop();\n      out.push_back(cur);\n      for (int v: G[cur]) {\n\tindeg[v]--;\n\tif (indeg[v] == 0 && !used[v]) {\n\t  used[v] = true;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  \n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n  }\n  \n  vector<int> build() {\n    fill(indeg.begin(), indeg.end(), 0);\n    fill(used.begin(), used.end(), 0);\n    for (int i = 0; i < n; ++i)\n      for (int v: G[i]) indeg[v]++;\n\n    for (int i = 0; i < n; ++i) {\n      if (indeg[i] == 0 && !used[i]) bfs(i);\n    }\n    return out;\n  }\n};\n\nint main() {\n  int v, e;\n  scanf(\"%d %d\", &v, &e);\n\n  TopologicalSort tp = TopologicalSort(v);\n  for (int i = 0; i < e; ++i) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    tp.add_edge(s, t);\n  }\n  vector<int> ans = tp.build();\n  for (size_t i = 0; i < ans.size(); ++i) {\n    printf(\"%d\\n\", ans[i]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\nusing namespace std;\nconst int Max=10000;\nvector<int>G[Max];\nlist<int>l;\nint V,E;\nint indeg[Max];\nbool flag[Max];\nvoid bfs(int u){\n    queue<int>q;\n    q.push(u);\n    flag[u]=true;\n    while(!q.empty()){\n        int i=q.front();\n        q.pop();\n        l.push_back(i);\n        for(int j=0;j<G[i].size();j++)\n        {\n            int v=G[i][j];\n            indeg[v]--;\n            if(!flag[v] && indeg[v]==0)\n            {\n                //l.push_back(v);\n                flag[v]=true;\n                q.push(v);\n                \n            }\n        }\n    }\n}\nvoid tsort(){\n    for(int i=0;i<V;i++)\n    {\n        if(indeg[i]==0 && !flag[i])\n            bfs(i);\n    }\n}\nint main()\n{\n    int s,t;\n    cin>>V>>E;\n    for(int i=0;i<V;i++)\n    {\n        indeg[i]=0;\n        flag[i]=false;\n    }\n    for(int i=0;i<E;i++)\n    {\n        cin>>s>>t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n    tsort();\n    for(list<int>::iterator it=l.begin();it!=l.end();it++)\n        cout<<(*it)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < V; i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0, s = ans.size(); i < s; i++) {\n        for (int j = 0; j < edge[ans[i]].size(); j++) {\n            int t = edge[ans[i]][j];\n            state[t]--;\n            if (state[t] == 0) {\n                ans.push_back(t);\n                s++;\n            }\n        }\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <list>\n#include <algorithm>\nusing namespace std;\nconst int maxx = 100010;\nconst int INF = 1 << 30;\n\nvector<int>G[maxx];\nlist<int>out;\nbool flag[maxx];\nint n;\n\nvoid dfs(int u) {\n\tflag[u] = true;\n\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (flag[v] == 0)\n\t\t\tdfs(v);\n\t}\n\tout.push_back(u);\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < n; i++) {\n\t\tflag[i] = false;\n\t}\n\n\tfor (int u = 0; u < n; u++) {\n\t\tif ( flag[u] == 0)\n\t\t\tdfs(u);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tprintf(\"%d\\n\", *it);\n}\nint main()\n{\n\tint s, t, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst int MAX_V = 10000;\nconst int MAX_E = 100000;\nvector<deque<int> > G(MAX_E);\nvector<int> L;  // トポロジカルソートした結果を蓄積する空リスト.\ndeque<int> S;   // 入力辺を持たないすべてのノードの集合.\nmap<int, int> inCount;\n\n// 各頂点から, トポロジカルソート を行い, 頂点の並び順を保存.\nvoid topologicalSort(){\n    \n    // 1. キュー S が 空になるまで, ループ.\n    while(!S.empty()){\n\n        // 2. S からノード n を削除.\n        int n = S.front();\n        S.pop_front();\n        \n        // 3. L に n を追加.\n        L.push_back(n);\n\n        while(!G[n].empty()){\n            // 4. 辺 e (n -> m)をグラフから削除.\n            int m = G[n].front();\n            G[n].pop_front();\n            inCount[m]--;\n            // printf(\"n=%d m=%d\\n\", n, m);\n            // 5. m がその他の入力辺を持っていなければ, m を S に追加.\n            if(inCount[m] == 0) S.push_back(m);\n        }\n    }\n    \n    // 6. グラフに辺が残っている場合は, 閉路があり DAG でないので中断.\n    // 本問では, 考慮しなくて良さそう.\n    \n    return;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    for(int i = 0; i < E; i++){\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n        inCount[t]++; // 各頂点への入力辺の本数を保存.\n    }\n    \n    // 2. 辺の数が, 0本の場合, 頂点を S に追加.\n    // -> 入力情報に, 必ずしも, 頂点情報が与えらるとは, 限らないので注意.\n    for(int i = 0; i < V; i++) if(inCount[i] == 0) S.push_back(i);\n    \n    // 3. トポロジカルソートを行う.\n    topologicalSort();\n    \n    // 4. 出力 ～ 後処理.\n    for(int i = 0; i < L.size(); i++) printf(\"%d\\n\", L[i]);\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,x) for(ll i = 0; i < (ll)(x); i++)\n#define rrep(i,x) for(ll i = (ll)(x)-1;0 <= i; i--)\n#define reps(i,x) for(ll i = 1; i < (ll)(x)+1; i++)\n#define rreps(i,x) for(ll i = (ll)(x); 1 <= i; i--)\n#define debug(x) cerr << #x << \": \" << (x) << \"\\n\";\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<vector<ll>>> vvvl;\nconst ll INF = numeric_limits<ll>::max()/4;\nconst int n_max = 1e5+10;\n#define int ll\n\n// 有向グラフ上のトポロジカルソート\nvector<ll> topo_sort(vvl &graph){\n    queue<ll> que;\n    vector<ll> ans;\n    ll v = graph.size();\n    vector<ll> in(v);\n    for(auto &vec : graph){\n        for(auto &to : vec)in[to]++;\n    }\n    rep(i,v)if(in[i] == 0){\n        que.emplace(i);\n        ans.emplace_back(i);\n    }\n    while(!que.empty()) {\n        auto f = que.front();que.pop();\n        for(auto &to : graph[f]) {\n            in[to]--;\n            if(!in[to]) {\n                ans.emplace_back(to);\n                que.emplace(to);\n            }\n        }\n    }\n\n    return ans;\n};\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    ll v,e; cin >> v >> e;\n    vvl graph(v);\n    vector<ll> in(v);\n    rep(i,e){\n        ll f,t; cin >> f >> t;\n        // f--;t--;\n        graph[f].emplace_back(t);\n        in[t]++;\n    }\n    auto ans = topo_sort(graph);\n\n    for(auto &i : ans){\n        cout << i;\n        if(&i != &ans.back())cout << \"\\n\";\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    set<int> g[n];\n    int f, t;\n\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f].insert(t);\n    }\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n\n    for (int i = 0; i < n; i++) {\n        int d = 0;\n        for (int j = 0; j < n; j++) {\n            if (g[j].find(i) != g[j].end())\n                d++;\n        }\n\n        if (!d)\n            q.push(i);\n\n        mm[i] = d;\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        cout << v << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            if (g[v].find(i) != g[v].end()) {\n                int e = mm[i]-1;\n                if (!e)\n                    q.push(i);\n\n                mm[i] = e;\n            }\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define pb push_back\n#define MAX 100005\n#define int long long\nusing namespace std;\n\nconst int MOD=1000000007;\nconst int INF=1000000009;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nstruct Edge{\n  int src,dst,wei;\n  Edge(int s=0,int d=0,int w=0):src(s),dst(d),wei(w){}\n};\nusing Graph = vector<vector<Edge>>;\n\nvector<int> Toposort(Graph&g){\n  int v=g.size(),k=0;\n  vector<int> res(v),in(v);\n  for(int i=0;i<v;i++){\n    for(int j=0;j<g[i].size();j++){\n      Edge x=g[i][j];\n      in[x.dst]++;\n    }\n  }\n  queue<int> q;\n  for(int i=0;i<v;i++){\n    if((in[i]==0))q.push(i);\n  }\n  while(!q.empty()){\n    int u=q.front();\n    q.pop();\n    res[k++]=u;\n    for(int i=0;i<g[u].size();i++){\n      Edge &e=g[u][i];\n      in[e.dst]--;\n      if(in[e.dst]==0)q.push(e.dst);\n    }\n  }\n  return res;\n}\n\n\n\nsigned main(){\n  int v,e;\n  cin>>v>>e;\n  Graph g(v);\n  rep(i,e){\n    int s,t;\n    cin>>s>>t;\n    g[s].pb(Edge(s,t,0));\n  }\n  vector<int> ans=Toposort(g);\n  rep(i,v){\n    cout<<ans[i]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class T>\nusing lp_queue=priority_queue<T, deque<T>, greater<T>>;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Edge {\n    size_t src, dst;\n    Weight weight;\n    Edge() {}\n    Edge(size_t src, size_t dst, Weight weight=1):\n        src(src), dst(dst), weight(weight)\n    {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    if (e.weight != f.weight) {\n        return e.weight > f.weight;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Edges=vector<Edge>;\nusing Vertex=vector<Edge>;\nusing Graph=vector<Vertex>;\n\nvoid join(Graph &g, size_t s, size_t d, Weight w=1) {\n    // non-directed\n    g[s].push_back(Edge(s, d, w));\n    g[d].push_back(Edge(d, s, w));\n}\n\nvoid connect(Graph &g, size_t s, size_t d, Weight w=1) {\n    // directed\n    g[s].push_back(Edge(s, d, w));\n}\n\nvector<size_t> tsort(const Graph &g) {\n    /* Kahn */\n    // returns lexico-smallest one.\n    // if impossible, returns empty vector.\n    size_t V=g.size();\n    vector<size_t> indeg(V);\n\n    for (const Vertex &v: g)\n        for (const Edge &e: v)\n            ++indeg[e.dst];\n\n    lp_queue<size_t> q;\n    for (size_t i=0; i<V; i++)\n        if (!indeg[i]) q.push(i);\n\n    vector<size_t> ord(V);\n    for (size_t k=0; !q.empty(); ++k) {\n        int v=q.top(); q.pop();\n        ord[k] = v;\n        for (const Edge &e: g[v])\n            if (!--indeg[e.dst]) q.push(e.dst);\n    }\n    return *max_element(indeg.begin(), indeg.end())? vector<size_t>():ord;\n}\n\nint main() {\n    size_t V, E;\n    scanf(\"%zu %zu\", &V, &E);\n\n    Graph g(V);\n    for (size_t i=0; i<E; ++i) {\n        size_t s, t;\n        scanf(\"%zu %zu\", &s, &t);\n\n        connect(g, s, t);\n    }\n\n    vector<size_t> ord=tsort(g);\n\n    for (size_t v: ord)\n        printf(\"%zd\\n\", v);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(v) cout<<v<<\"\\n\"\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  int V, E; cin >> V >> E;\n\n  vector<vector<bool>> edge(V, vector<bool>(V, false));\n  vector<int> in(V, 0);\n\n  queue<int> no_incoming_edge;\n  rep(i, E) {\n    int s, t;\n    cin >> s >> t;\n    edge[s][t] = true;\n    ++in[t];\n  }\n  rep(i, V) {\n    if (in[i] == 0)\n      no_incoming_edge.push(i);\n  }\n  vector<int> ans;\n  while (!no_incoming_edge.empty()) {\n    int p = no_incoming_edge.front(); no_incoming_edge.pop();\n    ans.push_back(p);\n    rep(to, V) {\n      if (edge[p][to] == 1) {\n        --in[to];\n        if (in[to] == 0)\n          no_incoming_edge.push(to);\n      }\n    }\n  }\n  rep(i, V)\n    out(ans[i]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct Node {\n  std::unordered_set<int> in_edge;\n  std::unordered_set<int> out_edge;\n};\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int v, e;\n  cin >> v >> e;\n  std::vector<Node> node(v);\n  for (int i = 0; i < e; i++) {\n    int from, to;\n    cin >> from >> to;\n    node[from].out_edge.insert(to);\n    node[to].in_edge.insert(from);\n  }\n\n  std::queue<int> search_set;\n  std::vector<int> result;\n\n  for (int i = 0; i < e; i++) {\n    if (node[i].in_edge.empty()) {\n      search_set.push(i);\n    }\n  }\n\n  while (!search_set.empty()) {\n    int tgt = search_set.front();\n    search_set.pop();\n    result.push_back(tgt);\n    for (auto itr = node[tgt].out_edge.begin(); itr != node[tgt].out_edge.end();\n         itr++) {\n      node[*itr].in_edge.erase(tgt);\n      if (node[*itr].in_edge.empty()) {\n        search_set.push(*itr);\n      }\n    }\n  }\n\n  for (auto x : result) {\n    cout << x << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\ntypedef struct UnionFindTree{\n  vector<int> par;\n  vector<int> treerank;\n  \n  UnionFindTree(int n){\n    par.resize(n); treerank.resize(n);\n    rep(i, n) par[i] = i, treerank[i] = 0;\n  }\n  \n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(treerank[x] < treerank[y]) swap(x, y);\n    if(treerank[x] == treerank[y]) treerank[x]++;\n    par[y] = x;\n    return;\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n}UF;\n \ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c){\n        from = f; to = t; cost = c;\n    }\n};\n \ntemplate<class T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n    \n    Graph(int n_){\n        n = n_;\n        G.resize(n);\n    }\n    \n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n    \n    vector<T> dijkstra(int s){\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<T> d(n, numeric_limits<T>::max());\n        d[s] = 0;\n        que.push(P((T)0, s));\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(edge<T> &e : G[v]){\n                if(d[e.to] > d[v] + e.cost){\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n        return d;\n    }\n    \n    T kruskal(){\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        sort(E.begin(), E.end(), [](const edge<T> &e1, const edge<T> &e2){return e1.cost < e2.cost;});\n        UF uf(n);\n        T res = 0;\n        for(edge<T> &e: E){\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        return res;\n    }\n    \n    vector<int> toposo(){\n        vector<int> ret(n), in(n, 0);\n        rep(i, n)for(edge<T> &e: G[i]) ++in[e.to];\n        int cur = 0;\n        stack<int> st;\n        rep(i, n)if(!in[i]) st.push(i);\n        while(!st.empty()){\n            int v = st.top(); st.pop();\n            ret[cur++] = v;\n            for(edge<T> &e: G[v]){\n                --in[e.to];\n                if(!in[e.to]) st.push(e.to);\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int v, e;\n    scanf(\"%d%d\", &v, &e);\n    Graph<int> g(v);\n    rep(i, e){\n        int s, t;\n        scanf(\"%d%d\", &s, &t);\n        g.add_edge(s, t, 0);\n    }\n    vector<int> ans = g.toposo();\n    rep(i, v) printf(\"%d\\n\", ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define dhoom ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);  \ntypedef long long ll;\n#define SIZE 10005\nvector< ll > dp[SIZE];\nll height[SIZE];\nll n ,m;\nvector< int > graph[SIZE];\nvector< int > ans;\nvector< int > vis(SIZE,0);\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(auto v : graph[u])\n\t{\n\t\tif(!vis[v])\n\t\t\tdfs(v);\n\t}\n\tans.push_back(u);\n}\nint main(){\n\tdhoom;\n\tcin >> n >> m;\n\tfor(int i = 0 ; i < m ; i++)\n\t{\n\t\tint u , v;\n\t\tcin >> u >> v;\n\t\tgraph[u].push_back(v);\n\t}\n\tfor(int i = 0 ;i < n ; i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\treverse(ans.begin() , ans.end());\n\tfor(int i = 0 ;i < n ; i++)\t\n\t{\n\t\tcout << ans[i] << endl;\n\t}\n\t\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(int i = 0; i < n; ++i) for(auto &e : g[i]) in[e.dst]++;\n    for(int i = 0; i < n; ++i){\n        if(in[i] == 0 && !vis[i]) {\n            vis[i] = true;res.push_back(i);\n            queue<int> q;\n            q.push(i);\n            while(!q.empty()) {\n                int p = q.front(); q.pop();\n                for(auto &e : g[p]){\n                    int np = e.dst;\n                    in[np]--;\n                    if(in[np] == 0 && !vis[np]){\n                        vis[np] = true;\n                        q.push(np);\n                        res.push_back(np);\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    // assert((int)ord.size() == n);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint n, m;\nvector<vector<int>> hen;\nvector<bool> seen;\nvector<int> top;\n\nvoid dfs(int v) {\n    if(seen[v]) return;\n    seen[v] = true;\n    for(auto i : hen[v]) {\n        dfs(i);\n    }\n    top.push_back(v);\n}\n\nint main()\n{\n    cin >> n >> m;\n    hen.resize(n);\n    seen.resize(n);\n    for(int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b;\n        hen[a].push_back(b);\n    }\n    for(int i = 0; i < n; i++)dfs(i);\n    reverse(top.begin(), top.end());\n    for(auto i : top)cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n  V[u] = true;\n  for ( int i = 0; i < G[u].size(); i++ ) {\n    int v = G[u][i];\n    if ( !V[v] ) dfs(v);\n  }\n  out.push_front(u);\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  for ( int i = 0; i < N; i++ )\n    if ( !V[i] ) dfs(i);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Topological sorted graph\nstruct TopologicalGraph\n{\n  vector< vector<int> > graph;\n  vector<int> order;\n  TopologicalGraph(int sz):graph(sz){}\n  TopologicalGraph(vector< vector<int> > graph):graph(graph){}\n  void add_edge(int from, int to)\n  {\n    graph[from].push_back(to);\n  }\n  bool visit(int u, vector<int>& color)\n  {\n    color[u] = 1;\n    for(int v : graph[u]) {\n      if(color[v] == 2) continue;\n      if(color[v] == 1) return false;\n      if(!visit(v, color)) return false;\n    }\n    order.push_back(u);\n    color[u] = 2;\n    return true;\n  }\n  bool sort()\n  {\n    vector<int> color((int)graph.size(), 0);\n    for(int i = 0; i < (int)color.size(); i++) {\n      if(color[i] == 0 && !visit(i, color)) return false;\n    }\n    reverse(order.begin(), order.end());\n    return true;\n  }\n  void print_order()\n  {\n    for(int i = 0; i < (int)order.size(); i++) cout << order[i] << endl;\n  }\n};\n\nint main()\n{\n  int V, E; cin >> V >> E;\n  TopologicalGraph graph(V);\n  while(E--) {\n    int s, t; cin >> s >> t;\n    graph.add_edge(s, t);\n  }\n  graph.sort();\n  graph.print_order();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(int i = 0; i < n; ++i) for(auto &e : g[i]) in[e.dst]++;\n    for(int i = 0; i < n; ++i){\n        if(in[i] == 0 && !vis[i]) {\n            vis[i] = true; res.push_back(i);\n            queue<int> q;\n            q.push(i);\n            while(!q.empty()) {\n                int p = q.front(); q.pop();\n                for(auto &e : g[p]){\n                    int np = e.dst;\n                    in[np]--;\n                    if(in[np] == 0 && !vis[np]){\n                        vis[np] = true;\n                        q.push(np);\n                        res.push_back(np);\n                    }\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    return 0;\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a, 0, sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MAX_V 100000\n\n#define MOD 1000000007L\n#define INF 2147483647\n\nvector<int> topo_sort(const vector<vector<int>>& g) {\n\tconst int V = g.size();\n\tvector<int> indeg(V, 0);\n\tstack<int> S;\n\n\tfor(auto& vs : g) {\n\t\tfor(auto& v: vs) {\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (indeg[i] == 0) {\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tvector<int> ans;\n\twhile( S.size() > 0) {\n\t\tint u = S.top();\n\t\tS.pop();\n\t\tans.emplace_back(u);\n\t\tfor (auto& v : g[u]) {\n\t\t\tindeg[v] --;\n\t\t\tif (indeg[v] == 0) {\n\t\t\t\tS.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> vs(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\tvs[from].push_back(to);\n\t}\n\tvector<int> res = topo_sort(vs);\n\tfor (int t: res) {\n\t\tcout << t << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI tsort(VVI g) {\n  int n = g.size();\n  vector<bool> used(n, false);\n  vector<int> ans;\n\n  function<void(int)> dfs = [&](int u) {\n    if(used[u]) return;\n    used[u] = true;\n    for(auto& i: g[u]) dfs(i);\n    ans.push_back(u);\n  };\n\n  for(int i=0; i<n; ++i) dfs(i);\n  reverse(ans.begin(), ans.end());\n  return ans;\n}\n\n// VI tsort(VVI g) {\n//   const int n = g.size();\n//   VI h(n, 0);\n//   REP(i, n) for(int j: g[i]) h[j]++;\n//\n//   stack<int> st;\n//   REP(i, n) if(h[i] == 0) st.push(i);\n//\n//   VI ans;\n//   while(st.size()) {\n//     int i = st.top(); st.pop();\n//     ans.push_back(i);\n//     for(auto& j: g[i]) {\n//       h[j]--;\n//       if(h[j] == 0) st.push(j);\n//     }\n//   }\n//\n//   return ans;\n// }\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  VVI g(n, VI(0));\n  REP(i, m) {\n    int a, b;\n    cin >> a >> b;\n    g[a].PB(b);\n  }\n\n  VI ans = tsort(g);\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> es[10000];\nint h[10000];\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    \n    for (int i = 0; i < E; i++) {\n        int u, v;\n        cin >> u >> v;\n        es[u].push_back(v);\n        h[v]++;\n    }\n    \n    stack<int> st;\n    for (int i = 0; i < V; i++) if (h[i] == 0) st.push(i);\n    \n    vector<int> ans;\n    \n    while (!st.empty()) {\n        int u = st.top(); st.pop();\n        ans.push_back(u);\n        \n        for (auto v: es[u]) {\n            h[v]--;\n            if (h[v] == 0) st.push(v);\n        }\n    }\n    \n    for (auto u: ans) cout << u << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nvector< vector<int> > G1, G2;\nint V;\nvector<bool> used;\nvoid init() {\n    G1.clear(); G1.resize(V);\n    G2.clear(); G2.resize(V);\n    used.clear(); used.resize(V);\n}\nvoid addEdge(int from, int to) {\n    G1[from].push_back(to);\n    G2[to].push_back(from);\n}\nvector<int> vs;\nvoid dfs1(int v) {\n    used[v] = true;\n    for (int i = 0; i < G1[v].size(); i++) {\n        if (!used[ G1[v][i] ]) dfs1(G1[v][i]);\n    }\n    vs.push_back(v);\n}\nvoid dfs2(int v, int k, vector<int>& order) {\n    used[v] = true;\n    order[v] = k;\n    for (int i = 0; i < G2[v].size(); i++) {\n        if (!used[ G2[v][i] ]) dfs2(G2[v][i], k, order);\n    }\n}\nint solve(vector<int>& ord) {\n    fill(whole(used), false);\n    vs.clear();\n    for (int v = 0; v < V; v++) {\n        if (!used[v]) dfs1(v);\n    }\n    fill(whole(used), false);\n    int k = 0;\n    ord.clear(); ord.resize(V, -1);\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) dfs2(vs[i], k++, ord);\n    }\n    return k;\n}\n\nint main() {\n    int E;\n    scanf(\"%d %d\\n\", &V, &E);\n    init();\n    for (int i = 0; i < E; i++) {\n        int s, t; scanf(\"%d %d\\n\", &s, &t);\n        addEdge(s, t);\n    }\n    vector<int> ord;\n    solve(ord);\n    for (int i = 0; i < V; i++) {\n        printf(\"%d\\n\", ord[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,e;\nint color[10001];\nint indegree[10001];\nvector<int> ans;\nvector<int> vec[10001];\nvoid Topological(int s){\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()){\n        int u=que.front();que.pop();\n        ans.push_back(u);\n        color[u]=1;\n        for(int i=0;i<vec[u].size();++i){\n            indegree[vec[u][i]]--;\n            if(indegree[vec[u][i]]==0&&color[vec[u][i]]==0){\n                que.push(vec[u][i]);\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d %d\",&n,&e);\n    for(int i=0;i<e;++i){\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        vec[u].push_back(v);\n        indegree[v]++;\n    }\n    for(int i=0;i<n;++i){\n        if(indegree[i]==0&&color[i]==0)\n        Topological(i);\n    }\n    for(int i=0;i<n;++i){\n        printf(\"%d\\n\",ans[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kNil = -1;\n\nenum class Color {\n  kWhite,\n  kGrey,\n  kBlack,\n};\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\nvoid DFSVisitTopological(const typename vector<Edge>::size_type node_now,\n       typename vector<Edge>::size_type & time,\n       const vector<vector<Edge>> & adjacency_list,\n       vector<int> & d,\n       vector<int> & f,\n       vector<Color> & color,\n       vector<int> & parent,\n       vector<typename vector<Edge>::size_type> & result) {\n  color[node_now] = Color::kGrey;\n  d[node_now] = time++;\n  for (const auto & e: adjacency_list[node_now]) {\n    if (color[e.v] == Color::kWhite) {\n      parent[e.v] = node_now;\n      DFSVisitTopological(e.v, time, adjacency_list, d, f, color, parent, result);\n    }\n  }\n  color[node_now] = Color::kBlack;\n  f[node_now] = time++;\n  result.push_back(node_now);\n}\n\ntemplate <class Edge>\nvector<typename vector<Edge>::size_type> DFSTopological(\n    const vector<Edge> & edges,\n    typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n\n  vector<vector<Edge>> adjacency_list(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency_list[e.u].push_back(e);\n  }\n\n  vector<int> d(node_num);\n  vector<int> f(node_num);\n  vector<Color> color(node_num, Color::kWhite);\n  vector<int> parent(node_num);\n  vector<size_type> result;\n  size_type time = 0;\n\n  for (unsigned i = 0; i < node_num; ++i) {\n    if (color[i] == Color::kWhite) {\n      DFSVisitTopological(i, time, adjacency_list, d, f, color, parent, result);\n    }\n  }\n\n  reverse(result.begin(), result.end());\n  return result;\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = unsigned;\n\n  vector<Edge<w_type>> edges;\n  unsigned V, E;\n  cin >> V >> E;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    w_type w;\n    cin >> u >> v;\n    edges.emplace_back(u, v, 1);\n  }\n\n  auto result = DFSTopological(edges, V);\n  for (const auto & e: result) {\n    cout << e << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(in) in.begin(), in.end()\nconstexpr int INF = (numeric_limits<int>::max() == INT_MAX ? (int)1e9 : (long long)1e18);\nconstexpr long double eps = 1e-6;\nconst string el = \"\\n\";\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\nusing ld = long double;using pii = pair<int,int>;using piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nvoid fast_io(){ios::sync_with_stdio(false); cin.tie(nullptr);}\nint out(int a){cout << a << el; return 0;}\nint out(string s = \"NO\"){cout << s << el; return 0;}\ntemplate <class T>\ninline int out(vector<T>&v,string c = \" \"){\n    for(int i = 0; i < v.size(); ++i){\n        if(i) cout << c; cout << v[i];\n    } cout << el;return 0;\n}\ntemplate<typename T>\nclass StronglyConnectedComponents{\n    vector<vector<T>>edge,rev_edge,compressed_edge,point_set;\n    vector<int>order,vcomp,sort_order_vec;\n    vector<bool>visit;\n    int v_size = 0,compress_size = 0;\n    void dfs(int v){\n        visit[v] = true;\n        for(auto nv : edge[v])\n            if(not visit[nv]) dfs(nv);\n        order.push_back(v);\n    }\n    void dfs_compress(int v){\n        vcomp[v] = compress_size;\n        for(auto nv : rev_edge[v])\n            if(vcomp[nv] == -1) dfs_compress(nv);\n    }\n    void rev_edge_build(){\n        for(int nv = 0; nv < edge.size(); ++nv)\n            for(auto v : edge[nv])\n                rev_edge[v].push_back(nv);\n    }\n    void popsort(){\n        for(int v = 0; v < edge.size(); ++v)\n            if(not visit[v]) dfs(v);\n    }\n    void compress_vertex(){\n        for(auto itr = order.rbegin(); itr != order.rend();++itr ){\n            auto v = *itr;\n            if(vcomp[v] == -1){\n                dfs_compress(v); compress_size++;\n            }\n        }\n    }\n    void construct_strcomp(){\n        compress_vertex();\n        //create compressed graph\n        compressed_edge = vector<vector<T>>(compress_size);\n        for(int frm = 0; frm < edge.size(); ++frm)\n            for(auto to : edge[frm]){\n                if(vcomp[frm] == vcomp[to])continue;\n                compressed_edge[vcomp[frm]].push_back(vcomp[to]);\n            }\n    }\n    void construct_point_set(){\n        point_set = vector<vector<int>>(compress_size);\n        for(int v = 0; v < vcomp.size(); ++v){\n            point_set[vcomp[v]].push_back(v);\n        }\n    }\npublic:\n    StronglyConnectedComponents(vector<vector<T>>&e)\n    :v_size((int)e.size()),edge(e),order{},rev_edge(e.size()){};\n    int operator [](int v){\n        return sort_order_vec[v];\n    }\n    void build(){\n        rev_edge_build();\n        visit = vector<bool>(v_size,false);\n        popsort();\n        vcomp = vector<int>(v_size,-1);\n        construct_strcomp();\n        construct_point_set();\n    }\n    bool isSamePointSet(int v, int u){return vcomp[v] == vcomp[u];}\n    int scc_size(){return compress_size;}\n    vector<vector<int>> get_point_set(){\n        return point_set;\n    }\n};\nvoid dfs_popsort(int cv,int& idx,vector<vector<int>>&edge,\n                 vector<bool>&visit,vector<int>&out){\n    visit[cv] = true;\n    for(auto nv : edge[cv]){\n        if(not visit[nv])dfs_popsort(nv,idx,edge,visit,out);\n    }\n    out[idx--] = cv;\n}\nauto TopologicalSort(vector<vector<int>>&edge){\n    int N = edge.size();\n    vector<bool>v(N,false);\n    vector<int>out(N,-1);\n    int idx = N-1;\n    for(int i = 0; i < v.size();i++){\n        if(not v[i])dfs_popsort(i,idx,edge,v,out);\n    }\n    return out;\n}\n//inline void solve(){\n//    int N,t; cin >> N >> t;\n//    vector<vector<int>>edge(N),tmp(N),directed_edge(N);\n//    vector<tuple<int,int,int>>tup;\n//    vector<tuple<int,int>>ans;\n//    rep(i,t){\n//        int d,s,t; cin >> d >> s >> t;\n//        --t;--s;\n//        tup.emplace_back(d,s,t);\n//        if(d == 1){\n//            edge[s].push_back(t);\n//            directed_edge[s].emplace_back(t);\n//        } else {\n//            edge[t].push_back(s);\n//            edge[s].push_back(t);\n//        }\n//    }\n//    StronglyConnectedComponents<int>SCC(directed_edge);\n//    SCC.build();\n//    vector<int>order(N,-1);\n//    int id  = 0;\n//    for( auto  v : TopologicalSort(directed_edge,-1)){\n//        order[v] = id++;\n//    }\n//    if(SCC.scc_size() != N){\n//        out(\"NO\"); return;\n//    }\n//    out(\"YES\");\n//    for(auto [d,s,t] : tup){\n//        if(d == 1){\n//            ans.emplace_back(s,t);\n//        } else {\n//            if(order[s] < order[t])\n//                ans.emplace_back(s,t);\n//            else\n//                ans.emplace_back(t,s);\n//        }\n//    }\n//    for(auto[s,t] : ans)\n//        cout << s + 1 << \" \" << t + 1 << endl;\n//    return;\n//}\nvoid yebi(){\n    int N,Q;\n    cin >> N >> Q;\n    vector<vector<int>>edge(N);\n    rep(_,Q){\n        int s,t; cin >> s >> t;\n        edge[s].push_back(t);\n    }\n    vector<int>order;\n    for(auto v : TopologicalSort(edge)){\n        order.push_back(v);\n    }\n    out(order,\"\\n\");\n}\nsigned main(){\n    fast_io();\n    int Q = 1;\n    //cin >> Q;\n    yebi(); return 0;\n    //while(Q--){solve();}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y)\n\nstatic const int MAX = 10000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while(!q.empty()) {\n    int u = q.front();\n    q.pop();\n    out.push_back(u);\n    rep(i, 0, G[u].size()) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n};\n\nvoid tsort() {\n  rep(i, 0, N)  {\n    indeg[i] = 0;\n  }\n\n  rep(u, 0, N)  {\n    rep(i, 0, G[u].size()) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  rep(u, 0, N)  {\n    if (indeg[u] == 0 && !V[u]) bfs(u);\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n};\n\nint main() {\n  int s, t, M;\n  cin >> N >> M;\n\n  rep(i, 0, N) {\n    V[i] = false;\n  }\n\n  rep(i, 0, M) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\n// O(|V|+|E|)\nclass Graph{\n    public:\n    ll size;\n    vector<vector<ll> > g;\n    vector<bool> visited;\n    vector<ll> indeg;\n\n    // sorted by topological sort\n    vector<ll> sorted;\n\n    Graph(ll n){\n        size = n;\n        g = vector<vector<ll> >(size);\n        visited = vector<bool>(size);\n        indeg = vector<ll>(size);\n    }\n\n    void add_edge(ll x, ll y){\n        g[x].push_back(y);  // x -> y\n        indeg[y]++;\n    }\n\n    void bfs(ll s){\n        queue<ll> Q; // v, dist\n        visited[s] = true;\n        Q.push(s);\n        while(!Q.empty()){\n            ll u = Q.front(); Q.pop();\n            sorted.push_back(u);\n            for(ll v: g[u]){\n                indeg[v]--;\n                if(indeg[v] == 0 && !visited[v]){\n                    visited[v] = true;\n                    Q.push(v);\n                }\n            }\n        }\n    }\n\n    // O(|E|log|V|)\n    vector<ll> topological_sort(){\n        for(ll s=0;s<size;s++){\n            if(indeg[s] == 0 && !visited[s]) bfs(s);\n        }\n        return sorted;\n    }\n};\n\n// GRL_4_B: verified\nint main(){\n    ll V, E; cin >> V >> E;\n    Graph graph(V); \n    for(ll i=0;i<E;i++){\n        ll s, t; cin >> s >> t;\n        graph.add_edge(s, t);\n    }\n    vector<ll> sorted = graph.topological_sort();\n    for(ll v: sorted) cout << v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <tuple>\n#include <stdio.h>\n#include <bitset>\n#include <limits.h>\n#include <complex>\n#include <deque>\n#include <iomanip>\n#include <list>\n#include <cstring>\nusing namespace std;\n#define pi pair<int,int>\n#define pl pair<long long,long long>\n#define chmax(a,b) (a<b ? a=b:0)\n#define chmin(a,b) (a>b ? a=b:0)\n#define en cout << endl //セミコロンつけろ\n//#define MM 1000000000\n//#define MOD MM+7\ntypedef long long ll;\nconst int MM = 1e9;\nconst int MOD = MM+7;\nconst long double PI = acos(-1);\nconst long long INF = 1e15;\nint dx[8] = {-1,0,1,0,-1,-1,1,1};\nint dy[8] = {0,-1,0,1,-1,1,1,-1};\n// 'A' = 65, 'Z' = 90, 'a' = 97, 'z' = 122\n\ntemplate<typename T> //最大公約数\nT GCD(T u,T v){\n    return v ? GCD(v,u%v) : u;\n}\ntemplate<typename T> //最小公倍数\nT LCM(T x,T y){\n    T gc = GCD(x,y);\n    return x*y/gc;\n}\n\nstruct edge\n{\n    int to, cost;\n};\n\nvector<vector<int> > g;\nvector<int> isVisited, out;\nvoid Topological(int pos){\n    isVisited[pos] = true;\n    for (int i = 0; i < g[pos].size(); i++){\n        if (!isVisited[g[pos][i]]){\n            Topological(g[pos][i]);\n        }\n    }\n    out.push_back(pos);\n}\n\nint main(){\n    int V, E; cin >> V >> E;\n    g.resize(V);\n    isVisited.resize(V, 0);\n    vector<int> IsVisited(V, 0);\n    for (int i = 0; i < E; i++){\n        int s, t; cin >> s >> t;\n        g[s].push_back(t);\n    }\n    for (int i = 0; i < V; i++){\n        if (isVisited[i]) continue;\n        Topological(i);\n    }\n    reverse(out.begin(), out.end());\n    for (int i = 0; i < out.size(); i++){\n        cout << out[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int MAXN = 100010 ;\nint n, m;\nint in[MAXN];\nbool vis[MAXN];\nvector<int> edge[MAXN];\nqueue<int> q;\nint main()\n{\n\tmemset(vis, false, sizeof(vis));\n\tcin >> n >> m;\n\tfor (int i = 1, s, t; i <= m; ++i)\n\t{\n\t\tcin >> s >> t;\n\t\tedge[s].push_back(t);\n\t\tin[t] ++;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tif (in[i] == 0 && ! vis[i])\n\t\t{\n\t\t\tvis[i] = true;\n\t\t\tq.push(i);\n\t\t}\n\twhile (! q.empty())\n\t{\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tcout << cur << endl;\n\t\tfor (int i = 0; i < edge[cur].size(); ++i)\n\t\t{\n\t\t\tint v = edge[cur][i];\n\t\t\tin[v] -- ;\n\t\t\tif (in[v] == 0 && ! vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7/*998244353*/;\nconst ll INF = 1LL << 60;\nll mod_pow(ll, ll, ll); ll mod_fact(ll, ll); ll mod_inv(ll, ll); ll gcd(ll, ll); ll lcm(ll, ll);\n//\nint main(){\n    int v, e;\n    cin >> v >> e;\n    vector<vector<int>> graph(v, vector<int>());\n    vector<int> deg(v);\n    for(int i = 0; i < e; i++){\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        deg[b]++;\n    }\n    vector<int> topological;\n    queue<int> q;\n    for(int i = 0; i < v; i++) if(!deg[i]) q.push(i);\n    while(!q.empty()){\n        int s = q.front();\n        topological.push_back(s);\n        q.pop();\n        for(auto to: graph[s]){\n            deg[to]--;\n            if(!deg[to]) q.push(to);\n        }\n    }\n    for(int i = 0; i < v; i++) cout << topological[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nvector<int> color(10005,0),indeg(10005,0);\nvector<vector<int>> G(10005,vector<int>(0));\nlist<int> ans;\n\nvoid bfs(int s){\n    queue<int> Q;\n    Q.push(s);\n    color[s]=1;\n    while(!Q.empty()){\n        int u=Q.front();\n        Q.pop();\n        ans.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&color[v]==0){\n                color[v]=1;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n\n    for(int i=0;i<n;i++){\n        if(indeg[i]==0&&color[i]==0) bfs(i);\n    }\n}\n\nint main(){\n    int a,b;\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        cin>>a>>b;\n        G[a].push_back(b);\n    }\n    \n    tsort();\n\n    for(auto i=ans.begin();i!=ans.end();i++){\n        cout<<*i<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1LL << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n\n  for (int u = 0; u < N; u++) {\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) {\n      bfs(u);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  Graph(u32 V);\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph(u32 V) {\n  edge_num = 0;\n  vertex_num = V;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph(V);\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100] = {};\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      //if( not ( 1 <= id[i] and id[i] <= V ) ) exit(1);\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int INFTY = 1 << 29;\n\nvector<int> g[MAX];\nlist<int> out;\nbool v[MAX];\nint n;\nint deg[MAX];\n\nvoid bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\tv[s] = true;\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\n\t\tfor (int i = 0; i < g[u].size(); i++) {\n\t\t\tint w = g[u][i];\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] == 0 && !v[w]) {\n\t\t\t\tv[w] = true;\n\t\t\t\tq.push(w);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort()\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tdeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < n; u++) {\n\t\tfor (int i = 0; i < g[u].size(); i++) {\n\t\t\tint w = g[u][i];\n\t\t\tdeg[w]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < n; u++) {\n\t\tif (deg[u] == 0 && !v[u]) bfs(u);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main()\n{\n\tint s, t, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) v[i] = false;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n\n#include <cstdint>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <string>\n#include <vector>\n\nconstexpr int32_t kMaxNumberOfVertices = 10000;\nconstexpr int32_t kInvalidIndex = -1;\n\nvoid CallTopologicalSort(std::istream &input_stream);\n\nstruct Vertex {\n  bool explored{false};\n  std::vector<int32_t> next;\n};\n\nclass TopologicalSort {\n public:\n  TopologicalSort();\n  ~TopologicalSort();\n  void ConfigureVertices(const int32_t number_of_vertices);\n  void AddVertex(const int32_t from_index, const int32_t to_index);\n  void Sort();\n  void Print();\n\n private:\n  void Dfs(std::vector<int32_t> chain);\n  int32_t GetUnexploredVertexIndex() const;\n\n private:\n  int32_t number_of_vertices_;\n  Vertex vertices_[kMaxNumberOfVertices];\n  std::vector<int32_t> chain_;\n  std::list<int32_t> sorted_result_;\n};\n\nvoid CallTopologicalSort(std::istream &input_stream) {\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  TopologicalSort *topological_sort = new TopologicalSort();\n  int32_t number_of_vertices, number_of_edges;\n  input_stream >> number_of_vertices >> number_of_edges;\n  topological_sort->ConfigureVertices(number_of_vertices);\n  for (int32_t i = 0; i < number_of_edges; ++i) {\n    int32_t vertex_from, vertex_to;\n    input_stream >> vertex_from >> vertex_to;\n    topological_sort->AddVertex(vertex_from, vertex_to);\n  }\n  topological_sort->Sort();\n  topological_sort->Print();\n  delete topological_sort;\n}\n\nTopologicalSort::TopologicalSort() : number_of_vertices_(0) {}\n\nTopologicalSort::~TopologicalSort() {}\n\nvoid TopologicalSort::ConfigureVertices(const int32_t number_of_vertices) {\n  number_of_vertices_ = number_of_vertices;\n}\n\nvoid TopologicalSort::AddVertex(const int32_t from_index, const int32_t to_index) {\n  vertices_[from_index].next.push_back(to_index);\n}\n\nvoid TopologicalSort::Sort() {\n  sorted_result_.clear();\n  chain_.clear();\n\n  while (true) {\n    const int32_t start_index = GetUnexploredVertexIndex();\n    if (start_index == kInvalidIndex) {\n      break;\n    }\n    chain_.push_back(start_index);\n    Dfs(chain_);\n  }\n}\n\nint32_t TopologicalSort::GetUnexploredVertexIndex() const {\n  int32_t unexplored = kInvalidIndex;\n  for (int32_t i = 0; i < number_of_vertices_; ++i) {\n    if (!vertices_[i].explored) {\n      unexplored = i;\n      break;\n    }\n  }\n  return unexplored;\n}\n\nvoid TopologicalSort::Dfs(std::vector<int32_t> chain) {\n  const int32_t target = chain.back();\n  vertices_[target].explored = true;\n  for (const int32_t next_index : vertices_[target].next) {\n    if (vertices_[next_index].explored) {\n      // DO NOTHING\n    } else {\n      chain.push_back(next_index);\n      Dfs(chain);\n      chain.pop_back();\n    }\n  }\n  sorted_result_.push_front(target);\n}\n\nvoid TopologicalSort::Print() {\n  for (std::list<int32_t>::iterator itr = sorted_result_.begin(); itr != sorted_result_.end(); ++itr) {\n    std::cout << *itr << std::endl;\n  }\n}\n\nint main() {\n  try {\n    CallTopologicalSort(std::cin);\n  } catch (...) {\n    std::cerr << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int WH = 0;\nconst int GR = 1;\n\nint size_v, size_e;\nvector<int> G[10100];\nvector<int> indeg(10100, 0);\nvector<int> color(10100, WH);\nqueue<int> Q;\nvector<int> out;\n\n\nvoid bfs(int s) {\n    Q.push(s);\n    color[s] = GR;\n    for (; Q.empty() == false; ) {\n        int u = Q.front(); Q.pop();\n        out.push_back(u);\n\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            if (color[v] == WH) {\n                indeg[v]--;\n                if (indeg[v] == 0) {\n                    Q.push(v);\n                    color[v] = GR;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> size_v >> size_e;\n\n    for (int i = 0; i < size_e; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    for (int u = 0; u < size_v; u++) {\n        if (indeg[u] == 0 && color[u] == WH) {\n            bfs(u);\n        }\n    }\n\n    for (int i = 0; i < out.size(); i++) {\n        cout << out[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    for(int k = 1; k <= 3; ++k) {\n      for(int i = 0; i < graph.adjust_size(k); ++i) {\n        std::cout << graph.adjust(k)[i].from() << ' ' << graph.adjust(k)[i].to() << std::endl;\n      }\n    }\n    int id[10100];\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      std::cout << id[i] - 1<< std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,N) for(int i = 0;i < N;i++)\n#define pb push_back\n\nvector<int>E[10005];\nint N;\nbool flag[10005] = {0};\nvector<int>out;\n\nvoid dfs(int v) {\n  flag[v] = true;\n  Rep(i,E[v].size()) {\n    int nv = E[v][i];\n    if(!flag[nv])dfs(nv);\n  }\n  out.pb(v);\n}\n\nint main()\n{\n  int M,s,t;\n  cin >> N >> M;\n  while(M--) {\n    cin >> s >> t;\n    E[s].pb(t);\n  }\n  Rep(i,N) {\n    if(!flag[i])dfs(i);\n  }\n  reverse(out.begin(),out.end());\n  Rep(i,N)cout << out[i] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[9]={1,0,-1,0,1,1,-1,-1,0};\nconst ll dx[9]={0,-1,0,1,1,-1,1,-1,0};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nvl topsort(vvl &g){\n    ll n=g.size();\n    vl ans,ind(n);\n    rep(i,n)for(auto e:g[i])ind[e]++;\n    queue<ll> que;\n    rep(i,n)if(!ind[i])que.push(i);\n    while(!que.empty()){\n        ll v=que.front();que.pop();\n        ans.pb(v);\n        for(auto nv:g[v]){\n            ind[nv]--;if(!ind[nv])que.push(nv);\n        }\n    }\n    return ans;\n}\nint main(){\n    ll n,m;cin >> n >>m;\n    vvl g(n);rep(i,m){\n        ll a,b;cin >> a >> b;\n        g[a].pb(b);\n    }\n    vl ans=topsort(g);\n    for(auto p:ans)cout << p <<endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(), (g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define INF 1 << 30\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef long long ll;\n\nstatic const int MAX = 100000;\n\n\nvector<int> G[MAX];\nvector<int> out;\nint V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        out.push_back(u);\n\n        rep(i, G[u].size()) {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && V[v] == 0) {\n                V[v] = 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\n\nvoid tsort(void) {\n    rep(i, N) {\n        V[i] = 0;\n        indeg[i] = 0;\n    }\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            indeg[G[i][j]]++;\n        }\n    }\n\n    rep(i, N) {\n        if (indeg[i] == 0 && V[i] == 0) bfs(i);\n    }\n}\n\n\nint main(void) {\n    int M, s, t;\n    scanf(\"%d %d\", &N, &M);\n\n    rep(i, M) {\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    rep(i, out.size()) printf(\"%d\\n\", out[i]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX]; //???DAG\nlist<int> out; // ?§£??¨????????????????????????????????¨\nbool V[MAX];  //\nint N; // ????????°\n\nvoid dfs(int u){\n    V[u] = true;\n    for(int i = 0; i < G[u].size(); i++){\n        int v = G[u][i]; // ??????????????????????????????\n        if(!V[v]) dfs(v);???// ??±???????????¢?´¢??§?????°????????????\n    }\n    //??? ????????¨?????????????????????????´?????????????????????§\n    //  ??????????????¢?´¢????§???????????????????????????§????´??????????\n    out.push_front(u);\n}\n\nint main(){\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++){\n        if(!V[i]) dfs(i);\n    }\n\n    for( list<int>::iterator it = out.begin(); it != out.end(); it++)\n        cout << *it << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    auto tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in.empty()) tp.clear(); // exist loop\n    tmp = in;\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.dfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 10000;\nvector<int> V[MAX];\nint NIL = -1;\n\nint color[MAX];\nint WHITE = 0;\nint GRAY = 1;\n\nvector<int> ans;\n\nvoid dfs(int u) {\n\n\tcolor[u] = GRAY;\n\tfor (int i = 0; i < (int) V[u].size(); ++i) {\n\t\tint next = V[u][i];\n\t\tif (color[next] == WHITE)\n\t\t\tdfs(next);\n\t}\n\tans.push_back(u);\n}\n\nint main() {\n\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tcolor[i] = WHITE;\n\t}\n\n\tfor (int i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tV[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tif (color[i] == WHITE)\n\t\t\tdfs(i);\n\t}\n\n\tfor (auto itr = ans.rbegin(); itr != ans.rend(); ++itr) {\n\t\tcout << *itr << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define N 10001\nvector<int> A[N];\nvector<int> sorted;\nint color[N];\nint indeg[N];\n\nvoid topologicalsort(int root) {\n    queue<int> Q;\n    Q.push(root);\n    color[root] = 1;\n    while (!Q.empty()) {\n        int node = Q.front();\n        Q.pop();\n        sorted.push_back(node);\n        for (vector<int>::iterator it=A[node].begin(); it != A[node].end(); it++) {\n            indeg[*it]--;\n            if (color[*it] == 0 && indeg[*it] == 0) {\n                color[*it] = 1;\n                Q.push(*it);\n            }\n        }\n    }\n}\n\nint main() {\n    int n, e;\n    cin >> n >> e;\n\n    for (int i = 0; i < n; i++) {\n        color[i] = 0;\n        indeg[i] = 0;\n    }\n\n    int v1, v2;\n    for (int i = 0; i < e; i++) {\n        cin >> v1 >> v2;\n        A[v1].push_back(v2);\n        indeg[v2]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (color[i] == 0 && indeg[i] == 0) {\n            topologicalsort(i);\n        }\n    }\n\n    for (int i = 0; i < sorted.size(); i++) {\n        cout << sorted[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\n\nint n,m;\nbool vis[10005];\nvector<int>v,G[10005];\n\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (auto p:G[u]) {\n\t\tif (!vis[p]) dfs(p);\n\t}\n\tv.pb(u);\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor (int i=0;i<m;i++) {\n\t\tint s,t; cin>>s>>t;\n\t\tG[s].pb(t);\n\t}\n\tfor (int i=0;i<n;i++) if (!vis[i]) dfs(i);\n\tfor (int i=v.size()-1;i>=0;i--) cout<<v[i]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int V_MAX=100000;\nconst int E_MAX=100000;\n\nvector<int> G[V_MAX];\nint used[V_MAX]={};\nint flag=false;\nvector<int> sorted;\n\nvoid dfs(int s){\n\tif(used[s]==1){return;}\n\tused[s]=2;\n\tfor (int i=0;i<G[s].size();i++){\n\t\tif(used[G[s][i]]==2){\n\t\t\tflag=true;\n\t\t}\n\t\tif(used[G[s][i]]==0)\n\t\tdfs(G[s][i]);\n\t}\n\tused[s]=1;\n\tsorted.push_back(s);\n\t\n}\n\nint main(){\n\tint V,E,s,t;\n\tcin>> V >> E;\n\tfor (int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\t\n\tfor(int i=0;i<V;i++){\n\t\tdfs(i);\n\t}\n\t\n\tfor(int i=sorted.size()-1;i>-1;i--){\n\t\tcout << sorted[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  vector<int> v[n];\n  int c[n];mem(c);\n  while(m--) {\n    int x,y;\n    cin >> x >> y;\n    v[x].pb(y);\n    c[y]++;\n  }\n  queue<int> que;\n  rep(i,n) {\n    if(!c[i]) que.push(i);\n  }\n  while(!que.empty()) {\n    int x=que.front();que.pop();\n    pr(x);\n    rep(i,v[x].size()) {\n      int y=v[x][i];\n      c[y]--;\n      if(!c[y]) que.push(y);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// VI tsort(VVI g) {\n//   int n = g.size();\n//   vector<bool> used(n, false);\n//   vector<int> ans;\n//\n//   function<void(int)> dfs = [&](int u) {\n//     if(used[u]) return;\n//     used[u] = true;\n//     for(auto& i: g[u]) dfs(i);\n//     ans.push_back(u);\n//   };\n//\n//   for(int i=0; i<n; ++i) dfs(i);\n//   reverse(ans.begin(), ans.end());\n//   return ans;\n// }\n\nVI tsort(VVI g) {\n  const int n = g.size();\n  VI h(n, 0);\n  REP(i, n) for(int j: g[i]) h[j]++;\n\n  stack<int> st;\n  REP(i, n) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  return ans;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  VVI g(n, VI(0));\n  REP(i, m) {\n    int a, b;\n    cin >> a >> b;\n    g[a].PB(b);\n    g[b].PB(a);\n  }\n\n  VI ans = tsort(g);\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <math.h>\n#include <stack>\n#include <deque>\n\n#define mp                  make_pair\n#define F                   first\n#define S                   second\n#define pb                  push_back\n#define FOR(i,j,n)          for(int i=j;i<n;i++)\n#define F0R(i,j,n)          for(int i=j;i<=n;i++)\n#define RFOR(i,j,n)         for(int i=n-1;i>=j;i--)\n#define RF0R(i,j,n)         for(int i=n;i>=j;i--)\n#define FOREACH(x,v)        for(auto x:v)\n#define ITFOR(it,v)         for(__typeof(v.begin()) it =v.begin();it!=v.end();++it)\n#define __in_arr__(a,j,n)   FOR(i,j,n)cin >> a[i];\n#define __out_arr__(a,j,n)  FOR(i,j,n)cout << a[i];\n#define LOG                 cout << \"[ !\" << __LINE__ << \"L ] \" << endl;\n#define PLOG(x)             cout << \"[ !\" << __LINE__ << \"L ] \" <<x<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vl;\n\nconst int MAXN = 1e4 + 6.66;\nconst int MAXM = 1e6 + 6.66;\nvi g[MAXN];\nint d[MAXN];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);cout.tie(NULL);\n  int n,m;\n  cin >> n >> m;\n  FOR(i,0,m) {\n    int x,y;cin >> x >> y;\n    d[x]++;\n    g[y].pb(x);\n  }\n//  F0R(i,1,n) {\n//    sort(g[i].begin(),g[i].end());\n//    reverse(g[i].begin(),g[i].end());\n//  }\n  queue<int> q;\n  stack<int> ans;\n  RFOR(i,0,n) if( d[i]==0 ) q.push(i);\n  while(q.size()) {\n    ans.push(q.front());\n    int i = q.front();q.pop();\n    for(auto x : g[i])\n    {\n      d[x]--;\n      if(!d[x]) q.push(x);\n    }\n  }\n  if(ans.size()!=n) cout << \"Sandro fails.\" << endl;\n  else\n    while(ans.size()) cout << ans.top() << \"\\n\",ans.pop();\n  cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// VI tsort(VVI g) {\n//   int n = g.size();\n//   vector<bool> used(n, false);\n//   vector<int> ans;\n//\n//   function<void(int)> dfs = [&](int u) {\n//     if(used[u]) return;\n//     used[u] = true;\n//     for(auto& i: g[u]) dfs(i);\n//     ans.push_back(u);\n//   };\n//\n//   for(int i=0; i<n; ++i) dfs(i);\n//   reverse(ans.begin(), ans.end());\n//   return ans;\n// }\n\nVI tsort(VVI g) {\n  const int n = g.size();\n  VI h(n, 0);\n  REP(i, n) for(int j: g[i]) h[j]++;\n\n  stack<int> st;\n  REP(i, n) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  return ans;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  VVI g(n, VI(0));\n  REP(i, m) {\n    int a, b;\n    cin >> a >> b;\n    g[a].PB(b);\n  }\n\n  VI ans = tsort(g);\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)\n#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)\n#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)\n#define RREP(i, n) for (decltype(n) i = (n) - 1; i >= 0; i--)\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nusing namespace std;\n\n// N, E, S, W\nconst int dx[4] = { 1, 0, -1, 0};\nconst int dy[4] = { 0, 1, 0, -1};\n\nusing LL = long long int;\nusing LD = long double;\n\nconst int INF = (1 << 30) - 1;\nconst LL INF64 = ((LL)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nusing pii = pair<int, int>;\nusing pll = pair<LL, LL>;\nusing pdd = pair<double, double>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<LL>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\n//==============================================\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint v, e;\n\tcin >> v >> e;\n\n\tvvi G(v);\n\tvi indeg(v);\n\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\n\tvi ans;\n\tqueue<int> q;\n\n\tREP(i, v) {\n\t\tif (indeg[i] == 0) q.push(i);\n\t}\n\t\n\twhile(!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\n\t\tans.push_back(u);\n\n\t\tfor (int a : G[u]) {\n\t\t\tindeg[a]--;\n\t\t\tif (indeg[a] == 0) {\n\t\t\t\tq.push(a);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i : ans) cout << i << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst ll INF = 1LL << 60;\nconst ll MOD = 1000000007;\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<vector<int>> G(N);\n    vector<int> deg(N, 0);\n    for (int i = 0; i < M; i++) {\n        int a, b; cin >> a >> b;\n        G[b].push_back(a);\n        deg[a]++;\n    }\n\n    queue<int> que;\n    for (int v = 0; v < N; v++) {\n        if (deg[v] == 0) que.push(v);\n    }\n\n    vector<int> order;\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop();\n        order.push_back(v);\n\n        for (auto nv : G[v]) {\n            deg[nv]--;\n            if (deg[nv] == 0) que.push(nv);\n        }\n    }\n\n    reverse(order.begin(), order.end());\n    for (int v : order) {\n        cout << v << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* GRL_4_B */\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<limits>\nusing namespace std;\nconst int maxn=100001;\nconst int Max_INF=numeric_limits<int>::max();\nint n,m;\nint indeg[maxn];                                //??\\???\nbool visited[maxn];\nvector<int> G[maxn];\nvector<int> out_put;\n\nvoid topological_sort_bfs(int s)\n{\n    queue<int> q;\n    q.push(s);\n    visited[s]=true;\n    while(!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        out_put.push_back(u);\n        for(int i=0;i<G[u].size();++i)\n        {\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !visited[v])\n            {\n                q.push(v);\n                visited[v]=true;\n            }\n        }\n    }\n}\n\nint main()\n{\n    // freopen(\"in.txt\",\"r\",stdin);\n    // freopen(\"out.txt\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n    memset(visited,0,sizeof(visited));\n    memset(indeg,0,sizeof(indeg));\n    for(int i=0;i<m;++i)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v);\n        indeg[v]++;\n    }\n    for(int u=0 ;u < n;++u)\n      if(indeg[u] == 0 && !visited[u])\n        topological_sort_bfs(u);\n    int num=out_put.size();\n    while(num)\n    {\n        printf(\"%d\\n\",out_put[out_put.size()-num]);\n        num--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <queue>\n#include <stack>\n\nconst int vmax = 10005;\nstd::array<std::vector<int>, vmax> adjlist;\nstd::array<int, vmax> indeg;\nstd::array<int, vmax> color;\n\nvoid dfs (int u)\n{\n  if (indeg[u] == 0 && color[u] ==0)\n    {\n      std::cout << u << std::endl;\n      color[u] = 1;\n      for (int i=0; i<adjlist[u].size(); ++i)\n        {\n          indeg[adjlist[u][i]]--;\n          dfs(adjlist[u][i]);\n        }\n    }\n}\n\nvoid dfs_stack (int u)\n{\n  std::stack<int> s;\n  s.push(u);\n\n  while (!s.empty())\n    {\n      u = s.top();\n      s.pop();\n\n      if (indeg[u] == 0 && color[u] ==0)\n        {\n          std::cout << u << std::endl;\n          color[u] = 1;\n          for (int i=0; i<adjlist[u].size(); ++i)\n            {\n              indeg[adjlist[u][i]]--;\n              s.push(adjlist[u][i]);\n            }\n        }\n    }\n}\n\nint main ()\n{\n  int V, E;\n  std::cin >> V >> E;\n\n  indeg.fill(0);\n  int s, t;\n  for (int i=0; i<E; ++i)\n    {\n      std::cin >> s >> t;\n      adjlist[s].push_back(t);\n      indeg[t]++;\n    }\n\n  color.fill(0); // 0: not visited, 1: visited\n\n  for (int i=0; i<V; ++i)\n    {\n      // dfs(i);\n      dfs_stack(i);\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\nusing edge_set = unordered_set<int>;\n\nint main() {\n\n    int V, E;\n    cin >> V >> E;\n\n    int count = 0;\n    pair<int, int> order[V];\n    edge_set indeg[V], outdeg[V];\n\n    for (int i = 0; i < V; i++) {\n        order[i].second = i;\n    }\n\n    int s, t;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        indeg[t].insert(s);\n        outdeg[s].insert(t);\n    }\n\n    queue<int> que;\n\n    for (int i = 0; i < V; i++) {\n        if (indeg[i].empty()) {\n            que.push(i);\n        }\n    }\n\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (int v : outdeg[u]) {\n            indeg[v].erase(u);\n            if (indeg[v].empty()) {\n                que.push(v);\n            }\n        }\n        cout << u << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int tgt_;\n\t  Edge(int t){\n\t\t\ttgt_ = t;\n\t  }\n};\n\ntypedef vector<vector<Edge> > Adj_list;\n\nvector<int> topological_sort(Adj_list G){\n\n\t  const int V = G.size();\n\n\t  vector<int> S; // ??\\?????????????????????\n\t  vector<int> inorder(V,0); // ??\\?????????????????????\n\t  \n\t  for(int i=0; i<V; i++) for(Edge& e : G[i]) inorder[e.tgt_]++;\n\t  for(int i=0; i<V; i++) if(inorder[i] == 0) S.push_back(i);\n\n\t  assert(S.size() > 0);\n\n\t  vector<int> topological_order;\n\t  while(S.size()){\n\t\t\tint v = S[S.size()-1]; S.pop_back();\n\t\t\ttopological_order.push_back(v);\n\n\t\t\tfor(int i=G[v].size()-1; i>=0; i--){\n\t\t\t\t  Edge e = G[v][i];\tG[v].pop_back();\n\t\t\t\t  inorder[ e.tgt_ ]--; \n\n\t\t\t\t  if( inorder[e.tgt_] == 0)\n\t\t\t\t\t\tS.push_back( e.tgt_ );\n\t\t\t}\n\t  }\n\t  for(int i=0; i<V; i++) assert(G[i].size()==0);\n\t  return topological_order;\n}\n\n\nint main(){\n\n\t  int V,E; cin >> V >> E;\n\t  Adj_list G(V);\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t; cin >> s >> t;\n\t\t\tG[s].push_back( Edge(t) );\n\t  }\n\t  \n\t  vector<int> ans = topological_sort(G);\n\t  for(int i=0; i<V; i++)\n\t\t\tcout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<functional>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\nvector<int>c[10000];\nbool used[10000];\nvector<int>V;\nvoid DFS(int a) {\n\tused[a] = true;\n\tfor (int i : c[a]) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tV.push_back(a);\n}\nint ans[10000];\nsigned main() {\n\tint a, b; scanf(\"%d%d\", &a, &b);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f; scanf(\"%d%d\", &e, &f);\n\t\tc[f - 1].push_back(e);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tans[V[i]] = i;\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tcout << ans[i];\n\t\tif (i + 1 == a)puts(\"\");\n\t\telse cout << \" \";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\nusing namespace std;\nlist<int> L;    //??????????????????????????????????????????????????????????????????\nbool DAG_check = false;\n\nvoid visit(int n, vector<vector<int>>& graph, vector<int>& mark) {\n\tif (DAG_check == true) {\n\t\treturn;\n\t}\n\tif (mark[n] == 1) {\n\t\tDAG_check = true; return;\n\t}\n\telse {\n\t\tif (mark[n] == 0) {\n\t\t\tmark[n] = 1;\n\t\t\tfor (int i = 0; i < graph[n].size();i++) {\n\t\t\t\tvisit(graph[n][i], graph, mark);\n\t\t\t}\n\t\t\tmark[n] = 2;\n\t\t\tL.emplace_back(n);\n\t\t}\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>> graph(V);\n\tvector<int> mark(V, 0); //????????????????????°    1???????????????????????????2??\\??\\??\\?????????\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tgraph[s].emplace_back(t);\n\t}\n\n\tfor (int i = 0; i < V;i++) {\n\t\tif (mark[i] == 0) {\n\t\t\tvisit(i, graph, mark);\n\t\t}\n\t}\n\n\tfor (int n : L) {\n\t\tcout << n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 10000;\nvector<int> V[MAX];\nint NIL = -1;\n\nint color[MAX];\nint WHITE = 0;\nint GRAY = 1;\n\nvector<int> ans;\n\nvoid dfs(int u) {\n\n\tcolor[u] = GRAY;\n\tfor (int i = 0; i < (int) V[u].size(); ++i) {\n\t\tint next = V[u][i];\n\t\tif (color[next] == WHITE)\n\t\t\tdfs(next);\n\t}\n\tans.push_back(u);\n}\n\nint main() {\n\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tcolor[i] = WHITE;\n\t}\n\n\tfor (int i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tV[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tif (color[i] == WHITE)\n\t\t\tdfs(i);\n\t}\n\n\tfor (auto itr = ans.rbegin(); itr != ans.rend(); ++itr) {\n\t\tcout << *itr << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\nusing namespace std;\n\n#define Getsign(n) ((n > 0) - (n < 0))\n\ntypedef vector<int> Ivec;\ntypedef pair<int, int> Pos;\n\nint main() {\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tvector<vector<int>> graph(v, vector<int>(v, 0));\n\tvector<int> numbers;\n\tfor (int i = 0; v > i; i++) {\n\t\tnumbers.push_back(i);\n\t}\n\tfor (int i = 0; e > i; i++) {\n\t\tint a,b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tgraph[b][a] = 1;\n\t}\n\n\twhile (v) {\n\t\tfor (int i = 0; v > i; i++) {\n\t\t\tif (find(graph[i].begin(), graph[i].end(), 1) == graph[i].end()) {\n\t\t\t\tfor (int j = 0; v > j; j++) {\n\t\t\t\t\tgraph[j][numbers[i]] = 0;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", numbers[i]);\n\n\t\t\t\tnumbers.erase(numbers.begin() + i);\n\t\t\t\tgraph.erase(graph.begin() + i);\n\t\t\t\tv--;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// トポロジカルソート\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int MAX_E = 100000;\n\nconst int NO = 0;\nconst int MID = 1;\nconst int YES = 2;\n\n// 各辺のつながりを格納する動的配列\nvector<int> v_connection[MAX_V];\n// 訪問情報を保持する配列\nint ary_visit[MAX_V];\n// 入力辺の数を格納する配列\nint ary_inputEdge[MAX_V];\n// トポロジカルソートの結果を格納するキュー\nqueue<int> topo_que;\n\nvoid TopologicalSort(int v);\n\nint main(void)\n{\n\n    int n, edge;\n    int first, second;\n\n    cin >> n >> edge;\n\n    for(int i = 0; i < n; i++)\n    {\n        // 配列の初期化\n        ary_inputEdge[i] = 0;\n        ary_visit[i] = NO;\n    }\n\n    for(int i = 0; i < edge; i++)\n    {\n        cin >> first >> second;\n\n        // 入力辺の数を記憶する\n        ary_inputEdge[second]++;\n        // 各辺のつながりを記憶する\n        v_connection[first].push_back(second);\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n        if( ary_visit[i] == NO )\n        {\n            // 頂点を順番に訪れる\n            TopologicalSort(i);\n        }\n    }\n\n    // 結果の表示\n    int size = topo_que.size();\n\n    int *result = new int[size];\n\n    for(int i = size - 1; i >= 0; i--)\n    {\n        int val = topo_que.front();\n        topo_que.pop();\n\n        result[i] = val;\n    }\n\n    for(int i = 0; i < size; i++)\n    {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    return 0;\n}\n\n// トポロジカルソートを実施するためのメソッド\n// v : 訪問する頂点\nvoid TopologicalSort(int v)\n{\n    int connect_v;\n\n    if( ary_inputEdge[v] >= 0 && ary_visit[v] == NO )\n    {\n        // 訪問途中を記録\n        ary_visit[v] = MID;\n\n        for(unsigned int i = 0; i < v_connection[v].size(); i++ )\n        {\n            // 接続先の頂点No.の格納\n            connect_v = v_connection[v][i];\n\n            // vから接続している頂点の入力辺の次数を減算する\n            ary_inputEdge[connect_v]--;\n            // 接続している頂点を順番に訪れる\n            TopologicalSort(connect_v);\n        }\n    }\n\n    //if( ary_inputEdge[v] == 0 )\n    if( ary_visit[v] == MID )\n    {\n        // 入力辺が無くなった頂点をトポロジカルキューに追加する\n        topo_que.push(v);\n        ary_inputEdge[v]--;\n        ary_visit[v] = YES;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[10000];\nlist<int> L;\nbool checked[10000];\n\nvoid visit(int n)\n{\n\tif (!checked[n])\n\t{\n\t\tchecked[n] = true;\n\t\tfor (auto& m : G[n])\n\t\t{\n\t\t\tvisit(m);\n\t\t}\n\t\tL.push_front(n);\n\t}\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E;\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tG[u].push_back(v);\n\t}\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tvisit(i);\n\t}\n\n\tfor (auto& n : L)\n\t{\n\t\tprintf(\"%d\\n\", n);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MAX_V 10000\n\ntypedef int int32_t;\n\n// ?????????topological sort???????????????\n\nint main(void) {\n    int v, e;\n    vector<int> g[MAX_V];\n    int n_in[MAX_V] = {};\n\n    scanf(\"%d %d\", &v, &e);\n    for (int i = 0; i < e; i++) {\n        int t, u;\n        scanf(\"%d %d\", &t, &u);\n        g[t].push_back(u);\n        n_in[u]++;\n    }\n\n    // topological sort\n    vector<int> s;\n    for (int i = 0; i < v; i++) {\n        if (n_in[i] == 0) {\n            s.push_back(i);\n        }\n    }\n\n    vector<int> done;\n    while (!s.empty()) {\n        int t = s.back();\n        s.pop_back();\n        done.push_back(t);\n        while (!g[t].empty()) {\n            int u = g[t].back();\n            g[t].pop_back();\n            if (--n_in[u] == 0) {\n                s.push_back(u);\n            }\n        }\n    }\n\n    for (int i = 0; i < v; i++) {\n        printf(\"%d\\n\", done[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\nusing UG = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nvoid tsort_dfs(int u,vector<int> &graph,vector<bool> &visited,WG<T> &g){\n\n  if(visited[u]) return;\n  visited[u] = true;\n  for(int i=0;i<g[u].size();i++){\n    tsort_dfs(g[u][i].to,graph,visited,g);\n  }\n  graph.PB(u);\n}\n\ntemplate< typename T>\nvector<int> tsort(WG<T> &g){\n  vector<int> graph;\n  vector<bool> visited(g.size(),false);\n  for(int i=0;i<g.size();i++){\n    tsort_dfs(i,graph,visited,g);\n  }\n  reverse(all(graph));\n  return graph;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,m;\n  cin>>n>>m;\n  WG<int> es(n);\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    es[a].PB(edge<int>(b,0));\n  }\n\n  vi res=tsort(es);\n  for(auto x:res){\n    cout<<x<<endl;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(i, n) for(int i=0; i<=n; i++)\n#define repr(i, n) for(int i=n; i>0; i--)\n#define REPR(i, n) for(int i=n; i>=0; i--)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\ntemplate<class T> void puts(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nbool visited[10010];\nvector<vector<int>> g;\nstack<int> st;\n\nvoid topological_sort(int i) {\n    visited[i] = true;\n    for (int j: g[i]) {\n        if (!visited[j]) topological_sort(j);\n    }\n    st.push(i);\n}\n\nint main() {\n    int V, E; cin >> V >> E;\n    g.resize(V);\n    rep(i, E) {\n        int u, v; cin >> u >> v;\n        g[u].pb(v);\n    }\n\n    rep(i, V) {\n        if (!visited[i]) topological_sort(i);\n    }\n\n    while (!st.empty()) {\n        cout << st.top() << endl;\n        st.pop();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct TopologicalSort{\n  int n;\n  vector<set<int> > G;\n  vector<int> indeg,V,p;\n  TopologicalSort(){}\n  TopologicalSort(int n):n(n){init();}\n  \n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    indeg.clear();\n    V.clear();\n    p.clear();\n    G.resize(n);\n    indeg.resize(n);\n    V.resize(n);\n    p.resize(n);\n  }\n\n  void add_edge(int s,int t){\n    G[s].insert(t);\n  }\n  \n  void bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n      int u=q.front();q.pop();\n      p.push_back(u);\n      for(int v:G[u]){\n\tindeg[v]--;\n\tif(indeg[v]==0&&!V[v]){\n\t  V[v]=1;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  \n  void tsort(){\n    fill(V.begin(),V.end(),0);\n    fill(indeg.begin(),indeg.end(),0);\n    for(int u=0;u<n;u++)\n      for(int v:G[u])\n\tindeg[v]++;\n    for(int u=0;u<n;u++)\n      if(indeg[u]==0&&!V[u]) bfs(u);\n    for(int i=0;i<n;i++)\n      cout<<p[i]<<endl;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  TopologicalSort ts(n);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    ts.add_edge(s,t);\n  }\n  ts.tsort();\n  return 0;\n}\n\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nvoid rec(int n,vector<int>& visited,vector<int>& job,vector<vector<int>>& G){\n    if(visited[n]) return;\n    visited[n] = 1;\n    for(auto next:G[n]){\n        rec(next,visited,job,G);\n    }\n    job.push_back(n);\n}\nvoid solve(){\n    int V,E; cin >> V >> E;\n    vector<vector<int>> G(V);\n    for(int i = 0; i < E;i++){\n        int s,t; cin >> s >> t;\n//        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    vector<int> job,visited(V);\n    for(int i = 0; i < V;i++){\n        //if(visited[i]) continue;\n        rec(i,visited,job,G);\n    }\n    for(auto J:job){\n        cout << J << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s)\n{\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty())\n    {\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v])\n            {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort()\n{\n    for(int i=0; i<N; i++) indeg[i] = 0;\n    for(int u=0; u<N; u++)\n    {\n        for(int i=0; i<G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    for(int u=0; u<N; u++) if(indeg[u]==0 && !V[u]) bfs(u);\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++) cout << *it << endl;\n}\n\nint main()\n{\n    int s, t, M;\n    cin >> N >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++)\n    {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <array>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <utility>\n#include <functional>\n\nusing namespace std;\nusing lli = long long int;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (lli i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (lli i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nlli sv, se;\nvector<lli> e[100001];\n\nvector<lli> ts;\nbool seen[100001];\n\nvoid dfs(lli u) {\n  if (seen[u]) return;\n  seen[u] = true;\n  for (lli v : e[u]) {\n    dfs(v);\n  }\n  ts.push_back(u);\n}\n\nint main() {\n  cin >> sv >> se;\n  for (lli i=0; i<se; ++i) {\n    lli u, v; cin >> u >> v;\n    e[u].push_back(v);\n  }\n  for (lli u=0; u<sv; ++u) dfs(u);\n  for (lli i=sv-1; i>=0; --i) cout << ts[i] << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (bfs) ------ //\nvector<int> tsort(Graph &g) {\n    int n = g.size();\n    vector<int> indeg(n, 0), visited(n, 0), ord;\n    for (int i = 0; i < n; i++) for (Edge &e : g[i]) indeg[e.dst]++;\n    auto bfs = [&](int s){\n        queue<int> q; q.push(s); visited[s] = true;\n        while (!q.empty()) {\n            int u = q.front(); q.pop(); ord.push_back(u);\n            for (Edge &e : g[u]) {\n                int v = e.dst;\n                if (--indeg[v] == 0 && !visited[v]) { visited[v] = true; q.push(v); }\n            }\n        }\n    };\n    for (int i = 0; i < n; i++) if (indeg[i] == 0 && !visited[i]) bfs(i);\n    return ord;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord = tsort(g);\n    for (int x : ord) cout << x << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <fstream>\n#include <bitset>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long INF = 1LL << 60;\nconst long long MOD = 1000000007LL;\nconst long long MAX = 500000LL;\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef  long long ll;\n\n\nint main()\n{\n\tll N, M;\n\tcin >> N >> M;\n\tvector<vector<ll>> g(N);\n\tvector<ll> idg(N, 0);\n\tvector<ll> dp(N, -1);\n\tvector<ll> to;\n\tfor (ll i = 0; i < M; i++) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\n\t\tg[a].push_back(b);\n\t\tidg[b]++;\n\t}\n\tqueue<ll> q;\n\tfor (ll i = 0; i < N; i++) {\n\t\tif (idg[i] == 0) {\n\t\t\tdp[i] = 0;\n\t\t\tq.push(i);\n\t\t\tto.push_back(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tll x = q.front();\n\t\tq.pop();\n\t\tfor (ll xx : g[x]) {\n\t\t\tidg[xx]--;\n\t\t\tif (idg[xx] == 0) {\n\t\t\t\tq.push(xx);\n\t\t\t\tto.push_back(xx);\n\t\t\t}\n\t\t}\n\t}\n\tfor (ll i = 0; i < to.size(); i++) {\n\t\tcout << to[i] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nvector<int> G[MAX_N];\nint color[MAX_N];\ndeque<int> L;\nbool flag;\t//????????????\n\nvoid visit(int u)\n{\n\tif(color[u] == 0){\n\t\tflag = true;\t//DAG??§??????\n\t\treturn;\n\t}\n\tif(color[u] == 1){\n\t\treturn;\n\t}\n\tcolor[u] = 0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tvisit(G[u][i]);\n\t}\n\tcolor[u] = 1;\n\tL.push_front(u);\n}\n\nint main()\n{\n\tint n;\n\tint m;\n\tcin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcolor[i] = -1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(color[i] == -1){\n\t\t\tflag = false;\n\t\t\tvisit(i);\n\t\t}\n\t\tif(flag == true){\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d\\n\",L[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\nvector<int> edge[110];\nint h[110];\n\nint V;\nint E;\n\nint main()\n{\n    cin >> V;\n    cin >> E;\n\n    for(int i = 0;i < E;i++)\n    {\n        int s;\n        int t;\n\n        cin >> s >> t;\n\n        edge[s].push_back(t);\n\n\n        h[t]++;\n    }\n\n    stack<int> st;\n\n    for(int i = 0;i < V;i++)\n    {\n        if(h[i] == 0) st.push(i);\n    }\n\n    vector<int> topolo;\n\n    while(!st.empty())\n    {\n        int v = st.top();\n        st.pop();\n\n        topolo.push_back(v);\n\n        for(int to : edge[v])\n        {\n            h[to]--;\n\n            if(h[to] == 0)\n            {\n                st.push(to);\n            }\n        }\n    }\n\n    for(int ans : topolo)\n    {\n        cout << ans << endl;\n    }\n\n    return 0;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    auto tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in.empty()) tp.clear(); // exist loop\n    tmp = in;\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.bfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T = long long>\nstruct edge {\n\tT len;\n\tint from;\n\tint to;\n\tbool operator<(const edge a) const {\n\t\tif(len != a.len) return len < a.len;\n\t\tif(from != a.from) return from < a.from;\n\t\treturn to < a.to;\n\t}\n\tbool operator>(const edge a) const {\n\t\tif(len != a.len) return len > a.len;\n\t\tif(from != a.from) return from > a.from;\n\t\treturn to > a.to;\n\t}\n};\ntemplate <class T = long long>\nstruct graph {\t// 0-indexed\n\tT const INF = numeric_limits<T>::max() / 3;\n\tvector<vector<edge<T>>> edges;\n\tbool directed, weight;\n\tint ver;\n\n\t// constructor\n\tgraph(int vertex, bool direction = 0, bool weigh = 0) : edges(vertex) {\n\t\tver = vertex;\n\t\tdirected = direction;\n\t\tweight = weigh;\n\t\tedges.resize(vertex);\n\t}\n\n\t//辺の追加 (0-indexed)\n\tvoid update(int from, int to, T len = 1, bool direction = 1) {\n\t\tedge<T> e;\n\t\te.len = len;\n\t\te.from = from;\n\t\te.to = to;\n\t\tedges[from].push_back(e);\n\t\tif(!direction) {\n\t\t\tswap(e.to, e.from);\n\t\t\tedges[to].push_back(e);\n\t\t}\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(int edge_num, int index = 1) {\n\t\tfor(int i = 0; i < edge_num; i++) {\n\t\t\tint a;\n\t\t\tint b;\n\t\t\tcin >> a >> b;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tT c;\n\t\t\tif(weight)\n\t\t\t\tcin >> c;\n\t\t\telse\n\t\t\t\tc = 1;\n\t\t\tupdate(a, b, c, directed);\n\t\t}\n\t}\n\n\t// 辺の長さを全て1とみたときの単一始点最短経路 (無理なときはINF)\n\tvector<T> bfs(int start) {\n\t\t// https://atcoder.jp/contests/abc007/submissions/me\n\t\tvector<T> ret(ver, INF);\n\t\tqueue<int> q;\n\t\tq.push(start);\n\t\tret[start] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != INF) continue;\n\t\t\t\tq.push(e.to);\n\t\t\t\tret[e.to] = ret[now] + 1;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//長さが負のpathがないときの単一始点最短経路<vll> O((ver)log(ver)+(edge))\n\tvector<T> dijkstra(int start) {\n\t\tvector<T> ret(ver, (T)INF);\n\t\t// pqup<pair<T, int>> p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //{dist,place}\n\t\tpriority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> p;  //{dist,place}\n\t\tp.push({0, start});\n\t\tret[start] = 0;\n\n\t\twhile(!p.empty()) {\n\t\t\tT dist = p.top().first;\n\t\t\tint place = p.top().second;\n\t\t\tp.pop();\n\t\t\tif(ret[place] < dist) continue;\n\t\t\tfor(auto &next : edges[place]) {\n\t\t\t\tint nextplace = next.to;\n\t\t\t\tT dis = next.len;\n\t\t\t\tif(ret[nextplace] > dist + dis) {\n\t\t\t\t\tret[nextplace] = dist + dis;\n\t\t\t\t\tp.push({ret[nextplace], nextplace});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//単一始点最短経路 O((ver)*(edge))\n\t//辿り着けないとき ret[i] = INF;\n\t//ある頂点までのコストが無限に小さくなり得るとき→ ret[i] = -INF;\n\tvector<T> BellmanFord(int start) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/problems/GRL_1_B\n\t\tvector<T> ret(ver, INF);\n\t\tret[start] = 0;\n\t\tfor(int loop = 0; loop < ver - 1; loop++) {\n\t\t\tfor(int v = 0; v < ver; v++) {\n\t\t\t\tif(ret[v] == INF) continue;\n\t\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\t\tret[e.to] = min(ret[e.to], ret[v] + e.len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//無限降下点の検索\n\t\tqueue<int> q;\n\t\tvector<bool> chk(ver, 0);\n\t\tfor(int v = 0; v < ver; v++) {\n\t\t\tif(ret[v] == INF) continue;\n\t\t\tfor(auto &e : edges[v]) {\n\t\t\t\tif(ret[e.to] > ret[v] + e.len) {\n\t\t\t\t\tret[e.to] = ret[v] + e.len;\n\t\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\t\tq.push(e.to);\n\t\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(!chk[e.to]) {\n\t\t\t\t\tchk[e.to] = 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chk[i]) ret[i] = -INF;\n\n\t\treturn ret;\n\t}\n\n\t//閉路に含まれない頂点列挙\n\t//要素数がver未満なら閉路が存在、そうでなければ閉路は存在しない\n\tvector<int> topo_sort() {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_A\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_B\n\t\tassert(directed);\n\t\tvector<int> num_input(ver);\n\t\t// 入次数\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tfor(auto e : edges[i]) {\n\t\t\t\tnum_input[e.to]++;\n\t\t\t}\n\t\t}\n\t\t// 入次数が0のノードをqueueで管理する\n\t\tqueue<int> que;\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(num_input[i] == 0) {\n\t\t\t\tque.push(i);\n\t\t\t}\n\t\t}\n\t\tvector<int> ans;\n\t\twhile(!que.empty()) {\n\t\t\tauto node = que.front();\n\t\t\tque.pop();\n\t\t\tans.push_back(node);\n\t\t\t// 頂点の削除\n\t\t\tfor(auto e : edges[node]) {\n\t\t\t\tnum_input[e.to]--;\n\t\t\t\t// 行き先の入次数が0になったらqueueに追加\n\t\t\t\tif(num_input[e.to] == 0) {\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//{{端点、端点},直径の大きさ}\n\tpair<pair<int, int>, T> DiameterOfTree(bool weigh = true) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_A\n\t\tvector<T> vec;\n\t\tvec = weigh ? dijkstra(0) : bfs(0);\n\t\tint v1 = -1;\n\t\tT dia = -1;\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chmax(dia, vec[i])) v1 = i;\n\n\t\tvec = weigh ? dijkstra(v1) : bfs(v1);\n\t\tdia = -1;\n\t\tint v2 = -1;\n\t\tfor(int i = 0; i < ver; i++)\n\t\t\tif(chmax(dia, vec[i])) v2 = i;\n\n\t\tpair<pair<int, int>, T> ans = {{v1, v2}, dia};\n\t\treturn ans;\n\t}\n\n\t//無向木構造を根から葉に伸びる有向木構造に書き換える\n\tgraph<T> RootToLeaf(int root) {\t // 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(now, e.to, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//無向木構造を葉から根に伸びる有向木構造に書き換える\n\tgraph<T> LeafToRoot(int root) {\t // 0-indexed\n\t\tgraph<T> ret(ver, 1, weight);\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[root] = 1;\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(chk[e.to] == 1) continue;\n\t\t\t\tchk[e.to] = 1;\n\t\t\t\tret.update(e.to, now, e.len, 1);\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\tret.update(root, root, 0);\n\t\treturn ret;\n\t}\n\n\t// LeafToRootのvector版.par[i]=iの親の頂点\n\tvector<int> par(int root) {\t // 0-indexed\n\t\tvector<int> ret(ver, -1);\n\t\tret[root] = root;  // rootの親はroot\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to] != -1) continue;\n\t\t\t\tret[e.to] = now;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\tvector<edge<T>> ParentAndDistance(int root) {  // 0-indexed\n\t\tvector<edge<T>> ret(ver);\n\t\tfor(int i = 0; i < ver; i++) ret[i].to = -1;\n\t\tret[root].to = root;  // rootの親はroot\n\t\tret[root].len = 0;\t  // rootの親との距離は0\n\t\tfunction<void(int)> dfs = [&](int now) {\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(ret[e.to].to != -1) continue;\n\t\t\t\tret[e.to].to = now;\n\t\t\t\tret[e.to].len = e.len;\n\t\t\t\tdfs(e.to);\n\t\t\t}\n\t\t};\n\t\tdfs(root);\n\t\treturn ret;\n\t}\n\n\t//隣接sheet.主にwarshall用\n\tvector<vector<T>> GraphArray(void) {\n\t\tvector<vector<T>> ret(ver, vector<T>(ver, INF));\n\t\tfor(int from = 0; from < ver; from++) {\n\t\t\tfor(auto &e : edges[from]) {\n\t\t\t\tret[from][e.to] = e.len;\n\t\t\t}\n\t\t\tret[from][from] = 0;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tgraph<T> Prim(int start = 0) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_2_A\n\t\tgraph<T> ret(ver, 0, 1);\n\t\tpriority_queue<edge<T>, vector<edge<T>>, greater<edge<T>>> p;\n\t\tfor(auto &e : edges[start]) {\n\t\t\tp.push(e);\n\t\t}\n\t\tvector<bool> chk(ver, 0);\n\t\tchk[start] = 1;\n\t\twhile(!p.empty()) {\n\t\t\tauto ed = p.top();\n\t\t\tp.pop();\n\t\t\tif(chk[ed.to]) continue;\n\t\t\tchk[ed.to] = 1;\n\t\t\tret.update(ed.from, ed.to, ed.len);\n\t\t\tfor(auto &e : edges[ed.to]) {\n\t\t\t\tp.push(e);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t//各頂点を根としたときの木の高さ\n\tvector<T> height(int start = 0) {\n\t\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_B\n\t\tvector<T> fir(ver, -1), sec(ver, -1);\n\t\tfunction<T(int, int)> dfs = [&](int now, int par) {\n\t\t\tT f = 0, s = 0;\t // startを根としたときのnowからの深さ1番目、2番目\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(e.to == par) continue;\n\t\t\t\tchmax(s, dfs(e.to, now) + e.len);\n\t\t\t\tif(f < s) swap(f, s);\n\t\t\t}\n\t\t\tsec[now] = s;\n\t\t\treturn fir[now] = f;\n\t\t};\n\t\tdfs(start, -1);\n\t\tfunction<void(int, int, T, T, T)> sol = [&](int now, int par, T parf, T pars, T parlen) {\n\t\t\tif(fir[now] + parlen == parf) parf = pars;\n\t\t\tchmax(sec[now], parf + parlen);\n\t\t\tif(fir[now] < sec[now]) swap(fir[now], sec[now]);\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(e.to == par) continue;\n\t\t\t\tsol(e.to, now, fir[now], sec[now], e.len);\n\t\t\t}\n\t\t\treturn;\n\t\t};\n\t\tsol(start, -1, -1, -1, -1);\n\t\treturn fir;\n\t}\n\n\t// lowest common ancestor\n\t// max-flow -> 別ファイル\n\t// 強連結成分分解\n\t// HL分解\n};\n\nstruct LCA {\n\t// https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_5_C\n\tint ver;\n\tint h;\t//最大ダブリング回数\n\tint rt;\n\tvector<int> par;\n\tvector<vector<int>> anc;\n\tvector<int> depth;\n\n\tLCA(int _ver, vector<int> _par) : ver(_ver), par(_par), depth(_ver, -1) {\n\t\tfor(int i = 0; i < ver; i++) {\n\t\t\tif(i == par[i]) rt = i;\n\t\t}\n\t\tanc.push_back(_par);\n\t\tvector<int> nxt(_ver);\n\t\tbool f = 1;\n\t\tint i = 0;\n\t\twhile(f) {\n\t\t\tf = 0;\n\t\t\tfor(int j = 0; j < _ver; j++) {\n\t\t\t\tif((nxt[j] = anc[i][anc[i][j]]) != rt) {\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tanc.push_back(nxt);\n\t\t\ti++;\n\t\t}\n\t\th = (int)anc.size();\n\t}\n\n\tint dep(int now) {\n\t\tif(depth[now] != -1) return depth[now];\n\t\tif(now == rt) return depth[rt] = 0;\n\t\treturn depth[now] = dep(par[now]) + 1;\n\t}\n\n\tint Lowest_Common_Ancestor(int x, int y) {\n\t\tint dx = dep(x), dy = dep(y);\n\t\t// 深さを揃える\n\t\tif(dx < dy) {\n\t\t\tint diff = dy - dx;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tif(diff & (1 << i)) {\n\t\t\t\t\ty = anc[i][y];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint diff = dx - dy;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tif(diff & (1 << i)) {\n\t\t\t\t\tx = anc[i][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x == y) return x;\n\t\tfor(int i = h - 1; i > -1; i--) {\n\t\t\tif(anc[i][x] != anc[i][y]) {\n\t\t\t\tx = anc[i][x];\n\t\t\t\ty = anc[i][y];\n\t\t\t}\n\t\t}\n\t\treturn par[x];\n\t}\n\n\tint distance(int x, int y) { return dep(x) + dep(y) - 2 * dep(Lowest_Common_Ancestor(x, y)); }\n};\n\ntemplate <class T>\t// WarshallFloyd\nvoid warshall(vector<vector<T>> &v, T dekai = numeric_limits<T>::max()) {\n\tint n = v.size();\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\tif(v[j][i] == dekai || v[i][k] == dekai) continue;\n\t\t\t\tv[j][k] = min(v[j][k], v[j][i] + v[i][k]);\n\t\t\t}\n\treturn;\n}\n\n// #pragma region macros_and_aliases\n// #define rep(i, n) for(long long i = 0; i < (n); i++)\n// #define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n// #define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n// #define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n// #define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n// #define foa(s, v) for(auto &s : v)\n// #define all(v) (v).begin(), (v).end()\n// #define rall(v) (v).rbegin(), (v).rend()\n// #define pq priority_queue\n// #define bcnt(n) __builtin_popcountll(n)\n// #define endk endl\n// #define ednl endl\n// #define enld endl\n// using ll = long long;\n// using ld = long double;\n// using vll = vector<ll>;\n// using vvll = vector<vll>;\n// using vvvll = vector<vvll>;\n// using vb = vector<bool>;\n// using mll = map<long long, long long>;\n// using pll = pair<long long, long long>;\n// using qll = queue<long long>;\n// using sll = set<long long>;\n// using vpll = vector<pair<long long, long long>>;\n// template <class T = ll>\n// using V = vector<T>;\n// template <class T = ll>\n// using VV = V<V<T>>;\n// template <class T = ll>\n// using VVV = V<V<V<T>>>;\n// //昇順pq(小さい方から取り出す)\n// template <class T = ll>\n// using pqup = priority_queue<T, vector<T>, greater<T>>;\n// //降順pq(大きい方から取り出す)\n// template <class T = ll>\n// using pqdn = priority_queue<T>;\n// #define debug(var)              \\\n// \tstd::cout << #var << \" : \"; \\\n// \tview(var)\n// template <typename T>\n// void view(T e) {\n// \tstd::cout << e << std::endl;\n// }\n// template <typename T>\n// void view(const std::vector<T> &v) {\n// \tfor(const auto &e : v) {\n// \t\tstd::cout << e << \" \";\n// \t}\n// \tstd::cout << std::endl;\n// }\n// template <typename T>\n// void view(const std::vector<std::vector<T>> &vv) {\n// \tfor(const auto &v : vv) {\n// \t\tview(v);\n// \t}\n// }\n// template <typename T1, typename T2>\n// ostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n// \tos << p.first << \" \" << p.second;\n// \treturn os;\n// }\n// template <typename T1, typename T2>\n// istream &operator>>(istream &is, pair<T1, T2> &p) {\n// \tis >> p.first >> p.second;\n// \treturn is;\n// }\n// #pragma endregion\n// #pragma region constants\n// long long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\n// long long const dekai = 3e16;\n// const long double pi = acos(-1);\n// int dx[4] = {1, 0, -1, 0};\n// int dy[4] = {0, 1, 0, -1};\n// int ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n// int ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const int mod = 1000000007;\n// // const int mod = 998244353;\n// #pragma endregion\n// #pragma region precedures\n// template <class T>\n// inline bool chmin(T &a, T b) {\n// \tif(a > b) {\n// \t\ta = b;\n// \t\treturn true;\n// \t}\n// \treturn false;\n// }\n// template <class T>\n// inline bool chmax(T &a, T b) {\n// \tif(a < b) {\n// \t\ta = b;\n// \t\treturn true;\n// \t}\n// \treturn false;\n// }\n// #pragma endregion\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint v, e;\n\tcin >> v >> e;\n\tgraph<long long> gra(v, 1, 0);\n\tgra.input(e, 0);\n\n\tauto tr = gra.topo_sort();\n\tfor(auto e:tr) cout<<e<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nこのコード、と～おれ!\nBe accepted!\n∧＿∧　\n（｡･ω･｡)つ━☆・*。\n⊂　　 ノ 　　　・゜+.\n　しーＪ　　　°。+ *´¨)\n 　　　　　　　　　.· ´¸.·*´¨) ¸.·*¨)\n\t\t  　　　　　　　　　　(¸.·´ (¸.·'* ☆\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <regex>\n#include <functional>\n#include <complex>\n#include <list>\n#include <cassert>\n#include <iomanip>\n#include <set>\n#include <stack>\n#include <bitset>\n\n////多倍長整数, cpp_intで宣言\n//#include <boost/multiprecision/cpp_int.hpp>\n//using namespace boost::multiprecision;\n\n//#pragma gcc target (\"avx2\")\n//#pragma gcc optimization (\"Ofast\")\n//#pragma gcc optimization (\"unroll-loops\")\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define printynl(a) printf(a ? \"yes\\n\" : \"no\\n\")\n#define printyn(a) printf(a ? \"Yes\\n\" : \"No\\n\")\n#define printYN(a) printf(a ? \"YES\\n\" : \"NO\\n\")\n#define printim(a) printf(a ? \"possible\\n\" : \"imposible\\n\")\n#define printdb(a) printf(\"%.50lf\\n\", a) //少数出力\n#define printLdb(a) printf(\"%.50Lf\\n\", a) //少数出力\n#define printdbd(a) printf(\"%.16lf\\n\", a) //少数出力(桁少なめ)\n#define prints(s) printf(\"%s\\n\", s.c_str()) //string出力\n#define all(x) (x).begin(), (x).end()\n#define deg_to_rad(deg) (((deg)/360.0L)*2.0L*PI)\n#define rad_to_deg(rad) (((rad)/2.0L/PI)*360.0L)\n#define Please return\n#define AC 0\n#define manhattan_dist(a, b, c, d) (abs(a - c) + abs(b - d)) /*(a, b) から (c, d) のマンハッタン距離 */\n#define inf numeric_limits<double>::infinity();\n#define linf numeric_limits<long double>::infinity()\n\nusing ll = long long;\nusing ull = unsigned long long;\n\nconstexpr int INF = 1073741823;\nconstexpr int MINF = -1073741823;\nconstexpr ll LINF = ll(4661686018427387903);\nconstexpr ll MOD = 1e9 + 7;\nconstexpr long double eps = 1e-6;\nconst long double PI = acosl(-1.0L);\n\nusing namespace std;\n\nvoid scans(string& str) {\n\tchar c;\n\tstr = \"\";\n\tscanf(\"%c\", &c);\n\tif (c == '\\n')scanf(\"%c\", &c);\n\twhile (c != '\\n' && c != -1 && c != ' ') {\n\t\tstr += c;\n\t\tscanf(\"%c\", &c);\n\t}\n}\n\nvoid scanc(char& str) {\n\tchar c;\n\tscanf(\"%c\", &c);\n\tif (c == -1)return;\n\twhile (c == '\\n') {\n\t\tscanf(\"%c\", &c);\n\t}\n\tstr = c;\n}\n\n\ndouble acot(double x) {\n\treturn PI / 2 - atan(x);\n}\n\nll LSB(ll n) { return (n & (-n)); }\n\ntemplate<typename T>\nT chmin(T& a, const T& b) {\n\tif (a > b)a = b;\n\treturn a;\n}\n\ntemplate<typename T>\nT chmax(T& a, const T& b) {\n\tif (a < b)a = b;\n\treturn a;\n}\n\n/*-----------------------------------------ここからコード-----------------------------------------*/\n\n/*\n* @title template(graph)\n* @docs kyopro/docs/graph_template.md\n*/\n\ntemplate<typename T>\nstruct edge {\n\tT cost;\n\tint from, to;\n\n\tedge(int from, int to) : from(from), to(to), cost(T(1)) {}\n\tedge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate<typename T = int>\nstruct graph {\n\n\tint n;\n\tbool directed, weighted;\n\n\tvector<vector<edge<T>>> g;\n\n\tgraph(int n, bool directed, bool weighted) : g(n), n(n), directed(directed), weighted(weighted) {}\n\n\tvoid add_edge(int from, int to, T cost = T(1)) {\n\t\tg[from].emplace_back(from, to, cost);\n\t\tif (not directed) {\n\t\t\tg[to].emplace_back(to, from, cost);\n\t\t}\n\t}\n\n\tvector<edge<T>>& operator[](const int& idx) {\n\t\treturn g[idx];\n\t}\n\n\tvoid read(int e, bool one_indexed) {\n\t\tint a, b, c = 1;\n\t\twhile (e--) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (weighted) {\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t}\n\t\t\tif (one_indexed)--a, --b;\n\t\t\tadd_edge(a, b, c);\n\t\t}\n\t}\n\n\tvoid read(int e, bool one_indexed, const string& format) {\n\t\tint a, b;\n\t\tT c = T(1);\n\t\twhile (e--) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (weighted) {\n\t\t\t\tscanf(format, &c);\n\t\t\t}\n\t\t\tif (one_indexed)--a, --b;\n\t\t\tadd_edge(a, b, c);\n\t\t}\n\t}\n\n};\n\ntemplate<typename T = int>\nvector<int> topological_sort(graph<T>& g, const int &v) {\n\tvector<int> ret, in(v);\n\n\tqueue<int> que;\n\trep(i, v) for (const auto& aa : g[i])++in[aa.to];\n\trep(i, v)if (not in[i])que.push(i);\n\n\twhile (not que.empty()) {\n\t\tint top = que.front();\n\t\tque.pop();\n\t\tfor (const auto& aa : g[top]) {\n\t\t\t--in[aa.to];\n\t\t\tif (not in[aa.to])que.push(aa.to);\n\t\t}\n\t\tret.emplace_back(top);\n\t}\n\treturn ret;\n}\n\nint main() {\n\n\tint v, e;\n\tscanf(\"%d%d\", &v, &e);\n\tgraph<int> g(v, true, false);\n\tg.read(e, false);\n\tfor (const auto& ans : topological_sort(g, v))printf(\"%d\\n\", ans);\n\n\tPlease AC;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i])\n                        continue;\n                S.push(i);\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        if (!U[c]) {\n                                L.push_back(c);\n                                U[c] = true;\n                        }\n                        for (auto a: A[c])\n                                if (--B[a] == 0 && !U[a])\n                                        S.push(a);\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v] ) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for ( int i = 0; i < N; i++ )\n    indeg[i] = 0;\n\n  for ( int u = 0; u < N; u++ )\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n\n  for ( int u = 0; u < N; u++ )\n    if ( indeg[u] == 0 && !V[u] ) bfs(u);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint V,E,s,t;\nvector<vector<int>> v(10001);\nvector<int> u;\nint visited[10001] = {0};\n\nvoid dfs(int n){\n\tvisited[n] = 1;\n\tfor(int i=0;i<v[n].size();i++){\n\t\tif(visited[v[n][i]]==0) dfs(v[n][i]);\n\t}\n\tu.push_back(n);\n}\n\nint main(){\n\tcin >> V >> E;\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t;\n\t\tv[s].push_back(t);\n\t}\n\tfor(int i=0;i<V;i++){\n\t\tif(visited[i]==0) dfs(i);\n\t}\n\tfor(int i=V-1;i>=0;i--) cout << u[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n\nstatic const int MAX = 100000;\nusing namespace std;\n\nvector<int> G[MAX];\nbool Visited[MAX];\nlist<int> result;\nvoid dfs(int u)\n{\n    Visited[u]=true;\n    for(int i=0;i<G[u].size();i++)\n        if(Visited[G[u][i]]==false)  dfs(G[u][i]);\n\n    //result.push_back(u);\n    result.push_front(u);\n}\nint main()\n{\n    int n,e;\n    cin>>n>>e;\n    //init\n    for(int i=0;i<n;i++)\n       Visited[i]=false;\n    int s,t;\n    for(int i=0;i<e;i++)\n    {\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n\n    //begin\n    //pay attention to the forest!!\n    for(int i=0;i<n;i++)\n    {\n        if(Visited[i]==false)\n            dfs(i);\n    }\n    //print\n    for(list<int>::iterator it=result.begin();it!=result.end();it++)\n        cout<<*it<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define outl(x) cout<< (x) << '\\n'\n#define fi first\n#define se second\nusing pii = pair<int,int>;\nusing ll = long long;\nusing vi = vector<int>;\n\nint V, E;\nvi G[100010];\nint indeg[100010];\nbool used[100010];\n\nvoid bfs(int u, vi &ans)\n{\n    queue<int> que;\n    que.push(u);\n\n    ans.push_back(u);\n    used[u] = true;\n\n    while ( !que.empty() ) {\n        int u = que.front(); que.pop();\n        for (const auto &e : G[u]) {\n            --indeg[e];\n            if (indeg[e]==0 && !used[e]) {\n                used[e] = true;\n                ans.push_back(e);\n                que.push(e);\n            }\n        }\n    }\n\n    return;\n}\n\nvoid topologicalSort(vi &ans)\n{\n    memset(indeg, 0, sizeof(indeg));\n    memset(used, false, sizeof(used));\n    ans.reserve(V+1);\n\n    rep(i, V) {\n        for (const auto &to : G[i]) {\n            ++indeg[to];\n        }\n    }\n\n    rep(i, V) {\n        if (indeg[i] == 0 && !used[i]) bfs(i, ans);\n    }\n    return;\n}\n\n\nint main()\n{\n    vi ans;\n    cin.tie(0), ios::sync_with_stdio(false);\n\n    cin >> V>> E;\n\n    rep(i, E) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    topologicalSort(ans);\n\n    for (const auto &e: ans)\n        outl(e);\n\n    return (0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nvector<int> topological_sort(vector<vector<int>>& g) {\n    int n = (int)g.size();\n    vector<int> ins(n, 0), q, res;\n    for (int u = 0; u < n; u++) {\n        for (int v : g[u]) { ins[v]++; }\n    }\n    for (int u = 0; u < n; u++) {\n        if (ins[u] == 0) { q.push_back(u); }\n    }\n    while (q.size()) {\n        int u = q.back();\n        q.pop_back();\n        res.push_back(u);\n        for (int v : g[u]) {\n            if (!--ins[v]) { q.push_back(v); }\n        }\n    }\n    if ((int)res.size() != n) {\n        return {};\n    } else {\n        return res;\n    }\n}\n\nint main() {\n    PRE_COMMAND\n    int n, m, a, b;\n    INPUT(n, m);\n    vector<vector<int>> g(n, vector<int>(0));\n    for (int i = 0; i < m; i++) {\n        cin >> a >> b;\n        g[a].push_back(b);\n    }\n    auto s = topological_sort(g);\n    FORR(i, s) { PRINT(i); }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\n\nvoid solve()\n{\n  int V, E;\n  cin >> V >> E;\n  StronglyConnectedComponents scc(V);\n  for(int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    scc.add_edge(s, t);\n  }\n  vector< vector< int > > g;\n  scc.build(g);\n  vector< int > rev(V);\n  for(int i = 0; i < V; i++) rev[scc[i]] = i;\n  for(int i = 0; i < V; i++) cout << rev[i] << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\n\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;//??????\nbool V[MAX];\nint N;\nint indeg[MAX];\n\n\n//??????????????????????????????????????????????????¢?´¢\nvoid bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n//???????????????????????????\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tindeg[G[u][i]]++;\n\t\t}\n\t}\n\n\n\tfor (int u = 0; u < N; u++) {\n\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\tbfs(u);\n\t\t}\n\t}\n\n\n\n\n}\n\nint main() {\n\tint s, t, M;\n\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tV[i] = false;\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rept(i,n) for(int (i)=0;(i)<=(int)(n);(i)++)\n#define reps(i,s,n) for(int (i)=(s);(i)<(int)(n);(i)++)\n#define repst(i,s,n) for(int (i)=(s);(i)<=(int)(n);(i)++)\n#define repr(i,n) for(int (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln \"\\n\"\n#define show(x) cout << #x << \" = \" << x ln\n#define dbg(x) cout<<#x\"=\"<<x ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ??????????????????????????????????????????( ^??^)??????????????????????????????????????????\n\n// ????????°????????°?????\\?¬???°\nint v, e, in[100000];\n// ??\\?¬???°0???????????????????????\\????????????\nqueue<int> S;\n// ????????£??\\?????????\nmat V(100000);\n// ??????\nvi ans;\n\nint main() {\n\tcin >> v >> e;\n\trep(i,e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tV[a].pb(b);\n\t\tin[b]++;\n\t}\n\t\n\t// ??\\?¬???°0??????????????????\n\trep(i,v) if (in[i]==0) S.push(i);\n\twhile (!S.empty()) {\n\t\tint u = S.front(); S.pop();\n\t\tans.pb(u);\n\t\t// u?????????????¢???????????????§??°?????????????¶?????????£??\\????????¨??????????????\\?¬???°???1?????????\n\t\trep(i,V[u].size()) {\n\t\t\tin[i]--;\n\t\t\t// ????????????????????£?????\\?¬???°???0????????£?????????????????°S?????????\n\t\t\tif (in[i]==0) S.push(i);\n\t\t}\n\t}\n\trep(i,v) cout << ans[i] << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\nstruct Node {\n    vector<int> parent;\n    \n};\nint main() {\n    int v, e; cin >> v >> e;\n    Node node[v];\n    rep(i, e) {\n        int s, t; cin >> s >> t;\n        node[t].parent.push_back(s);\n    }\n    int check[v]; rep(i, v) check[i] = 0;\n    //vector<int> comb; 1組だけ出せばいい\n    queue<int> q;\n    rep(i, v) if (node[i].parent.size() == 0) {\n        q.push(i);\n        cout << i << endl;\n        check[i] = 1;\n    }\n    while (!q.empty()) {\n        int now = q.front();\n        //cout << now << endl;\n        rep(i, v) {\n            if (check[i] == 1) continue;\n            rep(j, node[i].parent.size()) {\n                if (node[i].parent[j] == now) {\n                    node[i].parent[j] = -1;\n                }\n            }\n        }\n        q.pop();\n        rep(i, v) {\n            if (check[i] == 1) continue;\n            rep(j, node[i].parent.size()) {\n                if (node[i].parent[j] != -1) break;\n                if (j == node[i].parent.size() - 1) {\n                    q.push(i);\n                    cout << i << endl;\n                    check[i] = 1;\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst double pi = 3.14159265358979323846;\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing Graph = vector<vector<int>>;\nusing pint = pair<int, int>;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint dxx[8] = {1, 1, 1, 0, 0, -1, -1, -1}, dyy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    Graph g (n);\n    vector<int> chk (n, 0);\n    rep (i, m) {\n        int x, y;\n        cin >> x >> y;\n        g[x].push_back (y);\n        chk[y]++;\n    }\n    queue<int> q;\n    rep (i, n) if (chk[i] == 0) q.push (i);\n\n    vector<int> sortedvec;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (auto next : g[now]) {\n            if (!chk[next]) continue;\n            chk[next]--;\n            if (!chk[next]) q.push (next);\n        }\n        sortedvec.push_back (now);\n    }\n    rep (i, n) cout << sortedvec[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < state.size(); i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < edge[ans[i]].size(); j++) {\n            int t = edge[ans[i]][j];\n            state[t]--;\n            if (state[t] == 0) ans.push_back(t);\n        }\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nvector<int> to[10007];\nvector<int> color(10007);\nstack<int> ans;\n\nvoid dfs(int u){\n    color[u] = 1;\n    for (int i = 0; i < to[u].size(); i++){\n        int v = to[u][i];\n        if(color[v] == 0){\n            dfs(v);\n        }\n    }\n    ans.push(u);\n}\n\nint main() {\n    int V, E; cin >> V >> E;\n    rep(i, E){\n        int s, t; cin >> s >> t;\n        to[s].push_back(t);\n    }\n\n    for (int i = 0; i < V; i++){\n        if(color[i] == 0){\n            dfs(i);\n        }\n    }\n\n    while(!ans.empty()){\n        int x = ans.top(); ans.pop();\n        cout << x << endl;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define LL long long\n#define endl '\\n'\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u)\n{\n    V[u] = true;\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if (!V[v]) {\n            dfs(v);\n        }\n    }\n    out.push_front(u);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for (int i = 0; i < N; i++) {\n        V[i] = false;\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!V[i]) {\n            dfs(i);\n        }\n    }\n\n    for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n                                            //    #include <boost/multiprecision/cpp_int.hpp>\n \n                               \t       #define int long long\n                                                #define inf  1000000007\n                                              #define pa pair<int,int>\n                                               #define pad pair<double,double>\n                                                #define ll long long\n                                                #define pal pair<double,double>\n                                                #define ppap pair<pa,int>\n                                          #define PI 3.14159265358979323846\n                                                #define paa pair<pa,pa>\n                                                #define  mp make_pair\n                                                #define  pb push_back\n                                                #define EPS (1e-10)\n                                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                                            //    #define double long double\n        int dx[4]={0,-1,0,1};\n        int dy[4]={1,0,-1,0};\n                                                using namespace std;\n                                       \t\t\tclass pa3{\n                                                \tpublic:\n                                                \tint x,y,z;\n                                                \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                                \tbool operator < (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\t return z<p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                       \t\t\t\tbool operator > (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\t return z>p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa3 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z;\n                                                \t}\n                                                \t\tbool operator != (const pa3 &p) const{\n                                                \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                                \t}\n                                                \n                                                };\n                                                \n                                                class pa4{\n                                                \tpublic:\n                                                \tint x;\n                                                \tint y,z,w;\n                                                \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                                \tbool operator < (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\tif(z!=p.z)return z<p.z;\n                                                \t\treturn w<p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\tif(z!=p.z)return z>p.z;\n                                                \t\treturn w>p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa4 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                                \t}\n                                                \t\n                                                \tbool operator != (const pa4 &p) const{\n                                                \t\treturn !(x==p.x && y==p.y && z==p.z &&w==p.w);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                class pa2{\n                                                \tpublic:\n                                                \tint x,y;\n                                                \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                                \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                                \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                                \tbool operator < (const pa2 &p) const{\n                                                \t\treturn x!= p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa2 &p) const{\n                                                \t\treturn x != p.x ? x>p.x: y>p.y;\n                                                \t}\n                                                \tbool operator == (const pa2 &p) const{\n                                                \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                                \t}\n                                                \tbool operator != (const pa2 &p) const{\n                                                \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                \n                                              \n                                                \n                                                       #define ppa pair<int,pas>\n                                                class Point{\n                                                \tpublic:\n                                                \tdouble x,y;\n                                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                                \tdouble absv() {return sqrt(norm());}\n                                                \tdouble norm() {return x*x+y*y;}\n                                                \tbool operator < (const Point &p) const{\n                                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const Point &p) const{\n                                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                                \t}\n                                                };\n                                                typedef Point Vector;\n                                         #define pl pair<int,pas>\n                                                struct Segment{\n                                                Point p1,p2;\n                                                };\n                                                 double dot(Vector a,Vector b){\n                                                \treturn a.x*b.x+a.y*b.y;\n                                                }\n                                                double cross(Vector a,Vector b){\n                                                \treturn a.x*b.y-a.y*b.x;\n                                                }\n                                            \n                    bool parareru(Point a,Point b,Point c,Point d){\n                    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                    \treturn abs(cross(a-b,d-c))<EPS;\n                    }\n                    double distance_ls_p(Point a, Point b, Point c) {\n                      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                      return abs(cross(b-a, c-a)) / (b-a).absv();\n                    }\n                    bool is_intersected_ls(Segment a,Segment b) {\n                    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return 1;\n                    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                    //\t\tcout<<\"sss\"<<endl;\n                    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                    \t\treturn false;\n                    \t}\n                      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                    }\n                     \n                    double segment_dis(Segment a,Segment b){\n                    \tif(is_intersected_ls(a,b))return 0;\n                    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                    \treturn r;\n                    }\n                    Point intersection_ls(Segment a, Segment b) {\n                      Point ba = b.p2-b.p1;\n                      double d1 = abs(cross(ba, a.p1-b.p1));\n                      double d2 = abs(cross(ba, a.p2-b.p1));\n                      double t = d1 / (d1 + d2);\n                     \n                      return a.p1 + (a.p2-a.p1) * t;\n                    }\n                     \n                                    string itos( int i ) {\n                                    ostringstream s ;\n                                    s << i ;\n                                    return s.str() ;\n                                    }\n                                     \n                                    int gcd(int v,int b){\n                                    \tif(v==0) return b;\n                                    \tif(v>b) return gcd(b,v);\n                                    \tif(v==b) return b;\n                                    \tif(b%v==0) return v;\n                                    \treturn gcd(v,b%v);\n                                    }\n                     \n                                    double distans(double x1,double y1,double x2,double y2){\n                                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                    \treturn sqrt(rr);\n                                    \t\n                                    }\n                                                        /*\n        double bekid(double w,int r){\n        \tif(r==0) return 1.0;\n        \tif(r==1) return w;\n        \tif(r%2) return bekid(w,r-1)*w;\n        \tdouble f=bekid(w,r/2);\n        \treturn f*f;\n        }*/\n                                    int mod;\n                    int beki(int wa,int rr,int warukazu){\n                    \tif(rr==0) return 1%warukazu;\n                    \tif(rr==1) return wa%warukazu;\n                    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                    \tint zx=beki(wa,rr/2,warukazu);\n                    \treturn (zx*zx)%warukazu;\n                    }\n                          /*          \n                    int pr[401000];\n                    int inv[401000];\n                   \n                   \n\n                  \n        \t\t\tint comb(int nn,int rr){\n        \t\t\t\tint r=pr[nn]*inv[rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\tr*=inv[nn-rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\t\n        \t\t\t\treturn r;\n        \t\t\t}\n                  \n                    void gya(int ert){\n                    \tpr[0]=1;\n                    \tfor(int i=1;i<ert;i++){\n                    \t\tpr[i]=(pr[i-1]*i)%mod;\n                    \t}\n                    \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                    \t\n                    }\n                    */\n                    \n                  //   cin.tie(0);\n        \t\t//\tios::sync_with_stdio(false);\n        \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                     //sort(ve.begin(),ve.end(),greater<int>());\n\n\n///////////////////////////////////////////////////////////\n\nqueue<int> qu;\nint nyu[100200]={0};\nvector<int> G[10020];\n  signed main(){\n \t              cin.tie(0);\n   \t\tios::sync_with_stdio(false);\nint n,m;\n  \tcin>>n>>m;\n  \tfor(int i=0;i<m;i++){\n  \t\tint y,yy;\n  \t\tcin>>y>>yy;\n  \t\tG[y].pb(yy);\n  \t\t\n  \t\tnyu[yy]++;\n  \t}\n  \tfor(int i=0;i<n;i++)if(nyu[i]==0)qu.push(i);\n  \t\n  \twhile(qu.size()){\n  \t\tint z=qu.front();\n  \t\tqu.pop();\n  \t\tcout<<z<<endl;\n  \t\tfor(auto v:G[z]){\n  \t\t\tnyu[v]--;\n  \t\t\tif(nyu[v]==0) qu.push(v);\n  \t\t}\n  \t\n  \t}\n  \t\n  \treturn 0;\n  \t\n               }\n                \n                \n                \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i<(n); ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int>to[10010],ans;\nbool ok[10010];\n\nvoid dfs(int v){\n    ok[v]=true;\n    for(int u:to[v]){\n        if(ok[u])continue;\n        dfs(u);\n    }\n    ans.push_back(v);\n    return;\n}\n\nvoid Tsort(){\n    rep(i,n){\n        if(!ok[i])dfs(i);\n    }\n    return;\n}\n\nint main(){\n    cin>>n>>m;\n    rep(i,m){\n        int s,t; cin>>s>>t;\n        to[s].push_back(t);\n    }\n    Tsort();\n    reverse(ans.begin(),ans.end());\n    for(auto& x:ans){\n        cout<<x<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\nusing namespace std;\n\n#define Getsign(n) ((n > 0) - (n < 0))\n\ntypedef vector<int> Ivec;\ntypedef pair<int, int> Pos;\n\nint main() {\n\tvector<pair<int,vector<int>>> graph;\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; v > i; i++) {\n\t\tgraph.push_back({i,vector<int>()});\n\t}\n\tfor (int i = 0; e > i; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tgraph[b].second.push_back(a);\n\t}\n\twhile (v) {\n\t\tfor (int i = 0; v > i; i++) {\n\t\t\tif (!graph[i].second.size()) {\n\t\t\t\tprintf(\"%d\\n\", graph[i].first);\n\t\t\t\tint num = graph[i].first;\n\t\t\t\tgraph.erase(graph.begin()+i);\n\t\t\t\tv--;\n\t\t\t\tfor (int j = 0; v > j; j++) {\n\t\t\t\t\tauto itr = find(graph[j].second.begin(), graph[j].second.end(), num);\n\t\t\t\t\tif(itr != graph[j].second.end())\n\t\t\t\t\t\tgraph[j].second.erase(itr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\nstruct Edge{ll s,t,d;};\ntypedef vector<vector<Edge>> Graph;\n\nvi topologicalSort(vvi &G) {\n  ll V=G.size();\n  vi in(V);\n  for(vi &v:G) for(ll to:v) in[to]++;\n  queue<ll> q;\n  REP(i,V) if(in[i]==0) q.push(i);\n  vi ret;\n  while(q.size()) {\n    ll from=q.front();\n    q.pop();\n    ret.PB(from);\n    for(ll to:G[from]) {\n      in[to]--;\n      if(in[to]==0) q.push(to);\n    }\n  }\n  return ret;\n}\n\nint main() {\n  ll V,E; cin>>V>>E;\n  vvi G(V);\n  REP(i,E) {\n    ll s,t; cin>>s>>t;\n    G[s].PB(t);\n  }\n  vi ans=topologicalSort(G);\n  for(ll i:ans) cout<<i<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2,t3;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\n\nvector<ll> ans;\nll V,E;\nvector<ll> vec[10000];\nvector<ll> che(10000,0);\nvector<ll> path(10000,0);\n\nvoid dfs(ll k){\n  if(path[k] == 0){\n    ans.push_back(k);\n    for(auto itr:vec[k]){\n      path[itr]--;\n      dfs(itr);\n    }\n  }else{\n    //path[k]--;\n  }\n}\n\nint main(){\n  cin >> V >> E;\n  rep(i,E) {\n    cin >> t1 >> t2;\n    vec[t1].push_back(t2);\n    che[t2]=1;\n    path[t2]++;\n  }\n  rep(i,V){\n    if(che[i] == 0){\n      dfs(i);\n    }\n  }\n  ull len = ans.size();\n  rep(i,len){\n    cout << ans[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<list>\nusing namespace std;\nvector < int > G[1000000];\nlist < int > out;\nbool v[1000000];\nint n;\nint indeg[1000000];\nvoid bfs(int u){\n\tqueue < int > Q;\n\tQ.push(u);\n\tv[u]=1;\n\twhile(!Q.empty()){\n\t\tint k=Q.front();\n\t\tQ.pop();\n\t\tout.push_back(k);\n\t\tv[k]=1;\n\t\tfor(int i=0;i<G[k].size();i++){\n\t\t\tint p=G[k][i];\n\t\t\tindeg[p]--;\n\t\t\tif(indeg[p]==0&&!v[p]) Q.push(p);\n\t\t}\n\t}\n}\nvoid f(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tint v=G[i][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!v[i]&&indeg[i]==0) bfs(i);\n\t}\n\tfor(list<int >::iterator it=out.begin();it!=out.end();it++){\n\t\tprintf(\"%d\\n\",*it);\n\t}\n\t\n}\nint main(){\n\tint s,t,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tG[s].push_back(t);\n\t}\n\tf();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define outl(x) cout<< (x) << '\\n'\n#define fi first\n#define se second\nusing pii = pair<int,int>;\nusing ll = long long;\nusing vi = vector<int>;\n\nint V, E;\nvi G[100010];\nint indeg[100010];\n\nvoid topologicalSort(vi &ans)\n{\n    memset(indeg, 0, sizeof(indeg));\n    ans.reserve(V+1);\n\n    rep(i, V) {\n        for (const auto &to : G[i]) {\n            ++indeg[to];\n        }\n    }\n\n    {\n        queue<int> que;\n        rep(i, V) {\n            if (indeg[i] == 0) que.push(i);\n        }\n\n        while ( !que.empty()) {\n            int u = que.front(); que.pop();\n            ans.push_back(u);\n            for (const auto &e: G[u]) {\n                --indeg[e];\n                if (indeg[e] == 0) que.push(e);\n            }\n        }\n    }\n    return;\n}\n\n\nint main()\n{\n    vi ans;\n    cin.tie(0), ios::sync_with_stdio(false);\n\n    cin >> V>> E;\n\n    rep(i, E) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    topologicalSort(ans);\n\n    for (const auto &e: ans)\n        outl(e);\n\n    return (0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\nusing namespace std;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nint indeg[10005];\n\nvector<int> tsort()\n{\n    stack<int> S;\n    REP(i,V){\n        if(indeg[i]==0) S.push(i);\n    }\n    vector<int> res;\n    while(!S.empty()){\n        int v=S.top(); S.pop();\n        res.push_back(v);\n        for(auto u:G[v]){\n            indeg[u]--;\n            if(indeg[u]==0) S.push(u);\n        }\n    }\n    return res;\n}\n\nsigned main()\n{   \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n        indeg[b]++;\n    }\n    \n    vector<int> ans=tsort();\n    for(auto v:ans){\n        cout<<v<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector< vector< int > > g;\nvector< int > visited;\nvector< int > tlist;\n\nvoid dfs(int v){\n\tvisited[v] = 1;\n\t\n\tfor(vector< int >::iterator it = g[v].begin(); it != g[v].end(); ++it){\n\t\tif(visited[*it] == 0){\n\t\t\tdfs(*it);\n\t\t}\n\t}\n\ttlist.push_back(v);\n\t\n}\n\nint main(){\n\tint v, e, s, t;\n\t\n\tcin >> v >> e;\n\t\n\tg.resize(v);\n\tvisited.resize(v);\n\t\n\tfor(int i = 0; i < e; ++i){\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t);\n\t}\n\t\n\t\n\tfor(int i = 0; i < v; ++i){\n\t\tif(visited[i] == 0){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\treverse(tlist.begin(), tlist.end());\n\t\n\tfor(vector< int >::iterator it = tlist.begin(); it != tlist.end(); ++it){\n\t\tcout << (*it) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define INF (2e9)\nconst int maxv=10000+10;\nconst int maxe=100000+10;\nint V,E;\n\nint vis[maxv];\nlist<int> out;\nvector<int> g[maxv];\nint indege[maxv];\nvoid bfs(int s)\n{\n    queue<int> que;\n    que.push(s);\n    while(!que.empty())\n    {\n        int u=que.front();que.pop();\n        out.push_back(u);\n        for(int i=0;i<g[u].size();i++)\n        {\n            int v=g[u][i];\n            indege[v]--;\n            if(!vis[v]&&indege[v]==0)\n            {\n                vis[v]=1;\n                que.push(v);\n\n            }\n        }\n    }\n}\nvoid top_sort()\n{\n    memset(vis,0,sizeof(vis));\n    memset(indege,0,sizeof(indege));\n    for(int i=0;i<V;i++)\n    {\n        for(int j=0;j<g[i].size();j++)\n        {\n            int v=g[i][j];\n            indege[v]++;\n        }\n    }\n    for(int i=0;i<V;i++)\n    {\n        if(!vis[i]&&indege[i]==0)\n        {\n            bfs(i);\n        }\n    }\n    for(list<int>::iterator iter=out.begin();iter!=out.end();iter++)\n    {\n        printf(\"%d\\n\",*iter);\n    }\n}\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&V,&E);\n    int u,v;\n    for(int i=0; i<E; i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        g[u].push_back(v);\n    }\n    top_sort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nconst int MAX=100000;\nconst int INF=(1<<29);\n\nvector<int >G[MAX];\nlist<int >out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n  queue<int >q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();\n    q.pop();\n    out.push_back(u);\n    \n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(){\n  for(int i=0;i<N;i++){\n    indeg[i]=0;\n  }\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n  \n  for(int u=0;u<N;u++){\n    if(indeg[u]==0&&!V[u]) bfs(u);\n  }\n  \n  for(list<int>::iterator it=out.begin(); it!=out.end();it++){\n    cout<<*it<<endl;\n  }\n}\n\nint main(){\n  int s,t,M;\n  cin>>N>>M;\n  for(int i=0;i<N;i++){\n    V[i]=false;\n  }for(int i=0;i<M;i++){\n    cin>>s>>t;\n      G[s].push_back(t);\n    }\n  \n  tsort();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int V, E, x, y; cin >> V >> E;\n    vector<vector<int> > G(V);\n    vector<int> deg(V);\n    for(int i=0;i < E; ++i) {\n        cin >> x >> y;\n        G[x].push_back(y);\n        ++deg[y];\n    }\n\n    queue<int> que;\n    for(int i=0; i < V; ++i) if(deg[i]==0) que.push(i);\n\n    // topological sort\n    while(!que.empty()) {\n        int v = que.front(); que.pop();\n        cout << v << '\\n';\n        for(int nv : G[v]) {\n            --deg[nv];\n            if(deg[nv] == 0) que.push(nv);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v] ) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for ( int i = 0; i < N; i++ )\n    indeg[i] = 0;\n\n  for ( int u = 0; u < N; u++ )\n    for ( int i = 0; i < N; i++ ) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n\n  for ( int u = 0; u < N; u++ )\n    if ( indeg[u] == 0 && !V[u] ) bfs(u);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<stdio.h>\n#include <cstdint>\n#include <stdlib.h> \n#include <time.h>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) REP(i,1,n+1)\n#define all(a) a.begin(), a.end()\n#define fi first\n#define se second\n#define RNG(x, a, n) &((x)[a]), &((x)[n])\nlong long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> PII;\ntypedef vector<ll> Vl;\ntypedef vector<int> VI;\ntypedef tuple<int, int, int> TT;\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define dmt(x, y, z) make_tuple(x, y, z)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\nconst int MAX = 5100000;\nconst int inf = 1e9 + 7;\nconst int mod = 1e9 + 7;\nconst ll longinf = 1LL << 60;\nconst long double PI = (acos(-1));\nconst long double EPS = 0.0000000001;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\n\nint v, e;\nint h[100005];\nVI vec[100005];\nVI ans;\n\nint main() {\n\n\tcin >> v >> e;\n\n\trep(i, e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tvec[a].pb(b);\n\t\th[b]++;\n\t}\n\n\tqueue <int> q;\n\n\trep(i, v) {\n\t\tif (h[i] == 0) q.push(i);\n\t}\n\n\twhile (!q.empty()) {\n\t\tint tmp = q.front(); \n\t\tq.pop();\n\n\t\tans.push_back(tmp);\n\n\t\trep(i, vec[tmp].size()) {\n\t\t\th[vec[tmp][i]]--;\n\t\t\tif (h[vec[tmp][i]] == 0)q.push(vec[tmp][i]);\n\t\t}\n\t}\n\n\trep(i, ans.size())cout << ans[i] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nconst int MAX = 100000;\nvector<int> G[MAX];\nlist<int> out;\nvector<bool> visited;\n\nvoid dfs(int u){\n    visited[u] = true;\n    for (auto v :G[u]) {\n        if (!visited[v])dfs(v);\n    }\n    out.push_front(u);\n}\nint main(){\n    //freopen(\"in\", \"r\", stdin);\n    int v,e;\n    cin >> v >> e;\n    for (int i = 0; i < e; ++i) {\n        int s,t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    visited.resize(v);\n    for (int i = 0; i < v; ++i) {\n        if (!visited[i])dfs(i);\n    }\n    for (auto item :out) cout << item << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Topological Sort\n//\n//\n// Description:\n//\n//   Let G = (V, E) be a graph. An ordering ord: [n] -> V is a topological \n//   ordering if i > j then there is no edge from ord[i] to ord[j].\n//   G has a topological ordering if and only if G is DAG.\n//\n//   A topological order can be obtained in O(n + m) time by using\n//   an iterative method (Kuhn's algorithm) or a recursive method \n//   (by Tarjan's algorithm). The following implementation is a \n//   Kuhn's algorithm.\n//\n//   Note that if you want to find the all topological orders,\n//\n//\n// Complexity:\n//\n//   O(n + m)\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\nstruct Graph {\n  int n;\n  vector<vector<int>> adj;\n  Graph(int n) : n(n), adj(n) { }\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n  }\n};\n\n// return empty list if g has no topological order\nvector<int> topologicalSort(Graph g) {\n  vector<int> deg(g.n);\n  for (int u = 0; u < g.n; ++u)\n    for (int v: g.adj[u]) ++deg[v];\n  vector<int> stack; \n  for (int u = 0; u < g.n; ++u)\n    if (!deg[u]) stack.push_back(u);\n\n  vector<int> order;\n  while (!stack.empty()) {\n    int u = stack.back(); stack.pop_back();\n    order.push_back(u);\n    for (int v: g.adj[u]) \n      if (!--deg[v]) stack.push_back(v);\n  }\n  return order.size() == g.n ? order : vector<int>();\n}\n\nint main() {\n  int n, m; cin >> n >> m;\n  Graph g(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v; cin >> u >> v;\n    g.addEdge(u, v);\n  }\n  auto ord = topologicalSort(g);\n  for (int i = 0; i < ord.size(); ++i) {\n    if (i > 0) cout << \" \";\n    cout << ord[i];\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Ref : https://book.mynavi.jp/ec/products/detail/id=35408\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\n#include <queue>\nusing namespace std;\n\nint main() {\n\t// 入力データからグラフを構築する //\n\tint NV, NE;\n\tcin >> NV >> NE;\n\tvector<int> inDeg(NV, 0); // 0>=:入力数, -1:探索キューに追加済み\n\tvector<vector<int> > graph(NV);\n\tfor (int i = 0; i < NE; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgraph[s].push_back(t);\n\t\tinDeg[t]++;\n\t}\n\n\t// トポロジカルソートを実行する //\n\tlist<int> ans;\n\t// 幅優先探索でグラフを探索する\n\tqueue<int> q;\n\t// 探索用キューに始点を設定\n\tfor (int i = 0; i < NV; i++) {\n\t\tif (inDeg[i] == 0) {\n\t\t\tq.push(i);\n\t\t\tinDeg[i] = -1;\n\t\t}\n\t}\n\t// 幅優先探索を実行する\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tans.push_back(u);\n\t\t// 隣接リストを探索し、前処理が0になったら探索キュー追加\n\t\tfor (unsigned int i = 0; i < graph[u].size(); i++) {\n\t\t\tint v = graph[u][i];\n\t\t\tif (inDeg[v] < 1) continue;\n\t\t\tif (--inDeg[v] == 0) {\n\t\t\t\tq.push(v);\n\t\t\t\tinDeg[v] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グラフの頂点を, トポロジカルソートで表示する //\n\tfor (list<int>::iterator it = ans.begin(); it != ans.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < state.size(); i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < edge[ans[i]].size(); j++) {\n            int t = edge[ans[i]][j];\n            state[t]--;\n            if (state[t] == 0) ans.push_back(t);\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n\n#define MAXN 10000\n#define MAXM 100000\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  struct {\n    int to, next;\n  } E[MAXM];\n  vector<int> LE(MAXN, -1);\n\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0, s, t; i < m; ++i) {\n    cin >> s >> t;\n    E[i] = {t, LE[s]};\n    LE[s] = i;\n  }\n\n  int indegree[MAXN]{0};\n  for (int e = 0; e < m; ++e)\n    ++indegree[E[e].to];\n\n  queue<int> sources;\n  for (int i = 0; i < n; ++i)\n    if (indegree[i] == 0)\n      sources.push(i);\n\n  int seen = 0;\n  while (seen < n) {\n    int curr = sources.front();\n    sources.pop();\n    ++seen;\n    cout << curr << endl;\n    for (int e = LE[curr]; e != -1; e = E[e].next) {\n      --indegree[E[e].to];\n      if (indegree[E[e].to] == 0)\n        sources.push(E[e].to);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int MAX = 100000;\nconst int INF = 1<<29;\nvector<int> G[MAX];\nlist<int> out;\nint n;\nbool V[MAX];\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    r(i,G[u].size()){\n      int v=G[u][i];\n      indeg[v]--;\n      if(!indeg[v]&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid Tsort(){\n  r(u,n)r(i,G[u].size())indeg[G[u][i]]++;\n  r(u,n)if(!indeg[u]&&!V[u])bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    cout<<*it<<endl;\n}\nint main(){\n  int s,t,m;\n  cin>>n>>m;\n  r(i,m){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  Tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\nusing edge_set = unordered_set<int>;\n\nint main() {\n\n    int V, E;\n    cin >> V >> E;\n\n    int count = 0;\n    pair<int, int> order[V];\n    edge_set indeg[V], outdeg[V];\n\n    for (int i = 0; i < V; i++) {\n        order[i].second = i;\n    }\n\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        indeg[t].insert(s);\n        outdeg[s].insert(t);\n    }\n\n    queue<int> que;\n\n    for (int i = 0; i < V; i++) {\n        if (indeg[i].empty()) {\n            que.push(i);\n        }\n    }\n\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (int v : outdeg[u]) {\n            indeg[v].erase(u);\n            if (indeg[v].empty()) {\n                que.push(v);\n            }\n        }\n        order[u].first = ++count;\n    }\n\n    //count < |V| なら閉路がある\n\n    sort(order, order + V);\n\n    for (int i = 0; i < V; i++) {\n        cout << order[i].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  grl_4_b.cpp\n// Author: ymiyamoto\n//\n// Created on Fri Oct 20 01:00:42 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n#define SIZE 10000\n\nstatic vector<uint32_t> graph[SIZE];\nstatic vector<uint32_t> connected_num(SIZE, 0);\nstatic queue<uint32_t> q;\nstatic vector<uint32_t> sorted;\n\nint32_t main()\n{\n  uint32_t V, E;\n  cin >> V >> E;\n\n  for (uint32_t i = 0; i < E; i++) {\n    uint32_t s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    connected_num[t]++;\n  }\n\n  for (uint32_t i = 0; i < E; i++) {\n    if (connected_num[i] == 0) {\n      q.push(i);\n    }\n  }\n\n  while (!q.empty()) {\n    uint32_t index = q.front();\n    q.pop();\n\n    sorted.push_back(index);\n    for (uint32_t i = 0; i < graph[index].size(); i++) {\n      connected_num[graph[index][i]]--;\n      if (connected_num[graph[index][i]] == 0) {\n        q.push(graph[index][i]);\n      }\n    }\n  }\n\n  for (uint32_t i = 0; i < sorted.size(); i++) {\n    if (i != 0) cout << \" \";\n    cout << sorted[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\nvector<vector<int>> to;\nvector<bool> seen;\nvector<int> ans;\nvoid dfs(int v) {\n    if (seen[v]) return;\n    seen[v] = true;\n    for (auto u : to[v]) dfs(u);\n    ans.pb(v);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int v, e;\n    cin >> v >> e;\n    to.resize(v);\n    rep(i, e) {\n        int s, t;\n        cin >> s >> t;\n        to[s].pb(t);\n    }\n    seen.resize(v);\n    rep(i, v) dfs(i);\n    reverse(all(ans));\n    rep(i, v) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nvoid dfs(int i, const std::vector<std::vector<int>>& edges, std::vector<bool>& memo, std::vector<int>& ans) {\n    memo[i] = true;\n    for(auto v: edges[i]) {\n        if(!memo[v]) dfs(v, edges, memo, ans);\n    }\n    ans.push_back(i);\n}\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    std::vector<std::vector<int>> edges(V);\n    while(E--) {\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n    }\n\n    std::vector<int> ans;\n    ans.reserve(V);\n    std::vector<bool> memo(V, false);\n    for(int i = 0; i < V; ++i) {\n        if(!memo[i]) dfs(i, edges, memo, ans);\n    }\n\n    std::reverse(begin(ans), end(ans));\n\n    for(auto val: ans)\n        std::cout << val << \"\\n\";\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<25)     //33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nVI g[100010];\nint h[100010], s[100010], t[100010];\nsigned main(void)\n{\n  int v, e;\n  cin >> v >> e;\n  REP(i, e) {\n    cin >> s[i] >> t[i];\n    g[s[i]].push_back(t[i]);\n  }\n\n  stack<int> st;\n\n  for(auto& i: g)\n    for(auto& j: i)\n      h[j]++;\n\n  REP(i, v) {\n    if(h[i] == 0) st.push(i);\n  }\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nint used[10000];\n\nvoid dfs(int v, const Graph& G, vector<int>& res) {\n\tused[v] = 1;\n\tfor (auto to : G[v]) if (used[to] == 0) {\n\t\tdfs(to, G, res);\n\t}\n\tres.push_back(v);\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tGraph G(V);\n\tvector<int> ide(V);\n\tfor (int i = 0, s, t; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tide[t]++;\n\t}\n\tvector<int> res;\n\tfor (int i = V - 1; i >= 0; i--) {\n\t\tif (ide[i] == 0) {\n\t\t\tdfs(i, G, res);\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\tfor (int i = 0; i < V; i++) {\n\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef int Weight;\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n\n    Edge(int src, int dst, Weight weight) :\n            src(src), dst(dst), weight(weight) {}\n};\n\nbool operator<(const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n           e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool visit(const Graph &g, int v, vector<int> &order, vector<int> &color) {\n    color[v] = 1;\n    for (auto e: g[v]) {\n        if (color[e.dst] == 2) continue;\n        if (color[e.dst] == 1) return false;\n        if (!visit(g, e.dst, order, color)) return false;\n    }\n    order.push_back(v);\n    color[v] = 2;\n    return true;\n}\n\nbool topologicalSort(const Graph &g, vector<int> &order) {\n    int n = g.size();\n    vector<int> color(n);\n    rep(u, n) if (!color[u] && !visit(g, u, order, color))\n            return false;\n    reverse(order.begin(), order.end());\n    return true;\n}\n\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n\n    Graph g(v);\n\n    rep(i, e) {\n        int s, t;\n        cin >> s >> t;\n        Edge edge(s, t, 1);\n\n        g[s].push_back(edge);\n    }\n    vector<int> order;\n    topologicalSort(g, order);\n\n    for (int a :order) cout << a << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nconstexpr long long INF = 1LL << 60;\nconstexpr long long MOD = 1000000007;\ndouble PI = acos(-1.0);\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define rep1(i, n) for (ll i = 1; i <= (n); ++i)\n#define rrep(i, n) for (ll i = (n - 1); i >= 0; --i)\n#define perm(c) sort(ALL(c));for(bool c##p=1;c##p;c##p=next_permutation(ALL(c)))\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define pb push_back\n#define to_s to_string\n#define len(v) (ll)v.size()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define print(x) cout << (x) << '\\n'\n#define drop(x) cout << (x) << '\\n', exit(0)\n#define debug(x) cout << #x << \": \" << (x) << '\\n'\nusing namespace std;\nusing ll = long long;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> vec;\ntypedef vector<vector<ll>> vec2;\ntypedef vector<vector<vector<ll>>> vec3;\ntemplate<class S, class T> inline bool chmax(S &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class S, class T> inline bool chmin(S &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline ll msb(ll v) { return 1 << (31 - __builtin_clzll(v)); }\ninline ll devc(ll x, ll y) { return (x + y - 1) / y; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a * (b / gcd(a, b)); }\n \nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n        cerr << fixed << setprecision(10);\n    }\n} iosetup;\n \ntemplate< typename T1, typename T2 >\nostream &operator << (ostream &os, const pair< T1, T2 > &p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator >> (istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nostream &operator << (ostream &os, const tuple< T1, T2, T3 > &t) {\n    os << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t);\n    return os;\n}\n \ntemplate< typename T1, typename T2, typename T3 >\nistream &operator >> (istream &is, tuple< T1, T2, T3 > &t) {\n    is >> get<0>(t) >> get<1>(t) >> get<2>(t);\n    return is;\n}\n \ntemplate< typename T >\nostream &operator << (ostream &os, const vector< T > &v){\n    for (int i = 0; i < (int)v.size(); ++i) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\n \ntemplate< typename T >\nistream &operator >>  (istream &is, vector< T > &v){\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate< typename T >\nostream &operator << (ostream &os, const set< T > &st){\n    int ct = 0;\n    for(auto& s : st) cout << s << (++ct != st.size() ? \" \" : \"\");\n    return os;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator|= (set<T> &st1, const set<T> &st2) { \n    for(auto& s : st2) st1.insert(s);\n    return st1; \n}\n\ntemplate <typename T>\nconstexpr set<T> &operator-= (set<T> &st1, const set<T> &st2) {\n    for(auto& s : st2) if(st1.count(s)) st1.erase(s);\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> &operator&= (set<T> &st1, const set<T> &st2) {\n    auto itr = st1.begin();\n    while(itr != st1.end()){\n        if(!st2.count(*itr)) itr = st1.erase(itr);\n        else ++itr;\n    }\n    return st1;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator| (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res |= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator- (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res -= st2;\n    return res;\n}\n\ntemplate <typename T>\nconstexpr set<T> operator& (const set<T> &st1, const set<T> &st2) {\n    set<T> res = st1;\n    res &= st2;\n    return res;\n}\n\n/*---------------------------------    Tools    ------------------------------------------*/\ntemplate< typename T >\nvector<T> cumsum(const vector<T> &X){\n    vector<T> res(X.size() + 1, 0);\n    for(int i = 0; i < X.size(); ++i) res[i + 1] += res[i] + X[i];\n    return res;\n}\n \ntemplate< typename S, typename T, typename F>\npair<T, T> bisearch(S left, T right, F f) {\n    while(abs(right - left) > 1){\n        T mid = (right + left) / 2;\n        if(f(mid)) right = mid;\n        else left = mid;\n    }\n    return {left, right};\n}\n \ntemplate< typename S, typename T, typename F>\ndouble trisearch(S left, T right, F f, int maxLoop = 90){\n    double low = left, high = right;\n    while(maxLoop--){\n        double mid_left = high / 3 + low * 2 / 3;\n        double mid_right = high * 2 / 3 + low / 3;\n        if(f(mid_left) >= f(mid_right)) low = mid_left;\n        else high = mid_right;\n    }\n    return (low + high) * 0.5;\n}\n\ntemplate< typename F >\nll ternarySearch(ll L, ll R, F f) { //[L, R)\n    ll lo = L - 1, hi = R - 1;\n    while (lo + 1 != hi) {\n        ll mi = (lo + hi) / 2;\n        if (f(mi) <= f(mi + 1)) hi = mi;\n        else lo = mi;\n    }\n    return hi;\n}\n\n\n/*---------------------------------    Graph    ------------------------------------------*/\n\nstruct Graph {\n    struct Edge {\n        ll from, to, weight;\n        Edge() : from(0), to(0), weight(0) {}\n        Edge(ll f, ll t, ll w) : from(f), to(t), weight(w) {}\n    };\n    using Edges = vector<Edge>;\n\n    vector<Edges> G;\n\n    Graph(int N) : G(N) {}\n\n    Graph(int N, vector<P>& Edges) : G(N) {\n        for(auto e : Edges) add_arrow(e.first, e.second);\n    }\n\n    Graph(int N, vector<tuple<ll, ll, ll>>& Edges) : G(N){\n        for (auto e : Edges) add_arrow(get<0>(e), get<1>(e), get<2>(e));\n    }\n\n    Edges operator[](int k) const{\n        return G[k];\n    }\n\n    int size() const{\n        return G.size();\n    }\n\n    void add_edge(int a, int b, ll w = 1){\n        G[a].emplace_back(a, b, w);\n        G[b].emplace_back(b, a, w);\n    }\n\n    void add_arrow(int a, int b, ll w = 1){\n        G[a].emplace_back(a, b, w);\n    }\n\n    //Topological_sort\n    //!!ONLY FOR DAG\n    vector<ll> topological_sort() const;\n\n    //Dijkstra\n    template< typename T >\n    vector<T> dijkstra(T s, bool restore = false) const;\n\n    //Warshall-Floyd\n    vector<vector<ll>> Warshall_Floyd() const; \n};\n\n\ntemplate< typename T >vector<T> Graph::dijkstra(T s, bool restore) const{\n    vector<T> dist(G.size(), INF);\n    priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n\n    vector<T> prev(G.size(), -1);\n\n    while(!que.empty()){\n        T cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : G[idx]){\n            auto next_cost = cost + e.weight;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n\n            if(restore) prev[e.to] = e.from;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n    if(restore) return prev;\n    return dist;\n}\n\nvector<vector<ll>> Graph::Warshall_Floyd() const {\n    int N = G.size();\n    vector<vector<ll>> d(N, vector<ll>(N));\n\n    rep(i, N) rep(j, N) {\n        if (i == j) d[i][j] = 0;\n        else d[i][j] = INF;\n    }\n\n    rep(i, N) for (auto &e : G[i]) d[i][e.to] = e.weight;\n    rep(k, N) rep(i, N) rep(j, N) {\n        if (d[i][k] == INF or d[k][j] == INF) continue;\n        d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n    }\n    return d;\n}\n\nvector<ll> Graph::topological_sort() const{\n    vector<ll> ans;\n    int N = G.size();\n    vector<int> ind(N);\n    rep(i, N) for (auto &e : G[i]) ind[e.to]++;\n    queue<int> que;\n    rep(i, N) if (!ind[i]) que.push(i);\n    while(!que.empty()){\n        int now  = que.front();\n        ans.pb(now);\n        que.pop();\n        for(auto& e : G[now]) {\n            ind [e.to]--;\n            if(!ind[e.to]) que.push(e.to);\n        }\n    }\n    return ans;\n}\n\n/*------------------------------- Main Code Here -----------------------------------------*/\n \nint main()\n{\n    ll V, E;\n    cin >> V >> E;\n    vector<P> Edges(E);\n    cin >> Edges;\n    Graph G(V, Edges);\n    vec res = G.topological_sort();\n    for (auto r : res) print(r);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool queued;\n    bool flag;\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        queued = 0;\n        flag = 0;\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                glaph[j].flag = 1;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            glaph[i].flag = 1;\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\n\nstruct TopologicalSort\n{\n    int V;\n    vector<int> res, deg, used;\n    vector<vector<int>> G;\n    TopologicalSort(int v) : V(v)\n    {\n        deg.resize(V, 0);\n        used.resize(V, 0);\n        G.resize(V);\n    }\n    void add_edge(int s, int t)\n    {\n        G[s].push_back(t);\n        deg[t]++;\n    }\n    void bfs(int s)\n    {\n        queue<int> que;\n        used[s] = 1;\n        que.push(s);\n        while(que.size())\n        {\n            int v = que.front(); que.pop();\n            res.push_back(v);\n            for(auto &u : G[v])\n            {\n                if(used[u]) continue;\n                deg[u]--;\n                if(deg[u] == 0)\n                {\n                    used[u] = 1;\n                    que.push(u);\n                }\n            }\n        }\n    }\n    vector<int> build()\n    {\n        for(int i = 0; i < V; i++)\n        {\n            if(used[i] or deg[i] > 0) continue;\n            bfs(i);\n        }\n        return res;\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int V, E; cin >> V >> E;\n    TopologicalSort topolo = TopologicalSort(V);\n    for(int i = 0; i < E; i++)\n    {\n        int s, t; cin >> s >> t;\n        topolo.add_edge(s, t);\n    }\n    auto ans = topolo.build();\n    for(auto &x : ans) cout << x << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXV = 10005;\nvector<int> to[MAXV];\nvector<int> out;\n\nbool visited[MAXV];\nvoid dfs(int v)\n{\n  if (visited[v])\n  {\n    return;\n  }\n  visited[v] = true;\n  for (int u : to[v])\n  {\n    dfs(u);\n  }\n  out.push_back(v);\n}\n\nint main()\n{\n  int V, E, s, t;\n  cin >> V >> E;\n  for (int i = 0; i < E; i++)\n  {\n    cin >> s >> t;\n    to[s].push_back(t);\n  }\n  for (int i = 0; i < V; i++)\n  {\n    dfs(i);\n  }\n  reverse(out.begin(), out.end());\n  for (int v : out)\n  {\n    cout << v << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#define V_MAX 10000\n#define E_MAX 100000\nusing namespace std;\n\nint V,E;\nbool check[V_MAX+1],visited[V_MAX+1];\nqueue<int> G[V_MAX+1];//隣接リスト\nqueue<int> order;\nlist<int> TO,TO_tmp;//最後だけでなく先頭にも要素が追加できる点でやはりlistがベストな選択\n\nvoid bfs(){\n\twhile(!order.empty()){\n\t\tint num = order.front();order.pop();\n\t\tif(visited[num])return;visited[num] = true;check[num] = true;\n\t\tTO_tmp.push_back(num);\n\t\twhile(!G[num].empty()){\n\t\t\tif(!check[G[num].front()]){\n\t\t\t\torder.push(G[num].front());\n\t\t\t\tcheck[G[num].front()] = true;\n\t\t\t}\n\t\t\tG[num].pop();\n\t\t}\n\t}\n\twhile(!TO_tmp.empty()){\n\t\tTO.push_front(TO_tmp.back());\n\t\tTO_tmp.pop_back();\n\t}\n}\n\n\nvoid solve(){\n\tfor(int i = 0;i < V;i++){check[i] = false;visited[i] = false;}\n\tint vs,ve;\n\tfor(int i = 0;i < E;i++){\n\t\tcin >>vs >>ve;\n\t\tG[vs].push(ve);\n\t}\n\tfor(int i = 0;i < V;i++){order.push(i);bfs();}\n\twhile(!TO.empty()){cout <<TO.front() <<endl;TO.pop_front();}\n\treturn;\n}\n\nint main(){\n\tcin >>V >>E;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\nstruct P{\n\tint pos,time;\n};\nbool operator<(P a,P b){return a.time<b.time;}\nint a[100000],n,m,u1,u2;\nP b[100000];\nvector<int>e[100000];\nint main() {\n\tcin>>m>>n;\n\tfor(int i=1;i<=m;i++){\n\t\tb[i]=P{i,-1};\n\t\ta[i]=0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>u1>>u2;\n\t\te[u1].push_back(u2);\n\t\ta[u2]++;\n\t}\n\tqueue<int>p;\n\tfor(int i=1;i<=m;i++){\n\t\tif(a[i]==0){\n\t\t\tp.push(i);\n\t\t\tb[i].time=0;\n\t\t}\n\t}\n\twhile(!p.empty()){\n\t\tint t=p.front();p.pop();\n\t\tfor(int i=0;i<e[t].size();i++){\n\t\t\tif(b[e[t][i]].time<b[t].time+1){\n\t\t\t\tb[e[t][i]].time=b[t].time+1;\n\t\t\t\tp.push(e[t][i]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(b+1,b+m+1);\n\tfor(int i=1;i<=m;i++){\n\t\tcout<<b[i].pos<<endl;\n\t}\n\t//cout<<2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    int V,E;\n    cin >> V >> E;\n    vector<int> s(E);\n    vector<int> t(E);\n    vector<int> res;\n    vector< vector<int> > v(V,vector<int>(V,0));\n    vector<bool> used(V,false);\n    int count = 0;\n\n    REP(i,E) scanf(\"%d%d\",&s[i],&t[i]);\n    REP(i,E) v[s[i]][t[i]] = 1;\n    REP(i,V){\n\tREP(j,V){\n\t    if(used[j]) continue;\n\t    count = 0;\n\t    REP(k,V) if(v[k][j]) count++;\n\t    if(count == 0){\n\t\tres.PB(j);\n\t\tused[j] = true;\n\t\tREP(k,V) v[j][k] = 0;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    REP(i,V) cout << res[i] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n\nusing namespace std;\n\nconst int MAXN=10010;\n\ntypedef vector<int> vec;\ntypedef vector<vec> Graph;\n\nGraph G(MAXN);\nvec d(MAXN);\n\nint main()\n{\n\tint n,e;\n\tscanf(\"%d%d\",&n,&e);\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tG[s].push_back(t);\n\t\td[t]++;\n\t}\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++)\n\t\tif(d[i]==0)\n\t\t\tque.push(i);\n\twhile(!que.empty())\n\t{\n\t\tint t=que.front();que.pop();\n\t\tprintf(\"%d\\n\",t);\n\t\td[t]=INT_MAX;\n\t\tfor(int i=0;i<G[t].size();i++)\n\t\t{\n\t\t\td[G[t][i]]--;\n\t\t\tif(d[G[t][i]]==0)\n\t\t\t\tque.push(G[t][i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1LL << 29);\n\nvector<int> G[MAX]\nlist<int> out;\nbool V[MAX]\nint N;\nint indeg[MAX]\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n\n  for (int u = 0; u < N; u++) {\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) {\n      bfs(u);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> tsort(const Graph &g){\n    int n = g.size();\n    vector<int> ord(n, -1);\n    int k = 0;\n    for(int i = 0; i < n; i++){\n        if(ord[i] != -1) continue;\n        vector<int> s = { i };\n        while(s.size()){\n            int v = s.back();\n            s.pop_back();\n            if(v >= 0){\n                s.push_back(~v);\n                if(ord[v] >= 0) continue;\n                ord[v] = -2;\n                for(auto &e : g[v]){\n                    if(ord[e.dst] == -2) return {};\n                    if(ord[e.dst] == -1) s.push_back(e.dst);\n                }\n            } else {\n                v = ~v;\n                if(ord[v] >= 0) continue;\n                ord[v] = k++;\n            }\n        }\n    }\n    reverse(ord.begin(), ord.end());\n    return ord;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rept(i,n) for(int (i)=0;(i)<=(int)(n);(i)++)\n#define reps(i,s,n) for(int (i)=(s);(i)<(int)(n);(i)++)\n#define repst(i,s,n) for(int (i)=(s);(i)<=(int)(n);(i)++)\n#define repr(i,n) for(int (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln \"\\n\"\n#define show(x) cout << #x << \" = \" << x ln\n#define dbg(x) cout<<#x\"=\"<<x ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int>> mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ??????????????????????????????????????????( ^??^)??????????????????????????????????????????\n\n// ????????°????????°?????\\?¬???°\nint v, e, in[100000];\n// ??\\?¬???°0???????????????????????\\????????????\nqueue<int> S;\n// ????????£??\\?????????\nmat V(100000);\n// ??????\nvi ans;\n\nint main() {\n\tcin >> v >> e;\n\trep(i,e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tV[a].pb(b);\n\t\tin[b]++;\n\t}\n\t\n\t// ??\\?¬???°0??????????????????\n\trep(i,v) if (in[i]==0) S.push(i);\n\twhile (!S.empty()) {\n\t\tint u = S.front(); S.pop();\n\t\tans.pb(u);\n\t\t// u?????????????¢???????????????§??°?????????????¶?????????£??\\????????¨??????????????\\?¬???°???1?????????\n\t\teach(itr,V[u]) {\n\t\t\tin[itr]--;\n\t\t\t// ????????????????????£?????\\?¬???°???0????????£?????????????????°S?????????\n\t\t\tif (in[itr]==0) S.push(itr);\n\t\t}\n\t}\n\trep(i,v) cout << ans[i] << ln;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int s = 0, const int d = 0, const Weight w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int i) const { return g[i]; }\n  void addArc(const int src, const int dst, const Weight w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int node1, const int node2, const Weight w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nstd::vector<int> tsort(const Graph &g) {\n  int n = g.size(), k = 0;\n  std::vector<int> ord(n), in(n);\n  for (auto &es : g) {\n    for (auto &e : es) in[e.dst]++;\n  }\n  std::queue<int> q;\n  rep(i, n) if (in[i] == 0) q.push(i);\n  while (q.size()) {\n    int v = q.front();\n    q.pop();\n    ord[k++] = v;\n    for (auto &e : g[v])\n      if (--in[e.dst] == 0) q.push(e.dst);\n  }\n  return *std::max_element(in.begin(), in.end()) == 0 ? ord : std::vector<int>();\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int s, t;\n    cin >> s >> t;\n    g.addArc(s, t);\n  }\n  vi v = tsort(g);\n  for (auto &x : v) cout << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> tsort(const Graph &g){\n    int n = g.size();\n    vector<int> ord(n), indeg(n);\n    for(auto &es : g) for(auto &e : es) indeg[e.dst]++;\n    queue<int> q;\n    for(int i = 0; i < n; ++i) if (indeg[i] == 0) q.push(i);\n    int k = 0;\n    while(!q.size()){\n        int v = q.front(); q.pop();\n        ord[k++] = v;\n        for (auto &e : g[v]) {\n            indeg[e.dst]--;\n            if (indeg[e.dst] == 0) q.push(e.dst);\n        }\n    }\n    return ord;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint indeg[10000],s,t,V,E;\nvector<int> A[10000];\nbool flag[10000]={false};\nvector<int> ans;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid bfs(int a){\n    queue<int> Q;\n    Q.push(a);\n    flag[a]=true;\n\n    while(!Q.empty()){\n        int u=Q.front();\n        Q.pop();\n        ans.push_back(u);\n\n        for(int i=0;i<A[u].size();++i){\n            --indeg[A[u][i]];\n            if(indeg[A[u][i]]==0 && flag[A[u][i]]==false){\n                flag[A[u][i]]=true;\n                Q.push(A[u][i]);\n            }\n        }\n    }\n\n}\n\nvoid tp_srt(){\n    \n    for(int i=0;i<V;++i){\n        if(indeg[i]==0 && flag[i]==false){\n            bfs(i);\n        }\n    }\n}\n\nint main(){\n    \n    cin>>V>>E;\n    Fill(flag,false);\n\n    \n    for(int i=0;i<E;++i){\n        cin>>s>>t;\n        A[s].push_back(t);\n    }\n    \n    for(int i=0;i<V;++i){\n        for(int j=0;j<A[i].size();++j){\n            ++indeg[A[i][j]];\n        }\n    }\n    \n    tp_srt();\n\n    for(int i=0;i<ans.size();++i){\n        cout<<ans[i]<<\"\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG;\n  vector<bool> used;\n  vector<int> cmp,vs;\n\n  SCC(int V=0):V(V){\n    G.resize(V,vector<int>()), rG.resize(V,vector<int>()), cmp.resize(V), used.resize(V);\n  }\n\n  void add_edge(int s,int t){\n    G[s].push_back(t);\n    rG[t].push_back(s);\n  }\n\n  void dfs(int v){\n    used[v] = true;\n    rep(i,(int)G[v].size()) if( !used[G[v][i]] ) dfs(G[v][i]);\n    vs.push_back(v);\n  }\n\n  void rdfs(int v,int k){\n    used[v] = true;\n    cmp[v] = k;\n    rep(i,(int)rG[v].size()) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n  }\n\n  int scc(){\n    rep(i,V) used[i] = false;\n    vs.clear();\n    rep(v,V) if( !used[v] ) dfs(v);\n    rep(i,V) used[i] = false;\n    int k = 0;\n    for(int i=vs.size()-1;i>=0;i--) if( !used[vs[i]] ) rdfs(vs[i],k++);\n    return k;\n  }\n\n};\n\nint main() {\n  int V,E;\n  cin >> V >> E;\n  SCC scc(V);\n  rep(i,E) {\n    int s,t;\n    cin >> s >> t;\n    scc.add_edge(s,t);\n  }\n  scc.scc();\n  rep(i,V) cout << scc.vs[i] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\ntemplate<typename T>\nclass TopologicalSort {\nprivate:\n    map<T, bool> is;\n    map<T, vector<T>> g;\n    vector<T> tsort;\n\tmap<T, long long> inCnt;\n    void dfs(T now) {\n        if (is[now]) return;\n\t\tis[now] = true;\n        for (auto &&el : g[now]) {\n            dfs(el);\n        }\n        tsort.emplace_back(now);\n    }\npublic:\n    TopologicalSort() {}\n\tTopologicalSort(const vector<T>& vec) {\n\t\tfor (auto &&el : vec) {\n\t\t\tg[el].resize(0);\n\t\t\tis[el] = false;\n\t\t}\n\t}\n    vector<T> dfsTsort() {\n        for (auto &&el : g) {\n            dfs(el.first);\n        }\n        reverse(tsort.begin(), tsort.end());\n        return tsort;\n    }\n\tvoid addEdge(T src, T dst) {\n\t\tg[src].emplace_back(dst);\n\t\tinCnt[dst]++;\n\t}\n\tvector<T> bfsTsort() {\n\t\tqueue<T> q;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second == 0) {\n\t\t\t\tq.push(el.first);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tT now = q.front(); q.pop();\n\t\t\ttsort.emplace_back(now);\n\t\t\tfor (auto &&el : g[now]) {\n\t\t\t\tif (--inCnt[el] == 0) q.push(el);\n\t\t\t}\n\t\t}\n\t\tbool endFlag = true;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second) endFlag = false;\n\t\t}\n\t\treturn (endFlag ? tsort : vector<T>());\n\t}\n};\n\nint main(void) {\n\tint V, E;\n\tcin >> V >> E;\n\tVI v(V);\n\tiota(ALL(v), 0);\n\tTopologicalSort<int> t(v);\n\tREP(_, E) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\t\tt.addEdge(s, d);\n\t}\n\tauto ans = t.bfsTsort();\n\tFORE(el, ans) cout << el << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int  MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint n;\n\nvoid dfs(int u){\n    V[u]=true;\n    for(int i=0;i<G[u].size();i++){\n        int v =G[u][i];\n        if(!V[v])dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,q;\n    \n    cin>>n>>q;\n    \n    for(int i=0;i<n;i++)V[i]=false;\n    \n    for(int i=0;i<q;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    \n    for(int i=0; i<n; i++){\n        if(!V[i])dfs(i);\n    }\n    \n    for(list<int>::iterator it =out.begin();it !=out.end();it++) cout<<*it<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define int long long\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nvi G[10001];\nint in[10001];\n\nsigned main()\n{\n    int V, E; cin >> V >> E;\n\n    for (int i = 0; i < E; ++i) {\n        int s, t; cin >> s >> t;\n\n        G[s].PB(t);\n        in[t]++;\n    }\n\n    vi ans;\n\n    queue<int> St;\n\n    for (int i = 0; i < V; ++i) {\n        if (in[i] == 0) St.push(i);\n    }\n\n    while (St.size()) {\n        int st = St.front(); St.pop();\n\n        ans.push_back(st);\n\n        for (int v : G[st]) {\n            in[v]--;\n\n            if (in[v] == 0) St.push(v);\n        }\n    }\n\n    for (int a : ans) cout << a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n#include<climits>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const long long INFTY = (1LL<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\nvoid bfs(int s)\n{\n  queue<int> q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty())\n    {\n      int u=q.front();q.pop();\n      out.push_back(u);\n      for(int i=0;i<G[u].size();i++)\n\t{\n\t  int v = G[u][i];\n\t  indeg[v]--;\n\t  if(indeg[v] == 0 && !V[v])\n\t    {\n\t      V[v]=true;\n\t      q.push(v);\n\t    }\n\t}\n    }\n}\n\nvoid tsort()\n{\n  for (int i=0;i<N;i++)\n    {\n      indeg[i]=0;\n    }\n  for(int u=0;u<N;u++)\n    {\n      for(int i=0;i< G[u].size();i++)\n\t{\n\t  int v=G[u][i];\n\t  indeg[v]++;\n\t}\n    }\n  for(int u=0;u<N;u++)\n    if(indeg[u]==0 && !V[u])bfs(u);\n  \n  for(list<int>::iterator it = out.begin(); it != out.end();it++)\n    {\n      cout << *it << endl;\n    }\n}\n\nint main()\n{\n  int s,t,M;\n  cin >> N >> M;\n  \n  for(int i=0;i<N;i++) V[i]=false;\n  for(int i=0;i<M;i++)\n    {\n      cin >> s >> t;\n      G[s].push_back(t);\n    }\n  tsort();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> topological_sort(vector<vector<int>> &E){\n\tint N = E.size();\n\tvector<int> deg(N, 0);\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j : E[i]){\n\t\t\tdeg[j]++;\n\t\t}\n\t}\n\tqueue<int> Q;\n\tfor (int i = 0; i < N; i++){\n\t\tif (deg[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\twhile (!Q.empty()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tans.push_back(v);\n\t\tfor (int w : E[v]){\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] == 0){\n\t\t\t\tQ.push(w);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; i++){\n    int s, t;\n    cin >> s >> t;\n    E[s].push_back(t);\n  }\n  vector<int> ans = topological_sort(E);\n  for (int i = 0; i < N; i++){\n    cout << ans[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = long long;\nconst LL MOD = 1e9+7;\n// int main()\n// {\n//     cin.tie(0);\n//     ios::sync_with_stdio(false);\n//\n//     {{_cursor_}}\n//\n//     return 0;\n// }\nvoid topological_sort(const vector<vector<int>>& G, vector<int>& ord)\n{\n    int n = G.size();\n    vector<int> num(n, 0);\n    ord.assign(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (int u : G[i]) {\n            ++num[u];\n        }\n    }\n    stack<int> st;\n    for(int i = 0; i < n; ++i) {\n        if (num[i] == 0) {\n            st.push(i);\n        }\n    }\n    for (int k = 0; !st.empty(); ++k) {\n        int i = st.top(); st.pop();\n        ord[k] = i;\n        for (int u : G[i]) {\n            if (--num[u] == 0) {\n                st.push(u);\n            }\n        }\n    }\n}\nint main() {\n    int V, E; cin >> V >> E;\n    vector<vector<int>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n    }\n    vector<int> ord;\n    topological_sort(G, ord);\n    for (int v : ord) {\n        cout << v << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\n//typedef pair<int,int> P;\n//typedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct TopologicalSort {\n\tint n;\n\tvector< vector<int> > G;\n\tvector<int> flg,order;\n\n\tenum { YET,VISITED,DONE };\n\n\tTopologicalSort() {}\n\tTopologicalSort(int sz):n(sz),G(sz),flg(sz),order(0) {};\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t}\n\n\tbool dfs(int v) {\n\t\tflg[v]=VISITED;\n\t\tfor(auto u:G[v]) {\n\t\t\tif(flg[u]!=DONE&&(flg[u]==VISITED||!dfs(u))) return false;\n\t\t}\n\t\tflg[v]=DONE;\n\t\torder.push_back(v);\n\t\treturn true;\n\t}\n\n\tvector<int> topological_sort() {\n\t\tfill(flg.begin(),flg.end(),0);\n\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(flg[v]==YET&&!dfs(v)) return {};\n\t\t}\n\t\treverse(order.begin(),order.end());\n\n\t\treturn order;\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint v,e;cin>>v>>e;\n\tTopologicalSort tsort(v);\n\n\tREP(i,e) {\n\t\tint a,b;cin>>a>>b;\n\t\ttsort.add_edge(a,b);\n\t}\n\tauto order=tsort.topological_sort();\n\tfor(auto u:order) cout<<u<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<list>\n#include<vector>\nusing namespace std;\nstatic const int MAX=100000;\nvector<int> G[MAX];\nint N;\nlist<int>out;\nbool V[MAX];\nvoid dfs(int u)\n{\n    V[u]=true;\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i];\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\nint main()\n{\n    int s,t,M;\n    scanf(\"%d %d\",&N,&M);\n    for(int i=0;i<N;i++)\n        V[i]=false;\n    for(int i=0;i<M;i++)\n    {\n        scanf(\"%d %d\",&s,&t);\n        G[s].push_back(t);\n    }\n    for(int i=0;i<N;i++)\n    {\n        if(!V[i]) dfs(i);\n    }\n    for(list<int>::iterator it = out.begin();it!=out.end();it++)\n        cout<< *it<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <math.h>\n#include <deque>\n#include <queue>\n#include <map>\n#include <iterator>\n#include <set>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\n#define debug(var)  do{std::cout << #var << \" : \";view(var);}while(0)\ntemplate<typename T> void view(T e) { std::cout << e << std::endl; }\ntemplate<typename T> void view(const std::vector<T>& v) { for (const auto& e : v) { std::cout << e << \" \"; } std::cout << std::endl; }\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv) { for (const auto& v : vv) { view(v); } }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n\nconst int mxV = 10009;\nconst int mxE = 100009;\nvector<int> G[mxV];\nint in[mxV];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint v, e;\n\tcin >> v >> e;\n\tfill(in, in + v, 0);\n\tfor (int i = 0; i < e; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tin[b]++;\n\t}\n\n\tqueue<int> Q;\n\tfor (int i = 0; i < v; i++) {\n\t\tif (in[i] == 0) {\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tvector<int> ans;\n\n\twhile (!Q.empty()) {\n\t\tint p = Q.front();\n\t\tQ.pop();\n\n\t\tfor (auto e : G[p]) {\n\t\t\tin[e]--;\n\t\t\tif (in[e] == 0) {\n\t\t\t\tQ.push(e);\n\t\t\t}\n\t\t}\n\n\t\tans.push_back(p);\n\t}\n\n\tfor (auto e : ans) {\n\t\tcout << e << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int INFTY = (1 << 29);\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u)\n{\n    V[u] = true;\n    for (int i = 0; i != G[u].size(); ++i)\n    {\n        int v = G[u][i];\n        if (V[v] == false) dfs(v);\n    }\n    out.push_front(u);\n}\n\nvoid tsort()\n{\n    for (int i = 0; i != N; ++i)\n    {\n        V[i] = false;\n    }\n    for (int i = 0; i != N; ++i)\n    {\n        if (V[i] == false) dfs(i);\n    }\n    for (list<int>::iterator it = out.begin(); it != out.end(); ++it)\n    {\n        cout << *it << endl;\n    }\n}\n\nint main()\n{\n    int M, s, t;\n    cin >> N >> M;\n    for (int i = 0; i != M; ++i)\n    {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <list>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define sz(x) int(x.size())\n\ntypedef long long ll;\n\nusing namespace std;\n\n/*******-c++14 don't include-*******/\ntemplate<typename T>\nT gcd(T a, T b){if( b == 0)return a; return gcd(b, a%b); }\ntemplate<typename T>\nT lcm(T a, T b){return a*b/gcd(a,b); }\n/*******---------------------*******/\n\nstatic const int INTINF = (2147483647);\nstatic const ll LLINF = (1ll<<32);\nstatic const int MAX = 100001;\n\nint main(int argc, const char * argv[]) {\n    // input from txt\n\n    /////////\n    //write//\n    /////////\n    \n    int v, e;\n    cin >> v >> e;\n    vector<int> glaph[MAX];\n    int degree[MAX];\n    bool col[MAX];\n    \n    rep(i, e){\n        int s, t;\n        cin >> s >> t;\n        glaph[s].push_back(t);\n    }\n    \n    fill(degree, degree+v, 0);\n    fill(col, col+v, false);\n    \n    rep(i, v){\n        rep(j, glaph[i].size()){\n            degree[glaph[i][j]]++;\n        }\n    }\n    \n    queue<int> res;\n    rep(i, v){\n        if(degree[i] == 0 && !col[i]){\n            queue<int> q;\n            q.push(i);\n            col[i] = true;\n            while(!q.empty()){\n                int u = q.front(); q.pop();\n                res.push(u);\n                rep(j, glaph[u].size()){\n                    int u2 = glaph[u][j];\n                    degree[u2] --;\n                    if(degree[u2] == 0 && !col[u2]){\n                        col[u2] = true;\n                        q.push(u2);\n                    }\n                }\n            }\n        }\n    }\n    \n    while(!res.empty()){\n        int foo = res.front(); res.pop();\n        cout << foo;\n        cout << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int MAX = 10005;\n\nbool visited[MAX];\nint N, indeg[MAX];\nvector<int> G[MAX];\nlist<int> out;\n\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && visited[v] == false){\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++) indeg[i] = 0;\n\n    for(int u=0; u<N; u++){\n        for(int i=0; i<G[u].size(); i++){\n            indeg[G[u][i]]++;\n        }\n    }\n\n    for(int u=0; u<N; u++){\n        if(indeg[u] == 0 && !visited[u]) bfs(u);\n    }\n\n    for(auto itr = out.begin(); itr != out.end(); itr++){\n        cout << *itr << endl;\n    }\n\n}\n\nint main(void){\n    int M; cin >> N >> M;\n\n    for(int i=0; i<N; i++) visited[i] = false;\n\n    for(int i=0; i<M; i++){\n        int s, t; cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nconst int N = 10000;\nconst int WHITE = 0;\nconst int  GRAY = 1;\nconst int BLACK = 2;\n\nvector<int> G[N];\nvector<int> ans;\nint V;\nint degIn[N], color[N];\n\nqueue<int> Q;\n\nvoid bfs(int s){\n    if( degIn[s] > 0 || color[s] == BLACK) return;\n\n    Q.push(s);\n\n    int u;\n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        ans.push_back(u);\n        color[u] = BLACK;\n        for(int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            degIn[v]--;\n            if(degIn[v] == 0 && color[v] != BLACK){\n                Q.push(v);\n            }\n        } \n    }\n\n}\n\nvoid solve(){\n    rep(i,V) bfs(i);\n\n    rep(i,V) printf(\"%d\\n\", ans[i]);\n}\n\n\nint main(){\n    int E;\n    cin >> V >> E;\n\n    rep(i,V){\n        color[i] = WHITE;\n        degIn[i] = 0;\n    }\n\n    int s, t;\n    rep(i,E){\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n        degIn[t]++;\n    }\n\n    solve();\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 10005\n\nint n,q;\nint indeg[MAX];\nbool color[MAX];\nvector<int> G[MAX];\nvector<int> R;\n\nvoid bfs(int point){\n    queue<int> q;\n    q.push(point);\n    color[point] = false;\n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        R.push_back(u);\n        for(int i=0;i<G[u].size();++i){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&color[v]==true){\n                color[v] = false;\n                q.push(v);\n            }\n        }\n    }\n}\n\n\nint main(){\n    int v, e, s, t;\n    scanf(\"%d %d\",&v,&e);\n    for(int i=0;i<v;++i){\n        indeg[i] = 0;\n        color[i] = true;\n    }\n    for(int i=0;i<e;++i){\n        scanf(\"%d %d\",&s,&t);\n        indeg[t]++;\n        G[s].push_back(t);\n    }\n    for(int i=0;i<v;++i){\n        if(indeg[i]==0 && color[i]==true){\n            bfs(i);\n        }\n    }\n    for(int i=0;i<R.size();++i){\n        printf(\"%d\\n\",R[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(i,n) for(auto &i:n)\n\nint n, m, a, b;\nvi e[10000];\n\nvi tsort(int v, vi *e) {\n\tstack<int> st;\n\tint ny[v] = {0};\n\trep(i,v) rep(j,e[i].size()) ny[e[i][j]]++;\n\trep(i,v) {\n\t\tif (ny[i]) continue;\n\t\tst.push(i);\n\t}\n\tvi res;\n\twhile (!st.empty()) {\n\t\tint ne = st.top(); st.pop();\n\t\tres.push_back(ne);\n\t\trep(i,e[ne].size()) if (--ny[e[ne][i]]==0) st.push(e[ne][i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> m;\n\trep(i,m) {\n\t\tcin >> a >> b;\n\t\te[a].push_back(b);\n\t}\n\tvi r = tsort(n,e);\n\trep(i,n) cout << r[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for(i = 0;i < n;++i)\n#define pb push_back\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n\nstruct edge{\n  int to;\n};\n\nvector<edge> G[10000];\nint v, e;\n\n#define maxV 10000\nint in[maxV] = {0};\nint ord[maxV] = {0};\nint topo[maxV] = {0}, topohd = 0;\nvoid toposort(void){\n  for(int i = 0;i < v;++i)for(int j = 0;j < G[i].size();++j)++in[G[i][j].to];\n  queue<int> Q;\n  for(int i = 0;i < v;++i)if(in[i] == 0)Q.push(i);\n  for(;!Q.empty();){\n    int now = Q.front(); Q.pop();\n    topo[topohd++] = now;\n    for(int i = 0;i < G[now].size();++i)if(--in[G[now][i].to] == 0)Q.push(G[now][i].to);\n  }\n  return;\n}\n\nsigned main(void){\n  int i, j;\n  scanf(\"%d%d\", &v, &e);\n  rep(i, e){\n    int2(a, b);\n    G[a].pb((edge){b});\n  }\n\n  toposort();\n  rep(i, v)printf(\"%d\\n\", topo[i]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N, E;\nint g[10000][10000];\nvector<int> out;\nchar col[10000];\n\nvoid toposort(int s) {\n    col[s] = 'g';\n    for (int i = 0; i < N; ++i) {\n        if(g[s][i] && col[i] == 'w') {\n            toposort(i);\n        }\n    }\n    out.push_back(s);\n}\nint main() {\n    cin >> N >> E;\n    for (int i = 0; i < E; ++i) {\n        int s, t ;\n        cin >> s >> t;\n        g[s][t] = 1;\n    }\n\n    for (int j = 0; j < N; ++j) {\n        col[j] = 'w';\n    }\n    for (int k = 0; k < N; ++k) {\n        int sum = 0;\n        for (int i = 0; i < N; ++i) {\n            sum += g[i][k];\n        }\n        if(!sum && col[k] == 'w') {\n\n            toposort(k);\n        }\n    }\n\n    for (int l = N-1; l >=0; --l) {\n        if(l != N-1) cout << \" \";\n        cout << out.at(l) ;\n    }\n    cout <<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n#include <sys/time.h>\n#include <random>\n\n\n#define fs first\n#define sc second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\n\n\nclass Graph{\n    struct edge{\n        int vertice;\n        ll weight;\n    };\n\n    vector<vector<edge>> g;\n    unsigned int n;\n\npublic:\n    Graph(unsigned int n): n{n}{\n        g.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        g[u].emplace_back(edge{v, 1});\n    };\n\n    void add_edge(int u, int v, ll w){\n        g[u].emplace_back(edge{v, w});\n    }\n\n    vector<edge>& get_edge(int v){\n        return g[v];\n    }\n\n    unsigned int get_num_vertices() const{\n        return n;\n    }\n\n    unsigned int size() const{\n        return n;\n    }\n\n    vector<edge>& operator[](int v){\n        return get_edge(v);\n    }\n};\n\nvector<int> topologicalSort(Graph g){\n    int n = g.size();\n    vector<int> h(n, 0);\n\n    for(int i = 0; i < n; i++){\n        for(auto e: g[i]){\n            h[e.vertice]++;\n        }\n    }\n\n    stack<int> st;\n    for(int i = 0; i < n; i++){\n        if(h[i] == 0){\n            st.push(i);\n        }\n    }\n\n    vector<int> ans;\n    while(!st.empty()){\n        int v = st.top(); st.pop();    // 次数が0の頂点を取り出す\n        ans.push_back(v);\n        for(auto e: g[v]){\n            if(--h[e.vertice] == 0){\n                st.push(e.vertice);\n            }\n        }\n    }\n\n    return ans;\n}\n\n\nint main(){\n    int n, m;   cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s, t; ll w;\n        cin >> s >> t;\n//        s--; t--;\n        g.add_edge(s, t);\n//        g.add_edge(t, s);\n    }\n\n    vector<int> ans = topologicalSort(g);\n    for(auto x: ans){\n        cout << x << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n////////////////////////////////////////////////\nint n,m;\nbool V[10000];\nint indeg[10000];\nVI G[10000];\nLI out;\n\nvoid bfs(int s)\n{\n\tqueue<int> Q;\n\tQ.push(s);\n\tV[s]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tout.PB(u);\n\t\t\n\t\tREP(i,SZ(G[u]))\n\t\t{\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v]==0&&!V[v])\n\t\t\t{\n\t\t\t\tV[v]=true;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topologicalS()\n{\n\tREP(u,n)\n\t{\n\t\tif(!indeg[u]&&!V[u])\n\t\t{\n\t\t\tbfs(u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>n>>m;\n\tREP(i,m)\n\t{\n\t\tint s,t;cin>>s>>t;\n\t\tG[s].PB(t);\n\t\tindeg[t]++;\n\t}\n\ttopologicalS();\n\t\n\tfor(list<int>::iterator it=out.begin();it!=out.end();it++)\n\t{\n\t\tcout<<*it<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=10005;\n\nint n,m;\nbool vis[maxn];\nvector<int>G[maxn];\nvector<int>ans;\n\nvoid dfs(int u) {\n    vis[u]=1;\n    for (int v:G[u])\n        if (!vis[v]) dfs(v);\n    ans.pb(u);\n}\n\nint main() {\n    cin>>n>>m;\n    for (int i=0;i<m;i++) {\n        int u,v; cin>>u>>v;\n        G[u].pb(v);\n    }\n    for (int i=0;i<n;i++)\n        if (!vis[i]) dfs(i);\n    for(auto it=ans.rbegin(); it!=ans.rend();it++) cout <<*it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nconst int maxint = 1e9;\nstruct timestamp;\nvector<int> shortest, indeg;\nvector<vector<int>> connective;\n\nvoid dag(int n)\n{\n    vector<int> search;\n    vector<int> new_search;\n\n    for (int i = 0; i < n; i++)\n    {\n\n        if (indeg[i] == 0)\n        {\n            search.push_back(i);\n            cout << i << endl;\n        }\n    }\n    while (!search.empty())\n    {\n        for (auto itr = search.begin(); itr != search.end(); itr++)\n        {\n            for (auto itr2 = connective[*itr].begin(); itr2 != connective[*itr].end(); itr2++)\n            {\n                indeg[*itr2] -= 1;\n                if (indeg[*itr2] == 0)\n                {\n                    new_search.push_back(*itr2);\n                    indeg[*itr2] = -1;\n                    cout << *itr2 << endl;\n                }\n            }\n        }\n        search.clear();\n        search = new_search;\n        new_search.clear();\n    }\n}\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, s, t, m, maxindex;\n    cin >> n >> m;\n    connective.resize(n);\n    indeg.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        shortest.push_back(maxint);\n        indeg.push_back(0);\n    }\n    for (int i = 0; i < m; i++)\n    {\n        cin >> s >> t;\n        connective[s].push_back(t);\n        indeg[t]++;\n    }\n\n    dag(n);\n\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n// for (int j = 0; j < m; j++)\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define MOD 1000000007\n#define REP(i, N) for (int i = 0; i < N; ++i)\n#define REP1(i, N) for (int i = 1; i <= N; ++i)\n#define RREP(i, N) for (int i = N - 1; i >= 0; --i)\n#define ALL(a) a.begin(), a.end()\n\nint v, e;\nvector<int> G[10000];\nint in[10000];\nvector<int> ans;\n\nint main() {\n  cin >> v >> e;\n  REP(i, e) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);  // s -> t\n    in[t]++;\n  }\n  queue<int> que;\n  REP(i, v) {\n    if (in[i] == 0) que.push(i);\n  }\n  while (que.size()) {\n    int p = que.front();\n    que.pop();\n    ans.push_back(p);\n    REP(i, G[p].size()) {\n      int q = G[p][i];\n      in[q]--;\n      if (in[q] == 0) que.push(q);\n    }\n  }\n  REP(i, ans.size()) cout << ans[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<queue>\n#include<list>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint N;\nint indeg[MAX];\nvoid bfs(int u)\n{\n    queue<int>q;\n    q.push(u);\n    V[u]=true;\n    while(!q.empty())\n    {\n        int v=q.front();\n        q.pop();\n        out.push_back(v);\n        for(int i=0; i<G[v].size(); i++)\n        {\n            int u=G[v][i];\n            indeg[u]--;\n            if(indeg[u]==0&&!V[u])\n            {\n                q.push(u);\n                V[u]=true;\n            }\n        }\n    }\n}\nvoid tsort()\n{\n    for(int i=0; i<N; i++)\n    {\n        V[i]=false;\n        indeg[i]=0;\n    }\n    for(int i=0; i<N; i++)\n    {\n        for(int j=0; j<G[i].size(); j++)\n        {\n            int v=G[i][j];\n            indeg[v]++;\n        }\n    }\n    for(int u=0; u<N; u++)\n        if(indeg[u]==0&&!V[u])bfs(u);\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++)\n    {\n        cout<<*it<<endl;\n    }\n}\nint main()\n{\n    int e,v,c;\n    cin>>N>>e;\n    for(int i=0; i<e; i++)\n    {\n        cin>>v>>c;\n        G[v].push_back(c);\n    }\n    tsort();\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1L << (x))\nusing ll = long long;\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nvector<int> t_sort(const Graph& g){\n  int n = g.size();\n  vector<int> sorted;\n  vector<int> in(n, 0);\n\n  for(int v=0; v<n; v++){\n    for(const auto& to: g[v]){\n      in[to]++;\n    }\n  }\n\n  queue<int> que;\n\n  for(int i=0; i<n; i++){\n    if(in[i] == 0){\n      que.push(i);\n    }\n  }\n\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    sorted.emplace_back(now);\n    for(const auto& to: g[now]){\n      in[to]--;\n      if(in[to] == 0){\n        que.push(to);\n      }\n    }\n  }\n\n  return sorted;\n}\n\nint main(){\n  int n, m; cin >> n >> m;\n  Graph g(n);\n  REP(i, m){\n    int x, y; cin >> x >> y;\n    //x--; y--;\n    g[x].emplace_back(y);\n  }\n\n  vector<int> sorted = t_sort(g);\n  for(const auto& node: sorted){\n    cout << node << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\nconstexpr int MOD = 1000000007;\nconstexpr int INF = 2000000000;\nusing namespace std;\n\nconstexpr int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.emplace_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tif (indeg[u] == 0 && !V[u])bfs(u);\n\t}\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tV[i] = false;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].emplace_back(t);\n\t}\n\ttsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100000\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n\n// プロトタイプ宣言\nvoid tSort();\nvoid dfs(int s);\n// ここまでプロトタイプ宣言\n\n\nint v,e;\nvector<int> Graph[MAX];\nint color[MAX];\nlist<int> out;\n\nint main(){\n\n\tfor(int i=0;i<MAX;i++){\n\t\tcolor[i]=WHITE;\n\t}\n\n\tcin>>v>>e;\n\tint from,to;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>from>>to;\n\t\tGraph[from].push_back(to);\n\t}\n\n\ttSort();\n\n\tfor(list<int>::iterator it=out.begin();\tit!=out.end();\tit++){\n\t\tcout<< *it <<endl;\n\t}\n\n\treturn 0;\n}\n\nvoid dfs(int s){\n\tcolor[s]=GRAY;\n\n\tfor(int next: Graph[s]){\n\t\tif(color[next]==WHITE) dfs(next);\n\t}\n\tout.push_front(s);\n}\n\nvoid tSort(){\n\tfor(int s=0;s<v;s++){\n\t\tif(color[s]==WHITE){\n\t\t\tdfs(s);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\n#include<list>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst int MAX=100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint n;\n\nvoid dfs(int u)\n{\n\tV[u]=true;\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(!V[G[u][i]])dfs(G[u][i]);\n\t}\n\tout.push_front(u);\n\treturn;\n}\n\nvoid topologicalsort()\n{\n\tfor(int i=0;i<n;i++)V[i]=false;\n\tfor(int i=0;i<n;i++)if(!V[i])dfs(i);\n\tfor(auto it:out)cout<<it<<endl;\n\treturn;\n}\n\nint main()\n{\n\tint m;cin>>n>>m;\n\tint s,t;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t}\n\ttopologicalsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\nconst int MAX = 100000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing ll = long long int;\nusing namespace std;\n\nvector<int> graph[MAX];\nvector<int> out;\nbool visited[MAX];\nint N, M, cnt = 0;\n\nvoid dfs(int u)\n{\n    visited[u] = true;\n    for (int i = 0; i < graph[u].size(); i++)\n    {\n        int v = graph[u][i];\n        if (!visited[v])\n            dfs(v);\n    }\n\n    out.push_back(u);\n}\n\nint main()\n{\n    cin >> N >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n        visited[i] = false;\n\n    for (int i = 0; i < N; i++)\n        if (!visited[i])\n            dfs(i);\n\n    for(auto x : out)\n        cout << x << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define LD long double\n#define ST string\n#define BS bitset\n#define PA pair<LL,LL>\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define BPL __builtin_popcountll\n#define FOR(i,a,n) for(i=a;i<n;++i)\n#define FORR(i,a,n) for(i=n-1;i>=a;--i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) FORR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define INF 1145141919810364364LL\n#define PI 3.14159265358979\n//#define MOD 1000000007\n#define MOD 998244353\n#define ERR 0.00000001\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL dig(LL n){LL ret=0;while(n)n/=10,ret++;return ret;}\nLL LBn(VL &v,LL a){LL mx=v.size(),mn=-1,md;while(mx-mn>1){md=(mx+mn)/2;if(v[md]<a)mn=md;else mx=md;}return mx;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nint lcmp(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return 1;if(*(LL*)a<*(LL*)b)return -1;return 0;}\nint lcmpr(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return -1;if(*(LL*)a<*(LL*)b)return 1;return 0;}\nint ccmp(const void* a,const void* b){return *(char*)a-*(char*)b;}\nint ccmpr(const void* a,const void* b){return *(char*)b-*(char*)a;}\nint scmp(const void* a,const void* b){return strcmp((char*)a,(char*)b);}\nint scmpr(const void* a,const void* b){return strcmp((char*)b,(char*)a);}\nLL cmod(LL a,LL m){if(a%m<0)return a%m+abs(m);else return a%m;}\nLL DIV(LL a,LL d,LL m){LL l=m,x=1,y=0,k;while(l){k=d/l;d-=k*l;swap(l,d);x-=k*y;swap(x,y);}return cmod(a*cmod(x,m),m);}\nLL POW(LL a,LL n,LL m){LL ans=1;while(n>0){if(n&1)ans=ans*a%m;a=a*a%m;n>>=1;}return ans;}\nVL fact,finv,inv;\nvoid comi(LL n){LL i;fact.resize(max(2LL,n+1));finv.resize(max(2LL,n+1));inv.resize(max(2LL,n+1));fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,n+1){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\ntemplate<typename T>bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\nVL Tsort(VVL &g){//トポロジカルソート\n\tLL i,a,n=g.size();\n\tVL ret,v(n);\n\tqueue<LL> q;\n\trep(i,n)for(LL j:g[i])++v[j];\n\trep(i,n)if(!v[i])q.push(i);\n\twhile(!q.empty()){\n\t\ta=q.front();\n\t\tq.pop();\n\t\tret.PB(a);\n\t\tfor(LL j:g[a]){\n\t\t\t--v[j];\n\t\t\tif(!v[j])q.push(j);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n  FAST;\n  LL i,V,E,s,t;\n\tcin>>V>>E;\n\tVVL g(V);\n\trep(i,E){\n\t\tcin>>s>>t;\n\t\tg[s].PB(t);\n\t}\n\tVL v=Tsort(g);\n\tfor(LL j:v)cout<<j<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#define V_MAX 10000\n#define E_MAX 100000\nusing namespace std;\n\nint V,E;\nbool check[V_MAX+1],visited[V_MAX+1];\nqueue<int> G[V_MAX+1];//隣接リスト\nqueue<int> order;\nlist<int> TO,TO_tmp;//最後だけでなく先頭にも要素が追加できる点でやはりlistがベストな選択\n\nvoid bfs(){\n\twhile(!order.empty()){\n\t\tint num = order.front();order.pop();\n\t\tvisited[num] = true;check[num] = true;\n\t\tTO_tmp.push_back(num);\n\t\twhile(!G[num].empty()){\n\t\t\tif(!check[G[num].front()]){\n\t\t\t\torder.push(G[num].front());\n\t\t\t\tcheck[G[num].front()] = true;\n\t\t\t}\n\t\t\tG[num].pop();\n\t\t}\n\t}\n\twhile(!TO_tmp.empty()){\n\t\tTO.push_front(TO_tmp.back());\n\t\tTO_tmp.pop_back();\n\t}\n}\n\n\nvoid solve(){\n\tfor(int i = 0;i < V;i++){check[i] = false;visited[i] = false;}\n\tint vs,ve;\n\tfor(int i = 0;i < E;i++){\n\t\tcin >>vs >>ve;\n\t\tG[vs].push(ve);\n\t}\n\tfor(int i = 0;i < V;i++){if(!visited[i])order.push(i);bfs();}\n\twhile(!TO.empty()){cout <<TO.front() <<endl;TO.pop_front();}\n\treturn;\n}\n\nint main(){\n\tcin >>V >>E;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<list>\nusing namespace std;\n\nconst int maxn = 100000;\nconst int infly = (1<<29);\n\nvector <int> G[maxn+5];\nlist <int> out;\nbool c[maxn];\nint N;\nint indge[maxn];\n\nvoid bfs(int s)\n{\n    queue <int> q;\n    q.push(s);\n    c[s] = true;\n\n    while( !q.empty() )\n    {\n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n\n        for(int i = 0 ; i < G[u].size() ; i++)\n        {\n            int v = G[u][i];\n            indge[v]--;\n            if(indge[v] == 0 && !c[v])\n            {\n                c[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort()\n{\n    for(int i = 0 ;i < N ;i++)\n    {\n        indge[i] = 0;\n    }\n\n    for(int u = 0; u < N ; u++)\n    {\n        for(int i = 0 ;i < G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indge[v]++;\n        }\n    }\n\n    for(int u = 0; u < N ;u++)\n    {\n        if( indge[u] == 0 && !c[u])\n        {\n            bfs(u);\n        }\n    }\n\n    for(list<int> ::iterator it = out.begin(); it != out.end() ;it++)\n    {\n        cout << *it << endl;\n    }\n}\n\nint main()\n{\n    int s, t, M;\n\n    scanf(\"%d%d\",&N,&M);\n\n    for(int i = 0; i < N; i++) c[i] = false;\n\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%d%d\",&s,&t);\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nint main(){\n    int v, e; cin >> v >> e;\n    Graph G(v);\n    vector<int> indegree(v);\n    for(int i = 0; i < e; i++){\n        int a, b; cin >> a >> b;\n        G[a].push_back(b);\n        indegree[b]++;\n    }\n    queue<int> que;\n    for(int i = 0; i < v; i++){\n        if(indegree[i] == 0) que.push(i);\n    }\n    while(!que.empty()){\n        int now = que.front();\n        que.pop();\n        for(int nv: G[now]){\n            if(--indegree[nv] == 0) que.push(nv);\n        }\n        G[now].clear();\n        cout << now << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int> P;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[4] = {0, 1, 0, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool dfs(const Graph &g, int v, vector<int> &order, vector<bool> &visited, vector<bool> &pushed) {\n  visited[v] = true;\n  for (Edge e : g[v]) {\n    int w = e.dest;\n    if (pushed[w]) continue;\n    if (visited[w]) return false;\n    if (!dfs(g, w, order, visited, pushed)) return false;\n  }\n  order.push_back(v);\n  pushed[v] = true;\n  return true;\n}\n\ntuple<bool,vector<int>> topological_sort(const Graph &g) {\n  vector<int> order;\n  vector<bool> visited(g.size(), false), pushed(g.size(), false);\n  REP(i, g.size()) {\n    if (!pushed[i] && !dfs(g, i, order, visited, pushed))\n      return make_tuple(false, vector<int>());\n  }\n  reverse(ALL(order));\n  return make_tuple(true, order);\n}\ntuple<bool,vector<int>> topological_sort_stack(const Graph &g) {\n  vector<int> order;\n  vector<bool> visited(g.size(), false), marked(g.size(), false);\n  REP(i, g.size()) {\n    if (marked[i]) continue;\n\n    stack<tuple<int,int,int>> jobs; // 0 = visit, 1 = child, 2 = push\n    jobs.push(make_tuple(0, i, -1));\n    while (!jobs.empty()) {\n      auto job = jobs.top(); jobs.pop();\n      int com = get<0>(job), v = get<1>(job), i = get<2>(job);\n      cout <<DEBUG(com) << DEBUG(v) << DEBUG(i) << endl;\n      switch (com) {\n        case 0: // visit\n          visited[v] = true;\n          jobs.push(make_tuple(1, v, 0));\n          break;\n        case 1: // child\n          if (i >= (int)g[v].size()) {\n            jobs.push(make_tuple(2, v, -1));\n          } else if (marked[g[v][i].dest]) {\n            jobs.push(make_tuple(1, v, i + 1));\n          } else if (visited[g[v][i].dest]) {\n            return make_tuple(false, vector<int>());\n          } else {\n            jobs.push(make_tuple(1, v, i + 1));\n            jobs.push(make_tuple(0, g[v][i].dest, -1));\n          }\n          break;\n        case 2: // push\n          order.push_back(v);\n          marked[v] = true;\n          break;\n        default:;\n      }\n    }\n  }\n  reverse(ALL(order));\n  return make_tuple(true, order);\n}\n\n\nint main() {\n  cout << fixed << setprecision(10);\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  REP(i, E) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(Edge(s, t));\n  }\n\n  auto res = topological_sort(G);\n  for (int v : get<1>(res)) {\n    cout << v << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int M = 1e4+10;\nusing namespace std;\nint cnt;\nvector<int> arr,vec[M];\nset<int> st;\nint in[M];\nvoid go(){\n  \twhile(!st.empty()){\n    \tint u=*st.begin();\n   \t\tst.erase(st.begin());\n    \tarr.push_back(u);\n    \tcnt++;\n    \tfor(int i=0;i!=vec[u].size();i++){\n      \t\tin[vec[u][i]]--;\n      \t\tif(!in[vec[u][i]])\n        \t\tst.insert(vec[u][i]);\n    \t}\n  \t}\n}\nmain(){\n  \tint n,m;\n  \tcin>>n>>m;\n \tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n   \t\tcin>>x>>y;\n    \tvec[x].push_back(y);\n  \t\tin[y]++;\n  \t}\n \tfor(int i=0;i<n;i++)\n    \tif(!in[i])\n      \t\tst.insert(i);\n  \tgo();\n  \tfor(int i=0;i<n;i++)\n\t\tcout<<arr[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 10000;\nint n, color[MAX], indeg[MAX];\nvector<int> v, DAG[MAX];\n\nvoid bfs(int s);\n\nvoid topologicalSort(){\n  for(int i=0;i<n;i++){\n    color[i] = 0;\n  }\n  for(int i=0;i<n;i++){\n    if(color[i] == 0 && indeg[i] == 0){\n      bfs(i);\n    }\n  }\n}\n\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  color[s] = 1;\n\n  while(!q.empty()){\n    int u = q.front(); q.pop();\n    v.push_back(u);\n\n    for(int i=0;i<DAG[u].size();i++){\n      int w = DAG[u][i];\n      indeg[w]--;\n      if(indeg[w] == 0 && color[w] == 0){\n        q.push(w);\n        color[w] = 1;\n      }\n    }\n  }\n}\n\nint main(){\n  int e;\n  cin >> n >> e;\n  int s, t;\n  for(int i=0;i<e;i++){\n    cin >> s >> t;\n    DAG[s].push_back(t);\n    indeg[t]++;\n  }\n\n  topologicalSort();\n\n  for(int i=0;i<n;i++) cout << v[i] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nstatic const int MAX = 10000;\nvector<int> G[MAX];\nint indegs[MAX];\nbool visited[MAX];\n\nvoid visit(int x) {\n  cout << x << endl;\n  visited[x] = true;\n}\n\nvoid bfs(int start) {\n  queue<int> q;\n  q.push(start);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (auto t : G[u]) {\n      indegs[t]--;\n      if (indegs[t] == 0 && !visited[t])\n        q.push(t);\n    }\n    visit(u);\n  }\n}\n\nint main() {\n  int nv, ne;\n  cin >> nv >> ne;\n  for (int i = 0; i < nv; i++) {\n    indegs[i] = 0;\n    visited[i] = false;\n  }\n\n  for (int i = 0; i < ne; i++) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);\n    indegs[t]++;\n  }\n\n  for (int i = 0; i < ne; i++) {\n    if (indegs[i] == 0 && !visited[i])\n      bfs(i);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    auto tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        assert(in[nx].count(v));\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in.empty()) tp.clear(); // exist loop\n    tmp = in;\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.dfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <deque>\n#define MAX_V 10000\n#define MAX_E 100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nvector<int> G[MAX_V];\nvector<int> ans;\nbool done[MAX_V];\n\nvoid dfs(int i) {\n    if (done[i])\n        return;\n        \n    for (int j = 0; j < G[i].size(); ++j) {\n        dfs(G[i][j]);\n    }\n    ans.push_back(i);\n    done[i] = true;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        G[t].push_back(s);  // 逆向きの辺\n    }\n    \n    for (int i = 0; i < V; ++i) {\n        if (done[i])\n            continue;\n        dfs(i);\n    }\n    \n    for (int i = 0; i < V; ++i) {\n        cout << ans[i] << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// C++17 polyfill {{{\ntemplate<bool B>\nusing BoolConstant = integral_constant<bool, B>;\n// }}}\n\n// C++20 polyfill {{{\nstruct IDENTITY {\n    using is_transparent = void;\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n// }}}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n\nusing complex32 = complex<f32>;\nusing complex64 = complex<f64>;\nusing complex80 = complex<f80>;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'017LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MAX(const T& x, const T& y, Comp comp={}) {\n    return max(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MAX(initializer_list<T> ilist, Comp comp={}) {\n    return max(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MIN(const T& x, const T& y, Comp comp={}) {\n    return min(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MIN(initializer_list<T> ilist, Comp comp={}) {\n    return min(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename T3, typename Comp=less<>, SFINAE(\n    is_integral<T1>::value &&\n    is_integral<T2>::value &&\n    is_integral<T3>::value &&\n    is_signed<T1>::value != is_unsigned<T2>::value &&\n    is_signed<T2>::value != is_unsigned<T3>::value\n)>\ncommon_type_t<T1,T2,T3> CLAMP(T1 x, T2 xmin, T3 xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T1, typename T2, typename T3, typename Comp=less<>, SFINAE(\n    is_floating_point<T1>::value &&\n    is_floating_point<T2>::value &&\n    is_floating_point<T3>::value\n)>\ncommon_type_t<T1,T2,T3> CLAMP(T1 x, T2 xmin, T3 xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& CLAMP(const T& x, const T& xmin, const T& xmax, Comp comp={}) {\n    ASSERT(!comp(xmax, xmin));\n    if(comp(x, xmin)) return xmin;\n    if(comp(xmax, x)) return xmax;\n    return x;\n}\n\ntemplate<typename T>\nT ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\nf64 ROUND(f64 x) {\n    return round(x);\n}\n\ni64 IROUND(f64 x) {\n    return llround(x);\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// GCD(0,0) = 0\ni64 GCD(i64 a, i64 b) {\n    return gcd_impl(ABS(a), ABS(b));\n}\n\n// LCM(0,x) は未定義\ni64 LCM(i64 a, i64 b) {\n    ASSERT(a != 0 && b != 0);\n    a = ABS(a);\n    b = ABS(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// lo:OK, hi:NG\ntemplate<typename Pred>\ni64 bisect_integer(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    while(lo+1 < hi) {\n        i64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename Pred>\nf64 bisect_real(f64 lo, f64 hi, Pred pred, i64 iter=100) {\n    ASSERT(lo < hi);\n\n    REP(_, iter) {\n        f64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ni64 ipow(i64 x, i64 e) {\n    ASSERT(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\ni64 sqrt_floor(i64 x) {\n    ASSERT(x >= 0);\n\n    i64 lo = 0;\n    i64 hi = MIN(x/2+2, 3037000500LL);\n    return bisect_integer(lo, hi, [x](i64 r) { return r*r <= x; });\n}\n\ni64 sqrt_ceil(i64 x) {\n    i64 r = sqrt_floor(x);\n    return r*r == x ? r : r+1;\n}\n\n// 0 <= log10_ceil(x) <= 19\ni64 log10_ceil(i64 x) {\n    ASSERT(x > 0);\n    static constexpr i64 TABLE[19] {\n        1LL,\n        10LL,\n        100LL,\n        1000LL,\n        10000LL,\n        100000LL,\n        1000000LL,\n        10000000LL,\n        100000000LL,\n        1000000000LL,\n        10000000000LL,\n        100000000000LL,\n        1000000000000LL,\n        10000000000000LL,\n        100000000000000LL,\n        1000000000000000LL,\n        10000000000000000LL,\n        100000000000000000LL,\n        1000000000000000000LL,\n    };\n    REP(i, SIZE(TABLE)) {\n        if(x <= TABLE[i]) return i;\n    }\n    return SIZE(TABLE);\n}\n\n// 0 <= log10_floor(x) <= 18\ni64 log10_floor(i64 x) {\n    ASSERT(x > 0);\n    static constexpr i64 TABLE[18] {\n        9LL,\n        99LL,\n        999LL,\n        9999LL,\n        99999LL,\n        999999LL,\n        9999999LL,\n        99999999LL,\n        999999999LL,\n        9999999999LL,\n        99999999999LL,\n        999999999999LL,\n        9999999999999LL,\n        99999999999999LL,\n        999999999999999LL,\n        9999999999999999LL,\n        99999999999999999LL,\n        999999999999999999LL,\n    };\n    REP(i, SIZE(TABLE)) {\n        if(x <= TABLE[i]) return i;\n    }\n    return SIZE(TABLE);\n}\n\n// 2^n - 1 の形かどうか\nbool is_mersenne(i64 x) {\n    ASSERT(x >= 0);\n    return (x&(x+1)) == 0;\n}\n\nbool is_pow2(i64 x) {\n    ASSERT(x > 0);\n    return (x&(x-1)) == 0;\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\n// x を align の倍数に切り上げる\ni64 align_ceil(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_ceil(x,align) * align;\n}\n\n// x を align の倍数に切り下げる\ni64 align_floor(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_floor(x,align) * align;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmax(T& xmax, const U& x, Comp comp={}) {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmin(T& xmin, const U& x, Comp comp={}) {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename Pred>\ni64 arg_find(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    FOR(x, lo, hi) {\n        if(pred(x)) return x;\n    }\n    return INF;\n}\n\ntemplate<typename F>\ni64 arg_max(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymax = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmax(ymax, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename F>\ni64 arg_min(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymin = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmin(ymin, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename Pred>\ni64 arg_find_r(i64 lo, i64 hi, Pred pred) {\n    i64 x = arg_find(-hi+1, lo+1, [pred](i64 xx) { return pred(-xx); });\n    return x == INF ? INF : -x;\n}\n\ntemplate<typename F>\ni64 arg_max_r(i64 lo, i64 hi, F f) {\n    return -arg_max(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename F>\ni64 arg_min_r(i64 lo, i64 hi, F f) {\n    return -arg_min(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD(InputIt first, InputIt last,\n          typename iterator_traits<InputIt>::value_type init,\n          BinaryOp op)\n{\n    for(; first != last; ++first)\n        init = op(move(init), *first);\n    return init;\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD1(InputIt first, InputIt last, BinaryOp op) {\n    auto init = *first++;\n    return FOLD(first, last, init, op);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc>\nauto FLIP(BinaryFunc f) {\n    return [f](const auto& x, const auto& y) {\n        return f(y,x);\n    };\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\ntemplate<typename F>\nauto EQ_ON(F f) { return ON(equal_to<>(), f); }\n\ntemplate<typename F>\nauto NE_ON(F f) { return ON(not_equal_to<>(), f); }\n\ntemplate<typename Comp=less<>>\nauto EQUIV(Comp comp={}) {\n    return [comp](const auto& lhs, const auto& rhs) {\n        return !comp(lhs,rhs) && !comp(rhs,lhs);\n    };\n}\n\ntemplate<typename T=void>\nstruct OpMax {\n    using result_type          = T;\n    using first_argument_type  = T;\n    using second_argument_type = T;\n    T operator()(const T& x, const T& y) const {\n        return MAX(x, y);\n    }\n};\n\ntemplate<>\nstruct OpMax<void> {\n    using is_transparent = void;\n    template<typename T1, typename T2>\n    auto operator()(T1&& x, T2&& y) const {\n        return MAX(forward<T1>(x), forward<T2>(y));\n    }\n};\n\ntemplate<typename T=void>\nstruct OpMin {\n    using result_type          = T;\n    using first_argument_type  = T;\n    using second_argument_type = T;\n    T operator()(const T& x, const T& y) const {\n        return MIN(x, y);\n    }\n};\n\ntemplate<>\nstruct OpMin<void> {\n    using is_transparent = void;\n    template<typename T1, typename T2>\n    auto operator()(T1&& x, T2&& y) const {\n        return MIN(forward<T1>(x), forward<T2>(y));\n    }\n};\n\ntemplate<typename T=void>\nstruct OpGcd {\n    using result_type          = T;\n    using first_argument_type  = T;\n    using second_argument_type = T;\n    T operator()(const T& x, const T& y) const {\n        return GCD(x, y);\n    }\n};\n\ntemplate<>\nstruct OpGcd<void> {\n    using is_transparent = void;\n    template<typename T1, typename T2>\n    auto operator()(T1&& x, T2&& y) const {\n        return GCD(forward<T1>(x), forward<T2>(y));\n    }\n};\n\ntemplate<typename T=void>\nstruct OpLcm {\n    using result_type          = T;\n    using first_argument_type  = T;\n    using second_argument_type = T;\n    T operator()(const T& x, const T& y) const {\n        return LCM(x, y);\n    }\n};\n\ntemplate<>\nstruct OpLcm<void> {\n    using is_transparent = void;\n    template<typename T1, typename T2>\n    auto operator()(T1&& x, T2&& y) const {\n        return LCM(forward<T1>(x), forward<T2>(y));\n    }\n};\n\ntemplate<typename ForwardIt>\nForwardIt next_bounded(ForwardIt last, ForwardIt it, i64 n=1) {\n    auto bound = distance(it, last);\n    return next(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nForwardIt prev_bounded(ForwardIt first, ForwardIt it, i64 n=1) {\n    auto bound = distance(first, it);\n    return prev(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nvoid advance_bounded(ForwardIt first, ForwardIt last, ForwardIt& it, i64 n) {\n    if(n > 0) {\n        auto bound = distance(it, last);\n        advance(it, MIN(n, bound));\n    }\n    else if(n < 0) {\n        auto bound = distance(it, first);\n        advance(it, MAX(n, bound));\n    }\n}\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T, typename Enable=void>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename Enum>\nstruct Formatter<Enum, enable_if_t<is_enum<Enum>::value>> {\n    static ostream& write_str(ostream& out, Enum x) {\n        return WRITE_STR(out, static_cast<underlying_type_t<Enum>>(x));\n    }\n    static ostream& write_repr(ostream& out, Enum x) {\n        return WRITE_REPR(out, static_cast<underlying_type_t<Enum>>(x));\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    ASSERT(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD1(T& x) {\n    RD(x);\n    --x;\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n    cout.flush();\n#ifdef PROCON_LOCAL\n    cerr.flush();\n    exit(0);\n#else\n    _Exit(0);\n#endif\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) == 1)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, get<0>(value));\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_CARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), std::make_tuple(args))\n    #define DBG_CARRAY(expr) DBG_CARRAY_IMPL(__LINE__, CPP_STR(expr), (expr))\n    #define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, CPP_STR(first), CPP_STR(last), (first), (last))\n#else\n    #define DBG(args...)\n    #define DBG_CARRAY(expr)\n    #define DBG_RANGE(first,last)\n#endif\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n\n[[noreturn]] void PROCON_MLE(size_t size=1U<<31) {\n    static constexpr size_t PAGE_SIZE = 4096;\n    char* buf = new char[size];\n    for(size_t i = 0; i < size; i += PAGE_SIZE)\n        buf[i] = static_cast<char>(i);\n    EXIT();\n}\n\n[[noreturn]] void PROCON_OLE() {\n    static constexpr char BUF[8192] {};\n    for(;;)\n        cout.write(BUF, SIZE(BUF));\n}\n\n[[noreturn]] void PROCON_RE() {\n    abort();\n}\n\n[[noreturn]] void PROCON_TLE() {\n    this_thread::sleep_for(chrono::hours(10000));\n    EXIT();\n}\n\n[[noreturn]] void PROCON_WA() {\n    static constexpr char BUF[256] {\n        '\\xd1', '\\x14', '\\xe3', '\\xee', '\\x3c', '\\x37', '\\x82', '\\x11',\n        '\\x3f', '\\xa7', '\\x2a', '\\x89', '\\xbb', '\\x62', '\\xad', '\\xfc',\n        '\\xcd', '\\x79', '\\xfe', '\\x0e', '\\x0f', '\\xe9', '\\xdc', '\\x23',\n        '\\x8e', '\\x96', '\\x7a', '\\x5a', '\\xfa', '\\x56', '\\xeb', '\\xb9',\n        '\\xf4', '\\xb1', '\\x88', '\\xe8', '\\x05', '\\x68', '\\x13', '\\xd8',\n        '\\x77', '\\x31', '\\xc4', '\\x64', '\\xcc', '\\x85', '\\x92', '\\x22',\n        '\\xa2', '\\xbe', '\\x54', '\\xfd', '\\x3d', '\\xce', '\\x9a', '\\xe2',\n        '\\x36', '\\x47', '\\xa9', '\\x9d', '\\x24', '\\x58', '\\x2f', '\\x1c',\n        '\\x4f', '\\x7b', '\\x99', '\\xf6', '\\x76', '\\x70', '\\x93', '\\x4d',\n        '\\x6b', '\\xc5', '\\xc2', '\\x4c', '\\xd3', '\\x86', '\\x8d', '\\x0d',\n        '\\x5d', '\\x20', '\\x3b', '\\x4e', '\\x8f', '\\xa0', '\\x98', '\\x57',\n        '\\x9b', '\\x6d', '\\xb0', '\\x12', '\\xcf', '\\x69', '\\x66', '\\x27',\n        '\\x4a', '\\x53', '\\x60', '\\x67', '\\x78', '\\x87', '\\x59', '\\xa1',\n        '\\x43', '\\x1b', '\\xb5', '\\xd4', '\\x72', '\\x97', '\\x34', '\\x30',\n        '\\x06', '\\xe0', '\\x95', '\\x02', '\\xbd', '\\xd6', '\\xf5', '\\xc8',\n        '\\x91', '\\x10', '\\x90', '\\x63', '\\x5e', '\\x5f', '\\xfb', '\\xff',\n        '\\x94', '\\x2e', '\\xc7', '\\xb6', '\\xae', '\\x50', '\\xaa', '\\x44',\n        '\\x0b', '\\x6f', '\\xc9', '\\x83', '\\x32', '\\x81', '\\xb4', '\\x2b',\n        '\\xc6', '\\x7c', '\\x0a', '\\x42', '\\x28', '\\xb3', '\\x48', '\\x35',\n        '\\xea', '\\xf3', '\\x04', '\\x01', '\\xf8', '\\x08', '\\x4b', '\\xe5',\n        '\\xed', '\\x49', '\\x9f', '\\xba', '\\x26', '\\x29', '\\x71', '\\xa6',\n        '\\x09', '\\x9c', '\\xbc', '\\x38', '\\xe7', '\\x07', '\\x8b', '\\x1f',\n        '\\x75', '\\xec', '\\x1d', '\\x1a', '\\x7e', '\\xa8', '\\x8c', '\\xd7',\n        '\\xdb', '\\x2d', '\\xef', '\\x9e', '\\xf0', '\\xdf', '\\x40', '\\xb7',\n        '\\x21', '\\x5b', '\\xd5', '\\x15', '\\x45', '\\x19', '\\x03', '\\x7d',\n        '\\x1e', '\\x5c', '\\xc3', '\\xd9', '\\x52', '\\xca', '\\xda', '\\xac',\n        '\\x80', '\\xf2', '\\xc0', '\\xa4', '\\x6a', '\\x18', '\\x65', '\\xb8',\n        '\\x55', '\\x61', '\\xab', '\\xe6', '\\xcb', '\\x84', '\\xd2', '\\xe4',\n        '\\xbf', '\\xdd', '\\xb2', '\\xe1', '\\x16', '\\xf9', '\\xa3', '\\x74',\n        '\\x0c', '\\xde', '\\xa5', '\\x3a', '\\xaf', '\\xc1', '\\xf1', '\\x8a',\n        '\\x73', '\\x51', '\\xf7', '\\x46', '\\x41', '\\x25', '\\x7f', '\\x17',\n        '\\x00', '\\x39', '\\x2c', '\\xd0', '\\x6c', '\\x3e', '\\x6e', '\\x33',\n    };\n    cout.write(BUF, SIZE(BUF));\n    EXIT();\n}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\ntuple<bool,vector<i64>> graph_tsort(const vector<vector<i64>>& g) {\n    i64 n = SIZE(g);\n    vector<i64> res;\n    res.reserve(n);\n\n    vector<i64> deg_in(n, 0);\n    for(const auto& tos : g)\n        for(auto to : tos)\n            ++deg_in[to];\n\n    queue<i64> que;\n    REP(v, n) {\n        if(deg_in[v] == 0)\n            que.emplace(v);\n    }\n\n    while(!que.empty()) {\n        i64 v = que.front(); que.pop();\n\n        res.emplace_back(v);\n\n        for(auto to : g[v]) {\n            if(--deg_in[to] > 0) continue;\n            que.emplace(to);\n        }\n    }\n\n    bool ok = SIZE(res) == n;\n    return make_tuple(ok, res);\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 M; RD(M);\n\n    vector<vector<i64>> G(N);\n    REP(_, M) {\n        i64 from,to; RD(from); RD(to);\n        G[from].emplace_back(to);\n    }\n\n    bool ok;\n    vector<i64> ans;\n    tie(ok,ans) = graph_tsort(G);\n    assert(ok);\n\n    ALL(for_each, ans, GENERIC(PRINTLN));\n\n    // * 小さいケースで試した?\n    // * 不可能なケースはチェックした?\n    // * MOD はとった?\n    // * メモ化忘れてない?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define PB push_back\nconst int N=1e4+10;\nint main(){\n    int n,m,l,r,d[N],nxt;\n    queue<int> q;\n    vector<int> graph[N];\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)d[i]=0;\n    while(m--){\n        scanf(\"%d%d\",&l,&r);\n        graph[l].PB(r);\n        d[r]++;\n    }\n    for(int i=0;i<n;i++)if(d[i]==0)q.push(i);\n    while(!q.empty()){\n        nxt=q.front();\n        q.pop();\n        printf(\"%d\\n\",nxt);\n        for(int i=0;i<graph[nxt].size();i++){\n            d[graph[nxt][i]]--;\n            if(d[graph[nxt][i]]==0)q.push(graph[nxt][i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\nint pass = 0;\nvoid dfs(vector<vector<int > > g,vector<int>& used,int s){\n\tused[s] = 0;\n\tpass++;\n\t//auto it = lower_bound(g[s].begin(),g[s].end(),s);\n\t//int k = (int)(it-g[s].begin());\n\t//for(int i=k;g[s].size();i++ ){\n\trep(i,g[s].size()){\n\tif(used[g[s][i]])\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back(s);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<int> used(v,1);\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\tint i = (it-used.begin());\n\t//rep(i,v){\n\t//if(used[i]){\n\twhile(pass<=v-1){\n\t\t// int i = it-used.begin();\n\tdfs(g,used,i);\n\t//cout<<i<<endl;\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\t i = (it-used.begin());\n\t//\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\t/*rep(i,e){\n\tsort(g[i].begin(),g[i].end());\n\t}*/\n\t/*rep(i,e){\n\t\trep(j,g[i].size()){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        int e = E;\n        for (int i = 0; i < V; i++) {\n                if (B[i] || U[i])\n                        continue;\n                S.push(i);\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        U[c] = true;\n                        L.push_back(c);\n                        for (auto a: A[c])\n                                if (--e, --B[a] == 0)\n                                        S.push(a);\n                }\n        }\n        if (e > 0) {\n                cout << \"Found cyclic path\" << endl;\n        }\n        else {\n                for (auto l: L)\n                        cout << l << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// setting\ntypedef int LABEL;\ntypedef int WEIGHT;\ntypedef std::unordered_map<LABEL, std::unordered_map<LABEL, WEIGHT>> Graph;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> join(vector<int> result, const vector<int>& add) {\n  result.insert(end(result), begin(add), end(add));\n  return result;\n}\n\nvector<int> topological_sort(const Graph& g, int current, unordered_set<int>& unvisited) {\n  if(!unvisited.count(current)) return {};\n  unvisited.erase(current);\n  vector<int> result = {current};\n  if(g.count(current)) for(const auto& e: g.at(current)) result = join(result, topological_sort(g, e.first, unvisited));\n  return result;\n}\n\nvector<int> topological_sort(const Graph& g, int V) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  for(int i = 0; i < V; ++i) unvisited.insert(i);\n  while(!unvisited.empty()) result = join(topological_sort(g, *begin(unvisited), unvisited), result);\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g, V)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\nusing namespace std;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nint indeg[10005];\n\nvector<int> tsort()\n{\n    stack<int> S;\n    REP(i,V){\n        if(indeg[i]==0) S.push(i);\n    }\n    vector<int> res;\n    while(!S.empty()){\n        int v=S.top(); S.pop();\n        res.push_back(v);\n        for(auto u:G[v]){\n            indeg[u]--;\n            if(indeg[u]==0) S.push(u);\n        }\n    }\n    return res;\n}\n\nsigned main()\n{   \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n        indeg[b]++;\n    }\n    \n    vector<int> ans=tsort();\n    for(auto v:ans){\n        cout<<v<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF 1999999999\n#define MINF -1999999999\n#define INF64 (ll)1 << 60\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\nll n, m;\nvector<ll> list[110000];\nint main() {\n\tcin >> n >> m;\n\tREP(i, m) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tlist[a].push_back(b);\n\t}\n\t//トポロジカルソート\n\tvector<ll> in(n), ans; // 答え\n\tqueue<ll> que;\n\t//入次数\n\tREP(i, n) { //隣接リストの長さ\n\t\tREP(j, list[i].size()) { //隣接リストの変数名\n\t\t\tin[list[i][j]]++;\n\t\t}\n\t}\n\tREP(i, n) if (in[i] == 0)que.push(i);\n\twhile (!que.empty()) {\n\t\tll now = que.front();\n\t\tans.push_back(now);\n\t\tque.pop();\n\t\tREP(i, list[now].size()) {\n\t\t\tin[list[now][i]]--;\n\t\t\tif (in[list[now][i]] == 0) {\n\t\t\t\tque.push(list[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, ans.size())cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// using\ntemplate<typename Label, typename Weight>\nusing Graph = std::unordered_map<Label, std::unordered_map<Label, Weight>>;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> topological_sort(const Graph<int, int>& reverse, int current, unordered_set<int>& unvisited) {\n  vector<int> result = {current};\n  unvisited.erase(current);\n  if(reverse.count(current)) for(const auto& e: reverse.at(current)) {\n    if(unvisited.count(e.first)) {\n      auto add = topological_sort(reverse, e.first, unvisited);\n      result.insert(begin(result), begin(add), end(add));\n    }\n  }\n  return result;\n}\nvector<int> topological_sort(const Graph<int, int>& g, int V) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  for(int i = 0; i < V; ++i) unvisited.insert(i);\n  Graph<int, int> reverse;\n  for(const auto& list: g) for(const auto& e: list.second) reverse[e.first][list.first] = e.second;\n  while(!unvisited.empty()) {\n    auto add = topological_sort(reverse, *begin(unvisited), unvisited);\n    result.insert(end(result), begin(add), end(add));\n  }\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph<int, int> g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g, V)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to){ \n\tgraph[from].push_back({to});\n}\n\n// Description: ????????°?????????????????????????????????????????????  \n// TimeComplexity: $ \\mathcal{O}(V + E) $\n// Verifyed: AOJ GRL_4_B \n \nauto topological_sort(const G& graph){\n    const int n=graph.size();\n    vector<int> used(n,0),order;\n\n    auto dfs=[&](int v){\n        auto func=[&](int v,auto func)->void{\n            used[v]=true;\n            for(auto &e:graph[v]) if(!used[e.to]) func(e.to,func);\n            order.push_back(v);\n        };\n        return func(v,func);\n    };\n    \n    rep(v,n)if(!used[v]) dfs(v);\n    reverse(_all(order));\n    return order;\n}\n\nint main(void){\n\tint v,e;\n\tcin >> v >> e;\n\tG graph(v);\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_edge(graph,a,b);\n\t}\n\n\tauto res=topological_sort(graph);\n    for(auto &it:res) cout <<  it << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvector<vector<int>>G;\nlist<int>out;\nvector<bool>V;\nint N;\nvector<int>indeg;\n\nvoid bfs(int s) {\n\tqueue<int>q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tindeg = vector<int>(N, 0);\n\trep(u, 0, N) {\n\t\trep(i, 0, G[u].size()) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\trep(u, 0, N) {\n\t\tif (indeg[u] == 0 && !V[u])bfs(u);\n\t}\n\teach(it,out)cout << *it << endl;\n}\nsigned main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\tV = vector<bool>(N, false); G = vector<vector<int>>(N, vector<int>());\n\trep(i, 0, M) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n\nconst int MOD = 1e9 + 7;\nconst int MAX = 16;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing ll = long long int;\nusing namespace std;\n\nvector<int> graph[16];\nvector<int> out;\nbool visited[MAX];\nint N, M, cnt = 0;\n\nvoid dfs(int u)\n{\n    visited[u] = true;\n    for (int i = 0; i < graph[u].size(); i++)\n    {\n        int v = graph[u][i];\n        if (!visited[v])\n            dfs(v);\n    }\n\n    out.push_back(u);\n}\n\nint main()\n{\n    cin >> N >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n        visited[i] = false;\n\n    for (int i = 0; i < N; i++)\n        if (!visited[i])\n            dfs(i);\n\n    for(auto x : out)\n        cout << x << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\nusing namespace std;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nint indeg[10005];\n\nvector<int> tsort()\n{\n    stack<int> S;\n    REP(i,V) if(indeg[i]==0) S.push(i);\n\n    vector<int> res;\n    while(!S.empty()){\n        int v=S.top(); S.pop();\n        res.push_back(v);\n        for(auto u:G[v]){\n            indeg[u]--;\n            if(indeg[u]==0) S.push(u);\n        }\n    }\n    return res;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n        indeg[b]++;\n    }\n\n    vector<int> ans=tsort();\n    REP(i,ans.size()) cout<<ans[i]<<endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#define N 10001\nusing namespace std;\nint main() {\n\tint V, E;\n\tscanf(\"%d %d\", &V, &E);\n\n\tint s, t, L[N];\n\tvector <int> M[N];\n\tqueue <int> S;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tL[i] = 0;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tM[s].push_back(t); \n\t\tL[t]++; //tの持つ入力辺の数\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (L[i] == 0) {\n\t\t\tS.push(i); //入力辺を持たないノード\n\t\t}\n\t}\n\n\tint q;\n\twhile (!S.empty()) {\n\t\tq = S.front();\n\t\tS.pop();\n\t\tprintf(\"%d\\n\", q);\n\t\tfor (int i = 0; i < M[q].size(); i++) {\n\t\t\tL[M[q][i]]--; //辺を消す\n\t\t\tif (L[M[q][i]] == 0) { //もし入力辺を持っていないならば\n\t\t\t\tS.push(M[q][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<list>\nusing namespace std;\nconst int MAX = 100000;\nvector<int> G[MAX];\nlist<int> L;\nbool book[MAX];\nint n;\nvoid depthFSearch(int u)\n{\n\tbook[u] = true;\n\tfor (int i = 0; i < G[u].size(); i++)\n\t{\n\t\tint v = G[u][i];\n\t\tif (!book[v])\n\t\t\tdepthFSearch(v);\n\t}\n\tL.push_front(u);\n}\nvoid topologicalSort()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tif (!book[i])\n\t\t\tdepthFSearch(i);\n}\nint main()\n{\n\tint m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\ttopologicalSort();\n\tfor (auto it = L.begin(); it != L.end(); it++)\n\t\tcout << *it << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nbool visit(const vector<vi>& g, int v, vector<int>& order, vector<int>& color) {\n\tcolor[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (color[u] == 2) continue;\n\t\tif (color[u] == 1) return false;\n\t\tif (!visit(g, u, order, color)) return false;\n\t}\n\torder.push_back(v); color[v] = 2;\n\treturn true;\n}\n\n// ?????????????????????????????????\n// ???????????? true ???????????????????????????(false ?????´????????????)\nbool TopologicalSort(const vector<vi>& g, vector<int>& order) {\n\tint n = g.size();\n\tvector<int> color(n);\n\tfor (int u = 0; u < n; u++) if (!color[u] && !visit(g, u, order, color)) return false;\n\treverse(order.begin(), order.end());\n\treturn true;\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\n\tvvi edge(V);\n\trep(i, 0, E)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tedge[s].push_back(t);\n\t}\n\n\tvi order;\n\tif(!TopologicalSort(edge, order)) return 0;\n\trep(i, 0, V) cout << order[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass TSort\n{\npublic:\n  int solve();\n  void dfs( vector<vector<int>>& adj, vector<bool>& vd, vector<int>& rt, int u );\n};\n\nint TSort::solve()\n{\n  int nv, ne;\n  cin >> nv >> ne;\n\n  vector<vector<int>> adj(nv);\n  vector<bool> visited(nv, false);\n  vector<int> ret;\n\n  for ( auto i = 0; i < ne; ++i )\n    {\n      int s, t;\n      cin >> s >> t;\n      adj[s].push_back( t );\n    }\n\n  for ( auto i = 0; i < nv; ++i )\n    {\n      if ( ! visited[i] )\n        dfs( adj, visited, ret, i );\n    }\n\n  for ( auto i = 0; i < nv; ++i )\n    cout << ret[nv - 1 - i] << endl;\n  \n  return 0;\n}\n\nvoid TSort::dfs( vector<vector<int>>& adj, vector<bool>& vd, vector<int>& rt, int u )\n{\n  vd[u] = true;\n\n  int n = adj[u].size();\n  \n  for ( auto i = 0; i < n; ++i )\n    {\n      int v = adj[u][i];\n      \n      if ( ! vd[v] )\n        {\n          dfs( adj, vd, rt, v );\n        }\n    }\n\n  rt.push_back( u );\n}\n\nint main()\n{\n  TSort ts;\n\n  ts.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing ll = long long;\nusing namespace std;\n\nvector<int> G[1000000];\nint indeg[1000000] = {};\nint N;\nbool V[1000000];\nlist<int> out;\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while (!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for (int v : G[u]) {\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v]) {V[v] = true; q.push(v);}\n        }\n    }\n}\n\nvoid toporogicalsort() {\n    for (int i = 0; i < N; ++i) {\n        for (int v : G[i]) {\n            indeg[v]++;\n        }\n    }\n    for (int u = 0; u < N; ++u) {\n        if ( indeg[u] == 0 && !V[u]) bfs(u);\n    }\n    for (int &it : out) {\n        cout << it << \"\\n\";\n    }\n}\n\n\n\nint main() {\n    int s, t, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < N; ++i) {\n        V[i] = false;\n    }\n\n    for (int i = 0; i < M; ++i) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    toporogicalsort();\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;cost=c;\n\t}\n};\n\nvector<Edge> g[10000];\nvector<int> tres; //トポロジカルソートの結果\n//tres[j]=h 頂点hはトポロジカルソートするとj番目の意\nbool used[10000];\n\n//再帰で頂点を訪れる（現在nowにいる）\nvoid visit(int now)\n{\n\tused[now]=true;\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\t//まだ訪れていなければ再帰\n\t\tif(!used[g[now][i].to])\n\t\t\tvisit(g[now][i].to);\n\t}\n\ttres.push_back(now);\n\treturn;\n}\n//n頂点のトポロジカルソート\nvoid tsort(int n)\n{\n\ttres.clear();\n\tfill(used,used+10000,false);//初期化\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!used[i])\n\t\t\tvisit(i);\n\t}\n\t//これをやると逆順になっているのでひっくり返す\n\treverse(tres.begin(),tres.end());\n}\n\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tg[s].push_back(Edge(t,1));\n\t}\n\ttsort(n);\n\tfor(int i=0;i<n;i++)\n\t\tcout<<tres[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct vertex{\n    vector<int> E;//cost,to\n};\n#define MAX_V 10000\n#define MAX_E 100000\n\nbool isVisited[MAX_V];\nbool isChecked[MAX_V];\nvertex V[MAX_V];\nvector<int> A;\n\nvoid rec(int i){\n    isChecked[i]=true;\n    for(auto&e:V[i].E){\n        if(!isChecked[e]) rec(e);\n    }\n    A.push_back(i);\n    return;\n}\n\nint main(){\n    int nv,ne;\n    cin>>nv>>ne;\n    \n    for(int i=0;i<ne;i++){\n        int s,t;\n        cin>>s>>t;\n        V[s].E.emplace_back(t);\n    }\n    \n    fill(isChecked,isChecked+MAX_V,false);\n    for(int i=0;i<nv;i++){\n        if(!isChecked[i]) rec(i);\n    }\n    for(auto ite=A.rbegin();ite!=A.rend();ite++)cout<<*ite<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// DFSを用いたトポロジカルソート\n// 計算量 O(V + E) \n// reference Programming Contest Challenge Book Second Edition\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/1/GRL_4_B\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate<typename T> struct edge {\n  int to;\n  edge(int to_) : to(to_) {}\n};\n\ntemplate<typename T,template <typename ELEM> class C> struct AdListGraph {\n  vector<vector<C<T>>> G;\n  vector<bool> used;\n  vector<bool> is_ancetor;\n  int V;//0,...,|V|-1\n\n  AdListGraph (int V_) {\n    Init(V_);\n  }\n\n  void Init(int V_) {\n    V = V_;\n\n    G.clear();\n    G.resize(V);\n  }\n\n  // https://faithandbrave.hateblo.jp/entry/20080310/1205149207\n  template <typename FROM, class... Args>\n  void AddEdge(FROM from, Args&&... arg) {\n    G[from].emplace_back(arg...);\n  }\n\n  bool DFSForTopologicalSort (int i, vector<int>& sorted) {\n    if (is_ancetor[i]) return false;\n    if (used[i]) return true;\n\n    used[i] = true;\n    is_ancetor[i] = true;\n\n    for(const auto& v : G[i]) {\n      if(!DFSForTopologicalSort(v.to, sorted)) return false;\n    }\n\n    is_ancetor[i] = false;\n    sorted.emplace_back(i);//dfsの帰りがけの順\n\n    return true;\n  }\n\n  template<typename ID_TYPE>\n  bool TopologicalSort (vector<ID_TYPE>& sorted) { // 成功ならtrue 失敗(DAG出ない)ならfalseを返す\n    used.clear();\n    used.resize(V,false);\n    is_ancetor.clear();\n    is_ancetor.resize(V, false);\n\n    sorted.clear();\n\n    rep (i,V) {\n      if(!DFSForTopologicalSort(i, sorted)) {\n        return false;\n      }\n    }\n\n    reverse(sorted.begin(),sorted.end());\n\n    return true;\n  }\n\n};\n\nusing ll = long long;\n\nint main() {\n  ll V,E;\n  cin >> V >> E;\n  AdListGraph<ll,edge> G(V);\n  rep(i,E) {\n    ll s,t;\n    cin >> s >> t;\n    G.AddEdge(s,t);\n  }\n\n  vector<int> ans;\n\n  G.TopologicalSort(ans);\n\n  for (auto v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TopoSorter {\n    const int WHITE = 0, GRAY = 1, BLACK = 2;\n    int n;\n    vector<vector<int>> g;\n    bool hasCycle = false;\n    vector<int> color;\n    vector<int> s;\n    \n    TopoSorter(int n) : n(n) {\n        g.assign(n, vector<int>());\n        color.assign(n, WHITE);\n    }\n    \n    void addEdge(int from, int to) {\n        g[from].push_back(to);\n    }\n    \n    void solve() {\n        for (int i = 0; i < n; i++) {\n            if (color[i] == WHITE) {\n                dfs(i);\n            }\n        }\n    }\n    \n    void dfs(int u) {\n        color[u] = GRAY;\n        for (int v : g[u]) {\n            if (color[v] == WHITE) {\n                dfs(v);\n            }\n            else if (color[v] == GRAY) {\n                hasCycle = true;\n            }\n        }\n        color[u] = BLACK;\n        s.push_back(u);\n    }   \n};\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    TopoSorter d(v);\n    for (int i = 0; i < e; i++) {\n        int from, to;\n        cin >> from >> to;\n        d.addEdge(from, to);\n    }\n    d.solve();\n    for (int i = v - 1; i >= 0; i--) {\n        cout << d.s[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n \nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n \nvector<int> G[MAX];\nlist <int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n \nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=true;\n    while(q.size()){\n        int u=q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n \nvoid tsort(){\n    memset(indeg,0,sizeof(indeg));\n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n    for(int u=0;u<N;u++){\n        if(indeg[u]==0 && !V[u])bfs(u);\n    }\n    for(list<int>::iterator it=out.begin();it!=out.end();it++){\n        cout << *it << endl;\n    }\n}\n \nint main(void){\n    int s,t,M;\n    scanf(\"%d %d\",&N,&M);\n    memset(V,false,sizeof(V));\n    for(int i=0;i<M;i++){\n        scanf(\"%d %d\",&s,&t);\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n     \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V = 10000;\n\nint V, E;\nvi G[MAX_V];\nint deg[MAX_V];\nbool used[MAX_V];\n\nvoid solve() {\n   for (int i = 0; i < V; i++) {\n       if (!used[i] && deg[i] == 0) {\n           cout << i << endl;\n           used[i] = true;\n\n           for (auto to : G[i]) {\n               deg[to]--;\n           }\n\n           i = -1;\n       }\n   } \n}\n\nint main() {\n    cin >> V >> E;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n\n        G[s].push_back(t);\n    }\n\n    for (int i = 0; i < V; i++) {\n        for (auto to : G[i]) {\n            deg[to]++;\n        }\n    }\n\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    vector<unordered_set<int> > tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    swap(in,tmp);\n    for(int i=0;i<V;i++) if(!tmp[i].empty()) tp.clear(); // exist loop\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.dfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 10000\n\nvector<int> G[MAX_V];\nbool use[MAX_V];\nint V,E;            // V:????????°   E:????????°\nint indeg[MAX_V];   // ??\\?¬???°\nlist<int> out;\n\nvoid bfs(int s){\n    queue<int> que;\n    que.push(s);\n    use[s]=true;\n\n    while(!que.empty()){\n        int u=que.front();\n        que.pop();\n        out.push_back(u);\n\n        for(int v : G[u]){\n            indeg[v]--;\n            if(indeg[v]==0 and !use[v]){\n                use[v]=true;\n                que.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0;i<V;i++) indeg[i]=0;\n\n    //??\\?¬???°????¨????\n    for(int u=0;u<V;u++){\n        for(int v:G[u]){\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0;u<V;u++){\n        if(indeg[u]==0 and !use[u]) bfs(u);\n    }\n\n    for(auto v : out){\n        cout << v << endl;\n    }\n}\n\nint main(){\n    cin>>V>>E;\n    for(int i=0;i<E;i++){\n        int u,v;cin>>u>>v;\n        G[u].push_back(v);\n    }\n\n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\nusing namespace std;\nvoid solve();\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed;\n\tsolve();\n}\nstruct pea{\n\tll f,s;\n\tbool operator<(const pea &c)const{\n\t\treturn f!=c.f?f<c.f:s<c.s;\n\t};\n};\n//深さ優先探索\nvec<bool> seen;\nvll ans;\nvoid dfs(const vec<vll> &c,ll i=0){\n\tseen[i]=true;\n\trep(j,0,c[i].size()){\n\t\tif(!seen[c[i][j]])dfs(c,c[i][j]);\n\t}\n\tans.pub(i);\n}\nvoid solve(){\n\tll v,e;cin>>v>>e;\n\tseen.resize(v,false);\n\tvec<vll> c(v);\n\trep(i,0,e){\n\t\tll s,t;cin>>s>>t;\n\t\tc[s].pub(t);\n\t}\n\trep(i,0,v)if(!seen[i])dfs(c,i);\n\trrep(i,ans.size()-1,0)cout<<ans[i]<<kai;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define PA pair<ll,ll>\n#define FOR(I,A,B) for(ll I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(ll I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e16+7;\nconst ll MOD=1e9+7;\n\nstruct topolodical{\n\t//0-indexed   <---important\n\t//ans.size()==v -> heiro nasi\n\tll v,e,numsort;\n\tvector<vector<ll> > g;\n\tvector<bool> used;\n\tvector<ll> ans;\n\ttopolodical(ll a,ll b){\n\t\tv=a;e=b;\n\t\tused.resize(v);\n\t\tg.resize(v);\n\t}\n\tvoid make_edgedir(ll s,ll t){//s->t\n\t\tg[s].push_back(t);\n\t}\n\tvoid dfs(ll u){\n\t\tif(used[u]) return;\n\t\tused[u] = true;\n\t\tfor(auto& i:g[u])dfs(i);\n\t\tans.push_back(u);\n\t}\n\tvoid tsort(){\n\t\tfor(ll i=0;i<v;++i)dfs(i);\n\t\treverse(ans.begin(),ans.end());\n\t}\n\tvoid calcnumsort(){\n\t\tvector<ll> dp,a;\n\t\tdp.resize(1<<v,0);\n\t\ta.resize(v);\n\t\tFOR(i,0,v){\n\t\t\tFOR(j,0,g[i].size()){\n\t\t\t\tll x = i,y = g[i][j];\n\t\t\t\ta[y] |= 1<<x;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tfor(ll i=1; i < (1<<v); i++){\n\t\t\tfor(ll j=0;j<v;j++){\n\t\t\t\tif((i & 1<<j) && ((i | a[j])==i)){\n\t\t\t\t\tdp[i] += dp[i-(1<<j)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnumsort=dp[(1<<v)-1];\n\t}\n};\n\nint main(){\n\tll v,e,f,t;\n\tcin >> v >> e;\n\ttopolodical tp(v,e);\n\tFOR(i,0,e){\n\t\tcin >> f >> t;\n\t\ttp.make_edgedir(f,t);\n\t}\n\ttp.tsort();\n\tfor(auto x:tp.ans){\n\t\tcout << x << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define MAX_V 10000\nvector<int> G[MAX_V];\n\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    vector<int> in_deg(v,0);\n    vector<int> list;\n    \n    rep(i,e){\n        int s,t;\n        cin>>s>>t;\n        in_deg[t]++;\n        G[s].pb(t);\n    }\n    \n    stack<int> st;\n    rep(i,v)if(in_deg[i]==0)st.push(i);\n    \n    while(st.size()){\n        int q = st.top();\n        st.pop();\n        list.pb(q);\n        \n        rep(i,G[q].size()){\n            int to = G[q][i];\n            in_deg[to]--;\n            if(in_deg[to]==0)st.push(to);\n        }\n    }\n    \n    rep(i,list.size())cout<<list[i]<<endl;\n    \n    if(list.size()!=v){/*????????????*/}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n    V[u] = true;\n    for (int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if (!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main() {\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for (int i = 0; i < N; i++) V[i] = false;\n\n    for (int i = 0; i < M; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    for (int i = 0; i < N; i++) {\n        if ( !V[i]) dfs(i);\n    }\n\n    for (list<int>::iterator it = out.begin(); it != out.end(); it++)\n        cout << *it << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\nusing namespace std;\n\n#define Getsign(n) ((n > 0) - (n < 0))\n\ntypedef vector<int> Ivec;\ntypedef pair<int, int> Pos;\n\nint main() {\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tvector<vector<int>> graph(v, vector<int>(v, 0));\n\tvector<int> numbers;\n\tfor (int i = 0; v > i; i++) {\n\t\tnumbers.push_back(i);\n\t}\n\tfor (int i = 0; e > i; i++) {\n\t\tint a,b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tgraph[b][a] = 1;\n\t}\n\n\twhile (v) {\n\t\tfor (int i = 0; v > i; i++) {\n\t\t\tif (find(graph[i].begin(), graph[i].end(), 1) == graph[i].end()) {\n\t\t\t\tfor (int j = 0; v > j; j++) {\n\t\t\t\t\tgraph[j][numbers[i]] = 0;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", numbers[i]);\n\n\t\t\t\tnumbers.erase(numbers.begin() + i);\n\t\t\t\tgraph.erase(graph.begin() + i);\n\t\t\t\tv--;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                glaph[j].flag = 1;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            glaph[i].flag = 1;\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <utility>\ntypedef long long ll;\nusing namespace std;\n\nint v,e;\nint cnt[10000]={};\nbool visited[10000]={};\nvector<int> edge[10000];\n\nvoid print(int v){\n  int i;\n  if(visited[v])return;\n\n  printf(\"%d\\n\",v);\n  visited[v]=1;\n  for(i=0;i<edge[v].size();i++){\n    cnt[edge[v][i]]--;\n    if(cnt[edge[v][i]]==0){\n      print(edge[v][i]);\n    }\n  }\n}\n\nint main(void){\n  int s,t,i,j;\n  cin>>v>>e;\n  for(i=0;i<v;i++){\n    edge[i].clear();\n  }\n\n  for(i=0;i<e;i++){\n    cin>>s>>t;\n    edge[s].push_back(t);\n    cnt[t]++;\n  }\n\n  for(i=0;i<v;i++){\n    if(cnt[i]==0)print(i);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(a) sort(a.begin(), a.end())\n#define RSORT(a) sort(a.rbegin(), a.rend())\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define RREP(i, n) for (int i = n - 1; 0 <= i; i--)\n#define FOR(i, start, end) for (int i = start; i < end; i++)\n#define RFOR(i, start, end) for (int i = start - 1; 0 <= i; i--)\n#define ALL(a) a.begin(), a.end()\nusing ll = long long;\nusing namespace std;\nconstexpr int INF32       = 1'050'000'000;\nconstexpr long long INF64 = 4'000'000'000'000'000'000;\nconstexpr int MOD7        = 1'000'000'007;\nconstexpr int MOD9        = 1'000'000'009;\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nvoid print() { std::cout << '\\n'; }\ntemplate <class H, class... T> void print(H &&head, T &&... args) {\n    std::cout << head;\n    sizeof...(args) == 0 ? std::cout << \"\" : std::cout << ' ';\n    print(std::forward<T>(args)...);\n}\ntemplate <class T> void print(std::vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        std::cout << v[i];\n        i == v.size() - 1 ? std::cout << '\\n' : std::cout << ' ';\n    }\n}\ntemplate <class T> void print(std::vector<std::vector<T>> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        for (int j = 0; j < v[i].size(); j++) {\n            std::cout << v[i][j];\n            j == v[i].size() - 1 ? std::cout << '\\n' : std::cout << ' ';\n        }\n    }\n}\nvoid debug() { std::cerr << '\\n'; }\ntemplate <class H, class... T> void debug(H &&head, T &&... args) {\n    std::cerr << head;\n    sizeof...(args) == 0 ? std::cerr << \"\" : std::cerr << ' ';\n    debug(std::forward<T>(args)...);\n}\ntemplate <class T> void debug(std::vector<T> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        std::cerr << v[i];\n        i == v.size() - 1 ? std::cerr << '\\n' : std::cerr << ' ';\n    }\n}\ntemplate <class T> void debug(std::vector<std::vector<T>> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        for (int j = 0; j < v[i].size(); j++) {\n            std::cerr << v[i][j];\n            j == v[i].size() - 1 ? std::cerr << '\\n' : std::cerr << ' ';\n        }\n    }\n}\n\nstruct graph {\n    vector<vector<int>> gph;\n    vector<int> indeg, outdeg;\n    int vertex;\n    graph(int N) : vertex(N) {\n        gph.resize(vertex);\n        indeg.resize(N);\n        outdeg.resize(N);\n    }\n    // 有向グラフの構築\n    void directed_update(int in, int out) {\n        gph.at(in).emplace_back(out);\n        indeg.at(in)++;\n        outdeg.at(out)++;\n    }\n    // 無向グラフの構築\n    void undirected_update(int x, int y) {\n        gph.at(x).emplace_back(y);\n        gph.at(y).emplace_back(x);\n    }\n};\n\nclass DAG {\n  private:\n    bool done_tsort;\n    vector<int> used;\n    graph g;\n\n  public:\n    vector<int> tsorted, dp;\n    vector<vector<int>> parents;\n    DAG(const graph &_g)\n        : done_tsort(false), g(_g), used(_g.outdeg), parents(_g.vertex),\n          dp(_g.vertex) {\n        tsorted.reserve(g.vertex);\n    }\n    void tsort() {\n        if (done_tsort)\n            return;\n        queue<int> que;\n        for (int i = 0; i < g.vertex; i++) {\n            if (used.at(i) == 0)\n                que.push(i);\n        }\n        while (!que.empty()) {\n            int now = que.front();\n            que.pop();\n            tsorted.emplace_back(now);\n            for (auto &&i : g.gph.at(now)) {\n                used.at(i)--;\n                parents.at(i).emplace_back(now);\n                if (used.at(i) == 0) {\n                    que.push(i);\n                    dp.at(i) = max(dp.at(i), dp.at(now) + 1);\n                }\n            }\n        }\n        done_tsort = true;\n        return;\n    }\n    bool is_DAG() {\n        if (!done_tsort)\n            tsort();\n        return tsorted.size() == g.vertex;\n    }\n    int longest_path() {\n        if (!done_tsort)\n            tsort();\n        return *max_element(dp.begin(), dp.end());\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n    auto g = graph(V);\n    REP(i, E) {\n        int a, b;\n        cin >> a >> b;\n        g.directed_update(a, b);\n    }\n    auto dag = DAG(g);\n    dag.tsort();\n    for (auto &&i : dag.tsorted) {\n        print(i);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    auto tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in.empty()) tp.clear(); // exist loop\n    tmp = in;\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.bfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector <int> res, inDegree(n);\n    queue <int> q;\n    for(auto &es : g) for(auto &e : es) ++inDegree[e.dst];\n    for(int i = 0; i < n; ++i) if(inDegree[i] == 0) q.push(i);\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        res.push_back(v);\n        for(auto &e : g[v]){\n            --inDegree[e.dst];\n            if(inDegree[e.dst] == 0) q.push(e.dst);\n        }\n    }\n    if((int)res.size() != n) return {};\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <numeric>\n#include <climits>\n#include <iterator>\n#include <iomanip>\n#include <stack>\n#include <bitset>\n#include <functional>\nusing namespace std;\nconst constexpr int INF = 1e9;\n//typedef std::pair<std::string,double> P;\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n//グラフの隣接リスト\nVI g[100010];\n//頂点の入次数を管理\nint h[100010];\nsigned main(void) {\n\n\t//頂点数v, 辺の数e\n\tint v, e;\n\tcin >> v >> e;\n\tREP(i, e) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back(t); //sからtに向かう辺\n\n\t\th[t]++;\n\t}\n\tstack<int> st;\n\n\tREP(i, v) if (h[i] == 0)st.push(i);\n    \n\t//ソートされた後のグラフ\n\tVI ans;\n\t\n\twhile (st.size()) {\n\t\t//stの集合から一つ取り出す\n\t\tint i = st.top(); st.pop();\n\n\t\tans.push_back(i);\n\n\t\tfor (auto& j : g[i]) {\n\t\t\t//隣接する頂点の入次数をマイナス1\n\t\t\th[j]--;\n\t\t\t//これによって入次数が0になればstに追加\n\t\t\tif (h[j] == 0)st.push(j);\n\t\t}\n\t}\n\n\tfor (auto i : ans) cout << i << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> toposort(vector< vector<int> > &G){\n  size_t N = G.size();\n  vector<int> ret, d_in(N,0);\n  for(size_t i = 0; i < N; ++i)\n    for(size_t j = 0; j < G[i].size(); ++j)\n      ++d_in[G[i][j]];\n  queue<int> wait;\n  for(size_t i = 0; i < N; ++i)\n    if(!d_in[i]) wait.emplace(i);\n  while(!wait.empty()){\n    int v = wait.front();\n    wait.pop();\n    ret.emplace_back(v);\n    for(size_t i = 0; i < G[v].size(); ++i){\n      int v_ = G[v][i];\n      --d_in[v_];\n      if(!d_in[v_]) wait.emplace(v_);\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int s, t;\n    cin >> s >> t;\n    G[s].emplace_back(t);\n  }\n  vector<int> order = toposort(G);\n  for(int i = 0; i < N; ++i)\n    cout << order[i] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\t//DEBUG\n\t\t\tif (indeg[v] == 0 && V[v]) {\n\t\t\t\tcout << \"DEBUG1\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tif (indeg[u] == 0 && !V[u]) bfs(u);\n\t\t//DEBUG\n\t\tif (indeg[u] == 0 && V[u]) {\n\t\t\tcout << \"DEBUG2\" << endl;\n\t\t}\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\nconstexpr int MOD = 1000000007;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconstexpr int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nconstexpr int dy[] = {0, -1, 0, 1, 1, -1, -1, 1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){os << \"[\"; for (const auto &v : vec) {os << v << \",\"; } os << \"]\"; return os; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &p) {os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\n\n// TopologicalSort\n// [input]\n// G: 有向グラフ(G[i][j] : 頂点iから行けるj番目の頂点)\n// [output] \n// 頂点のトポロジカルソート。 DAGでない場合空のvector<int>()を返す\nvector<int> TopologicalSort(vector<vector<int>> &G) {\n    int N = G.size();\n    vector<int> cnt(N);\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < G[i].size(); j++) {\n            cnt[G[i][j]]++;\n        }\n    }\n    vector<int> S;\n    for (int i = 0; i < N; i++) {\n        if (!cnt[i]) S.push_back(i);\n    }\n    if (!S.size()) return vector<int>();\n\n    vector<int> L;\n    while(!S.empty()) {\n        int n = S.back(); S.pop_back();\n        L.push_back(n);\n        for(int i = 0; i < G[n].size(); i++) {\n            cnt[G[n][i]]--;\n            if (!cnt[G[n][i]]) {\n                S.push_back(G[n][i]);\n            }\n        }\n    }\n    if (L.size() == N) return L;\n    return vector<int>();\n}\n\n\nvoid solve() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n    }\n    vector<int> top = TopologicalSort(G);\n    for (int i = 0; i < top.size(); i++) {\n        cout << top[i] << endl;\n    }\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "wree"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#define y0 qvya13579\n#define y1 qvyb24680\n#define j0 qvja13579\n#define j1 qvjb24680\n#define next qvne13579xt\n#define prev qvpr13579ev\n#define INF 1000000007\n#define MOD 1000000007\n#define PI acos(-1.0)\n#define endl \"\\n\"\n#define IOS cin.tie(0);ios::sync_with_stdio(false)\n#define M_P make_pair\n#define PU_B push_back\n#define PU_F push_front\n#define PO_B pop_back\n#define PO_F pop_front\n#define U_B upper_bound\n#define L_B lower_bound\n#define B_S binary_search\n#define PR_Q priority_queue\n#define FIR first\n#define SEC second\n#if __cplusplus < 201103L\n#define stoi(argument_string) atoi((argument_string).c_str())\n#define stoll(argument_string) atoll((argument_string).c_str())\n#endif\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP_R(i,n) for(int i=((int)(n)-1);i>=0;--i)\n#define FOR(i,m,n) for(int i=((int)(m));i<(int)(n);++i)\n#define FOR_R(i,m,n) for(int i=((int)(m)-1);i>=(int)(n);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define RALL(v) (v).rbegin(),(v).rend()\n#define SIZ(x) ((int)(x).size())\n#define CIN(x) cin>>(x)\n#define CIN2(x,y) cin>>(x)>>(y)\n#define CIN3(x,y,z) cin>>(x)>>(y)>>(z)\n#define CIN4(x,y,z,w) cin>>(x)>>(y)>>(z)>>(w)\n#define CIN5(x,y,z,w,u) cin>>(x)>>(y)>>(z)>>(w)>>(u)\n#define SCAND(x) scanf(\"%d\",&(x))\n#define SCAND2(x,y) scanf(\"%d%d\",&(x),&(y))\n#define SCAND3(x,y,z) scanf(\"%d%d%d\",&(x),&(y),&(z))\n#define SCAND4(x,y,z,w) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(w))\n#define SCAND5(x,y,z,w,u) scanf(\"%d%d%d%d%d\",&(x),&(y),&(z),&(w),&(u))\n#define SCANLLD(x) scanf(\"%lld\",&(x))\n#define SCANLLD2(x,y) scanf(\"%lld%lld\",&(x),&(y))\n#define SCANLLD3(x,y,z) scanf(\"%lld%lld%lld\",&(x),&(y),&(z))\n#define SCANLLD4(x,y,z,w) scanf(\"%lld%lld%lld%lld\",&(x),&(y),&(z),&(w))\n#define SCANLLD5(x,y,z,w,u) scanf(\"%lld%lld%lld%lld%lld\",&(x),&(y),&(z),&(w),&(u))\n#define I64DSCAN(x) scanf(\"%I64d\",&(x))\n#define I64DSCAN2(x,y) scanf(\"%I64d%I64d\",&(x),&(y))\n#define I64DSCAN3(x,y,z) scanf(\"%I64d%I64d%I64d\",&(x),&(y),&(z))\n#define I64DSCAN4(x,y,z,w) scanf(\"%I64d%I64d%I64d%I64d\",&(x),&(y),&(z),&(w))\n#define I64DSCAN5(x,y,z,w,u) scanf(\"%I64d%I64d%I64d%I64d%I64d\",&(x),&(y),&(z),&(w),&(u))\n#define PRINTD(x) printf(\"%d\\n\",(x))\n#define PRINTLLD(x) printf(\"%lld\\n\",(x))\n#define PRINTI64D(x) printf(\"%I64d\\n\",(x))\n#define DEBUG(argument) cerr<<(#argument)<<\" : \"<<(argument)<<\"\\n\"\ntypedef long long int lli;\nusing namespace std;\n\n\nbool compare_by_2nd(pair<int,int> a, pair<int,int> b)\n{\n  if( a.second != b.second )\n    {\n      return a.second < b.second;\n    }\n  else\n    {\n      return a.first < b.first;\n    }\n  \n}\n\nint ctoi(char c)\n{\n  if( c >= '0' and c <= '9' )\n    {\n      return (int)(c-'0');\n    }\n\n  return -1;\n}\n\nint alphabet_pos(char c) \n{\n  if( c >= 'a' and c <= 'z' )\n    {\n      return (int)(c-'a');\n    }\n\n  return -1;\n}\n\n\nint alphabet_pos_capital(char c)\n{\n  if( c >= 'A' and c <= 'Z' )\n    {\n      return (int)(c-'A');\n    }\n\n  return -1;\n}\n\n\nvector<string> split(string str, char ch)\n{\n  int first = 0;\n  int last = str.find_first_of(ch);\n  \n  if(last == string::npos)\n    {\n      last = SIZ(str);\n    }\n\n  vector<string> result;\n\n  while( first < SIZ(str) )\n    {\n      string Ssubstr(str, first, last - first);\n      result.push_back(Ssubstr);\n      first = last + 1;\n      last = str.find_first_of(ch, first);\n\n      if(last == string::npos)\n\t{\n\t  last = SIZ(str);\n\t}\n    }\n  \n  return result;\n}\n\n\n\nint gcd( int a , int b ) // assuming a,b >= 1\n{\n  if( a < b )\n    {\n      swap(a,b);\n    }\n\n  if( a % b == 0 )\n    {\n      return b;\n      \n    }\n\n  return gcd( b , a % b );\n  \n}\n\nlong long gcd( long long a , long long b ) // assuming a,b >= 1\n{\n  if( a < b )\n    {\n      swap(a,b);\n    }\n\n  if( a % b == 0 )\n    {\n      return b;\n      \n    }\n\n  return gcd( b , a % b );\n  \n}\n\nint lcm( int a , int b ) // assuming a,b >= 1\n{\n  return  a * b / gcd( a , b );\n  \n}\n\nlong long lcm( long long a , long long b ) // assuming a,b >= 1\n{\n  return  a * b / gcd( a , b );\n  \n}\n\nlong long pow_fast( long long x, long long n_power , long long modulus )\n{\n  \n  if( n_power == 0 )\n    {\n      return 1;\n    }\n  \n  if( n_power % 2 == 0)\n    {\n      return pow_fast( x * x % modulus , n_power / 2 , modulus );  \n    }\n\n  \n  return x * pow_fast( x , n_power - 1 , modulus ) % modulus;\n}\n\n\nstruct CombinationTable\n{\n  vector<vector<long long> > val;\n\n  CombinationTable( int size ) : val( size+1 , vector<long long>( size+1 ) ) //constructor\n  {\n    for( int i = 0 ; i <= size ; ++ i ) // note that 0 <= i <= size\n      {\n\n\tfor( int j = 0 ; j <= i ; ++ j )\n\t  {\n\t    \n\t    if( j == 0 or j == i )\n\t      {\n\t\tval[i][j] = 1LL;\n\t      }\n\t    else\n\t      {\n\t\tval[i][j] = val[i-1][j-1] + val[i-1][j];\n\t      }\n\n\t  }\n\t\n\t\n      }\n    \n  }\n\n  \n};\n\n\nvoid print_vector(vector<int>& h)\n{\n  int L =  h.size();\n  \n  for(int i = 0; i < L; ++ i)\n    {\n      printf(\"%d\",h[i]);\n\n      if( i != L-1 )\n\t{\n\t  printf(\" \");\n\t}\n      else\n\t{\n\t  printf(\"\\n\");\n\t}\n    }    \n}\n\nvoid print_vector(vector<long long>& h)\n{\n  int L =  h.size();\n  \n  for(int i = 0; i < L; ++ i)\n    {\n      printf(\"%lld\",h[i]);\n\n      if( i != L-1 )\n\t{\n\t  printf(\" \");\n\t}\n      else\n\t{\n\t  printf(\"\\n\");\n\t}\n    }    \n}\n\n\n\nvoid print_matrix2D(vector<vector<int> >& h)\n{\n  int Ly =  h.size();\n  int Lx = h[0].size();\n        \n  for(int i = 0; i < Ly; ++ i)\n    {\n      for(int j = 0; j < Lx; ++ j)\n        {\n\t  printf(\"%d\",h[i][j]);\n\n\t  if( j != Lx-1 )\n\t    {\n\t      printf(\" \");\n\t    }\n\t  else\n\t    {\n\t      printf(\"\\n\");\n\t    }\t  \n        }\n    }    \n}\n\nvoid print_matrix2D(vector<vector<long long> >& h)\n{\n  int Ly =  h.size();\n  int Lx = h[0].size();\n        \n  for(int i = 0; i < Ly; ++ i)\n    {\n      for(int j = 0; j < Lx; ++ j)\n        {\n\t  printf(\"%lld\",h[i][j]);\n\n\t  if( j != Lx-1 )\n\t    {\n\t      printf(\" \");\n\t    }\n\t  else\n\t    {\n\t      printf(\"\\n\");\n\t    }\n        }\n    }\n}\n\nvoid print_matrix2D(vector<string>& h)\n{\n  int Ly =  h.size();\n  int Lx = h[0].size();\n        \n  for(int i = 0; i < Ly; ++ i)\n    {\n      for(int j = 0; j < Lx; ++ j)\n        {\n\t  printf(\"%c\",h[i][j]);\n        }\n      printf(\"\\n\");\n    }    \n}\n\n\nstruct UnionFind //size-based\n{\n  vector<int> parent, treesize;\n  \n  UnionFind( int size ) : parent( size ) , treesize( size , 1 ) //constructor\n  {\n    for( int i = 0 ; i < size ; ++ i )\n      {\n\tparent[i] = i;\n      }\n  }\n\n  int root( int x )\n  {\n    if( parent[x] == x )\n      {\n\treturn x;\n      }\n    \n    return parent[x] = root(parent[x]);\n  }\n\n  void unite( int x, int y )\n  {\n    x = root(x); \n    y = root(y);\n    \n    if( x == y )\n      {\n\treturn; \n      }\n\n    if( treesize[x] < treesize[y] )\n      {\n\tparent[x] = y;\n\ttreesize[y] += treesize[x];\n      }\n    else\n      {\n\tparent[y] = x;\n\ttreesize[x] += treesize[y];\t\n      }\n    \n  }\n\n  bool sametree( int x, int y )\n  {\n    return root(x) == root(y);\n  }\n\n  int gettreesize( int x )\n  {\n    return treesize[root(x)];\n  }\n  \n};\n\ntemplate< typename Type_value >\nstruct SegmentTree //Range Minimum Query (RMQ)\n{\n\nprivate:\n  int n;\n  vector<Type_value> node;\n  Type_value identity_element_segmenttree;\n  \npublic:\n  SegmentTree( vector<Type_value> v, Type_value identity_element_st ) //constructor\n  {\n    int sz = v.size();\n    identity_element_segmenttree = identity_element_st;\n    n = 1;\n    while(n < sz)\n      {\n\tn <<= 1;\n      }\n    \n    node.resize(2*n-1, identity_element_segmenttree);\n\n    for( int i = 0 ; i < sz ; ++ i )\n      {\n\tnode[i+n-1] = v[i];\n      }\n    \n    for( int i = n-2 ; i >= 0 ; -- i )\n      {\n\tnode[i] = min(node[2*i+1], node[2*i+2]);\n      } \n  }\n \n  void update(int x, Type_value val)\n  {\n    x += (n - 1);\n    node[x] = val;\n    \n    while( x > 0 )\n      {\n\tx = (x - 1) / 2;\n\tnode[x] = min(node[2*x+1], node[2*x+2]);\n      }\n  }\n \n  Type_value getmin( int a, int b, int k = 0, int l = 0, int r = -1 ) //getting minimum value in [a,b)\n  {\n    // k : index of the referred node\n    // [l,r) : range covered by the k-th node \n    \n    if( r < 0 )\n      {\n\tr = n;\n      } \n    if( r <= a or b <= l )\n      {\n\treturn identity_element_segmenttree;\n      } \n    if( a <= l and r <= b )\n      {\n\treturn node[k];\n      }\n    \n    Type_value vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n    Type_value vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n  \n};\n\n\ntemplate< typename Type_value >\nstruct BinaryIndexedTree //Range Sum Query (RSQ), 0-indexed\n{\n  \nprivate:\n  int size_;\n  vector< Type_value > data;\n\npublic:\n  BinaryIndexedTree(int sz, Type_value identity_element_binaryindexedtree = 0.0 ) // constructor\n  {\n    size_ = sz;\n    data.resize(sz+1,identity_element_binaryindexedtree);\n  }\n\n  Type_value sum(int i) //sum within [0,i)\n  {\n    if( i <= 0 )\n      {\n\treturn (Type_value) 0.0;\n      }\n\n    if( i > size_ )\n      {\n\ti = size_;\n      }\n    \n    Type_value sm = 0.0;\n    while( i > 0 )\n      {\n\tsm += data[i];\n\ti -= i & -i;\n      }\n    \n    return sm;\n  }\n\n  void add(int i, Type_value x)\n  {\n    if( i < 0 or i >= size_ )\n      {\n\treturn;\n      }\n    ++ i;\n    while( i <= size_ )\n      {\n\tdata[i] += x;\n\ti += i & -i;\n      }\n  }\n};\n\n/*------------------ the end of the template -----------------------*/\n\n\n\n\n\n\n\n\n\nsigned main()\n{\n  IOS; /* making cin faster */\n  int V,E;\n  SCAND2(V,E);\n  vector<vector<int> > G(V);\n  vector<int> indeg(V,0);\n  vector<bool> notused(V,true);\n  REP(_,E)\n    {\n      int s,t;\n      SCAND2(s,t);\n      G[s].push_back(t);\n      ++ indeg[t];\n    }\n\n  vector<int> out;\n\n  REP(i,V)\n    {\n      if( indeg[i] == 0 and notused[i] )\n\t{\n\t  deque<int> dq;\n\t  dq.push_back(i);\n\t  notused[i] = false;\n\n\t  while( not dq.empty() )\n\t    {\n\t      int u = dq.front();\n\t      dq.pop_front();\n\t      out.push_back(u);\n\n\t      REP(j,SIZ(G[u]))\n\t\t{\n\t\t  int v = G[u][j];\n\t\t  -- indeg[v];\n\n\t\t  if( indeg[v] == 0 and notused[v] )\n\t\t    {\n\t\t      notused[v] = false;\n\t\t      dq.push_back(v);\n\t\t    }\n\t\t  \n\t\t}\n\t    }\n\t  \n\t}\n      \n    }\n\n\n  REP(i,V)\n    {\n      PRINTD(out[i]);\n    }\n  \n  \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define WHITE 0\n#define CANDIDATE 1\n#define VISITED 2\n\nvoid topo(vvi &g, vi &id, vi &c, vi &o, int n) {\n  queue<int> q;\n  q.push(n);\n\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    \n    o.push_back(u);\n    c[u] = VISITED;\n    \n    for (auto x: g[u]) {\n      id[x]--;\n      if (!id[x] && c[x] == WHITE) {\n        c[x] = CANDIDATE;\n        q.push(x);\n      }\n    }\n  }\n}\n\nint main() {\n  int v, e, s, t;\n  cin >> v >> e;\n  \n  vvi g(v);\n  vi id(v), c(v, WHITE), o;\n  rep(i, e) {\n    cin >> s >> t;\n    g[s].push_back(t);\n    id[t]++;\n  }\n  \n  rep(i, v) \n    if (!id[i] && c[i] == WHITE) topo(g, id, c, o, i);\n  \n  rep(i, v) cout << o[i] << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define F first\n#define S second\nint const M=2e5+10;\nvector<int>adj[M];\nint cnt[M],q[M];\nmain()\n{\n\tint n,m,a,b;\n\tcin>>n>>m;\n\tint tail=0,head=0;\n\tfor(int i=1;i<=m;i++)cin>>a>>b,adj[a].pb(b),cnt[b]++;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\t//sort(adj[i].begin(),adj[i].end());\n\t\tif(cnt[i]==0)\n\t\t\tq[head++]=i;\n\t}\n\tint tmp=0;\n\twhile(head>tail)\n\t{\n\t\ttmp++;\n\t\tint now=q[tail++];\n\t\tfor(int i=0;i<adj[now].size();i++)\n\t\t{\n\t\t\tint u=adj[now][i];\n\t\t\tcnt[u]--;\n\t\t\tif(cnt[u]==0)\n\t\t\t\tq[head++]=u;\n\t\t}\n\t}\n\tif(tmp==n){\n\t\tfor(int i=0;i<head;i++)\n\t\t\tcout<<q[i]<<endl;\n\t}\n\telse cout<<\"NO\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\nconstexpr auto INF = 2147483647;\ntypedef long long ll;\n\nstatic const int MAX = 100000;\nvector<int> adjGraph[MAX];\nlist<int> ans;\nbool check[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int start){\n  queue<int> que;\n  que.push(start);\n  check[start] = true;\n  while(!que.empty()){\n    int u = que.front(); \n    que.pop();\n    ans.push_back(u);\n    rep(i,adjGraph[u].size()){\n      int v = adjGraph[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !check[v]){\n        que.push(v);\n        check[v] = true;\n      }\n    }\n  }\n}\n\nvoid tpSort(){\n  rep(i,N) indeg[i] = 0;\n  rep(u,N){\n    rep(i,adjGraph[u].size()){\n      int v = adjGraph[u][i];\n      indeg[v]++;\n    }\n  }\n  \n  rep(u,N){\n    if(indeg[u] == 0 && !check[u])bfs(u);\n  }\n  for(auto itr = ans.begin();itr != ans.end(); itr++){\n    cout << *itr << endl;\n  }\n  \n}\n\n\nint main(){\n\n  int s,t ,M;\n  cin >> N >> M;\n\n  rep(i,N) check[i] = false;\n\n  rep(i,M){\n    cin >> s >> t;\n    adjGraph[s].push_back(t);\n  }\n  tpSort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){cout << \"{\"; for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\nvoid solve();\nint main(){ cin.tie(0); ios::sync_with_stdio(false); solve(); return 0;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nvector<int> topological_sort(const vector<vector<int>>& graph){\n  // if graph is not DAG, return {}\n  // else topological sorted vertices\n  int N = graph.size();\n  stack<int> st;\n  vector<int> h(N), res;\n  for(int i = 0; i < N; i++)\n    for(auto& v: graph[i]) h[v]++;\n  for(int i = 0; i < N; i++)\n    if(h[i] == 0) st.push(i);\n  while(st.size()) {\n    int u = st.top(); st.pop();\n    res.push_back(u);\n    for(auto& v: graph[u]){\n      h[v]--;\n      if(h[v] == 0) st.push(v);\n    }\n  }\n  if(res.size() != N) res.clear();\n  return res;\n}\n\nvoid GRL_4_B(){\n  int N,M; cin >> N >> M;\n  vvi g(N);\n  rep(i,M){\n    int s,t; cin >> s >> t;\n    g[s].pb(t);\n  }\n  auto ts = topological_sort(g);\n  rep(i,N) cout << ts[i] << endl;\n}\n\nvoid solve(){\n  GRL_4_B();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint n, m;\nvector<int> G[10000];\nint in[10000];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    queue<int> que;\n    vector<int> ans;\n    rep(i, n) if(in[i] == 0) que.push(i);\n\n    while(!que.empty()) {\n        int v = que.front();\n        ans.push_back(v);\n        que.pop();\n        for(int e : G[v])\n            if(--in[e] == 0) que.push(e);\n    }\n\n    rep(i, n) cout << ans[i] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <list>\n#include <algorithm>\n\n\nusing namespace std;\n\n\nusing ll = long long;\n\n\nvector<vector<ll>> graph;\nvector<ll> out;\n// list<ll> out;\nvector<bool> discovered;\nvector<ll> indeg;\nll V, E;\n\n/*\nvoid bfs(ll start)\n{\n    queue<ll> q;\n    q.push(start);\n    discovered[start] = true;\n\n    while (!q.empty()) {\n        ll now = q.front();\n        q.pop();\n\n        out.push_back(now);\n\n        for (auto e : graph[now]) {\n            indeg[e]--;\n            if (indeg[e] == 0 && !discovered[e]) {\n                discovered[e] = true;\n                q.push(e);\n            }\n        }\n    }\n}\n\n\nvoid topological_sort_bfs()\n{\n    for (ll i = 0; i < V; i++) {\n        if (indeg[i] == 0 && !discovered[i]) {\n            bfs(i);\n        }\n    }\n}\n*/\n\n\nvoid dfs(ll now)\n{\n    discovered[now] = true;\n    for (auto e : graph[now]) {\n        if (!discovered[e])\n            dfs(e);\n    }\n    out.push_back(now);\n}\n\n\nvoid topological_sort_dfs()\n{\n    // for (ll i = 0; i < V; i++) {\n    for (ll i = V - 1; i >= 0; i--) {\n        if (!discovered[i])\n            dfs(i);\n    }\n    reverse(out.begin(), out.end());\n}\n\n\nint main()\n{\n\n    cin >> V >> E;\n    graph.resize(V);\n    discovered.resize(V, false);\n    indeg.resize(V, 0);\n\n    for (ll i = 0; i < E; i++) {\n        ll s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        indeg[t]++;\n    }\n\n    topological_sort_dfs();\n\n    for (auto e : out)\n        cout << e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\nvoid tsort(){\n    for(int i=0;i<N;i++) indeg[i]=0;\n    for(int u=0;u<N;u++){  \n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n    for(int u=0;u<N;u++){\n        if(indeg[u]==0 && !V[u])\n            bfs(u);\n    }\n    for(list<int>::iterator it=out.begin();it!=out.end();it++)\n        cout<<*it<<\"\\n\";\n}\nint main(){\n    int s,t,M;\n    cin>>N>>M;\n    for(int i=0;i<N;i++)V[i]=false;\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\nusing namespace std;\n\nconst int N = 10000;\nconst int INFTY = (1 << 29);\nint n, e;\nvector<int> G[N];\nint indeg[N];\nbool visited[N];\nlist<int> out;\n\nvoid bfs(int u) {\n\tqueue<int> q;\n\tq.push(u);\n \n\tvisited[u] = true;\n    int s;\n    while( !q.empty() ) {\n    \ts = q.front(); q.pop();\n    \tout.push_back(s);\n    \tfor( int i = 0; i < G[s].size(); i++) {\n    \t\t    int v = G[s][i];\n    \t\t\tindeg[v]--;\n    \t\t\tif(indeg[v] == 0 )\n    \t\t\t{\n    \t\t\t\tvisited[v] = true;\n    \t\t\t\tq.push(v);\n    \t\t\t}\n   \t\t\t\n    \t\t\n    \t}\n\n\n    }\n    \n}\nvoid tsort() {\n\tfor( int i = 0; i < n; i++ ) indeg[i]= 0;\n\n\tfor( int i = 0; i < n; i++ ) {\n\t\t\n\t\tfor( int j = 0; j < G[i].size(); j++ ) {\n           indeg[G[i][j]] ++;\n\t\t}\n\t}\n\n\tfor( int u = 0; u < n; u++ ) {\n\t\tif( indeg[u] == 0 && !visited[u] ) bfs(u);\n\t}\n\n\tfor( list<int>::iterator it = out.begin(); it != out.end(); it++ ) {\n\t\tcout << *it << endl;\n\t}\n}\nint main() {\n\tint u, k, v;\n\tcin>> n >> e;\n    \n    for( int i = 0; i < n; i++ ) visited[i] = false;\n\t\n\t\n\tfor ( int i = 0; i < e; i++ ) {\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\n\t}\n\n\ttsort();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,u,v;\nvector<int>e[100005];\nint d[100005];\nint main(){\n//\tfreopen(\"a.txt\",\"r\",stdin);\n\tcin.tie(0);\n\tcin>>n>>m;\n\twhile(m--){\n\t\tcin>>u>>v;\n\t\te[u].push_back(v);\n\t\td[v]++;\n\t}\n\tqueue<int>q;\n\tfor(int i=0;i<n;i++)if(d[i]==0)q.push(i);\n\twhile(!q.empty()){\n\t\tcout<<q.front()<<endl;\n\t\tfor(int i=0;i<e[q.front()].size();i++){\n\t\t\t--d[e[q.front()][i]];\n\t\t\tif(d[e[q.front()][i]]==0)q.push(e[q.front()][i]);\n\t\t}\n\t\tq.pop();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nconst ll MOD = 1e9+7;\nll solve(){\n    ll res = 0;\n    ll N,K; cin >> N >> K;\n    string S; cin >> S;\n    \n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n   // cout << solve() << endl;\n    ll V,E; cin >> V >> E;\n    vector<int> cnt(V);\n    for(int i = 0; i < E;i++){\n        int s,t; cin >> s >> t;\n        cnt[t]++;\n    }\n    priority_queue<pll,vector<pll>,greater<pll>> pq;\n    for(int i = 0; i < V;i++) pq.push({cnt[i],i});\n    while(pq.size()){\n        cout << pq.top().second << endl;\n        pq.pop();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100] = {};\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      if( not ( 1 <= id[i] and id[i] <= V ) ) exit(1);\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor ( int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif( indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor(int i = 0; i< N;i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor(int u =0; u< N; u++) {\n\t\tfor ( int i =0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor ( int u = 0; u < N; u++) {\n\t\tif( indeg[u] == 0 && !V[u]) bfs(u);\n\t}\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main(){\n\tint s, t, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i ++) V[i] = false;\n\tfor ( int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nnamespace ProconLib{\n\n    //struct graph_t\n    //  requirement\n    //      int to;\n\n\n    template<class graph_t>\n    std::vector<int> TopologicalSort(const graph_t &g){\n        int n=g.size();\n        std::vector<int> res(n);\n        std::vector<int> in(n);\n        for(int i=0;i<n;i++) for(auto e:g[i]) in[e.to]++;\n\n        std::queue<int> que;\n        for(int i=0;i<n;i++) if(in[i]==0) que.push(i);\n\n        int id=0;\n        while(!que.empty()){\n            int v=que.front(); que.pop();\n            res[id++]=v;\n            for(auto e:g[v]){\n                in[e.to]--;\n                if(in[e.to]==0) que.push(e.to);\n            }\n        }\n        if(id!=n){\n            throw std::runtime_error(\"Given graph is not DAG.\");\n        }\n        return res;\n    };\n\n    template<typename graph_t>\n    bool isDAG(const graph_t& g){\n        try{\n            TopologicalSort(g);\n            return true;\n        }catch(std::runtime_error e){\n            return false;\n        }\n    }\n    \n};\n\nusing namespace std;\nusing namespace ProconLib;\n\nstruct Edge{\n    int to;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        g[u].push_back({v});\n    }\n\n    auto res=TopologicalSort(g);\n    for(auto v:res)cout<<v<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n\tint num,E,from,to,table[10000],tmp;\n\tvector<int> V[10000];\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < 10000; i++)table[i] = 0;\n\n\tscanf(\"%d %d\",&num,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\ttable[to]++;\n\t}\n\n\tfor(int i = 0; i < num; i++){\n\t\tif(table[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\t\tprintf(\"%d\\n\",tmp);\n\t\tfor(int i = 0; i < V[tmp].size(); i++){\n\t\t\ttable[V[tmp][i]]--;\n\t\t\tif(table[V[tmp][i]] == 0){\n\t\t\t\tQ.push(V[tmp][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// using\n// template<typename Label, typename Weight>\n// using Graph = std::unordered_map<Label, std::unordered_map<Label, Weight>>;\ntypedef std::unordered_map<int, std::unordered_map<int, int>> Graph;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> topological_sort(const Graph& reverse, int current, unordered_set<int>& unvisited) {\n  vector<int> result = {current};\n  unvisited.erase(current);\n  if(reverse.count(current)) for(const auto& e: reverse.at(current)) {\n    if(unvisited.count(e.first)) {\n      auto add = topological_sort(reverse, e.first, unvisited);\n      result.insert(begin(result), begin(add), end(add));\n    }\n  }\n  return result;\n}\nvector<int> topological_sort(const Graph& g, int V) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  for(int i = 0; i < V; ++i) unvisited.insert(i);\n  Graph reverse;\n  for(const auto& list: g) for(const auto& e: list.second) reverse[e.first][list.first] = e.second;\n  while(!unvisited.empty()) {\n    auto add = topological_sort(reverse, *begin(unvisited), unvisited);\n    result.insert(end(result), begin(add), end(add));\n  }\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g, V)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nconst int V_MAX = 1000;\n\nvoid solve(vector<int> a[], int table[], int n) {\n\tif (--table[n] > 0)return;\n\tprintf(\"%d\\n\", n);\n\tfor (int i = 0; i < a[n].size(); i++) {\n\t\tsolve(a, table, a[n][i]);\n\t}\n}\n\nint main() {\n\tint v, e;\n\tint table[V_MAX] = { 0 };\n\tvector<int> edge[V_MAX];\n\tvector<int> ans;\n\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tedge[s].push_back(t);\n\t\ttable[t]++;\n\t}\n\t\n\tfor (int i = 0; i < v; i++) {\n\t\tif (table[i] == 0) {\n\t\t\tsolve(edge, table, i);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nvoid visit(const vector<vector<int>>& g, int u, vector<bool>&used, vector<int>& ans) {\n\n    if( used[u] == false ) {\n\tused[u] = true;\n\tfor(auto& v : g[u]) {\n\t    visit(g, v, used, ans);\n\t}\n\tans.emplace_back(u);\n    }\n}\n\nvector<int> tsort_Tarjan(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<bool> used(V,false);\n    vector<int> ans;\n    for (int u=0; u<V; ++u) {\n\tvisit(g, u, used, ans);\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n\n\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_Tarjan(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n\nstd::vector<int> tsort(const Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    std::vector<int> res, flg(n, YET);\n    static const std::function<bool(int)> dfs = [&](int v) {\n        if(flg[v] == VISITED)\n            return false;\n        else if (flg[v] == YET) {\n            flg[v] = VISITED;\n            for (auto &e : g[v])\n                if (!dfs(e.dst)) return false;\n            flg[v] = DONE;\n            res.push_back(v);\n        }\n        return true;\n    };\n    for (int i = 0; i < n; ++i)\n        if (flg[i] == YET && !dfs(i)) return {};\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint v, e, a, b;\nstd::vector<std::vector<int>> g;\nstd::vector<int> indeg, out;\nstd::vector<bool> visited;\n\nint main() {\n    std::cin >> v >> e;\n    visited.assign(v, false);\n    g.assign(v, std::vector<int>(0));\n    indeg.assign(v, 0);\n    for (int i = 0; i < e; i++) {\n        std::cin >> a >> b;\n        g[a].push_back(b);\n    }\n    for (int i = 0; i < v; i++) {\n        for (int p = 0; p < g[i].size(); p++) {\n            int c = g[i][p];\n            indeg[c]++;\n        }\n    }\n    for (int w = 0; w < v; w++) {\n        if (indeg[w] == 0 && !visited[w]) {\n            std::queue<int> q;\n            q.push(w);\n            while (!q.empty()) {\n                auto f = q.front();\n                q.pop();\n                out.push_back(f);\n                for (int k = 0; k < g[f].size(); k++) {\n                    int x = g[f][k];\n                    indeg[x]--;\n                    if (indeg[x] == 0 && !visited[x]) {\n                        visited[x] = true;\n                        q.push(x);\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < out.size(); i++) {\n        std::cout << out[i] << std::endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;// 998244353;// ;\nconstexpr long long INF = numeric_limits<LL>::max() / 2;\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<vector<LL>>g;\nvector<edge>edges;\nvector<LL>v;\nmap<LL, LL>ma;\nset<Pll>st;\nLL h, w, n, m, k, t, s, p, q, last, cnt, sum, ans, dp[210000],a[210000], b[210000];\nstring str, ss;\nbool f;\nchar c;\nvector<LL> tsort(vector<vector<LL>>&g) {\n\tLL n = g.size();\n\tvector<LL>ret;\n\tvector<bool>used(n);\n\tfunction<void(LL)>dfs = [&](LL cur) {\n\t\tused[cur] = 1;\n\t\trep(i, g[cur].size()) {\n\t\t\tif(!used[g[cur][i]])\n\t\t\tdfs(g[cur][i]);\n\t\t}\n\t\tret.push_back(cur);\n\t};\n\trep(i, n) {\n\t\tif (!used[i])dfs(i);\n\t}\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nint main() {\n\tcin >> n>>m;\n\tg.resize(n);\n\trep(i, m) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tg[x].push_back(y);\n\t}\n\tvector<LL>ts = tsort(g);\n\trep(i, n) {\n\t\tcout << ts[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint v ,e;\nint sta[10001];\nvector <int> gin[10001];\nvector <int> gout[10001];\nqueue <int> Q;\nvector <int> ans;\n\nvoid toporogical_sort(){\n  for(int i=0;i<v;i++)\n    if(gin[i].size() == 0) {\n      Q.push(i);\n    }\n  while(!Q.empty()) {\n    int t = Q.front();\n    Q.pop();\n    ans.push_back(t);\n\n    for(int i=0;i<gout[t].size();i++){\n      int nx = gout[t][i];\n      int size = gin[nx].size();\n      for(int j=0;j<size;j++)\n\tif(gin[nx][j] == t){\n\t  gin[nx].erase(gin[nx].begin()+j);\n\t  break;\n\t}\n      if(gin[nx].size() == 0) Q.push(nx);\n    }\n  }\n\n\n}\n\n\nint main() {\n\n  cin >> v >> e;\n\n  for(int i=0;i<e;i++) {\n    int s,t;\n    cin >> s >> t;\n    gin[s].push_back(t);\n    gout[t].push_back(s);\n  }\n  toporogical_sort();\n\n  for(int i=ans.size()-1;i>=0;i--) cout << ans[i] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP( i, n )     for( int (i) = 0; (i) < (n); (i)++ )\n#define ALL( a )        (a).begin(), (a).end()\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nint V, E;\nvector<int> G[10001];\nvector<int> ans;\nint indeg[10001];\nbool seen[10001];\n\nvoid dfs( int s ){\n    seen[s] = true;\n\n    for( auto nv : G[s] ){\n        if( seen[nv] ) continue;\n        dfs( nv );\n    }\n\n    ans.emplace_back( s );\n}\n\nint main(){\n    cin >> V >> E;\n    REP( i, E ){\n        int s, t; cin >> s >> t;\n        G[s].emplace_back( t );\n        indeg[t]++;\n    }\n\n    REP( i, V ){\n        if( indeg[i] == 0 ){\n            dfs( i );\n        }\n    }\n\n    REP( i, ans.size() ) cout << ans[ans.size() - i - 1] << endl;\n\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1000000\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint N;\nint indog[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indog[v]--;\n      if(indog[v]==0&&!V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(){\n  for(int i=0;i<N;i++){\n    indog[i]=0;\n  }\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){\n      int V=G[u][i];\n      indog[V]++;\n    }\n  }\n  for(int u=0;u<N;u++){\n    if(indog[u]==0&&!V[u]){\n      bfs(u);\n    }\n  }\n  for(list<int>::iterator it=out.begin();it!=out.end();it++){\n    cout<<*it<<endl;\n  }\n}\nint main(){\n  int s,t,M;\n  cin>>N>>M;\n  for(int i=0;i<N;i++){\n    V[i]=false;\n  }\n  for(int i=0;i<M;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  tsort();\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INF = (1<<29);\nint N,M;\nvector< int > G[MAX];\nbool V[MAX];\nint indeg[MAX];\nlist< int > out;\n\nvoid bfs(int num){\n  queue<int> que;\n  que.push(num);\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    out.push_back(now);\n    for(int i=0;i<G[now].size();i++){\n      int v = G[now][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n\tV[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(){\n  for(int i=0;i<N;i++){\n    indeg[i] = 0;\n    V[i] = false;\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<G[i].size();j++) indeg[G[i][j]]++;\n  }\n  for(int i=0;i<N;i++){\n    if(indeg[i] == 0 && !V[i]) bfs(i);\n  }\n  for(list<int>::iterator it = out.begin();it != out.end();it++){\n    cout << *it << endl;\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<M;i++){\n    int s,t; cin >> s >> t;\n    G[s].push_back(t);\n  }\n  tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nvector<bool> used(10000, 0);\nvector<int> indeg(10000, 0), child[10000], res;\n\nint main(){\n    int v, e, s, t;\n    cin >> v >> e;\n\n    for(int i = 0; i < e; i++){\n        cin >> s >> t;\n        child[s].push_back(t);\n        indeg[t]++;\n    }\n\n    queue<int> q;\n    for(int i = 0; i < v; i++)  if(indeg[i] == 0)   q.push(i);\n\n    while(!q.empty()){\n        int x = q.front();  q.pop();\n        used[x] = true;\n        res.push_back(x);\n        for(int c : child[x]){\n            indeg[c]--;\n            if(indeg[c] == 0)   q.push(c);\n        }\n    }\n\n    for(int x : res)    cout << x << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct TopologicalSort {\n  TopologicalSort () {}\n  TopologicalSort (int n) : n(n), G(n), used(n, 0) {}\n\n  int n;\n  vector<vector<int>> G;\n  vector<int> order, used;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n  }\n\n  void dfs(int v) {\n    if (used[v]) return;\n    used[v] = true;\n    for (auto to : G[v]) dfs(to);\n    order.push_back(v);\n  }\n\n  void build() {\n    for (int i = 0; i < n; ++i) dfs(i);\n    reverse(order.begin(), order.end());\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  TopologicalSort ts(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ts.add_edge(u, v);\n  }\n\n  ts.build();\n\n  for (int i = 0; i < n; ++i) {\n    cout << ts.order[i] << (i + 1 == n ? \"\\n\" : \" \");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// DFS algorithm\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool dfs(vector<vector<int>> &A, vector<int> &U, vector<int> &R, int c)\n{\n        if (U[c] == 2)\n                return true;\n        if (U[c] == 1)\n                return false;\n        U[c] = 1;\n        for (auto a: A[c])\n                if (!dfs(A, U, R, a))\n                        return false;\n        U[c] = 2;\n        R.push_back(c);\n        return true;\n}\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n        }\n        vector<int> U(V), R;\n        bool ok = true;\n        for (int i = 0; i < V && ok; i++)\n                if (!U[i])\n                       ok = dfs(A, U, R, i);\n        if (!ok) {\n                cout << \"Found cyclic path\" << endl;\n                return 0;\n        }\n        reverse(R.begin(), R.end());\n        for (auto r: R)\n                cout << r << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\n\nvector<int> g[100100];\nint h[100100];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,m; cin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y; cin >> x >> y;\n\t\tg[x].push_back(y);\n\t\th[y]++;\n\t}\n\tstack<int> st;\n\tfor(int i=0;i<n;i++){\n\t\tif(h[i]==0){\n\t\t\tst.push(i);\n\t\t}\n\t}\n\tvector<int> ans;\n\twhile(st.size()){\n\t\tint i=st.top(); st.pop();\n\t\tans.push_back(i);\n\t\tfor(int j:g[i]){\n\t\t\th[j]--;\n\t\t\tif(h[j]==0){\n\t\t\t\tst.push(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i:ans){\n\t\tcout << i << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAXN 10000+5\nusing namespace std;\nvector <int> p[MAXN];\nbool jud[MAXN];\nint n,m;\n\nvoid dfs(int i){\n\t\n\tint len=p[i].size();\n\tif (jud[i]) return;\n\t\n\tif (len == 0 && !jud[i]) {\n\t\tjud[i]=1;\n\t\tcout<<i<<endl;\n\t\treturn;\n\t}\n\t\n\tfor (int j = 0;j < len;++j){\n\t\tif (!jud[p[i][j]]) {\n\t\t\tdfs(p[i][j]);\t\n\t\t}\n\t}\n\tif (!jud[i]){\n\t\tjud[i]=1;\n\t\tcout<<i<<endl;\n\t}\n}\n\nint main(){\n\tint a,b,i,j;\n\tcin>>n>>m;\n\tfor (i = 0;i < m;++i){\n\t\tcin>>a>>b;\n\t\tp[b].push_back(a);\n\t}\n\tfor (i = 0;i < n;++i){\n\t\tif (p[i].size() == 0 && !jud[i]){\n\t\t\tjud[i]=1;\n\t\t\tcout<<i<<endl;\n\t\t}\n\t\telse dfs(i);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nvector<int>v[10000];\nvector<bool>vis(10000);\nstack<int>order;\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(auto i:v[u]){\n\t\tif(!vis[i])dfs(i);\n\t}\n\torder.emplace(u);\n}\nint main(){\n\tcin>>n>>m;\n\twhile(m--){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tv[l].emplace_back(r);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!vis[i])dfs(i);\n\t}\n\twhile(!order.empty()){\n\t\tcout<<order.top()<<\"\\n\";\n\t\torder.pop();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAXV 10001\n#define MAXE 100001\nusing namespace std;\n\nint main() {\n\tint i, j, v, e, s, t, isVisited[MAXV] = {};\n\tvector<int*> ntopa[MAXV];\n\tvector<int*>::iterator itv;\n\n\n\tcin >> v >> e;\n\tfor (i = 0; i < e; i++) {\n\t\tcin >> s >> t;\n\t\tntopa[t].push_back(&isVisited[s]);\n\t}\n\n\ti = -1;\n\twhile (1) {\n\t\t++i %= v;\n\t\tif (isVisited[i])continue;\n\t\tfor (itv = ntopa[i].begin(); itv != ntopa[i].end(); itv++) {\n\t\t\tif (*(*itv) == 0)break;\n\t\t}\n\t\tif (itv == ntopa[i].end()) {\n\t\t\tisVisited[i] = 1;\n\t\t\tcout << i << endl;\n\t\t\ti = 0;\n\t\t\tfor (j = 0; j < v; j++) {\n\t\t\t\tif (isVisited[j] == 0)break;\n\t\t\t}\n\t\t\tif (j == v) return 0;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\n\nint N,M;\nvector<int> graph[vmax];\n\nbool used[vmax];\n\nvoid dfs(int v,vector<int>& order){\n\tused[v]=true;\n\tfor(auto &u:graph[v]){\n\t\tif(!used[u])\n\t\t\tdfs(u,order);\n\t}\n\torder.push_back(v);\n}\n\nvoid topologicalSort(vector<int>& order) {\n\trep(i,N) used[i]=false;\n\trep(i,N)if(!used[i]) dfs(i,order);\n\treverse(order.begin(),order.end());\n}\n\nint main(void){\n\tcin >> N >> M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t}\n\tvector<int> order;\n\ttopologicalSort(order);\n\tfor(auto &v:order) cout << v << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\n#define LP(i,n) for(int i=0;i<n;i++)\n#define Mset(x,v) memset(x,v,sizeof(x))\n\nusing namespace std;\nusing LL=long long;\n\nstatic const int MAX=100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n    V[u]=true;\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,M;\n    cin>>N>>M;\n    for(int i=0;i<N;i++) V[i]=false;\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    for(int i=0;i<N;i++){\n        if(!V[i]) dfs(i);\n    }\n    for(list<int>::iterator it=out.begin();it!=out.end();it++) cout<<*it<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_V = 1e5 + 10;\n\nvector<int> G[MAX_V];\nint V;\nbool visited[MAX_V]; \nvector<int> ans;\nint degree[MAX_V];\n\nvoid bfs(int s){\n\tqueue<int> q;\n\tq.push(s);\n\tvisited[s] = true;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tans.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tdegree[v]--;\n\t\t\tif (degree[v] == 0 && !visited[v]){\n\t\t\t\tvisited[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid topologicalSort(){\n\tfill(degree, degree + V, 0);\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tfor (int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tdegree[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t\tif (degree[u] == 0 && !visited[u]) bfs(u);\n}\n\nint main(int argc, char const *argv[])\n{\n\tint E;\n\tcin >> V >> E;\n\n\tfill(visited, visited + V, false);\n\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttopologicalSort();\n\n\tfor (int i = 0; i < ans.size(); ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nconst constexpr int MAX = 100;\nconst constexpr ll INF = 1LL<<32;\nvi G[MAX], indeg(MAX, 0), out;\nvb V(MAX, false);\nint n;\ndeque<int> dq;\ninline void bfs(int s) {\n\tdq.clear();\n\tdq.eb(s);\n\tV[s] = true;\n\tint u, v;\n\twhile(!dq.empty()) {\n\t\tu = dq.front(); dq.pop_front();\n\t\tout.eb(u);\n\t\trep(i, 0, len(G[u])) {\n\t\t\tv = G[u][i];\n\t\t\tif(--indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tdq.eb(v);\n\t\t\t}\n\t\t}\n\t}\n}\ninline void tsort() {\n\trep(u, 0, n) rep(i, 0, len(G[u])) ++indeg[G[u][i]];\n\trep(u, 0, n) if(indeg[u] == 0 && !V[u]) bfs(u);\n\trep(i, 0, len(out)) P(out[i]);\n}\nint main() {\n\tint m; cin >> n >> m;\n\tint s, t;\n\trep(i, 0, m) {\n\t\tcin >> s >> t;\n\t\tG[s].eb(t);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\nvoid dfs(vector<vector<int > > g,vector<int>& used,int s){\n\tused[s] = 0;\n\t//auto it = lower_bound(g[s].begin(),g[s].end(),s);\n\t//int k = (int)(it-g[s].begin());\n\t//for(int i=k;g[s].size();i++ ){\n\trep(i,g[s].size()){\n\tif(used[g[s][i]])\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back(s);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<int> used(v,1);\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\tint i = (it-used.begin());\n\t//rep(i,v){\n\t//if(used[i]){\n\twhile(i<=v-1){\n\t\t// int i = it-used.begin();\n\tdfs(g,used,i);\n\t//cout<<i<<endl;\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\t i = (it-used.begin());\n\t//\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\trep(i,e){\n\tsort(g[i].begin(),g[i].end());\n\t}\n\t/*rep(i,e){\n\t\trep(j,g[i].size()){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\n\nint V, E;\nvector<vector<int> > G;\nvector<int> color;\nlist<int> ans;\nvoid init()\n{\n  G.resize(V);\n  color.resize(V, WHITE);\n}\n\nvoid dfs(int u)\n{\n  color.at(u) = GRAY;\n  for (int i = 0; i < G.at(u).size(); i++)\n  {\n    if (color.at(G.at(u).at(i)) == WHITE)\n    {\n      dfs(G.at(u).at(i));\n    }\n  }\n  ans.push_front(u);\n}\n\nvoid topological_sort()\n{\n  for (int i = 0; i < V; i++)\n  {\n    if (color.at(i) == WHITE)\n    {\n      dfs(i);\n    }\n  }\n}\n\nint main()\n{\n  cin >> V >> E;\n  init();\n  for (int i = 0; i < E; i++)\n  {\n    int s, t;\n    cin >> s >> t;\n    G.at(s).push_back(t);\n  }\n  topological_sort();\n  for (int i = 0; i < V; i++)\n  {\n    cout << ans.front() << endl;\n    ans.pop_front();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while ( !q.empty() ) {\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for ( int i = 0; i < G[u].size(); i++ ) {\n            int v = G[u][i];\n            indeg[v]--;\n            if ( indeg[v] == 0 && !V[v] ) {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort() {\n    for ( int i = 0; i < N; i++ ) {\n        indeg[i] = 0;\n    }\n    \n    for ( int u = 0; u < N; u++ ) {\n        for ( int i = 0; i < G[u].size(); i++ ) {\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    \n    for ( int u = 0; u < N; u++ )\n        if ( indeg[u] == 0 && !V[u] ) bfs(u);\n        \n    for ( list<int>::iterator it = out.begin(); it != out.end(); it++ ) {\n        cout << *it << endl;\n    }\n}\n\nint main() {\n    int s, t, M;\n    \n    cin >> N >> M;\n    \n    for ( int i = 0; i < N; i++ ) V[i] = false;\n    \n    for ( int i = 0; i < M; i++ ) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// Begin Header {{{\n#define all(x)          (x).begin(), (x).end()\n#define rep(i, n)       for (i64 i = 0, i##_limit = (n); i < i##_limit; ++i)\n#define reps(i, s, t)   for (i64 i = (s), i##_limit = (t); i <= i##_limit; ++i)\n#define repr(i, s, t)   for (i64 i = (s), i##_limit = (t); i >= i##_limit; --i)\n#define var(Type, ...)  Type __VA_ARGS__; input(__VA_ARGS__)\n#ifndef DBG\n#define trace(...)\n#endif\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<i64, i64>;\ntemplate <class T, class U> inline bool chmax(T &a, const U &b) { return b > a && (a = b, true); }\ntemplate <class T, class U> inline bool chmin(T &a, const U &b) { return b < a && (a = b, true); }\ninline i64  sigma(i64 n)            { return (n * (n + 1) >> 1); }\ninline i64  updiv(i64 a, i64 b)     { return (a + b - 1) / b; }\ninline i64  sqr(i64 n)              { return n * n; }\ninline string to_string(char c)     { return string(1, c); }\nconstexpr int INF  = 0x3f3f3f3f;\nconstexpr i64 LINF = 0x3f3f3f3f3f3f3f3fLL;\n\ntemplate <class T>\ninline vector<T> make_v(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\ntemplate <class T, class... Args>\ninline auto make_v(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(make_v<T>(initValue, args...))>(sz, make_v<T>(initValue, args...));\n}\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head &head, Tail&... tail) { cin >> head; input(tail...); }\n\ninline void print() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void print(Head &&head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) cout << ' ';\n    print(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<< (ostream &out, const vector<T> &vec) {\n    static constexpr const char *delim[] = { \" \", \"\" };\n    for (const auto &e : vec) out << e << delim[&e == &vec.back()];\n    return out;\n}\n\ntemplate <typename Func>\nstruct FixPoint : Func {\n    inline constexpr FixPoint(Func &&f) noexcept : Func(forward<Func>(f)) {}\n\n    template <typename... Args>\n    inline decltype(auto) operator()(Args &&... args) const {\n        return Func::operator()(*this, forward<Args>(args)...);\n    }\n};\n\ntemplate< typename Func >\ninline decltype(auto) makeFixPoint(Func &&f) {\n    return FixPoint< Func >{forward< Func >(f)};\n}\n// }}} End Header\n\nnamespace topologicalSort { /// {{{\n    namespace {\n        template <class Edge> using Graph = vector<vector<Edge>>;\n    }\n\n    template <class Edge>\n        vector<int> sortedNodeArray(const Graph<Edge> &G) {\n            const int V = G.size();\n            vector<int> indeg(V, 0);\n            vector<int> ans, stk;\n            ans.reserve(V);\n            stk.reserve(V);\n\n            for (int v = 0; v < V; ++v) {\n                for (const int to : G[v]) ++indeg[to];\n            }\n            for (int v = 0; v < V; ++v) {\n                if (indeg[v] == 0) stk.emplace_back(v);\n            }\n\n            while (stk.size()) {\n                const int v = stk.back(); stk.pop_back();\n                ans.emplace_back(v);\n                for (const int to : G[v]) {\n                    if (--indeg[to] == 0) stk.emplace_back(to);\n                }\n            }\n\n            return ans;\n        }\n\n    template <class Edge>\n        vector<int> orderTable(const Graph<Edge> &G) {\n            const auto sorted = sortedNodeArray(G);\n            vector<int> order(G.size());\n\n            for (int i = 0; i < sorted.size(); ++i) {\n                order[sorted[i]] = i;\n            }\n\n            return order;\n        }\n} // }}}\n\nusing Graph = vector<vector<int>>;\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n\n    var(int, V, E);\n    Graph G(V);\n    rep(i, E) {\n        var(int, a, b);\n        G[a].emplace_back(b);\n    }\n\n    for (const int v : topologicalSort::sortedNodeArray(G)) {\n        print(v);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(a);i<(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define var auto\n#define mod 1000000007\n#define inf 2147483647\n#define nil -1\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\n\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p){\n        cout << fixed << setprecision(p)  << a << \"\\n\";\n    }\n    else{\n        cout << a << \"\\n\";\n    }\n}\n// end of template\n\nclass topological_sort{\npublic:\n    int V;\n    vector<int> vis, indeg, sorted;\n    vector<vector<int>> edge;\n    topological_sort(int v){\n        V = v;\n        vis.resize(v, 0);\n        indeg.resize(v, 0);\n        edge.resize(v);\n    }\n    \n    void add(int from, int to){\n        edge[from].push_back(to);\n        indeg[to]++;\n    }\n    \n    void bfs(int s){\n        queue<int> q;\n        q.push(s);\n        vis[s] = 1;\n        while (!q.empty()) {\n            int f = q.front();\n            q.pop();\n            sorted.push_back(f);\n            rep(i, edge[f].size()){\n                int e = edge[f][i];\n                indeg[e]--;\n                if (indeg[e] == 0 && !vis[e]) {\n                    vis[e] = 1;\n                    q.push(e);\n                }\n            }\n        }\n    }\n    \n    void sort(){\n        rep(i, V){\n            if (indeg[i] == 0 && !vis[i]) {\n                bfs(i);\n            }\n        }\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    int V, E;\n    cin >> V >> E;\n    topological_sort ts(V);\n    rep(i, E){\n        int s, t;\n        cin >> s >> t;\n        ts.add(s, t);\n    }\n    ts.sort();\n    \n    rep(i, ts.sorted.size()){\n        cout << ts.sorted[i] << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<list>\n#include<queue>\nusing namespace std;\nconst int MAX = 10005;\nbool status[MAX]={false};\nint indeg[MAX]={0};\nlist<int> result;\nvector<int> mark[MAX];\nint n;\ninline void setdata(){\n\tint m,s,t;\n\tcin>>n>>m;\n\twhile(m--){\n\t\tcin>>s>>t;\n\t\tmark[s].push_back(t);\n\t\t++indeg[t];\n\t}\n}\ninline void display(){\n\tfor(list<int>::iterator it = result.begin();it!=result.end();++it)\n\t\tcout<<*it<<endl;\n}\nvoid bfs(int v){\n\tqueue<int> q;\n\tstatus[v]=true;\n\tq.push(v);\n\twhile(!q.empty()){\n\t\tint now = q.front();\n\t\tq.pop();\n\t\tresult.push_back(now);\n\t\tfor(int i =0;i<mark[now].size();++i){\n\t\t\tindeg[mark[now][i]]--;\n\t\t\tif(!indeg[mark[now][i]]&&!status[mark[now][i]]){\n\t\t\t\tstatus[mark[now][i]]=true;\n\t\t\t\tq.push(mark[now][i]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int v){\n\tstatus[v] = true;\n\tresult.push_back(v);\n\tfor(int i =0;i<mark[v].size();++i){\n\t\tindeg[mark[v][i]]--;\n\t\tif(!indeg[mark[v][i]]&&!status[mark[v][i]]) \n\t\t\tdfs(mark[v][i]);\n\t}\n}\nvoid slove(){\n\tsetdata();\n\tfor(int i = 0;i<n;++i)\n\t\tif(!indeg[i]&&!status[i])\n\t\t\tdfs(i);\n\tdisplay();\n}\nint main(){\n\tslove();\n\treturn 0;\n}\n/*\nmark v\npush v\nfor i ---v-size \n --i-indeg\n\tif(allow) dfs [i]\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nstruct edge {\n    typedef size_t weight_type;\n\n    size_t m_to;\n\n    edge(size_t to) : m_to(to) { }\n\n    inline size_t to() const { return m_to; }\n\n    inline weight_type weight() const { return 1; }\n\n    friend std::ostream& operator<<(std::ostream &os, const edge &e) {\n        os << \"{ to: \" << e.m_to << \" }\";\n        return os;\n    }\n};\n\ntemplate <class Edge>\nstruct graph {\n    typedef Edge edge_type;\n\n    size_t m_n_vertices;\n    std::vector<std::vector<edge_type>> m_edges;\n\n    graph(size_t n_vertices) : m_n_vertices(n_vertices), m_edges(n_vertices) { }\n\n    inline size_t n_vertices() const { return m_n_vertices; }\n\n    inline void make_edge(size_t from, size_t to, typename edge_type::weight_type weight) {\n        m_edges[from].emplace_back(edge_type(to, weight));\n    }\n\n    inline void make_edge(size_t from, size_t to) {\n        m_edges[from].emplace_back(edge(to));\n    }\n\n    inline void make_edge(size_t from, const edge_type &e) {\n        m_edges[from].emplace_back(e);\n    }\n\n    inline std::vector<edge_type> edges_from(size_t v) const {\n        return m_edges[v];\n    }\n};\n\n// time complexity: O(V + E)\ntemplate <class Graph>\nstd::vector<size_t> topological_sort(const Graph &g) {\n\n    using Edge = typename Graph::edge_type;\n\n    std::vector<size_t> topological_orders(g.n_vertices());\n    std::vector<size_t> indegrees(g.n_vertices());\n\n    for (size_t v = 0; v < g.n_vertices(); ++v) {\n        for (const Edge &e: g.edges_from(v)) {\n            ++indegrees[e.to()];\n        }\n    }\n\n    std::queue<size_t> q;\n\n    for (size_t v = 0; v < g.n_vertices(); ++v) {\n        if (!indegrees[v]) {\n            q.push(v);\n        }\n    }\n\n    for (size_t i = 0; i < g.n_vertices(); ++i) {\n        if (q.empty()) { // has cycle\n            return { };\n        }\n        size_t u = q.front();\n        q.pop();\n        topological_orders[i] = u;\n        for (const Edge &e: g.edges_from(u)) {\n            size_t v = e.to();\n            --indegrees[v];\n            if (!indegrees[v]) {\n                q.push(v);\n            }\n        }\n    }\n\n    return topological_orders;\n}\n\nint main() {\n    using namespace std;\n\n    using Graph = graph<edge>;\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        g.make_edge(s, t);\n    }\n\n    auto topological_orders = topological_sort(g);\n\n    for (int i = 0; i < V; ++i) {\n        cout << topological_orders[i] << '\\n';\n    }\n    cout << flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\nusing namespace std;\nlist<int> L;    //??????????????????????????????????????????????????????????????????\nbool DAG_check = false;\n\nvoid visit(int n, vector<vector<int>>& graph, vector<int>& mark) {\n\tif (DAG_check == true) {\n\t\treturn;\n\t}\n\tif (mark[n] == 1) {\n\t\tDAG_check = true; return;\n\t}\n\telse {\n\t\tif (mark[n] == 0) {\n\t\t\tmark[n] = 1;\n\t\t\tfor (int i = 0; i < graph[n].size();i++) {\n\t\t\t\tvisit(graph[n][i], graph, mark);\n\t\t\t}\n\t\t\tmark[n] = 2;\n\t\t\tL.emplace_back(n);\n\t\t}\n\t}\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>> graph(V);\n\tvector<int> mark(V, 0); //????????????????????°    1???????????????????????????2??\\??\\??\\?????????\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tgraph[s].emplace_back(t);\n\t}\n\n\tfor (int i = 0; i < V;i++) {\n\t\tif (mark[i] == 0) {\n\t\t\tvisit(i, graph, mark);\n\t\t}\n\t}\n\n\t//List???????????????????´????????????????\n\tfor (auto i = L.rbegin(); i != L.rend(); i++) {\n\t\tcout << *i << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u)\n{\n  V[u] = true;\n  for (int i = 0; i < G[u].size(); i++)\n  {\n    int v = G[u][i];\n    if (!V[v])\n    {\n      dfs(v);\n    }\n  }\n  out.push_front(u);\n}\n\nint main()\n{\n  int s, t, M;\n  cin >> N >> M;\n  for (int i = 0; i < N; i++)\n  {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++)\n  {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  for (int i = 0; i < N; i++)\n  {\n    if (!V[i])\n    {\n      dfs(i);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++)\n  {\n    cout << *it << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct topological_sort{\n    vector<vector<int>> graph;\n    vector<bool> done;\n    vector<int> res;\n    topological_sort(vector<vector<int>> &graph):graph(graph),done(graph.size()){\n        //rep(i,0,v) topo_dfs(i);\n        for(int i=0; i<graph.size(); ++i) dfs(i);\n        reverse(res.begin(),res.end());\n    }\n    void dfs(int v){\n        if(done[v]) return;\n        done[v]=true;\n        for(auto &u:graph[v]) dfs(u);\n        res.push_back(v);\n    }\n};\n\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<int>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n    topological_sort ts(graph);\n    rep(i,0,v) cout << ts.res[i] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size; i++ ) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v] ) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for ( int i = 0; i < N; i++ )\n    indeg[i] = 0;\n\n  for ( int u = 0; u < N; u++ )\n    for ( int i = 0; i < N; i++ ) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n\n  for ( int u = 0; u < N; u++ )\n    if ( indeg[u] == 0 && !V[u] ) bfs(u);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<list>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nint V[100000];\nlist<int> ut;\nint N;\n\nvoid dfs(int u){\n    V[u]=1;\n    for(int i=0;i<G[u].size();i++){\n        int v =G[u][i];\n        if(!V[v])dfs(v);\n    }\n    ut.push_front(u);\n}\n\nint main(){\n    int s,t,M;\n    cin>>N>>M;\n    for(int i=0;i<N;i++){\n        V[i]=0;\n    }\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    for(int i=0;i<N;i++){\n        if(!V[i])dfs(i);\n    }\n    for(list<int>::iterator it =ut.begin();it !=ut.end();it++){\n        cout<<*it<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 100000\nstatic const long long FAR = (1L << 31);\n\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nvector<int> G[N];\nvector<int> out;\nbool Visited[N];\nint n, m;\nint indeg[N];\n\nvoid bfs(int s){\n\tqueue<int>q; q.push(s);\n\tVisited[s] = true;\n\twhile (!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !Visited[v]){\n\t\t\t\tVisited[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int i = 0; i < n; ++i) indeg[i] = 0;\n\n\tfor (int u = 0; u < n; ++u){\n\t\tfor (int j = 0; j < G[u].size(); ++j){\n\t\t\tint v = G[u][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < n; ++u) if (indeg[u] == 0 && !Visited[u]) bfs(u);\n\tfor (int i = 0; i < out.size(); ++i) cout << out[i] << endl;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) Visited[i] = false;\n\tfor (int i = 0; i < m; ++i){\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define rrep(ri,n) for(int ri = (int)(n-1); ri >= 0; ri--)\n#define rep2(i,x,n) for(int i = (int)(x); i < (int)(n); i++)\n#define repit(itr,x) for(auto itr = x.begin(); itr != x.end(); itr++)\n#define rrepit(ritr,x) for(auto ritr = x.rbegin(); ritr != x.rend(); ritr++)\n#define ALL(x) x.begin(), x.end()\nusing ll = long long;\nusing namespace std;\n\nvoid bfs(vector<vector<int>> &gr, vector<bool> &chk, vector<int> &deg, vector<int> &ans, int i){\n  queue<int> q;\n  q.push(i);\n  chk.at(i) = true;\n  while(!q.empty()){\n    int now = q.front(); q.pop();\n    ans.push_back(now);\n    for(auto nx : gr.at(now)){\n      deg.at(nx)--;\n      if(deg.at(nx) == 0 && chk.at(nx) == false){\n        chk.at(nx) = true;\n        q.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  int v, e;\n  cin >> v >> e;\n  vector<int> deg(v, 0);\n  vector<vector<int>> gr(v, vector<int>());\n  rep(i, e){\n    int s, t;\n    cin >> s >> t;\n    gr.at(s).push_back(t);\n    gr.at(t).push_back(s);\n    deg.at(t)++;\n  }\n  vector<bool> chk(v, false);\n  vector<int> ans;\n  rep(i, v){\n    if(deg.at(i) == 0 && chk.at(i) == false){\n      bfs(gr, chk, deg, ans, i);\n    }\n  }\n\n  for(int i : ans){\n    cout << i << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*\n * 'from' depends 'to', which means 'to' must be done before 'from'.\n */\nclass Edge {\n    public:\n        int from;\n        int to;\n        int cost;\n};\n\nenum VisitStatus {\n    NOT_VISITED,\n    VISITING,\n    VISITED\n};\n\nvoid print_edges(const vector<vector<Edge> > &edges) {\n    for (int i = 0; i < (int) edges.size(); i++) {\n        cout << i << \": \";\n        for (int j = 0; j < (int) edges[i].size(); j++) {\n            cout << edges[i][j].to << \" \";\n        }\n        cout << endl;\n    }\n}\n\nconst int MAX_V = 10000;\nconst int MAX_E = 100000;\n\n/*\n * edges: edges represented by adjacent list\n * n: number of vertices\n * v: current verticle\n * sorted: sorted vertices\n */\nbool do_topological_sort(const vector<vector<Edge> > &edges, const int n, const int v, vector<VisitStatus> &visited, vector<int> &sorted) {\n    for (int i = 0; i < (int) edges[v].size(); i++) {\n        const Edge edge = edges[v][i];\n        if (visited[edge.to] == VISITING) {\n            // detect cyclization\n            return false;\n        } else if (visited[edge.to] == NOT_VISITED) {\n            visited[edge.to] = VISITING;\n            if (!do_topological_sort(edges, n, edge.to, visited, sorted)) {\n                return false;\n            }\n        }\n    }\n\n    sorted.push_back(v);\n    visited[v] = VISITED;\n    return true;\n}\n\n/*\n * Return false if the given graph is not DAG.\n *\n * Assume that ids of vertices starts from 0.\n */\nbool topological_sort(const vector<vector<Edge> > &edges, const int n, vector<VisitStatus> &visited, vector<int> &sorted) {\n    assert((int) visited.size() == n);\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i] != VISITED) {\n            visited[i] = VISITING;\n            if (!do_topological_sort(edges, n, i, visited, sorted)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/*\n * ref. http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n */\nint main(void) {\n    int v, e;\n    cin >> v >> e;\n\n    vector<vector<Edge> > edges(v);\n    vector<VisitStatus> visited(v);\n\n    for (int i = 0; i < e; i++) {\n        int s, t, cost;\n        cin >> s >> t;\n        cost = 1;\n        edges[t].push_back({t, s, cost});\n    }\n\n    // print_edges(edges);\n\n    vector<int> answer;\n    if (!topological_sort(edges, v, visited, answer)) {\n        cerr << \"Failed to perform topological sort due to cyclization\" << endl;\n        return 1;\n    }\n\n    for (int i = 0; i < (int) answer.size(); i++) {\n        cout << answer[i] << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nclass node {\npublic:\n\tint d = -1, f = -1;\n\tvector<int> v;\n};\n\nint cnt = 1;\nvector<int> A;\nnode V[10001];\n\nvoid Serch(int u) {\n\tV[u].d = cnt; cnt++;\n\n\tfor (int i = 0; i < V[u].v.size(); i++) {\n\t\tif (V[V[u].v[i]].d < 0) {\n\t\t\tSerch(V[u].v[i]);\n\t\t}\n\t}\n\n\tV[u].f = cnt; cnt++; A.push_back(u);\n}\n\nint main() {\n\tint v, e, s, t;\n\tscanf(\"%d %d\", &v, &e);\n\tfor (int i = 0; i < e; i++) {\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tV[s].v.push_back(t);\n\t}\n\n\tfor (int i = 0; i < v; i++) {\n\t\tif (V[i].d < 0) Serch(i);\n\t}\n\n\tfor (int i = v-1; i  >= 0; i--) cout << A[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint A[10000][10000],indeg[10000];\nint s,t,V,E;\nbool flag[10000]={false};\nqueue<int> Q;\nvector<int> ans;\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid bfs(int a){\n    Q.push(a);\n    flag[a]=true;\n\n    while(!Q.empty()){\n        int u=Q.front();\n        Q.pop();\n        ans.push_back(u);\n\n        for(int i=0;i<V;++i){\n            if(A[u][i]!=0){\n                --indeg[i];\n                if(indeg[i]==0 && flag[i]==false){\n                    flag[i]=true;\n                    Q.push(i);\n                }\n            }\n        }\n    }\n\n}\n\nvoid tp_srt(){\n    cin>>V>>E;\n\n    Fill(A,0);\n    Fill(flag,false);\n\n    \n    for(int i=0;i<E;++i){\n        cin>>s>>t;\n        A[s][t]=1;\n    }\n    \n    for(int i=0;i<V;++i){\n        indeg[i]=0;\n        for(int j=0;j<V;++j){\n            indeg[i]+=A[j][i];\n        }\n    }\n    \n    for(int i=0;i<V;++i){\n        if(indeg[i]==0 && flag[i]==false){\n            bfs(i);\n        }\n    }\n}\n\nint main(){\n    \n    tp_srt();\n\n    for(int i=0;i<ans.size();++i){\n        cout<<ans[i]<<\"\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tvector<int> order;\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\ttopologicalSort(g,order);\n\t\tfor(i=0;i<V;i++){\n\t\t\tprintf(\"%d\\n\",order[i]+1);\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 0);\n\n    for (int i = 0; i < E; i++) {\n        state[edge[i].second]++;\n    }\n    for (int i = 0; i < state.size(); i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < edge.size(); j++) {\n            if (edge[j].first != ans[i]) continue;\n            state[edge[j].second]--;\n            if (state[edge[j].second] == 0) {\n                ans.push_back(edge[j].second);\n            }\n            edge[j] = edge.back();\n            edge.pop_back();\n            j--;\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    int V,E;\n    cin >> V >> E;\n    vector<int> s(E);\n    vector<int> t(E);\n    vector<int> res;\n    vector< vector<int> > v(V);\n    vector< vector<int> > rv(V);\n    vector<bool> used(V,false);\n    int count = 0;\n\n    REP(i,E) scanf(\"%d%d\",&s[i],&t[i]);\n    REP(i,E) v[s[i]].PB(t[i]);\n    REP(i,E) rv[t[i]].PB(s[i]);\n    REP(i,V){\n\tREP(j,V){\n\t    if(used[j]) continue;\n\t    if(rv[j].size() == 0){\n\t\tres.PB(j);\n\t\tused[j] = true;\n\t\tint size = v[j].size();\n\t\tREP(k,size) rv[v[j][k]].erase(rv[v[j][k]].begin());\n\t\tfill(ALL(v[j]),0);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    REP(i,V) cout << res[i] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector< vector<int> > G(10001);\nqueue<int> que;\nint n_v, n_e, u, v;\nint in_degree[10001], ans[10001], idx;\n\n\nint main(){\n\n    memset(in_degree, 0, sizeof(in_degree));\n    scanf(\"%d %d\", &n_v, &n_e);\n    for(int i=0; i<n_e; i++){\n        scanf(\"%d %d\", &u, &v);\n        G[u].push_back(v);\n        in_degree[v] += 1;\n    }\n\n    idx = 0;\n    for(int i=0; i<n_v; i++) \n        if(in_degree[i]==0){\n            ans[idx++] = i;\n            que.push(i);     \n        }\n\n    while(!que.empty()){\n        u = que.front();\n        que.pop();\n        for(int i=0; i<G[u].size(); i++){\n            v = G[u][i];\n            in_degree[v] -= 1;\n            if(in_degree[v]==0){\n                ans[idx++] = v;\n                que.push(v);\n            }\n        }\n    }\n    for(int i=0; i<n_v; i++)\n        printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\nconst int MAXV = 10000;\nconst int MAXE = 100000;\n\nint indeg[MAXV];\nbool used[MAXV];\nvector<int> G[MAXV];\nvector<int> out;\n\nvoid bfs(int start) {\n  queue<int> q;\n  q.push(start);\n  used[start] = true;\n  while (!q.empty()) {\n    int cur = q.front(); q.pop();\n    out.push_back(cur);\n    for (int i = 0; i < G[cur].size(); ++i) {\n      int v = G[cur][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !used[v]) {\n\tused[v] = true;\n\tq.push(v);\n      }\n    }\n  }  \n}\n\nvoid topological_sort(int n) {\n  for (int i = 0; i < n; ++i) indeg[i] = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < G[i].size(); ++j) {\n      int v = G[i][j];\n      indeg[v]++;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (indeg[i] == 0 && !used[i]) bfs(i);\n  }\n}\n\nint main() {\n  int v, e;\n  scanf(\"%d %d\", &v, &e);\n  for (int i = 0; i < e; ++i) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    G[s].push_back(t);\n  }\n\n  for (int i = 0; i < v; ++i) used[i] = false;\n  topological_sort(v);\n  for (size_t i = 0; i < out.size(); ++i) {\n    printf(\"%d\\n\", out[i]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <regex>\nusing namespace std;\nusing pii  = pair<int,int>;\nusing ll=long long;\nusing ld=long double;\n#define pb push_back\n#define mp make_pair\n#define stpr setprecision\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define Rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define rRep(i,a,b) for(int i=a;i>=b;i--)\n#define crep(i) for(char i='a';i<='z';++i)\n#define psortsecond(A,N) sort(A,A+N,[](const pii &a, const pii &b){return a.second<b.second;});\n#define ALL(x) (x).begin(),(x).end()\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define endl '\\n'\nint ctoi(const char c){\n  if('0' <= c && c <= '9') return (c-'0');\n  return -1;\n}\nll gcd(ll a,ll b){return (b == 0 ? a : gcd(b, a%b));}\nll lcm(ll a,ll b){return a*b/gcd(a,b);}\nconstexpr ll MOD=1000000007;\nconstexpr ll INF=1000000011;\nconstexpr ll MOD2=998244353;\nconstexpr ll LINF = 1001002003004005006ll;\nconstexpr ld EPS=10e-8;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename T> istream& operator>>(istream& is,vector<T>& v){for(auto&& x:v)is >> x;return is;}\ntemplate<typename T,typename U> istream& operator>>(istream& is, pair<T,U>& p){ is >> p.first; is >> p.second; return is;}\ntemplate<typename T,typename U> ostream& operator>>(ostream& os, const pair<T,U>& p){ os << p.first << ' ' << p.second; return os;}\ntemplate<class T> ostream& operator<<(ostream& os, vector<T>& v){\n    for(auto i=begin(v); i != end(v); ++i){\n        if(i !=begin(v)) os << ' ';\n        os << *i;\n    }\n    return os;\n}\n\nvector<vector<ll>> E(10007);  //各点の持つ子の情報\nll color[10007];              //訪れ所の\nbool B[100007];\nlist<ll> out;                 //トポロジカルソート済みの配列を入れる\nll N,M,a,b;                   //N:頂点数　M:エッジ数\nll indeg[100007];             //各点の入次数。訪問した回数だけ減っていく。\n\nvoid bfs(ll s){\n    queue<ll> Q;\n    Q.push(s);\n    B[s]=true;\n    while(!Q.empty()){\n        ll u=Q.front();\n        Q.pop();\n        out.pb(u);\n        rep(i,E[u].size()){\n            ll v=E[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !B[v]){\n                B[v]=true;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nvoid topological_sort(){\n    rep(i,N){     // 初期化\n        indeg[i]=0;\n    }\n    rep(i,N){\n        rep(j,E[i].size()){    //  入次数を持たせる\n            indeg[E[i][j]]++;\n        }\n    }\n\n    rep(i,N){\n        if(indeg[i]==0 && !B[i]){\n            bfs(i);\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    rep(i,N){\n        B[i]=false;\n    }\n    rep(i,M){\n        cin >> a >> b;\n        E[a].pb(b);\n    }\n\n    topological_sort();\n\n    for(list<ll> :: iterator it=out.begin();it != out.end();it++){  // 出力\n        cout << *it << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 10010\ntypedef vector<int> Vec;\n\nint V,E;\nVec G[MAX_V];\n\nbool visit(int v,Vec &order,Vec &color){\n    color[v] = 1;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(color[to] == 2) continue;\n        if(color[to] == 1) return false;\n        if(!visit(to,order,color)) return false;\n    }\n    order.push_back(v);\n    color[v] = 2;\n    return true;\n}\n\nbool topologicalSort(Vec &order){\n    Vec color(V,0);\n    for(int i = 0 ; i < V ; i++){\n        if(color[i] == 0 && !visit(i,order,color)){\n            return false;\n        }\n    }\n    reverse(order.begin(),order.end());\n    return true;\n}\n\nint main(){\n    int s,t;\n    cin >> V >> E;\n    for(int i = 0 ; i < E ; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    Vec order;\n    if(topologicalSort(order)){\n        for(int i = 0 ; i < V ; i++){\n            cout << order[i] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\nstatic const int WHITE = 0;\nstatic const int BLACK  =2;\n\nvector<int> G[MAX];                     //隣接リスト G[i]にはi番目の頂点から向かう頂点が格納されている\nint colors[MAX] = {WHITE};              //色\nint inDegrees[MAX] = {0};               //入次数\nlist<int> orders;                        //頂点の順番格納\n\nvoid bfs(int v);\n\n//トポロジカルソート\nvoid topologicalSort(int vNumber){\n\n    //色と入次数の初期化\n    for(int i=0;i<vNumber;i++){\n        colors[i] = WHITE;\n        inDegrees[i] = 0;\n    }\n\n    //inDegreeをそれぞれ格納\n    for(int i=0;i<vNumber;i++){\n        for(int j=0;j<G[i].size();j++){\n            int v = G[i][j];\n            inDegrees[v]++;\n        }\n    }\n\n\n    //各頂点から行う\n    for(int i=0;i<vNumber;i++){\n\n        //すでに順番が決まっていない\n        //かつ、入次数がゼロの場合\n        if(colors[i] != BLACK  &&  inDegrees[i]  == 0){\n            bfs(i);\n        }\n    }\n\n}\n\n//幅優先探索\nvoid bfs(int v){\n\n    //順番確定\n    colors[v] = BLACK;\n\n    //頂点vを含む集合の更新\n    queue<int> Q;\n    Q.push(v);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        orders.push_back(u);\n\n\n        for(int i=0;i<G[u].size();i++){\n            //辺の削除\n            int to = G[u][i];\n            inDegrees[to]--;\n\n            //uからの向かう頂点が浮いていた場合\n            if(inDegrees[to] == 0 && colors[to] !=BLACK){\n                colors[to] = BLACK;\n                Q.push(to);\n            }\n        }\n    }\n\n}\n\nvoid print(){\n    for(auto it=orders.begin(); it!= orders.end();it++){\n        printf(\"%d\\n\",*it);\n    }\n}\n\nint main() {\n\n    int V; scanf(\"%d\", &V);\n    int E; scanf(\"%d\", &E);\n\n    int s, t;\n    for(int i=0;i<E;i++){\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n    }\n\n    topologicalSort(V);\n\n    print();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    int g[n][n];\n    int f, t;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;j < n; j++)\n            g[i][j] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f][t] = 1;\n    }\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n\n    for (int i = 0; i < n; i++) {\n        int d = 0;\n        for (int j = 0; j < n; j++) {\n            if (g[j][i])\n                d++;\n        }\n\n        if (!d)\n            q.push(i);\n\n        mm[i] = d;\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        cout << v << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            if (g[v][i]) {\n                int e = mm[i]-1;\n                if (!e)\n                    q.push(i);\n\n                mm[i] = e;\n            }\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\n//****************************************\n// Graph template\n//****************************************\n\n// status of node\ntemplate <typename X>\nstruct Node{ \n  int idx;\n  int in;\n  int depth;\n  \n  Node() = default;\n\n  Node(int idx, int in, int depth) : idx(idx), in(in), depth(depth) {}\n\n  void Show() {\n    cout << idx  << \":\" << in << \":\" << depth << \"\\n\";\n  }\n  \n};\n\n// status of edge\ntemplate <typename X>\nstruct Edge{\n  int from;\n  int to;\n  X cost;\n\n  Edge() = default;\n\n  Edge(int from, int to, X cost) : from(from), to(to), cost(cost) {}\n};\n\ntemplate <typename X>\nclass Graph{\nprivate:\n  int n; // number of node\n  int m; // number of edge\n  vector<vector<Edge<X>>> edge; // edge\n  vector<Node<X>> node; \n  vector<Node<X>> tsort;\n  \npublic:\n  explicit Graph(int n) : n(n) {\n    edge.resize(n);\n  }\n\n  Graph(int n, int m, vector<int> from, vector<int> to) : n(n), m(m) {\n    edge.resize(n);\n    rep(i,m) {\n      add_edge(from[i], to[i]);\n      //      add_edge(to[i], from[i]);      \n    }\n  }\n  \n  Graph(int n, int m, vector<int> from, vector<int> to, vector<X> cost) : n(n), m(m) {\n    edge.resize(n);\n    rep(i,m) {\n      add_edge(from[i], to[i], cost[i]);\n      //      add_edge(to[i], from[i], cost[i]);      \n    }\n  }\n\n  void add_edge(int from, int to, X cost = 1) {\n    edge[from].emplace_back(from, to, cost);\n  }\n\n  void Init_node() {\n    rep(i,n) {\n      node.emplace_back(i, 0, 0);\n    }\n  }\n\n  void Tsort() {\n    Init_node();\n\n    rep(i,n) for(auto next: edge[i]) node[next.to].in++;\n\n    queue<Node<X>> q;\n    rep(i,n) if(node[i].in == 0) {\n      q.emplace(i, 0, 0);\n    }\n\n    while( !q.empty() ) {\n      Node<X> now = q.front(); q.pop();\n      int v = now.idx;\n      int depth = now.depth;\n      tsort.push_back(node[v]);\n      for(auto next: edge[v]) {\n\tint w = next.to;\n\tnode[w].in--;\n\tnode[w].depth = depth + 1;\n\tif(node[w].in == 0) {\n\t  q.emplace(w, 0, depth + 1);\n\t}\n      }\n    }\n  }\n\n  void Show() {\n    // rep(i,n) {\n    //   tsort[i].Show();\n    // }\n    rep(i,n) cout << tsort[i].idx << \"\\n\";\n  }\n  \n};\n\nint main()\n{\n  int n,m;cin >> n >> m;\n  vector<int> a(m), b(m);\n  rep(i,m) {\n    cin >> a[i] >> b[i];\n  }\n\n  Graph<int> gp(n, m, a, b);\n  gp.Tsort();\n  gp.Show();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <boost/format.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#define rep(i, n) repr((i), 0, (n))\n#define repr(i, a, t) reps((i), (a), (t), 1)\n#define reps(i, a, t, s) for (long long (i) = (a); (i) < (long long)(t); (i) += (s))\n#define rrep(i, n) rrepr((i), (n) - 1, 0)\n#define rrepr(i, a, t) rreps((i), (a), (t), 1)\n#define rreps(i, a, t, s) for (long long (i) = (a); (i) >= (long long)(t); (i) -= (s))\n#define each(v, c) for (auto &&(v) : (c))\n#define all(c) (c).begin(), (c).end()\nusing namespace std;\nnamespace mp = boost::multiprecision;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing ml = mp::cpp_int;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (v.empty()) return os << \"vector{}\";\n  os << \"vector{\" << *v.begin();\n  for (auto it = ++v.begin(); it != v.end(); ++it)\n    os << \", \" << *it;\n  return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> &s) {\n  if (s.empty()) return os << \"set{}\";\n  os << \"set{\" << *s.begin();\n  for (auto it = ++s.begin(); it != s.end(); ++it)\n    os << \", \" << *it;\n  return os << \"}\";\n}\ntemplate<typename S, typename T>\nostream &operator<<(ostream &os, const map<S, T> &m) {\n  if (m.empty()) return os << \"map{}\";\n  os << \"map{\" << (*m.begin()).first << \": \" << (*m.begin()).second;\n  for (auto it = ++m.begin(); it != m.end(); ++it)\n    os << \", \" << (*it).first << \": \" << (*it).second;\n  return os << \"}\";\n}\ntemplate<typename S, typename T>\nostream &operator<<(ostream &os, const pair<S, T> &p) {\n  return os << \"pair{\" << p.first << \", \" << p.second << \"}\";\n}\n\nvector<ll> topological_sort(const vector<vector<ll>> &graph) {\n  ll size = graph.size();\n\n  // 入次数\n  vector<ll> ins(size, 0);\n  each (vs, graph) {\n    each (v, vs) {\n      ins[v]++;\n    }\n  }\n\n  // 入次数がゼロのやつを集める\n  vector<ll> zeros;\n  rep (v, size) {\n    if (ins[v] == 0) {\n      zeros.push_back(v);\n    }\n  }\n\n  // ゼロのやつから追加してく\n  vector<ll> ret;\n  while (!zeros.empty()) {\n    ll v = zeros.back();\n    zeros.pop_back();\n    ret.push_back(v);\n    each (u, graph[v]) {\n      ins[u]--;\n      if (ins[u] == 0) {\n        zeros.push_back(u);\n      }\n    }\n  }\n  // 閉路があると入次数が絶対ゼロにならない\n  if (ret.size() != size) {\n    throw invalid_argument(\"閉路があります\");\n  }\n\n  return ret;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  ifstream ifs;\n  if (getenv(\"LOCAL\") != nullptr) {\n    ifs.open(\"src/_in.txt\");\n    cin.rdbuf(ifs.rdbuf());\n  }\n\n  ll V, E;\n  cin >> V >> E;\n  vector<ll> S(E), T(E);\n  rep (i, E) {\n    cin >> S[i] >> T[i];\n  }\n\n  vector<vector<ll>> graph(V, vector<ll>());\n  rep (i, E) {\n    graph[S[i]].push_back(T[i]);\n  }\n\n  vector<ll> ans = topological_sort(graph);\n  each (r, ans) {\n    cout << r << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_Kahn(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\nstd::vector<Vertex> Kahn(const Graph& G) {\n  std::vector<Vertex> order;\n  std::vector<int> indeg(G.size());\n  for(const auto& E: G) for(const auto& e: E) ++indeg[e.to];\n  std::queue<Vertex> q;\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] == 0) q.emplace(v);\n  while(!q.empty()) {\n    for(const auto& e: G[q.front()]) if(--indeg[e.to] == 0) q.emplace(e.to);\n    order.emplace_back(q.front());\n    q.pop();\n  }\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] != 0) return {};\n  return order;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back({s, t, 0});\n  }\n  for(auto v: Kahn(G)) cout << v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nvector<int> topo_sort(const graph& G) {\n\tint n = G.size();\n\tvector<int> used(n), idx; idx.reserve(n);\n\tfunction<void(int)> dfs = [&](int v) {\n\t\tused[v] = true;\n\t\tfor (int w : G[v]) if (!used[w]) dfs(w);\n\t\tidx.push_back(v);\n\t};\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (!used[i]) dfs(i);\n\t}\n\treverse(idx.begin(), idx.end());\n\treturn idx;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tgraph G(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\tauto ts = topo_sort(G);\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", ts[i]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\n\nconst long long int mod=1000000007;\nconst long long int INF=99999999999999999;\n\n\n//INFを宣言すること。Edgeに辺の情報を入れよう。\nclass Graph{\n//メンバ変数の説明\n//Edge:一つ目の番号が辺が出る方向\n//MaxV,MaxE:頂点数と辺の数\n//Result系:各メソッドの答え\n//InfinteUpdate:BellmanFordで各番号の頂点までの最短経路が更新されるか\n//\npublic:\n\tvector<pair<long long int,long long int> > *Edge;\n\tvector<pair<pair<long long int,long long int>,long long int> >PrimEdge;\n\tlong long int MaxV,MaxE;\n\tlong long int *BellmanFordResult,*DijkstraResult,**WarshallFloydResult;\n\tbool *InfiniteUpdate;\n\tbool NegativeLoop=false;\n\tlong long int PrimResult=0;\n\tbool NotConected=false;\n\tlong long int *InEdge;\n\tvector<long long int>TopologicalSortdVertex;\n\n\n\tGraph(long long int InputV,long long int InputE){\n\t\tMaxV=InputV;\n\t\tMaxE=InputE;\n\t\tEdge=new vector<pair<long long int,long long int> >[InputV+1];\n\n\t}\n\t\n\tvoid BellmanFord(long long int Start) {\n\t\tBellmanFordResult=new long long int[MaxV];\n\t\tInfiniteUpdate=new bool[MaxV];\n\t\tfor (int i = 0; i < MaxV; i++) { BellmanFordResult[i] = INF;InfiniteUpdate[i]=false; }\n\t\tBellmanFordResult[Start] = 0;\n\t\tlong long int turn=0;\n\t\twhile (true) {\n\t\t\tturn++;\n\t\t\tbool update = false;\n\t\t\tfor (int i = 0; i < MaxV; i++) {\n\t\t\t\tfor(int j=0;j<Edge[i].size();j++){\n\t\t\t\t\tpair<long long int,long long int> e = Edge[i][j];\n\t\t\t\t\tif(turn>=MaxV&&InfiniteUpdate[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tInfiniteUpdate[e.first]=true;\n\t\t\t\t\t}\n\t\t\t\t\tif (BellmanFordResult[i] != INF && BellmanFordResult[e.first] > BellmanFordResult[i] + e.second) {\n\t\t\t\t\t\tBellmanFordResult[e.first] = BellmanFordResult[i] + e.second;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\tif(turn>=MaxV){\n\t\t\t\t\t\t\tInfiniteUpdate[e.first]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) { \n\t\t\t\tNegativeLoop=false;\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tif(turn>=2*MaxV-1){\n\t\t\t\tNegativeLoop=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid Dijkstra(long long int Start) {\n\t\tDijkstraResult=new long long int[MaxV];\n\t\tpriority_queue<pair<long long int,long long int>, vector<pair<long long int,long long int> >, greater<pair<long long int,long long int> > >que;\n\t\tfill(DijkstraResult, DijkstraResult + MaxV, INF);\n\t\tDijkstraResult[Start] = 0;\n\t\tque.push(pair<long long int,long long int>(0, Start));\n\n\t\twhile (!que.empty()) {\n\t\t\tpair<long long int,long long int> p = que.top();\n\t\t\tque.pop();\n\t\t\tlong long int v = p.second;\n\t\t\tif (DijkstraResult[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < Edge[v].size(); i++) {\n\t\t\t\tpair<long long int,long long int> e = Edge[v][i];\n\t\t\t\tif (DijkstraResult[e.first] > DijkstraResult[v] + e.second) {\n\t\t\t\t\tDijkstraResult[e.first] = DijkstraResult[v] + e.second;\n\t\t\t\t\tque.push(pair<long long int,long long int>(DijkstraResult[e.first], e.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid WarshallFloyd() {\n\t\tWarshallFloydResult=new long long int*[MaxV];\n\t\tfor(int i=0;i<MaxV;i++){\n\t\t\tWarshallFloydResult[i]=new long long int[MaxV];\n\t\t}\n\t\tfor(int i=0;i<MaxV;i++){\n\t\t\tfor(int j=0;j<Edge[i].size();j++){\n\t\t\t\tWarshallFloydResult[i][Edge[i][j].first]=Edge[i][j].second;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < MaxV; k++) {\n\t\t\tfor (int i = 0; i < MaxV; i++) {\n\t\t\t\tfor (int j = 0; j < MaxV; j++) {\n\t\t\t\t\tWarshallFloydResult[i][j] = min(WarshallFloydResult[i][j], WarshallFloydResult[i][k] + WarshallFloydResult[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid Prim(){\n\t\tNotConected=false;\n\t\tpriority_queue<pair<long long int,pair<long long int,long long int> >,vector<pair<long long int,pair<long long int,long long int> > > ,greater<pair<long long int,pair<long long int,long long int> > > >PriorityEdge;\n\t\tbool *IncludedVertex=new bool[MaxV];\n\t\tfill(IncludedVertex,IncludedVertex+MaxV,false);\n\t\tPrimEdge.clear();\n\t\tfor(int i=0;i<Edge[0].size();i++)\n\t\t{\n\t\t\tPriorityEdge.push({Edge[0][i].second,{0,Edge[0][i].first}});\n\t\t}\n\t\tIncludedVertex[0]=true;\n\t\tfor(int i=0;i<MaxV-1;i++)\n\t\t{\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(PriorityEdge.empty())\n\t\t\t\t{\n\t\t\t\t\tNotConected=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpair<long long int,pair<long long int,long long int> > pe = PriorityEdge.top();\n\t\t\t\tPriorityEdge.pop();\n\t\t\t\t//cout<<pe.first<<\" \"<<pe.second.first<<\" \"<<pe.second.second<<endl;\n\t\t\t\tif(!IncludedVertex[pe.second.second])\n\t\t\t\t{\n\t\t\t\t\tIncludedVertex[pe.second.second]=true;\n\t\t\t\t\tPrimResult+=pe.first;\n\t\t\t\t\tPrimEdge.push_back({pe.second,pe.first});\n\t\t\t\t\t//cout<<\"size\"<<pe.second.second<<\" \"<<Edge[pe.second.second].size()<<endl;\n\t\t\t\t\tfor(int j=0;j<Edge[pe.second.second].size();j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tPriorityEdge.push({Edge[pe.second.second][j].second,{pe.second.second,Edge[pe.second.second][j].first}});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvoid TopologicalSort(){\n\t\tbool notupdate=false;\n\t\tInEdge=new long long int[MaxV];\n\t\tTopologicalSortdVertex.clear();\n\t\tqueue<long long int>task,firsttask;\n\t\tfor(int i=0;i<MaxV;i++){\n\t\t\tInEdge[i]=0;\n\t\t}\n\t\tfor(int i=0;i<MaxV;i++){\n\t\t\tfor(int j=0;j<Edge[i].size();j++){\n\t\t\t\tInEdge[Edge[i][j].first]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<MaxV;i++){\n\t\t\tif(InEdge[i]==0){\n\t\t\t\tfirsttask.push(i);\n\t\t\t}\n\n\t\t}\n\t\twhile(!firsttask.empty()){\n\t\t\tlong long int i=firsttask.front();\n\t\t\tfirsttask.pop();\n\t\t\tTopologicalSortdVertex.push_back(i);\t\t\t\n\t\t\tInEdge[i]=-1;\n\t\t\tfor(int j=0;j<Edge[i].size();j++){\n\t\t\t\tInEdge[Edge[i][j].first]--;\n\t\t\t\tif(InEdge[Edge[i][j].first]==0){\n\t\t\t\t\ttask.push(Edge[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\twhile(!task.empty()){\n\t\t\tlong long int tmp=task.front();\n\t\t\t//cout<<\"Debug: \"<<tmp<<endl;\n\t\t\tfor(int i=0;i<MaxV;i++){\n\t\t\t\t//cout<<\"InEdge: \"<<i<<\" \"<<InEdge[i]<<endl;\n\t\t\t}\n\t\t\t\n\t\t\tTopologicalSortdVertex.push_back(tmp);\n\t\t\ttask.pop();\n\t\t\tif(InEdge[tmp]==0){\n\t\t\t\tInEdge[tmp]=-1;\n\t\t\t\tfor(int j=0;j<Edge[tmp].size();j++){\n\t\t\t\t\tInEdge[Edge[tmp][j].first]--;\n\t\t\t\t\tif(InEdge[Edge[tmp][j].first]==0){\n\t\t\t\t\t\ttask.push(Edge[tmp][j].first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n};\n\n\n\nint main() {\n    long long int N,M;\n\t//cout << fixed << setprecision(10);\n\tcin>>N>>M;\n\tGraph graph(N,M);\n\tfor(int i=0;i<M;i++){\n\t\tlong long int A,B;\n\t\tcin>>A>>B;\n\t\tgraph.Edge[A].push_back({B,1});\n\t}\n\tgraph.TopologicalSort();\n\tfor(int i=0;i<graph.TopologicalSortdVertex.size();i++){\n\t\tcout<<graph.TopologicalSortdVertex[i]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define inf (int)(1e9+7)\n#define mod (ll)(1e9+7)\n#define eb emplace_back\n\nint table[10007];\nint main() {\n    fill_n(table, 10007, inf);\n    int V, E; cin >> V >> E;\n    if (E == 0) {rep(i, V) cout << i << endl; return 0;}\n    vector<int> v[V];\n    rep(i, E) {\n        int s, t; cin >> s >> t;\n        v[t].eb(s);\n    }\n    vector<int> ans;\n    int c = 0;\n    rep(i, V) if (v[i].size() == 0) {table[i] = 1; ans.eb(i); c++;}\n    while (1) {\n        int wflg = 0;\n        int flg = 0;\n        rep(k, V) {\n            //cout << \"k \" << k << endl;\n            if (table[k] != inf) continue;\n            flg = 0;\n            rep(i, v[k].size()) {\n                int bef = v[k][i];\n                if (table[bef] == inf) {flg = 1; break;}\n            }\n            if (flg) continue;\n            ans.eb(k);\n            table[k] = 1;\n            c++;\n            if (c == V) {wflg = 1; break;}\n        }\n        //cout << \"wflg \" << wflg << endl;\n        if (wflg) break;\n    }\n    rep(i, V) cout << ans[i] << endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> graph[100003];\nvector <int> ans;\nqueue <int >q;\n\nint node,edge;\nint indegree[100003];\nbool del[100003], flag=1;\n\nvoid topologicalSort(){\n    for(int i=0; i<node; i++){\n        if(indegree[i]==0) q.push(i);\n    }\n\n    while(!q.empty()){\n        int u=q.front();\n        del[u]=1;\n        q.pop();\n        ans.push_back(u);\n\n        int len=graph[u].size();\n        for(int i=0; i<len; i++){\n            int v=graph[u][i];\n            if(del[v]) flag=0;\n\n            if(indegree[v]>0){\n                indegree[v]--;\n                if(indegree[v]==0) q.push(v);\n            }\n        }\n    }\n}\n\nvoid print(){\n    int len=ans.size();\n    for(int i=0; i<len; i++){\n        cout<<ans[i]<<endl;\n    }\n}\n\nint main(){\n    cin>>node>>edge;\n\n    for(int i=0; i<edge; i++){\n        int u,v;\n        cin>>u>>v;\n\n        graph[u].push_back(v);\n        indegree[v]++;\n    }\n\n    topologicalSort();\n    print();\n\n//    if(ans.size()==node && flag) print();\n//    else cout<<\"-1\"<<endl;\n    return 0;\n}\n\n/*\n\n6 6\n0 1\n1 2\n3 1\n3 4\n4 5\n5 2\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define V_MAX 10000\n#define WHITE 1\n#define BLACK 2\n\nvector<int> G[V_MAX];\nint indig[V_MAX];\nint V_color[V_MAX];\n\nvector<int> l;\n\nvoid init(){\n    for(int i = 0; i < V_MAX; i++){\n        indig[i] = 0;\n        V_color[i] = WHITE;\n    }\n}\n\nvoid tpsort(int num){\n    queue<int> Q;\n    Q.push(num);\n    int target;\n\n    while(!Q.empty()){\n        target = Q.front(); Q.pop();\n        V_color[target] = BLACK;\n        l.push_back(target);\n        for(int i = 0; i < G[target].size(); i++){\n            indig[G[target][i]]--;\n            if(indig[G[target][i]] == 0){\n                Q.push(G[target][i]);\n            }\n        }\n    }\n}\n\nint main(void){\n    init();\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n\n    for(int i = 0; i < E; i++){\n        int s, t, d;\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n        indig[t]++;\n    }\n\n    for(int i = 0; i < V; i++){\n        if(indig[i] == 0 && V_color[i] == WHITE){\n            tpsort(i);\n        }\n    }\n\n    for(int i = 0; i < l.size(); i++){\n        printf(\"%d\\n\", l[i]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<list>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=100000;\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint n;\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0 && !V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(){\n  for(int i=0;i<n;i++) indeg[i]=0;\n  for(int u=0;u<n;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n  for(int u=0;u<n;u++){\n    if(indeg[u]==0 && !V[u]) bfs(u);\n  }\n  for(list<int>::iterator it=out.begin();it!=out.end();it++){\n    cout<<*it<<endl;\n  }\n}\nint main(){\n  int s,t,m;\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++) V[i]=false;\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d\",&s,&t);\n    G[s].push_back(t);\n  }\n  tsort();\n  return 0;\n}\n   \n  \n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,N) for(int i = 0;i < N;i++)\n#define pb push_back\n\nint main()\n{\n  vector<int>E[10005];\n  int flag[10005] = {0};\n  int indeg[10005] = {0};\n  vector<int>out;\n  int N,M,s,t;\n  cin >> N >> M;\n  while(M--) {\n    cin >> s >> t;\n    E[s].pb(t);\n  }\n  Rep(i,N) {\n    Rep(j,E[i].size()) {\n      int v = E[i][j];\n      indeg[v]++;\n    }\n  }\n  Rep(p,N) {\n    if(!flag[p] && indeg[p] == 0) {\n      \n      queue<int>que;\n      que.push(p);\n      flag[p] = true;\n      while(!que.empty()) {\n\tint v = que.front(); que.pop();\n\tout.pb(v);\n\tRep(i,E[v].size()) {\n\t  int nv = E[v][i];\n\t  indeg[nv]--;\n\t  if(indeg[nv] == 0 && !flag[nv]) {\n\t    flag[nv] = true;\n\t    que.push(nv);\n\t  }\n\t}\n      }\n      \n    }\n  }\n  Rep(i,N) {\n    cout << out[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\n\nusing namespace std;\nstatic const int MAX=100000;\n\nvector<int> G[MAX];\nlist<int> result;\nint n;\nint indeg[MAX]; //??????????????\\???\nbool Visited[MAX];\n\nvoid bfs(int s)\n{\n    queue<int> Q;\n    Q.push(s); //???????????\\???\n    Visited[s]=true;\n    while(!Q.empty())\n    {\n        int u=Q.front(); Q.pop();\n        //enqueue\n        result.push_back(u); //??¨???bfs????????????????°±??????????????????\n        //trav\n        for(int i=0;i<G[u].size();i++)\n        {\n            int v=G[u][i];\n            indeg[v]--; //??\\?????????\n            if(indeg[v]==0&&!Visited[v])  //????¬??°???\\??????0??????????????\\????????????\n            {\n                Visited[v]=true;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort()\n{\n    //init\n    for(int i=0;i<n;i++)\n        indeg[i]=0;\n    //count the indeg of every node\n    for(int i=0;i<n;i++)\n        for(int j=0;j<G[i].size();j++)\n            indeg[G[i][j]]++;\n    //begin bfs\n    for(int i=0;i<n;i++)\n        if(indeg[i]==0&&!Visited[i]) bfs(i); //??\\??????0??????????????????????????????bfs??????\n    //print\n    for(list<int>::iterator it=result.begin();it!=result.end();it++)\n        cout<<*it<<endl;\n}\nint main()\n{\n    int e;\n    cin>>n>>e;\n    //init\n    for(int i=0;i<n;i++) Visited[i]=false;\n\n    int s,t;\n    for(int i=0;i<e;i++)\n    {\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n\n    //begin tsort\n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kNil = -1;\n\nenum class Color {\n  kWhite,\n  kGrey,\n  kBlack,\n};\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\nvoid DFSVisitTopological(const typename vector<Edge>::size_type node_now,\n       typename vector<Edge>::size_type & time,\n       const vector<vector<Edge>> & adjacency_list,\n       vector<int> & d,\n       vector<int> & f,\n       vector<Color> & color,\n       vector<int> & parent,\n       stack<int> & stk) {\n  color[node_now] = Color::kGrey;\n  d[node_now] = time++;\n  for (const auto & e: adjacency_list[node_now]) {\n    if (color[e.v] == Color::kWhite) {\n      parent[e.v] = node_now;\n      DFSVisitTopological(e.v, time, adjacency_list, d, f, color, parent, stk);\n    }\n  }\n  color[node_now] = Color::kBlack;\n  f[node_now] = time++;\n  stk.push(node_now);\n}\n\ntemplate <class Edge>\ndecltype(auto) DFSTopological(const vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n\n  vector<vector<Edge>> adjacency_list(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency_list[e.u].push_back(e);\n  }\n\n  vector<int> d(node_num);\n  vector<int> f(node_num);\n  vector<Color> color(node_num, Color::kWhite);\n  vector<int> parent(node_num);\n  stack<int> stk;\n  size_type time = 0;\n\n  for (unsigned i = 0; i < node_num; ++i) {\n    if (color[i] == Color::kWhite) {\n      DFSVisitTopological(i, time, adjacency_list, d, f, color, parent, stk);\n    }\n  }\n\n  return stk;\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = unsigned;\n\n  vector<Edge<w_type>> edges;\n  unsigned V, E;\n  cin >> V >> E;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    w_type w;\n    cin >> u >> v;\n    edges.emplace_back(u, v, 1);\n  }\n\n  auto result = DFSTopological(edges, V);\n  while (!result.empty()) {\n    auto e = result.top();\n    result.pop();\n    cout << e << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\nusing namespace std;\n\nstruct SCC{\n    vector<vector<int> > g,rg;\n    vector<int> vs,cmp,used;\n    SCC(int v):g(v),rg(v),cmp(v,-1),used(v,0){}\n    \n    void add_edge(int src,int dst){\n        g[src].pb(dst);\n        rg[dst].pb(src);\n    }\n    void dfs(int v){\n        used[v]=true;\n        rep(i,g[v].size()){\n            if(!used[g[v][i]]) dfs(g[v][i]);\n        }\n        vs.pb(v);\n    }\n    void rdfs(int v,int k){\n        used[v]=true;\n        cmp[v]=k;\n        rep(i,rg[v].size()){\n            if(!used[rg[v][i]]) rdfs(rg[v][i],k);\n        }\n    }\n    int scc(){\n        fill(used.begin(),used.end(),0);\n        vs.clear();\n        rep(i,used.size()){\n            if(!used[i]) dfs(i);\n        }\n        fill(used.begin(),used.end(),0);\n        int k=0;\n        for(int i=vs.size()-1;i>=0;--i){\n            if(!used[vs[i]]) rdfs(vs[i],k++);\n        }\n        return k;\n    }\n};\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    SCC scc(v);\n    int s,t;\n    rep(i,e){\n        cin>>s>>t;\n        scc.add_edge(s,t);\n    }\n    int k=scc.scc();\n    vector<int> ans(v);\n    if(v==k){\n        rep(i,v) ans[scc.cmp[i]]=i;\n        rep(i,v) cout<<ans[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n    std::vector<std::vector<int>> edges(V);\n    std::vector<int> cnts(V, 0);\n    while(E--) {\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n        ++cnts[t];\n    }\n\n    std::queue<int> que;\n    for(int i = 0; i < V; ++i) {\n        if(cnts[i] == 0) que.push(i);\n    }\n\n    std::vector<int> ans;\n    ans.reserve(V);\n    while(!que.empty()) {\n        auto v = que.front();\n        que.pop();\n        ans.push_back(v);\n        for(auto u: edges[v]) {\n            --cnts[u];\n            if(cnts[u] == 0) que.push(u);\n        }\n    }\n\n    for(auto val: ans)\n        std::cout << val << \"\\n\";\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*トポロジカルソート*/\n#include<iostream>\n#include<vector>\n#include<queue>\n\nusing Graph = std::vector<std::vector<size_t>>;\n\nint main(){\n    \n    size_t v, e;\n    std::cin >> v >> e;\n\n    Graph g(v);\n    std::vector<size_t> in(v, 0);\n\n    for(size_t i = 0; i < e; i++){\n        size_t s, t;\n        std::cin >> s >> t;\n\n        g.at(s).emplace_back(t);\n        in.at(t)++;\n    }\n\n    std::queue<size_t> set;\n\n    for(size_t i = 0; i < in.size(); i++){\n        if(in.at(i) == 0) set.emplace(i);\n    }\n\n    std::vector<size_t> ans;\n\n    while(!set.empty()){\n        auto vertex = set.front(); set.pop();\n        ans.emplace_back(vertex);\n\n        for(const auto& e : g.at(vertex)){\n            in.at(e)--;\n            if(in.at(e) == 0) set.emplace(e);\n        }\n    }\n\n    for(const auto& e : ans){\n        std::cout << e << std::endl;\n    }\n    \n    return 0;\n}\n\n/*\nfor(size_t i = 0; i < v; i++){\n    std::cout << \"in size: \" << in.at(i) << \", out vertex: \";\n    for(size_t j = 0; j < g.at(i).size(); j++){\n        std::cout << g.at(i).at(j) << \", \";\n    }std::cout << std::endl;\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\nconstexpr int INF = 2147483647;\nconstexpr long long int INF_LL = 9223372036854775807;\nconstexpr int MOD = 1000000007;\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\nstruct edge {\n\tll to;\n\tll cost;\n};\n\nvoid toposo_(vector<vector<edge>>& g, vector<int>& used, vector<int>& l, int pos) {\n\tif (!used[pos]) {\n\t\tused[pos] = 1;\n\t\tfor (int i = 0; i < g[pos].size(); i++) {\n\t\t\ttoposo_(g, used, l, g[pos][i].to);\n\t\t}\n\t\tl.push_back(pos);\n\t}\n}\nvector<int> toposo(vector<vector<edge>>& g) {\n\tvector<int> u(g.size(),0), ret;\n\tfor (int i = 0; i < g.size(); i++)toposo_(g, u, ret, i);\n\treverse(ret.begin(), ret.end());\n\treturn ret;\n}\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<edge>> g(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back({ b,1 });\n\t}\n\tauto c = toposo(g);\n\n\tfor (int i = 0; i < c.size(); i++)cout << c[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    int g[n][n];\n    int f, t;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;j < n; j++)\n            g[i][j] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f][t] = 1;\n    }\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n\n    for (int i = 0; i < n; i++) {\n        int d = 0;\n        for (int j = 0; j < n; j++) {\n            if (g[j][i])\n                d++;\n        }\n\n        if (!d)\n            q.push(i);\n\n        mm[i] = d;\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        cout << v << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            if (g[v][i]) {\n                int e = mm[i]-1;\n                if (!e)\n                    q.push(i);\n\n                mm[i] = e;\n            }\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class Data> struct Graph;\n\nstruct DefData {\n  struct VData {};\n  struct GData {};\n\n  using Len = int;\n  struct EData {\n    Len len;\n    EData() : len(1) {}\n  };\n  static const Len INF = 0x33433433;\n};\n\ntemplate<class Data=DefData>\nstruct Graph {\n  using VData = typename Data::VData;\n  using EData = typename Data::EData;\n  using GData = typename Data::GData;\n  struct Edge {\n    int to;\n    int rev_idx;\n    bool is_es;\n    EData dat;\n  };\n  using Len = decltype(EData::len);\n  using Ls = vector<Len>;\n  using Es = vector<Edge>;\n  Len INF = Data::INF;\n\n  int n;\n  GData gdat;\n  vector<VData> vdat;\n  vector<Es> es;\n  vector<Es> res;\n  vector<Ls> cost;\n  \n  Graph() {}\n  Graph(int sz) {\n    Init(sz);\n  }\n\n  void Init(int sz) {\n    n = sz;\n    vdat.resize(sz);\n    es.resize(sz);\n    res.resize(sz);\n  }\n\n  void AddEdge(int u, int v, EData d, EData r) {\n    es[u].emplace_back(Edge{v, 0, true, d});\n    res[v].emplace_back(Edge{u, 0, false, r});\n    es[u].back().rev_idx = res[v].size()-1;\n    res[v].back().rev_idx = es[u].size()-1;\n  }\n\n  void AddEdge(int u, int v, EData d=EData()) {\n    AddEdge(u, v, d, d);\n  }\n\n  Edge *GetRevEdge(Edge *e) {\n    int v = e->to;\n    if (e->is_es) return &res[v][e->rev_idx];\n    return &es[v][e->rev_idx];\n  }\n\n  // should be tested\n  template<class Cmp>\n  void EraseMultipleEdge(Cmp cmp, bool really_erase) {\n    auto same = [](const Edge &a, const Edge &b) {\n      return a.to == b.to;\n    };\n\n    vector<Es> new_res(n);\n    for (int v=0; v<n; v++) {\n      auto &ves = es[v];\n      sort(ves.begin(), ves.end(), cmp);\n      auto itr = unique(ves.begin(), ves.end(), same);\n      if (really_erase) ves.erase(itr, ves.end());\n      for (int i=0; i<ves.size(); i++) {\n        auto &e = ves[i];\n        int u = e.to;\n        new_res[u].emplace_back(Edge{v, i, false, GetRevEdge(e)->dat});\n      }\n    }\n    res.swap(new_res);\n  }\n\n  void CreateAdjMat() {\n    cost.clear();\n    cost.resize(n, Ls(n, INF));\n\n    auto cmp = [](const Edge &a, const Edge &b) {\n      if (a.to != b.to) return a.to < b.to;\n      return a.dat.len < b.dat.len;\n    };\n    EraseMultipleEdge(cmp, false);\n\n    for (int i=0; i<n; i++) {\n      int prev = -1;\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (prev > v) break;\n        cost[i][v] = min(cost[i][v], e.dat.len);\n        prev = v;\n      }\n    }\n  }\n\n  void DijkstraV(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) d[s] = 0;\n\n    if (cost.empty()) CreateAdjMat();\n\n    vector<bool> used(n, false);\n    for (int i=0; i<n; i++) {\n      int v = -1;\n      for (int u=0; u<n; u++) {\n        if (used[u]) continue;\n        if (v == -1 || d[u] < d[v]) {\n          v = u;\n        }\n      }\n      if (v == -1) return;\n\n      used[v] = true;\n      for (int u=0; u<n; u++) {\n        d[u] = mind(d[u], d[v] + cost[v][u]);\n      }\n    }\n\n    // must not reach here\n    assert(0);\n  }\n\n  void DijkstraE(vector<int> &starts, Ls &d) {\n    using Pair = pair<Len, int>;\n    priority_queue<Pair, vector<Pair>, greater<Pair> > q;\n    d.clear();\n    d.resize(n, INF);\n    for (int s : starts) {\n      d[s] = 0;\n      q.push(Pair(0, s));\n    }\n\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (auto &e : es[v]) {\n        int u = e.to;\n        Len nd = d[v] + e.dat.len;\n        if (d[u] > nd) {\n          d[u] = nd;\n          q.push(Pair(nd, u));\n        }\n      }\n    }\n  }\n\n  // return true if the graph has a negative cycle\n  bool SPFA(vector<int> &starts, Ls &d) {\n    d.clear();\n    d.resize(n, INF);\n\n    if (n == 1) {\n      d[0] = 0;\n      return false;\n    }\n\n    queue<int> q;\n    vector<bool> inq(n);\n    vector<int> cnt(n);\n    for (int s : starts) {\n      inq[s] = true;\n      q.push(s);\n      d[s] = 0;\n    }\n\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      inq[v] = false;\n      cnt[v]++;\n      if (cnt[v] > n) continue;\n      for (auto &e : es[v]) {\n        int u = e.to;\n        Len nd = d[v] + e.dat.len;\n        if (d[u] > nd) {\n          d[u] = nd;\n          if (inq[u]) continue;\n          inq[u] = true;\n          q.push(u);\n        }\n      }\n    }\n\n    // do DFS if you need the concrete contents of such cycles\n    for (int i=0; i<n; i++) {\n      if (cnt[i] >= n) return true;\n    }\n\n    return false;\n  }\n\n  void DijkstraV(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraV(ss, d);\n  }\n\n  void DijkstraE(int s, Ls &d) {\n    vector<int> ss(1, s);\n    DijkstraE(ss, d);\n  }\n\n  bool SPFA(int s, Ls &d) {\n    vector<int> ss(1, s);\n    return SPFA(ss, d);\n  }\n\n  // Create \"Shortest Path Graph\", which should be DAG\n  Graph<Data> RestoreShortestPaths(Ls &d) {\n    Graph<Data> ret(n);\n\n    for (int i=0; i<n; i++) {\n      for (auto &e : es[i]) {\n        int v = e.to;\n        if (d[v] == d[i] + e.dat.len) {\n          ret.AddEdge(i, e.to, e.dat, GetRevEdge(&e)->dat);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  void WarshallFloyd(vector<Ls> &ds) {\n    if (cost.empty()) CreateAdjMat();\n\n    ds.clear();\n    ds.resize(cost);\n    for (int i=0; i<n; i++) {\n      ds[i][i] = min(ds[i][i], 0);\n    }\n\n    for (int k=0; k<n; k++) {\n      for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n          if (ds[i][j] > ds[i][k] + ds[k][j]) {\n            ds[i][j] = ds[i][k] + ds[k][j];\n          }\n        }\n      }\n    }\n  }\n\n  // Karp's Algorithm O(NM)\n  // should be tested\n  // should be used for SCC\n  double MinimumMeanCycle() {\n    vector<Ls> dp(n+1, Ls(n, INF));\n\n    dp[0][0] = 0;\n    for (int i=1; i<=n; i++) {\n      for (int v=0; v<n; v++) {\n        for (auto &e : es[v]) {\n          int u = e.to;\n          dp[i][u] = min(dp[i][u], dp[i-1][v] + e.dat.len);\n        }\n      }\n    }\n\n    double ret = 1.0/0.0;\n    for (int v=0; v<n; v++) {\n      double alpha = (-1.0)/0.0;\n      for (int i=1; i<n; i++) {\n        if (dp[n][v] == INF) continue;\n        if (dp[i][v] == INF) continue;\n        alpha = max(alpha, (dp[n][v]-dp[i][v])/double(n-i));\n      }\n      ret = min(ret, alpha);\n    }\n    return ret;\n  }\n};\n\ntemplate<class Data=DefData>\nstruct DFSForest {\n  using G = Graph<Data>;\n  using Edge = typename G::Edge;\n  using Brid = pair<int, Edge*>;\n\n  int grp;\n  vector<int> ord;\n  vector<int> low;\n  vector<int> belong;\n  vector<int> artic;\n  vector<Brid> bridge;\n\n  DFSForest(G &g, bool is_directed) {\n    int k = 0;\n    int idx = 0;\n    int n = g.n;\n    vector<int> st(n);\n\n    grp = 0;\n    ord.resize(n, -1);\n    low.resize(n);\n    belong.resize(n, -1);\n\n    function<void(int,int,Edge*)> dfs;\n    // to deal with multiple edges, it uses a pointer\n    auto update = [&](int v, Edge *e, bool &is_artic, int &cnt) {\n      int u = e->to;\n      if (ord[u] != -1) {\n        if (belong[u] == -1) low[v] = min(low[v], ord[u]);\n      } else {\n        cnt++;\n        dfs(u, v, e);\n        low[v] = min(low[v], low[u]);\n        if (ord[v] <= low[u]) is_artic = true;\n        if (ord[v] < low[u]) bridge.emplace_back(Brid(v, e));\n      }\n    };\n\n    dfs = [&](int v, int p, Edge *par) {\n      bool is_artic = false;\n      int cnt = 0;\n\n      st[idx++] = v;\n      low[v] = ord[v] = k++;\n\n      for (auto &e : g.es[v]) {\n        if (g.GetRevEdge(&e) == par) continue;\n        update(v, &e, is_artic, cnt);\n      }\n\n      if (!is_directed) {\n        for (auto &e : g.res[v]) {\n          if (g.GetRevEdge(&e) == par) continue;\n          update(v, &e, is_artic, cnt);\n        }\n      }\n\n      if (p == -1) is_artic = (cnt > 1);\n      if (is_artic) artic.emplace_back(v);\n\n      if (low[v] != ord[v]) return;\n      while (1) {\n        int u = st[--idx];\n        belong[u] = grp;\n        if (u == v) break;\n      }\n      grp++;\n    };\n\n    for (int i=0; i<n; i++) {\n      if (ord[i] == -1) dfs(i, -1, NULL);\n    }\n  }\n};\n\n\ntemplate<class Data=DefData>\nstruct SCCData {\n  using VD = typename Data::VData;\n  using ED = typename Data::EData;\n  using GD = typename Data::GData;\n  using G = Graph<Data>;\n  using Len = int;\n\n  struct VData {\n    G g; // the graph consisting of contracted nodes in one component\n    vector<int> cont2orig; // the correspondence of the node index: v on SCCVData::g -> cont2orig[v] on the original graph(G)\n  };\n\n  struct EData : ED {\n    int s;\n    int t;\n    EData(int a, int b, const ED &dat) : ED(dat), s(a), t(b) {}\n  };\n\n  struct GData {\n    vector<int> orig2cont; // the correspondence of the node index: v on G -> orig2cont[v] on G's SCC::vdat[belong[v]].g\n  };\n\n  static const Len INF = 0x33433433;\n};\n\ntemplate<class Data=DefData>\nstruct SCC : Graph<SCCData<Data> > {\n  using ED = typename Data::EData;\n  using EData = typename SCCData<Data>::EData;\n  using G = Graph<Data>;\n\n  DFSForest<Data> df;\n  SCC(G &g) : df(g, true) {\n    int n = g.n;\n\n    this->Init(df.grp);\n    auto &gdat = this->gdat;\n    auto &vdat = this->vdat;\n\n    gdat.orig2cont.resize(n);\n    for (int v=0; v<n; v++) {\n      auto &vd = vdat[df.belong[v]];\n      gdat.orig2cont[v] = vd.cont2orig.size();\n      vd.cont2orig.emplace_back(v);\n    }\n\n    for (int i=0; i<df.grp; i++) {\n      auto &vd = vdat[i];\n      vd.g.Init(vd.cont2orig.size());\n    }\n    \n    for (int v=0; v<n; v++) {\n      for (auto &e : g.es[v]) {\n        int u = e.to;\n        ED &rd = g.GetRevEdge(&e)->dat;\n        int bv = df.belong[v];\n        int bu = df.belong[u];\n\n        if (bv == bu) {\n          auto &vd = vdat[bv];\n          auto &dic = gdat.orig2cont;\n          vd.g.AddEdge(dic[v], dic[u], e.dat, rd);\n        } else {\n          this->AddEdge(bv, bu, EData(v, u, e.dat), EData(u, v, rd));\n        }\n      }\n    }\n  }\n};\n\nint n;\nint m;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Graph<> g(n);\n  while (m--) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    g.AddEdge(s, t);\n  }\n\n  SCC<> scc(g);\n  for (int i=scc.df.grp-1; i>=0; i--) {\n    printf(\"%d\\n\", scc.vdat[i].cont2orig[0]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n#define PI acos(-1)\n#define Mod (int)1000000007\n#define INFTY (int)INT_MAX\n#define Rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define BitRep(i, n) for (int i = 0; i < (int)(1 << n); i++)\n#define All(vec) vec.begin(), vec.end()\n#define Sum(vec) accumulate(vec.begin(), vec.end(), 0)\n#define Sort(vec) sort(vec.begin(), vec.end())\n#define Reverse(vec) reverse(vec.begin(), vec.end())\n#define Count(vec, x) count(vec.begin(), vec.end(), x)\n#define Next_permutation(vec) next_permutation(vec.begin(), vec.end())\n#define Find(S, s) S.find(s) != string::npos\n\nvector<int> topological_sort(vector<vector<int>> &graph, vector<int> &indegree, int V) {\n\tvector<int> ans;\n\tqueue<int> Q;\n\tRep(i, V) {\n\t\tif (indegree[i] == 0) {\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tRep(i, graph[v].size()) {\n\t\t\tint u = graph[v][i];\n\t\t\tindegree[u]--;\n\t\t\tif (indegree[u] == 0) Q.push(u);\n\t\t}\n\t\tans.push_back(v);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> graph(V);\n\tvector<int> indegree(V);\n\tRep(i, E) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\tindegree[b]++;\n\t}\n\tvector<int> ans = topological_sort(graph, indegree, V);\n\tRep(i, V) {\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<21);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n    for(int u=0; u<N; u++){\n        if(indeg[u]==0 && !V[u]) bfs(u);\n    }\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#define MAXV 10005\n#define MAXE 100005\nusing namespace std;\n\nint N,E;\nbool V[MAXV];\nvector<int> G[MAXV],out;\nint indeg[MAXV];\n\nvoid bfs(int u){\n    queue<int> q;\n    q.push(u);\n    V[u]=true;\n    int i;\n    while(!q.empty()){\n        int a=q.front();q.pop();\n        out.push_back(u);\n        for(i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[i]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n     int i;\n     for(i=0;i<N;i++){\n        if(!V[i]&&indeg[i]==0)bfs(i);\n     }\n     for(vector<int>::iterator it=out.begin();it!=out.end();it++)cout<<*it<<endl;\n}\n\nint main()\n{\n    cin>>N>>E;\n    int i,j;\n    for(i=0;i<E;i++){\n        int a,b;\n        cin>>a>>b;\n        G[a].push_back(b);\n    }\n\n    memset(indeg,0,sizeof(indeg));\n    for(i=0;i<N;i++)V[i]=false;\n    for(i=0;i<N;i++){\n        for(j=0;i<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    tsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nusing cEdges=std::vector<std::vector<int>>;\n\nvoid sort_by_dfs_helper(int root,const cEdges& Edges,vector<bool>& IsVisit,vector<int>& Ans,int& index){\n\tIsVisit[root]=true;\n\n\tfor(const auto& val:Edges[root]){\n\t\tif(!IsVisit[val]){\n\t\t\tsort_by_dfs_helper(val,Edges,IsVisit,Ans,index);\n\t\t}\n\t}\n\n\tAns[index]=root;\n\tif(index>0)--index;\n}\nvector<int> sort_by_dfs(const cEdges& Edges){\n\tif(Edges.empty())return vector<int>();\n\n\tvector<bool> IsVisit(Edges.size(),false);\n\tvector<int> Ans(Edges.size(),-1);\n\tint index=Ans.size()-1;\n\tfor(int i=0;i<IsVisit.size();++i){\n\t\tif(!IsVisit[i]){\n\t\t\tsort_by_dfs_helper(i,Edges,IsVisit,Ans,index);\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main() {\n\tint N,M;\n\tcin>>N>>M;\n\tcEdges Edges(N);\n\tfor(int i=0;i<M;++i){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tEdges[u].push_back(v);\n\t}\n\n\tauto ans=sort_by_dfs(Edges);\n\n\tfor(const auto& val:ans){\n\t\tcout<<val<<\"\\n\";\n\t}\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (dfs) ------ //\nvector<int> tsort(Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    vector<int> res, color(n, YET);\n    static const function<bool(int)> dfs = [&](int v) {\n        color[v] = VISITED;\n        for (Edge &e : g[v]) {\n            if (color[e.dst] != DONE && (color[e.dst] == VISITED || !dfs(e.dst))) return false;\n        }\n        color[v] = DONE; res.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i) if (color[i] == YET && !dfs(i)) return {};\n    reverse(res.begin(), res.end());\n    return res;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord = tsort(g);\n    for (int i = 0; i < V; i++) cout << ord[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int V, E;\n    cin >> V >> E;\n\n    vector<int> G[V];\n    int in[V] = {};\n\n    int s, t;\n    for (int i=0; i<E; ++i) {\n        cin >> s >> t;\n        G[s].push_back(t);\n        in[t] ++;\n    }\n\n    stack<int> can;\n    for (int i=0; i<V; ++i) {\n        if (in[i] == 0) {\n            can.push(i);\n        }\n    }\n\n    vector<int> res;\n\n    while (can.size()) {\n        int k = can.top(); can.pop();\n        res.push_back(k);\n        for (int &i: G[k]) {\n            in[i] --;\n            if (in[i] == 0) {\n                can.push(i);\n            }\n        }\n    }\n\n    for (int i=0; i<res.size(); ++i) {\n        cout << res[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// DFSを用いたトポロジカルソート\n// 計算量 O(V) \n// reference Programming Contest Challenge Book Second Edition\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/1/GRL_4_B\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate<typename T> struct edge {\n  int to;\n  edge(int to_) : to(to_) {}\n};\n\ntemplate<typename T,template <typename ELEM> class C> struct Topological_Sort {\n  vector<vector<C<T>>> G;\n  vector<bool> used;\n  int V;//0,...,|V|-1\n  T INF;\n\n  Topological_Sort (int V_) {\n    init(V_);\n  }\n\n  void init(int V_) {\n    V = V_;\n\n    G.clear();\n    G.resize(V);\n  }\n\n  // https://faithandbrave.hateblo.jp/entry/20080310/1205149207\n  template <typename FROM, class... Args>\n  void add_edge(FROM from, Args&&... arg) {\n    G[from].emplace_back(arg...);\n  }\n\n  void dfs (int i, vector<int> &sorted) {\n    used[i] = true;\n\n    rep(j,(int)G[i].size()) {\n      if (!used[G[i][j].to]) {\n        dfs(G[i][j].to, sorted);\n      }\n    }\n\n    sorted.emplace_back(i);//dfsの帰りがけの順\n  }\n\n  template<typename ID_TYPE>\n  bool topological_sort (vector<ID_TYPE> &sorted) { // 成功ならtrue 失敗(DAG出ない)ならfalseを返す\n    used.clear();\n    used.resize(V,false);\n\n    sorted.clear();\n\n    rep (i,V) {\n      if (!used[i]) dfs(i,sorted);\n    }\n\n    // DAGでないときトポロジカルソート出来ないのでfalseを返す\n    // https://ferin-tech.hatenablog.com/entry/2017/01/24/184750\n    if (V != (int)(sorted.size())) return false;\n\n    reverse(sorted.begin(),sorted.end());\n\n    return true;\n  }\n\n};\n\nusing ll = long long;\n\nint main() {\n  ll V,E;\n  cin >> V >> E;\n  Topological_Sort<ll,edge> ts(V);\n  rep(i,E) {\n    ll s,t;\n    cin >> s >> t;\n    ts.add_edge(s,t);\n  }\n\n  vector<int> ans;\n\n  ts.topological_sort(ans);\n\n  for (auto v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <vector>\n#include <list>\n\nusing namespace std;\nstatic const int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nlist<int> out;\nbool visited[MAX_V];\n\nvoid\ndfs(int u)\n{\n\tvisited[u] = true;\n\tfor (unsigned int i = 0; i < G[u].size(); ++i)\n\t{\n\t\tint v = G[u][i];\n\t\tif (!visited[v])\n\t\t\tdfs(v);\n\t}\n\n\tout.push_front(u);\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint V, E;\n\tint s, t;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < V; ++i)\n\t\tvisited[i] = false;\n\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tif (!visited[i])\n\t\t\tdfs(i);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); ++it)\n\t\tprintf(\"%d\\n\", *it);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<int> G[10000];\n\nint main(void) {\n    int v,e;\n    scanf(\"%d%d\",&v,&e);\n\n    vector<int> res;\n    vector<int> in(v);\n\n    for(int i=0; i<e; i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        G[s].push_back(t);\n        in[t]++;\n    }\n    \n    queue<int> q;\n    for(int i=0; i<v; i++)\n        if(in[i] == 0)\n            q.push(i);\n    while(q.size()) {\n        int i = q.front(); q.pop();\n        res.push_back(i);\n        for(auto &j : G[i])\n            if(--in[j] == 0)\n                q.push(j);\n    }\n    for(auto &r : res)\n        cout << r << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct topological_sort{\n    vector<vector<int>> graph;\n    vector<bool> done,open;\n    vector<int> res;\n    bool success;\n    topological_sort(vector<vector<int>> &graph):graph(graph),done(graph.size()),open(graph.size()){\n        success=true;\n        rep(i,0,graph.size()){\n            if(!dfs(i)){\n                success=false;\n                break;\n            }\n        }\n        reverse(res.begin(),res.end());\n    }\n    bool dfs(int v){\n        if(open[v]) return false;\n        if(done[v]) return true;\n        open[v]=true;\n        done[v]=true;\n        for(auto &u:graph[v]) if(!dfs(u)) return false;\n        open[v]=false;\n        res.push_back(v);\n        return true;\n    }\n};\n\nvoid solve(){\n    int v,e;\n    cin >> v >> e;\n    vector<vector<int>> graph(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n    topological_sort ts(graph);\n    rep(i,0,v) cout << ts.res[i] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass graph\n{\n    private:\n        const int number_of_nodes;\n        const bool is_directed;\n    public:\n        vector<int> *edges;\n        graph(int number_of_nodes, bool is_directed = true): number_of_nodes(number_of_nodes), is_directed(is_directed) {\n            edges = new vector<int>[number_of_nodes];\n        }\n        ~graph() {\n            delete [] edges;\n        }\n        int size() const {return number_of_nodes;}\n        void make_edge(int u, int v) {\n            edges[u].push_back(v);\n            if (!is_directed) {\n                edges[v].push_back(u);\n            }\n        }\n};\n\n// lp[v] = (maximum length of a path which starts from node v)\n// the length of a path with single node is 1.\n// if graph g has a cycle, return nullptr.\nint * longest_path(graph &g)\n{\n    int *lp = new int[g.size()]();\n    function<int(int, int)> f = [&](int u, int depth) -> int {\n        if (lp[u] != 0) {\n            return lp[u];\n        }\n        if (g.edges[u].size() == 0) {\n            return lp[u] = 1;\n        }\n        if (depth == g.size()) {\n            return lp[u] = -1;\n        }\n        int x_max = 0;\n        for (int v: g.edges[u]) {\n            int x = f(v, depth + 1);\n            if (x == -1) {\n                return lp[u] = -1;\n            }\n            x_max = max(x_max, x);\n        }\n        return lp[u] = x_max + 1;\n    };\n    for (int v = 0; v < g.size(); ++v) {\n        if (f(v, 0) == -1) {\n            delete [] lp;\n            return nullptr;\n        }\n    }\n    return lp;\n}\n\n// g: directed graph\n// return topological sorted array.\n// if g has a cycle, return nullptr.\nint * topological_sort(graph &g)\n{\n    int *lp = longest_path(g);\n    if (lp == nullptr) {\n        return nullptr;\n    }\n    pair<int, int> *a = new pair<int, int>[g.size()];\n    for (int v = 0; v < g.size(); ++v) {\n        a[v] = pair<int, int>(lp[v], v);\n    }\n    sort(a, a + g.size(), greater<pair<int, int> >());\n    int *result = new int[g.size()];\n    for (int i = 0; i < g.size(); ++i) {\n        result[i] = a[i].second;\n    }\n    delete [] lp;\n    delete [] a;\n    return result;\n}\n\nint main(void)\n{\n    int V, E;\n    cin >> V >> E;\n    graph g(V);\n    REP(i, E) {\n        int s, t;\n        cin >> s >> t;\n        g.make_edge(s, t);\n    }\n    int *a = topological_sort(g);\n    REP(i, V) cout << a[i] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n\tint num,E,from,to,table[10000],tmp;\n\tvector<int> V[10000];\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < 10000; i++)table[i] = 0;\n\n\tscanf(\"%d %d\",&num,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\ttable[to]++;\n\t}\n\n\tfor(int i = 0; i < num; i++){\n\t\tif(table[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\t\tprintf(\"%d\\n\",tmp);\n\t\tfor(int i = 0; i < V[tmp].size(); i++){\n\t\t\ttable[V[tmp][i]]--;\n\t\t\tif(table[V[tmp][i]] == 0){\n\t\t\t\tQ.push(V[tmp][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nclass TOPO{//out is tsort's return.\n\tpublic:\n\tvvi G;\n\tvi out;\n\tvector<bool>V;\n\tvi indeg;\n\tint n;\n\tTOPO(int size){\n\t\tn=size;\n\t\tG=vvi(n);\n\t\tout=vi(0);\n\t\tV=vector<bool>(n);\n\t\tindeg=vi(n);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t}\n\tvoid bfs(int s){\n\t\tqueue<int>q;\n\t\tq.push(s);\n\t\tV[s]=true;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tout.pb(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tindeg[v]--;\n\t\t\t\tif(indeg[v]==0&&!V[v]){\n\t\t\t\t\tV[v]=true;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid tsort(){\n\t\trep(i,n)indeg[i]=0;\n\t\trep(i,n)rep(j,G[i].size()){\n\t\t\tint v=G[i][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t\trep(i,n)if(indeg[i]==0&&!V[i])bfs(i);\n//\t\trep(i,n)cout<<out[i]<<endl;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tTOPO topo(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ttopo.add_edge(a,b);\n\t}\n\ttopo.tsort();\n\trep(i,n)cout<<topo.out[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Tarjan 閉路検出なし\n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n//constexpr i64 MOD = INT64_C(998'244'353);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, SFINAE(is_signed<T>::value)>\nconstexpr T ABS(T x) noexcept {\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr i64 CMP(T x, T y) noexcept { return (y<x) - (x<y); }\n\ntemplate<typename T>\nconstexpr i64 SGN(T x) noexcept { return CMP(x,T(0)); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](i64, const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// math {{{\n/*constexpr*/ i64 GCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    return f_gcd(ABS(a), ABS(b));\n}\n\n/*constexpr*/ i64 LCM(i64 a, i64 b) noexcept {\n    ASSERT(a != 0 && b != 0);\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    a = ABS(a);\n    b = ABS(b);\n    return a / f_gcd(a,b) * b;\n}\n\n/*constexpr*/ tuple<i64,i64,i64> EXTGCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto impl = FIX([](auto&& self, i64 aa, i64 bb) -> tuple<i64,i64,i64> {\n        if(bb == 0) return make_tuple(aa, 1, 0);\n        i64 g,x,y; tie(g,x,y) = self(bb, aa%bb);\n        return make_tuple(g, y, x-(aa/bb)*y);\n    });\n    i64 g,x,y; tie(g,x,y) = impl(ABS(a), ABS(b));\n    x *= SGN(a);\n    y *= SGN(b);\n    return make_tuple(g, x, y);\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan_impl(istream& in) {\n    return make_tuple(Scan<T>::scan(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan_impl(istream& in) {\n    auto head = make_tuple(Scan<T>::scan(in));\n    return tuple_cat(head, tuple_scan_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return tuple_scan_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T>\ntuple<T> tuple_scan1_impl(istream& in) {\n    return make_tuple(Scan1<T>::scan1(in));\n}\n\ntemplate<typename T, typename... TS, SFINAE(sizeof...(TS) > 0)>\ntuple<T,TS...> tuple_scan1_impl(istream& in) {\n    auto head = make_tuple(Scan1<T>::scan1(in));\n    return tuple_cat(head, tuple_scan1_impl<TS...>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return tuple_scan1_impl<TS...>(in);\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<size_t N>\nstruct Dbg<char[N]> {\n    static void dbg(ostream& out, const char (&s)[N]) {\n        out << s;\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 M>\nstruct ModIntT {\n    static_assert(M >= 2, \"\");\n    i64 v_;  // [0,M)\n\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) {\n        i64 r = v % M;\n        v_ = r >= 0 ? r : r+M;\n    }\n\n    ModIntT operator-() const {\n        return ModIntT(-v_);\n    }\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ += rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ += M;\n        v_ -= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ *= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n\n    ModIntT& operator++() {\n        return *this += 1;\n    }\n    ModIntT& operator--() {\n        return *this -= 1;\n    }\n    ModIntT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModIntT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n\n    ModIntT inv() const {\n        i64 g,x; tie(g,x,ignore) = EXTGCD(v_, M);\n        ASSERT(g == 1);\n        return ModIntT(x);\n    }\n};\n\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) += lhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) -= lhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) *= lhs; }\n\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, ModIntT<M> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, i64 rhs) { return lhs == ModIntT<M>(rhs); }\ntemplate<i64 M>\nbool operator==(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) == rhs; }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(i64 lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 M>\nstruct Scan<ModIntT<M>> {\n    static ModIntT<M> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 M>\nstruct Fmt<ModIntT<M>> {\n    static void fmt(ostream& out, ModIntT<M> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 M>\nstruct Dbg<ModIntT<M>> {\n    static void dbg(ostream& out, ModIntT<M> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModInt = ModIntT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(2);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nvoid solve() {\n    i64 N = RD();\n    i64 M = RD();\n\n    vector<vector<i64>> G(N);\n    REP(_, M) {\n        i64 a = RD();\n        i64 b = RD();\n        G[a].emplace_back(b);\n    }\n    DBG(G);\n\n    auto ans = vec_reserve<i64>(N);\n    vector<bool> visited(N, false);\n    auto dfs = FIX([&](auto&& self, i64 v) -> void {\n        visited[v] = true;\n        for(i64 to : G[v]) {\n            if(!visited[to])\n                self(to);\n        }\n        ans.emplace_back(v);\n    });\n    REP(v, N) {\n        if(!visited[v])\n            dfs(v);\n    }\n    ALL(reverse, ans);\n\n    ASSERT(SIZE(ans) == N);\n\n    ALL(for_each, ans, LIFT(PRINTLN));\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nvector<unordered_set<int>> redge;\n\nunordered_set<int> memo;\nvoid topological_sort(int u) {\n  if(memo.count(u)) return;\n  memo.insert(u);\n  for(int v: redge[u]) topological_sort(v);\n  cout << u << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  redge.resize(V);\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    redge[v].insert(u);\n  }\n  for(int i = 0; i < V; ++i) topological_sort(i);\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i])\n                        continue;\n                S.push(i);\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        if (!U[c]) {\n                                L.push_back(c);\n                                U[c] = true;\n                        }\n                        for (auto a: A[c])\n                                if (--B[a] == 0 && !U[a])\n                                        S.push(a);\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <list>\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define repR(i, n) for(int i = (n) - 1; i > -1; i--)\n#define rep1(i, n) for(int i = 1; i < (int)(n + 1); i++)\n#define rep1R(i, n) for(int i = (n); i > 0; i--)\n#define ll long long\nusing namespace std;\n\nconst int MAX = 10000;\n\nenum Color {\n  WHITE = 0,\n  GRAY = 1,\n  BLACK = 2,\n};\n\nvector<int> adj[MAX + 10];\nColor color[MAX + 10];\nint indeg[MAX + 10] = {};\nlist<int> out;\n\nvoid bfs(int s) {\n  queue<int> Q;\n  Q.push(s);\n  color[s] = GRAY;\n  while (!Q.empty()) {\n    int u = Q.front(); Q.pop();\n\n    out.push_back(u);\n\n    rep(i, adj[u].size()) {\n      int v = adj[u][i];\n      --indeg[v];\n      if (indeg[v] == 0 && color[v] == WHITE) {\n        color[v] = GRAY;\n        Q.push(v);\n      }\n    }\n  }\n}\n\nvoid topologicalSort(int V) {\n  rep(i, V) color[i] = WHITE;\n\n  rep(u, V) {\n    if (indeg[u] == 0 && color[u] == WHITE) bfs(u);\n  }\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  rep(i, E) {\n    int s, t;\n    cin >> s >> t;\n    adj[s].push_back(t);\n    ++indeg[t];\n  }\n  topologicalSort(V);\n  for (auto i : out) cout << i << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 414514\nset<int> G[MAX];\nint indeg[MAX];\nbool V[MAX];\nvector<int> p;\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  V[s]=1;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    p.push_back(u);\n    for(int v:G[u]){\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n\tV[v]=1;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(int n){\n  memset(V,0,sizeof(V));\n  memset(indeg,0,sizeof(indeg));\n  for(int u=0;u<n;u++)\n    for(int v:G[u])\n      indeg[v]++;\n  for(int u=0;u<n;u++)\n    if(indeg[u]==0&&!V[u]) bfs(u);\n\n  if((int)p.size()!=n){\n    cout<<-1<<endl;\n    return;\n  }\n  for(int i=0;i<n;i++)\n    cout<<p[i]<<endl;\n}\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].insert(t);\n  }\n  tsort(n);\n  return 0;\n}\n\n/*\nverified on 2017/04/28\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <list>\n#include <vector>\nusing namespace std;\n\nint v, e, cnt = 1, idx, order[10005];\nbool chk[10005];\nlist<int> di[10005], rev[10005];\nvector<int> vec;\nvoid bfs(){\n    while(idx < vec.size()){\n        int num = vec[idx++], have = 0;\n        if(!chk[num]){\n            for(list<int>::iterator it = di[num].begin(); it != di[num].end(); ++it){\n                if(!chk[*it]){\n                    have++;\n                    vec.push_back(*it);\n                }\n            }\n            if(have == 0){\n                order[cnt++] = num;\n                chk[num] = true;\n                for(list<int>::iterator it = rev[num].begin(); it != rev[num].end(); ++it)\n                    if(!chk[*it])\n                        vec.push_back(*it);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\", &v, &e);\n    for(int i = 0; i < e; ++i){\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        di[a].push_back(b);\n        rev[b].push_back(a);\n    }\n    for(int i = 0; i < v; ++i){\n        if(!chk[i]){\n            vec.push_back(0);\n            bfs();\n        }\n    }\n    for(int i = v; i >= 1; --i)\n        printf(\"%d\\n\", order[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = ( 1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\n\tV[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v])\n\t\t\t{\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid tsort()\n{\n\tfor (int i = 0; i < N; ++i)\n\t\tindeg[i] = 0;\n\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); ++j)\n\t\t{\n\t\t\tint v = G[i][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (indeg[i] == 0 && !V[i]) bfs(i);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); ++it)\n\t\tcout << *it << endl;\n}\n\nint main()\n{\n\tint s, t, m;\n\tcin >> N >> m;\n\n\n\tfor (int i = 0; i < N; ++i) V[i] = false;\n\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<string>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<iomanip>\n#include<cctype>\n#include<map>\n#include<cstring>\n#include<bitset>\n#include<cassert>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep2(i,a,b) for (int (i)=a;(i)<(b);(i)++)\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nusing ll = long long int;\n\nconst int inf = 1001001000;\nconst long long int Inf = 1001001001001001000;\n\n\n\nvoid print(vector<vector<int>> a){\n\tfor (int i = 0; i < a.size(); i++)\n\t{\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<vector<long long int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<int> a){\n    int n = a.size();\n    for (int j=0;j<n;j++) {\n        if (j != n-1) cout << a[j] << \" \";\n        else cout << a[j] << endl;\n    }\n}\n\nvoid print(vector<long long int> a){\n    int n = a.size();\n    for (int j=0;j<n;j++) {\n        if (j != n-1) cout << a[j] << \" \";\n        else cout << a[j] << endl;\n    }\n}\n\nvoid print(set<int> a){\n\tfor (auto x:a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\n//トポロジカルソートの結果を返す関数.graphは隣接リスト.0-origin.\n//閉路がある場合，空のvectorを返す.\nvector<int> tsort(const vector<vector<int>> &graph){\n\tconst int v = graph.size();\n\tvector<int> indeg(v, 0);\n\tvector<int> s;\n\tfor (auto out : graph)\n\t{\n\t\tfor (auto x:out){\n\t\t\tindeg[x]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < v; i++){\n\t\tif(indeg[i] == 0){\n\t\t\ts.push_back(i);\n\t\t}\n\t}\n\tvector<int> res;\n\twhile(s.size()){\n\t\tint u = s.back();\n\t\ts.pop_back();\n\t\tres.push_back(u);\n\t\tfor(auto x:graph[u]){\n\t\t\tindeg[x]--;\n\t\t\tif(indeg[x] == 0){\n\t\t\t\ts.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tif (res.size() != v)\n\t\treturn vector<int>();\n\treturn res;\n}\n\nint main(){\n\tint v, e;\n\tcin >> v >> e;\n\tvector<vector<int>> graph(v);\n\trep(i,e){\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tgraph[s].push_back(t);\n\t}\n\tvector<int> ans = tsort(graph);\n\tprint(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int v, e;\n   std::cin >> v >> e;\n   std::vector<Int> ss(e), ts(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i];\n   std::vector<std::vector<Int>> nexts(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i];\n      nexts[s].emplace_back(t);\n   }\n   std::vector<Int> xs(v, -1);\n   Int id = 0;\n   std::function<void(Int,Int)> dfs = [&](Int i, Int prev) {\n      if( xs[i] != -1 ) return;\n      xs[i] = -2;\n      for(Int k : nexts[i]) {\n         guard( k != prev );\n         if( xs[k] == -1 ) {\n            dfs(k, i);\n         }\n      }\n      xs[i] = id; id += 1;\n   };\n   rep(i, v) dfs(i, -1);\n   std::vector<Int> ys(v);\n   rep(i, v) ys[xs[i]] = i;\n   rep(i, v) printf(\"%ld\\n\", ys[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nvoid solve(){\n  int v, e; cin >> v >> e;\n  vector<vector<int> > a(v);\n  vector<int> ind(v, 0), c(v, 0), ans;\n  for(int i = 0; i < e; i++){\n    long long s, t; cin >> s >> t;\n    a[s].push_back(t);\n    ind[t]++;\n  }\n  for(int i = 0; i < v; i++){\n    if(ind[i] == 0 && c[i] == 0){\n      queue<int> q;\n      q.push(i);\n      c[i] = 1;\n      while(q.size() > 0){\n        int x = q.front();\n        q.pop();\n        ans.push_back(x);\n        for(int j = 0; j < a[x].size(); j++){\n          ind[a[x][j]]--;\n          if(ind[a[x][j]] == 0 && c[a[x][j]] == 0){\n            q.push(a[x][j]);\n            c[a[x][j]] = 1;\n          }\n        }\n      }\n    }\n  }\n  for(int i = 0; i < ans.size(); i++){\n    cout << ans[i] << endl;\n  }\n  return;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\n\nclass Graph{\n\tprivate:\n\tint GV,GE;\n\tvvi List;\n\tvoid TSfunc(int v,vb& used){\n\t\tused[v]=1;\n\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\tint u=List[v][i];\n\t\t\tif(!used[u]) TSfunc(u,used);\n\t\t}\n\t\tts.push_back(v);\n\t}\n\tpublic:\n\tvi ts;\n\tGraph(int v,int e){\n\t\tGV=v;\n\t\tGE=e;\n\t\tList=vvi(v);\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t}\n\tvoid TS(){\n\t\tvb used(GV);\n\t\tfor(int i=0;i<GV;i++){\n\t\t\tif(!used[i]) TSfunc(i,used);\n\t\t}\n\t}\n};\n\nint V,E;\n\nint main(){\n\tcin>>V>>E;\n\tGraph gra(V,E);\n\tint s,t;\n\tfor(int i=0;i<E;i++){\n\t\tcin>>s>>t;\n\t\tgra.add_edge(s,t);\n\t}\n\tgra.TS();\n\tfor(int i=V-1;i>=0;i--) cout<<gra.ts[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <queue>\n#define MAXV 10005\n#define MAXE 100005\nusing namespace std;\n\nint N,E;\nbool V[MAXV];\nvector<int> G[MAXV],out;\nint indeg[MAXV];\n\nvoid bfs(int u){\n    queue<int> q;\n    q.push(u);\n    V[u]=true;\n    int i;\n    while(!q.empty()){\n        int a=q.front();q.pop();\n        out.push_back(u);\n        for(i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[i]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n     int i;\n     for(i=0;i<N;i++){\n        if(!V[i]&&indeg[i]==0)bfs(i);\n     }\n     for(vector<int>::iterator it=out.begin();it!=out.end();it++)cout<<*it<<endl;\n}\n\nint main()\n{\n    cin>>N>>E;\n    int i,j;\n    for(i=0;i<E;i++){\n        int a,b;\n        cin>>a>>b;\n        G[a].push_back(b);\n    }\n    \n    memset(indeg,0,sizeof(indeg));\n    for(i=0;i<N;i++)V[i]=false;\n    for(i=0;i<N;i++){\n        for(j=0;i<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    tsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < N; u++)\n\t\tif (indeg[u] == 0 && !V[u]) bfs(u);\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector <int> res, graph[10000];\nbool visited[10000];\n\nvoid dfs(int v){\n  visited[v] = true;\n  for(int u : graph[v]){\n    if(!visited[u]){\n      dfs(u);\n    }\n  }\n  res.push_back(v);\n}\n\nvoid topological_sort(int n){\n  for(int i = 0; i < n; i++){\n    if(!visited[i]){\n      dfs(i);\n    }\n  }\n  reverse(res.begin(), res.end());\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n, m, i, x, y;\n  cin >> n >> m;\n  while(m--){\n    cin >> x >> y;\n    graph[x].push_back(y);\n  }\n  topological_sort(n);\n  for(int x : res){\n    cout << x << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nvector<int>G[10005];\nint V,E,F[10005]={0};\nqueue<P>Q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint s,e;\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tG[s].push_back(e);\n\t\tF[e]=1;\n\t}\n\tfor(int i=0;i<V;i++)if(!F[i])Q.push(make_pair(i,0));\n\tmemset(F,0,sizeof(F));\n\twhile(!Q.empty())\n\t{\n\t\tP T=Q.front();Q.pop();\n\t\tint s=T.first,t;\n\t\tfor(int i=0;i<G[s].size();i++)\n\t\t{\n\t\t\tt=G[s][i];\n\t\t\tif(F[t]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[t]=F[s]+1;\n\t\t\t\tQ.push(make_pair(t,F[t]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tint t=-1;\n\t\tfor(int i=0;i<V;i++)\n\t\t{\n\t\t\tif(t==-1||F[t]>F[i])\n\t\t\t\tt=i;\n\t\t}\n\t\tprintf(\"%d\\n\",t);\n\t\tF[t]=100000;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (dfs) ------ //\nvector<int> tsort(Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    vector<int> res, color(n, YET);\n    static const function<bool(int)> dfs = [&](int v) {\n        color[v] = VISITED;\n        for (Edge &e : g[v]) {\n            if (color[e.dst] == DONE) continue;\n            if (color[e.dst] == VISITED) return false;\n            if (!dfs(e.dst)) return false;\n        }\n        color[v] = DONE; res.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i) if (color[i] == YET && !dfs(i)) return {};\n    reverse(res.begin(), res.end());\n    return res;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord = tsort(g);\n    for (int i = 0; i < V; i++) cout << ord[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconstexpr int di[] = { 0, 1, 0, -1 }, dj[] = { 1, 0, -1, 0 };\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define repr(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define all(v) (v).begin(), (v).end()\n#define MAX 100000\n#define vmax 10000\n#define sentinel 2000000000\n#define INF (1<<29)\nconstexpr long long int inf = 100000000000000000;\nconstexpr long long int rinf = -(INT64_MAX);\nstatic const int NIL=-1;\n\n//cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\nvector<int> g[MAX];\nlist<int> out;\nbool V[MAX];\nint n;\n\nvoid dfs(int u){\n    V[u]=true;\n    for(auto v:g[u]){\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,m;\n    cin>>n>>m;\n    rep(i,n) V[i]=false;\n    for(int i=0;i<m;i++){\n        cin>>s>>t;\n        g[s].push_back(t);\n    }\n\n    rep(i,n){\n        if(!V[i]) dfs(i);\n    }\n\n    for(auto it:out){\n        cout<<it<<endl;\n    }\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nint main(){\n  int s,t,n,m;\n  cin>>n>>m;\n\n  vector<vector<int> > lis(n+1000);\n  list<int> out;  \n  vector<bool> V(n+1000,false);\n  for(int i=0;i<m;i++){\n    cin>>s>>t;\n    lis[s].push_back(t);  \n  }\n  \n  //ここから本番\n  vector<int> indeg(n+1000,0);\n\n  //隣接リストを参照して、入次数の数を数える\n  for(int u=0;u<n;u++){\n    for(int i=0;i<lis[u].size();i++){\n      int v=lis[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for(int u=0;u<n;u++){\n    if(indeg[u]==0 && !V[u]){\n      //幅優先探索\n      queue<int> que;\n      que.push(u);\n      V[u]=true;\n      while(!que.empty()){\n        int u=que.front(); que.pop();\n        out.push_back(u);\n        for(int i=0;i<lis[u].size();i++){\n          int v=lis[u][i];\n          indeg[v]--;\n          if(indeg[v]==0 && !V[v]){\n            V[v]=true;\n            que.push(v);\n          }\n        }\n      }\n    }\n  }\n\n  for(auto it=out.begin();it!=out.end();it++){\n    cout<<*it<<'\\n';\n  }\n  return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\n/*vector<int> tpsort_Kahn(const Graph &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.pb(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}*/\n\nvoid tpTarjanVisit(const Graph &g, int u, vector<bool> &used, vector<int> &ans) {\n    if(used[u] == false) {\n        used[u] = true;\n        rep(i,0,g[u].size()) \n            tpTarjanVisit(g, g[u][i].to, used, ans);\n        ans.pb(u);\n    }\n}\n\nvector<int> tpsort_Tarjan(const Graph &g) {\n    const int V = g.size();\n    vector<bool> used(V, false);\n    vector<int> ans;\n    rep(i,0,V) tpTarjanVisit(g, i, used, ans);\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n\nsigned main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    int s, t;\n    rep(i,0,E) {\n        cin >> s >> t;\n        G[s].pb(Edge(t,1));\n    }\n    vector<int> ans = tpsort_Tarjan(G);\n    rep(i,0,ans.size()) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rept(i,n) for(int (i)=0;(i)<=(int)(n);(i)++)\n#define reps(i,s,n) for(int (i)=(s);(i)<(int)(n);(i)++)\n#define repst(i,s,n) for(int (i)=(s);(i)<=(int)(n);(i)++)\n#define repr(i,n) for(int (i)=(n);(i)>=0;(i)--)\n#define each(itr,v) for(auto (itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp(x,y) make_pair((x),(y))\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln \"\\n\"\n#define show(x) cout << #x << \" = \" << x ln\n#define dbg(x) cout<<#x\"=\"<<x ln\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > mat;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ??????????????????????????????????????????( ^??^)??????????????????????????????????????????\n\n// ????????°????????°?????\\?¬???°\nint v, e, in[100000];\n// ??\\?¬???°0???????????????????????\\????????????\nqueue<int> S;\n// ????????£??\\?????????\nmat V(100000);\n// ??????\nvi ans;\n\nint main() {\n\tcin >> v >> e;\n\trep(i,e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tV[a].pb(b);\n\t\tin[b]++;\n\t}\n\t\n\t// ??\\?¬???°0??????????????????\n\trep(i,v) if (in[i]==0) S.push(i);\n\twhile (!S.empty()) {\n\t\tint u = S.front(); S.pop();\n\t\tans.pb(u);\n\t\t// u?????????????¢???????????????§??°?????????????¶?????????£??\\????????¨??????????????\\?¬???°???1?????????\n\t\trep(i,V[u].size()) {\n\t\t\tint to = V[u][i];\n\t\t\tin[to]--;\n\t\t\t// ????????????????????£?????\\?¬???°???0????????£?????????????????°S?????????\n\t\t\tif (in[to]==0) S.push(to);\n\t\t}\n\t}\n\trep(i,v) cout << ans[i] << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n  \n}\n\nvoid tsort(){\n\n  for(int i=0;i<N;i++){\n    indeg[i]=0;\n  }\n\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for(int u=0;u<N;u++)\n    if(indeg[u]==0&&!V[u]) bfs(u);\n\n  for(list<int>::iterator it=out.begin();it!=out.end();it++){\n    cout<<*it<<endl;\n  }\n\n}\n\nint main(){\n  int s,t,M;\n  cin>>N>>M;\n\n  for(int i=0;i<N;i++) V[i]=false;\n\n  for(int i=0;i<N;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <list>\n\nusing namespace std;\n#define  INF  (INT_MAX/2)\n#define  MAXV  10001\n#define  MAXE 100001\n#define  NIL  -1\n\nlist<int> ans;\nbool vis[MAXV];\nint head[MAXE], indegree[MAXV];\nint cnt;\n\nstruct Edge {\n  int  to, next=NIL;\n} edge[MAXE];\n\nvoid bfs(int u){\n  queue<int> q;\n  vis[u] = true;\n  q.push(u);\n  while (!q.empty()){\n    u = q.front();\n    ans.push_back(u);\n    q.pop();\n\n    for (int i=head[u];i!=NIL;i=edge[i].next){\n      u=edge[i].to;\n      if (!vis[u] && --indegree[u] == 0){\n\tvis[u] = true;\n\tq.push(u);\n      }\n    }\n  }\n}\n\nvoid tpSort(int n){\n  for (int i = 0; i < n; ++i) {vis[i] = false;}\n  for (int i = 0; i < n; ++i) {\n    if (indegree[i] == 0 && !vis[i]) {bfs(i);}\n  }\n}\n\nvoid add(int u, int v){\n  edge[cnt].to = v;\n  edge[cnt].next = head[u];\n  head[u] = cnt++;\n}\n\nint main(void){\n  int V, E, s, t;\n  cin >> V >>E;\n  cnt = 0;\n  memset(head,NIL,sizeof(int)*(E+1));\n\n  for (int i = 0; i < E; ++i){\n    cin >> s>>t;\n    indegree[t]++;\n    add(s, t);\n  }\n\n  tpSort(V);\n  for (list<int>::iterator itr=ans.begin(); itr!=ans.end();itr++){cout << *itr <<endl;}\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stack>\n#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  int i,v,e,s,t;\n  queue<int> que;\n  vector<int> indgree(10010);\n  vector<vector<int> > g(10010);\n  vector<int> to;\n  scanf(\"%d %d\\n\",&v,&e);\n  for(i=0;i<e;i++){\n    scanf(\"%d %d\\n\",&s,&t);\n    g[s].push_back(t);\n    indgree[t]++;\n  }\n  for(i=0;i<v;i++){\n    if(indgree[i]==0){\n      que.push(i);\n    }\n  }\n  while(!que.empty()){\n    int x=que.front();\n    que.pop();\n    for(i=0;i<g[x].size();i++){\n      int us=g[x][i];\n      indgree[us]--;\n      if(indgree[us]==0){\n        que.push(us);\n      }\n    }\n    to.push_back(x);\n  }\n  for(i=0;i<to.size();i++){\n    printf(\"%d\\n\",to[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#include <iomanip>\n#include <numeric>\n#include <unordered_map>\n#include <sstream>   \n#include<limits.h>\n#include<list>\n#include <array>\n#include <complex>\nusing namespace std;\n#define i64  long long\n#define int  long long\n \n#define I32_MAX 2147483647\n#define I64_MAX 9223372036854775807\n#define INF I64_MAX\n#define MOD 1000000007\n#define MEM_SIZE = 1e5+5;\n\ntemplate<typename T> void DEBUG(T e){std::cout << e << std::endl;}\ntemplate<class T> void DEBUG(string str, T e){std::cout <<str << \">>\" << e << std::endl;}\ntemplate<typename T> void DEBUG(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void DEBUG(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ DEBUG(v); } }\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\n\n\n\n\n//-----CODE------//\nvoid topological_sort_BFS(vector<vector<int> >&GRAPH,vector<bool> & V,vector<int>& DEG, int NODE,vector<int>& sorted)\n{\n  queue<int> q;\n  q.push(NODE);\n  V[NODE] = true;\n  while(!q.empty())\n  {\n    int u = q.front();\n    q.pop();\n    sorted.push_back(u);\n    for (int i = 0; i < GRAPH[u].size(); i++)\n    {\n      int v = GRAPH[u][i];\n      DEG[v]--;\n      if((DEG[v] == 0)&&(V[v] == false))\n      {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n    \n  }\n}\n\nvector<int> topological_sort(vector<vector<int> >&GRAPH)\n{\n  int N = GRAPH.size();\n  vector<bool> V(N,false);\n  vector<int> DEG(N,0);\n  vector<int> sorted;\n  for (int i = 0; i < N ; i++)\n  {\n    for (int s = 0; s < GRAPH[i].size(); s++)\n    {\n      DEG[GRAPH[i][s]]++;\n    }\n  }\n  for (int i = 0; i < N; i++)\n  {\n    if((DEG[i] == 0) && (V[i] == false))\n    {\n      topological_sort_BFS(GRAPH,V,DEG,i,sorted);\n    }\n  }\n  \n  return sorted;\n}\nvoid solve(void)\n{\n  int N;\n  int M;\n  cin>>N>>M;;\n  vector<vector<int> > GRAPH(N);\n  for (int i = 0; i < M; i++)\n  {\n    int A,B;\n    cin>>A>>B;\n    GRAPH[A].push_back(B);\n  }\n  vector<bool>V(N,false);\n  vector<int> sorted;\n  sorted = topological_sort(GRAPH);\n  for (int i = 0; i < N; i++)\n  {\n    cout<<sorted[i]<<endl;\n  }\n  cout<<endl;\n  \n  \n  return; \n}\n\n\nint32_t main(int32_t argc, const char *argv[])\n{\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n\n  std::cout << std::fixed;\n  std::cout << std::setprecision(9);\n  solve();\n\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << (x) << endl\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n\nstd::vector<int> tsort(const Graph &g) {\n    int n = g.size();\n    enum State { NEW, ACTIVE, FINISHED };\n    std::vector<int> res;\n    vector <State> state(n, NEW);\n    static const std::function<bool(int)> dfs = [&](int v) {\n        state[v] = ACTIVE;\n        for (auto &e : g[v]) {\n            int w = e.dst;\n            if (state[w] == ACTIVE) return false;\n            else if (state[w] == NEW) if (!dfs(w)) return false;\n        }\n        state[v] = FINISHED;\n        res.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i)\n        if (state[i] == NEW && !dfs(i)) return {-1};\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_V (10010)\nvector<int> G[MAX_V];\nint I[MAX_V];\t\t\t// ??\\?¬???°\nbool arrived[MAX_V];\nvector<int> ans;\nvoid dfs( int s ) {\n    ans.push_back( s );\n    arrived[s] = true;\n    for ( int i = 0; i < G[s].size(); i++ ) {\n\tint t = G[s][i];\n\tI[t]--;\n\tif ( I[t] == 0 ) {\n\t    dfs( t );\n\t}\n    }\n}\n\nint main()\n{\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    \n    for ( int i = 0; i < E; i++ ) {\n\tint s, t;\n\tscanf(\"%d %d\", &s, &t);\n\tG[s].push_back( t );\n        I[t]++;\n    }\n\n    for ( int i = 0; i < V; i++ ) {\n\tif ( !arrived[i] && I[i] == 0 ) dfs( i );\n    }\n\n    for ( int i = 0; i < ans.size(); i++ ) {\n\tprintf(\"%d\\n\", ans[i] );\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 100000\nstatic const long long FAR = (1L << 31);\n\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nvector<int> G[N];\nvector<int> out;\nbool Visited[N];\nint n, m;\n\nvoid bfs(int s){\n\tqueue<int>q; q.push(s);\n\tVisited[s] = true;\n\twhile (!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tif (!Visited[v]){\n\t\t\t\tVisited[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int u = 0; u < n; ++u) if (!Visited[u]) bfs(u);\n\tfor (int i = 0; i < out.size(); ++i) cout << out[i] << endl;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) Visited[i] = false;\n\tfor (int i = 0; i < m; ++i){\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\nstruct Node {\n    vector<int> parent;\n    \n};\nint main() {\n    int v, e; cin >> v >> e;\n    Node node[v];\n    rep(i, e) {\n        int s, t; cin >> s >> t;\n        node[t].parent.push_back(s);\n    }\n    //vector<int> comb; 1組だけ出せばいい\n    queue<int> q;\n    rep(i, v) if (node[i].parent.size() == 0) {q.push(i); cout << i << endl;}\n    while (!q.empty()) {\n        int now = q.front();\n        //cout << now << endl;\n        rep(i, v) {\n            rep(j, node[i].parent.size()) {\n                if (node[i].parent[j] == now) {\n                    node[i].parent[j] = -1;\n                }\n            }\n        }\n        q.pop();\n        rep(i, v) {\n            rep(j, node[i].parent.size()) {\n                if (node[i].parent[j] != -1) break;\n                if (j == node[i].parent.size() - 1) {\n                    q.push(i);\n                    node[i].parent[0] = -2;\n                    cout << i << endl;\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// setting\ntypedef int LABEL;\ntypedef int WEIGHT;\ntypedef std::unordered_map<LABEL, std::unordered_map<LABEL, WEIGHT>> Graph;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> join(vector<int> result, const vector<int>& add) {\n  result.insert(end(result), begin(add), end(add));\n  return result;\n}\n\nvector<int> topological_sort(const Graph& g, int current, unordered_set<int>& unvisited) {\n  if(!unvisited.count(current)) return {};\n  unvisited.erase(current);\n  vector<int> result = {current};\n  if(g.count(current)) for(const auto& e: g.at(current)) result = join(result, topological_sort(g, e.first, unvisited));\n  return result;\n}\n\nvector<int> topological_sort(const Graph& g, int V) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  for(int i = 0; i < V; ++i) unvisited.insert(i);\n  while(!unvisited.empty()) result = join(result, topological_sort(g, *begin(unvisited), unvisited));\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g, V)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvi toposort(vvc<t> g){\n\tint n=g.size();\n\tvi a(n);\n\trep(i,n)for(auto e:g[i])\n\t\ta[e]++;\n\tqueue<int> q;\n\trep(i,n)if(a[i]==0)\n\t\tq.push(i);\n\tvi res;\n\trep(i,n){\n\t\tif(q.empty())return {};\n\t\tint v=q.front();q.pop();\n\t\tres.pb(v);\n\t\tfor(auto e:g[v])\n\t\t\tif(--a[e]==0)\n\t\t\t\tq.push(e);\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint s,t;cin>>s>>t;\n\t\tg[s].pb(t);\n\t}\n\t\n\tvi idx=toposort(g);\n\tfor(auto i:idx)\n\t\tcout<<i<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\"\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\n\n// #include \"../../library/graph/topologicalsort.cpp\"\n// topologically sort the directed graph\n// 0-indexed\nstruct TopologicalSort {\n    int n;\n    vector<set<int>> G;\n    vector<bool> used;\n    vector<int> indeg, p;\n\n    TopologicalSort(int size) : n(size), G(n), used(n), indeg(n), p(0) {}\n\n    void addEdge(int s, int t) { G[s].insert(t); }\n    void bfs(int s) {\n        queue<int> q;\n        q.push(s);\n        used[s] = 1;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            p.push_back(v);\n            for (int u : G[v]) {\n                indeg[u]--;\n                if (indeg[u] == 0 && !used[u]) {\n                    used[u] = 1;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    // returns topologically sorted nodes\n    // if p.size() < n, the graph cannot be sorted\n    vector<int> build() {\n        fill(used.begin(), used.end(), 0);\n        fill(indeg.begin(), indeg.end(), 0);\n        for (int i = 0; i < n; ++i) {\n            for (int v : G[i])\n                indeg[v]++;\n        }\n        for (int i = 0; i < n; ++i) {\n            if (indeg[i] == 0 && !used[i])\n                bfs(i);\n        }\n        return p;\n    }\n};\n\nint main() {\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    int v, e;\n    cin >> v >> e;\n    TopologicalSort graph(v);\n    for (int i = 0; i < e; ++i) {\n        int s, t;\n        cin >> s >> t;\n        graph.addEdge(s, t);\n    }\n    auto ret = graph.build();\n    for (auto &r : ret) {\n        cout << r << \"\\n\";\n    }\n    cout << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int v, e;\n   std::cin >> v >> e;\n   std::vector<Int> ss(e), ts(e);\n   rep(i, e) std::cin >> ss[i] >> ts[i];\n   std::vector<std::vector<Int>> nexts(v);\n   rep(i, e) {\n      Int s = ss[i], t = ts[i];\n      nexts[s].emplace_back(t);\n   }\n   std::vector<Int> xs(v, -1);\n   Int id = 0;\n   std::function<void(Int,Int)> dfs = [&](Int i, Int prev) {\n      if( xs[i] != -1 ) return;\n      xs[i] = -2;\n      for(Int k : nexts[i]) {\n         guard( k != prev );\n         if( xs[k] == -1 ) {\n            dfs(k, i);\n         }\n      }\n      xs[i] = id; id += 1;\n   };\n   rep(i, v) dfs(i, -1);\n   std::vector<Int> ys(v);\n   rep(i, v) ys[xs[i]] = i;\n   std::reverse(ys.begin(), ys.end());\n   rep(i, v) printf(\"%ld\\n\", ys[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nbool redge[10000][10000];\n\nbool memo[10000];\nvoid topological_sort(int u) {\n  if(memo[u]) return;\n  memo[u] = true;\n  for(int v = 0; v < V; ++v) if(redge[u][v]) topological_sort(v);\n  cout << u << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    redge[v][u] = true;\n  }\n  for(int i = 0; i < V; ++i) topological_sort(i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\nvector<int> g[101010];\nint h[101010];\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n    \n    for (int i = 0; i < e; i++){\n        \n        int s, t;\n        cin >> s >> t;\n        \n        g[s].push_back(t);\n        h[t]++;\n    }\n    \n    // 入次数0の頂点の集合\n    \n    stack<int> st;\n    \n    //　入次数0の頂点を追加する\n    for (int i = 0; i < v; i++) {\n        if (h[i] == 0) st.push(i);\n    }\n    \n    vector<int> ans;\n    \n    while (st.size()){\n        \n        int i = st.top();\n        st.pop();\n        \n        ans.push_back(i);\n        \n        for (auto &j : g[i]){\n            \n            h[j]--;\n            \n            if (h[j] == 0) st.push(j);\n        }\n    }\n    \n    for (int i : ans) cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while( !q.empty() ){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }    \n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n\n    for(int u=0; u<N; u++){\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0; u<N; u++)\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n\n    for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for(int i=0; i<N; i++) V[i] = false;\n\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 10000;\n\nstatic const bool DEBUG = false;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\t//DEBUG\n\tif (DEBUG == true) {\n\t\tcout << \"in BFS 1\" << endl;\n\t\tcout << \"V[i]:\" << endl;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << V[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\n\t\tcout << \"indeg[i]:\" << endl;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << indeg[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\t//if (indeg[v] == 0 && !V[v]) {\n\t\t\tif (indeg[v] == 0) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t\tif (DEBUG == true) {\n\t\t\t\t\t//DEBUG\n\t\t\t\t\tcout << \"in BFS 2\" << endl;\n\t\t\t\t\tcout << \"V[i]:\" << endl;\n\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\tcout << V[i] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\n\t\t\t\t\tcout << \"indeg[i]:\" << endl;\n\t\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\t\tcout << indeg[i] << \" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\n\tfor (int u = 0; u < N; u++) {\n\t\tfor (unsigned int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tif (DEBUG == true) {\n\t\t//DEBUG\n\t\tcout << \"V[i]: \";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << V[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\n\t\tcout << \"indeg[i]: \";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << indeg[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tfor (int u = 0; u < N; u++) {\n\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\tbfs(u);\n\t\t}\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T = int64_t>\nstruct Edge {\n  int64_t to;\n\n  Edge(int64_t to_) : to(to_) {}\n};\n\ntemplate <typename T>\nusing Graph = vector<vector<Edge<T>>>;\n\ntemplate <typename T>\nbool TopologicalSort(const Graph<T>& graph, vector<int64_t>* sorted,\n                     vector<int64_t>* group = nullptr) {\n  sorted->clear();\n  sorted->reserve(graph.size());\n  if (group != nullptr) {\n    group->clear();\n    group->resize(graph.size(), -1);\n  }\n\n  using P = pair<int64_t, int64_t>;\n\n  vector<int64_t> degs(graph.size(), 0);\n  queue<P> que;\n  for (const auto& v : graph) {\n    for (const auto& e : v) {\n      degs[e.to]++;\n    }\n  }\n\n  for (size_t v_id = 0; v_id < graph.size(); ++v_id) {\n    if (degs[v_id] == 0) {\n      que.emplace(v_id, 0);\n    }\n  }\n\n  while (!que.empty()) {\n    const int64_t v_id = que.front().first;\n    const int64_t g_id = que.front().second;\n    que.pop();\n    sorted->emplace_back(v_id);\n    if (group != nullptr) {\n      (*group)[v_id] = g_id;\n    }\n\n    for (const auto& e : graph[v_id]) {\n      degs[e.to]--;\n      if (degs[e.to] == 0) {\n        que.emplace(e.to, g_id + 1);\n      }\n    }\n  }\n\n  return sorted->size() == graph.size();\n}\n\n#ifdef USE_STACK_TRACE_LOGGER\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Weverything\"\n#include <glog/logging.h>\n#pragma clang diagnostic pop\n#endif  //__clang__\n#endif  // USE_STACK_TRACE_LOGGER\n\nsigned main(int argc, char* argv[]) {\n  (void)argc;\n#ifdef USE_STACK_TRACE_LOGGER\n  google::InitGoogleLogging(argv[0]);\n  google::InstallFailureSignalHandler();\n#else\n  (void)argv;\n#endif  // USE_STACK_TRACE_LOGGER\n  int64_t V, E;\n  cin >> V >> E;\n  Graph<int64_t> graph(V);\n  for (size_t i = 0; i < size_t(E); ++i) {\n    int64_t s, t;\n    cin >> s >> t;\n\n    graph[s].emplace_back(t);\n  }\n  vector<int64_t> sorted;\n  TopologicalSort(graph, &sorted);\n  for (auto v : sorted) {\n    cout << v << endl;\n  }\n  return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// ?§?????????¨????????¨???????????????????¨???????????§???????\nstruct Edge {\n    int from, to, cost;\n    Edge(int s, int d) : to(s), cost(d) {}\n    Edge(int f, int s, int d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\n// 1??????????????????????????????????????±????????????????????????????????? vector\n// Edges????????????????????????????????????????????°??????????????????\ntypedef vector<Edge> Edges;\n\n// ???????????±??????????????? vector\n// Graph??????????????????????????°?????????????????§??? V ??§?????????\ntypedef vector<Edges> Graph;\n\nvector<int> tpsort_Kahn(const Graph &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        // C++11??\\???\n        // ans.emplace_back(u);\n        ans.pb(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    int s, t;\n    rep(i,0,E) {\n        cin >> s >> t;\n        G[s].pb(Edge(t,1));\n    }\n    vector<int> ans = tpsort_Kahn(G);\n    rep(i,0,ans.size()) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool topologicalSort(const vector<vector<int>>& adj, vector<int>& ord) {\n    int N = adj.size();\n    vector<int> deg(N);//??\\?¬???°\n    for(int i = 0; i < N; ++i)\n      for(int nv : adj[i])\n        ++deg[nv];\n    ord.assign(N, -1);\n    int t = 0;\n    for(int v = 0; v < N; ++v) \n      if(deg[v] == 0)\n        ord[t++] = v;\n\n    for(int h = 0; h < t; ++h) {\n        int v = ord[h];\n        for(int nv : adj[v]) {\n            --deg[nv];\n            if(deg[nv] == 0)\n              ord[t++] = nv;\n        }\n    }\n    return t == N;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> adj(V);\n    for(int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].emplace_back(v);\n    }\n    vector<int> ord;\n    topologicalSort(adj, ord);\n    for(int x : ord) cout << x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 100010\n\nvector<int> g[maxn];\nint dist[maxn], parent[maxn], n, m, src;\n//\n//\n//void dijkstra(int src) {\n//    memset(dist, 63, sizeof dist);\n//    int inf = dist[0];\n//    dist[src] = 0;\n//    set<pair<int, int>> q;\n//\n////    dist , node\n//    q.insert({0, src});\n//    while (!q.empty()) {\n//        int len = q.begin()->first;\n//        int node = q.begin()->second;\n//\n//        q.erase({len, node});\n//        for (auto x: g[node]) {\n//            if (dist[x.first] > dist[node] + x.second) {\n//                q.erase({dist[x.first], x.first});\n//                parent[x.first] = node;\n//                dist[x.first] = x.second + dist[node];\n//                q.insert({dist[x.first], x.first});\n//            }\n//        }\n//    }\n//    for (int i = 0; i < n; i++)\n//        if (dist[i] == inf)\n//            cout << \"INF\" << endl;\n//        else\n//            cout << dist[i] << endl;\n//}\n\nvector<pair<pair<int, int>, int>> ed;\n\nvoid bellman(int src) {\n    memset(dist, 63, sizeof dist);\n    int inf = dist[0];\n\n    dist[src] = 0;\n    int xx;\n    for (int i = 0; i < n; i++) {\n        xx = -1;\n        for (auto x: ed) {\n            if (dist[x.first.first] < inf and dist[x.first.first] + x.second < dist[x.first.second]) {\n                dist[x.first.second] = x.second + dist[x.first.first];\n                xx = 2;\n            }\n        }\n    }\n    if (xx == -1) {\n        for (int i = 0; i < n; i++)\n            if (dist[i] == inf)\n                cout << \"INF\" << endl;\n            else\n                cout << dist[i] << endl;\n    } else\n        cout << \"NEGATIVE CYCLE\" << endl;\n}\n\nbool comp(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\n    return a.second < b.second;\n}\n\nint sz[maxn], p[maxn];\n\nvoid init(int n) {\n    for (int i = 0; i <= n; i++)\n        p[i] = i, sz[i] = 1;\n}\n\nint find(int n) {\n    return (n == p[n]) ? n : p[n] = find(p[n]);\n}\n\nbool unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n\n    if (a == b)\n        return false;\n    if (sz[b] > sz[a])\n        swap(a, b);\n    sz[a] += sz[b];\n    p[b] = a;\n    return true;\n}\n\nvoid mst() {\n    sort(ed.begin(), ed.end(), comp);\n    int ans = 0;\n    for (auto x:ed) {\n        if (unite(x.first.first, x.first.second))\n            ans += x.second;\n    }\n    cout << ans << endl;\n}\n\ndeque<int> top;\nint visited[maxn];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (auto x:g[u]) {\n        if (!visited[x])\n            dfs(x);\n    }\n    top.push_front(u);\n}\n\nvoid solve() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n\n        g[a].push_back(b);\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i])\n            dfs(i);\n    }\n    for (auto x:top)\n        cout << x << endl;\n//    dijkstra(src);\n//    bellman(src);\n//    init(n + 1);\n//    mst();\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a, 0, sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define SIZE(array) (sizeof(array) / sizeof(array[0]))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MAX_V 100000\n\n#define MOD 1000000007L\n#define INF 2147483647\n\nvector<int> topo_sort(const vector<vector<int>>& g) {\n\tconst int V = g.size();\n\tvector<int> indeg(V, 0);\n\tstack<int> S;\n\n\tfor(auto& vs : g) {\n\t\tfor(auto& v: vs) {\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (indeg[i] == 0) {\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\tvector<int> ans;\n\twhile( S.size() > 0) {\n\t\tint u = S.top();\n\t\tS.pop();\n\t\tans.emplace_back(u);\n\t\tfor (auto& v : g[u]) {\n\t\t\tindeg[v] --;\n\t\t\tif (indeg[v] == 0) {\n\t\t\t\tS.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> vs(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\tvs[from].push_back(to);\n\t}\n\tvector<int> res = topo_sort(vs);\n\tfor (int t: res) {\n\t\tcout << t << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tvector<int> order;\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s-1].push_back(t-1);\n\t\ttopologicalSort(g,order);\n\t\tfor(i=0;i<V;i++){\n\t\t\tprintf(\"%d\\n\",order[i]+1);\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <cstdlib>\n#include <queue>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\n\n#define rep(i, n) for (int i=0;i<(n);++i)\n#define rep2(i, s, n) for (int i=s;i<(n);++i)\n#define INF (1e9)\n\n/* Adjacent List */\nusing Edge = pair<int,int>;\nusing Edges = vector<Edge>;\n#define to   first\n#define cost second\n\n/* DFS-based Topological Sort */\nvoid dfs(Edges G[], int u, char visited[], vector<int>& L)\n{\n    visited[u] = 1;\n    for(auto v:G[u]) if(!visited[v.to]) dfs(G, v.to, visited, L);\n    L.insert(L.begin(), u);\n}\n\nvoid tsort(Edges G[], int V, vector<int>& L)\n{\n    char visited[V];\n    memset(visited, 0, sizeof(visited));\n    rep(i,V) if(!visited[i]) dfs(G,i,visited,L);\n}\n    \nint main()\n{\n    int V,E; cin>>V>>E;\n    Edges G[V];\n    vector<int> L;\n\n    rep(i,E) {\n        int u,v; cin>>u>>v; \n        G[u].pb(Edge(v,1));\n    }\n    tsort(G,V,L);\n\n    for(auto e:L) cout << e << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef vector<vector<pair<int, int> > > vvp;\ntypedef vector<pair<int, int> > vp;\ntypedef vector<vector<int> > vvi;\ntypedef vector<int> vi;\ntypedef vector<vector<ll> > vvl;\ntypedef vector<ll> vl;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef pair<string, int> psi;\ntypedef pair<int, int> pii;\n#define rep(i,s,n) for(int i = (s); i < (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define yn(f) (f?\"yes\":\"no\")\n#define YN(f) (f?\"YES\":\"NO\")\n#define Yn(f) (f?\"Yes\":\"No\")\n#define mod (1e9+7)\n#define inf (1e9+7)\n#define nil -1\n\nvvi List;\nvb Visit;\nvi indeg;\nvi out;\nint V;\nvoid bfs(int s) {\n\tqueue<int> Q;\n\tQ.push(s);\n\t\n\twhile (!Q.empty()) {\n\t\tint now = Q.front();\n\t\tQ.pop();\n\t\tVisit[now] = true;\n\t\tout.push_back(now);\n\t\tfor (int i = 0; i < List[now].size(); i++)\n\t\t{\n\t\t\tint u = List[now][i];\n\t\t\tindeg[u]--;\n\t\t\tif (indeg[u]==0&&Visit[u]==false) {\n\t\t\t\tQ.push(List[now][i]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\nvoid tsort() {\n\tfor (int i = 0; i < V; i++)indeg[i] = 0;\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < List[i].size(); j++)\n\t\t{\n\t\t\tint u = List[i][j];\n\t\t\tindeg[u]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (indeg[i]==0&&Visit[i]==false) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < out.size(); i++)\n\t{\n\t\tcout<<out[i]<<endl;\n\t}\n}\nint main() {\n\tint  E;\n\tcin >> V >> E;\n\tVisit.resize(V);\n\trep(i, 0, V)Visit[i] = false;\n\tList.resize(V);\n\tindeg.resize(V);\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tList[s].push_back(t);\n\t}\n\ttsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector<vector<int>> g;\nvector<int> was;\nvector<int> topoSort;\n\nvoid dfs(int u) {\n  was[u] = true;\n  for (auto& v : g[u]) {\n    if (!was[v]) {\n      dfs(v);\n    }\n  }\n  topoSort.push_back(u);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m;\n  g = vector<vector<int>>(n);\n  vector<int> indeg(n, 0);\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    cin >> u >> v;\n    g[u].push_back(v);\n    indeg[v]++;\n  }\n  was = vector<int>(n, false);\n  for (int i = 0; i < n; i++) {\n    if (!was[i]) {\n      dfs(i);\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    cout << topoSort[i] << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  topological_sort\n//\n//  Created by ???????????? on 2017/11/13.\n//  Copyright ?? 2017 ????????????. All rights reserved.\n//\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\n\nvector<int> adjList[MAX];\nvector<int> out;\nint colors[MAX];\nint indeg[MAX];\n//int openTable\n\n\nvoid bfs(int vertexInd, int numVertex){\n    queue<int> Q;\n    Q.push(vertexInd);\n    colors[vertexInd] = GRAY;\n    while(!Q.empty()){\n        int u = Q.front();\n        Q.pop();\n        out.push_back(u);\n        \n        for(int i = 0; i < adjList[u].size(); i++ ){\n            int adjInd = adjList[u][i];\n            indeg[adjInd]--;\n            if(indeg[adjInd] == 0 && colors[adjInd] == WHITE){\n                colors[adjInd] = GRAY;\n                Q.push(adjInd);\n            }\n        }\n    }\n}\n\nvoid topologicalSort(int numVertex){\n    \n    //init\n    for(int i = 0; i < numVertex; i++){\n        colors[i] = WHITE;\n        indeg[i] = 0;\n    }\n    \n    for(int i = 0; i < numVertex; i++){\n        for (int j = 0; j < adjList[i].size(); j++) {\n            int temp = adjList[i][j];\n            indeg[temp]++;\n        }\n    }\n    \n    \n    for(int i = 0; i < numVertex; i++){\n        if (indeg[i] == 0 && colors[i] == WHITE){\n            bfs(i, numVertex);\n        }\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int numVertex, numEdge;\n    scanf(\"%d %d\", &numVertex, &numEdge);\n    \n    int x, y;\n    for (int i = 0; i < numEdge; i ++){\n        scanf(\"%d %d\", &x, &y);\n        adjList[x].push_back(y);\n    }\n    \n    topologicalSort(numVertex);\n    \n    //print \"out\"\n    for(int i = 0; i < out.size(); i ++){\n        cout << out[i] << endl;\n    }\n    \n    \n//    std::cout << \"Hello, World!\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn = 10001;\n\nvector<int> G[maxn], ans;\nint indegree[maxn], vis[maxn];\nint n, e;\nvoid BFS(int s)\n{\n    queue<int> Q;\n    Q.push(s);\n    vis[s] = 1;\n    while(!Q.empty())\n    {\n        int top = Q.front();\n        ans.push_back(top);\n        vis[top] = 1;\n        Q.pop();\n        for(int i = 0; i < G[top].size(); i++)\n        {\n            indegree[G[top][i]]--;\n            if(indegree[G[top][i]] == 0 && vis[G[top][i]] == 0)\n            {\n                Q.push(G[top][i]);\n            }\n        }\n    }\n}\n\nvoid topologicalSort()\n{\n    for(int u = 0; u < n; u++)\n        if(indegree[u] == 0 && vis[u] == 0)\n            BFS(u);\n}\n\nint main()\n{\n    cin >> n >> e;\n    for(int i = 0; i < n; i++)\n    {\n        vis[i] = 0;\n        indegree[i] = 0;\n    }\n    for(int i = 0; i < e; i++)\n    {\n        int x, y;\n        cin >> x >>y;\n        G[x].push_back(y);\n        indegree[y]++;\n    }\n    topologicalSort();\n    for(int i = 0; i < ans.size(); i++)\n        cout << ans[i] <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <math.h>\n#include <set>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n ; i++)\n#define pb push_back\nstatic const int MAX = 100000;\nstatic const int INF = 1000000;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint main(void){\n  int V,E; cin >> V >> E;\n  vector<int> list[MAX]; int into[E];\n  int a,b;\n  rep(i,E){\n    into[i] = 0;\n  }\n  rep(i,E){\n    cin >> a >> b;\n    list[a].pb(b);\n    into[b] += 1;\n  }\n  queue<int> Q;\n  rep(i,E){\n    if (into[i] == 0) Q.push(i);\n  }\n\n  while(!Q.empty()){\n      cout << Q.front() << endl;\n      rep(i,list[Q.front()].size()){\n        into[list[Q.front()][i]] -= 1;\n        if(into[list[Q.front()][i]] == 0) Q.push(list[Q.front()][i]);\n      }\n\n      Q.pop();\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n\nbool TopologicalSort(vector<vector<pair<int,int>>> &graph, vector<int> &sorted){\n\tvector<int> count(graph.size());\n\tstack<int> currentNode;\n\t\n\tfor(int i = 0; i < graph.size(); i++){\n\t\tfor(pair<int,int> next : graph[i]){\n\t\t\tcount[next.first]++;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < graph.size(); i++){\n\t\tif(!count[i]){\n\t\t\tcurrentNode.push(i);\n\t\t}\n\t}\n\t\n\twhile(!currentNode.empty()){\n\t\tint node = currentNode.top(); currentNode.pop();\n\t\tsorted.push_back(node);\n\t\tfor(pair<int,int> next : graph[node]){\n\t\t\tcount[next.first]--;\n\t\t\tif(count[next.first] == 0) currentNode.push(next.first);\n\t\t}\n\t}\n\t\n\tif(sorted.size() == graph.size()) return true;\n\telse return false;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tvector<vector<pair<int,int>>> graph;\n\tvector<int> sorted;\n\tint V, E;\n\t\n\tcin>>V>>E;\n\t\n\tgraph.resize(V);\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint s, t;\n\t\t\n\t\tcin>>s>>t;\n\t\t\n\t\tgraph[s].push_back(make_pair(t,0));\n\t}\n\t\n\tif(TopologicalSort(graph, sorted)){\n\t\tfor(int y : sorted){\n\t\t\tcout<<y<<endl;\n\t\t}\n\t} else {\n\t\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int tgt_;\n\t  Edge(int t){\n\t\t\ttgt_ = t;\n\t  }\n};\n\ntypedef vector<vector<Edge> > Adj_list;\n\nvector<int> topological_sort(Adj_list& G){\n\n\t  const int V = G.size();\n\n\t  vector<int> S; // ??\\?????????????????????\n\t  vector<int> inorder(V,0); // ??\\?????????????????????\n\t  \n\t  for(int i=0; i<V; i++) for(Edge& e : G[i]) inorder[e.tgt_]++;\n\t  for(int i=0; i<V; i++) if(inorder[i] == 0) S.push_back(i);\n\n\t  assert(S.size() > 0);\n\n\t  vector<int> topological_order;\n\t  while(S.size()){\n\t\t\tint v = S[S.size()-1]; S.pop_back();\n\t\t\ttopological_order.push_back(v);\n\n\t\t\tfor(int i=G[v].size()-1; i>=0; i--){\n\t\t\t\t  Edge e = G[v][i];\t// G[v].pop_back();\n\t\t\t\t  inorder[ e.tgt_ ]--; \n\n\t\t\t\t  if( inorder[e.tgt_] == 0) \tS.push_back( e.tgt_ );\n\t\t\t}\n\t  }\n\t  for(int i=0; i<V; i++) assert(inorder[i]==0);\n\t  return topological_order;\n}\n\n\nint main(){\n\n\t  int V,E; cin >> V >> E;\n\t  Adj_list G(V);\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t; cin >> s >> t;\n\t\t\tG[s].push_back( Edge(t) );\n\t  }\n\t  \n\t  vector<int> ans = topological_sort(G);\n\t  for(int i=0; i<V; i++)\n\t\t\tcout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Topological Sort\n//\n//\n// Description:\n//\n//   Let G = (V, E) be a graph. An ordering ord: [n] -> V is a topological \n//   ordering if i > j then there is no edge from ord[i] to ord[j].\n//   G has a topological ordering if and only if G is DAG.\n//\n//   A topological order can be obtained in O(n + m) time by using\n//   an iterative method (Kuhn's algorithm) or a recursive method \n//   (by Tarjan's algorithm). The following implementation is a \n//   Kuhn's algorithm.\n//\n//   Note that if you want to find the all topological orders,\n//\n//\n// Complexity:\n//\n//   O(n + m)\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\nstruct Graph {\n  int n;\n  vector<vector<int>> adj;\n  Graph(int n) : n(n), adj(n) { }\n  void addEdge(int u, int v) {\n    adj[u].push_back(v);\n  }\n};\n\n// return empty list if g has no topological order\nvector<int> topologicalSort(Graph g) {\n  vector<int> deg(g.n);\n  for (int u = 0; u < g.n; ++u)\n    for (int v: g.adj[u]) ++deg[v];\n  vector<int> stack; \n  for (int u = 0; u < g.n; ++u)\n    if (!deg[u]) stack.push_back(u);\n\n  vector<int> order;\n  while (!stack.empty()) {\n    int u = stack.back(); stack.pop_back();\n    order.push_back(u);\n    for (int v: g.adj[u]) \n      if (!--deg[v]) stack.push_back(v);\n  }\n  return order.size() == g.n ? order : vector<int>();\n}\n\nint main() {\n  int n, m; cin >> n >> m;\n  Graph g(n);\n  for (int i = 0; i < m; ++i) {\n    int u, v; cin >> u >> v;\n    g.addEdge(u, v);\n  }\n  auto ord = topologicalSort(g);\n  for (int i = 0; i < ord.size(); ++i) {\n    if (i > 0) cout << \" \";\n    cout << ord[i];\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint V, E;\nstd::vector<std::vector<int>> link_from;\nstd::vector<int> flag;\n\nvoid search(int idx) {\n    if (flag[idx] != 0) {\n        return;\n    }\n    for (auto i : link_from[idx]) {\n        search(i);\n    }\n\n    flag[idx] = 1;\n    std::cout << idx << std::endl;\n}\n\n\nint main() {\n    std::cin >> V >> E;\n\n    link_from = std::vector<std::vector<int>>(V);\n    flag = std::vector<int>(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        std::cin >> s >> t;\n        link_from[t].emplace_back(s);\n    }\n\n    for (int i = 0; i < V; i++) {\n        if (flag[i] == 0) {\n            search(i);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> edge(V);\n    vector<int> count_in(V);\n    for(int i = 0; i < V; i++){\n        count_in[i] = 0;\n    }\n\n    int s, t;\n    for(int i = 0; i < E; i++){\n        cin >> s >> t;\n        edge[s].emplace_back(t);\n        count_in[t]++;\n    }\n\n    queue<int> q;\n    for(int i = 0; i < V; i++){\n        if(count_in[i] == 0){\n            q.push(i);\n        }\n    }\n\n    vector<int> ans;\n\n    while(!q.empty()){\n        int temp = q.front();\n        q.pop();\n\n        if(count_in[temp] == 0){\n            ans.emplace_back(temp);\n            for(int i = 0; i < (int)edge[temp].size(); i++){\n                int to = edge[temp][i];\n                count_in[to]--;\n                if(count_in[to] == 0){\n                    q.push(to);\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < V; i++){\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// Kahn's algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<pair<int, int>>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back({t, 0});\n                B[t]++;\n        }\n        int edges = E;\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++)\n                if (!B[i])\n                        S.push(i);\n        while (!S.empty()) {\n                auto c = S.front();\n                S.pop();\n                L.push_back(c);\n                for (auto &a: A[c]) {\n                        if (a.second)\n                                continue;\n                        a.second = 1;\n                        edges--;\n                        if (--B[a.first] == 0)\n                                S.push(a.first);\n                }\n        }\n        for (int i = 0; i < V; i++)\n                cout << L[i] << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int N=100000;\nvector<int> g[N];\nlist<int> out;\nbool v[N];\nint n;\nvoid dfs(int u)\n{\n\tv[u]=true;\n\tfor(int i=0;i<g[u].size();i++)\n\t{\n\t\tint s=g[u][i];\n\t\tif(!v[s]) dfs(s);\n\t}\n\tout.push_front(u);\n}\nint main()\n{\n\tint s,t,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++) v[i]=false;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>s>>t;\n\t\tg[s].push_back(t);\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(!v[i]) dfs(i); \n\t}\n\tfor(list<int>::iterator it =out.begin();it!=out.end();it++)\n\t{\n\t\tcout<<*it<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topological_sort (const vector<vector<int>> &g) {\n\tconst int n = g.size();\n\tvector<int> sorted, indeg(n, 0);\n\tvector<bool> processed(n, false);\n\n\tfor (int v = 0; v < n; v++) {\n\t\tfor (int u : g[v]) indeg[u]++;\n\t}\n\n\tfor (int s = 0; s < n; s++) {\n\t\tif (indeg[s] > 0 or processed[s]) continue;\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\tprocessed[s] = true;\n\t\twhile (not que.empty()) {\n\t\t\tint v = que.front();\n\t\t\tque.pop();\n\t\t\tsorted.push_back(v);\n\t\t\tfor (const int &u : g[v]) {\n\t\t\t\tif (--indeg[u] == 0 and not processed[u]) {\n\t\t\t\t\tque.push(u);\n\t\t\t\t\tprocessed[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sorted;\n\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int>> g(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t}\n\t\n\tfor (int v : topological_sort(g)) {\n\t\tcout << v << '\\n';\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const int MAX = 10000;\nstatic const bool NOTV = 0;\nstatic const bool VISIT = 1;\nint v;\n\nvector<int> G[MAX];\nbool visit[MAX];\nlist<int> out;\nvoid dfs(int s) {\n\tvisit[s] = VISIT;\n\tfor (int i = 0; i < G[s].size(); i++) {\n\t\tif (not visit[G[s][i]]) dfs(G[s][i]);\n\t}\n\tout.push_front(s);\n}\n\nvoid topoSort() {\n\tfill(visit, visit + v, NOTV);\n\tfor (int i = 0; i < v; i++) {\n\t\tif (not visit[i]) dfs(i);\n\t}\n}\n\n\nint main() {\n\tint e, s, t;\n\tcin >> v >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttopoSort();\n\twhile (not out.empty()) {\n\t\tcout << out.front() << endl;\n\t\tout.pop_front();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000;\nvector<int>G[N];\nqueue<int>Q;\nlist<int>L;\nlist<int>::iterator it;\nint n,m,deg[N]={0},vis[N]={0};\nvoid top(int i){\n\tQ.push(i);\n\twhile(!Q.empty()){\n\t\tint v=Q.front();Q.pop();\n\t\tvis[v]=1;\n\t\tL.push_back(v);\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u=G[v][i];\n\t\t\tdeg[u]--;\n\t\t\tif(deg[u]==0&&!vis[u]) Q.push(u);\n\t\t}\n\t}\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<n;i++) for(int j=0;j<G[i].size();j++) deg[G[i][j]]++;\n\tfor(int i=0;i<n;i++) if(deg[i]==0&&!vis[i]) top(i);\n\tfor(it=L.begin();it!=L.end();it++) printf(\"%d\\n\",*it);\n\treturn 0;\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\nvoid dfs(vector<vector<int > > g,vector<int>& used,int s){\n\tused[s] = 0;\n\t//auto it = lower_bound(g[s].begin(),g[s].end(),s);\n\t//int k = (int)(it-g[s].begin());\n\t//for(int i=k;g[s].size();i++ ){\n\trep(i,g[s].size()){\n\tif(used[g[s][i]])\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back(s);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<int> used(v,1);\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\tint i = (it-used.begin());\n\t//rep(i,v){\n\t//if(used[i]){\n\twhile(i<=v-1){\n\t\t// int i = it-used.begin();\n\tdfs(g,used,i);\n\t//cout<<i<<endl;\n\tauto it = lower_bound(used.begin(),used.end(),1);\n\t i = (it-used.begin());\n\t//\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\trep(i,e){\n\tsort(g[i].begin(),g[i].end());\n\t}\n\t/*rep(i,e){\n\t\trep(j,g[i].size()){\n\t\t\tcout<<g[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\n\nstruct Graph{\n  int n;\n  vector<vector<int> > edge;\n  vector<int> in_deg;\n  Graph(int n_){\n    n = n_;\n    edge.resize(n);\n    in_deg.resize(n, 0);\n  }\n  void adde(int at, int to){\n    edge[at].push_back(to);\n    in_deg[to]++;\n  }\n  vector<int> topological_sort(){\n    stack<int> st;\n    for(int i = 0; i < n; i++){\n      if(in_deg[i] == 0)st.push(i);\n    }\n    vector<int> res;\n    while(st.size()){\n      int at = st.top(); st.pop();\n      res.push_back(at);\n      for(int j: edge[at]){\n        in_deg[j]--;\n        if(in_deg[j] == 0)st.push(j);\n      }\n    }\n\n    return res;\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  Graph graph(n);\n  rep(i, m){\n    int a, b;\n    cin >> a >> b;\n    graph.adde(a, b);\n  }\n  auto v = graph.topological_sort();\n  rep(i, sz(v))cout << v[i] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint v ,e;\nint sta[10001];\nvector <int> gin[10001],gout[10001],ans;\nqueue <int> Q;\n\nvoid toporogical_sort(){\n  for(int i=0;i<v;i++)\n    if(!gin[i].size())Q.push(i);\n  \n  while(!Q.empty()) {\n    int t = Q.front(); Q.pop();\n    ans.push_back(t);\n \n    for(int i=0;i<gout[t].size();i++){\n      int nx = gout[t][i];\n      int size = gin[nx].size();\n      for(int j=0;j<size;j++)\n\tif(gin[nx][j] == t){\n\t  gin[nx].erase(gin[nx].begin()+j);\n\t  break;\n\t}\n      if(!gin[nx].size()) Q.push(nx);\n    }\n  }\n}\n \n \nint main() {\n  cin >> v >> e;\n   for(int i=0;i<e;i++) {\n    int s,t;\n    cin >> s >> t;\n    gin[s].push_back(t);\n    gout[t].push_back(s);\n   }\n  toporogical_sort();\n  for(int i=ans.size()-1;i>=0;i--) cout << ans[i] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\nint n,m;\nvector<int> E[maxn],ans;\nint vis[maxn];\nint ind[maxn];\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    cin>>n>>m;\n    rep(i,1,m){\n        int x,y;\n        cin>>x>>y;\n        E[x].push_back(y);\n        ind[y]++;\n    }\n    queue<int> Q;\n    rep(i,0,n-1)if(!ind[i])Q.push(i);\n    while(!Q.empty()){\n        int now=Q.front();Q.pop();\n        vis[now]=1;\n        ans.push_back(now);\n        for(auto t:E[now]){\n            if(vis[t])continue;\n            ind[t]--;\n            if(ind[t]==0)Q.push(t);\n        }\n    }\n    for(auto t:ans)cout<<t<<endl;\n    //cout<<endl;\n}\n/* \n6 6\n0 1\n1 2\n3 1\n3 4\n4 5\n5 2\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#define V_MAX 10000\n#define E_MAX 100000\nusing namespace std;\n\nint V,E;\nbool check[V_MAX+1],visited[V_MAX+1];\nqueue<int> G[V_MAX+1];//隣接リスト\nqueue<int> order;\nlist<int> TO,TO_tmp;//最後だけでなく先頭にも要素が追加できる点でやはりlistがベストな選択\n\nvoid bfs(){\n\twhile(!order.empty()){\n\t\tint num = order.front();order.pop();\n\t\tvisited[num] = true;check[num] = true;\n\t\tTO_tmp.push_back(num);\n\t\twhile(!G[num].empty()){\n\t\t\tif(!check[G[num].front()]){\n\t\t\t\torder.push(G[num].front());\n\t\t\t\tcheck[G[num].front()] = true;\n\t\t\t}\n\t\t\tG[num].pop();\n\t\t}\n\t}\n\twhile(!TO_tmp.empty()){\n\t\tTO.push_front(TO_tmp.back());\n\t\tTO_tmp.pop_back();\n\t}\n}\n\n\nvoid solve(){\n\tfor(int i = 0;i < V;i++){check[i] = false;visited[i] = false;}\n\tint vs,ve;\n\tfor(int i = 0;i < E;i++){\n\t\tcin >>vs >>ve;\n\t\tG[vs].push(ve);\n\t}\n\tfor(int i = 0;i < V;i++){if(!visited[i]){order.push(i);bfs();}}\n\twhile(!TO.empty()){cout <<TO.front() <<endl;TO.pop_front();}\n\treturn;\n}\n\nint main(){\n\tcin >>V >>E;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define ARRS int(3e5+600)\n#define BARRS int(2e6+600)\n#define MAX ((long long)(1e17+1))\n#define MMAX ((long long)(1e9+10))\n#define HS1 ((long long)(1000001329))\n#define HS2 ((long long)(1000001531))\n#define MOD ((long long)1000000007)\n#define SQ 31622780\n#define PI 3.14159265358979323846264338327950288419716939937510\n\nvector<ll> v[ARRS];\nvector<ll> pas;\nll fx[ARRS];\nvoid go(ll x){\n    fx[x]--;\n    pas.pb(x);\n    for(auto y:v[x]){\n        fx[y]--;\n        if(!fx[y])go(y);\n    }\n}\n\n\nint main(){\n   #ifdef KHOKHO\n    freopen(\"in.in\",\"r\",stdin);\n    freopen(\"out.out\",\"w+\",stdout);\n   #endif //KHOKHO\n    ll n,m,k,p;\n    cin>>n>>m;\n    for(int i=0; i<m; i++){\n        cin>>k>>p;\n        v[k].pb(p);\n        fx[p]++;\n    }\n\n    for(int i=0; i<n; i++){\n        if(!fx[i])\n            go(i);\n    }\n\n    for(auto x:pas){\n        cout<<x<<\" \";\n    }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 10005\nusing namespace std;\nint n, m;\nint in[N];\nint used[N];\nvector<int> G[N];\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int t = q.front(); q.pop();\n        used[t] = 1;\n        printf(\"%d\\n\", t);\n\n        for(int i = 0; i < G[t].size(); i++){\n            int v = G[t][i];\n            in[v]--;\n            if(in[v] == 0 && !used[v]) q.push(v);\n        }\n    }\n}\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    for(int i = 0; i < n; i++) {in[i] = 0; used[i] = 0;}\n    for(int i = 0; i < m; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        in[b]++;\n        G[a].push_back(b);\n    }\n    for(int i = 0; i < n; i++){\n        if(!used[i] && in[i] == 0) bfs(i);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a)-1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a)-1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cerr << C << endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, e) (s.find(e) != s.end())\n#define EB emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint V, E;\nVII graph;\nVI ans;\nvector <bool> is;\nvoid dfs(int now) {\n    if (is[now]) return;\n    is[now] = true;\n    FORE(el, graph[now]) {\n        dfs(el);\n    }\n    ans.EB(now);\n}\n\nint main(void) {\n    cin >> V >> E;\n    graph.resize(V);\n    is.resize(V, false);\n    set <int> s;\n    REP(i, E) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        graph[a].EB(b);\n        s.insert(a);\n    }\n    REP(i, V) dfs(i);\n    REVERSE(ans);\n    FORE(el, ans) cout << el << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\ntemplate<class T>inline bool chmax(T &a, const T &b){if(a < b){a = b; return 1;}return 0;}\ntemplate<class T>inline bool chmin(T &a, const T &b){if(a > b){a = b; return 1;}return 0;}\ntypedef long long ll;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  // トポロジカルソート\n  int V, E; cin >> V >> E;\n  vector<vector<int> > edge(V, vector<int>());\n  vector<int> h(V, 0);\n  REP(i, E){\n    int x, y; cin >> x >> y;\n    edge[x].push_back(y);\n    h[y]++;\n  }\n  queue<int> q;\n  REP(i, V){\n    if(h[i] == 0) q.push(i);\n  }\n  vector<int> ans;\n  while(!q.empty()){\n    int i = q.front(); q.pop();\n    ans.push_back(i);\n    for(auto j : edge[i]){\n      h[j]--;\n      if(h[j] == 0) q.push(j);\n    }\n  }\n  for(auto &i : ans) cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\nconst int maxv = 100010;\n// 頂点数，辺数\nint v, e;\nvector<int> g[maxv];\nbool used[maxv];\n// トポロジカルソートされた数列\nvector<int> ans;\n\nvoid dfs(int u) {\n    if (used[u]) return;\n    used[u] = true;\n    for (auto& i : g[u]) dfs(i);\n    // 帰りがけ順で追加\n    ans.push_back(u);\n}\n\nvoid tsort() {\n    for (int i=0; i<v; ++i) dfs(i);\n    reverse(ans.begin(), ans.end());\n}\n\nint main() {\n    cin >> v >> e;\n    for (int i=0; i<e; ++i) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n\n    tsort();\n    for (int i: ans) cout << i << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#define N 10000\nusing namespace std;\n\nlist<int> l;\nbool color[N]={false};\nvector<int> adj[N];\nint n;\n\nvoid topo(int k){\n\tfor(int i=0;i<adj[k].size();i++){\n\t\tif(!color[adj[k][i]])topo(adj[k][i]);\n\t}\n\tif(!color[k])l.push_front(k);\n\tcolor[k]=true;\n}\n\nint main(void){\n\tint u,v;\n\tint e;\n\tcin>>n>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!color[i])topo(i);\n\t}\n\tfor(list<int>::iterator it=l.begin();it!=l.end();it++)cout<<*it<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nmap<pair<int,int>,int> mp;\nbool cmp(int i,int j){\n\tif(mp[{j,i}])\n\t\treturn 1;\n\treturn i<j;\n}\nmain(){\n\tint n,m;cin>>n>>m;\n\tvector<int> vec;\n\tfor(int i=0;i<n;i++)\n\t\tvec.push_back(i);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;cin>>x>>y;\n\t\tmp[{x,y}]=1;\n\t}\n\tsort(vec.begin(),vec.end(),cmp);\n\tfor(int i:vec)\n\t\tcout<<i<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool flag;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        flag = 0;\n        id = _id;\n        count = 0;\n    }\n}\n\nvector<vertex> glaph;\nqueue<int> q;\n\nvoid BFS(){\n    if (q.size() == 0) return;\n    int i = q.top();\n    q.pop();\n    if (glaph[i].count == 0]) {\n        cout << glaph[i].id << ' ';\n        glaph[i].count--;\n        glaph[i].flag = 1;\n    }\n    \n    REP1(k,glaph[i].toList.size()){\n        if (!glaph[k].flag) {\n            q.push(glaph[i].toList[k]);\n        }\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[i].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    int  start;\n    REP1(i,V) if(glaph[i].count == 0) start = i;\n    \n    q.push(start);\n    \n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// May this submission get accepted!\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define STEP(i, is, ie, step) for (long long i=(is), i##_end=(ie), i##_step = (step); i<=i##_end; i+=i##_step)\n#define UNIQUE(v) do { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); } while (false)\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return true;} return false; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return true;} return false; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) ((q) ? \"Yes\" : \"No\")\n#define YES(q) ((q) ? \"YES\" : \"NO\")\n#define Possible(q) ((q) ? \"Possible\" : \"Impossible\")\n#define POSSIBLE(q) ((q) ? \"POSSIBLE\" : \"IMPOSSIBLE\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) do { cerr << \"[DEBUG] \" #q \": [\"; REP(i, (q).size()) { cerr << (q)[i] << (i == i_len-1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl; } while (false)\ntemplate<class T> T gcd(T a, T b) { if (a < b) std::swap(a, b); while (b) std::swap(a %= b, b); return a; }\ntemplate<class T> T lcm(const T a, const T b) { return a / gcd(a, b) * b; }\n\n// gcc拡張マクロ\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\n#define DANCE_ long\n#define ROBOT_ unsigned\n#define HUMAN_ signed\n#define CHOKUDAI_ const\nusing  ll = DANCE_ HUMAN_ DANCE_;\nusing ull = DANCE_ ROBOT_ DANCE_;\nusing cll = DANCE_ DANCE_ CHOKUDAI_;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n// Kahn (1962) のアルゴリズムによるトポソ DAGでないものを入れると鼻から悪魔が出る可能性がある\nvector<ll> toposo(const vector<vector<ll>> &g) {\n    ll n = g.size();\n    vector<ll> r; r.reserve(n);\n    vector<ll> indeg(n, 0);\n    for (ll i = 0; i < n; i++) {\n        for (const ll &j : g[i]) {\n            ++indeg[j];\n        }\n    }\n    deque<ll> zerodeg;\n    for (ll i = 0; i < n; i++) {\n        if (!indeg[i]) {\n            zerodeg.push_back(i);\n        }\n    }\n    while (zerodeg.size()) {\n        ll i = zerodeg.front(); zerodeg.pop_front();\n        r.push_back(i);\n        for (const ll &j : g[i]) {\n            if (--indeg[j] == 0) {\n                zerodeg.push_back(j);\n            }\n        }\n    }\n    return r;\n}\n\n// 処理内容\nint main() {\n    \n    // インタラクティブ問題では除去した方がいいかも\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    ll v, e; cin >> v >> e;\n    vector<vector<ll>> g(v);\n    REP(i, e) {\n        ll s, t; cin >> s >> t;\n        g[s].push_back(t);\n    }\n\n    auto tps = toposo(g);\n\n    for (ll i : tps) cout << i << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "// DP F\n\n#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nconst int INF = 1e9;\nconst long long INFL = 1LL<<60;\n\nvoid dump(const vector<pair<int, int>>& a)\n{\n  for (auto v : a) {\n    cerr << v.first << \" \" << v.second << endl;\n  }\n}\n\n////////////////////////////////////////////////////\n\nstatic const int MAX = 100000;\nbool V[MAX];\nlist<int> out;\nvector<int> G[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s)\n{\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    rep(i, G[u].size()) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid topologicalSort()\n{\n  rep(i, N) {\n    indeg[i] = 0;\n  }\n\n  rep(u, N) {\n    rep(i, G[u].size()) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  rep(u, N) {\n    if (indeg[u] == 0 && !V[u]) {\n      bfs(u);\n    }\n  }\n\n  for (auto it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main()\n{\n  int s, t, M;\n  cin >> N >> M;\n  rep(i, N) {\n    V[i] = false;\n  }\n  rep(i, M) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  topologicalSort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\n#define FOR(i,a,n) for(int (i)=(a);(i)<(n);(i)++)\n#define eFOR(i,a,n) for(int (i)=(a);(i)<=(n);(i)++)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; }return 0; }\ninline void init() { cout.tie(nullptr); cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\n\nstruct edge {\n    int from, to; ll cost;\n    edge(int s, int t, ll w = 0) : from(s), to(t), cost(w) {}\n};\n\nint main() {\n    init();\n\n    int v, e;\n    cin >> v >> e;\n    vector<vector<edge>> g(v);\n    VI in(v, 0);\n    int s, t;\n    FOR(i, 0, e) {\n        cin >> s >> t;\n        g[s].push_back({ s,t });\n        in[t]++;\n    }\n\n    queue<int> n;\n    FOR(i, 0, v)if (in[i] == 0)n.push(i);\n\n    VI ans;\n    while (!n.empty()) {\n        int now = n.front(); n.pop();\n        ans.push_back(now);\n        for (edge next : g[now]) {\n            in[next.to]--;\n            if (in[next.to] == 0)n.push(next.to);\n        }\n    }\n\n    FOR(i, 0, v)cout << ans[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nvector<vector<int>> G;\n\nvector<int> topsort(int n, vector<vector<int>> G) {\n  vector<int> vs, indeg(n, 0);\n  rep(v, n) for (int u: G[v]) indeg[u]++;\n  queue<int> q;\n  vector<bool> visited(n, false);\n  rep(i, n) {\n    if (indeg[i] || visited[i]) continue;\n    q.push(i);\n    while (q.size()) {\n      int v = q.front();\n      q.pop();\n      if (visited[v]) continue;\n      vs.push_back(v);\n      visited[v] = true;\n      for (int u: G[v]) {\n        if (visited[u]) continue;\n        if (--indeg[u] == 0 && !visited[u]) q.push(u);\n      }\n    }\n  }\n  return vs;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n, m;\n  cin >> n >> m;\n  G.resize(n);\n  rep(i, m) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  vector<int> ans = topsort(n, G);\n  rep(i, n) cout << ans[i] << '\\n';\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef long long int llint;\n#define MM 1000000000\n#define MOD MM+7\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n#define chmax(a,b) (a<b ? a=b:0)\n#define chmin(a,b) (a>b ? a=b:0)\nconst long double PI = acos(-1);\nconst long long INF = 1e15;\nconst ll DEP = (1LL << 50);\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\ntemplate<typename T>\nT GCD(T x,T y){\n    return y ? GCD(y,x%y) : x;\n}\ntemplate<typename T>\nstring toString( const T &a ){\n    ostringstream oss;\n    oss << a;\n    return oss.str();\n};\nint v,e;\nvector<int> In[10001],Out[10001],ans;\nqueue<int> Q;\n\n\n/* \nvoid toporogical_sort(){\n    for(int i = 0; i < v; i++){\n        if(!In[i].size()) Q.push(i);\n    }\n    while(!Q.empty()){\n        int t = Q.front(); \n        Q.pop();\n        ans.push_back(t);\n        for(int i = 0; i < Out[t].size(); i++){\n            int nx = Out[t][i];\n            int size = In[nx].size();\n            for(int j = 0; j < size; j++){\n                if(In[nx][j] == t){\n                    In[nx].erase(In[nx].begin()+j);\n                    break;\n                }\n            }\n            if(!In[nx].size()) Q.push(nx);\n        }\n    }\n}\n*/\n\n\nvoid toporogical_sort(){\n  for(int i=0;i<v;i++)\n    if(!In[i].size())Q.push(i);\n   \n  while(!Q.empty()) {\n    int t = Q.front(); Q.pop();\n    ans.push_back(t);\n  \n    for(int i=0;i<Out[t].size();i++){\n      int nx = Out[t][i];\n      int size = In[nx].size();\n      for(int j=0;j<size;j++)\n    if(In[nx][j] == t){\n      In[nx].erase(In[nx].begin()+j);\n      break;\n    }\n      if(!In[nx].size()) Q.push(nx);\n    }\n  }\n}\n\nint main(){\n    cin >> v >> e;\n    for(int i = 0; i < e; i++){\n        int s,t; cin >> s >> t;\n        In[s].push_back(t);\n        Out[t].push_back(s);\n    }\n    toporogical_sort();\n    for(int i = ans.size()-1; i >= 0; i--){\n        cout << ans[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Template\n#include <bits/stdc++.h>\n#define INF INT_MAX\n#define MOD 100000007\n#define MAX_E 1000000\n#define MAX_V 1000000\nusing namespace std;\n\nint V, E;\nvector<int> adj[MAX_V];\nint visited[MAX_V];\nstack<int> stk;\nvoid DFS(int u){\n\tvisited[u]=2;\n\tint d=adj[u].size();\n\tfor(int j=0; j<d; ++j){\n\t\tif(visited[adj[u][j]]==2){\n\t\t\tprintf(\"Sandro fails.\");\n\t\t\texit(0);\n\t\t}\n\t\tif(visited[adj[u][j]]==0)\n\t\tDFS(adj[u][j]);\n\t}\n\tvisited[u]=1;\n\tstk.push(u);\n\treturn;\n}\nbool cmp(int i, int j){return i>j;}\nint main(){\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i=0; i<E; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t}\n\tfor(int i=0; i<V; ++i){\n\t\tsort (adj[i].begin(), adj[i].begin()+adj[i].size(), cmp);\n\t}\n\tfor(int i=0; i<V; ++i){\n\t\tif(!visited[i])DFS(i);\n\t}\n\twhile(!stk.empty()){\n\t\tcout<<stk.top()<<endl;\n\t\tstk.pop();\n\t}\n\treturn 0;\n}\n/*\n8 9\n1 4\n1 2\n4 2\n4 3\n3 2\n5 2\n3 5\n8 2\n8 6\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < V; i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0, s = ans.size(); i < s; i++) {\n        int a = ans[i];\n        for (int j = 0, ss = edge[a].size(); j < ss; j++) {\n            int t = edge[a][j];\n            state[t]--;\n            if (state[t] == 0) {\n                ans.push_back(t);\n                s++;\n            }\n        }\n        cout << a << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int u) {\n  queue<int> q;\n  q.push(u);\n  V[u] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n  for (int u = 0; u < N; u++) {\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) bfs(u);\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  tsort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tint *box, *pos;\n\tbox = (int*)malloc(sizeof(int) * V);\n\tpos = (int*)malloc(sizeof(int) * V);\n\tfor(int i = 0; i < V; i++){\n\t\tbox[i] = i;\n\t\tpos[i] = i;\n\t}\n\n\tint from, to;\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\", &from, &to);\n\n\t\tint k = pos[to];\n\t\twhile(pos[to] < pos[from]){\n\t\t\tint tmp = box[k];\n\t\t\tint tmp2 = pos[box[k]];\n\n\t\t\tpos[box[k]] = pos[box[k + 1]];\n\t\t\tbox[k] = box[k + 1];\n\n\t\t\tpos[box[k + 1]] = tmp2;\n\t\t\tbox[k + 1] = tmp;\n\t\t\tk++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(i)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%d\", box[i]);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint color[10000];\nint indeg[10000];\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<vector<int>> g(n);\n  for(int i=0;i<m;++i){\n    int a,b;\n    cin >> a >> b;\n    g[a].emplace_back(b);\n    indeg[b]++;\n  }\n\n  vector<int> out;\n  for(int u=0;u<n;++u){\n    if(indeg[u]==0&&color[u]==0){\n      queue<int> q;\n      q.push(u);\n      color[u] = 1;\n      while(!q.empty()){\n        auto v = q.front();q.pop();\n\n        out.push_back(v);\n        for(const auto &w:g[v]){\n          indeg[w]--;\n          if(indeg[w]==0&&color[w]==0){\n            color[w] = 1;\n            q.push(w);\n          }\n        }\n      }\n    }\n  }\n  for(auto o:out) cout << o << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct Node {\n  std::unordered_set<int> in_edge;\n  std::unordered_set<int> out_edge;\n};\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int v, e;\n  cin >> v >> e;\n  std::vector<Node> node(v);\n  for (int i = 0; i < e; i++) {\n    int from, to;\n    cin >> from >> to;\n    node[from].out_edge.insert(to);\n    node[to].in_edge.insert(from);\n  }\n\n  std::queue<int> search_set;\n  std::vector<int> result;\n\n  for (int i = 0; i < e; i++) {\n    if (node[i].in_edge.empty()) {\n      search_set.push(i);\n    }\n  }\n\n  while (!search_set.empty()) {\n    int tgt = search_set.front();\n    search_set.pop();\n    result.push_back(tgt);\n    for (auto itr = node[tgt].out_edge.begin(); itr != node[tgt].out_edge.end();\n         itr++) {\n      node[*itr].in_edge.erase(tgt);\n      if (node[*itr].in_edge.empty()) {\n        search_set.push(*itr);\n      }\n    }\n  }\n\n  for (auto x : result) {\n    cout << x << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n    int N, M;\n    cin >> N >> M;\n    int s[M], t[M];\n    vector<int> adj[N];\n    for (int i = 0; i < M; i++) {\n        cin >> s[i] >> t[i];\n        adj[s[i]].push_back(t[i]);\n    }\n    int indeg[N]{};\n    int flag[N]{};\n    \n    int dp[N]{};\n    fill(dp, dp + N, -1);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < adj[i].size(); j++) {\n            int u = adj[i][j];\n            indeg[u]++;\n        }\n    }\n    deque<int> q;\n    vector<int> id;\n    for (int i = 0; i < N; i++) {\n        if (indeg[i] == 0 && flag[i] == 0) {\n            q.push_back(i);\n            while (!q.empty()) {\n                int u = q.front();\n                id.push_back(u);\n                q.pop_front();\n                flag[u] = 1;\n                for (int j = 0; j < adj[u].size(); j++) {\n                    int v = adj[u][j];\n                    indeg[v]--;\n                    if (indeg[v] == 0 && flag[v] == 0) {\n                        flag[v] = 1;\n                        q.push_back(v);\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i : id) {\n        cout << i << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct edge{int u,v,cost;};\nint V,E;\nlist<int> out;\nvi G[100005];\nbool visited[100005];\nint N;\nint indeg[100005];\nvoid bfs(int s)\n{\n  queue<int> q;\n  q.push(s);\n  visited[s]=true;\n  while(!q.empty())\n    {\n      int u=q.front();q.pop();\n      out.push_back(u);\n      for(int i=0;i<G[u].size();i++)\n\t{\n\t  int v=G[u][i];\n\t  indeg[v]--;\n\t  if(indeg[v]==0 && !visited[v])\n\t    {\n\t      visited[v]=true;\n\t      q.push(v);\n\t    }\n\t}\n    }\n}\n\nvoid tsort()\n{\n  for(int i=0;i<V;i++)\n    {\n      indeg[i]=0;\n    }\n  for(int u=0;u<V;u++)\n    {\n      for(int i=0;i<G[u].size();i++)\n\t{\n\t  int v=G[u][i];\n\t  indeg[v]++;\n\t}\n    }\n  for(int u=0;u<V;u++) if(indeg[u]==0 && !visited[u]) bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    {\n      cout << *it << endl;\n    }\n}\n\nint main(void)\n{\n  cin >> V >> E;\n  for(int i=0;i<E;i++)\n    {\n      int s,t;\n      cin >> s >> t;\n      G[s].push_back(t);\n    }\n  tsort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nstruct Edge{\n  int to;\n  long long cost;\n};\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nclass dijkstra{\n  public:\n  const int MAX_V = 1000000;\n  vector<Edge> g[100000],rg[100000];\n  bool visit[100000];\n\n  int N;\n  const ll INF = 1e15;\n  dijkstra(){};\n  dijkstra(int n):N(n){};\n  vector<ll> shorter_path(int s){\n    priority_queue<NODE> Q;\n    Q.push({s,0});\n    vector<ll> res(N,INF);\n    while(Q.size()){\n      NODE q= Q.top();Q.pop();\n      if(res[q.pos] == INF){\n        res[q.pos] = q.cost;\n      }\n      else{\n        continue;\n      }\n      for(auto n : g[q.pos]){\n        Q.push({n.to,q.cost+n.cost});\n      }\n    }\n    return res;\n  }\n  void push(int p,int to,int c){\n    g[p].push_back({to,c});\n    rg[to].push_back({p,c});\n  }\n  deque<ll> Topological_sort(){\n    deque<ll> res;\n    rep(i,N){\n      dfs(res,i);\n    }\n    return res;\n  }\n  void dfs(deque<ll> &res,int k){\n    if(!visit[k]){\n      visit[k] = true;\n      for (auto&& nxt : g[k]) {\n        dfs(res,nxt.to);\n      }\n      res.emplace_front(k);\n    }\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll v,e,a,b;\n  cin >> v >> e;\n  dijkstra d(v);\n  rep(i,e){\n    cin >> a >> b;\n    d.push(a,b,0);\n  }\n  auto res = d.Topological_sort();\n  for (auto&& n : res) {\n    std::cout << n << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int MAX = 100000;\nconst int INF = 1<<29;\nvector<int> G[MAX];\nlist<int> out;\nint n;\nbool V[MAX];\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    r(i,G[u].size()){\n      int v=G[u][i];\n      indeg[v]--;\n      if(!indeg[v]&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid Tsort(){\n  r(i,n)indeg[i]=0;\n  r(u,n)r(i,G[u].size())indeg[G[u][i]]++;\n  r(u,n)if(!indeg[u]&&!V[u])bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    cout<<*it<<endl;\n}\nint main(){\n  int s,t,m;\n  cin>>n>>m;\n  r(i,n){\n    V[i]=false;\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  Tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\tfor(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\nif(V!=order.size())return 1;\n\t\t\tfor(i=0;i<V;i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define reps(i, s, n) for(int i=(s); i<=(n); ++i)\n#define outl(x) cout<< (x) << '\\n'\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef const int let;\n\nint V, E;\nvector <int> G[10005];\nbool vis[10005];\nvector <int> out;\n\nvoid bfs(let s, int *indeg)\n{\n   queue <int> que; que.emplace(s);\n   ++indeg[s];\n   while (!que.empty()) {\n      int u = que.front(); que.pop();\n      out.emplace_back(u);\n      for(let x : G[u])\n         if( --indeg[x] == 0 && !vis[x]++ ) que.emplace(x);\n   }\n}\n\nvoid topologial_sort()\n{\n   static int indeg[10005] = {};\n   rep(i, V)\n      for(let x: G[i]) ++indeg[x];\n   rep(i, V)\n      if (indeg[i] == 0 && !vis[i]) bfs(i, indeg);\n\n   for_each(out.cbegin(), out.cend(), [](let x) { outl( x ); });\n}\n\nsigned main()\n{\n   cin.tie(0), ios::sync_with_stdio(false);\n   cin >> V >> E;\n\n   while(E--) {\n      int s, t;\n      cin >> s >> t;\n      G[s].emplace_back(t);\n   }\n\n   topologial_sort();\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n#include<queue>\nusing namespace std;\nstatic const int MAX=100000;\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint n;\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();\n    q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();++i){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0 && !V[v]){\n\tV[v]=true;\n\tq.push(v);\n      }\n    }\n  }\n}\nvoid tsort(){\n  for(int i=0;i<n;++i){ \n    indeg[i]=0; \n  }\n  for(int u=0;u<n;++u){\n    for(int i=0;i<G[u].size();++i){\n      int v=G[u][i];\n      indeg[v]++;\n    }\n  }\n  for(int u=0;u<n;++u) if(indeg[u]==0 && !V[u]) bfs(u);\n  for(list<int>::iterator it =out.begin(); it!=out.end(); ++it){\n    cout<<*it<<endl;\n  }\n}\nint main(){\n  int s,t,M;\n  cin>>n>>M;\n  for(int i=0;i<n;++i){ V[i]=false; }\n  for(int i=0;i<M;++i){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  tsort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    vector<unordered_set<int> > tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    swap(in,tmp);\n    for(int i=0;i<V;i++) if(!tmp[i].empty()) tp.clear(); // exist loop\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.bfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n//#include <iostream>\n//#include<vector>\n//#include<algorithm>\n//#include<queue>\n//#include<list>\n//using namespace std;\n//static const int MAX = 100000;\n//static const int INFTY = (1 << 29);\n//\n//vector<int>G[MAX];\n//list<int>out;\n//bool V[MAX];\n//int indeg[MAX];\n//int N;\n//\n//\n//void bfs(int s) {\n//    queue<int> q;\n//    q.push(s);\n//    V[s] = true;\n//    while (!q.empty()) {\n//        int u = q.front(); q.pop();\n//        out.push_back(u);\n//        for (int i = 0; i < G[u].size(); i++) {\n//            int v = G[u][i];\n//            indeg[v]--;\n//            if (indeg[v] == 0 && !V[v]) {\n//                V[v] = true;\n//                q.push(v);\n//            }\n//        }\n//    }\n//}\n//    \n//\n//void tsort() {\n//    for (int i = 0; i < N; i++) {\n//        indeg[i] = 0;\n//    }\n//    for (int u = 0; u < N; u++) {\n//        for (int i = 0; i < G[u].size(); i++) {\n//            int v = G[u][i];\n//            indeg[v]++;\n//        }\n//    }\n//\n//    for (int u = 0; u < N; u++)\n//        if (indeg[u] == 0 && !V[u])bfs(u);\n//\n//    for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n//        cout << *it << endl;\n//    }\n//}\n//int main()\n//{\n//    int s, t, M;\n//\n//\n//    cin >> N >> M;\n//    for (int i = 0; i < N; i++)V[i] = false;\n//\n//    for (int i = 0; i < M; i++) {\n//        cin >> s >> t;\n//        G[s].push_back(t);\n//    }\n//\n//    tsort();\n//\n//    return 0;\n//\n//}\n\n//dfs ver\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\n\nvoid dfs(int u) {\n\tV[u] = true;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!V[v])dfs(v);\n\n\t}\n\tout.push_front(u);\n\n}\n\nint main() {\n\tint s, t, M;\n\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++)V[i] = false;\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!V[i])dfs(i);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100000\n#define INF (1<<29)\n\nvector<int> G[MAX];\nlist<int> out; //やるべき仕事の順番に入ってるリスト\nbool V[MAX]; //仕事が完了したかどうかを示す配列\nint N; //仕事の数\nint indeg[MAX]; //ノードiに入ってくる有向辺の数\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s); //最初のノードをキューに入れる\n  V[s] = true;\n\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i]; //隣接するノード\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < G[i].size(); j++) {\n      int v = G[i][j];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) bfs(u);\n  }\n\n  for (auto it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) { V[i] = false; }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<21);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    T[s] = true;\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n    for(int u=0; u<N; u++){\n        if(indeg[u]==0 && !V[u]) bfs(u);\n    }\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define MAX_V 10000\nvector<int> G[MAX_V];\n\nvector<int> topologicalSort(vector<int> in_deg){\n    stack<int> st;\n    vector<int> list;\n    int v = in_deg.size();\n    \n    rep(i,v)if(in_deg[i]==0)st.push(i);\n    \n    while(st.size()){\n        int q = st.top();\n        st.pop();\n        list.pb(q);\n        \n        rep(i,G[q].size()){\n            int to = G[q][i];\n            in_deg[to]--;\n            if(in_deg[to]==0)st.push(to);\n        }\n    }\n    \n    if(list.size()!=v){/*????????????*/}\n\n    return list;\n}\n\nint main(){\n    int v,e;\n    cin>>v>>e;\n    vector<int> in_deg(v,0);\n    \n    rep(i,e){\n        int s,t;\n        cin>>s>>t;\n        in_deg[t]++;\n        G[s].pb(t);\n    }\n    vector<int> list = topologicalSort(in_deg);\n    \n    rep(i,list.size())cout<<list[i]<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=10000;\nconst int INF=123456789;\nvector<pair<int,int> > G[MAX];\nlist<int> out;\nint indeg[MAX];\nbool V[MAX];\nint n;\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i].first;\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid toposort(){\n  for(int i=0;i<)\n}\n\nint main(){\n  int e;\n  cin>>n>>e;\n  for(int i=0;i<n;i++){\n    V[i]=false;\n  }\n\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(make_pair(t,1));\n  }\n\n  toposort();\n\n  for(list<int>::iterator p=out.begin();p!=out.end();p++){\n    cout<<*p<<endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n\n#include <limits.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvector<vector<int>> edges;\nvector<bool> visited;\nvector<int> ans;\n\nvoid dfs(int cur) {\n    if (visited[cur]) {\n        return;\n    }\n    for (auto &next : edges[cur]) {\n        dfs(next);\n    }\n    ans.push_back(cur);\n    visited[cur] = true;\n}\n\nint main(void) {\n    int V, E;\n    cin >> V >> E;\n\n    edges.resize(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edges[t].push_back(s);\n    }\n\n    visited.resize(V, false);\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    for (auto v : ans) {\n        cout << v << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000000\nusing namespace std;\n\nqueue<int> S;// ??\\???????????????????????¨???????????????\nvector<int> in[N];// ??\\??????\nvector<int> out[N];// ?????????\nvector<int> G[N];// ??\\?????????????????????????????\\???\n\nvoid init(int V){// ?????°??????????????°\n  for(int i=0;i<V;i++)in[i].clear();\n  for(int i=0;i<V;i++){\n    out[i]=G[i];\n    for(int j=0;j<G[i].size();j++)\n      in[G[i][j]].push_back(i);\n  }\n  for(int i=0;i<V;i++)\n    if(!in[i].size())S.push(i);\n}\n\nvector<int> Topological_Sort(int V){\n  vector<int> res;\n  while(!S.empty()){\n    int pos=S.front(); S.pop();\n    res.push_back(pos);\n    for(int i=0;i<out[pos].size();i++){\n      int nx=out[pos][i];\n      if(in[nx].size()==1)S.push(nx);\n      for(int j=0;j<in[nx].size();j++)\n\tif(pos==in[nx][j]){\n\t  in[nx].erase(in[nx].begin()+j);\n\t  break;\n\t}\n      out[pos].erase(out[pos].begin()+i);\n      i--;\n    }\n  }\n  for(int i=0;i<V;i++)\n    if(in[i].size()||out[i].size())\n      res.clear();\n  return res;\n}\n\nint main(){\n  int v,e,s,t;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  init(v);\n  vector<int> ans=Topological_Sort(v);\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY  (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v] == 0 && !V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor(int i = 0; i < N; i++){\n\t\tindeg[i] = 0;\n\t}\n\n\tfor(int u = 0; u < N; u++){\n\t\tfor(int i = 0; i < G[u].size(); i++){\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor(int u = 0; u < N; u++)\n\t\tif(indeg[u] == 0 && !V[u]) bfs(u);\n\n\tfor(list<int>::iterator it = out.begin(); it != out.end(); it++){\n\t\tcout << *it << endl;\n\t}\n}\n\nint main(void){\n\tint s, t, M;\n\n\tcin >> N >> M;\n\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstatic const int MaxV = 10000;\n\nint AdjL[MaxV][MaxV];\nint OutDegree[MaxV];\nint InDegree[MaxV];\nqueue<int> Q;\n\nint main() {\n\tint V, E;\n\tint s, t;\n\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; i++) {\n\t\tOutDegree[i] = InDegree[i] = 0;\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tAdjL[s][OutDegree[s]++] = t;\n\t\tInDegree[t]++;\n\t}\n\tfor (int i = 0; i < V; i++) {\n\t\tif (InDegree[i] == 0) {\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\twhile (Q.empty() == false) {\n\t\ts = Q.front();\n\t\tQ.pop();\n\t\tcout << s << endl;\n\t\tfor (int i = 0; i < OutDegree[s]; i++) {\n\t\t\tt = AdjL[s][i];\n\t\t\tif (--InDegree[t] == 0) {\n\t\t\t\tQ.push(t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nclass ans\n{\npublic:\n    int a,i;\n};\nvector<int> cn[10001];\nint chk[10001],now=1;\nans num[10001];\nint dfs(int n)\n{\n    if(chk[n]>0) return 0;\n    int tmp=cn[n].size();\n    for(int i=0;i<tmp;i++)\n    {\n        dfs(cn[n][i]);\n    }\n    chk[n]=now++;\n    return 0;\n}\nbool cmp(ans a,ans b)\n{\n    return a.i>b.i;\n}\nint main()\n{\n    int v,e,x,y;\n    scanf(\"%d%d\",&v,&e);\n    for(int i=0; i<=v; i++)\n    {\n        num[i].a=i;\n    }\n    for(int i=0; i<e; i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        cn[x].push_back(y);\n    }\n    for(int i=0; i<v; i++)\n    {\n        if(chk[i]==0)\n        {\n            dfs(i);\n        }\n    }\n    for(int i=0; i<v; i++) num[i].i=chk[i];\n    sort(num,num+v,cmp);\n    for(int i=0; i<v; i++) printf(\"%d\\n\",num[i].a);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nVI g[100010];\nint h[100010];\nsigned main(void)\n{\n  int v, e;\n  cin >> v >> e;\n  REP(i, e) {\n    int s, t;\n    cin >> s >> t;\n    g[s].push_back(t);\n    h[t]++;\n  }\n\n  stack<int> st;\n\n  REP(i, v) if(h[i] == 0) st.push(i);\n\n  VI ans;\n  while(st.size()) {\n    int i = st.top(); st.pop();\n    ans.push_back(i);\n    for(auto& j: g[i]) {\n      h[j]--;\n      if(h[j] == 0) st.push(j);\n    }\n  }\n\n  for(int i: ans) cout << i << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n    vector<int> g[v];\n    int h[v + 1];\n    memset(h, 0, sizeof(h));\n    int a, b;\n    for (int i = 0; i < e; ++i) {\n        cin >> a >> b;\n        g[a].push_back(b);\n        h[b]++;\n    }\n\n    queue<int> que;\n    for (int i = 0; i < v; ++i) {\n        if (h[i] == 0) {\n            que.push(i);\n        }\n    }\n\n    vector <int> ans;\n    while (!que.empty()) {\n        int p = que.front();\n        que.pop();\n        ans.push_back(p);\n        for (auto c: g[p]) {\n            h[c]--;\n            if(h[c] == 0) {\n                que.push(c);\n            }\n        }\n    }\n\n    for (int i = 0; i < v; ++i) {\n        cout << ans[i] << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nvoid vprint(vector<ll> A){\n    ll L = A.size();\n    FOR(i, 0, L){\n        if(i) cout << ' ';\n        cout << A[i];\n    }\n    cout << endl;\n}\n\nVI topological_sort(VV& G){\n    ll N = G.size();\n    \n    // 入次数\n    VI IN(N, 0);\n    REP(i, N){\n        for(ll to : G[i]){\n            IN[to]++;\n        }\n    }\n\n    stack<ll> st; // 入次数0のものを入れる\n    REP(i, N){\n        if(IN[i]==0) st.push(i);\n    }\n\n    VI ret;\n    while(!st.empty()){\n        ll i = st.top();\n        st.pop();\n        ret.push_back(i);\n        for(ll to : G[i]){\n            IN[to]--;\n            if(IN[to]==0){\n                st.push(to);\n            }\n        }\n    }\n\n    // 成功したか確認\n    for(ll in : IN){\n        if(in!=0){\n            // 失敗（DAGじゃなかった）\n            VI empty_vector;\n            return empty_vector;\n        }\n    }\n    // 正常の戻り値\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll V, E;\n    cin >> V >> E;\n\n    VV G;\n    G.resize(V);\n\n    REP(i, E){\n        ll s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    auto A = topological_sort(G);\n    for(ll a : A){\n        p(a);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector<int> in(n), res, vis(n);\n    for(auto &es : g) for(auto &e : es) in[e.dst]++;\n    for(int i = 0; i < n; ++i){\n        if(in[i] || vis[i]) continue;\n        queue<int> q;\n        q.push(i); vis[i] = true; res.push_back(i);\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e : g[v]){\n                int d = e.dst;\n                --in[d];\n                if(in[d] || vis[d]) continue;\n                q.push(d); vis[d] = true; res.push_back(d);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    assert((int)ord.size() == n);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\n\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T> void bfs(const vector<vector<T>>& G, int i, vector<bool>& seen, vector<T>& in_dgree, vector<T>& ans) {\n    queue<int> q;\n    q.push(i);\n    seen[i] = true;\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        ans.push_back(v);\n        for (auto u : G[v]) {\n            --in_dgree[u];\n            if ((!seen[u]) && in_dgree[u] == 0) {\n                q.push(u);\n                seen[u] = true;\n            }\n        }\n    }\n}\n\ntemplate <typename T> void topological_sort(const vector<vector<T>>& G, vector<T>& in_dgree) {\n    int v = G.size();\n    vector<bool> seen(v, false);\n    vector<T> ans;\n    rep(i, 0, v) {\n        if ((!seen[i]) && in_dgree[i] == 0) { bfs(G, i, seen, in_dgree, ans); }\n    }\n    for (auto v : ans) { cout << v << endl; }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vvi G(v);\n    vi in_dgree(v, 0);\n    rep(i, 0, e) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n        ++in_dgree[t];\n    }\n    // for (auto v : in_dgree) { cout << v << endl; }\n\n    topological_sort(G, in_dgree);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvector<vector<int>>G;\nlist<int>out;\nvector<bool>V;\nint N;\nvector<int>indeg;\n\nvoid bfs(int s) {\n\tqueue<int>q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tindeg = vector<int>(N, 0);\n\trep(u, 0, N) {\n\t\trep(i, 0, G[u].size()) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\trep(u, 0, N) {\n\t\tif (indeg[u] == 0 && !V[u])bfs(u);\n\t}\n\teach(it,out)cout << *it << endl;\n}\nsigned main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\tV = vector<bool>(N, false);\n\trep(i, 0, M) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nstatic const int MAX = 10000;\nvector<int> G[MAX];\nint indegs[MAX];\nbool visited[MAX];\n\nvoid visit(int x) {\n  cout << x << endl;\n  visited[x] = true;\n}\n\nvoid bfs(int start) {\n  queue<int> q;\n  q.push(start);\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (auto t : G[u]) {\n      indegs[t]--;\n      if (indegs[t] == 0 && !visited[t])\n        q.push(t);\n    }\n    visit(u);\n  }\n}\n\nint main() {\n  int nv, ne;\n  cin >> nv >> ne;\n  for (int i = 0; i < nv; i++) {\n    indegs[i] = 0;\n    visited[i] = false;\n  }\n\n  for (int i = 0; i < ne; i++) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);\n    indegs[t]++;\n  }\n\n  for (int i = 0; i < nv; i++) {\n    if (indegs[i] == 0 && !visited[i])\n      bfs(i);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 1);\n//0: edge[i].secondに載っているため設定できない\n//1: 設定できる状態\n//2: すでに設定済みなので除外\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] != 2) state[i] = 1;\n        }\n        for (int i = 0; i < edge.size(); i++) {\n            state[edge[i].second] = 0;\n        }\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 1) {\n                ans.push_back(i);\n                state[i] = 2;\n                for (int j = 0; j < edge.size(); j++) {\n                    if (edge[j].first == i) {\n                        edge[j] = edge.back();\n                        edge.pop_back();\n                        j--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i = 0; i < N; i++){\n        indeg[i] = 0;\n    }\n    \n    for(int u = 0; u < N; u++){\n        for(int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    \n    for(int u = 0; u < N; u++){\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n    }\n    \n    for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s, t, M;\n    \n    cin >> N >> M;\n    \n    for(int i = 0; i < N; i++) V[i] = false;\n    \n    for(int i = 0; i < M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れれるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\tint from, to;\n\tll cost;\n\n\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b; \n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) { \n\t\ta = b;\n\t\treturn true; \n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<class T>void swap(T &a, const T &b) {\n\tT tmp = a;\n\ta = b;\n\tb = a; \n\treturn;\n}//aとbを入れ替える\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) { \n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head); \n\tfor (auto& v : vec) { resize(v, tail...);}\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll POW_MOD(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {//最小公倍数\n\treturn a * b / gcd(a, b);\n}\nint mergecount(vector<int> &a) {\n\t//反転数(バブルソートの交換回数)を数える\n\tint count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += mergecount(b);\n\t\tcount += mergecount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nbool  Warshall_Floyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\n\nbool topological_sort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> articulationPoint(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tll w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\n\n\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<edge>> g(V);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tg[s].emplace_back(s, t, 0);\n\t}\n\n\tvector<int> ans;\n\tif (topological_sort(g, ans)) {\n\t\tfor (auto x : ans) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << 1 << endl;\n\t}\n\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#include <cstdio>\n\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repc(i, s, n) for (int i = (s); i <= (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define rrepc(i, s, n) for (int i = (s); i >= (n); i--)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nvector<int> DAG[10000];\nvector<int> ans;\nbool done[10000] = { false };\nint indeg[10000] = { 0 };\n\nint main()\n{\n\tint V, E;\n\tint s, t;\n\tqueue<int> Q;\n\n\tcin >> V >> E;\n\trep(i, E) {\n\t\tcin >> s >> t;\n\t\tDAG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\n\trep(i, V) {\n\t\tif (indeg[i] == 0 && !done[i]) {\n\t\t\tQ.push(i);\n\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ts = Q.front(); Q.pop();\n\t\t\t\tdone[s] = true;\n\t\t\t\tans.push_back(s);\n\n\t\t\t\trep(j, DAG[s].size()) {\n\t\t\t\t\tt = DAG[s][j];\n\t\t\t\t\tindeg[t]--;\n\n\t\t\t\t\tif (indeg[t] == 0 && !done[t]) {\n\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, ans.size()) cout << ans[i] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nconst int MAX = 100000;\nconst int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort() {\n\tfor (int i = 0; i < N; i++)\n\t\tindeg[i] = 0;\n\tfor (int u = 0; u < N; u++)\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (indeg[u] == 0 && !V[u]) bfs(u);\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tcout << *it << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint s, t, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++)\n\t\tV[i] = false;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttoposort();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tvector<int> order;\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\ttopologicalSort(g,order);\n\t\tfor(i=0;i<order.size();i++){\n\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[12000];int n,m,a,b,dist[12000],c[12000];\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){cin>>a>>b;x[a].push_back(b);c[b]++;}\n\tqueue<int>Q;for(int i=0;i<n;i++){if(c[i]==0)Q.push(i);}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int i=0;i<x[a1].size();i++){\n\t\t\tif(dist[x[a1][i]]<dist[a1]+1){\n\t\t\t\tdist[x[a1][i]]=dist[a1]+1;Q.push(x[a1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){if(c[j]==i)cout<<j<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    vector<vector<int>> adj(v, vector<int>());\n    vector<int> indeg(v, 0);\n    for (int i = 0; i < e; i++) {\n        int s, t;\n        cin >> s >> t;\n        adj[s].push_back(t);\n        indeg[t]++;\n    }\n\n    queue<int> q;\n    for (int i = 0; i < v; i++) {\n        if (indeg[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector<int> ans;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        ans.push_back(u);\n        for (auto v : adj[u]) {\n            indeg[v]--;\n            if (indeg[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    for (auto u : ans) {\n        cout << u << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int MAX = 100000;\nconst int INF = 1<<29;\nvector<int> G[MAX];\nlist<int> out;\nint n;\nbool V[MAX];\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    r(i,G[u].size()){\n      int v=G[u][i];\n      indeg[v]--;\n      if(!indeg[v]&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid Tsort(){\n  r(u,n)r(i,G[u].size())indeg[G[u][i]]++;\n  r(u,n)if(!indeg[u]&&!V[u])bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    cout<<*it<<endl;\n}\nint main(){\n  int s,t,m;\n  cin>>n>>m;\n  r(i,n){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  Tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX = 10000;\nvector<int> G[MAX];\n\nvector<int> ans;\n\nbool visited[MAX];\n\nvoid dfs(int u) {\n\n\tvisited[u] = true;\n\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\tint next = G[u][i];\n\t\tif (visited[next] == false) {\n\t\t\tdfs(next);\n\t\t}\n\t}\n\tans.push_back(u);\n}\n\nint main() {\n\n\tint v, e;\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tvisited[i] = false;\n\t}\n\n\tfor (int i = 0; i < e; ++i) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tG[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < v; ++i) {\n\t\tif (visited[i] == false)\n\t\t\tdfs(i);\n\t}\n\n\tfor (auto itr = ans.rbegin(); itr != ans.rend(); ++itr) {\n\t\tcout << *itr << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> u[10010];\nint n,m,t[10010],d[10010];\nvoid dfs(int p){\n\tcout<<p<<\"\\n\";\n\tfor(int i=0;i<u[p].size();i++){\n\t\td[u[p][i]]++;\n\t\tif(d[u[p][i]]==t[u[p][i]]){\n\t\t\tdfs(u[p][i]);\t\n\t\t\td[u[p][i]]=1008610086;\n\t\t}\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tu[a].push_back(b);\n\t\tt[b]++;\n\t}\n\tfor(int i=0;i<n;i++) if(t[i]==0) dfs(i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct edge { int to; edge(int to) : to(to) {} };\n\nint scc(const VV<edge>& g, V<>& comp) {\n  int n = g.size();\n  VV<edge> rg(n); for (int i = 0; i < n; i++) for (auto&& e : g[i]) rg[e.to].push_back(i);\n  V<> vs;\n  V<bool> vis(n);\n  comp.resize(n);\n\n  function<void(int)> dfs = [&](int v) {\n    vis[v] = true;\n    for (auto&& e : g[v]) if (!vis[e.to]) dfs(e.to);\n    vs.push_back(v);\n  };\n\n  function<void(int, int)> rdfs = [&](int v, int k) {\n    vis[v] = true;\n    comp[v] = k;\n    for (auto&& e : rg[v]) if (!vis[e.to]) rdfs(e.to, k);\n  };\n\n  for (int v = 0; v < n; v++) if (!vis[v]) dfs(v);\n  vis.assign(n, false);\n  int k = 0;\n  reverse(vs.begin(), vs.end());\n  for (auto&& v : vs) if (!vis[v]) rdfs(v, k++);\n  return k;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  VV<edge> g(n);\n  for (int i = 0; i < m; i++) {\n    int a, b; cin >> a >> b;\n    g[a].emplace_back(b);\n  }\n  V<> comp;\n  scc(g, comp);\n  V<> res(n);\n  for (int i = 0; i < n; i++) res[comp[i]] = i;\n  for (int i = 0; i < n; i++) cout << res[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool queued;\n    bool flag;\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        queued = 0;\n        flag = 0;\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                glaph[j].flag = 1;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            glaph[i].flag = 1;\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\tfor(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\nif(V!=order.size())return 1;\n\t\t\tfor(i=0;i<order.size();i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <deque>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nvoid topological_sort(vector<vector<int>> G, deque<int>& ans) {\n    vector<bool> seen(G.size());\n\n    function<void(int)> visit;\n    visit = [&](auto key) {\n        if (seen[key])\n            return;\n        seen[key] = true;\n        for (auto x : G[key]) {\n            if (seen[x]) {\n                continue;\n            }\n            visit(x);\n        }\n        ans.push_front(key);\n    };\n\n    for (int i = 0; i < G.size(); ++i) {\n        visit(i);\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    deque<int> ans;\n    topological_sort(G, ans);\n    for (auto x : ans) {\n        cout << x << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int tgt_;\n\t  int weight_;\n\t  Edge(int t){\n\t\t\ttgt_ = t;\n\t  }\n};\n\ntypedef vector<vector<Edge> > Adj_list;\n\n\n\n\nvoid visit(int v, vector<int>& topological_order, vector<int>& used, Adj_list& G){\n\n\t  if( used[v] != 0 ) return;\n\t  used[v] = 1;\n\n\t  for( Edge& e : G[v] ){\n\t\t\tvisit(e.tgt_, topological_order, used, G);\n\t  }\n\t  topological_order.push_back(v);\n}\n\nvector<int> toporogical_sort(Adj_list& G){\n\n\t  vector<int> topological_order;\n\t  vector<int> used(G.size()+1,0);\n\n\t  for(int i=0; i<G.size(); i++){\n\t\t\tvisit(i,topological_order,used,G);\n\t  }\n\t  reverse(topological_order.begin(),topological_order.end());\n\t  return topological_order;\n}\n\nint main(){\n\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_list G(V);\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t; cin >> s >> t;\n\t\t\tG[s].push_back(Edge(t));\n\t  }\n\t  vector<int> ans = toporogical_sort(G);\n\t  for(int i=0; i<V; i++)\n\t\t\tcout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int WHITE = 0;\nstatic const int BLACK = 1;\n\nint n, e;\nint indeg[MAX], color[MAX];\nvector<int> L[MAX];\nvector<int> vec;\n\nvoid bfs(int u) {\n\tfor (int i = 0; i < L[u].size(); i++) {\n\t\tint v = L[u][i];\n\t\tindeg[v]--;\n\t\tif (indeg[v] == 0) {\n\t\t\tcolor[v] = BLACK;\n\t\t\tvec.push_back(v);\n\t\t\tbfs(v);\n\t\t}\n\t}\n}\n\nvoid TopoligicalSort() {\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (color[i] == WHITE && indeg[i] == 0) {\n\t\t\tcolor[i] = BLACK;\n\t\t\tvec.push_back(i);\n\t\t\tbfs(i);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> e;\n\tint s, t;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcolor[i] = WHITE;\n\t}\n\n\tfor (int i = 0; i < e; i++)\t{\n\t\tcin >> s >> t;\n\t\tindeg[t]++;\n\t\tL[s].push_back(t);\n\t}\n\n\tTopoligicalSort();\n\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (i) cout << ' ';\n\t\tcout << vec[i];\n\t}\n\tcout << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\nvoid printv(vector<vector<int> > g){\n    int si = g.size();\n    for (int i = 0; i < si; ++i) {\n        for (int j = 0; j < si; ++j) {\n            cout << g[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid printq(queue<int> que){\n    int si = que.size();\n    int tmp;\n    queue<int> k = que;\n    for (int i = 0; i < si; ++i) {\n        tmp = k.front();\n        cout << tmp << \" \";\n        k.pop();\n    }\n    cout << endl;\n}\n\nint main() {\n    int v, e, s_tmp, t_tmp, tmp;\n    cin >> v >> e;\n    vector<vector<bool> > g(v, vector<bool> (v,0));\n    vector<int> ans;\n    vector<int> v_n(v, 0);\n    for (int i = 0; i < e; ++i) {\n        cin >> s_tmp >> t_tmp;\n        g[s_tmp][t_tmp] = 1;\n        ++v_n[t_tmp];\n    }\n    //printv(g);\n    queue<int> que;\n    for (int i = 0; i < v; ++i) {\n        if(v_n[i] == 0) {\n            que.push(i);\n        }\n    }\n    while(!que.empty()){\n        //printq(que);\n        tmp = que.front();\n        que.pop();\n        ans.push_back(tmp);\n        for (int i = 0; i < v; ++i) {\n            if(g[tmp][i] == 1){\n                g[tmp][i] = 0;\n                --v_n[i];\n                if(!v_n[i]) {\n                    que.push(i);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < v-1; ++i) {\n        cout << ans[i] << \" \" << endl;\n    }\n    cout << ans[v-1] << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF INT32_MAX\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tvector<vector<int>> g( V );\n\tvector<int> indeg( V );\n\tvector<int> color( V );\n\tfor( int i = 0; i < E; i++ ) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].push_back( t );\n\t\tindeg[t]++;\n\t}\n\n\tvector<int> out;\n\tfor( int i = 0; i < V; i++ ) {\n\t\tif( color[i] || indeg[i] ) continue;\n\t\tqueue<int> que;\n\t\tque.push( i );\n\t\tcolor[i] = 1;\n\t\twhile( !que.empty() ) {\n\t\t\tint u = que.front();\n\t\t\tque.pop();\n\t\t\tout.push_back( u );\n\t\t\tfor( int v : g[u] ) {\n\t\t\t\tindeg[v]--;\n\t\t\t\tif( indeg[v] || color[v] ) continue;\n\t\t\t\tcolor[v] = 1;\n\t\t\t\tque.push( v );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( int i = 0; i < out.size(); i++ ) {\n\t\tcout << out[i] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> node[10010];\nbitset<10010> vis;\nint n,m;\nvoid dfs(int k)\n{\n\tvector<int>::iterator v;\n\tif(vis[k])\n\t\treturn ;\n\tcout<<k<<endl;\n\tvis[k]=1;\n\tv=node[k].begin()+1;\n\tif(v==node[k].end())\n\t\treturn ;\n\tfor(; v!=node[k].end(); ++v)\n\t{\n\t\tnode[*v][0]--;\n\t\tif(node[*v][0]==0)\n\t\t\tdfs(*v);\n\t}\n\treturn ;\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=0; i<n; ++i)\n\t\tnode[i].push_back(0);\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tint r1,r2;\n\t\tcin>>r1>>r2;\n\t\tnode[r2][0]++;\n\t\tnode[r1].push_back(r2);\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tif(node[i][0]==0)\n\t\t\tdfs(i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V, E;\nvector<set<int>> redge;\n\nset<int> memo;\nvoid topological_sort(int u) {\n  if(memo.count(u)) return;\n  memo.insert(u);\n  for(int v: redge[u]) topological_sort(v);\n  cout << u << endl;\n}\n\nint main() {\n  cin >> V >> E;\n  redge.resize(V);\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    redge[v].insert(u);\n  }\n  for(int i = 0; i < V; ++i) topological_sort(i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAX = 10010;\nint V, E;\nvector<int> G[MAX];\nint dig[MAX];\n\nvoid init(int V, int E) {\n    for (int i = 0; i < V; i++) {\n        G[i].clear();\n        dig[i] = 0;\n    }\n\n    for (int i = 0; i < E; i++) {\n        int from, to;\n        scanf(\"%d %d\", &from, &to);\n        G[from].push_back(to);\n        dig[to]++;\n    }\n}\n\nvoid topSort(vector<int> &ans) {\n    queue<int> Q;\n    for (int i = 0; i < V; i++) {\n        if (dig[i] == 0) {\n            Q.push(i);\n        }\n    }\n    while (!Q.empty()) {\n        int t = Q.front();\n        Q.pop();\n        ans.push_back(t);\n        for (int i = 0; i < G[t].size(); i++) {\n            int to = G[t][i];\n            dig[to]--;\n            if (dig[to] == 0) {\n                Q.push(to);\n            }\n        }\n    }\n}\n\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    scanf(\"%d %d\", &V, &E);\n    init(V, E);\n    vector<int> ans;\n    topSort(ans);\n    for (int i = 0; i < ans.size(); i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> M[10000];\nvector<int> m[10000];\nint mark[10000]={0};\n\nint main(){\n  int V;\n  int E;\n  int s,t;\n  cin >> V >> E;\n  for(int i=0;i<E;i++){\n    cin >> s >> t;\n    M[s].push_back(t);\n    m[t].push_back(s);\n  }\n\n  for(int i=0;i<V;i++){\n    for(int j=0;j<V;j++){\n      if(m[j].size()==0&&mark[j]!=1){\n        mark[j]=1;\n        cout << j <<endl;\n        for(int k=0;k<M[j].size();k++){\n          for(int l=0;l<m[M[j][k]].size();l++){\n            if(m[M[j][k]][l]==j){\n              m[M[j][k]].erase(m[M[j][k]].begin() + l);\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t i64;\ntypedef uint64_t ui64;\n\nclass graph{\npublic:\n    struct adj{\n        int index;\n        int start;\n        int to;\n        i64 cost;\n    };\n    int nd;\n    int eg;\n    vector<adj> *node;\n    vector<adj> edge;\n    graph(int n,int m){\n        nd=n;\n        eg=m;\n        node=new vector<adj>[nd]{};\n        edge={};\n    }\n    void add_dir(int i,int s,int t,i64 c){\n        node[s].push_back({i,s,t,c});\n        edge.push_back({i,s,t,c});\n    }\n    void add_undir(int i,int s,int t,i64 c){\n        node[s].push_back({i,s,t,c});\n        node[t].push_back({i,t,s,c});\n        edge.push_back({i,s,t,c});\n    }\n    void refr(void){\n        for(int i=0;i<nd;i++) vector<adj>().swap(node[i]);\n        delete[] node;\n        vector<adj>().swap(edge);\n    }\n    bool IsLink(void);\n    void DFS(int r,i64 *&p,bool *&vst);\n    bool IsPlus(void);\n    void BellmanFord(int s,i64 *&d);\n    void Dijkstra(int s,i64 *&d);\n    void BFS(int s,i64 *&d);\n    void WarshallFloyd_dir(i64 **&d);\n    void WarshallFloyd_undir(i64 **&d);\n    i64 WMST_dir(int r);\n    i64 WMST_undir(void);\n    void Edmonds(int r,vector<adj> &p);\n    void Kruscal(vector<adj> &p);\n    void Prim(vector<adj> &p);\n    void Artic(vector<int> &p);\n    void Artic_sub(int r,int &k,int par,vector<int> &p,int *&ord,int *&low,bool *&vst);\n    void Bridge(vector<adj> &p);\n    void Bridge_sub(int r,int &k,int par,vector<adj> &p,int *&ord,int *&low,bool *&vst);\n    void SCC(int *&c);\n    void SCC_sub1(int r,vector<int> &vs,bool *&vst);\n    void SCC_sub2(int r,int k,int *&c,bool *&vst,graph &rg);\n    bool IsDAG(void);\n    bool IsDAG_sub(int r,int &k,int *&l,int *&vst);\n    void TopolSort(int *&l);\n    void TopolSort_sub(int r,int &k,int *&l,bool *&vst);\n    void Cumul(int s,i64 *&d);\n};\n\nvoid graph::TopolSort(int *&l){\n    bool *vst=new bool[nd]{};\n    int k=0;\n    for(int i=0;i<nd;i++){\n        if(!vst[i]) TopolSort_sub(i,k,l,vst);\n    }\n    stack<int> stk;\n    for(int i=0;i<nd;i++) stk.push(l[i]);\n    for(int i=0;i<nd;i++){\n        l[i]=stk.top();\n        stk.pop();\n    }\n    delete[] vst;\n}\n\nvoid graph::TopolSort_sub(int r,int &k,int *&l,bool *&vst){\n    if(!vst[r]){\n        vst[r]=1;\n        for(const auto &i:node[r]){\n            if(!vst[i.to]) TopolSort_sub(i.to,k,l,vst);\n        }\n        l[k]=r;\n        k++;\n    }\n}\n\nint main(void){\n    int v,e;\n    scanf(\"%i%i\",&v,&e);\n    graph g(v,e);\n    int s,t;\n    for(int i=0;i<e;i++){\n        scanf(\"%i%i\",&s,&t);\n        g.add_dir(i,s,t,1);\n    }\n    int *l=new int[v];\n    g.TopolSort(l);\n    for(int i=0;i<v;i++){\n        printf(\"%i\\n\",l[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author:zeke\n    \n    pass System Test!\n    GET AC!!\n*/\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <bitset>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(), (x).end()\n#define rep3(var, min, max) for (ll(var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll(var) = (max)-1; (var) + 1 > (min); --(var))\n#define Mp(a, b) make_pair((a), (b))\n#define F first\n#define S second\n#define Icin(s) \\\n    ll(s);      \\\n    cin >> (s);\n#define Scin(s) \\\n    ll(s);      \\\n    cin >> (s);\ntemplate <class T>\nbool chmax(T &a, const T &b)\n{\n    if (a < b)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b)\n{\n    if (b < a)\n    {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef vector<V> VV;\ntypedef vector<P> VP;\nll mod = 1e9 + 7;\nunsigned long long MOD = 1e9 + 7;\nll INF = 1e18;\nll v, e;\nVV gragh;\nV in_num;\nvoid dfs(ll x)\n{\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> v >> e;\n    gragh.resize(v);\n    in_num.resize(v);\n    rep(i, e)\n    {\n        ll x, y;\n        cin >> x >> y;\n        gragh[x].push_back(y);\n        in_num[y]++;\n    }\n    queue<ll> q;\n    rep(i, v)\n    {\n        if (in_num[i] == 0)\n            q.push(i);\n    }\n    V result;\n    while (!q.empty())\n    {\n        ll x = q.front();\n        q.pop();\n        result.push_back(x);\n        rep(i, gragh[x].size())\n        {\n            in_num[gragh[x][i]]--;\n            if (in_num[gragh[x][i]] == 0)\n            {\n                q.push(gragh[x][i]);\n            }\n        }\n    }\n    rep(i,v){\n        cout << result[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\n\nconst int MAX = 100000;\nconst int INFTY = (1<<29);\n\nstd::vector<int> G[MAX];\nstd::list<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s)\n{\n    std::queue<int> q;\n    q.push(s);\n    V[s] = true;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        out.push_back(u);\n\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v]) {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort()\n{\n    for (int i = 0; i < N; i++) {\n        indeg[i] = 0;\n    }\n\n    for (int u = 0; u < N; u++) {\n        for (int i = 0; i < G[u].size(); i++) {\n            int v = G[u][i];\n            indeg[v]++;            \n        }\n    }\n\n    for (int u = 0; u < N; u++) {\n        if (indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n    for (std::list<int>::iterator it = out.begin(); it != out.end(); it++) {\n        std::cout << *it << std::endl;\n    }\n}\n\nint main()\n{\n    int s, t, M;\n\n    std::cin >> N >> M;\n\n    for (int i = 0; i < N; i++) V[i] = false;\n\n    for (int i = 0; i < M; i++) {\n        std::cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int maxV = 10005;\n\nvector<int> to[maxV];\n\nbool visited[maxV];\nvoid dfs(int i, vector<int>& ans) {\n    if (visited[i]) return;\n    visited[i] = true;\n    for (int e : to[i]) {\n        dfs(e, ans);\n    }\n    ans.push_back(i);\n}\n\nsigned main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    int V, E;\n    cin >> V >> E;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        to[s].push_back(t);\n    }\n    vector<int> ans;\n    for (int i = 0; i < V; i++) {\n        dfs(i, ans);\n    }\n    for (int i = V - 1;  i>= 0; i--) {\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int tgt_;\n\t  int weight_;\n\t  Edge(int t){\n\t\t\ttgt_ = t;\n\t  }\n};\n\ntypedef vector<vector<Edge> > Adj_list;\n\n\n\n\nvoid visit(int v, vector<int>& topological_order, vector<int>& used, Adj_list& G){\n\n\t  if( used[v] != 0 ) return;\n\t  used[v] = 1;\n\n\t  for( Edge& e : G[v] ){\n\t\t\tvisit(e.tgt_, topological_order, used, G);\n\t  }\n\t  topological_order.push_back(v);\n}\n\nvector<int> toporogical_sort(Adj_list& G){\n\n\t  vector<int> topological_order;\n\t  vector<int> used(G.size()+1,0);\n\n\t  for(int i=0; i<G.size(); i++){\n\t\t\tvisit(i,topological_order,used,G);\n\t  }\n\t  reverse(topological_order.begin(),topological_order.end());\n\t  return topological_order;\n}\n\nint main(){\n\n\t  int V,E;\n\t  cin >> V >> E;\n\t  Adj_list G(V);\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t; cin >> s >> t;\n\t\t\tG[s].push_back(Edge(t));\n\t  }\n\t  vector<int> ans = toporogical_sort(G);\n\t  for(int i=0; i<V; i++)\n\t\t\tcout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i] || U[i])\n                        continue;\n                S.push(i);\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        U[c] = true;\n                        L.push_back(c);\n                        for (auto a: A[c])\n                                if (--B[a] == 0)\n                                        S.push(a);\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define REP(i, n) for(decltype(n) i = 0; i < (n); i++)\n#define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++)\n#define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++)\n#define RREP(i, n) for (decltype(n) i = (n) - 1; i >= 0; i--)\n\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nusing namespace std;\n\n// N, E, S, W\nconst int dx[4] = { 1, 0, -1, 0};\nconst int dy[4] = { 0, 1, 0, -1};\n\nusing LL = long long int;\nusing LD = long double;\n\nconst int INF = (1 << 30) - 1;\nconst LL INF64 = ((LL)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nusing pii = pair<int, int>;\nusing pll = pair<LL, LL>;\nusing pdd = pair<double, double>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vl = vector<LL>;\nusing vvl = vector<vl>;\nusing vvvl = vector<vvl>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\n\n//==============================================\nint v, e;\nvvi G;\nvi indeg;\n\nvoid solve() {\n\tqueue<int> q;\n\n\tREP(i, v) {\n\t\tif (indeg[i] == 0) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\n\t\tcout << u << \"\\n\";\n\n\t\tREP(i, G[u].size()) {\n\t\t\tindeg[G[u][i]]--;\n\n\t\t\tif (indeg[G[u][i]] == 0) {\n\t\t\t\tq.push(G[u][i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> v >> e;\n\n\tG.resize(v);\n\tindeg.resize(v);\n\n\tREP(i, v) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint N, E;\nint g[10000][10000];\nvector<int> out;\nchar col[10000];\n\nvoid toposort(int s) {\n    stack<int> chain;\n    col[s] = 'g';\n    chain.push(s);\n    while(!chain.empty()) {\n        int now = chain.top();\n        int hasnext = false;\n        for (int i = 0; i < N; ++i) {\n            if(g[now][i] && col[i] == 'w') {\n                chain.push(i);\n                col[i] = 'g';\n                hasnext = true;\n                break;\n            }\n        }\n        if(!hasnext) {\n            col[now] = 'b';\n            chain.pop();\n            out.push_back(now);\n        }\n\n    }\n\n}\nint main() {\n    cin >> N >> E;\n    for (int i = 0; i < E; ++i) {\n        int s, t ;\n        cin >> s >> t;\n        g[s][t] = 1;\n    }\n\n    for (int j = 0; j < N; ++j) {\n        col[j] = 'w';\n    }\n    for (int k = 0; k < N; ++k) {\n        int sum = 0;\n        for (int i = 0; i < N; ++i) {\n            sum += g[i][k];\n        }\n        if(!sum && col[k] == 'w') {\n\n            toposort(k);\n        }\n    }\n\n    for (int l = N-1; l >=0; --l) {\n        if(l != N-1) cout << \" \";\n        cout << out.at(l) ;\n    }\n    cout <<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\n\nstatic const int MAX=100000;\n\nvector<int>G[MAX];\nlist<int>out;\nbool V[MAX];\nint N,M;\n\nvoid dfs(int u)\n{\n\tV[u]=true;\n\t\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif(!V[v])dfs(v);\n\t}\n\tout.push_front(u);\n} \n\nint main()\n{\n\tint s,t,w;\n\t\n\tcin>>N>>M;\n\t\n\tfor(int i=0;i<N;i++)\n\tV[i]=false;\n\t\n\tfor(int i=0;i<M;i++)\n\t{\n\tcin>>s>>t;\n\tG[s].push_back(t);\n\t}\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(!V[i])dfs(i);\n\t}\n\t\n\tfor(list<int>::iterator it=out.begin();it!=out.end();it++)\n\t{\n\t\tcout << *it << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nusing cEdges=std::vector<std::vector<int>>;\n\nvoid sort_by_dfs_helper(int root,const cEdges& Edges,vector<bool>& IsVisit,vector<int>& Ans,int& index){\n\tIsVisit[root]=true;\n\n\tfor(const auto& val:Edges[root]){\n\t\tif(!IsVisit[val]){\n\t\t\tsort_by_dfs_helper(val,Edges,IsVisit,Ans,index);\n\t\t}\n\t}\n\n\tAns[index]=root;\n\tif(index>0)--index;\n}\nvector<int> sort_by_dfs(const cEdges& Edges){\n\tif(Edges.empty())return vector<int>();\n\n\tvector<bool> IsVisit(Edges.size(),false);\n\tvector<int> Ans(Edges.size(),-1);\n\tint index=Ans.size()-1;\n\tfor(int i=0;i<IsVisit.size();++i){\n\t\tif(!IsVisit[i]){\n\t\t\tsort_by_dfs_helper(i,Edges,IsVisit,Ans,index);\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main() {\n\tint N,M;\n\tcin>>N>>M;\n\tcEdges Edges(N);\n\tfor(int i=0;i<M;++i){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tEdges[u].push_back(v);\n\t}\n\n\tauto ans=sort_by_dfs(Edges);\n\n\tfor(const auto& val:ans){\n\t\tcout<<val<<\"\\n\";\n\t}\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: Samson\n* @Date:   2018-06-28 21:51:36\n* @Last Modified by:   Samson\n* @Last Modified time: 2018-06-28 23:03:03\n*/\n//   @URL : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n\n#include<bits/stdc++.h>\n#include<algorithm>\n#include <queue>\n#include<vector>\n#include<list>\n#include <cstdlib>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 1e4+10;\n\nvector<int> g[MAXN];\nlist<int> l;\nint in[MAXN],vis[MAXN];\n \nvoid bfs(int s)\n{\n\tqueue<int> que;\n\tque.push(s);\n\tvis[s] = 1;\n\twhile(que.size())\n\t{\n\t\tint u = que.front();\n\t\tque.pop();\n\t\tl.push_back(u);\n\t\tfor(int i = 0; i < g[u].size(); ++i)\n\t\t{\n\t\t\tint v = g[u][i];\n\t\t\t--in[v];\n\t\t\tif(!in[v] && !vis[v])\n\t\t\t{\n\t\t\t\tque.push(v);\n\t\t\t\tvis[v] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(int n)\n{\n\tfor(int u = 0; u < n; ++u)\n\t{\n\t\tif(!in[u] && !vis[u])\n\t\t\tbfs(u);\n\t}\n\tfor(list<int>::iterator it = l.begin(); it != l.end(); ++it)\n\t\tcout<<*it<<'\\n';\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(false); \n\t//cin.tie(0);\n\tint v,e,s,t;\n\tcin>>v>>e;\n\tfor(int i = 1; i <= e; ++i)\n\t{\n\t\tcin>>s>>t;\n\t\tg[s].push_back(t);\n\t\t++in[t];\n\t}\n\n\tsolve(v);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\nusing namespace std;\nconst int INF=INT_MAX;\n\nvector< int > G[100000];\nlist< int > out;\nbool V[100000];\nint N;\nint indeg[100000];\n\nvoid bfs(int s){\n    queue< int > q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        out.push_back(u);\n        REP(i,G[u].size()){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    REP(i,N){\n        indeg[i]=0;\n    }\n\n    REP(u,N){\n        REP(i,G[u].size()){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    REP(u,N) if(indeg[u]==0&&!V[u]) bfs(u);\n\n    for(auto it=out.begin();it!=out.end();++it) printf(\"%d\\n\",*it);\n}\n\nint main(){\n    int s,t,M;\n\n    scanf(\"%d%d\",&N,&M);\n\n    REP(i,N) V[i]=false;\n\n    REP(i,M){\n        scanf(\"%d%d\",&s,&t);\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint n, m;\nstd::vector<int> g[100001];\nstd::vector<int> l;\nint used[100001];\nbool isClose = false;\n\n//??????????????????\nvoid topologicalSort(int n){\n\tif (used[n] == 1){\n\t\tisClose = true;\n\t\treturn;\n\t}\n\telse if (!used[n]){\n\t\tused[n] = 1;\n\t\trep(i, g[n].size())topologicalSort(g[n][i]);\n\t\tl.push_back(n);\n\t\tused[n] = 2;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> m;\n\trep(i, m){\n\t\tint a, b;\n\t\tstd::cin >> a >> b;\n\t\tg[a].push_back(b);\n\t}\n\n\trep(i, n)if (!used[i])topologicalSort(i);\n\tstd::reverse(l.begin(), l.end());\n\trep(i, l.size())std::cout << l[i] << std::endl;;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 0);\n\n    for (int i = 0; i < E; i++) {\n        state[edge[i].second]++;\n    }\n    for (int i = 0; i < state.size(); i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        for (int j = 0; j < edge.size(); j++) {\n            if (edge[j].first == ans[i]) {\n                state[edge[j].second]--;\n                if (state[edge[j].second] == 0) {\n                    ans.push_back(edge[j].second);\n                }\n                edge[j] = edge.back();\n                edge.pop_back();\n                j--;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class T>\nstruct Edge {\n    int to;\n    T cost;\n    Edge(int to, T cost) : to(to), cost(cost){};\n};\n\ntemplate <class T>\nclass Graph {\npublic:\n    explicit Graph(int N = 0) : size(N) { path.resize(size); }\n    void span(int u, int v, T cost = 1) { path[u].push_back(Edge<T>(v, cost)); }\n    vector<Edge<T>> operator[](int v) const { return path[v]; }\n\n    int size;\n    vector<vector<Edge<T>>> path;\n};\n\ntemplate <class T>\nclass TopologicalSort {\npublic:\n    int size;\n    Graph<T> graph;\n    vector<bool> visited;\n    vector<int> order, id;\n    // トポロジカルソート後において、頂点vはid[v]番目\n\n    void dfs(int v) {\n        if (visited[v]) return;\n        visited[v] = true;\n        for (const auto& e : graph[v]) dfs(e.to);\n        order.push_back(v);\n    }\n\n    explicit TopologicalSort(const Graph<T>& g) : size(g.size), graph(g) {\n        visited.assign(size, false);\n        for (int v = 0; v < size; ++v) dfs(v);\n        reverse(order.begin(), order.end());\n\n        id.resize(size);\n        for (int i = 0; i < size; ++i) id[order[i]] = i;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    Graph<int> graph(N);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph.span(u, v);\n    }\n\n    TopologicalSort<int> ts(graph);\n    for (int v : ts.order) cout << v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define MAXN 10000+2\nint topo[MAXN],n,m,t;\nint c[MAXN];\nvector<int> map1[MAXN];\nvoid input(){\n\tcin>>n>>m;\n\tint xx,yy;\n\tfor(int i=0;i<m;++i){\n\t    cin>>xx>>yy;\n\t    map1[xx].push_back(yy);\n\t}\n}\nvoid dfs(int u){\n\tc[u]=-1;\n\tfor(int i=0;i<map1[u].size();++i){\n\t\tif(!c[map1[u][i]]) dfs(map1[u][i]);\n\t}\n\tc[u]=1;\n\ttopo[--t]=u;\n}\nvoid jl(){\n\tt=n;\n\tfor(int i=n-1;i>=0;--i){\n\t\tif(!c[i]) dfs(i);\n\t}\n\tfor(int i=0;i<n-1;++i){\n\t\tcout<<topo[i]<<\" \";\n\t}\n\tcout<<topo[n-1]<<endl;\n}\nint main(){\n\tinput();\n\tjl();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> topological_sort(const vector<vector<int>>& g) {\n    int n = g.size();\n    vector<int> tpl, indeg(n, 0);\n    vector<bool> seen(n, false);\n    for (int i = 0; i < n; i++) {\n        for (auto v : g[i]) indeg[v]++;\n    }\n    for (int s = 0; s < n; s++) {\n        if (indeg[s] == 0 && !seen[s]) {\n            queue<int> que; que.emplace(s); seen[s] = true;\n            while (!que.empty()) {\n                int u = que.front(); que.pop(); tpl.emplace_back(u);\n                for (int i = 0; i < g[u].size(); i++) {\n                    int v = g[u][i]; indeg[v]--;\n                    if (indeg[v] == 0 && !seen[v]) {\n                        seen[v] = true; que.emplace(v);\n                    }\n                }\n            }\n        }\n    }\n    if (tpl.size() != n) tpl.clear();\n    return tpl;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n        int s, t;\n        scanf(\"%d%d\", &s, &t);\n        g[s].emplace_back(t);\n    }\n    \n    vector<int> ans = topological_sort(g);\n    for (auto v : ans) printf(\"%d\\n\", v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#define MAXV 10005\n#define MAXE 100005\nusing namespace std;\n\nint N,E;\nbool V[MAXV];\nvector<int> G[MAXV],out;\nint indeg[MAXV];\n\nvoid bfs(int u){\n    queue<int> q;\n    q.push(u);\n    V[u]=true;\n    int i;\n    while(!q.empty()){\n        int a=q.front();q.pop();\n        out.push_back(a);\n        for(i=0;i<G[a].size();i++){\n            int v=G[a][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[i]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n     int i;\n     for(i=0;i<N;i++){\n        if(!V[i]&&indeg[i]==0){\n            bfs(i);\n        }\n     }\n     for(vector<int>::iterator it=out.begin();it!=out.end();it++)cout<<*it<<endl;\n}\n\nint main(){\n    cin>>N>>E;\n    int i,j;\n    for(i=0;i<E;i++){\n        int a,b;\n        cin>>a>>b;\n        G[a].push_back(b);\n    }\n\n    memset(indeg,0,sizeof(indeg));\n    for(i=0;i<N;i++)V[i]=false;\n    for(i=0;i<N;i++){\n        for(j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    tsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\n// ans[i] = (i番目の頂点v, swapできる頂点をまとめたときにvが何番目か)\nvector<PII> tsort(vector<vector<ll>> g) {\n    const int n = g.size();\n    vector<ll> h(n);\n    REP(i, n) for(int j: g[i]) h[j]++;\n\n    stack<PII> st;\n    REP(i, n) if(h[i] == 0) st.push({i, 0});\n\n    vector<PII> ans;\n    while(st.size()) {\n        PII p = st.top(); st.pop();\n        ans.push_back(p);\n        for(auto& j: g[p.first]) {\n            h[j]--;\n            if(h[j] == 0) st.push({j, p.second+1});\n        }\n    }\n\n    return ans;\n}\n\nsigned main(void) {\n    ll n, m;\n    cin >> n >> m;\n    vector<vector<ll>> g(n);\n    REP(i, m) {\n        ll u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n    }\n\n    auto ans = tsort(g);\n    for(auto p: ans) cout << p.first << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nvrrtll==???>;::::~~~~~~......`.`````````````````````...-?777!_.._?7u,~~~::::;>>??=lllttrrzu\nrtll==??>>;::::~~~~......`.`````````````````` ..J77!`````````...`..._T,~~~~:::;;>??==lttrrv\ntll=??>>;:::~~~~......``````````````````..J7^ ` ``  ` `` .,```````...._4,.~~~::;;>>?===lttr\nl=???>;;::~~~......`````HTSu,.``  `..J7!    `      `` .J\"~N```````````..?&.~~~~::;;>>?==llt\n=??>;;::~~~~.....``````.@????7SJ.?=     `     ` `` .J=....J;  ``````````..h..~~~~::;;>??=ll\n?>>;::~~~~.....````````.D?>>?>?>?8+.``         `.J\"_......_b`     ````````.S_.~~~~::;;>??=l\n>;;::~~~~....``````````.C>??>>>?>>>?8J.`  ```..Y~..........J;  `  ` ``````` G...~~~~::;>??=\n;;::~~~....```````` `..W1>>?>>>>?>>>>>?S,.`.7^.............-N``  `   ``````` 6...~~~~::;>??\n;:~~~~....``````` ..7` d??>>?>?>>?>>?>>1udMgggNNNNggJ.......([          `````.L...~~~~::;>?\n:~~~.....`````` .7`   `K>?>?>>>>>>+ugNMMMB\"\"7<!~~<?7TWMNNa,..w.`  ` `  ` `````,)....~~:::;>\n~~~....``````.J^     ` #>>?>>>?jgMMM9=_................-?TMMa,b` `   `  `  ````(,...~~~~:;;\n~~~....``` .7``   `    @?>>?1uMM#=.........................(TMNa......  ` ``````4....~~~::;\n~~~...`` .=`` `     ` .b>>jgNH\".................`.............?HNmx??17TYY9SA+(..L....~~~::\n~....` ,^``     `   ` .b+dN#^............6..-(,-...`............(HMm+>>>>>?>>????zOM_.~~~::\n.... .=```  `` `   ...JNMM^..........`..._n.(MMN,....`..`.........?MNe<>>?>??>????d^...~~~:\n~...v```` ` ..-Z\"\"!_..(M@_........`........?7MMMMp.................-TNN+?>>>????1d4-..-(Jk9\n..(^`...zY\"!_........(MD..............`......JMMMMp....`..`..`......./MNx>??>>?1d!.h7=~(??=\n(v_`,R_.............(NF..(/..(&,...`..........?MMMM;..................(MMs>>?1&T\"!``....(1=\nt..`` 4,...........(N@....?,(NMNR_.....`..`....(WMM$..`....`..`..`....._HMe7=```````....~_1\n...````.4,........-dM:.....(7MMMNR-.....................`............(.?^ ``  ``````....~~~\n...``````,4,....`.(NF........(MMMMb..`....--................`....(.7!        `  ````....~~:\n..````` ` `.5J_...JMt.........?NMMM[...`.HH5._(J7[...`...`...--?^`          ` `````....~~~:\n...````` `  ` 7a,.dM{....`...../MMMN......(J=`  .>......._(/=             `  ` `````...~~~:\n....```` ``     (4MN{..........._7\"^...(/^    `.C....-(J=`                  ` ` ```....~~~:\n....````` `      JdM[...`...`........`_3..  ..?!..(-7!                  ` ` ``````....~~~::\nr...``````  ` ``(CJMb..............`......__..-(?^                     `  `  `````....~~::;\nJ/...````` `  `,3>+MN-.`..`...`..........._(J=``                     `  ` ```````....~~~::;\n_j,..`.```` ``.5>>?dNb...`......`......_-?'`                            `  `````....~~~::;;\n~~j,..```````.D??>>>MM/....`........(-=`                          `  ` ` ```````...~~~:::;>\n~~~j,...````.E??>??>?MN-.........(J=                            `   ` ` ``````....~~~~::;??\n:~~~?,...``.@>?>?>>??dMN_....-(?^                        `  `    ` `  ````````...~~~~:;;>??\n::~~~?/....K??????>>?>dMN-_(7!                               `  ` ` ````````....~~~:::>>??l\n;:::~~/e.(K==?????????<dM\"!                          `    `   ` ` `` ``````...~~~~:::;>??=l\n*/\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define ok1 printf(\"ok1\\n\");\n#define ok2 printf(\"ok2\\n\");\n#define M 1000000000000000000LL\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,s,n) for(int i=(s);i<(n);++i)\n#define repr(i,n) for(int i=n-1;i>=0;--i)\n#define REPR(i,s,n) for(int i=(s);i>=(n);--(i))\n#define all(a) (a).begin(),(a).end()\n#define reall(a) (a).rbegin(),(a).rend()\n#define pb emplace_back //emplace_backの方が速いが使い慣れてないため\n#define pf push_front\n#define MIN(a,b) a=min((a),(b))\n#define MAX(a,b) a=max((a),(b))\n#define SIZE(v) (int)v.size()\n#define DOUBLE fixed << setprecision(15)\n#define fi first\n#define se second\n#define mp make_pair\nconst double pi = acos(-1.0);\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<double> vd;\ntypedef vector<bool> vb;\ntypedef deque<ll> dll;\ntypedef pair<ll, ll> P;\ntypedef vector<P> vP;\nconst ll mod = 1e9 + 7;\n//const ll mod = 998244353;\nll dy[4] = { 1,0,-1,0 };\nll dx[4] = { 0,1,0,-1 };\nstruct edge {\n\tint to;\n\tint cost;\n};\nbool out_check(ll a, ll b) {\n\tif (0 <= a && a < b) return true;\n\telse return false;\n}\nvoid Pvll(vll v) {\n\tcout << \"vll------------------------------------------------\\n\";\n\trep(i, v.size()) cout << v[i] << \" \";\n\tcout << endl;\n\tcout << \"------------------------------------------------\\n\";\n}\nvoid Pvvll(vvll v) {\n\tcout << \"vvll------------------------------------------------\\n\";\n\trep(i, v.size()) {\n\t\trep(j, v[i].size()) {\n\t\t\tcout << v[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"------------------------------------------------\\n\";\n}\n\nvoid Ps(string s) {\n\tcout << \"str------------------------------------------------\\n\";\n\trep(i, s.size()) cout << s[i] << \" \";\n\tcout << endl;\n\tcout << \"------------------------------------------------\\n\";\n}\n\nvoid Pvs(vs s) {\n\tcout << \"vs------------------------------------------------\\n\";\n\trep(i, s.size()) {\n\t\trep(j, s[i].size()) {\n\t\t\tcout << s[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"------------------------------------------------\\n\";\n}\n\nvoid Yes(bool x) {\n\tif (x) cout << \"Yes\\n\";\n\telse cout << \"No\\n\";\n}\n\nvoid YES(bool x) {\n\tif (x) cout << \"YES\\n\";\n\telse cout << \"NO\\n\";\n}\n\nvoid yes(bool x) {\n\tif (x) cout << \"yes\\n\";\n\telse cout << \"no\\n\";\n}\n\nvoid Yay(bool x) {\n\tif (x) cout << \"Yay!\\n\";\n\telse cout << \":(\\n\";\n}\n\nll  n, m, d, r, l, k, h, ans, ret = M;\nbool flag = false, flag2 = false, flag3 = false;\nstring s, t, u;\n\nvoid INIT() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n}\n\nvoid addmod(ll &a, ll &b) {\n\ta = (a + b) % mod;\n}\n\nstruct TopologicalSort {\n\tvector< set<ll> > G;\n\tvector<ll> used, indeg, ps;\n\n\tTopologicalSort() {}\n\tTopologicalSort(int n) :G(n), used(n, 0), indeg(n, 0) {}\n\n\tvoid add_edge(ll s, ll t) {\n\t\tG[s].emplace(t);\n\t\tindeg[t]++;\n\t}\n\n\tvoid bfs(ll s) {\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\tused[s] = 1;\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tps.emplace_back(v);\n\t\t\tfor (int u : G[v]) {\n\t\t\t\tindeg[u]--;\n\t\t\t\tif (indeg[u] == 0 && !used[u]) {\n\t\t\t\t\tused[u] = 1;\n\t\t\t\t\tque.emplace(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<ll> build() {\n\t\tll n = G.size();\n\t\tfor (int i = 0; i<n; i++)\n\t\t\tif (indeg[i] == 0 && !used[i]) bfs(i);\n\t\treturn ps;\n\t}\n};\n\nint main() {\n\tcin >> n >> m;\n\tTopologicalSort g(n);\n\trep(i, m) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg.add_edge(a, b);\n\t}\n\tvll an = g.build();\n\tfor (auto p : an) cout << p << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <deque>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\ntemplate<class T> inline bool chmax(T& a, T b) {if (a<b) {a=b; return true;} return false;}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a>b) {a=b; return true;} return false;}\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = 1e18;\n\nvvll graph;\nV<bool> visited;\nll n;\nvll indeg;\nvll toposo;\n\nvoid bfs(ll i) {\n  queue<ll> q; q.push(i);\n  visited[i] = true;\n  while (!q.empty()) {\n    ll to = q.front(); q.pop();\n    toposo.push_back(to);\n    REP(i, graph[to].size()) {\n      ll v = graph[to][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !visited[v]) {\n        visited[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  REP(i, n) indeg[i] = 0;  // 入次数の初期化\n  REP(i, n) REP(j, graph[i].size()) indeg[graph[i][j]]++;\n  REP(i, n) if (indeg[i]==0 && !visited[i]) bfs(i);\n  REP(i, toposo.size()) cout << toposo[i] << endl;\n}\n\nint main() {\n  ll s, t, m;\n  cin >> n >> m;\n  visited.resize(n); indeg.resize(n);\n  graph.resize(n);\n  REP(i, n) visited[i] = false;\n  REP(i, m) {\n    cin >> s >> t;\n    graph[s].push_back(t);\n  }\n  tsort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 6;\nconst ll LLINF = 1e18 + 1;\n\nstruct DAG {\nprivate:\n    struct Edge {\n        int to;\n    };\n    std::vector<std::vector<Edge>> graph;\n    bool is_dag = false;\n    std::vector<int> sorted; // トポロジカルソート\n    int V; // 頂点数\npublic:\n\n    DAG(int v) {\n        assert(v > 0);\n        V = v;\n        graph.resize(v);\n    }\n\n    // from から to への有向辺を張る\n    void add_edge(int from, int to) {\n        graph[from].push_back({to});\n    }\n\n    // トポロジカルソート O(V + E)\n    // DAG じゃないなら size 0 の vectorを返す\n    std::vector<int> topological_sort() {\n        std::stack<int> sta;\n        //std::vector<int> dist(V, 0);//その頂点までの最長路\n        std::vector<int> in(V, 0);// 入次数\n        int used_cnt = 0;//使用した頂点の数\n        for (int i = 0; i < V; i++) {\n            for (Edge e : graph[i]) {\n                in[e.to]++;\n            }\n        }\n        for (int i = 0; i < V; i++) if (in[i] == 0) {\n            sta.push(i);\n            used_cnt++;\n        }\n        while (!sta.empty()) {\n            int p = sta.top(); sta.pop();\n            sorted.push_back(p);\n            for (Edge e : graph[p]) {\n                int v = e.to;\n                in[v]--;\n                //dist[v] = std::max(dist[v], dist[p] + 1);\n                if (in[v] == 0) {\n                    sta.push(v);\n                    used_cnt++;\n                }\n            }\n        }\n        if (used_cnt == V) {\n            return sorted;\n        }\n        else {\n            return std::vector<int>(0);\n        }\n    }\n\n    vector<Edge>& operator[](int x) {\n        return graph[x];\n    }\n};\n\nint main() {\n    int v, e; cin >> v >> e;\n    DAG G(v);\n    REP(i, e) {\n        int s, t; scanf(\"%d %d\", &s, &t);\n        G.add_edge(s, t);\n    }\n    for (auto &v : G.topological_sort()) {\n        cout << v << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 0);\n\n    for (int i = 0; i < E; i++) {\n        state[edge[i].second]++;\n    }\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 0) {\n                ans.push_back(i);\n                for (int j = 0; j < edge.size(); j++) {\n                    if (edge[j].first == i) {\n                        state[edge[j].second]--;\n                        edge[j] = edge.back();\n                        edge.pop_back();\n                        j--;\n                    }\n                }\n                state[i]--;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// DFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint dfs(vector<vector<int>> &A, vector<bool> &U, vector<int> &R, int c)\n{\n        if (U[c])\n                return -1;\n        if (R[c])\n                return R[c];\n        U[c] = true;\n        int m = 0;\n        for (auto a: A[c]) {\n                int d = dfs(A, U, R, a);\n                if (d < 0) {\n                        m = -2;\n                        break;\n                }\n                m = max(m, d);\n        }\n        U[c] = false;\n        R[c] = ++m;\n        return m;\n}\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n        }\n        bool cyc = false;\n        vector<bool> U(V);\n        vector<int> R(V);\n        for (int i = 0; i < V; i++) {\n                if (!R[i] && dfs(A, U, R, i) < 0) {\n                        cyc = true;\n                        break;\n                }\n        }\n        if (cyc) {\n                cout << \"Found cyclic path\" << endl;\n                return 0;\n        }\n        vector<int> P(V);\n        iota(P.begin(), P.end(), 0);\n        sort(P.begin(), P.end(), [&](int x, int y) { return R[x] > R[y]; });\n        for (auto p: P)\n                cout << p << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <forward_list>\n#include <queue>\n\nusing namespace std;\n\nint cnt = 0;\nint cntp = 0;\n\nqueue<int> source;\nvector<int> pre;\nvector<int> in;\n\nclass Edge{\npublic:\n  int v;\n  int w;\n  Edge(int vi,int wi):v(vi),w(wi){;}\n};\n\nclass Graph{\npublic:\n    int V;\n    int E;\n    vector<forward_list<int>> adj_list;\n    Graph(int v,int e):V(v),E(e){\n        adj_list.resize(V);\n        pre.resize(V);\n        in.resize(V);\n        for(int i = 0; i < V;i++) {pre[i] = -1;in[i] = 0;}\n    }\n    void addEdge(int v,int w){\n        adj_list[v].push_front(w);\n    }\n};\n\nint main(){\n    int V,E,v,w;\n    scanf(\"%d %d\",&V,&E);\n    Graph G(V,E);\n    for(int i = 0; i < V;i++){\n        scanf(\"%d %d\",&v,&w);\n        G.addEdge(v,w);\n        in[w]++;\n    }\n\n    for(int i = 0; i < V;i++){\n        if(!in[i]) source.push(i);\n    }\n    while(!source.empty()){\n        int j = source.front();\n        pre[j] = 0;\n        printf(\"%d\\n\",j);\n        source.pop();\n        for(auto a = G.adj_list[j].begin();a!=G.adj_list[j].end();++a){\n            int v = *a;\n            if(pre[v] == -1){\n               if(--in[v] == 0)\n                    source.push(v);\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Topological Sort\n\n// ???????????¨?????±?????????????????? DAG\n\n// library\n#include<unordered_map>\n// using\n// template<typename Label, typename Weight>\n// using Graph = std::unordered_map<Label, std::unordered_map<Label, Weight>>;\ntypedef std::unordered_map<int, std::unordered_map<int, int>> Graph;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\ntemplate <typename T>\nusing Vec = std::vector<T>; // Template Alias\n\nVec<int> v; // OK: std::vector<int> v; ??¨??????\nvector<int> topological_sort(const Graph& reverse, int current, unordered_set<int>& unvisited) {\n  vector<int> result = {current};\n  unvisited.erase(current);\n  if(reverse.count(current)) for(const auto& e: reverse.at(current)) {\n    if(unvisited.count(e.first)) {\n      auto add = topological_sort(reverse, e.first, unvisited);\n      result.insert(begin(result), begin(add), end(add));\n    }\n  }\n  return result;\n}\nvector<int> topological_sort(const Graph& g) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  Graph reverse;\n  for(const auto& list: g) for(const auto& e: list.second) {\n    reverse[e.first][list.first] = e.second;\n    unvisited.insert(list.first);\n    unvisited.insert(e.first);\n  }\n  while(!unvisited.empty()) {\n    auto add = topological_sort(reverse, *begin(unvisited), unvisited);\n    result.insert(end(result), begin(add), end(add));\n  }\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*     *******************Bismillahir Rahmanir Rahim************************\n                          MD. ASFAKUL GHANI!\n                          *ProMAGFAT*!\n SECRET_warning :)->FAT   CSE-25!\n                          JAHANGIRNAGAR UNIVERSITY!\n                          Dhaka,Bangladesh!\n*/\n\n#include <bits/stdc++.h>\n#include <set>\nusing namespace std;\n\n#define           fasterIO ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define           Im int main()\n#define           ll long long\n#define           sc scanf\n#define           pf printf\n#define           rn0 return 0\n#define           rn return\n#define           f0(i,n) for(ll i=0;i<n;i++)\n#define           f1(i,n) for(ll i=1;i<=n;i++)\n#define           f2(i,n) for(ll i=n-1;i>=0;i--)\n#define           pi 2*acos(0.0)\n#define           modulo 1000003\n#define           dd double\n#define           PI 3.14159265358979\n#define           pi 2*acos(0.0)\n#define           p_b push_back\n#define           ps push\n\n/*\nll for_binarySearch(ll a,ll b,ll aa[],ll x){while(a<=b){ll mid=(a+b)/2;if(aa[mid]==x) return 1;else if(aa[mid] > x) b=mid-1;else a=mid+1;}return -1;}\nll for_gcd(ll a,ll b){if(a==0) return b;else return for_gcd(b%a,a);}\nll for_prime(ll x){for (ll i=2;i*i<=x;i++){if(x%i==0) return 0;}return 1;}\nvoid for_swap(char *x,char *y){char temp;temp=*x;*x=*y;*y=temp;}\nll for_big_mod(ll b,ll p,ll m){if(p==0) return 1;else if(p%2==0){ll k=for_big_mod(b,p/2,m);return (k*k)%m;}else return ((b%m)*(for_big_mod(b,p-1,m)))%m;}\nll for_josephus(ll n,ll k){if(n==1) return 1;return (for_josephus(n-1,k)+k-1)%n+1;}\nll for_gcdExtended(ll a,ll b,ll *x,ll *y){if(a==0){*x=0;*y=1;return b;}ll x1,y1;ll gcd=for_gcdExtended(b%a,a,&x1,&y1);*x=y1-(b/a)*x1;*y=x1;return gcd;}\n*/\n\nvoid debug1()\n{\n    cout << \"***\" << endl;\n}\n\nvoid debug11(ll n)\n{\n    cout << n << endl;\n}\n\nll m,n;\nvector <ll> v1[101010];\nll in_dg[101010];\nbool vis[101010];\nstack <ll> s1;\n\nvoid FAT_dfs(ll u)\n{\n    vis[u] = 1;\n    vector <ll> ::iterator it;\n    for (it = v1[u].begin(); it != v1[u].end(); it += 1){\n           if (!vis[*it]) FAT_dfs(*it);\n    }\n    s1.ps(u);\n}\n\nvoid FAT_topSort()\n{\n   memset(vis,0,sizeof(vis));\n   for (ll i = 0; i < n; i += 1){\n        if (!vis[i]){\n            FAT_dfs(i);\n        }\n   }\n   while (!s1.empty()){\n      cout << s1.top() << endl;\n      s1.pop();\n   }\n}\n\nIm\n{\n    /*#ifdef FAT\n       freopen(\"input.txt\",\"w\",stdin);\n    #endif // FAT*/\n\n    fasterIO;\n\n    cin>>n>>m;\n\n    for (ll i = 0; i < m; i += 1){\n        ll u,v;\n        cin>>u>>v;\n        v1[u].p_b(v);\n    }\n\n    FAT_topSort();\n\n   // main();\n\n    rn0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n    for(int i=0; i<N; i++){\n        for(int j=0; j<G[i].size(); j++){\n            int v = G[i][j];\n            indeg[v]++;\n        }\n    }\n    for(int u=0; u<N; u++){\n        if(indeg[u]==0 && !V[u]) bfs(u);\n    }\n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> N >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n    V[u] = true;\n    for(int i=0; i < G[u].size(); i++){\n        int v = G[u][i];\n        if( !V[v] ) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,M;\n    \n    cin >> N >> M;\n    for(int i=0; i<N; i++) V[i] = false;\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    for(int i=0; i<N; i++){\n        if( !V[i] ) dfs(i);\n    }\n    \n    for(list<int>::iterator it=out.begin(); it!=out.end(); it++){\n        cout << *it << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nvector<int> nodes[100100];\nint pre[100100] = {0};\nint post[100100] = {0};\nint ith = 0;\nstack<int> re;\nvoid topo(int s)\n{\n   pre[s] = ++ith;\n   for (auto i : nodes[s])\n   {\n      if (!pre[i])\n      {\n         topo(i);\n      }\n   }\n   re.push(s);\n}\nint main()\n{\n   int e, n;\n   cin >> n >> e;\n   for (int i = 0; i < e; ++i)\n   {\n      int x, y;\n      cin >> x >> y;\n      nodes[x].push_back(y);\n   }\n   for (int i = 0; i < n; ++i)\n   {\n      if (!pre[i])\n      {\n         topo(i);\n      }\n   }\n   while(!re.empty()){\n      cout << re.top() << \"\\n\";\n      re.pop();\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// Kahn's algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<pair<int, int>>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back({t, 0});\n                B[t]++;\n        }\n        int edges = E;\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++)\n                if (!B[i])\n                        S.push(i);\n        while (!S.empty()) {\n                auto c = S.front();\n                S.pop();\n                L.push_back(c);\n                for (auto &a: A[c]) {\n                        if (a.second)\n                                continue;\n                        a.second = 1;\n                        edges--;\n                        if (--B[a.first] == 0)\n                                S.push(a.first);\n                }\n        }\n        if (edges > 0) {\n                cout << \"Found cyclic path\" << endl;\n        }\n        else {\n                for (auto l: L)\n                        cout << l << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<iterator>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Graph{\n    public:\n    typedef struct Edge{\n        ll from, to, cost;\n        Edge(ll f, ll t, ll c): from(f),to(t),cost(c){}\n    } Edge;\n\n    bool isDirected;\n    ll INF = 1LL << 62;\n    ll v; // 頂点数\n    std::vector<Edge> edges;  // 辺のリスト\n    std::vector<std::vector<std::pair<ll,ll>>> list;  // 隣接リスト\n    //std::vector<std::vector<ll>> matrix; // 隣接行列\n\n    Graph() : isDirected(false){ init(0); }\n    Graph(ll n, bool isDirected=false) : isDirected(isDirected) { init(n); }\n    void init(ll n){\n        v=n;\n        edges.clear();\n        list.assign(n, std::vector<std::pair<ll,ll>>());\n        //matrix.assign(n, std::vector<ll>(n, INF));\n    }\n    void connect(ll from, ll to){\n        con(from, to, 1);\n        if(!isDirected) con(to, from, 1);\n    }\n    void connect(ll from, ll to, ll cost){\n        con(from, to, cost);\n        if(!isDirected) con(to, from, cost);\n    }\n    void con(ll from, ll to, ll cost){\n        edges.push_back(Edge(from,to,cost));\n        list[from].push_back(std::make_pair(to, cost));\n        //matrix[from][to] = cost;\n    }\n};\n\nclass StronglyConnectedComponents{  // 強連結成分分解\n    public:\n    std::vector<std::vector<ll>> list, rlist;\n    Graph G;\n    std::vector<ll> order; // 帰りがけ順の並び\n    std::vector<ll> used;\n    std::vector<ll> cmp;   // 属する強連結成分のトポロジカル順序\n    std::vector<std::vector<ll>> nodes; // sccの各ノードに属する頂点集合\n    Graph Gscc;    // 強連結成分を縮約したDAG 各vに属する頂点集合はnodes[v]\n    ll node_num;\n\n    StronglyConnectedComponents(Graph G) : G(G){\n        list.assign(G.v, std::vector<ll>());\n        rlist.assign(G.v, std::vector<ll>());\n        order.clear();\n        used.assign(G.v, 0);\n        cmp.assign(G.v, -1);\n    }\n\n    void make_list(){\n        for(auto i : G.edges){\n            list[i.from].push_back(i.to);\n            rlist[i.to].push_back(i.from);\n        }\n    }\n    void dfs(ll idx){\n        if(used[idx])return;\n        used[idx]=true;\n        for(ll to : list[idx]) dfs(to);\n        order.push_back(idx);\n    }\n    void rdfs(ll idx, ll cnt){\n        if(cmp[idx] != -1) return;\n        cmp[idx] = cnt;\n        for(ll to : rlist[idx]) rdfs(to, cnt);\n    }\n    void build(){\n        make_list();\n        for(ll i=0; i<list.size(); i++) dfs(i);\n        std::reverse(order.begin(), order.end());\n        ll ptr=0;\n        for(ll i : order)if(cmp[i]==-1) rdfs(i,ptr++);\n        node_num = ptr;\n\n        nodes.assign(node_num, std::vector<ll>());\n        for(ll i=0; i<G.v; i++)nodes[cmp[i]].push_back(i);\n\n        std::set<std::pair<ll,ll>> connect;\n        Gscc = Graph(node_num, true);\n        for(auto i : G.edges){\n            ll x = cmp[i.from];\n            ll y = cmp[i.to];\n            if(x==y)continue;\n            if(connect.count({x,y}))continue;\n            connect.emplace(x,y);\n        }\n        for(auto i : connect){\n            Gscc.connect(i.first, i.second);\n        }\n    }\n    ll operator[](ll k){\n        return cmp[k];\n    }\n};\n\nint main(){\n    ll v,e,s,t;\n    cin >> v >> e;\n    Graph G(v, true);\n    REP(i,e){\n        cin >> s >> t;\n        G.connect(s,t);\n    }\n    StronglyConnectedComponents scc(G);\n    scc.build();\n    //for(auto i : scc.cmp)cout << \"###\" << i << endl;\n    //cout << \"##\" << scc.node_num << endl;\n    for(auto i : scc.nodes){\n        if(i.size()!=1)cout << \"###\" << endl;\n        cout << i[0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\nconstexpr int INF = 0x3f3f3f3f; constexpr ll BINF = 0x3f3f3f3f3f3f3f3fLL;\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\nint solve() {\n\tint n, m; cin >> n >> m;\n\tvvi g(n);\n\tvi inDe(n);\n\tfor (int i=0;i<m;i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tg[u].push_back(v); inDe[v]++;\n\t}\n\tvi ans;\n\tqueue<int> q;\n\tfor (int i=0;i<n;i++) if (inDe[i] == 0) q.push(i);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tans.push_back(u);\n\t\tfor (int v : g[u]) {\n\t\t\tinDe[v]--;\n\t\t\tif (inDe[v] == 0) q.push(v);\n\t\t}\n\t}\n\tfor (int x : ans) cout << x << endl;\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define all(c) c.begin(),c.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi  = vector<int>;\nconstexpr int INF = 1001001001001001001LL;\n\nvi topological_sort(vvi &g) {\n    int n = sz(g);\n    vi sorted;\n    vi deg(n, 0);\n    queue<int> q;\n    rep(v, 0, n) for (int w : g[v]) deg[w]++;\n    rep(v, 0, n) if (deg[v] == 0) q.push(v);\n    while (sz(q)) {\n        int v = q.front(); q.pop();\n        sorted.push_back(v);\n        for (int w : g[v]) {\n            deg[w]--;\n            if (deg[w] == 0) {\n                q.push(w);\n            }\n        }\n    }\n    return sorted;\n}\nsigned main() {\n    int V, E;\n    cin >> V >> E;\n    vvi G(V);\n    rep(i, 0, E) {\n        int vs, vt;\n        cin >> vs >> vt;\n        G[vs].push_back(vt);\n    }\n    auto ans = topological_sort(G);\n    for (int v : ans) {\n        cout << v << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> adjList[10005], ts;\nbool vis[10005];\n\nvoid toposort(int u){\n    vis[u] = true;\n    for (int i=0; i<adjList[u].size(); i++){\n        int v = adjList[u][i];\n\n        if (!vis[v]) toposort(v);\n    }\n    ts.push_back(u);\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n\n    // init\n    memset(vis,0,sizeof(vis));\n\n    int N, E;\n    cin >> N >> E;\n\n    int u, v;\n    for (int i=0; i<E; i++){\n        cin >> u >> v;\n\n        adjList[u].push_back(v);\n    }\n\n    for (int i=0; i<N; i++){\n        if (!vis[i]) toposort(i);\n    }\n\n    for (int i=ts.size()-1; i>=0; i--) cout << ts[i] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n \n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n\n// 重みなしグラフ\nclass GraphWithoutWeight{\nprivate:\n    const int infinityInGWW = 2e9 + 334 + 810 + 893 + 114514; // 無限大\n    const int Vsize; // グラフの頂点の数\n    std::vector<std::vector<int>> EdgeFrom; // EdgeFrom[a] = b ; a -> b の矢印\n    std::vector<int> NodeIn; // 頂点に入ってくる枝の数 (a-> b => NodeIn[b]++;)\n    std::vector<int> Topological; // 順序\npublic:\n    // コンストラクタ その①  : 長さを受け取る ; 枝はなしで初期化\n    GraphWithoutWeight(int n): Vsize(n){ \n        EdgeFrom.resize(n, std::vector<int>(0));\n        Topological.resize(n); NodeIn.resize(n, 0);\n    }\n    // コンストラクタ その②  : 枝の情報の配列を受け取る\n    GraphWithoutWeight(std::vector<std::vector<int>>& E): Vsize(E.size()){\n        EdgeFrom = E; Topological.resize(Vsize);\n    }\n    // from -> toへの枝を追加する関数\n    void add(int from, int to){\n        EdgeFrom.at(from).push_back(to);\n        NodeIn.at(to)++;\n    }\n    // 順序を計算の実行をする関数 : 閉路検出 => trueを返す\n    bool findLoop(){\n        // 順序無限大で埋める : 初期設定\n        std::fill(Topological.begin(), Topological.end(), infinityInGWW);\n        std::vector<int> copyNodeIn = NodeIn; // 枝の数の配列のコピー\n        std::queue<int> Que;\n        int count_vertexes = 0; // 訪れた頂点を数える\n \n        // 入ってくる枝の数が0の頂点を詰める\n        for(int v = 0; v < Vsize; v++) if(copyNodeIn[v] == 0){\n            Que.push(v); Topological[v] = 0; count_vertexes++;\n        }\n        while(not Que.empty()){ // 非再帰 bfs\n            int v = Que.front(); Que.pop();\n            for(int nv : EdgeFrom[v]){ // 次のノード\n                // 無限大の場合\n                if(Topological[nv] == infinityInGWW){\n                    --copyNodeIn[nv];\n                    if(copyNodeIn[nv] == 0){\n                        Topological[nv] = Topological[v] + 1;\n                        Que.push(nv); count_vertexes++;\n                    }\n                }\n            }\n        }\n        return count_vertexes == Vsize;\n    }\n \n    void solve(void){\n        std::vector<std::pair<int, int>> TPS(Vsize);\n        REP(i, Vsize) TPS[i] = {Topological[i], i};\n        std::sort(TPS.begin(), TPS.end());\n        REP(i, Vsize) printf(\"%d\\n\", TPS[i].second);\n    }\n    // 順序(Topological)を表示する関数\n    void showTopological(){\n        puts(\"Topological\");\n        for(int v = 0; v < Vsize; v++){\n            printf(\"  %d : %d\\n\", v, Topological[v]);\n        }\n    }\n};\n \nint main(void){\n    int n, m; scanf(\"%d%d\", &n, &m);\n    GraphWithoutWeight GWW(n);\n    REP(_, m){\n        int a, b; \n        scanf(\"%d\", &a);\n        scanf(\"%d\", &b);\n        GWW.add(a, b);\n    }\n    GWW.findLoop();\n    GWW.solve();\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <math.h>\n#include <set>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n ; i++)\n#define pb push_back\nstatic const int MAX = 100000;\nstatic const int INF = 1000000;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint main(void){\n  int V,E; cin >> V >> E;\n  vector<int> list[MAX]; int into[E];\n  int a,b;\n  rep(i,E){\n    into[i] = 0;\n  }\n  rep(i,E){\n    cin >> a >> b;\n    list[a].pb(b);\n    into[b] += 1;\n  }\n  queue<int> Q;\n  rep(i,E-1){\n    if (into[i] == 0) Q.push(i);\n  }\n\n  while(!Q.empty()){\n      cout << Q.front() << endl;\n      rep(i,E-1){\n        //cout << into[i] << endl;\n      }\n      //cout << endl;\n\n      rep(i,list[Q.front()].size()){\n        into[list[Q.front()][i]] -= 1;\n        if(into[list[Q.front()][i]] == 0) Q.push(list[Q.front()][i]);\n      }\n\n\n      Q.pop();\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  c/temp.cpp file\n//  Last Updated: 2018-10-23 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n\n#define coutYN(a) cout<<((a)?\"YES\":\"NO\")<<endl;\n#define coutYn(a) cout<<((a)?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<((a)?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\n//const long long INF=114514191911451419;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<typename T> istream &operator >> (istream &is, vector<T> &v){for(T &x:v) is>>x;return is;}\ntemplate<typename T> ostream &operator << (ostream &os, vector<T> &v){int i=0;for(T &x:v) os<<(i++?\" \":\"\")<<x;return os;}\n\nll rev(ll n){ll x=0;for(;n>0;){x=x*10+n%10;n/=10;}return x;}\n\nll upper(ll n,ll m){return (n+m-1)/m;};\nll rounding(ll n){return (long double)n+0.5;};\n\nbool inG(ll x,ll n){return 0<=x && x<n;}\nbool outG(ll x,ll n){return x<0 || n<=x;}\n\ninline int qp(int a,ll b){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\ninline ll fac(ll k,ll n){ll a=1;for(int i=0;i<n;i++)a*=k--;return a;}\ninline ll fac(ll k,ll n,int mo){ll a=1;for(int i=0;i<n;i++)a*=k--,a%=mo;return a;}\n\ninline int dsum(ll n){int a=0;for(;n;n/=10)a+=n%10;return a;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"です\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←？\"<<endl;}\n//ori_func S\n\n//ori_func E\n#else\ntemplate<typename T>void deb(T a){}\n#define debl\nvoid what_cr(){}void t_t(){}\n#endif\n\nvi G[250000];\nvi rG[250000];\nvi ord(250000,INF);\nvi stg(250000,INF);\nvi topolo;\n\nvoid dfs(int u,int k=0){\n\n  ord[u]=k++;\n\n  REP(i,G[u].size()){\n\n    int v=G[u][i];\n\n    if(ord[v] == INF) dfs(v,k);\n\n    }\n\n  topolo.pb(u);\n\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  int v,e;\n  cin>>v>>e;\n\n  REP(i,e){\n\n    int s,t;\n    cin>>s>>t;\n\n    G[s].pb(t);\n    rG[t].pb(s);\n\n  }\n\n  REP(i,v) if(ord[i]==INF) dfs(i);\n\n  stg.resize(v);\n\n  fill(ALL(ord),INF);\n\n  reverse(ALL(topolo));\n\n  REP(i,v) cout<<topolo[i]<<endl;\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nvoid topological_sort(vector<vector<int>> G, vector<int>& ans) {\n    vector<bool> seen(G.size());\n\n    function<void(int)> visit;\n    visit = [&](auto key) {\n        if (seen[key])\n            return;\n        seen[key] = true;\n        for (auto x : G[key]) {\n            if (seen[x]) {\n                continue;\n            }\n            visit(x);\n        }\n        ans.push_back(key);\n    };\n\n    for (int i = 0; i < G.size(); ++i) {\n        visit(i);\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        G[t].push_back(s);\n    }\n\n    vector<int> ans;\n    topological_sort(G, ans);\n    for (auto x : ans) {\n        cout << x << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 999999999;\n\nstruct edge\n{\n  int src, to, cost;\n};\nusing Edges = vector<edge>;\nusing WeightedGraph = vector<Edges>;\n\nvector<int> tsort(WeightedGraph &G){\n    vector<int> tsorted;\n    vector<bool> used(G.size(), false);\n    function<void(int)> dfs = [&](int u){\n        if(used[u]) return;\n        used[u] = true;\n        for(auto &e : G[u]) dfs(e.to);\n        tsorted.pb(u);\n    };\n    rep(i, G.size()) dfs(i);\n    reverse(all(tsorted));\n    return tsorted;\n}\n\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n  WeightedGraph G(n);\n  rep(i, m)\n  {\n    int s, t;\n    cin >> s >> t;\n    G[s].emplace_back((edge){s, t, 1});\n  }\n  vector<int> ans = tsort(G);\n  rep(i, n) cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Graph {\n\tstruct Vertex {\n\t\tVertex() {}\n\t};\n\tstruct Edge {\n\t\tint to;\n\t\tEdge(int t) : to(t) {}\n\t\tEdge() {}\n\t};\n\tint sz;\n\tvector<Vertex> v;\n\tvector<vector<Edge>> e;\n\tGraph(int n) : sz(n), v(n), e(n) {}\n\ttemplate<class... Args>\n\tinline void assign_vertex(int pos, Args... args) {\n\t\tv[pos] = Vertex(args...);\n\t}\n\ttemplate<class... Args>\n\tinline void add_edge(int pos, Args... args) {\n\t\te[pos].emplace_back(args...);\n\t}\n\tinline int size() {\n\t\treturn sz;\n\t}\n};\n\nstruct TopologicalSort : public Graph {\n\tTopologicalSort(int n) : Graph(n) {}\n\tpair<bool, vector<int>> Topological_solve() {\n\t\tint V = size();\n\t\tvector<char> visited(V, false);\n\t\tvector<int> cnt(V, 0);\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tfor (auto& x : e[i]) {\n\t\t\t\tcnt[x.to]++;\n\t\t\t}\n\t\t}\n\t\tstack<int> s;\n\t\tvector<int> res;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (cnt[i] == 0) s.push(i);\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tint v = s.top(); s.pop();\n\t\t\tres.push_back(v);\n\t\t\tfor (auto& x : e[v]) {\n\t\t\t\tif (--cnt[x.to] == 0) s.push(x.to);\n\t\t\t}\n\t\t}\n\t\treturn make_pair((int)res.size() == size(), res);\n\t}\n};\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tTopologicalSort G(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint v, u; cin >> v >> u;\n\t\tG.add_edge(v, u);\n\t}\n\tauto res = G.Topological_solve();\n\tfor (auto& x : res.second) cout << x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct vertex{\n    vector<int> E;//cost,to\n};\n#define MAX_V 100\n#define MAX_E 1000\n\nbool isVisited[MAX_V];\nbool isChecked[MAX_V];\nvertex V[MAX_V];\nvector <int> A;\n\nvoid rec(int i){\n    isChecked[i]=true;\n    for(auto&e:V[i].E){\n        if(!isChecked[e]) rec(e);\n    }\n    A.push_back(i);\n    return;\n}\n\nint main(){\n    int nv,ne;\n    cin>>nv>>ne;\n    \n    for(int i=0;i<ne;i++){\n        int s,t;\n        cin>>s>>t;\n        V[s].E.emplace_back(t);\n    }\n    \n    fill(isChecked,isChecked+MAX_V,false);\n    for(int i=0;i<nv;i++){\n        if(isChecked[i])continue;\n        rec(i);\n    }\n    for(auto ite=A.rbegin();ite!=A.rend();ite++)cout<<*ite<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// グラフ、頂点の入次数、頂点数を受け取り、そのトポロジカルソートを記録した配列を返す関数\nvector<int> topological_sort(vector<vector<int>> &G, vector<int> &indegree, int V) {\n    // トポロジカルソートを記録する配列\n    vector<int> sorted_vertices;\n\n    // 入次数が0の頂点を発見したら、処理待ち頂点としてキューに追加する\n    queue<int> que;\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n\n    // キューが空になるまで、操作1~3を繰り返す\n    while (que.empty() == false) {\n        // キューの先頭の頂点を取り出す\n        int v = que.front();\n        que.pop();\n\n        // その頂点と隣接している頂点の入次数を減らし、0になればキューに追加\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        // 頂点vを配列の末尾に追加する \n        sorted_vertices.push_back(v);\n    }\n\n    // トポロジカルソートを返す\n    return sorted_vertices;\n}\n\nint main(void) {\n    // 頂点数と辺の本数\n    int V, E;\n    cin >> V >> E;\n\n    // 隣接リストにより表現されるグラフ\n    vector<vector<int>> G(V);\n    // 頂点の入次数を記録する配列\n    vector<int> indegree(V);\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        indegree[v] += 1;\n    }\n\n    // トポロジカルソートする\n    vector<int> sorted_vertices = topological_sort(G, indegree, V);\n\n    // トポロジカルソートを出力\n    for (int i = 0; i < sorted_vertices.size(); i++) {\n        cout << sorted_vertices[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int> > edge(10001);\n    vector<int> state(V, 0);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n        state[t]++;\n    }\n    vector<int> ans;\n    for (int i = 0; i < V; i++) {\n        if (state[i] == 0) ans.push_back(i);\n    }\n    for (int i = 0, s = ans.size(); i < s; i++) {\n        int a = ans[i];\n        for (int j = 0, ss = edge[a].size(); j < ss; j++) {\n            int t = edge[a][j];\n            state[t]--;\n            if (state[t] == 0) {\n                ans.push_back(t);\n                s++;\n            }\n        }\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int>G[MAX];\nlist<int>Out;\nbool V[MAX] = {false};\nint N;\nint indeg[MAX] = {0};\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    \n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        Out.push_back(u);\n        \n        for(int i = 0;i < G[u].size();++i){\n            int v = G[u][i];\n            indeg[v]--;\n            \n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int u = 0;u < N;++u){\n        for(int i = 0;i < G[u].size();++i){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    \n    for(int u = 0;u < N;++u){\n        if(indeg[u] == 0 && !V[u]){\n            bfs(u);\n        }\n    }\n    \n    for(list<int>::iterator it = Out.begin();it != Out.end();++it){\n        cout << *it << endl;\n    }\n}\n\nint main(){\n    int s,t,m;\n    cin >> N >> m;\n    \n    for(int i = 0;i < m;++i){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> ans;\nvoid dfs(vector<vector<int > > g,vector<bool>& used,int s){\n\tused[s] = false;\n\trep(i,g[s].size() ){\n\tif(used[g[s][i]])\t{\n\t\tdfs(g,used,g[s][i]);\n\t//\tcout<<i<<endl;\n\t}\n\t}\n\tans.push_back(s);\n\treturn;\n}\nvoid topological(vector<vector<int > > g,int v){\n\tvector<bool> used(v,true);\n\trep(i,v){\n\tif(used[i]){\n\tdfs(g,used,i);\n\t}\n\t}\n\t//rep(i,v)if(used[i])cout<<i<<endl;\n\treturn ;\n}\nint main(){\n\tint v,e;\n\tcin>>v>>e;\n\tvector<vector<int> > g(v);\t\n\tint s,t;\n\trep(i,e){\n\tcin>>s>>t;\n\tg[s].push_back(t);\n\t}\n\ttopological(g,v);\n\tfor(int i=ans.size()-1;i>=0;i--)cout<<ans[i]<<endl;\t\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#define y0 qvya13579\n#define y1 qvyb24680\n#define j0 qvja13579\n#define j1 qvjb24680\n#define next qvne13579xt\n#define prev qvpr13579ev\n#define INF 1000000007\n#define MOD 1000000007\n#define PI acos(-1.0)\n#define endl \"\\n\"\n#define IOS cin.tie(0);ios::sync_with_stdio(false)\n#define M_P make_pair\n#define PU_B push_back\n#define PU_F push_front\n#define PO_B pop_back\n#define PO_F pop_front\n#define U_B upper_bound\n#define L_B lower_bound\n#define B_S binary_search\n#define PR_Q priority_queue\n#define FIR first\n#define SEC second\n#if __cplusplus < 201103L\n#define stoi(argument_string) atoi((argument_string).c_str())\n#endif\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP_R(i,n) for(int i=((int)(n)-1);i>=0;--i)\n#define FOR(i,m,n) for(int i=((int)(m));i<(int)(n);++i)\n#define FOR_R(i,m,n) for(int i=((int)(m)-1);i>=(int)(n);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define RALL(v) (v).rbegin(),(v).rend()\n#define SIZ(x) ((int)(x).size())\n#define CIN(x) cin>>(x)\n#define CIN2(x,y) cin>>(x)>>(y)\n#define CIN3(x,y,z) cin>>(x)>>(y)>>(z)\n#define CIN4(x,y,z,w) cin>>(x)>>(y)>>(z)>>(w)\n#define CIN5(x,y,z,w,u) cin>>(x)>>(y)>>(z)>>(w)>>(u)\n#define SCAND(x) scanf(\"%d\",&(x))\n#define SCAND2(x,y) scanf(\"%d%d\",&(x),&(y))\n#define SCAND3(x,y,z) scanf(\"%d%d%d\",&(x),&(y),&(z))\n#define SCAND4(x,y,z,w) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(w))\n#define SCAND5(x,y,z,w,u) scanf(\"%d%d%d%d%d\",&(x),&(y),&(z),&(w),&(u))\n#define SCANLLD(x) scanf(\"%lld\",&(x))\n#define SCANLLD2(x,y) scanf(\"%lld%lld\",&(x),&(y))\n#define SCANLLD3(x,y,z) scanf(\"%lld%lld%lld\",&(x),&(y),&(z))\n#define SCANLLD4(x,y,z,w) scanf(\"%lld%lld%lld%lld\",&(x),&(y),&(z),&(w))\n#define SCANLLD5(x,y,z,w,u) scanf(\"%lld%lld%lld%lld%lld\",&(x),&(y),&(z),&(w),&(u))\n#define PRINTD(x) printf(\"%d\\n\",(x))\n#define PRINTLLD(x) printf(\"%lld\\n\",(x))\n#define DEBUG(argument) cerr<<(#argument)<<\" : \"<<(argument)<<\"\\n\"\ntypedef long long int lli;\nusing namespace std;\n\n\nbool compare_by_2nd(pair<int,int> a, pair<int,int> b)\n{\n  if( a.second != b.second )\n    {\n      return a.second < b.second;\n    }\n  else\n    {\n      return a.first < b.first;\n    }\n  \n}\n\nint ctoi(char c)\n{\n  if( c >= '0' and c <= '9' )\n    {\n      return (int)(c-'0');\n    }\n\n  return -1;\n}\n\nint alphabet_pos(char c) \n{\n  if( c >= 'a' and c <= 'z' )\n    {\n      return (int)(c-'a');\n    }\n\n  return -1;\n}\n\n\nint alphabet_pos_capital(char c)\n{\n  if( c >= 'A' and c <= 'Z' )\n    {\n      return (int)(c-'A');\n    }\n\n  return -1;\n}\n\n\nvector<string> split(string str, char ch)\n{\n  int first = 0;\n  int last = str.find_first_of(ch);\n  \n  if(last == string::npos)\n    {\n      last = SIZ(str);\n    }\n\n  vector<string> result;\n\n  while( first < SIZ(str) )\n    {\n      string Ssubstr(str, first, last - first);\n      result.push_back(Ssubstr);\n      first = last + 1;\n      last = str.find_first_of(ch, first);\n\n      if(last == string::npos)\n\t{\n\t  last = SIZ(str);\n\t}\n    }\n  \n  return result;\n}\n\n\n\nint gcd( int a , int b ) // assuming a,b >= 1\n{\n  if( a < b )\n    {\n      return gcd( b , a );\n      \n    }\n\n  if( a % b == 0 )\n    {\n      return b;\n      \n    }\n\n  return gcd( b , a % b );\n  \n}\n\nint lcm( int a , int b ) // assuming a,b >= 1\n{\n  return  a * b / gcd( a , b );\n  \n}\n\nlli pow_fast( lli x, lli n_power , lli modulus )\n{\n  \n  if( n_power == 0 )\n    {\n      return 1;\n    }\n  \n  if( n_power % 2 == 0)\n    {\n      return pow_fast( x * x % modulus , n_power / 2 , modulus );  \n    }\n\n  \n  return x * pow_fast( x , n_power - 1 , modulus ) % modulus;\n}\n\n\nstruct CombinationTable\n{\n  vector<vector<long long> > val;\n\n  CombinationTable( int size ) : val( size+1 , vector<long long>( size+1 ) ) //constructor\n  {\n    for( int i = 0 ; i <= size ; ++ i ) // note that 0 <= i <= size\n      {\n\n\tfor( int j = 0 ; j <= i ; ++ j )\n\t  {\n\t    \n\t    if( j == 0 or j == i )\n\t      {\n\t\tval[i][j] = 1LL;\n\t      }\n\t    else\n\t      {\n\t\tval[i][j] = val[i-1][j-1] + val[i-1][j];\n\t      }\n\n\t  }\n\t\n\t\n      }\n    \n  }\n\n  \n};\n\n\n\n\n\nstruct UnionFind //size-based\n{\n  vector<int> parent, treesize;\n  \n  UnionFind( int size ) : parent( size ) , treesize( size , 1 ) //constructor\n  {\n    for( int i = 0 ; i < size ; ++ i )\n      {\n\tparent[i] = i;\n      }\n  }\n\n  int root( int x )\n  {\n    if( parent[x] == x )\n      {\n\treturn x;\n      }\n    \n    return parent[x] = root(parent[x]);\n  }\n\n  void unite( int x, int y )\n  {\n    x = root(x); \n    y = root(y);\n    \n    if( x == y )\n      {\n\treturn; \n      }\n\n    if( treesize[x] < treesize[y] )\n      {\n\tparent[x] = y;\n\ttreesize[y] += treesize[x];\n      }\n    else\n      {\n\tparent[y] = x;\n\ttreesize[x] += treesize[y];\t\n      }\n    \n  }\n\n  bool sametree( int x, int y )\n  {\n    return root(x) == root(y);\n  }\n\n  int gettreesize( int x )\n  {\n    return treesize[root(x)];\n  }\n  \n};\n\n\n\n/*------------------ the end of the template -----------------------*/\n\n\n\n\n\n\n\n\n\nsigned main()\n{\n  IOS; /* making cin faster */\n  int V,E;\n  SCAND2(V,E);\n  vector<int> s(E), t(E);\n  vector<vector<int> > G(V);\n  REP(i,E)\n    {\n      int s,t;\n      SCAND2(s,t);\n      G[s].push_back(t);\n    }\n\n  \n  vector<int> indeg(V,0);\n  vector<int> color(V,0);\n  deque<int> q;\n  vector<int> out;\n\n\n\n  REP(i,V)\n    {\n      REP(j,SIZ(G[i]))\n\t{\n\t  int v = G[i][j];\n\t  ++ indeg[v];\n\t}\n    }\n\n\n\n  \n  REP(i,V)\n    {\n      if( indeg[i] == 0 and color[i] == 0 )\n\t{\n\t  q.push_back(i);\n\t  color[i] = 1;\n\n\t  while( not q.empty() )\n\t    {\n\t      int u = q.front();\n\t      q.pop_front();\n\n\t      out.push_back(u);\n\n\t      REP(j,SIZ(G[u]))\n\t\t{\n\t\t  int v = G[u][j];\n\t\t  -- indeg[v];\n\n\t\t  if( indeg[v] == 0 and color[v] == 0 )\n\t\t    {\n\t\t      color[v] = 1;\n\t\t      q.push_back(v);\n\t\t    }\n\t\t  \n\t\t}\n\t      \n\t    }\n\t}\n    }\n\n  REP(i,SIZ(out))\n    {\n      PRINTD(out[i]);\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Given a DAG G, print the order of vertices after the topological sort.\n * Output\n * Print the vertices numbers in order. Print a number in a line.\n * If there are multiple possible solutions, print any one of them (the solution\n * is judged by a special validator).\n *\n * Constraints\n * 1≤|V|≤10,000\n * 0≤|E|≤100,000\n * There are no parallel edges in G\n * There are no self loops in G\n */\n\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n\n#define MAXN 10000\n#define MAXM 100000\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  struct {\n    int to, next;\n  } E[MAXM];\n  vector<int> LE(MAXN, -1);\n\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0, s, t; i < m; ++i) {\n    cin >> s >> t;\n    E[i] = {t, LE[s]};\n    LE[s] = i;\n  }\n\n  bool visited[MAXN]{0};\n\n  struct data {\n    int id;\n    bool post;\n  };\n  stack<data> dfs;\n  stack<int> topo;\n  for (int i = 0; i < n; ++i) {\n    if (visited[i])\n      continue;\n    dfs.push({i, 0});\n    while (!dfs.empty()) {\n      data d = dfs.top();\n      dfs.pop();\n      if (visited[d.id] && !d.post)\n        continue;\n      if (visited[d.id] && d.post) {\n        topo.push(d.id);\n      } else {\n        visited[d.id] = true;\n        dfs.push({d.id, 1});\n        for (int e = LE[d.id]; e != -1; e = E[e].next)\n          if (!visited[E[e].to])\n            dfs.push({E[e].to, 0});\n      }\n    }\n  }\n\n  while (!topo.empty()) {\n    cout << topo.top() << endl;\n    topo.pop();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // ver2.3.4\n#define int long long\n#define endl \"\\n\"\n#define ALL(v) (v).begin(),(v).end()\n#define COUNT(a,k) upper_bound(ALL(a),k)-lower_bound(ALL(a),k)\n#define BIGGER(a,k) a.end()-upper_bound(ALL(a),k)\n#define SMALLER(a,k) lower_bound(ALL(a),k)-a.begin()\n#define Vi vector<int>\n#define VVi vector<Vi>\n#define Vs vector<string>\n#define Pii pair<int,int>\n#define VPii vector<Pii>\n#define Tiii tuple<int,int,int>\n#define VTiii vector<Tiii>\n#define PQi priority_queue<int>\n#define PQir priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define itos to_string\n#define stoi stoll\n#define FI first\n#define SE second\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define cyes cout<<\"yes\"<<endl\n#define cno cout<<\"no\"<<endl\n#define _ <<' '<<\n#define sortr(v) sort(v,greater<>())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repeq(i,a,b) for(int i=a;i<=b;i++)\n#define repreq(i,a,b) for(int i=a;i>=b;i--)\n#define leng(n) (int)(log10(n)+1)\n#define dem(a,b) ((a+b-1)/(b))\n#define Vin(a) rep(iI,0,a.size())cin>>a[iI]\n#define Vout(a) rep(lZ,0,a.size()-1)cout<<a[lZ]<<' ';cout<<a.back()<<endl\n#define VVout(a) rep(lY,0,a.size()){if(!a[lY].empty()){Vout(a[lY]);}else cout<<endl;}\n#define VPout(a) rep(lX,0,a.size())cout<<a[lX].FI<<' '<<a[lX].SE<<endl\n#define Verr(a) rep(iZ,0,a.size()-1)cerr<<a[iZ]<<' ';cerr<<a.back()<<endl\n#define VVerr(a) rep(J,0,a.size()){if(!a[J].empty()){Verr(a[J]);}else cerr<<'.'<<endl;}\n#define VPerr(a) rep(iX,0,a.size())cerr<<a[iX].FI<<' '<<a[iX].SE<<endl\n#define INF 3000000000000000000  //  3.0*10^18(MAXの1/3くらい)\n#define MAX LLONG_MAX\n#define PI 3.141592653589793238462\n#define MOD 1000000007  //  10^9 + 7\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;} // 最大公約数gcd\nint lcm(int a,int b){return a/gcd(a,b)*b;} // 最小公倍数lcm\nint mypow(int x, int n, int m){ // 累乗x^n(mod m) O(log(n))\nif(n==0)return 1;if(n%2==0)return mypow(x*x%m,n/2,m);else return x*mypow(x,n-1,m)%m;}\nint scomb(int n, int r){if((n-r)<r)r=n-r; // nCr(小さい場合)\nint a=1;for(int i=n;i>n-r;--i){a=a*i;}for(int i=1;i<r+1;++i){a=a/i;}return a;}\nint comb(int n, int r){if((n-r)<r)r=n-r; // nCr(%MOD)\nint a=1;for(int i=n;i>n-r;--i){a=a*i%MOD;}for(int i=1;\ni<r+1;++i){a=a*mypow(i,MOD-2,MOD)%MOD;}return a%MOD;}\nVi stpowV(){Vi a(100001);\na[0]=1;repeq(i,1,100000)a[i]=a[i-1]*i%MOD;return a;}\n//Vi stpow = stpowV();  // 階乗配列(%MOD)\nvoid press(auto &v){v.erase(unique(ALL(v)),v.end());} // 圧縮\nVi Vsum(Vi &v){Vi S(v.size()+1);rep(i,1,S.size())S[i]+=v[i-1]+S[i-1];return S;} // 累積和\nint keta(int k,int i){string s = itos(k);return s[s.size()-i]-'0';} // i桁目の数字\n\n\nint v, e; // 頂点数、辺数\nconst int MAX_N = 100010; // 頂点数の最大値\nvector<int> g[MAX_N]; // 隣接リスト\nbool used[MAX_N];\nvector<int> ans; // トポロジカルソートされた数列\n\nvoid dfs(int u) {\n  if(used[u]) return;\n  used[u] = true;\n  for(auto& i: g[u]) dfs(i);\n  // 帰りがけ順で追加\n  ans.push_back(u);\n}\n\nvoid tsort() {\n  for(int i=0; i<v; ++i) dfs(i);\n  reverse(ans.begin(), ans.end());\n}\n\n\n\nsigned main() {\n  cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(12);\n  \n  cin >> v >> e;\n  \n  rep(i,0,e) {\n    int s, t;\n    cin >> s >> t;\n    //s--,t--;  // 1-indexの場合\n    g[s].push_back(t);\n  }\n  \n  tsort();\n  \n  //Vout(ans);\n  rep(i,0,ans.size()){\n    cout << ans[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Graph{\n  int v_size;\n  vector<vector<int>> adj;\n\n  Graph(const int v_size):v_size(v_size){\n    this->adj.resize(v_size);\n  }\n\n  void add_edge(const int s, const int t){\n    this->adj[s].emplace_back(t);\n  }\n};\n\nvoid tsort(const Graph& g)\n{\n  vector<int> indeg(g.v_size);\n  for(const auto& u : g.adj){\n    for(const auto& to : u){\n      ++indeg[to];\n    }\n  }\n  \n  vector<bool> used(g.v_size);\n  queue<int> q;\n\n  vector<int> ans;\n  ans.reserve(g.v_size);\n  \n  for(int i = 0; i < g.v_size; ++i){\n    if(indeg[i] == 0 && !used[i]){\n      q.push(i);\n      used[i] = true;\n\n      while(!q.empty()){\n        auto u {q.front()};\n        q.pop();\n        \n        ans.emplace_back(u);\n\n        for(const auto& v : g.adj[u]){\n          --indeg[v];\n\n          if(indeg[v] == 0 && !used[v]){\n            q.push(v);\n            used[v] = true;\n          }\n        }        \n      }\n    }\n  }\n\n  for(const auto& v : ans){\n    cout << v << endl;\n  }\n}\n\nint main()\n{\n  int V, E;\n  cin >> V >> E;\n\n  Graph g(V);\n\n  int s, t;\n  for(int i = 0; i < E; ++i){\n    cin >> s >> t;\n    g.add_edge(s,t);\n  }\n\n  tsort(g);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <list>\n#include <algorithm>\nusing namespace std;\nconst int maxx = 100010;\nconst int INF = 1 << 30;\n\nvector<int>G[maxx];\nlist<int>out;\nbool flag[maxx];\nint n;\n\nvoid dfs(int u) {\n\tflag[u] = true;\n\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (flag[v] == 0)\n\t\t\tdfs(v);\n\t}\n\tout.push_front(u);\n}\n\nvoid tsort() {\n\tfor (int i = 0; i < n; i++) {\n\t\tflag[i] = false;\n\t}\n\n\tfor (int u = 0; u < n; u++) {\n\t\tif ( flag[u] == 0)\n\t\t\tdfs(u);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tprintf(\"%d\\n\", *it);\n}\nint main()\n{\n\tint s, t, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvector<int> toposort(int n,vector<int> G[],int h[]){\n    stack<int> st;\n    vector<int> res;\n    for(int i=0;i<n;i++){\n        if(!h[i])st.push(i);\n    }\n    while(!st.empty()){\n        int id=st.top();\n        st.pop();\n        res.push_back(id);\n        for(auto e:G[id]){\n            h[e]--;\n            if(!h[e])st.push(e);\n        }\n    }\n    return res;\n}\nint main(){\n    int n,m;cin>>n>>m;\n    vector<int> G[10010];\n    int h[10010];\n    for(int i=0;i<m;i++){\n        int s,t;cin>>s>>t;\n        G[s].push_back(t);\n        h[t]++;\n    }\n    vector<int> ans=toposort(n,G,h);\n    for(auto e:ans){\n        cout<<e<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n// Just stands for connections\nclass LinkList\n{\npublic:\n    LinkList(const std::size_t v) : m_v{v}\n    {\n        m_table.resize(v);\n        m_reversed_table.resize(v);\n    }\n    void addEdge(const std::size_t from, const std::size_t to)\n    {\n        m_e++;\n        m_table[from].push_back(to);\n        m_reversed_table[to].push_back(from);\n    }\n\n    void TopologocalSort(std::vector<std::size_t>& srt) const\n    {\n        srt.clear();\n        std::vector<bool> used(m_v, false);\n        for (std::size_t i = 0; i < m_v; i++) {\n            dfs_topo(i, used, srt);\n        }\n        std::reverse(srt.begin(), srt.end());\n    }\n\n    std::size_t SCC(std::vector<std::size_t>& cmp) const\n    {\n        assert(cmp.size() == m_v);\n        for (std::size_t i = 0; i < m_v; i++) {\n            cmp[i] = 0;\n        }\n\n        std::vector<std::size_t> st;\n        std::vector<bool> used(m_v, false);\n        for (std::size_t i = 0; i < m_v; i++) {\n            if (not used[i]) {\n                dfs1_scc(i, st, used);\n            }\n        }\n\n        for (std::size_t i = 0; i < m_v; i++) {\n            used[i] = false;\n        }\n        std::size_t comp = 0;\n        for (std::size_t i = 0; i < st.size(); i++) {\n            const std::size_t s = st[st.size() - i - 1];\n            if (not used[s]) {\n                dfs2_scc(s, comp++, cmp, used);\n            }\n        }\n        return comp;\n    }\n\n    std::size_t getV() const\n    {\n        return m_v;\n    }\n\n    std::size_t getE() const\n    {\n        return m_e;\n    }\n\n    const std::vector<std::vector<std::size_t>>& getEdge() const\n    {\n        return m_table;\n    }\n\n    std::vector<std::vector<std::size_t>>& getEdge()\n    {\n        return m_table;\n    }\n\n    const std::vector<std::vector<std::size_t>>& getReversedEdge() const\n    {\n        return m_reversed_table;\n    }\n\n    std::vector<std::vector<std::size_t>>& getReversedEdge()\n    {\n        return m_reversed_table;\n    }\n\n    void printDot() const\n    {\n        std::cout << \"digraph \\\"Graph\\\" {\\n\";\n\n        std::cout << \"  graph [\\n\"\n                  << \"    charset = \\\"UTF-8\\\";\\n\"\n                  << \"    label = \\\"Graph\\\",\\n\"\n                  << \"    labelloc = \\\"t\\\",\\n\"\n                  << \"    labeljust = \\\"c\\\",\\n\"\n                  << \"    bgcolor = \\\"#343434\\\",\\n\"\n                  << \"    fontcolor = white,\\n\"\n                  << \"    fontsize = 18,\\n\"\n                  << \"    style = \\\"filled\\\",\\n\"\n                  << \"    rankdir = TB,\\n\"\n                  << \"    margin = 0.2,\\n\"\n                  << \"    splines = spline,\\n\"\n                  << \"    ranksep = 1.0,\\n\"\n                  << \"    nodesep = 0.9,\\n\"\n                  << \"    layout = dot\\n\"\n                  << \"  ];\\n\\n\";\n\n        std::cout << \"  node [\\n\"\n                  << \"    colorscheme = \\\"rdylgn11\\\"\\n\"\n                  << \"    style = \\\"solid,filled\\\",\\n\"\n                  << \"    fontsize = 16,\\n\"\n                  << \"    fontcolor = 6,\\n\"\n                  << \"    fontname = \\\"Migu 1M\\\",\\n\"\n                  << \"    color = 7,\\n\"\n                  << \"    fillcolor = 11,\\n\"\n                  << \"    fixedsize = true,\\n\"\n                  << \"    height = 0.6,\\n\"\n                  << \"    width = 1.2\\n\"\n                  << \"  ];\\n\\n\";\n\n        std::cout << \"  edge [\\n\"\n                  << \"    style = solid,\\n\"\n                  << \"    fontsize = 14,\\n\"\n                  << \"    fontcolor = white,\\n\"\n                  << \"    fontname = \\\"Migu 1M\\\",\\n\"\n                  << \"    color = white,\\n\"\n                  << \"    labelfloat = true,\\n\"\n                  << \"    labeldistance = 2.5,\\n\"\n                  << \"    labelangle = 70\\n\"\n                  << \"  ];\\n\\n\";\n\n        std::cout << \"  // Node definition\\n\";\n        for (std::size_t i = 0; i < m_v; i++) {\n            std::cout << \"  \" << i << \";\\n\";\n        }\n        std::cout << \"\\n\";\n        std::cout << \"  // Edge definition\\n\";\n        for (std::size_t i = 0; i < m_v; i++) {\n            for (const std::size_t to : m_table[i]) {\n                std::cout << \"  \" << i << \" -> \" << to << \";\\n\";\n            }\n        }\n        std::cout << \"}\" << std::endl;\n    }\n\n\nprivate:\n    void dfs_topo(const std::size_t s, std::vector<bool>& used, std::vector<std::size_t>& srt) const\n    {\n        assert(s < m_v);\n        assert(used.size() == m_v);\n        if (not used[s]) {\n            used[s] = true;\n            for (const std::size_t to : m_table[s]) {\n                dfs_topo(to, used, srt);\n            }\n            srt.push_back(s);\n        }\n    }\n\n    void dfs1_scc(const std::size_t s, std::vector<std::size_t>& st, std::vector<bool>& used) const\n    {\n        assert(s < m_v);\n        assert(used.size() == m_v);\n        used[s] = true;\n        for (const std::size_t to : m_table[s]) {\n            if (not used[to]) {\n                dfs1_scc(to, st, used);\n            }\n        }\n        st.push_back(s);\n    }\n\n    void dfs2_scc(const std::size_t s, const std::size_t index, std::vector<std::size_t>& cmp, std::vector<bool>& used) const\n    {\n        assert(s < m_v);\n        assert(index < m_v);\n        assert(cmp.size() == m_v);\n        cmp[s] = index;\n        used[s] = true;\n        for (const std::size_t to : m_reversed_table[s]) {\n            if (not used[to]) {\n                dfs2_scc(to, index, cmp, used);\n            }\n        }\n    };\n\n    const std::size_t m_v;\n    std::size_t m_e;\n    std::vector<std::vector<std::size_t>> m_table;\n    std::vector<std::vector<std::size_t>> m_reversed_table;\n};\n\n\nint main()\n{\n    std::size_t V, E;\n    std::cin >> V >> E;\n    LinkList g{V};\n    for (std::size_t i = 0; i < E; i++) {\n        std::size_t s, t;\n        std::cin >> s >> t;\n        g.addEdge(s, t);\n    }\n\n    std::vector<std::size_t> srt;\n    g.TopologocalSort(srt);\n    for (std::size_t i = 0; i < V; i++) {\n        std::cout << srt[i] << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i] || U[i])\n                        continue;\n                S.push(i);\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        U[c] = true;\n                        L.push_back(c);\n                        for (auto a: A[c])\n                                if (--B[a] == 0 && !U[a])\n                                        S.push(a);\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000];\nvector<int> ord;\n\nvoid visit(int n){\n\tif(!vis[n]){\n\t\tvis[n] = true;\n\t\tfor(int i = 0; i < G[n].size(); i++){\n\t\t\tvisit(G[n][i]);\n\t\t}\n\t\tord.push_back(n);\n\t\t//cout << n;\n\t}\n}\n\nint main(){\n\t\n\tint V, E;\n\tcin >> V >> E;\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tG[x].push_back(y);\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tvisit(i);\n\t}\n\t\n\treverse(ord.begin(), ord.end());\n\t\n\tfor(int i = 0; i < ord.size(); i++){\n\t\tcout << ord[i] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\nconst int maxN=1e5+100;\n\nvector<int> g[maxN],topol;\nint n,m;\nbool mark[maxN];\n\nvoid input()\n{\n  cin>>n>>m;\n  for(int i=1;i<=m;i++)\n    {\n      int k1,k2;\n      cin>>k1>>k2;\n      g[k1+1].push_back(k2+1);\n    }\n}\n\nvoid dfs(int v)\n{\n  mark[v]=true;\n  for(int i=0;i<g[v].size();i++)\n    if(!mark[g[v][i]])\n      dfs(g[v][i]);\n  topol.push_back(v);\n}\nvoid show()\n{\n  for(int i=0;i<topol.size();i++)\n    cout<<topol[i]-1<<\"\\n\";\n}\nint main()\n{\n  input();\n  for(int i=1;i<=n;i++)\n    if(!mark[i])\n      dfs(i);\n  reverse(topol.begin(),topol.end());\n  show();  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\nstatic const int MAX_V = 10000;\n\nvector<int> G[MAX_V];\nlist<int> out;\nbool visited[MAX_V];\nint indeg[MAX_V];\nint V;\n\nvoid\nbfs(int s)\n{\n\tqueue<int> q;\n\n\tq.push(s);\n\tvisited[s] = true;\n\twhile (!q.empty())\n\t{\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (unsigned int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tfor (int i = 0; i < V; ++i)\n\t\tindeg[i] = 0;\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tfor (unsigned int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); ++it)\n\t\tprintf(\"%d\\n\", *it);\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < V; ++i)\n\t\tvisited[i] = false;\n\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s].push_back(t);\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct Node {\n  std::unordered_set<int> in_edge;\n  std::unordered_set<int> out_edge;\n};\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int v, e;\n  cin >> v >> e;\n  std::vector<Node> node(v);\n  for (int i = 0; i < e; i++) {\n    int from, to;\n    cin >> from >> to;\n    node[from].out_edge.insert(to);\n    node[to].in_edge.insert(from);\n  }\n\n  std::queue<int> search_set;\n  std::vector<int> result;\n\n  for (int i = 0; i < v; i++) {\n    if (node[i].in_edge.empty()) {\n      search_set.push(i);\n    }\n  }\n\n  while (!search_set.empty()) {\n    int tgt = search_set.front();\n    search_set.pop();\n    result.push_back(tgt);\n    for (auto itr = node[tgt].out_edge.begin(); itr != node[tgt].out_edge.end();\n         itr++) {\n      node[*itr].in_edge.erase(tgt);\n      if (node[*itr].in_edge.empty()) {\n        search_set.push(*itr);\n      }\n    }\n  }\n\n  for (auto x : result) {\n    cout << x << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a) for(int i=0; i<(int)(a); i++)\ntypedef long long ll;\ntemplate<typename T>\nstruct edge {\n  int src, to;\n  T cost;\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n  operator int() const { return to; }\n};\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing Matrix = vector<vector<T>>;\n\n/////////////////////////////////////////////////////////////////////\nconst ll inf = 1LL<<60;\n\nvector<int> tsort(vector<vector<int>> g) {\n  int n = g.size();\n  vector<int> ret;\n\n  vector<int> in(n, 0);\n  for (int i=0; i<n; i++) {\n    for (auto v : g[i]) in[v]++;\n  }\n\n  queue<int> que;\n  for (int i=0; i<n; i++) {\n    if (in[i] == 0) que.push(i);\n  }\n\n  while (!que.empty()) {\n    int v = que.front(); que.pop();\n    for (auto u : g[v]) {\n      in[u] -= 1;\n      if (in[u] == 0) que.push(u);\n    }\n    ret.push_back(v);\n  }\n\n  return ret;\n}\n\nint main()\n{\n  int n,e; cin>>n>>e;\n  vector<vector<int>> g(n);\n  rep(i, e) {\n    int u,v; cin>>u>>v;\n    g[u].push_back(v);\n  }\n  vector<int> sv = tsort(g);\n  for (auto v : sv) cout << v << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define RFOR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define LL long long\n#define INF INT_MAX/3\n\nconst double EPS = 1e-14;\nconst double PI  = acos(-1.0);\n\nstruct Edge {\n  int to;\n  int cost;\n};\n\nclass SingleSourceGraph {\n  protected:\n    int vertex;\n    int start;\n    std::vector<long long> dist;\n    std::vector<int> prev;\n    std::vector<std::vector<Edge> > list;\n\n  public:\n    long long inf = LLONG_MAX / 3;\n\n    SingleSourceGraph(int v, int s);\n\n    \n    virtual void push(int from, int to, int cost) = 0;\n\n    void dijkstra();\n    bool bellman_ford();\n\n    std::vector<long long> get_dist();\n    std::vector<int> get_path(int d);\n};\n\nSingleSourceGraph::SingleSourceGraph(int v, int s) {\n  vertex = v;\n  start = s;\n  list.resize(vertex);\n  dist.resize(vertex);\n  prev.resize(vertex);\n  for (int i = 0; i < vertex; ++i) {\n    dist[i] = inf;\n    prev[i] = -1;\n  }\n  dist[start] = 0;\n}\n\nvoid SingleSourceGraph::dijkstra() {\n  std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >, std::greater<std::pair<int, int> > > pq;\n  pq.push(std::make_pair(0, start));\n\n  while (!pq.empty()) {\n    int cost = pq.top().first;\n    int v = pq.top().second;\n    pq.pop();\n\n    for (int i = 0; i < (int)list[v].size(); ++i) {\n      Edge e = list[v][i];\n      if (cost + e.cost < dist[e.to] ) {\n        prev[e.to] = v;\n        dist[e.to] = cost + e.cost;\n        pq.push(std::make_pair(dist[e.to], e.to));\n      }\n    }\n  }\n}\n\nbool SingleSourceGraph::bellman_ford() {\n  bool update = true;\n  int cnt = 0;\n  while (update) {\n    cnt++;\n    update = false;\n    for (int i = 0; i < vertex; ++i) {\n      for (int j = 0; j < (int)list[i].size(); ++j) {\n        Edge e = list[i][j];\n        if (dist[i] + e.cost < dist[e.to] && dist[i] != inf) {\n          if (cnt >= vertex) return true;\n          dist[e.to] = dist[i] + e.cost;\n          prev[e.to] = i;\n          update = true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nstd::vector<long long> SingleSourceGraph::get_dist() {\n  return dist;\n}\n\nstd::vector<int> SingleSourceGraph::get_path(int d) {\n  std::vector<int> path;\n  int v = d;\n  while (v != start) {\n    path.push_back(v);\n    v = prev[v];\n  }\n  path.push_back(v);\n  std::reverse(path.begin(), path.end());\n  return path;\n}\n\nclass SingleSourceDirectedGraph : public SingleSourceGraph {\n  using SingleSourceGraph::SingleSourceGraph;\n\n  public:\n    void push(int from, int to, int cost) {\n      Edge e;\n      e.to = to;\n      e.cost = cost;\n      list[from].push_back(e);\n    }\n};\n\nclass DAG : public SingleSourceDirectedGraph {\n  using SingleSourceDirectedGraph::SingleSourceDirectedGraph;\n\n  public:\n  std::vector<int> topological_sort() {\n      std::vector<int> intoVertex(vertex, 0);\n      std::queue<int> q;\n\n      for (std::vector<Edge> vec: list) {\n        for (Edge e: vec) {\n          intoVertex[e.to]++;\n        }\n      }\n\n      for (int i = 0; i < vertex; ++i) {\n        if (intoVertex[i] == 0)\n          q.push(i);\n      }\n\n      std::vector<int> ans;\n      while (q.size() > 0) {\n        int v = q.front();\n        q.pop();\n        ans.emplace_back(v);\n        for (Edge e: list[v]) {\n          intoVertex[e.to]--;\n          if (intoVertex[e.to] == 0)\n            q.push(e.to);\n        }\n      }\n\n      return ans;\n    }\n};\n\nclass SingleSourceUndirectedGraph : public SingleSourceGraph {\n  using SingleSourceGraph::SingleSourceGraph;\n\n  public:\n    void push(int from, int to, int cost) {\n      Edge e;\n      e.to = to;\n      e.cost = cost;\n      list[from].push_back(e);\n\n      e.to = from;\n      e.cost = cost;\n      list[to].push_back(e);\n    }\n\n    void prim();\n};\n\nvoid SingleSourceUndirectedGraph::prim() {\n  std::priority_queue<std::pair<long long, int>, std::vector<std::pair<long long, int> >, std::greater<std::pair<long long, int> > > pq;\n\n  std::vector<bool> done(vertex, false);\n\n  pq.push(std::make_pair(dist[start], start));\n\n  while (!pq.empty()) {\n    int v = pq.top().second;\n    pq.pop();\n\n    done[v] = true;\n\n    for (int i = 0; i < (int)list[v].size(); ++i) {\n      Edge e = list[v][i];\n      if (!done[e.to] && e.cost < dist[e.to]) {\n        dist[e.to] = e.cost;\n        prev[e.to] = v;\n        pq.push(std::make_pair(dist[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main() {\n  \n  int v;\n  int e;\n\n  scanf(\"%d %d\", &v, &e);\n\n  DAG g = DAG(v, 0);\n\n  int from, to;\n\n  for (int i = 0; i <  e; i++) {\n    scanf(\"%d %d\", &from, &to);\n    g.push(from, to, 1);\n  }\n\n  std::vector<int> ans = g.topological_sort();\n  for (int v: ans) printf(\"%d\\n\", v);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nvector<int> topological_sort(vector<vector<int>> &G, vector<int> &indegree, int V) {\n    // トポロジカルソートを記録する配列\n    vector<int> sorted_vertices;\n    // 入次数が0の頂点を発見したら、処理待ち頂点としてキューに追加する\n    queue<int> que;\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n\n    // キューが空になるまで、操作1~3を繰り返す\n    while (que.empty() == false) {\n        // キューの先頭の頂点を取り出す\n        int v = que.front();\n        que.pop();\n\n        // その頂点と隣接している頂点の入次数を減らし、0になればキューに追加\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        // 頂点vを配列の末尾に追加する \n        sorted_vertices.push_back(v);\n    }\n\n    // トポロジカルソートを返す\n    return sorted_vertices;\n}\n\nint main(void) {\n    // 頂点数と辺の本数\n    int V, E;\n    cin >> V >> E;\n\n    // 隣接リストにより表現されるグラフ\n    vector<vector<int>> G(V);\n    // 頂点の入次数を記録する配列\n    vector<int> indegree(V);\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        indegree[v] += 1;\n    }\n\n    // トポロジカルソートする\n    vector<int> sorted_vertices = topological_sort(G, indegree, V);\n\n    // トポロジカルソートを出力\n    for (int i = 0; i < sorted_vertices.size(); i++) {\n        cout << sorted_vertices[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\n\n#define rep(i,n) for(int (i) = 0; (i) < (n); ++(i))\n\nconst int INF_32 = -1 + (1 << 30);\n\ntemplate<class Abel> struct D_Graph {\n\tint V,E;\n\tAbel INF;\n\tvector<vector<pair<int,Abel>>> adj;\n\tvector<vector<pair<int,Abel>>> adj_inv;\n\t\n\tD_Graph(int V_size = 0, Abel dist_max = INF_32) : INF(dist_max)\n\t{\n\t\tinit(V_size);\n\t}\n\t\n\tvoid init(int V_size) {\n\t\tV = V_size, E = 0;\n\t\tadj.clear(); \n\t\tadj_inv.clear();\n\t\tadj.resize(V + 1);\n\t\tadj_inv.resize(V + 1);\n\t\tadj[0].resize(V);\n\t\tfor(int i = 1; i <= V; ++i){\n\t\t\tadj[0][i - 1] = {i,0};\n\t\t\tadj[i].reserve(min(V,100));\n\t\t\tadj_inv[i].reserve(min(V,100));\n\t\t}\n\t}\n\t\n\tint deg_out(int v) { return adj[v].size(); }\n\t\n\tint deg_in(int v) { return adj_inv[v].size(); }\n\t\n\tbool is_leaf(int v) { return deg_out(v) == 0; }\n\t\n\tbool is_root(int v) { return deg_in(v) == 0; }\n\t\n\tvoid add_edge(int from, int to, Abel cost = 1) {\n\t\tadj[from].push_back({to,cost});\n\t\tadj_inv[to].push_back({from,cost});\n\t\t++E;\n\t}\n\t\n\tvoid sort_adj() {\n\t\tfor(int i = 0; i <= V; ++i) sort_adj(i);\n\t}\n\t\n\tvoid sort_adj(int v) {\n\t\tsort(begin(adj[v]),end(adj[v]));\n\t\tsort(begin(adj_inv[v]),end(adj_inv[v]));\n\t}\n\t\n\tvoid dijkstra(vector<Abel> &dist, int src) {\n\t\tdist.clear();\n\t\tdist.assign(V + 1,INF);\n\t\tpriority_queue<pair<Abel,int>,vector<pair<Abel,int>>,greater<pair<Abel,int>>> que;\n\t\tque.push({0,src});\n\t\twhile(!que.empty()){\n\t\t\tint d = que.top().first;\n\t\t\tint v = que.top().second;\n\t\t\tque.pop();\n\t\t\tif(dist[v] <= d) continue;\n\t\t\tdist[v] = d;\n\t\t\tfor(auto e : adj[v]) que.push({e.second + d,e.first});\n\t\t}\n\t}\n\t\n\tbool is_cyclic() {\n\t\tvector<int> s;\n\t\treturn !tsort(s);\n\t}\n\t\n\tbool tsort(vector<int> &seq, bool idx_ord = 0) {\n\t\tseq.clear();\n\t\tseq.reserve(V + 1);\n\t\tsort_adj();\n\t\tvector<int> in(V + 1);\n\t\tfor(int i = 0; i <= V; ++i) in[i] = deg_in(i);\n\t\tstack<int> rt;\n\t\trt.push(0);\n\t\twhile(!rt.empty()){\n\t\t\tint r = rt.top();\n\t\t\trt.pop();\n\t\t\tfor(auto e : adj[r]){\n\t\t\t\tint v = e.first;\n\t\t\t\tif(r) --in[v];\n\t\t\t\tif(!in[v]){\n\t\t\t\t\trt.push(v);\n\t\t\t\t\tif(idx_ord){\n\t\t\t\t\t\tauto pos = begin(seq);\n\t\t\t\t\t\tbool det = 0;\n\t\t\t\t\t\tfor(auto i = begin(seq); i < end(seq); ++i){\n\t\t\t\t\t\t\tif(!det && v > *i) ++pos;\n\t\t\t\t\t\t\telse det = 1; \n\t\t\t\t\t\t\tauto u = lower_bound(begin(adj[*i]),end(adj[*i]),make_pair(v,-INF));\n\t\t\t\t\t\t\tif(u < end(adj[*i]) && u->first == v){\n\t\t\t\t\t\t\t\tpos = i + 1;\n\t\t\t\t\t\t\t\tdet = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseq.insert(pos,v);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseq.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(seq.size() == V) return 1;\n\t\treturn 0;\n\t}\n\t\n\tvoid scc(vector<int> &label){\n\t\tlabel.assign(V + 1,0);\n\t\tstack<int> s;\n\t\tvector<int> low(V + 1);\n\t\tvector<int> idx(V + 1,0);\n\t\tint l = 0,c = 0;\n\t\tdfs(0,c,l,s,label,low,idx);\n\t}\n\t\n\tvoid dfs(int v, int &cnt, int &l, stack<int> &s, vector<int> &label, vector<int> &low, vector<int> &idx){\n\t\ts.push(v);\n\t\tidx[v] = low[v] = cnt++;\n\t\tfor(auto e : adj[v]){\n\t\t\tint u = e.first;\n\t\t\tif(label[u]) continue;\n\t\t\tif(!idx[u]) dfs(u,cnt,l,s,label,low,idx);\n\t\t\tlow[v] = min(low[v],low[u]);\n\t\t}\n\t\tif(idx[v] == low[v]){\n\t\t\t++l;\n\t\t\tfor(int t = 0; t != v; s.pop()){\n\t\t\t\tt = s.top();\n\t\t\t\tlabel[t] = l;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tint V,E,s,t; cin>>V>>E;\n\tD_Graph<int> G(V);\n\trep(i,E){\n\t\tcin>>s>>t;\n\t\tG.add_edge(++s,++t);\n\t}\n\tvector<int> v;\n\tG.tsort(v);\n\tfor(int e : v) cout<<e - 1<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//トポソの唯一性\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<vector<int> > adj(n);\n    vector<int> d(n, 0);                           //入次数\n    for(int i = 0; i < m; i++){\n        int a, b; cin >> a >> b;                   //a->bへ有向辺\n        d[b]++;\n        adj[a].push_back(b);\n    }\n\n    queue<int> q;\n\n    //入次数が0の頂点queueに入れる\n    for(int i = 0; i < n; i++){\n        if(d[i] == 0) q.push(i);                    \n    }\n\n    vector<int> ans;\n\n    while(!q.empty()){\n\n        int v = q.front();\n        q.pop();\n        ans.push_back(v);\n\n        //vから伸びている有向辺をなめる\n        for(int i = 0; i < (int)adj[v].size(); i++){\n            d[adj[v][i]]--;\n            //辺を取り除いた後に入次数が0になったら\n            if(d[adj[v][i]] == 0) q.push(adj[v][i]);\n        }\n\n    }\n\n    for(int i = 0; i < (int)ans.size(); i++) cout << ans[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#define MAXV 10005\n#define MAXE 100005\nusing namespace std;\n\nint N,E;\nbool V[MAXV];\nvector<int> G[MAXV],out;\nint indeg[MAXV];\n\nvoid bfs(int u){\n    queue<int> q;\n    q.push(u);\n    V[u]=true;\n    int i;\n    while(!q.empty()){\n        int a=q.front();q.pop();\n        out.push_back(a);\n        for(i=0;i<G[a].size();i++){\n            int v=G[a][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n     int i;\n     for(i=0;i<N;i++){\n        if(!V[i]&&indeg[i]==0){\n            bfs(i);\n        }\n     }\n     for(i=0;i<out.size();i++)cout<<out[i]<<endl;\n}\n\nint main(){\n    cin>>N>>E;\n    int i,j;\n    for(i=0;i<E;i++){\n        int a,b;\n        cin>>a>>b;\n        G[a].push_back(b);\n    }\n\n    memset(indeg,0,sizeof(indeg));\n    for(i=0;i<N;i++)V[i]=false;\n    for(i=0;i<N;i++){\n        for(j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    tsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define loop(i, s, e) for(ll i = s;i < e;i++)\n\n#include <iostream>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long signed ll;\n\nll v, e, s, t;\nvector<pair<ll, ll>> w;\nbool color[10000];\nll indeg[10000];\nqueue<ll> q;\nvector<ll> out;\n\nvoid bfs(ll ss){\n    q.push(ss);\n    color[ss] = true;\n    while(!q.empty()){\n        int u = q.front();q.pop();\n        out.push_back(u);\n        auto l = lower_bound(w.begin(),w.end(),make_pair((ll)u,(ll)0));\n        auto r = lower_bound(w.begin(),w.end(),make_pair((ll)u+1,(ll)0));\n        for(auto itr = l;itr != r;itr++){\n            indeg[itr->second]--;\n            if(!indeg[itr->second] && !color[itr->second]){\n                color[itr->second] = true;\n                q.push(itr->second);\n            }\n        }\n\n    }\n}\n\nint main() {\n    cin >> v >> e;\n    loop(i, 0, e) {\n        cin >> s >> t;\n        indeg[t]++;\n        w.push_back(make_pair(s, t));\n    }\n    sort(w.begin(), w.end());\n    loop(u,0,v) if(!indeg[u] && !color[u]) bfs(u);\n    for(auto x:out) cout << x << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<cstring>\nusing namespace std;\nconst int MAXN=10010,MAXM=100010;\nint n,m;\nint to[MAXM],head[MAXN],nex[MAXM],top;\nint sum[MAXN],dfn[MAXN],top1,hash[MAXN];\nstack<int> s;\nvoid add(int x,int y)\n{\n\tnex[top]=head[x];\n\thead[x]=top;\n\tto[top++]=y;\n\tsum[y]++;\n}\n\nvoid input()\n{\n\tmemset(nex,-1,sizeof(nex));\n\tmemset(head,-1,sizeof(head));\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t}\n}\n\nvoid tuopu()\n{\n\tfor(int i=0;i<n;i++)\n\t    if(!sum[i]) {s.push(i);dfn[top1++]=i;hash[i]=1;}\n\twhile(!s.empty())\n\t{\n\t\tint tmp=s.top();\n\t\ts.pop();\n\t\tint u=head[tmp];\n\t\twhile(u!=-1)\n\t\t{\n\t\t\tint tt=to[u];\n\t\t\tu=nex[u];\n\t\t\tif(hash[tt]) continue;\n\t\t\tsum[tt]--;\n\t\t\tif(sum[tt]==0) {s.push(tt);hash[tt]=1;dfn[top1++]=tt;}\n\t\t}\n\t}\n}\n\nvoid xxj()\n{\n\ttuopu();\n}\n\nvoid output()\n{\n\tfor(int i=0;i<top1;i++)\n\t    cout<<dfn[i]<<'\\n';\n}\n\nint main()\n{\n\tinput();\n\txxj();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tvector<int> order;\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\ttopologicalSort(g,order);\n\t\tfor(i=0;i<V;i++){\n\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i] || U[i])\n                        continue;\n                S.push(i);\n                U[i] = true;\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        L.push_back(c);\n                        for (auto a: A[c]) {\n                                if (--B[a] == 0 && !U[a]) {\n                                        S.push(a);\n                                        U[a] = true;\n                                }\n                        }\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint color[10000];\nint indeg[10000];\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<vector<int>> g(n);\n  for(int i=0;i<m;++i){\n    int a,b;\n    cin >> a >> b;\n    g[a-1].emplace_back(b-1);\n    indeg[b-1]++;\n  }\n\n  vector<int> out;\n  for(int u=0;u<n;++u){\n    if(indeg[u]==0&&color[u]==0){\n      queue<int> q;\n      q.push(u);\n      color[u] = 1;\n      while(!q.empty()){\n        auto v = q.front();q.pop();\n\n        out.push_back(v);\n        for(const auto &w:g[v]){\n          indeg[w]--;\n          if(indeg[w]==0&&color[w]==0){\n            color[w] = 1;\n            q.push(w);\n          }\n        }\n      }\n    }\n  }\n  for(auto o:out) cout << o << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10000\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\ntemplate<typename T>\nclass TopologicalSort {\nprivate:\n    map<T, bool> is;\n    map<T, vector<T>> g;\n    vector<T> tsort;\n\tmap<T, long long> inCnt;\n    void dfs(T now) {\n        if (is[now]) return;\n\t\tis[now] = true;\n        for (auto &&el : g[now]) {\n            dfs(el);\n        }\n        tsort.emplace_back(now);\n    }\npublic:\n    TopologicalSort() {}\n\tTopologicalSort(const vector<T>& vec) {\n\t\tfor (auto &&el : vec) {\n\t\t\tg[el].resize(0);\n\t\t\tis[el] = false;\n\t\t}\n\t}\n    vector<T> dfsTsort() {\n        for (auto &&el : g) {\n            dfs(el.first);\n        }\n        reverse(tsort.begin(), tsort.end());\n        return tsort;\n    }\n\tvoid addEdge(T src, T dst) {\n\t\tg[src].emplace_back(dst);\n\t\tinCnt[dst]++;\n\t}\n\tvector<T> bfsTsort() {\n\t\tqueue<T> q;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second == 0) {\n\t\t\t\tq.push(el.first);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tT now = q.front(); q.pop();\n\t\t\ttsort.emplace_back(now);\n\t\t\tfor (auto &&el : g[now]) {\n\t\t\t\tif (--inCnt[el] == 0) q.push(el);\n\t\t\t}\n\t\t}\n\t\tbool endFlag = true;\n\t\tfor (auto &&el : inCnt) {\n\t\t\tif (el.second) endFlag = false;\n\t\t}\n\t\treturn (endFlag ? tsort : vector<T>());\n\t}\n};\n\nint main(void) {\n\tint V, E;\n\tcin >> V >> E;\n\tVI v(V);\n\tiota(ALL(v), 0);\n\tTopologicalSort<int> t(v);\n\tREP(_, E) {\n\t\tint s, d;\n\t\tcin >> s >> d;\n\t\tt.addEdge(s, d);\n\t}\n\tauto ans = t.dfsTsort();\n\tFORE(el, ans) cout << el << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nclass DAG {\n    int n;\n    vvi adj;\n    vi used;\n\npublic:\n    vi sorted;\n    DAG(int n) : n(n), adj(n), used(n) {}\n\n    void addArc(int a, int b) {\n        adj[a].push_back(b);\n    }\n    \n    void tsort() {\n        function<void(int)> dfs = [&](int v) {\n            if (used[v]) return;\n            used[v] = 1;\n            for (int s: adj[v]) {\n                dfs(s);\n            }\n            sorted.push_back(v);\n        };\n        for (int i = 0; i < n; i++) {\n            dfs(i);\n        }\n        reverse(sorted.begin(), sorted.end());\n    }\n};\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    DAG g(v);\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b;\n        g.addArc(a, b);\n    }\n    g.tsort();\n    for (int v: g.sorted) {\n        cout << v << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\nusing namespace std;\n\nvector <int> edges[10000];\nint incoming[10000];\nint order[10000];\nint cur_count;\n\nvoid dfs(int cur){\n    for(int i = 0; i < edges[cur].size(); i++){\n        if(order[edges[cur][i]] == 0){\n            dfs(edges[cur][i]);\n        }\n    }\n    order[cur] = cur_count;\n    cur_count --;\n    return;\n}\n\nint main(){\n    int N;\n    int M;\n    cin >> N >> M;\n    cur_count = N - 1;\n    for(int i = 0; i < M; i++){\n        int s;\n        int t;\n        cin >> s >> t;\n        edges[s].push_back(t);\n        incoming[t] ++;\n    }\n    vector <int> sources;\n    for(int i = 0; i < N; i++){\n        if(incoming[i] == 0){\n            sources.push_back(i);\n        }\n    }\n    for(int i = 0; i < sources.size(); i++){\n        dfs(sources[i]);\n    }\n\n    for(int i = 0; i < N; i++){\n        cout << order[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e5+9;\nint vis[MAX];\nstack<int>st;\nvector<int>adj[MAX];\nvoid dfs(int s){\n\tvis[s]=1;\n\tfor(int i=0;i<adj[s].size();i++){\n\t\tif(vis[adj[s][i]]!=1)\n\t\t\tdfs(adj[s][i]);\n\t}\n\tst.push(s);\n}\nint main(){\n\tmemset(vis, 0, sizeof(vis));\n\tint n,m;\n\tcin>>n>>m;\n\twhile(m--){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadj[x].push_back(y);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(vis[i]==0)\n\t\t\tdfs(i);\n\t}\n\twhile(!st.empty()){\n\t\tcout<<st.top()<<\"\\n\";\n\t\tst.pop();\n\t}\n//\tcout<<\"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const int MAX = 10000;\nstatic const bool NOTV = 0;\nstatic const bool VISIT = 1;\nint v;\n\nvector<int> G[MAX];\nbool visit[MAX];\nlist<int> out;\nvoid dfs(int s) {\n\tvisit[s] = VISIT;\n\tfor (int i = 0; i < G[s].size(); i++) {\n\t\tif (not visit[G[s][i]]) dfs(G[s][i]);\n\t}\n\tout.push_front(s);\n}\n\nvoid topoSort() {\n\tfill(visit, visit + v, NOTV);\n\tfor (int i = 0; i < v; i++) {\n\t\tif (not visit[i]) dfs(i);\n\t}\n}\n\n\nint main() {\n\tint e, s, t;\n\tcin >> v >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttopoSort();\n\twhile (not out.empty()) {\n\t\tcout << out.front() << endl;\n\t\tout.pop_front();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>x[12000];int n,m,a,b,dist[12000],c[12000];\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){cin>>a>>b;x[a].push_back(b);c[b]++;}\n\tqueue<int>Q;for(int i=0;i<n;i++){if(c[i]==0)Q.push(i);}\n\twhile(!Q.empty()){\n\t\tint a1=Q.front();Q.pop();\n\t\tfor(int i=0;i<x[a1].size();i++){\n\t\t\tif(dist[x[a1][i]]<dist[a1]+1){\n\t\t\t\tdist[x[a1][i]]=dist[a1]+1;Q.push(x[a1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){if(dist[j]==i)cout<<j<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[550][550];\ndouble w[1000],v[1000];\ndouble box[200010];\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid dfs(int s){\n  queue<int> que;\n  que.push(s);\n  V[s] = true;\n  while(!que.empty()){\n    int u = que.front();que.pop();\n    out.push_back(u);\n    for(int i = 0;i < G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n        V[v] = true;\n        que.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(){\n  for(int i = 0;i < N;i++){\n    indeg[i] = 0;\n  }\n  for(int u = 0;u < N;u++){\n    for(int i = 0;i < G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n  for(int u = 0;u < N;u++)\n    if(indeg[u] == 0 && !V[u])dfs(u);\n\n  for(list<int>::iterator it = out.begin(); it != out.end();it++){\n    cout << *it << endl;\n  }\n}\n\nint main(){\n  int p,q,M;\n  cin >> N >> M;\n  for(int i = 0;i < N;i++)V[i] = false;\n  for(int i = 0;i < M;i++){\n    cin >> p >> q;\n    G[p].push_back(q);\n  }\n\n  tsort();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <queue>\n#include <stack>\n#define mk(a,b) make_pair(a,b)\n#define pii pair<int,int>\nusing namespace std;\n#define MAX 1005\n\nstruct Node{\n    bool vis;\n    set<int> e;\n    Node(){vis=false;}\n};\nNode V[MAX];\nint n;\nstack<int> ans;\n\n\nvoid dfs(int v){\n    if(V[v].vis) return;\n    V[v].vis = true;\n    set<int>::iterator it;\n    set<int> &e = V[v].e;\n\n    for(it=e.begin();it!=e.end();it++){\n        dfs(*it);\n    }\n    ans.push(v);\n}\n\nvoid solve(){\n    for(int i=0;i<n;i++){\n        dfs(i);\n    }\n    while(!ans.empty()){\n        printf(\"%d\\n\",ans.top());\n        ans.pop();\n    }\n}\n\n\nvoid get_in(){\n    int ne;\n    scanf(\"%d%d\",&n,&ne);\n    int a,b;\n    while(ne--){\n        scanf(\"%d%d\",&a,&b);\n        V[a].e.insert(b);\n    }\n}\nint main(){\n  //  freopen(\"in\",\"r\",stdin);\n    get_in();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL V, E; cin >> V >> E;\n\t\tvector<vector<UL>> G(V);\n\t\tvector<UL> ins(V);\n\t\trep(i, E) {\n\t\t\tUL a, b; cin >> a >> b;\n\t\t\tG[a].push_back(b);\n\t\t\tins[b]++;\n\t\t}\n\t\tqueue<UL> Q;\n\t\trep(i, V) if (ins[i] == 0) Q.push(i);\n\t\tvector<UL> tro;\n\t\twhile (Q.size()) {\n\t\t\tUL p = Q.front(); Q.pop();\n\t\t\ttro.push_back(p);\n\t\t\tfor (UL e : G[p]) {\n\t\t\t\tins[e]--;\n\t\t\t\tif (ins[e] == 0) Q.push(e);\n\t\t\t}\n\t\t}\n\t\trep(i, tro.size()) cout << tro[i] << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint N, E;\nvector<int> g[10000];\nvector<int> out;\nchar col[10000];\n\nvoid toposort(int s) {\n    stack<int> chain;\n    col[s] = 'g';\n    chain.push(s);\n    while(!chain.empty()) {\n        int now = chain.top();\n        int hasnext = false;\n        for (int i = 0; i < g[now].size(); ++i) {\n            if(col[g[now].at(i)] == 'w') {\n                chain.push(g[now].at(i));\n                col[g[now].at(i)] = 'g';\n                hasnext = true;\n                break;\n            }\n        }\n        if(!hasnext) {\n            col[now] = 'b';\n            chain.pop();\n            out.push_back(now);\n        }\n\n    }\n\n}\nint main() {\n    cin >> N >> E;\n    for (int i = 0; i < E; ++i) {\n        int s, t ;\n        cin >> s >> t;\n        g[s].push_back(t);\n//        g[s][t] = 1;\n    }\n\n    for (int j = 0; j < N; ++j) {\n        col[j] = 'w';\n    }\n    for (int k = 0; k < N; ++k) {\n        int sum = 0;\n        sum = g[k].size();\n        if(col[k] == 'w') {\n            toposort(k);\n        }\n    }\n\n    for (int l = N-1; l >=0; --l) {\n        if(l != N-1) cout << \" \";\n        cout << out.at(l) ;\n    }\n    cout <<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tvector<int> order;\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\tfor(;!g.empty();){\n\t\t\ttopologicalSort(g,order);\n\t\t\tfor(i=0;i<order.size();i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "// ????????°????????????????????????????????????????±???????O(|V|^2)?:cycledetectDirected()\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 100000\n// ??°????????????????????°\nint V;\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nvector <int> list;\nint indeg[MAX_V];\n\nvoid topologicalsort() {\n  memset(indeg, 0, sizeof(indeg));\n  for (int i = 0; i < V; i++) {\n    for (int j = 0; j < graph[i].size(); j++) {\n      int p = graph[i][j];\n      indeg[p]++;\n    }\n  }\n\n  for (int i = 0; i < V; i++) {\n    if (indeg[i] == 0 && !vis[i]) {\n      queue<int> que;\n      que.push(i);\n      vis[i] = true;\n      while (!que.empty()) {\n\tint p = que.front(); que.pop();\n\tlist.push_back(p);\n\n\tfor (int j = 0; j < graph[p].size(); j++) {\n\t  int np = graph[p][j];\n\t  indeg[np]--;\n\t  if (vis[np]) continue;\n\t  if (indeg[np] == 0) {\n\t    vis[np] = true;\n\t    que.push(np);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  int E;\n  cin >> V >> E;\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n  }\n  topologicalsort();\n\n  for (int i = 0; i < list.size(); i++) {\n    cout << list[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i])\n                        continue;\n                S.push(i);\n                U[i] = true;\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        for (auto a: A[c]) {\n                                if (--B[a] == 0 && !U[a]) {\n                                        S.push(a);\n                                        U[a] = true;\n                                }\n                        }\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n\nvoid topological_sort(vector<vector<int>> G, vector<int>& ans) {\n    vector<bool> seen(G.size());\n\n    std::function<void(int)> visit;\n    visit = [&](auto key) {\n        if (seen[key])\n            return;\n        seen[key] = true;\n        for (auto x : G[key]) {\n            if (seen[x]) {\n                continue;\n            }\n            visit(x);\n        }\n        ans.push_back(key);\n    };\n\n    for (int i = 0; i < G.size(); ++i) {\n        visit(i);\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        G[t].push_back(s);\n    }\n\n    vector<int> ans;\n    topological_sort(G, ans);\n    for (auto x : ans) {\n        cout << x << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1LL << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX]\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n\n  for (int u = 0; u < N; u++) {\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) {\n      bfs(u);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> A[10010],B;\nint color[10010],indeg[10010];\nint v,e;\n\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  color[s]=1;\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    B.push_back(u);\n    for(auto x:A[u]){\n      indeg[x]--;\n      if(indeg[x]==0 && color[x]==0){\n        color[x]=1;\n        q.push(x);\n      }\n    }\n  }  \n}\n\nint main(){\n  cin>>v>>e;\n  \n  int s,t;\n  rep(i,e){\n    cin>>s>>t;\n    indeg[t]++;\n    A[s].push_back(t);\n  }\n  \n  rep(i,v){\n    if(indeg[i]==0 && color[i]==0) bfs(i);\n  }\n  \n  rep(i,v) cout<<B[i]<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//DFS na neusmerenim grafovima\n#include <bits/stdc++.h>\n#define INF INT_MAX\n#define MOD 100000007\n#define MAX_V 100000\n#define MAX_E 100000\n\nusing namespace std;\n\nint V, E;\nvector<int> adj[MAX_V];\nint visited[MAX_V];\nint parent[MAX_V];\nstack<int> stk;\nvoid DFS(int v) {\n\tvisited[v] = 1;\n\tint d = adj[v].size();\n\tfor (int i = 0; i<d; ++i) {\n\t\tif (visited[adj[v][i]] == 1) {\n\t\t\tcout << \"IMA CIKLUS\";\n\t\t\texit(0);\n\t\t}\n\t\tif(visited[adj[v][i]]==0)\n\t\tDFS(adj[v][i]);\n\t}\n\tvisited[v]=2;\n\tstk.push(v);\n\treturn;\n}\n\nint main() {\n\tmemset(parent, -1, sizeof(parent));\n\tios::sync_with_stdio(false);\n\tcin >> V >> E;\n\tfor (int i = 0; i<E; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t/*u--;\n\t\tv--;*/\n\t\tadj[u].push_back(v);\n\t}\n\tfor (int i = 0; i<V; ++i) {\n\t\tif (!visited[i])DFS(i);\n\t}\n\twhile (!stk.empty()) {\n\t\tcout << stk.top() << \" \";\n\t\tcout << endl;\n\t\tstk.pop();\n\t}\n\treturn 0;\n}\n/*\n4 4\n1 2\n2 3\n3 4\n1 4\n\n*/\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n// BFS algorithm\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n        int V, E;\n        cin >> V >> E;\n        vector<vector<int>> A(V);\n        vector<int> B(V);\n        for (int i = 0; i < E; i++) {\n                int s, t;\n                cin >> s >> t;\n                A[s].push_back(t);\n                B[t]++;\n        }\n        vector<bool> U(V);\n        vector<int> L;\n        queue<int> S;\n        for (int i = 0; i < V; i++) {\n                if (B[i] || !U[i])\n                        continue;\n                S.push(i);\n                U[i] = true;\n                while (!S.empty()) {\n                        auto c = S.front();\n                        S.pop();\n                        L.push_back(c);\n                        for (auto a: A[c]) {\n                                if (--B[a] == 0 && !U[a]) {\n                                        S.push(a);\n                                        U[a] = true;\n                                }\n                        }\n                }\n        }\n        for (auto l: L)\n                cout << l << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\ntypedef long long ll;\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n\n  int link[V];\n  int available[V];\n  REP(i, V) {\n    link[i] = 0;\n    available[i] = 1;\n  }\n  vector<int> G[V];\n  REP(i, E) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(t);\n    link[t]++;\n  }\n\n  // priority_queue<pair<int, int> , vector<pair<int, int> >, greater<pair<int, int> > > Q; // (link, vertex id)\n  // REP(i, V) {\n  //   Q.push(make_pair(link[i], i));\n  // }\n\n  REP(_, V) {\n    int minv = -1;\n    int minlink = 1 << 21;\n    REP(i, V) {\n      if (link[i] < minlink && available[i]) {\n        minlink = link[i];\n        minv = i;\n      }\n    }\n\n    assert(minlink == 0);\n    assert(minv != -1);\n    cout << minv << endl;\n    available[minv] = 0;\n\n    for (vector<int>::iterator it = G[minv].begin(); it != G[minv].end(); it++) {\n      link[*it]--;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nclass TopoSort {\nprivate:\n  int N;\n  vector<vector<int>> G;\n  vector<int> indeg;\n  vector<bool> V;\n  list<int> out;\n\n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n  }\n\n  void bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while (!q.empty()) {\n      int u = q.front();\n      q.pop();\n      out.push_back(u);\n      for (auto v : G[u]) {\n        indeg[v]--;\n        if (indeg[v] == 0 && V[v] != true) {\n          V[v] = true;\n          q.push(v);\n        }\n      }\n    }\n  }\n\n  list<int> do_topoSort() {\n    for (int i = 0; i < N; i++) {\n      indeg[i] = 0;\n    }\n    for (int i = 0; i < N; i++) {\n      for (auto v : G[i]) {\n        indeg[v]++;\n      }\n    }\n    for (int i = 0; i < N; i++) {\n      if (indeg[i] == 0 && V[i] != true) {\n        bfs(i);\n      }\n    }\n    return out;\n  }\n\npublic:\n  TopoSort(int N) : N(N), G(N, vector<int>()), indeg(N), V(N, false) {}\n\n  void addEdge(int from, int to) { return add_edge(from, to); }\n  list<int> topoSort() { return do_topoSort(); }\n};\n\nsigned main() {\n  int V, E;\n  cin >> V >> E;\n  TopoSort ts(V);\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    ts.addEdge(s, t);\n  }\n\n  list<int> out = ts.topoSort();\n\n  for (auto x : out) cout << x << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nvector<vector<int>>G;\nlist<int>out;\nvector<bool>V;\nint N;\n\nvoid dfs(int u) {\n\tV[u] = true;\n\trep(i, 0, G[u].size()) {\n\t\tint v = G[u][i];\n\t\tif (!V[v])dfs(v);\n\t}\n\tout.push_back(u);\n}\n\nsigned main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\tV = vector<bool>(N, false); G = vector<vector<int>>(N, vector<int>());\n\trep(i, 0, M) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\trep(i, 0, N) {\n\t\tif (!V[i])dfs(i);\n\t}\n\treverse(out.begin(), out.end());\n\teach(it, out)cout << *it << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList(0);\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph(0);\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <list>\n#include <vector>\nusing namespace std;\nconst int num = 10000;\nvector<int> ne[num];\nint n, c[num];\nlist<int> ans;\ninline void dfs(int a) {\n\tc[a] = 1;\n\tfor (int i = 0; i < ne[a].size(); i++)\n\t\tif (c[ne[a][i]] == 0) dfs(ne[a][i]);\n\tans.push_front(a);\n}\ninline void tp() {\n\tfor (int i = 0; i < n; i++) \n\t\tif (c[i] == 0) dfs(i);\n}\nint main() {\n\tint p, s, t;\n\tcin >> n >> p;\n\tfor (int i = 0; i < p; i++) {\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tne[s].push_back(t);\n\t}\n\tfor (int i = 0; i < n; i++) c[i] = 0;\n\ttp();\n\tfor (int i = 0; i < n; i++) {\n\t\tlist<int>::iterator it  = ans.begin();\n\t\tprintf(\"%d\\n\", *it);\n\t\tans.pop_front();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    if(V == 2){\n        cout << 0 << endl << 1 << endl;\n        return 0;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint v, e;\n\tcin >> v >> e;\n\tvector<vector<int>> elist(v);\n\tvector<int> indeg(v);\n\tfor(int i=0; i<e; ++i){\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\telist[s].push_back(t);\n\t\t++indeg[t];\n\t}\n\tqueue<int> zeroq;\n\tfor(int i=0; i<v; ++i){\n\t\tif(indeg[i]==0) zeroq.push(i);\n\t}\n\tvector<int> result;\n\twhile(!zeroq.empty()){\n\t\tint u=zeroq.front();\n\t\tzeroq.pop();\n\n\t\tresult.push_back(u);\n\t\tfor(int i : elist[u]){\n\t\t\t--indeg[i];\n\t\t\tif(indeg[i]==0) zeroq.push(i);\n\t\t}\n\t}\n\n\tfor(int i : result) cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} fast;\n\nvoid yes() {\n    cout << \"Yes\" << endl;\n    exit(0);\n}\nvoid no() {\n    cout << \"No\" << endl;\n    exit(0);\n}\n#define REP(i, n) for (long long i = 0; i < (n); i++)\n\nvector<bool> visited(105);\nvector<vector<int>> edge(105);\nbool dfs(int cur, int par) {\n    // if a cycle doesn't exist, return true\n    visited[cur] = true;\n    bool ic = false;\n    if (edge[cur].size() == 0) {\n        return true;\n    } else {\n        for (int i = 0; i < edge[cur].size(); i++) {\n            if (edge[cur][i] == par) {\n                continue;\n            }\n            if (visited[edge[cur][i]]) {\n                ic = true;\n                break;\n            } else {\n                visited[edge[cur][i]] = true;\n            }\n            if (!dfs(edge[cur][i], cur)) {\n                ic = true;\n            }\n        }\n        if (ic) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\nint ctoi(char c) {\n    if (c >= '0' && c <= '9') {\n        return c - '0';\n    }\n    return 0;\n}\nlong long modpow(long long m, long long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long long t = modpow(m, n / 2);\n        return t * t % 2019;\n    } else {\n        return modpow(m, n - 1) * m % 2019;\n    }\n}\nsigned main() {\n    long long v, e;\n    cin >> v >> e;\n    vector<int> ans;\n    queue<int> zeros;\n    vector<vector<int>> graph(v);\n    vector<int> degree(v);\n    REP(i, e) {\n        // https/chess.com\n        int a, b;\n        cin >> a >> b;\n        graph[a].push_back(b);\n        degree[b]++;\n    }\n    REP(i, v) {\n        if (degree[i] == 0) {\n            zeros.push(i);\n        }\n    }\n    while (zeros.size() > 0) {\n        int cur = zeros.front();\n        zeros.pop();\n        ans.push_back(cur);\n        for (int i = 0; i < graph[cur].size(); i++) {\n            degree[graph[cur][i]]--;\n            if (degree[graph[cur][i]] == 0) {\n                zeros.push(graph[cur][i]);\n            }\n        }\n    }\n    REP(i, ans.size()) { cout << ans[i] << endl; }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 100000\n\nint V;\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\nvector <int> mlist;\nint indeg[MAX_V];\n\nvoid topologicalsort() {\n  memset(indeg, 0, sizeof(indeg));\n  for (int i = 0; i < V; i++) {\n    for (int j = 0; j < graph[i].size(); j++) {\n      int p = graph[i][j];\n      indeg[p]++;    \n    }\n  }\n\n  for (int i = 0; i < V; i++) {\n    if (indeg[i] == 0 && !vis[i]) {\n      queue<int> que;\n      que.push(i);\n      mlist.push_back(i);\n      vis[i] = true;\n      while (!que.empty()) {\n\tint p = que.front(); que.pop();\n\n\tfor (int j = 0; j < graph[p].size(); j++) {\n\t  int np = graph[p][j];\n\t  indeg[np]--;\n\t  if (vis[np]) continue;\n\t  if (indeg[np] == 0) {\n\t    vis[np] = true;\n\t    que.push(np);\n\t    mlist.push_back(np);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  int E;\n  cin >> V >> E;\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n  }\n  topologicalsort();\n\n  for (int i = 0; i < mlist.size(); i++) {\n    cout << mlist[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_Kahn(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,e,inDeg[100005];\nvector<int>graph[5*100005];\nvector<int>out;\n\nvoid init(int n, int e){\n    for(int i=0; i<e; i++){\n        int u,v;\n        cin>>u>>v;\n        graph[u].push_back(v);\n        inDeg[v]++;\n    }\n}\n\nvoid topo(){\n    queue<int>q;\n    for(int i=0; i<n; i++)if(inDeg[i]==0)q.push(i);\n\n    while(!q.empty()){\n        int u=q.front();\n        q.pop(); out.push_back(u);\n\n        int len=graph[u].size();\n\n        for(int i=0; i<len; i++){\n            int v=graph[u][i];\n            if(inDeg[v]>0){\n                inDeg[v]--;\n                if(inDeg[v]==0)q.push(v);\n            }\n        }\n    }\n}\n\nint main(){\n    cin>>n>>e;\n    init(n,e);\n    topo();\n    vector<int>::iterator it=out.begin();\n    for(it; it!=out.end(); it++)cout<<*it<<endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define REPr(i,n) for(int i=(n)-1;i>=0; --i)\n#define FORq(i, m, n) for(int i = (m);i <= (n);++i)\n#define SCD(n) scanf(\"%d\",&n)\n#define SCD2(m,n) scanf(\"%d%d\",&m,&n)\n#define SCD3(m,n,k) scanf(\"%d%d%d\",&m,&n,&k)\n#define SCLLD(n) scanf(\"%lld\",&n)\n#define SCLLD2(m,n) scanf(\"%lld%lld\",&m,&n)\n#define SCLLD3(m,n,k) scanf(\"%lld%lld%lld\",&m,&n,&k)\n#define PB push_back\n#define MP make_pair\n#define ARSCD(A,N) REP(i,N){SCD(A[i]);}\n#define ARSCD1(A,N) FORq(i,1,N){SCD(A[i]);}\n#define VSCD(v,N) REP(i,N){int x; SCD(x); v.PB(x);}\n#define VSCLLD(v,N) REP(i,N){long long x; SCLLD(x); v.PB(x);}\n#define PRINTD(n) printf(\"%d\\n\",n)\n#define PRINTLLD(n) printf(\"%lld\\n\",n)\n#define DEBUG printf(\"%s\\n\",\"debug\")\n#define fst first\n#define snd second\n#define SIN(x,S) (S.count(x) != 0)\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector < VI > VVI;\ntypedef vector<long long> VL;\ntypedef long long ll;\ntypedef long long integer;\n////////////////////////////////////////////////////////////////////\nstruct Vertex {\n\t// edge information\n\tvector<int> edges_to; //to vertex number\n\tvector<ll> edges_cost; // edge cost\n\t\n\t//for dijkstra\n\tbool done; //conform or not\n\tll cost; // now cost\n\tint from;\n\t\n\tbool operator<(const Vertex& another) const { // priority --> min\n        return another.cost < cost; // order(cost)\n    }\n\t\n\tbool operator==(const Vertex& another) const {\n        return another.cost == cost; // order(cost)\n    }\n};\n\nint main(){\n\tconst int V_MAX = 11002;\n\tconst int E_MAX = 100002;\n\tint V,E; SCD2(V,E);\n\tVertex v[V_MAX];\n\n\tREP(i,E){\n\t\tint s,t; SCD2(s,t);\n\t\tv[s].edges_to.PB(t);\n\t\tv[t].cost++;\n\t}\n\n\tstack<int> S;\n\tvector<int> ans;\n\n\tREP(i,V){\n\t\tif (v[i].cost == 0){\n\t\t\tS.push(i);\n\t\t}\n\t}\n\n\twhile(!S.empty()){\n\t\tint now = S.top(); S.pop();\n\t\tVertex nowV = v[now];\n\t\tans.PB(now);\n\t\tREP(i,nowV.edges_to.size()){\n\t\t\tint nto = nowV.edges_to[i];\n\t\t\tv[nto].cost--;\n\t\t\tif (v[nto].cost == 0) S.push(nto);\n\t\t}\n\t}\n\n\tREP(i,ans.size()){\n\t\tPRINTD(ans[i]);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvector<int> toposort(int n,vector<int> G[],int h[]){\n    stack<int> st;\n    vector<int> res;\n    for(int i=0;i<n;i++){\n        if(!h[i])st.push(i);\n    }\n    while(!st.empty()){\n        int id=st.top();\n        st.pop();\n        res.push_back(id);\n        for(auto e:G[id]){\n            h[e]--;\n            if(!h[e])st.push(e);\n        }\n    }\n    return res;\n}\nint main(){\n    int n,m;cin>>n>>m;\n    vector<int> G[10010];\n    int h[10010];\n    for(int i=0;i<m;i++){\n        int s,t;cin>>s>>t;\n        G[s].push_back(t);\n        h[t]++;\n    }\n    vector<int> ans=toposort(n,G,h);\n    for(auto e:ans){\n        cout<<e<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list> \nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n    V[u] = true;\n    for(int i = 0; i < G[u].size(); i++) {\n    \tint v = G[u][i];\n    \tif(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\n\nint main() {\n\tint s, t, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++) {\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n    \n    for(int i = 0; i < N; i++) {\n    \tif(!V[i]) dfs(i);\n    }\n    \n    for(list<int> ::iterator it = out.begin(); it != out.end(); it++) {\n    \tcout << *it << endl;\n    }\n    \n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\nusing namespace std;\n\nvector <int> edges[10000];\nint incoming[10000];\nbool used[10000];\nvector <int> order;\n\nvoid dfs(int cur){\n    used[cur] = true;\n    for(int i = 0; i < edges[cur].size(); i++){\n        if(!used[edges[cur][i]]){\n            dfs(edges[cur][i]);\n        }\n    }\n    order.push_back(cur);\n    return;\n}\n\nint main(){\n    int N;\n    int M;\n    cin >> N >> M;\n    for(int i = 0; i < M; i++){\n        int s;\n        int t;\n        cin >> s >> t;\n        edges[s].push_back(t);\n        incoming[t] ++;\n    }\n    vector <int> sources;\n    for(int i = 0; i < N; i++){\n        if(incoming[i] == 0){\n            sources.push_back(i);\n        }\n    }\n    for(int i = 0; i < sources.size(); i++){\n        dfs(sources[i]);\n    }\n\n    for(int i = 0; i < N; i++){\n        cout << order[N - 1 - i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <stdint.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\nconst int INF = (1 << 28);\nconst long INFL = (1LL << 50);\n\nclass FastIO {\npublic:\n  void flush() {\n    fflush(stdin);\n    fflush(stdout);\n  }\n  FastIO& operator >> (int &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (s64 &right) {\n    if( scanf(\"%ld\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (u32 &right) {\n    if( scanf(\"%d\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (double &right) {\n    if( scanf(\"%lf\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }\n    return *this;\n  }\n  FastIO& operator >> (char &right) {\n    if( scanf(\"%c\", &right) == EOF ) {\n      flush();\n      exit(0);\n    }     \n    return *this;\n  }\n  FastIO& operator >> (char right[]) {\n    if( scanf(\"%s\", right) == EOF ) {\n      flush();\n      exit(0);\n    }           \n    return *this;\n  }  \n  FastIO& operator << (const int& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u32& right) {\n    printf(\"%d\", right);\n    return *this;\n  }\n  FastIO& operator << (const u64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const s64& right) {\n    printf(\"%ld\", right);\n    return *this;\n  }\n  FastIO& operator << (const double& right) {\n    printf(\"%.20lf\", right);\n    return *this;\n  }\n\n  FastIO& operator << (const char right[]) {\n    printf(\"%s\", right);\n    return *this;\n  }\n  \n  FastIO& operator << (const char& right) {\n    printf(\"%c\", right);\n    return *this;\n  }\n};\n\nFastIO io;\n\n#include <cstdint>\n\ntypedef uint32_t u32;\n\nclass void_ {\n};\n\ntemplate<typename T>\nclass Weight {\nprotected:\n  T w_;\npublic:\n  const T& weight() const;\n};\n\ntemplate<>\nclass Weight<void_> : public void_ {\n};\n\ntemplate<typename Tweight>\nconst Tweight& Weight<Tweight>::weight() const {\n  return w_;\n}\n\ntemplate<typename Tweight>\nclass Edge : public Weight<Tweight> {\npublic:\n  Edge();\n  Edge(u32 from, u32 to);\n  Edge(u32 from, u32 to, Tweight w);\n  const u32& from() const;\n  const u32& to() const;\n  Edge reverse();\n  void dump();\nprivate:\n  u32 s, t;\n};\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge() {\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to) {\n  s = from; t = to;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight>::Edge(u32 from, u32 to, Tweight w) {\n  s = from; t = to;\n  this->w_ = w;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::from() const {\n  return s;\n}\n\ntemplate<typename Tweight>\nconst u32& Edge<Tweight>::to() const {\n  return t;\n}\n\ntemplate<typename Tweight>\nEdge<Tweight> Edge<Tweight>::reverse() {\n  Edge res = *this;\n  u32 tmp;\n  tmp = s; s = t; t = tmp;\n  return res;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nclass Graph {\npublic:\n  Graph();\n  void insert(Edge<Tweight> edge);\n  u32 Vsize();\n  void activate();\n  Edge<Tweight>* adjust(u32 v);\n  u32 adjust_size(u32 v);\nprivate:\n  Edge<Tweight> edge_[maxE];\n  u32 edge_num;\n  u32 vertex_num;\n  u32 adjust_size_[maxV];\n  u32 index[maxV];\n};\n\ntemplate<typename T, typename U>\nT Max(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg1 < arg2T ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename T, typename U>\nT Min(T arg1, U arg2) {\n  T arg2T = static_cast<T>(arg2);\n  if( arg2T < arg1 ) return arg2T;\n  return arg1;\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nGraph<Tweight, isdirected, maxV, maxE>::Graph() {\n  edge_num = 0;\n  vertex_num = 0;\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = 0;\n    index[i] = 0;\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::insert(Edge<Tweight> edge) {\n  edge_[edge_num] = edge;\n  edge_num += 1;\n  if( not isdirected ) {\n    edge_[edge_num] = edge.reverse();\n    edge_num += 1;\n  }\n  vertex_num = Max(vertex_num, edge.from());\n  vertex_num = Max(vertex_num, edge.to());\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nvoid Graph<Tweight, isdirected, maxV, maxE>::activate() {\n  Edge<Tweight> buffer[maxE];\n  u32 E = edge_num;\n  u32 count[maxV];\n  for(int i = 0; i < maxV; ++i) count[i] = 0;\n  for(int i = 0; i < E; ++i) {\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < maxV; ++i) {\n    adjust_size_[i] = count[i];\n  }\n  int t = 0;\n  for(int i = 0; i < maxV; ++i) {\n    t += count[i];\n    count[i] = t - count[i];\n    index[i] = count[i];\n  }\n  for(int i = 0; i < E; ++i) {\n    buffer[count[edge_[i].from()]] = edge_[i];\n    count[edge_[i].from()] += 1;\n  }\n  for(int i = 0; i < E; ++i) {\n    edge_[i] = buffer[i];\n  }\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nEdge<Tweight>* Graph<Tweight, isdirected, maxV, maxE>::adjust(u32 v) {\n  return &edge_[index[v]];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::adjust_size(u32 v) {\n  return adjust_size_[v];\n}\n\ntemplate<typename Tweight, bool isdirected, u32 maxV, u32 maxE>\nu32 Graph<Tweight, isdirected, maxV, maxE>::Vsize() {\n  return vertex_num;\n}\n\nu64 rdtsc() {\n  u64 u, l;\n  __asm__ volatile (\"rdtsc\" : \"=a\" (l), \"=d\" (u));\n  return (u << 32) | l;\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort(Graph<Tweight, true, maxV, maxE>& graph, int *id) {\n  bool used[maxV] = {};\n  int k = graph.Vsize();\n  for(int i = 1; i <= graph.Vsize(); ++i) {\n    if( not used[i] ) {\n      topological_sort_dfs(graph, id, used, i, k);\n    }\n  }\n}\n\ntemplate<typename Tweight, u32 maxV, u32 maxE>\nvoid topological_sort_dfs(Graph<Tweight, true, maxV, maxE>& graph, int *id, bool *used, int i, int& k) {\n  if( used[i] ) return;\n  used[i] = true;\n  u32 n = graph.adjust_size(i);\n  for(int j = 0; j < n; ++j) {\n    topological_sort_dfs(graph, id, used, graph.adjust(i)[j].to(), k);\n  }\n  id[k] = i;\n  k -= 1;\n}\n\nclass Solver {\nprivate:\npublic:\n  void solve() {\n    int V, E;\n    std::cin >> V >> E;\n    Edge<void_> edge;\n    Graph<void_, true, 10010, 100100> graph;\n    for(int i = 0; i < E; ++i) {\n      int s, t;\n      std::cin >> s >> t;\n      graph.insert(Edge<void_>(s + 1, t + 1));\n    }\n    graph.activate();\n    int id[10100] = {};\n    topological_sort(graph, id);\n    for(int i = 1; i <= V; ++i) {\n      std::cout << id[i] - 1 << std::endl;\n    }\n  }\n};\n\nint main() {\n\n  Solver solver;\n  solver.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list> \nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N, indeg[MAX];\n\nvoid bfs(int s) {\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v] --;\n\t\t\tif(indeg[v] == 0 && V[v] == false) {\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid tsort() {\n\tfor(int i = 0; i < N; i++) {\n\t\tindeg[i] = 0;\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tfor(int i = 0; i < G[u].size(); i++) {\n\t\t\tint v =  G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\t\n\tfor(int u = 0; u < N; u++) {\n\t\tif(indeg[u] == 0 && ! V[u]) bfs(u);\n\t}\n\t\n\tfor(list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n}\n\nint main() {\n\tint s, t, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++) {\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n    \n    tsort();\n    \n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass TSort{\npublic:\n  int V;\n  vector<unordered_set<int> > in,out;\n  vector<int> tp;\n  TSort():V(0){}\n  TSort(int V):V(V),in(V),out(V){}\n  \n  void add_edge(int from,int to){\n    assert(from >= 0 && to >= 0);\n    assert(from < V && to < V);\n    out[from].insert(to);\n    in[to].insert(from);\n  }\n\n  vector<int> dfs(){\n    vector<int> visited(V,0);\n    \n    function<void(int)> dfs = [&](int pos){\n      if(visited[pos]++) return;\n      for(int nx:out[pos]) dfs(nx);\n      tp.push_back(pos);\n    };\n    \n    tp.clear();\n    for(int i=0;i<V;i++) dfs(i);\n    reverse(tp.begin(),tp.end());\n    return tp;\n  }\n\n  vector<int> bfs(){\n    vector<unordered_set<int> > tmp = in;\n    tp.clear();\n    queue<int> Q;\n    for(int i=0;i<V;i++)if(in[i].empty()) Q.push(i);\n    \n    while(!Q.empty()){\n      int v = Q.front();Q.pop();\n      tp.push_back(v);\n      for(int nx:out[v]){\n        if(in[nx].size() == 1) Q.push(nx);\n        in[nx].erase(v);\n      }     \n    }\n    for(int i=0;i<V;i++) if(!in.empty()) tp.clear(); // exist loop\n    tmp = in;\n    return tp;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  TSort A(n);\n  \n  for(int i=0,a,b;i<m;i++)cin>>a>>b,A.add_edge(a,b);\n  \n  A.bfs();\n  for(int i=0;i<n;i++)cout<<A.tp[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> g;\n\nvector<int> topological_sort(vector<vector<int>> &g) {\n    int V = g.size();\n    vector<int> ans;\n\n    vector<int> ind(V);\n    for (int i = 0; i < V; ++i) for (int x: g[i]) ind[x]++;\n    queue<int> Q;\n    for (int i = 0; i < V; ++i) if (ind[i] == 0) Q.push(i);\n    while (!Q.empty()) {\n        int v = Q.front(); Q.pop(); \n        ans.push_back(v);\n        for (int x: g[v]) if (--ind[x] == 0) Q.push(x);\n    }\n    return ans;\n}\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    g.resize(v);\n    for (int i = 0; i < e; i++) {\n        int s, t;\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n\n    vector<int> ans = topological_sort(g);\n\n    for (int i = 0; i < v; i++) cout << ans[i] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Long = long long;\ntemplate<typename W>\nusing Edge = pair<int, W>;\ntemplate<typename W>\nusing WeightedGraph = vector<vector<Edge<W>>>;\nusing UnWeightedGraph = vector< vector<int>>;\n\nvoid bfs(int s,const UnWeightedGraph &g, vector<int> &indeg, vector<int> &used, vector<int> &order) {\n    queue<int> q;\n    q.push(s);\n    used[s] = true;\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        order.push_back(u);\n        for(auto &v: g[u]) {\n            indeg[v]--;\n            if(indeg[v] == 0 && !used[v]) {\n                used[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tpsort(const UnWeightedGraph &g, vector<int> &order){\n    vector<int> indeg(g.size(), 0);\n    vector<int> used(g.size(), false);\n    order.clear();\n    for(int u = 0;u < g.size(); u++)\n        for(int v: g[u])\n            indeg[v]++;\n    for(int u = 0;u < g.size(); u++)\n        if(indeg[u] == 0 && !used[u])\n            bfs(u, g, indeg, used, order);\n}\n\ntemplate<typename W>\nvoid tpsort(const WeightedGraph<W> &g, vector<int> &order) {\n    UnWeightedGraph g2(g.size());\n    for (int i = 0; i < g.size();i++) {\n        for(auto &e : g[i]) {\n            g2[i].emplace_back(e.first);\n        }\n    }\n    tpsort(g2, order);\n}\n\nint main() {\n    int V,E;\n    cin >> V >> E;\n    UnWeightedGraph g(V);\n    for(int i = 0;i < E;i++) {\n        int s, t;\n        cin >> s >> t;\n        g[s].emplace_back(t);\n    }\n\n    vector<int> order;\n    tpsort(g, order);\n    for (auto &e : order) {\n        cout << e << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for (ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\n#define inputv(v, n)    \\\n    rep(i, n)           \\\n    {                   \\\n        ll x;           \\\n        cin >> x;       \\\n        v.push_back(x); \\\n    }\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans = 0;\nstruct edge\n{\n    ll to, cost;\n};\nstruct Gragh\n{\n    vector<vector<edge>> G;\n    ll N;\n    vl visited;\n    vl active;\n    ll isloop = 0;\n    vl toposo;\n    void init(ll n)\n    {\n        N = n;\n        G.resize(N);\n        visited = vl(N, 0);\n    }\n\n    void add(ll a, ll b, ll c = 1)\n    {\n        G[a].push_back((edge){b, c});\n    }\n\n    void resetv(void)\n    {\n        visited = vl(N, 0);\n    }\n\n    vl TOPOSO(void)\n    {\n        active.resize(N);\n        active = vl(N, 0);\n        rep(i, N)\n        {\n            if (visited[i] == 0)\n                dfs(i);\n        }\n        reverse(all(toposo));\n        return toposo;\n    }\n\n    void dfs(ll x)\n    {\n        visited[x] = 1;\n        active[x] = 1;\n        for (edge i : G[x])\n        {\n            if (visited[i.to] == 0)\n            {\n                dfs(i.to);\n            }\n            else\n            {\n                if (active[i.to] == 1)\n                    isloop = 1;\n            }\n        }\n        active[x] = 0;\n        toposo.push_back(x);\n    }\n};\n\nint main()\n{\n    cin >> n >> m;\n    Gragh g;\n    g.init(n);\n    rep(i, m)\n    {\n        cin >> x >> y;\n        g.add(x, y);\n    }\n\n    vl A = g.TOPOSO();\n    rep(i, n)\n    {\n        cout << A[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include <cstdio>\n#include<queue>\n#include<map>\n#define WHITE 0\n#define GRAY  1\n#define BLACK 2\n#define endl '\\n'\n#define forup(i,a,n) for( int i =a; i < n; i++)\n#define llforup(i,a,n) for( ll i =a; i < n; i++)\n#define fordown(i,a,n) for( int i =a; i >= n; i--)\n#define fornot(i,a,n) for( int i=a;!n;i++)\n#define mod  (ll)(1e9+7)\n#define ifempty(a)  if(!a)\nusing namespace std;\ntypedef long long ll;\ninline int readnum()\n{\n\tint p, data = 0; char ch = 0;\n\twhile ((ch != '-') &&( ch < '0' || ch>'9') )//注意运算优先级，逻辑与大于逻辑非\n\t\tch = getchar();//相当于正则表达式的搜索，跳过不需要的字符\n\tif (ch == '-')\n\t\tp = -1, ch = getchar();//不能与if平行放置，不懂为什么，可能是bug\n\telse p = 1;\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + ch - '0', ch = getchar();//搜索需要的字符\n\treturn data * p;\n}\ninline int ReadPossitive()\n{\n\tchar ch; int data = 0;\n\tch = getchar();\n\twhile (ch == ' ' || ch == '\\n')ch = getchar();\n\twhile (ch != ' ' && ch != '\\n' && ch != EOF)\n\t{\n\t\tdata = data * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn data;\n}\n//E-mail 374656045@qq.com\nclass solve {\nprivate:\n\tint v, e;\n\tvector<int>*G;\n\tbool* vis;//有向图必须有vis,一次dfs||bfs能遍历一颗树，但是一个根和一棵树，但是一颗树可能有多个根2->3,1->3;\n\tint *order;\n\tint ordersize;\npublic://采用邻接表建图\n\tsolve(const char kind[])\n\t{\n\t\tinitial();\n\t\tif (kind == \"bfs\")\n\t\t{\n\t\t\tTsortBfs();\n\t\t\tforup(i, 0, ordersize)\n\t\t\t\tprintf(\"%d\\n\", order[i]);\n\t\t}\n\t\tif (kind == \"dfs\")\n\t\t{\n\t\t\tTsortDfs();\n\t\t\tfor(int i=ordersize-1;i>=0;i--)\n\t\t\t\tprintf(\"%d\\n\", order[i]);\n\t\t}\n\t}\n\tvoid initial()\n\t{\n\t\tv = ReadPossitive(); e = ReadPossitive();\n\t\tG = new vector<int>[v];\n\t\tvis = new bool[v]();\n\t\torder = new int[v];\n\t\tordersize = 0;\n\t\tint u, to;\n\t\tforup(i, 0, e)\n\t\t{\n\t\t\tu = ReadPossitive(); to = ReadPossitive();\n\t\t\tG[u].push_back(to);\n\t\t}\n\t}\n\tvoid TsortBfs()\n\t{\n\t\tint *indeg=new int[v]();//初始化入度为0\n\t\tforup(i,0,v)\n\t\t\tforup(j, 0, G[i].size())\n\t\t{\n\t\t\tindeg[G[i][j]]++;\n\t\t}\n\t\tforup(i, 0, v)\n\t\t\tif (indeg[i]==0&&!vis[i])\n\t\t\t{\n\t\t\t\tqueue<int>temp;\n\t\t\t\ttemp.push(i);\n\t\t\t\tint cur, son;\n\t\t\t\twhile (!temp.empty())\n\t\t\t\t{\n\t\t\t\t\tcur = temp.front(); temp.pop(); vis[cur] = true; order[ordersize++] = cur;\n\t\t\t\t\tforup(i, 0, G[cur].size())\n\t\t\t\t\t{\n\t\t\t\t\t    son = G[cur][i];\n\t\t\t\t\t\tindeg[son]--;\n\t\t\t\t\t\tif (indeg[son] == 0 && !vis[son])\n\t\t\t\t\t\t\ttemp.push(son);//避免多根共用的子树被重复操作,所以1->2,3->2的顺序是1,3,2。满足拓扑排序的要求：所有平级的父节点排在子节点前面。\n\t\t\t\t\t\t//先输出多根共用子树中不重合的部分，再输出重合的部分，这是跟TsortDfs不同的最大区别\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\tvoid TsortDfs()//思维相对简单一些\n\t{\n\t\tforup(i, 0, v)\n\t\t\tif(!vis[i])dfs(i);//直接递归，不手动写栈了\n\t}\n\tvoid dfs(int i)\n\t{\n\t\tvis[i] = true;\n\t\tint son;\n\t\tforup(j, 0, G[i].size())\n\t\t{\n\t\t\tson = G[i][j];\n\t\t\tif(!vis[son])\n\t\t\tdfs(son);\n\t\t}\n\t\torder[ordersize++] = i;//注意顺序是逆序的,并且是将多个根共用的子树根据先来后到原则进行剖分，剖分为独立子树输出（345012）\n\t}\n};\nint main(void)\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);//慎用，cin和scanf混用会导致非MSC++WA\n#ifdef DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tsolve solution(\"bfs\");\n#ifdef DEBUG\n\tfclose(stdin);//关闭文件 \n\tfclose(stdout);//关闭文件 \n#endif\n\treturn 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<functional>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\nvector<int>c[10000];\nbool used[10000];\nvector<int>V;\nvoid DFS(int a) {\n\tused[a] = true;\n\tfor (int i : c[a]) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tV.push_back(a);\n}\nsigned main() {\n\tint a, b; scanf(\"%d%d\", &a, &b);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f; scanf(\"%d%d\", &e, &f);\n\t\tc[f].push_back(e);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tfor (int i : V) {\n\t\tcout << i << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxx=10010;\n\nvector<int> A[maxx],ans;\nqueue<int> task;\nint f[maxx];\nbool flag[maxx];\nint v,e;\n\nint main (){\n\tint x,y;\n\tbool xx=false;\n\tcin>>v>>e;\n\tfor(int i=0;i<maxx;i++){\n\t\tf[i]=0;\n\t\tflag[i]=false;\n\t}\n\twhile(e--){\n\t\tcin>>x>>y;\n\t\tA[x].push_back(y);\n\t\tf[y]++;\n\t}\n\tfor(int i=0;i<v;i++) {\n\t\tif(f[i]==0&&flag[i]==false) {\n\t\t\ttask.push(i);\n\t\t\tflag[i]=true;\n\t\t}\n\t}\n\twhile(1){\n\t\txx=false;\n\t\twhile(task.empty()==0){\n\t\t\tx=task.front();\n\t\t\tans.push_back(x);\n\t\t\tfor(int k=0;k<A[x].size();k++){\n\t\t\t\tf[A[x][k]]--;\n\t\t\t\tif(f[A[x][k]]==0&&flag[A[x][k]]==false) {\n\t\t\t\t\ttask.push(A[x][k]);\n\t\t\t\t\tflag[A[x][k]]=true;\n\t\t\t\t\txx=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttask.pop();\n\t\t}\n\t\tif(xx==false) break;\n\t}\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<endl;\n\t}\n\treturn 0;\n\t\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_B\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return std::cout << \"\\n\", 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v), res[v].emplace_back(v, u);\n        if (bi) { es[v].emplace_back(v, u), res[u].emplace_back(u, v); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c), res[v].emplace_back(v, u, c);\n        if (bi) { es[v].emplace_back(v, u, c), res[u].emplace_back(u, v, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\ntemplate<typename Edge>\nstd::pair<bool, std::vector<usize>> top_sort(const base_graph<Edge>& g)\n{\n    const usize v = g.size();\n    std::vector<usize> srt, used(v, 0);\n    auto dfs = [&](auto&& self, const usize s) -> bool {\n        if (used[s] == 1) {\n            return false;\n        } else if (used[s] == 0) {\n            used[s] = 1;\n            for (const auto& e : g[s]) {\n                const usize to = e.to();\n                if (not self(self, to)) { return false; }\n            }\n            used[s] = 2, srt.push_back(s);\n        }\n        return true;\n    };\n    for (usize i = 0; i < v; i++) {\n        if (not dfs(dfs, i)) { return {false, srt}; }\n    }\n    std::reverse(srt.begin(), srt.end());\n    return {true, srt};\n}\nint main()\n{\n    const auto V = in<usize>();\n    const auto E = in<usize>();\n    graph g(V);\n    for (usize i = 0; i < E; i++) {\n        const usize s = in<usize>();\n        const usize t = in<usize>();\n        g.add_edge(s, t);\n    }\n    const auto vs = top_sort(g).second;\n    for (const usize v : vs) { outln(v); }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst static int WHITE = 0;\nconst static int GRAY = 1;\n\nstd::vector<int> color, indeg, ans;\nstd::vector<std::vector<int>> earray;\nint v;\nstd::queue<int> q;\n\nvoid bfs(int u){\n    q.push(u);\n    while(!q.empty()){\n        int node = q.front();\n        q.pop();\n        ans.push_back(node);\n        for(int i = 0; i < earray[node].size(); i++){\n            indeg[ earray[node][i] ]--;\n            if(indeg[ earray[node][i] ] == 0 && color[ earray[node][i] ] == WHITE){\n                color[ earray[node][i] ] = GRAY;\n                q.push(earray[node][i]);\n            }\n        }\n    }\n}\n\nvoid topologicalSort(){\n    for(int i = 0; i < v; i++){\n        if(indeg[i] == 0 && color[i] == WHITE){\n            bfs(i);\n        }\n    }\n}\n\nint main(void){\n    \n    int e, s, t;\n    \n    std::cin >> v >> e;\n    color.resize(v);\n    indeg.resize(v);\n    earray.resize(v);\n\n    for(int i = 0; i < v; i++){\n        indeg[i] = 0;\n    }\n\n    for(int i = 0; i < e; i++){\n        std::cin >> s >> t;\n        earray[s].push_back(t);       \n    }\n\n    for(int i = 0; i < v; i++){\n        for(int j = 0; j < earray[i].size(); j++){\n            indeg[ earray[i][j] ]++;\n        }\n    }\n\n    topologicalSort();\n\n    for(int i = 0; i < v; i++){\n        std::cout << ans[i] << std::endl;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"template.cc\"\n\nstd::vector<int> tsort(const Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    std::vector<int> res, flg(n, YET);\n    static const std::function<bool(int)> dfs = [&](int v) {\n        if(flg[v] == VISITED)\n            return false;\n        else if (flg[v] == YET) {\n            flg[v] = VISITED;\n            for (auto &e : g[v])\n                if (!dfs(e.dst)) return false;\n            flg[v] = DONE;\n            res.push_back(v);\n        }\n        return true;\n    };\n    for (int i = 0; i < n; ++i)\n        if (flg[i] == YET && !dfs(i)) return {};\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n\nusing namespace std;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nvector<int> topological_sort(const vector<vector<int>> &G, vector<int> in) {\n    vector<int> ret;\n    stack<int> st;\n    for(int i = 0; i < in.size(); i++)\n        if(in[i] == 0)\n            st.push(i);\n    while(st.size()) {\n        int v = st.top();\n        st.pop();\n        ret.push_back(v);\n        for(auto &nv : G[v]) {\n            in[nv]--;\n            if(in[nv] == 0)\n                st.push(nv);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> G(V, vector<int>());\n    vector<int> in(V);\n    rep(i, E) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n        in[t]++;\n    }\n    auto sorted = topological_sort(G, in);\n    for(auto x : sorted) {\n        cout << x << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int tgt_;\n\t  Edge(int t){\n\t\t\ttgt_ = t;\n\t  }\n};\n\ntypedef vector<vector<Edge> > Adj_list;\n\nvector<int> topological_sort(Adj_list G){\n\n\t  const int V = G.size();\n\n\t  vector<int> S; // ??\\?????????????????????\n\t  vector<int> inorder(V,0); // ??\\?????????????????????\n\t  \n\t  for(int i=0; i<V; i++) for(Edge& e : G[i]) inorder[e.tgt_]++;\n\t  for(int i=0; i<V; i++) if(inorder[i] == 0) S.push_back(i);\n\n\t  assert(S.size() > 0);\n\n\t  vector<int> topological_order;\n\t  while(S.size()){\n\t\t\tint v = S[S.size()-1]; S.pop_back();\n\t\t\ttopological_order.push_back(v);\n\n\t\t\tfor(int i=G[v].size()-1; i>=0; i--){\n\t\t\t\t  Edge e = G[v][i];\t// G[v].pop_back();\n\t\t\t\t  inorder[ e.tgt_ ]--; \n\n\t\t\t\t  if( inorder[e.tgt_] == 0) \tS.push_back( e.tgt_ );\n\t\t\t}\n\t  }\n\t  for(int i=0; i<V; i++) assert(inorder[i]==0);\n\t  return topological_order;\n}\n\n\nint main(){\n\n\t  int V,E; cin >> V >> E;\n\t  Adj_list G(V);\n\t  for(int i=0; i<E; i++){\n\t\t\tint s,t; cin >> s >> t;\n\t\t\tG[s].push_back( Edge(t) );\n\t  }\n\t  \n\t  vector<int> ans = topological_sort(G);\n\t  for(int i=0; i<V; i++)\n\t\t\tcout << ans[i] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);i++)\n#define FOR(i,a,n) for(int i=a;i<(int)(n);i++)\n#define FORR(x,arr) for(auto& x:arr)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) begin(c),end(c)\n#define PB push_back\n#define MP make_pair\nconst int DX[4]={0,1,0,-1}, DY[4]={-1,0,1,0};\nconst int INF = 1e9;\n\nint con[16][16];\nint main(int argc, char const *argv[]) {\n    int N,M;\n    cin >> N >> M;\n    REP(i,M) {\n        int x,y;\n        cin >> x >> y;\n        con[x][y]=1;\n    }\n    queue<int> q;\n    REP(i,N) {\n        bool f=false;\n        REP(j,N) {\n            if(con[j][i]==1) {\n                f=true;\n                break;\n            }\n        }\n        if(!f) q.push(i);\n    }\n\n    vector<int> t;\n    while(!q.empty()) {\n        int n=q.front(); q.pop();\n        t.PB(n);\n\n        REP(i,N) {\n            if(con[n][i]==1) {\n                con[n][i] = 0;\n                bool f = false;\n                REP(j,n) {\n                    if(con[j][i]==1) {\n                        f=true;\n                        break;\n                    }\n                }\n                if(!f) {\n                    q.push(i);\n                }\n            }\n        }\n    }\n    FORR(a,t) {\n        cout << a << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while( !q.empty() ){\n    int u = q.front();\n    q.pop();\n    out.push_back(u);\n\n    for(int i=0;i<G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\n// 各Nodeが処理しなければならない数を記録\nvoid tsort(){\n  for(int i=0;i<N;i++) indeg[i] = 0;\n\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for(int u=0;u<N;u++){\n    if(indeg[u] == 0 && !V[u]) bfs(u);\n  }\n\n  for(list<int>::iterator it = out.begin(); it != out.end();it++){\n    cout << *it << endl;\n  }\n}\n\nint main(){\n  int s,t,M;\n  cin >> N >> M;\n\n  // 初期化\n  for(int i=0;i<N;i++) V[i] = false;\n\n  // sに繋がるtを保存\n  for(int i=0;i<M;i++){\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define itn ll\n#define int ll\n//const int INF = 100100100;\nconst int INF = (1LL<<32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\n\nstatic const int MAX = 100000;\n\nint N;\nlist<int>  out;\nbool bV[MAX];\nvector<int> G[MAX];\n\nvoid dfs(int u) {\n\tbV[u] = true;\n\trep(i, G[u].size()) {\n\t\tint v = G[u][i];\n\t\tif (!bV[v])\n\t\t\tdfs(v);\n\t}\n\tout.push_front(u);\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tint s, t, M;\n\tcin >> N >> M;\n\trep(i, N) bV[i] = false;\n\trep(i, M) {\n\t\tcin >> s >> t;\n\t\tG[s].pb(t);\n\t}\n\trep(i, N) {\n\t\tif (!bV[i]) dfs(i);\n\t}\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\t//cin >> V >> E;\n\t//rep(i, E) {\n\t//\tint s, t;\n\t//\tcin >> s >> t;\n\t//\tG[s].pb(t);\n\t//}\n\t//rep(u, V) bV[u] = false;\n\t//rep(i, V) {\n\t//\tif (!bV[i])\n\t//\t\tdfs(i);\n\t//}\n\t//for (auto l : out)\n\t//\tcout << l << '\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nvector <int> adj[10007];\nint in[10007];\nqueue <int> q;\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<m;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        in[y]++;\n        adj[x].push_back(y);\n    }\n\n    for(int i=0;i<n;i++)\n        if(in[i]==0)\n            q.push(i);\n\n    while(q.size()>0)\n    {\n        int x=q.front();\n        q.pop();\n        in[x]=-1;\n        cout<<x<<\" \";\n        for(int i=0;i<adj[x].size();i++)\n        {\n            in[adj[x][i]]--;\n            if(in[adj[x][i]]==0)\n                q.push(adj[x][i]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst ll INF = 400000000000;\nconst int NUM = 10010;\nclock_t START, END;\n\nqueue<int> Q;\nlist<int> out;\nvector<int> G[NUM];\nint indeg[NUM], cor[NUM];\nint V;\n\nvoid bfs(int s)\n{\n\tint u;\n\tQ.push(s);\n\tcor[s] = 1;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tQ.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && cor[v] == 0) {\n\t\t\t\tcor[v] = 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in44.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint E, s, t;\n\tbool negative = false;\n\tcin >> V >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\tfor (int i = 0; i < V; i++) {\n\t\tif (indeg[i] == 0 && cor[i] == 0)\n\t\t\tbfs(i);\n\t}\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++)\n\t\tcout << *it << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\n// Graph Templates\nusing Weight = ll;\n// using Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    // Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\nconst Weight inf = numeric_limits<Weight>::max() / 8;\n\n// add edge a <--(weight = w)--> b\nvoid add_edge(Graph &g, int a, int b, Weight w) {\n    g[a].push_back(Edge(a, b, w));\n    g[b].push_back(Edge(b, a, w));\n}\n\n// add edge a --(weight = w)--> b\nvoid add_arc(Graph &g, int a, int b, Weight w) { g[a].push_back(Edge(a, b, w)); }\n\n// topological sort\n// g : directed acyclic graph\n// return : ord or empty vector array\nvector<int> tsort(const Graph &g) {\n    int n = g.size(), k = 0;\n    std::vector<int> ord(n), in(n);\n    for (auto &es : g)\n        for (auto &e : es) in[e.dst]++;\n    std::queue<int> q;\n    for (int i = 0; i < n; ++i)\n        if (in[i] == 0) q.push(i);\n    while (q.size()) {\n        int v = q.front();\n        q.pop();\n        ord[k++] = v;\n        for (auto &e : g[v])\n            if (--in[e.dst] == 0) q.push(e.dst);\n    }\n    return *std::max_element(in.begin(), in.end()) == 0 ? ord : std::vector<int>();\n}\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n    int s, t;\n    Graph g;\n    g.resize(v);\n    for (int i=0; i<e; ++i){\n        cin >> s >> t;\n        add_arc(g, s, t, 1);\n    }\n    vector<int> ans = tsort(g);\n    for (int i=0; i<v; ++i){\n        cout << ans[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n\n#define P push\n#define PB push_back\n#define F(i,a,b) for (ll i=a; i<=b; i++)\n#define FF(i,a,b) for (ll i=b; i>=a; i--)\nusing namespace std;\ntypedef long long int ll;\nconst int maxN=1e5+100;\n\nvector <int> g[maxN],topol;\nint n,m,x,y;\nbool mark[maxN];\nvoid dfs(int v)\n{\n  mark[v]=true;\n  if(g[v].size())\n    F(i,0,g[v].size()-1)\n      {\n\tif(!mark[g[v][i]])\n\t  dfs(g[v][i]);\n      }\n  topol.PB(v);\n}\nvoid input()\n{\n  cin>>n>>m;\n  F(i,1,m)\n    {\n      cin>>x>>y;\n      g[x+1].PB(y+1);\n    }\n}\nint main()\n{\n  //ios::sync_with_stdio(false);\n  input();\n  F(i,1,n)\n    {\n      if(!mark[i])\n\tdfs(i);\n    }\n  reverse(topol.begin(),topol.end());\n  F(i,0,topol.size()-1)\n    cout<<topol[i]-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// O(|E| + |V|)\n\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass TopologicalSort {\n#define MAX_V 101\nprivate:\n\n  struct Edge {\n    int to;\n    Edge(int to): to(to) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n  TopologicalSort(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to) {\n    G[from].push_back(Edge(to));\n  }\n\n  vector<int> Solve() {\n    int k = 0;\n    vector<int> ord(V), in(V);\n    for (int i = 0; i < V; i++) {\n      for (auto &e : G[i]) {\n        in[e.to]++;\n      }\n    }\n    queue<int> q;\n    for (int i = 0; i < V; i++) {\n      if (in[i] == 0) {\n        q.push(i);\n      }\n    }\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      ord[k++] = v;\n      for (auto &e : G[v]) {\n        if (--in[e.to] == 0) {\n          q.push(e.to);\n        }\n      }\n    } \n\n    return (*max_element(in.begin(), in.end()) == 0)? ord : vector<int>();\n  }\n};\n\n#include <iostream>\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  TopologicalSort ts(V);\n\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    ts.AddEdge(s, t);\n  }\n\n  vector<int> ans = ts.Solve();\n\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nstatic const int VERTEX_MAX = 100000;\nstatic const int INF = 1 << 29;\n\nusing namespace std;\n\n\nvector<int>\t\tGraph[VERTEX_MAX];\t\t//各頂点から他の頂点への出辺\nint\t\t\t\tIndegree[VERTEX_MAX];\t//各頂点の入次数\nbool\t\t\tUsed[VERTEX_MAX];\t\t//各頂点のソート済みフラグ\n\nint\t\t\t\tnum_vertex;\nint\t\t\t\tnum_edge;\nvector<int>\t\tsorted_vertices;\t\t//トポロジカルソートされた頂点\n\n\nvoid breadth_first_search(int vertex) {\n\tqueue<int> queue;\n\tqueue.push(vertex);\n\tUsed[vertex] = true;\n\n\twhile (!queue.empty()) {\n\t\tint front_v = queue.front();\n\t\tqueue.pop();\n\t\t\n\t\t//ここに来る頂点は入次数が0なのでソートされた行列にpushbackできる\n\t\tsorted_vertices.push_back(front_v);\n\n\t\tfor (int i = 0; i < Graph[front_v].size(); i++) {\n\t\t\tint next_v = Graph[front_v][i];\n\t\t\tIndegree[next_v]--;\t\t//front_vからの入辺がなくなるので入次数を一つ減らす\n\n\t\t\tif (Indegree[next_v] == 0 && !Used[next_v]) {\n\t\t\t\tUsed[next_v] = true;\n\t\t\t\tqueue.push(next_v);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid topological_sort() {\n\t//入次数初期化\n\tfor (int v_i = 0; v_i < num_vertex; v_i++) {\n\t\tIndegree[v_i] = 0;\n\t}\n\t//入力条件から入次数を入力\n\tfor (int v_i = 0; v_i < num_vertex; v_i++) {\n\t\tfor (int i = 0; i < Graph[v_i].size(); i++) {\n\t\t\tint v = Graph[v_i][i];\n\t\t\tIndegree[v]++;\n\t\t}\n\t}\n\t\n\tfor (int v_i = 0; v_i < num_vertex; v_i++) {\n\t\tif (Indegree[v_i] == 0 && !Used[v_i]) {//源点か、現時点で入次数が0で未使用の頂点に対して幅優先探索\n\t\t\tbreadth_first_search(v_i);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main() {\n\tcin >> num_vertex >> num_edge;\n\n\tfor (int i = 0; i < num_vertex; i++) {\n\t\tUsed[i] = false;\n\t}\n\n\tint s, t;\n\tfor (int i = 0; i < num_edge; i++) {\n\t\tcin >> s >> t;\n\t\tGraph[s].push_back(t);\n\t}\n\n\ttopological_sort();\t\n\n\tfor (vector<int>::iterator it = sorted_vertices.begin(); it != sorted_vertices.end(); ++it) {\n\t\tcout << *it << endl;\n\t}\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <tuple>\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n\n// Graph template (start)\ntemplate <class... Args>\nstruct Edge\n{\n    int from, to;\n    std::tuple<Args...> values;\n    Edge(int from, int to, Args... values)\n        : from(from), to(to), values(values...) {}\n};\n\ntemplate <class E>\nauto operator<(const E &e, const E &f)\n{\n    return e.values > f.values;\n}\n\ntemplate <class... Args>\nclass Graph\n{\n    using Edges = std::vector<Edge<Args...>>;\n    std::vector<Edges> graph_;\n\n  public:\n    Graph(int n) : graph_(n) {}\n    std::size_t size() { return graph_.size(); };\n    std::size_t size() const { return graph_.size(); };\n    auto &operator[](unsigned int x) { return graph_[x]; }\n    const auto &operator[](unsigned int x) const { return graph_[x]; }\n    void AddEdge(int s, int t, Args... v) { graph_[s].emplace_back(s, t, v...); }\n    void AddEdge(Edge<Args...> e) { graph_[e.from].push_back(e); }\n};\n// Graph template (end)\n\n//再帰ラムダ用テンプレート\ntemplate <typename F>\nclass FixPoint : F\n{\n  public:\n    explicit constexpr FixPoint(F &&f) noexcept\n        : F(std::forward<F>(f))\n    {\n    }\n\n    template <typename... Args>\n    constexpr decltype(auto)\n    operator()(Args &&... args) const\n    {\n        return F::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic inline constexpr decltype(auto)\nmakeFixPoint(F &&f) noexcept\n{\n    return FixPoint<F>{std::forward<F>(f)};\n}\n\n//トポロジカル順序でソートされた、頂点集合の配列を返す\ntemplate <typename G>\nauto TopologicalSort(const G &g)\n{\n    const int kSize = g.size();\n    std::vector<int> sorted;\n    sorted.reserve(kSize);\n    std::vector<bool> visited(kSize, false);\n    auto topo_dfs = makeFixPoint([&](auto f, int n) -> void {\n        if (!visited[n])\n        {\n            visited[n] = true;\n            for (const auto &e : g[n])\n            {\n                f(e.to);\n            }\n            sorted.push_back(n);\n        }\n    });\n    for (int i = 0; i < kSize; ++i)\n    {\n        topo_dfs(i);\n    }\n    std::reverse(sorted.begin(), sorted.end());\n    return sorted;\n}\n\nint main()\n{\n    int n, m;\n    std::cin >> n >> m;\n    Graph<> g(n);\n    for (int i = 0; i < m; ++i)\n    {\n        int u, v;\n        std::cin >> u >> v;\n        g.AddEdge(u, v);\n    }\n    auto ans = TopologicalSort(g);\n    for (auto x : ans)\n    {\n        std::cout << x << std::endl;\n    }\n}\n// be checked by AOJ(GRL-4-B).\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nstruct TopologicalSort {\n\tint n;\n\tvector< vector<int> > G;\n\tvector<bool> used;\n\tvector<int> indeg,order;\n\n\tTopologicalSort() {}\n\tTopologicalSort(int sz):n(sz),G(sz),used(sz),indeg(sz) {};\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t}\n\n\n\tvector<int> topological_sort() {\n\t\tfill(indeg.begin(),indeg.end(),0);\n\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tfor(auto u:G[v]) indeg[u]++;\n\t\t}\n\t\tqueue<int> Q;\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(indeg[v]==0) Q.push(v);\n\t\t}\n\t\twhile(!Q.empty()) {\n\t\t\tint v=Q.front();Q.pop();\n\t\t\torder.push_back(v);\n\t\t\tfor(auto u:G[v]) {\n\t\t\t\tif(--indeg[u]==0) Q.push(u);\n\t\t\t}\n\t\t}\n\n\t\treturn order;\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V,E;\n\tcin>>V>>E;\n\tTopologicalSort tsort(V);\n\tfor(int i=0;i<E;i++) {\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\ttsort.add_edge(u,v);\n\t}\n\tauto order=tsort.topological_sort();\n\tfor(auto v:order) cout<<v<<endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int MAXV = 1e4 + 7, MAXE = 1e5 + 7;\nint anspos;\nbool vis[MAXV];\nint ans[MAXE];\nvector <int> G[MAXV];\nvoid dfs(int cur) {\n\tvis[cur] = true;\n\tfor (int i = 0; i < G[cur].size(); i++) {\n\t\tif (!vis[G[cur][i]]) dfs(G[cur][i]);\n\t}\n\tans[--anspos] = cur;\n}\nint main() {\n    int v, e;\n    scanf(\"%d%d\", &v, &e);\n    anspos = v;\n    while (e--) {\n    \tint s, t;\n    \tscanf(\"%d%d\", &s, &t);\n    \tG[s].push_back(t);\n\t}\n\tfor (int i = 0; i < v; i++) {\n\t\tif (!vis[i]) dfs(i);\n\t}\n\tfor (int i = 0; i < v; i++) {\n\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n  queue<int> q;\n  q.push(s);\n  V[s] = true;\n  while ( !q.empty() ) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 && !V[v] ) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort() {\n  for ( int i = 0; i < N; i++ )\n    indeg[i] = 0;\n\n  for ( int u = 0; u < N; u++ )\n    for ( int i = 0; i < G[u].size(); i++ ) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n\n  for ( int u = 0; u < N; u++ )\n    if ( indeg[u] == 0 && !V[u] ) bfs(u);\n\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ )\n    cout << *it << endl;\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for ( int i = 0; i < N; i++ ) V[i] = false;\n\n  for ( int i = 0; i < M; i++ ) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  tsort();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ????????°????????????????????????????????????????±???????O(|V|^2)?:cycledetectDirected()\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ????????°????????§??°\n#define MAX_V 100000\n// ??°????????????????????°\nint V;\nvector <int> graph[MAX_V];\nbool vis[MAX_V];\n// ?????????????????????????????????????????????\nvector <int> list;\n// ??\\????¬???°\nint indeg[MAX_V];\n\n// ??\\????¬???°???0???????????????????????????????????¢?´¢??????????????°???????¨?????????????????¬???°???1?????????????????\\????????°???0???????????°???????????????????????????????§?\nvoid topologicalsort() {\n  memset(indeg, 0, sizeof(indeg));\n  for (int i = 0; i < V; i++) {\n    for (int j = 0; j < graph[i].size(); j++) {\n      int p = graph[i][j];\n      indeg[p]++;\n    }\n  }\n\n  // queue????????§?????????push?????????????????????????????????????????????????????????\n  for (int i = 0; i < V; i++) {\n    if (indeg[i] == 0 && !vis[i]) {\n      queue<int> que;\n      que.push(i);\n      list.push_back(i);\n      vis[i] = true;\n      while (!que.empty()) {\n\tint p = que.front(); que.pop();\n\n\tfor (int j = 0; j < graph[p].size(); j++) {\n\t  int np = graph[p][j];\n\t  indeg[np]--;\n\t  if (vis[np]) continue;\n\t  if (indeg[np] == 0) {\n\t    vis[np] = true;\n\t    que.push(np);\n\t    list.push_back(np);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  int E;\n  cin >> V >> E;\n  for (int i = 0; i < E; i++) {\n    int s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n  }\n  topologicalsort();\n\n  for (int i = 0; i < list.size(); i++) {\n    cout << list[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    unordered_set<int> g[n];\n    int f, t;\n\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f].insert(t);\n    }\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n\n    for (int i = 0; i < n; i++) {\n        int d = 0;\n        for (int j = 0; j < n; j++) {\n            if (g[j].find(i) != g[j].end())\n                d++;\n        }\n\n        if (!d)\n            q.push(i);\n\n        mm[i] = d;\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        cout << v << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            if (g[v].find(i) != g[v].end()) {\n                int e = mm[i]-1;\n                if (!e)\n                    q.push(i);\n\n                mm[i] = e;\n            }\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst auto gcu = getchar_unlocked;\nconst auto pcu = putchar_unlocked;\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n_T _DEF(T,in,int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_DEF(int, in){return in<int>(gcu());}\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n_T _SCAN(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_DEF(bool, scan, char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_SCAN(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_OUT(string s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b,m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=n%10*m+'0',n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _OUT(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _OUTL(T&&... t){out(move(t)...);outl();}\nstruct range{\n\tint e,b=0,s=1;\n\trange(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it { int v, s; it (int _v, int _s) : v(_v), s(_s) {} operator int()const{return v;} operator int&(){return v;} int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin() {return {b, s};} it end() {return {e, s};}};\n\nint main() {\n\tint V {in()};\n\tvector<vector<int>> n(V);\n\tvector<int> v(V);\n\tfor (int E {in()}; E; E--) {\n\t\tint a {in()}, b {in()};\n\t\tn[a].push_back(b);\n\t\tv[b]++;\n\t}\n\tqueue<int> q;\n\tfor (int i: range(V))\n\t\tif (!v[i])\n\t\t\tq.push(i);\n\twhile(!q.empty()) {\n\t\tint i = q.front();\n\t\tq.pop();\n\t\toutl(i);\n\t\tfor (int j: n[i])\n\t\t\tif (!(--v[j]))\n\t\t\t\tq.push(j);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nvector<int> deg;\n\nvoid tsort(int n, vector<int>& res) {\n\tqueue<int> que;\n\trep(i,n){\n        if(deg[i] == 0){\n            que.push(i);\n        }\n    }\n\twhile(!que.empty()){\n\t\tint p = que.front();\n        que.pop();\n\t\tres.pb(p);\n\t\trep(i,G[p].size()){\n            if(--deg[G[p][i]] == 0){\n                que.push(G[p][i]);\n            }\n        }\n\t}\n\tif(*max_element(all(deg)) != 0){\n        res.clear();\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    deg.resize(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        G[a].push_back(b);\n        deg[b]++;\n    }\n    vector<int> res;\n    tsort(n,res);\n    if((int)res.size() != 0){\n        rep(i,res.size()){\n            cout << res[i] << endl;\n        }\n    }else{\n        cout << \"-1\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {1, 1, 0, -1, -1, 0};\nint dx[] = {1, 0, -1, -1, 0, 1};\n#define ceil(a, b) a / b + !!(a % b)\n\nstruct Node {\n    int parent = -1;\n    \n};\nint main() {\n    int v, e; cin >> v >> e;\n    Node node[v];\n    rep(i, e) {\n        int s, t; cin >> s >> t;\n        node[t].parent = s;\n    }\n    //vector<int> comb; 1組だけ出せばいい\n    queue<int> q;\n    rep(i, v) if (node[i].parent == -1) {q.push(i); cout << i << endl;}\n    while (!q.empty()) {\n        int now = q.front();\n        rep(i, v) {\n            if (node[i].parent == now) {\n                q.push(i);\n                cout << i << endl;\n            }\n        }\n        q.pop();\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <unordered_set>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<ll> > vvll;\ntypedef map<int, int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define itn int\n#define endl '\\n';\n#define fi first\n#define se second\n#define NONVOID [[nodiscard]]\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\n\nvvi G(10000); // グラフ(リスト)\n\n// トポロジカルソート\nvoid rec(int v, vector<bool> &seen, vector<int> &order) {\n    seen[v] = true;\n    for (int i= 0; i < G[v].size(); i++) {\n        int next = G[v][i];\n        if (seen[next]) continue; // 既に訪問済みなら探索しない\n        rec(next, seen, order);\n    }\n    order.push_back(v);\n}\n\nvector<int> topo(int N) { // Nはノード数\n    // 探索\n    vector<bool> seen(N, 0); // 初期状態では全ノードが未訪問\n    vector<int> order; // トポロジカルソート順\n    for (int v = 0; v < N; ++v) {\n        if (seen[v]) continue; // 既に訪問済みなら探索しない\n        rec(v, seen, order);\n    }\n    reverse(order.begin(), order.end());\n    return order;\n}\n\nint main() {\n    \n    int n,m;\n    cin>>n>>m;\n    rep(i,m){\n        int s,t;\n        cin>>s>>t;\n        G[s].pb(t);\n    }\n    vi v=topo(n);\n    rep(i,v.size())fin(v[i]);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n    for (int i = 0; i < n; i++)\n        mm[i] = 0;\n\n    int f, t;\n    unordered_set<int> g[n];\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f].insert(t);\n        mm[t]++;\n    }\n\n    for (const auto& p : mm) {\n        if (!p.second)\n            q.push(p.first);\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        cout << v << \"\\n\";\n\n        for (int vv : g[v]) {\n            int d = mm[vv]-1;\n            if (!d)\n                q.push(vv);\n            mm[vv] = d;\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP0(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define REP1(i,n) for(int i=1, i##_len=(n); i<=i##_len; ++i)\n#define RREP0(i,n) for(int i=n-1; i>=0; --i)\n#define RREP1(i,n) for(int i=n; i>=1; --i)\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\nconst int INTINF = 2147483647;\nconst LL LLINF = 9223372036854775807;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int WHITE = 0;\nconst int GRAY = 1;\nconst int BLACK = 2;\nconst int MAX = 100000;\n\nVI G[MAX]; // G[i] には iから到達可能な頂点が入る\nlist<int> out;\nbool V[MAX];\nint N, E;\nint indeg[MAX]; // 入次数=到達に必要な仕事(ノード)の数\n\nstruct init{\n    init(){\n        cin.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(20);\n    };\n} init;\n\n\nvoid input(){\n  int s,t;\n  std::cin >> N >> E;\n\n  REP0(i,N) V[i] = false;\n\n  REP0(i,E){\n    std::cin >> s >> t;\n    G[s].PB(t);\n  }\n\n}\n\n\nvoid bfs( int s ) {\n  queue<int> Q;\n  Q.push(s);\n  V[s] = true;\n\n  while ( !Q.empty() ) {\n    int u = Q.front(); Q.pop();\n    out.PB(u);\n    REP0( i, G[u].size() ){ // u に到達したら\n      int v = G[u][i]; // uから到達可能な頂点の入次数を下げる\n      indeg[v]--;\n      if ( indeg[v]==0 && !V[v] ) {\n        V[v] = true;\n        Q.push(v);\n      }\n    }\n  }\n\n}\n\n\nvoid tsort(){\n  REP0( i, N ) indeg[i] = 0;\n\n  REP0( u, N ){\n    REP0( i, G[u].size() ){ // 各点から到達可能な頂点を列挙することで入次数をカウント\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  REP0( u, N ){\n    if ( indeg[u]==0 && !V[u] ) bfs(u);\n  }\n\n}\n\n\nvoid output(){\n  for ( list<int>::iterator it = out.begin(); it != out.end(); it++ ) {\n    std::cout << *it << '\\n';\n  }\n}\n\n\nint main(int argc, char const *argv[]) {\n  input();\n  tsort();\n  output();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Topological Sort\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nqueue<int> Q;\nlist<int> out;\nbool V[MAX] = {};\nint indeg[MAX] = {};\nint N;\n\nvoid bfs(int u) {\n    while(!Q.empty()) Q.pop();\n    int v;\n    Q.push(u);\n    V[u] = true;\n    while(!Q.empty()) {\n        v = Q.front();\n        Q.pop();\n        out.push_back(v);\n        for(auto i : G[v]) {\n            indeg[i]--;\n            if(indeg[i] == 0) {\n                Q.push(i);\n                V[i] = true;\n            }\n        }\n    }\n}\n\nvoid topologivalSort() {\n    for(int i = 0; i < N; i++) {\n        if(indeg[i] == 0 && !V[i]) bfs(i);\n    }\n}\n\nint main() {\n    int M, s, t;\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    topologivalSort();\n\n    for(auto itr = out.begin(); itr != out.end(); itr++) cout << *itr << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX]; // 入力次数\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u=q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n\n    for(int u=0; u<N; u++){\n        for(int i=0; i<G[u].size(); i++){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0; u<N; u++){\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n    for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    int s, t, M;\n    cin >> N >> M;\n\n    for(int i=0; i<N; i++) V[i] = false;\n\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N, E;\nint g[10000][10000];\nvector<int> out;\nchar col[10000];\n\nvoid toposort(int s) {\n    col[s] = 'g';\n    for (int i = 0; i < N; ++i) {\n        if(g[s][i] && col[i] == 'w') {\n            toposort(i);\n        }\n    }\n    out.push_back(s);\n}\nint main() {\n    cin >> N >> E;\n    for (int i = 0; i < E; ++i) {\n        int s, t ;\n        cin >> s >> t;\n        g[s][t] = 1;\n    }\n\n    for (int j = 0; j < N; ++j) {\n        col[j] = 'w';\n    }\n    for (int k = 0; k < N; ++k) {\n        int sum = 0;\n        for (int i = 0; i < N; ++i) {\n            sum += g[i][k];\n        }\n        if(!sum && col[k] == 'w') {\n\n            toposort(k);\n        }\n    }\n\n    for (int l = N-1; l >=0; --l) {\n        if(l) cout << \" \";\n        cout << out.at(l) ;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 0);\n\n    for (int i = 0; i < E; i++) {\n        state[edge[i].second]++;\n    }\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 0) {\n                ans.push_back(i);\n                for (int j = 0; j < edge.size(); j++) {\n                    if (edge[j].first == i) {\n                        state[edge[j].second]--;\n                        edge[j] = edge.back();\n                        edge.pop_back();\n                        j--;\n                    }\n                }\n                state[i]--;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INF = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while (!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for (int i = 0; i < G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid topological_sort(){\n    for (int i = 0; i < N; i++){\n        indeg[i] = 0;\n    }\n    for (int u = 0; u < N; u++){\n        for (int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }   \n    }\n    for (int u = 0; u < N; u++){\n        if (indeg[u] == 0 && !V[u]){\n            bfs(u);\n        }\n    }\n    for (list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }    \n}\n\nint main(){\n    int s, t, M;\n    cin >> N >> M;\n    for (int i = 0; i < N; i++){\n        V[i] = false;\n    }\n    for (int i = 0; i < M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    topological_sort();\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass TopologicalSort {\n    int V;\n    vector <vector<int>> G;\n    vector <bool> used;\n    vector <int> indeg; // 入次数\n    vector <int> ret;\n\n    void bfs(int s) {\n        queue<int> q;\n        q.push(s);\n        used[s] = 1;\n        while (!q.empty()) {\n            int cur = q.front(); q.pop();\n            ret.push_back(cur);\n            for (int to : G[cur]) {\n                indeg[to]--;\n                if (indeg[to] == 0 && !used[to]) {\n                    used[to] = 1;\n                    q.push(to);\n                }\n            }\n        }\n    }\n\npublic:\n    TopologicalSort(vector<vector<int>> &edge) {\n        V = edge.size();\n        G = edge;\n        used.assign(V, false);\n        indeg.assign(V, 0);\n    }\n\n    vector<int> build() {\n        for (int i = 0; i < V; i++) for (int v : G[i]) indeg[v]++;\n        for (int i = 0; i < V; i++) if (indeg[i] == 0 && !used[i]) bfs(i);\n        return ret;\n    }\n};\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/4/GRL_4_B\nvoid AOJ_GRL_4_B() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> edge(V);\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge[s].push_back(t);\n    }\n    TopologicalSort ts(edge);\n    vector <int> dag = ts.build();\n    for (int i : dag) cout << i << '\\n';\n}\n\nint main() {\n    AOJ_GRL_4_B();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n\nusing namespace std;\n\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n  V[u] = true;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!V[v]) {\n      dfs(v);\n    }\n  }\n  out.push_front(u);\n}\n\nint main() {\n  int s, t, M;\n\n  cin >> N >> M;\n\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (!V[i]) {\n      dfs(i);\n    }\n  }\n\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nvoid visit(const vector<vector<int>>& g, int u, vector<bool>&used, vector<int>& ans) {\n\n    if( used[u] == false ) {\n\tused[u] = true;\n\tfor(auto& v : g[u]) {\n\t    visit(g, v, used, ans);\n\t}\n\tans.emplace_back(u);\n    }\n}\n\nvector<int> tsort_Tarjan(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<bool> used(V,false);\n    vector<int> ans;\n    for (int u=0; u<V; ++u) {\n\tvisit(g, u, used, ans);\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n\n// tsort_Kahn??¨???????????????\nvector<int> tsort_BFS(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    queue<int>  Q;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    Q.push(i);\n    \n    vector<int> ans;\n    while( Q.size() ) {\n\tint u = Q.front(); Q.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) Q.push(v);\n\t}\n    }\n    return ans;\n}\n\n\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_Kahn(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstd::vector<bool> cango;\nstd::stack<int> ans;\n\nvoid dfs(std::vector<std::vector<int> > &g,int now){\n    cango[now]=false;\n    for(size_t i=0;i<g[now].size();++i){\n        if(cango[g[now][i]])dfs(g,g[now][i]);\n    }\n    ans.push(now);\n}\n\nint main(){\n    int v,e;\n    std::cin>>v>>e;\n    std::vector<std::vector<int> > g(v);\n    std::vector<int> ec(v,0);\n    for (int i = 0; i < e; ++i) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        g[s].push_back(t);\n    }\n    cango=std::vector<bool>(v,true);\n    for (int i = 0; i < v; ++i) {\n        if(cango[i])dfs(g,i);\n    }\n    while(!ans.empty()){\n        printf(\"%d\\n\",ans.top());\n        ans.pop();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct TopologicalSort{\n  int n;\n  vector<set<int> > G;\n  vector<int> indeg,V,p;\n  TopologicalSort(){}\n  TopologicalSort(int sz):n(sz),G(n),indeg(n),V(n){}\n\n  void add_edge(int s,int t){\n    G[s].insert(t);\n  }\n  \n  void bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n      int u=q.front();q.pop();\n      p.push_back(u);\n      for(int v:G[u]){\n\tindeg[v]--;\n\tif(indeg[v]==0&&!V[v]){\n\t  V[v]=1;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  \n  void tsort(){\n    fill(V.begin(),V.end(),0);\n    fill(indeg.begin(),indeg.end(),0);\n    for(int u=0;u<n;u++)\n      for(int v:G[u])\n\tindeg[v]++;\n    for(int u=0;u<n;u++)\n      if(indeg[u]==0&&!V[u]) bfs(u);\n    for(int i=0;i<n;i++)\n      cout<<p[i]<<endl;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  TopologicalSort ts(n);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    ts.add_edge(s,t);\n  }\n  ts.tsort();\n  return 0;\n}\n\n/*\nverified on 2017/10/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e12)\n \ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nstruct edge{\n    int to;\n    bool f;\n};\n\nvector<vector<edge>> G;\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n    G.resize(v);\n    vector<int> iri(v, 0);\n\n    rep(i, e){\n        int from, to; cin >> from >> to;\n        G[from].push_back({to, true});\n        iri[to]++;\n    }\n\n    queue<int> que;\n    rep(i, v) if(iri[i]==0) que.push(i);\n    vector<int> res;\n\n    while(!que.empty()){\n        int a = que.front(); que.pop();\n        res.push_back(a);\n\n        for(auto ed: G[a]){\n            iri[ed.to]--;\n            if(iri[ed.to]==0) que.push(ed.to);\n        }\n    }\n\n    rep(i, v){\n        cout << res[i] << endl;\n    }\n    // prvec(res\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nvector<int> ans;\nint vis[10010] = {0};\nint cc[10010];\nvector<int> r[10010];\n\nclass priority {\n  public:\n    bool operator() (const pair<int,int> &x, const pair<int,int> &y) const {\n      return x.second > y.second;\n    }\n};\n\nvoid topo(int n) {\n  priority_queue<pair<int,int>, vector<pair<int,int> >, priority> pq;\n  for (int i = 0; i < n; i++) { \n    pq.push(make_pair(i, cc[i]));\n  }\n  while (!pq.empty()) {\n    pair<int,int> now = pq.top();\n    pq.pop();\n    int no = now.first;\n    int count = now.second;\n    if (count != 0) break;\n    if (vis[no]) continue;\n    vis[no] = 1;\n    ans.push_back(no);\n    for (int i = 0; i < r[no].size(); i++) {\n      int t = r[no][i];\n      pq.push(make_pair(t, --cc[t]));\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m, x, y;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> x >> y;\n    r[x].push_back(y);\n    cc[y]++;\n  }\n  topo(n);\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INF = (1<<29);\nint N,M;\nvector< int > G[MAX];\nbool V[MAX];\nint indeg[MAX];\nlist< int > out;\n\nvoid bfs(int num){\n  queue<int> que;\n  que.push(num);\n  while(!que.empty()){\n    int now = que.front(); que.pop();\n    out.push_back(now);\n    for(int i=0;i<G[now].size();i++){\n      int v = G[now][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n\tV[v] = true;\n\tque.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(){\n  for(int i=0;i<N;i++){\n    indeg[i] = 0;\n    V[i] = false;\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<G[i].size();j++) indeg[G[i][j]]++;\n  }\n  for(int i=0;i<N;i++){\n    if(indeg[i] == 0 && !V[i]) bfs(i);\n  }\n  for(list<int>::iterator it = out.begin();it != out.end();it++){\n    cout << *it << endl;\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int s,t; cin >> s >> t;\n    G[s].push_back(t);\n  }\n  tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while( !q.empty() ){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }    \n}\n\nvoid tsort(){\n    for(int i=0; i<N; i++){\n        indeg[i] = 0;\n    }\n\n    for(int u=0; u<N; u++){\n        for(int i=0; i<G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for(int u=0; u<N; u++)\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n\n    for(auto x : out){\n        cout << x << endl;\n    }\n}\n\nint main(){\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for(int i=0; i<N; i++) V[i] = false;\n\n    for(int i=0; i<M; i++){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n//グラフDFS\nvoid dfs(ll x, vector<vector<ll>> &g, vector<bool> &see, vector<pair<ll, ll>> &ans, ll &cnt)\n{\n  //点xに対する処理\n  see[x] = 1;\n  for (auto p : g[x])\n  {\n    if (see[p])\n      continue;\n    //進む辺に対する処理（これは木構造でオイラーツアーするために使う）\n    dfs(p, g, see, ans, cnt);\n    //戻る辺に対する処理\n  }\n  ans[x].first = cnt;\n  cnt++;\n}\nint main()\n{\nll n, m;\ncin >> n >> m;\nvector<vector<ll>> g(n);\nrep(i, m)\n{\n  ll a, b;\n  cin >> a >> b;\n  g[a].push_back(b);\n}\nll cnt = 1;\nvector<bool> see(n);\nvector<pair<ll, ll>> ans(n);\nrep(i, n) ans[i].second = i;\nrep(i, n)\n{\n  if (!see[i])\n    dfs(i, g, see, ans, cnt);\n}\nsort(ans.begin(),ans.end());\nreverse(ans.begin(),ans.end());\nrep(i,n)cout << ans[i].second << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <list>\n\nstatic const int MAX = 100000;\n\nstd::vector<int> Graph[MAX];\n//std::list<int> out;\nstd::stack<int> outs;\nbool isVisited[MAX];\nint N;\n\nvoid dfs(int u) {\n    isVisited[u] = true;\n    for (int i = 0; i < Graph[u].size(); i++) {\n        int v = Graph[u][i];\n        //ha az adott vertex meg nem vizsgalt\n        if (!isVisited[v]) {\n            //std::cout << \"run: \" << v << std::endl;\n            dfs(v);\n        }\n    }\n    //out.push_front(u);\n    outs.push(u);\n}\n\nint main()\n{\n    int start, target, M;\n    std::cin >> N >> M;\n    for (int i = 0; i < N; i++) isVisited[i] = false;\n    for (int i = 0; i < M; i++) {\n        std::cin >> start >> target;\n        Graph[start].push_back(target);\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!isVisited[i])\n            dfs(i);\n    }\n\n    /*for (std::list<int>::iterator it = out.begin(); it != out.end(); it++) {\n        std::cout << *it << std::endl;\n    } */\n    while (!outs.empty()) {\n        std::cout << outs.top() << std::endl;\n        outs.pop();\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int INFTY = (1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid dfs(int u) {\n  V[u] = true;\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (!V[v]) dfs(v);\n  }\n  out.push_front(u);\n}\n\nvoid bfs(int u) {\n  queue<int> q;\n  q.push(u);\n  V[u] = true;\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    out.push_back(u);\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]--;\n      if (indeg[v] == 0 && !V[v]) {\n        V[v] = true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort_dfs() {\n  for (int i = 0; i < N; i++) {\n    if (!V[i]) dfs(i);\n  }\n}\n\nvoid tsort() {\n  for (int i = 0; i < N; i++) {\n    indeg[i] = 0;\n  }\n  for (int u = 0; u < N; u++) {\n    for (int i = 0; i < G[u].size(); i++) {\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n\n  for (int u = 0; u < N; u++) {\n    if (indeg[u] == 0 && !V[u]) bfs(u);\n  }\n\n}\n\nvoid print() {\n  for (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n    cout << *it << endl;\n  }\n}\n\nint main() {\n  int s, t, M;\n  cin >> N >> M;\n  for (int i = 0; i < N; i++) {\n    V[i] = false;\n  }\n  for (int i = 0; i < M; i++) {\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  //tsort();\n  tsort_dfs();\n  print();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nトポロジカルソートができる⇔DAG(閉路がない有向グラフ)である\n\nvector<int>を引数にすることを前提にしている\n\nO(V+E)\n\nedgeなどを使う場合には、eの所をe.toにする必要がある\n（逆に言えばそれだけでいい）\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B\n参考:\nhttps://ferin-tech.hatenablog.com/entry/2017/01/24/184750\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long int;\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\nusing Graph=vector<vector<int>>;\n\n//DAGではない場合、空のvectorを返す\ntemplate<typename G>\nvector<int> TopologicalSort(G &v){\n    int sz=(int)v.size();\n    vector<int> cnt(sz,0);\n    vector<int> ret;\n    stack<int> st;\n    for(int i=0;i<sz;i++){\n        for(auto &e:v[i]){\n            cnt[e]++;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        if(cnt[i]==0) st.push(i);\n    }\n    while(!st.empty()){\n        int now=st.top(); st.pop();\n        ret.push_back(now);\n        for(auto &e:v[now]){\n            cnt[e]--;\n            if(cnt[e]==0) st.push(e);\n        }\n    }\n    if(ret.size()!=sz) return vector<int>();\n    return ret; \n}\n\nsigned main(){\n    int v,e;\n    cin>>v>>e;\n    Graph g(v);\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        g[s].push_back(t);\n    }\n    vector<int> ret=TopologicalSort(g);\n    for(auto i:ret){\n        cout<<i<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (dfs) ------ //\nvector<int> tsort(Graph &g) {\n    int n = g.size();\n    enum { YET, VISITED, DONE };\n    vector<int> res, color(n, YET);\n    static const function<bool(int)> dfs = [&](int v) {\n        color[v] = VISITED;\n        for (Edge &e : g[v]) {\n            if (color[e.dst] == DONE) continue;\n            if (color[e.dst] == VISITED) return false;\n            if (!dfs(e.dst)) return false;\n        }\n        color[v] = DONE; res.push_back(v);\n        return true;\n    };\n    for (int i = 0; i < n; ++i) if (color[i] == YET && !dfs(i)) return {};\n    reverse(res.begin(), res.end());\n    return res;\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord = tsort(g);\n    for (int i = 0; i < V; i++) cout << ord[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> topological_sort(int **g, int n)\n{\n\tdeque<int> q;\n\tunordered_map<int, int> m;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint d = 0;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (g[j][i])\n\t\t\t\td++;\n\t\t}\n\n\t\tm[i] = d;\n\n\t\tif (!d)\n\t\t\tq.push_back(i);\n\t}\n\n\tvector<int> vs;\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop_front();\n\n\t\tvs.push_back(v);\n\n\t\tvector<int> adj;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (g[v][i]) {\n\t\t\t\tm[i]--;\n\t\t\t\tif (!m[i])\n\t\t\t\t\tq.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((int)vs.size() != n)\n\t\tthrow \"cycle detected!\";\n\n\treturn vs;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, m, x, y;\n\n\tcin >> n >> m;\n\t\n\tint **g = new int*[n];\n\tfor (int i = 0; i < n; i++)\n\t\tg[i] = new int[n];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tg[i][j] = 0;\n\t}\t\t\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x >> y;\n\t\tg[x][y] = 1;\n\t}\t\t\n\n\tauto vs = topological_sort(g, n);\n\n\tfor (const auto& v : vs)\n\t\tcout << v << \"\\n\";\n\n\tfor (int i = 0; i < n; i++)\n\t\tdelete[] g[i];\n\n\tdelete[] g;\t\t\t\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nconst ll INF = 1e+9+7;\nll n,m,l;\n// string s,t;\nll d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid dfs(int s){\n  queue<int> que;\n  que.push(s);\n  V[s] = true;\n  while(!que.empty()){\n    int u = que.front();que.pop();\n    out.push_back(u);\n    for(int i = 0;i < G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && !V[v]){\n        V[v] = true;\n        que.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(){\n  for(int i = 0;i < N;i++){\n    indeg[i] = 0;\n  }\n  for(int u = 0;u < N;u++){\n    for(int i = 0;i < G[u].size();i++){\n      int v = G[u][i];\n      indeg[v]++;\n    }\n  }\n  for(int u = 0;u < N;u++)\n    if(indeg[u] == 0 && !V[u])dfs(u);\n\n  for(list<int>::iterator it = out.begin(); it != out.end();it++){\n    cout << *it << endl;\n  }\n}\n\nint main(){\n  int p,q,M;\n  cin >> N >> M;\n  for(int i = 0;i < N;i++)V[i] = false;\n  for(int i = 0;i < M;i++){\n    cin >> p >> q;\n    G[p].push_back(q);\n  }\n\n  tsort();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint v,e;\n// hasparent\nset<int> hp;\n// children,parent\nmap<int,set<int>> c;\nmap<int,set<int>> p;\n// topsort seq\nvector<int> t;\n\nint main(){\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    int a,b;cin>>a>>b;\n    c[a].insert(b);\n    p[b].insert(a);\n  }\n  for(int i=0;i<v;i++){\n    if(p[i].empty())hp.insert(i);\n  }\n  while(hp.size()){\n    int o=*hp.begin();\n    t.push_back(o);\n    hp.erase(hp.begin());\n    for(auto h:c[o]){\n      p[h].erase(o);\n      if(p[h].empty())hp.insert(h);\n    }\n  }\n  copy(t.begin(),t.end(),ostream_iterator<int>(cout,\"\\n\"));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std;\n\nvector<int> edge[10010];\nint h[10010];\n\nint V;\nint E;\n\nint main()\n{\n    cin >> V;\n    cin >> E;\n\n    for(int i = 0;i < E;i++)\n    {\n        int s;\n        int t;\n\n        cin >> s >> t;\n\n        edge[s].push_back(t);\n\n\n        h[t]++;\n    }\n\n    stack<int> st;\n\n    for(int i = 0;i < V;i++)\n    {\n        if(h[i] == 0) st.push(i);\n    }\n\n    vector<int> topolo;\n\n    while(!st.empty())\n    {\n        int v = st.top();\n        st.pop();\n\n        topolo.push_back(v);\n\n        for(int to : edge[v])\n        {\n            h[to]--;\n\n            if(h[to] == 0)\n            {\n                st.push(to);\n            }\n        }\n    }\n\n    for(int ans : topolo)\n    {\n        cout << ans << endl;\n    }\n\n    return 0;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nvoid visit(const vector<vector<int>>& g, int u, vector<bool>&used, vector<int>& ans) {\n\n    if( used[u] == false ) {\n\tused[u] = true;\n\tfor(auto& v : g[u]) {\n\t    visit(g, v, used, ans);\n\t}\n\tans.emplace_back(u);\n    }\n}\n\nvector<int> tsort_Tarjan(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<bool> used(V,false);\n    vector<int> ans;\n    for (int u=0; u<V; ++u) {\n\tvisit(g, u, used, ans);\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n\nvector<int> tsort_BFS(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    queue<int>  Q;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    Q.push(i);\n    \n    vector<int> ans;\n    while( Q.size() ) {\n\tint u = Q.front(); Q.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) Q.push(v);\n\t}\n    }\n    return ans;\n}\n\n\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_BFS(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <set>\n#include <stack>\n#include <cctype>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\n/* typedef */\ntypedef long long ll;\n\n/* constant */\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\nconst int WHITE = 0;\nconst int GRAY = 1;\nconst int BLACK = 2;\n\n/* global variables */\nvector<int> out;\nvector< vector<int> > Adj(MAX);\nvector<int> indeg(MAX, 0), color(MAX, WHITE);\n/* function */\nvoid bfs(int u);\n\n/* main */\nint main() {\n\n    int V, E, v, u;\n    cin >> V >> E;\n\n    for (int i = 0; i < E; i++) {\n        cin >> v >> u;\n        Adj[v].push_back(u);\n        indeg[u]++;\n    }\n\n    for (int u = 0; u < V; u++) {\n        if (indeg[u] == 0 && color[u] == WHITE) {\n            bfs(u);\n        }\n    }\n\n    for (auto o : out)\n        cout << o << '\\n';\n\n}\n\nvoid bfs(int u) {\n    queue<int> Q;\n    int s, t;\n    Q.push(u);\n    color[u] = GRAY;\n    while (!Q.empty()) {\n        s = Q.front();\n        Q.pop();\n        out.push_back(s);\n\n        for (int i = 0; i < Adj[s].size(); i++) {\n            t = Adj[s][i];\n            indeg[t]--;\n            if (indeg[t] == 0 && color[t] == WHITE) {\n                color[t] = GRAY;\n                Q.push(t);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cfloat>\n\nusing namespace std;\n\n#define INFD numeric_limits<double>::infinity()\n#define INFL (int)1e8\n#define INFLL (long long)1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <complex>\n#include <cfloat>\n\nusing namespace std;\n\n#define INFD numeric_limits<double>::infinity()\n#define INFL (int)1e8\n#define INFLL (long long)1e15\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\n\n/*******************************************************/\n\nstruct graph_t {\n  int n;           // |V|, index begins with 0\n  int m;           // |E|\n  vector<P> edges; // E\n  vector<ll> cost; // cost or distance\n  vector<ll> cap;  // capacity\n};\n\nclass Topological_Sort {\nprivate:\n  struct node {\n    int id; bool done; vi to; int from_cnt;\n  };\n  vector<node> nodes;\n  int n;\n  vi result;\n  bool cycle_existing_flag;\npublic:\n  Topological_Sort(graph_t G) {\n    n = G.n;\n    nodes.resize(n);\n    Loop(i, n) nodes[i] = { i, false, {}, 0 };\n    Loop(i, G.edges.size()) {\n      nodes[G.edges[i].first].to.push_back(G.edges[i].second);\n      nodes[G.edges[i].second].from_cnt++;\n    }\n    result = {};\n    stack<int> stk;\n    vector<bool> evalid(G.edges.size(), true);\n    Loop(i, n) {\n      if (nodes[i].from_cnt == 0) stk.push(i);\n    }\n    while (stk.size()) {\n      int a = stk.top(); stk.pop();\n      result.push_back(a);\n      Loop(i, nodes[a].to.size()) {\n        int b = nodes[a].to[i];\n        nodes[b].from_cnt--;\n        if (nodes[b].from_cnt == 0) stk.push(b);\n      }\n    }\n    if (result.size() != n) cycle_existing_flag = true;\n    else cycle_existing_flag = false;\n    return;\n  }\n  vi get_result() {\n    return result;\n  }\n  bool is_cycle_existing() {\n    return cycle_existing_flag;\n  }\n};\n\nint main() {\n  graph_t G;\n  cin >> G.n >> G.m;\n  Loop(i, G.m) {\n    int s, t; cin >> s >> t;\n    G.edges.push_back({ s, t });\n  }\n  Topological_Sort ts(G);\n  vi result = ts.get_result();\n  Loop(i, result.size()) {\n    cout << result[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//------------------------------- Libraries --------------------------------//\n\n//------------------------------- Type Names -------------------------------//\n\nusing i64 = int_fast64_t;\n\nusing seika = string;\n//akari : 1D, yukari : 2D, maki : 3D vector\ntemplate <class kizuna>\nusing akari = vector<kizuna>;\ntemplate <class yuzuki>\nusing yukari = akari<akari<yuzuki>>;\ntemplate <class tsurumaki>\nusing maki = akari<yukari<tsurumaki>>;\n//akane : ascending order, aoi : decending order\ntemplate <class kotonoha>\nusing akane = priority_queue<kotonoha, akari<kotonoha>, greater<kotonoha>>;\ntemplate <class kotonoha>\nusing aoi = priority_queue<kotonoha>;\n\n//------------------------------- Dubug Functions ---------------------------//\ninline void print()\n{\n    cout << endl;\n}\ntemplate <typename First, typename... Rest>\nvoid print(const First &first, const Rest &... rest)\n{\n    cout << first << ' ';\n    print(rest...);\n}\n//------------------------------- Solver ------------------------------------//\n\nvoid solve()\n{\n    int n, m;\n    cin >> n >> m;\n    yukari<int> g(n);\n    akari<int> e(n);\n    while (m--)\n    {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        e[v]++;\n    }\n    queue<int> q;\n    for (int s = 0; s < n; s++)\n    {\n        if (!e[s])\n        {\n            q.push(s);\n        }\n    }\n\n    while (!q.empty())\n    {\n        int v = q.front();\n        q.pop();\n        for (int nv : g[v])\n        {\n            e[nv]--;\n            if (!e[nv])\n            {\n                q.push(nv);\n            }\n        }\n        cout << v << '\\n';\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass ConnectNodeInfo{\n\tvector<vector<pair<ll,ll>>> graph;\npublic:\n\tConnectNodeInfo(int node_num){\n\t\tgraph.resize(node_num);\n\t}\n\tvoid AddNonDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t\tgraph[v].emplace_back(u,w);\n\t}\n\tvoid AddDirectionalConnection(ll u,ll v,ll w){\n\t\tgraph[u].emplace_back(v,w);\n\t}\n\tvector<pair<ll,ll>>& operator[](ll index){\n\t\treturn graph[index];\n\t}\n\tsize_t size(){return graph.size();}\n};\n\nvector<ll> TopologicalSort(ConnectNodeInfo& connect){\n\tint N=connect.size();\n\tstack<ll> vertex;\n\tvector<ll> input(N),sorted;\n\tREP(i,N){\n\t\tfor(auto& x:connect[i]) input[x.first]++;\n\t}\n\tREP(i,N){\n\t\tif(input[i]==0) vertex.push(i);\n\t}\n\twhile(!vertex.empty()){\n\t\tauto v=vertex.top();vertex.pop();\n\t\tsorted.push_back(v);\n\t\tfor(auto& x:connect[v]){\n\t\t\tinput[x.first]--;\n\t\t\tif(!input[x.first]) vertex.push(x.first);\n\t\t}\n\t}\n\treturn sorted;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint V=in(),E=in();\n\tConnectNodeInfo connect(V);\n\tREP(i,E){\n\t\tint u=in(),v=in();\n\t\tconnect.AddDirectionalConnection(u,v,1);\n\t}\n\t\n\tauto P=TopologicalSort(connect);\n\n\tfor(auto& x:P){\n\t\tout(x);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<list>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\nvoid bfs(int s)\n{\n    queue<int> q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++)\n        {\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v])\n                {\n                    V[v]=true;\n                    q.push(v);\n                }\n        }\n    }\n}\nvoid tsort()\n{\n    int v;\n    for(int i=0;i<N;i++)\n        indeg[i]=0;\n    for(int u=0;u<N;u++)\n    {\n        for(int i=0;i<G[u].size();i++)\n        {\n            v=G[u][i];\n            indeg[v]++;\n        }\n    }\n    for(int u=0;u<N;u++)\n    if(indeg[u]==0&&!V[v]) bfs(u);\n    for(list<int>::iterator it =out.begin();it!=out.end();it++)\n    {\n        cout<< *it<<endl; }\n}\nint main()\n{\n    int s,t,M;\n    scanf(\"%d %d\",&N,&M);\n    for(int i=0;i<N;i++)\n        V[i]=false;\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%d %d\",&s,&t);\n        G[s].push_back(t);\n\n    }\n    tsort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <stack>\nusing namespace std;\nint V,E;\nvector< vector<int> > A;\nvector<int> c;\nstack<int> F;\n\nvoid dfsVisit(int u) {\n    c[u] = 1;\n    for(int i=0; i<A[u].size(); i++) {\n        int v = A[u][i];\n        if(c[v] == 0) dfsVisit(v);\n    }\n    F.push(u);\n}\n\nint main() {\n    cin >> V >> E;\n    A.resize(V);\n    c.resize(V);\n\n    for(int i=0; i<V; i++) A[i].clear();\n    \n    for(int i=0; i<E; i++) {\n        int s,t;\n        cin >> s >> t;\n        A[s].push_back(t);\n    }\n\n    for(int i=0; i<V; i++) c[i] = 0;\n    for(int i=0; i<V; i++) {\n        if(c[i] == 0) dfsVisit(i);\n    }\n\n    while(!(F.empty())) {\n        cout << F.top() << endl;\n        F.pop();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) ((a)>(b)?(b):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nvector<int> G[10000];\nvector<int> L;\nbool checked[10000];\n\nvoid visit(int n)\n{\n\tif (!checked[n])\n\t{\n\t\tchecked[n] = true;\n\t\tfor (auto& m : G[n])\n\t\t{\n\t\t\tvisit(m);\n\t\t}\n\t\tL.push_back(n);\n\t}\n}\n\nint main() \n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint V, E;\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tG[u].push_back(v);\n\t}\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tvisit(i);\n\t}\n\n\treverse(L.begin(), L.begin() + V);\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tprintf(\"%d\\n\", L[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 1);\n//0: edge[i].secondに載っているため設定できない\n//1: 設定できる状態\n//2: すでに設定済みなので除外\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] != 2) state[i] = 1;\n        }\n        for (int i = 0; i < edge.size(); i++) {\n            state[edge[i].second] = 0;\n        }\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 1) {\n                ans.push_back(i);\n                state[i] = 2;\n                for (int j = 0; j < edge.size(); j++) {\n                    if (edge[j].first == i) {\n                        edge.erase(edge.begin() + j);\n                        j--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    unordered_set<int> g[n];\n    int f, t;\n\n    for (int i = 0; i < m; i++) {\n        cin >> f >> t;\n        g[f].insert(t);\n    }\n\n    queue<int> q;\n    unordered_map<int, int> mm;\n\n    for (int i = 0; i < n; i++) {\n        int d = 0;\n        for (int j = 0; j < n; j++) {\n            if (g[j].find(i) != g[j].end())\n                d++;\n        }\n\n        if (!d)\n            q.push(i);\n\n        mm[i] = d;\n    }\n\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n\n        cout << v << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            if (g[v].find(i) != g[v].end()) {\n                int e = mm[i]-1;\n                if (!e)\n                    q.push(i);\n\n                mm[i] = e;\n            }\n        }\n    }\n\n    cout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nint main()\n{\n    ll i,j;\n    ll v,e;\n    cin >> v >> e;\n    vector<ll> invec(v, 0);\n    vector<vector<ll>> graph(v);\n    for(i = 0;i < e;++i){\n        ll s,t;\n        cin >> s >> t;\n        graph.at(s).push_back(t);\n        ++invec.at(t);\n    }\n    queue<ll> que;\n    for(i = 0;i < v;++i){\n        if(invec.at(i) == 0){\n            que.push(i);\n            --invec.at(i);\n        }\n    }\n    vector<ll> ans;\n    while(!que.empty()){\n        ll top = que.front();\n        que.pop();\n        ans.push_back(top);\n        for(auto next: graph.at(top)){\n            if(--invec.at(next) == 0) que.push(next);\n        }\n    }\n    for(i = 0;i < v;++i){\n        cout << ans.at(i) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 隣接リストで表現された有向グラフ\n\n// Weightをdoubleにすると、桁数が多いとき1e9のように表示されることに注意\n\n#include<algorithm>\n#include<functional>\n#include<memory>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<vector>\n\nusing Weight = long long;\nusing Vertex = int;\nstruct Edge {Vertex from, to; Weight weight;};\nusing Graph = std::vector<std::vector<Edge>>;\n\n// 比較演算子\n// bool operator==(const Edge& lhs, const Edge& rhs) {return lhs.from==rhs.from && lhs.to==rhs.to && lhs.weight==rhs.weight;}\n\n// 隣接行列 O(|V|^2 + |E|)\nstd::vector<std::vector<Vertex>> adjacent_matrix(const Graph& G) {\n  std::vector<std::vector<Vertex>> A(G.size(), std::vector<Vertex>(G.size(), 0));\n  for(const auto& list: G) for(const auto& e: list) ++A[e.from][e.to];\n  return A;\n}\n\n// 逆辺 O(1)\nEdge reverse(const Edge& e) {\n  return {e.to, e.from, e.weight};\n}\n\n// 逆辺からなるグラフ O(|V| + |E|)\nGraph reverse(const Graph& G) {\n  Graph H(G.size());\n  for(auto& list: G) for(auto& e: list) H[e.to].push_back({e.to, e.from, e.weight});\n  return H;\n}\n\n// 帰りがけ順 O(|V| + |E|)\nstd::vector<Vertex> postorder(const Graph& G) {\n  std::vector<bool> used(G.size());\n  std::vector<Vertex> order;\n  std::function<void(Vertex)> dfs = [&](Vertex v) {\n    used[v] = true;\n    for(const auto& e: G[v]) if(!used[e.to]) dfs(e.to);\n    order.emplace_back(v);\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!used[v]) dfs(v);\n  return order;\n}\n\n// トポロジカルソート O(|V| + |E|)\n//   逆辺にしてから帰りがけ順を求める\n//   ※逆辺にせずに帰りがけ順を求めて, その結果を reverse しても良い O(|V| log |V| + |E|)\nstd::vector<Vertex> topological_order(const Graph& G) {\n  return postorder(reverse(G));\n}\n// トポロジカルソート O(|V| + |E|)\n//   サイクルが存在する場合は空 vector を返す\nstd::vector<Vertex> Kahn(const Graph& G) {\n  std::vector<Vertex> order;\n  std::vector<int> indeg(G.size());\n  for(const auto& E: G) for(const auto& e: E) ++indeg[e.to];\n  std::queue<Vertex> q;\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] == 0) q.emplace(v);\n  while(!q.empty()) {\n    for(const auto& e: G[q.front()]) if(--indeg[e.to] == 0) q.emplace(e.to);\n    order.emplace_back(q.front());\n    q.pop();\n  }\n  for(Vertex v = 0; v < G.size(); ++v) if(indeg[v] != 0) return {};\n  return order;\n}\n\n// 連結成分ごとに分解 O(|V|)\n// ※無向グラフのみ\nstd::vector<std::vector<Vertex>> connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> cc;\n  std::vector<bool> used(G.size());\n  std::function<void(int)> dfs = [&](int v) {\n    cc.back().push_back(v);\n    used[v] = true;\n    for(const auto& e: G[v]) if(!used[e.to]) dfs(e.to);\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!used[v]) {\n    cc.push_back(std::vector<Vertex>());\n    dfs(v);\n  }\n  return cc;\n}\n\n// すべての連結成分に対して関節点と橋を列挙 O(|V| + |E|)\n// ※無向グラフのみ\n// ※articulationには同じ頂点が複数個入る可能性があり、その個数は「分割後の成分数 - 1」個\nvoid Tarjan(const Graph& G, std::vector<Vertex>& articulation, std::vector<Edge>& bridge) {\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  std::function<void(Vertex,Vertex)> dfs = [&](Vertex cur, Vertex pre) {\n    num[cur] = low[cur] = ++timer;\n    for(const auto& e: G[cur]) if(e.to != pre) {\n      if(num[e.to]) {\n        low[cur] = std::min(low[cur], num[e.to]);\n      } else {\n        dfs(e.to, cur);\n        low[cur] = std::min(low[cur], low[e.to]);\n        if(cur == pre) if(num[cur]+1 < num[e.to]) articulation.push_back(cur);\n        if(cur != pre) if(num[cur] <= low[e.to])  articulation.push_back(cur);\n        if(num[cur] < low[e.to])                  bridge.push_back(e);\n      }\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v, v);\n}\n\n// 二重辺連結成分分解 O(|V| + |E|)\n// ※無向グラフのみ\n// ※戻り値は選択\nauto bridge(const Graph& G) {\n  std::stack<Vertex> roots, S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size());\n  std::vector<Edge> bridge;\n  std::vector<std::vector<Vertex>> bcc;\n  int timer = 0;\n  // Tarjan\n  std::function<void(const Edge&)> dfs = [&](const Edge& cur) {\n    num[cur.to] = ++timer;\n    S.push(cur.to); inS[cur.to] = true;\n    roots.push(cur.to);\n    for(const auto& nex: G[cur.to]) {\n      if(!num[nex.to]) dfs(nex);\n      else if(nex.to != cur.from && inS[nex.to]) while(num[roots.top()] > num[nex.to]) roots.pop();\n    }\n    if(roots.top() == cur.to) {\n      bridge.push_back(cur);\n      bcc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto v = S.top(); S.pop(); inS[v] = false;\n        bcc.back().push_back(v);\n        if(v == cur.to) break;\n      }\n      roots.pop();\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) {\n    dfs({v, v});\n    bridge.pop_back();\n  }\n//   return bridge;\n  return bcc;\n}\n\n// 強連結成分分解 O(|V| + |E|)\nstd::vector<std::vector<Vertex>> strongly_connected_component(const Graph& G) {\n  std::vector<std::vector<Vertex>> scc;\n  std::stack<Vertex> S;\n  std::vector<bool> inS(G.size());\n  std::vector<int> num(G.size()), low(G.size());\n  int timer = 0;\n  // Tarjan\n  std::function<int(Vertex v)> dfs = [&](Vertex v) {\n    num[v] = low[v] = ++timer;\n    S.push(v); inS[v] = true;\n    for(const auto& e: G[v]) {\n      if(!num[e.to])     low[v] = std::min(low[v], dfs(e.to));\n      else if(inS[e.to]) low[v] = std::min(low[v], num[e.to]);\n    }\n    if(num[v] == low[v]) {\n      scc.push_back(std::vector<Vertex>());\n      while(true) {\n        auto w = S.top(); S.pop(); inS[w] = false;\n        scc.back().push_back(w);\n        if(v == w) break;\n      }\n    }\n    return low[v];\n  };\n  for(Vertex v = 0; v < G.size(); ++v) if(!num[v]) dfs(v);\n  return scc;\n}\n\n// 単一始点最短経路 O(|V| |E|)\n// ※重みを-1倍したグラフに適用すると元のグラフの最長経路を得られる\nstd::vector<Weight> BellmanFord(const Graph& G, Vertex s, Weight INF = 1e18) {\n  std::vector<Weight> d(G.size(), INF);\n  d[s] = 0;\n  for(auto k = 0; k < G.size(); ++k) for(Vertex v = 0; v < G.size(); ++v) for(const auto& e: G[v]) {\n    if(d[e.to] > d[e.from] + e.weight) {\n      d[e.to] = d[e.from] + e.weight;\n      if(k == G.size()-1) d[e.to] = -INF;\n    }\n  }\n  return d;\n}\n\n// 単一始点最短経路 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nstd::vector<Weight> Dijkstra(const Graph& G, Vertex s) {\n  std::vector<Weight> d(G.size(), -1);\n  std::priority_queue<Edge, std::vector<Edge>, std::function<bool(Edge,Edge)>> q([](Edge lhs, Edge rhs){return lhs.weight > rhs.weight;});\n  q.push({s, s, 0});\n  while(!q.empty()) {\n    auto cur = q.top();\n    q.pop();\n    if(d[cur.to] != -1) continue;\n    d[cur.to] = cur.weight;\n    for(const auto& nex: G[cur.to]) if(d[nex.to] == -1) q.push({cur.to, nex.to, cur.weight + nex.weight});\n  }\n  return d;\n}\n\n// 単一始点最短経路に含まれ得る辺の列挙 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nGraph shortest_DAG(const Graph& G, Vertex s) {\n  Graph H(G.size());\n  auto d = Dijkstra(G, s);\n  for(const auto& E: G) for(const auto& e: E) if(d[e.from] + e.weight == d[e.to]) H[e.from].emplace_back(e);\n  return H;\n}\n\n// 単一始点最短経路の個数 O(|E| + |V| log |V|)\n// ※負辺を含むグラフには使えない\nstd::vector<int> shortest_path_number(const Graph& G, Vertex s) {\n  std::vector<int> dp(G.size());\n  dp[s] = 1;\n  auto d = Dijkstra(G, s);\n  for(const auto& E: G) for(const auto& e: E) if(d[e.from] + e.weight == d[e.to]) dp[e.to] += dp[e.from];\n  return dp;\n}\n\n// 2頂点間最短経路 O(|E| + |V|^3)\n// ※INF+INFがオバーフローを起こさないよう注意\nstd::vector<std::vector<Weight>> WarshallFloyd(const Graph& G, Weight INF = 1e9) {\n  std::vector<std::vector<Weight>> d(G.size(), std::vector<Weight>(G.size(), INF));\n  for(Vertex i = 0; i < G.size(); ++i) d[i][i] = 0;\n  for(const auto& list: G) for(const auto& e: list) d[e.from][e.to] = std::min(d[e.from][e.to], e.weight);\n  for(Vertex i = 0; i < G.size(); ++i) for(Vertex j = 0; j < G.size(); ++j) for(Vertex k = 0; k < G.size(); ++k) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n  return d;\n}\n\n// すべての u-v パスに対して u の直後に訪れる頂点の最小値/最大値 O(|V| log |V| + |V| |E|)\n// ※有向グラフの迂回路判定に利用(ARC092F)\nstd::vector<std::vector<std::vector<Vertex>>> follower(Graph G) {\n  for(auto& E: G) sort(begin(E), end(E), [](const auto& l, const auto& r) {return l.to < r.to;});\n  std::vector<std::vector<std::vector<Vertex>>> ok(2, std::vector<std::vector<Vertex>>(G.size(), std::vector<Vertex>(G.size(), -1)));\n  std::function<void(int, Vertex, Vertex)> dfs = [&](auto b, auto r, auto v) {\n    for(const auto& e: G[v]) if(ok[b][r][e.to] == -1) {\n      ok[b][r][e.to] = ok[b][r][e.from];\n      dfs(b, r, e.to);\n    }\n  };\n  for(Vertex v = 0; v < G.size(); ++v) for(auto b: {0, 1}) ok[b][v][v] = v;\n  for(Vertex r = 0; r < G.size(); ++r) for(auto i = 0; i < G[r].size(); ++i) for(auto b: {0, 1}) {\n    auto x = (b==0) ? i : G[r].size()-1-i;\n    auto v = G[r][x].to;\n    if(ok[b][r][v] == -1) {\n      ok[b][r][v] = x;\n      dfs(b, r, v);\n    }\n  }\n  return ok;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n//   int V, E;\n//   cin >> V >> E;\n//   Graph G(V);\n//   for(int i = 0; i < E; ++i) {\n//     int s, t;\n//     cin >> s >> t;\n//     G[s].push_back({s, t, 0});\n//     G[t].push_back({t, s, 0});\n//   }\n  // GRL_3_A\n  // GRL_3_B\n//   vector<int> cut_vertex;\n//   vector<Edge> bridge;\n//   for(auto S: connected_component(G)) lowlink(G, S.front(), S.front(), cut_vertex, bridge);\n//   // Articulation vertex\n//   set<int> S(begin(cut_vertex), end(cut_vertex));\n//   for(auto v: S) cout << v << endl;\n//   // Bridge\n//   for(auto& e: bridge) if(e.from > e.to) swap(e.from, e.to);\n//   set<Edge, function<bool(Edge,Edge)>> S(begin(bridge), end(bridge), [](Edge lhs, Edge rhs){\n//     if(lhs.from != rhs.from) return lhs.from < rhs.from;\n//     if(lhs.to != rhs.to) return lhs.to < rhs.to;\n//     return lhs.weight < rhs.weight;\n//   });\n//   for(auto e: S) cout << e.from << \" \" << e.to << endl;\n  // GRL_3_C\n//   auto scc = strongly_connected_component(G);\n//   vector<int> group(G.size());\n//   for(int i = 0; i < scc.size(); ++i) for(auto v: scc[i]) group[v] = i;\n//   int Q;\n//   cin >> Q;\n//   for(int i = 0; i < Q; ++i) {\n//     int u, v;\n//     cin >> u >> v;\n//     cout << (group[u] == group[v] ? 1 : 0) << endl;\n//   }\n\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  for(int i = 0; i < E; ++i) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back({s, t, 0});\n  }\n//   GRL_4_B\n  for(auto v: Kahn(G)) cout << v << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\nconst int V = 10001;\nvector<int> adj[V];\nbool marked[V];\nint degree[V];\nvector<int> ans;\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = 0; i < adj[u].size(); ++i) {\n            degree[adj[u][i]]--;\n            if (degree[adj[u][i]] == 0) {\n                q.push(adj[u][i]);\n            }\n        }\n\n        marked[u] = true;\n        ans.push_back(u);\n    }\n}\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    for (int i = 0; i < e; ++i) {\n        int s, t;\n        cin >> s >> t;\n        adj[s].push_back(t);\n        degree[t]++;\n    }\n\n    for (int i = 0; i < v; ++i) {\n        if (!marked[i] && degree[i] == 0) {\n            bfs(i);\n        }\n    }\n\n    for (int i = 0; i < ans.size(); ++i) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nint v,e,in[10005];\nstd::queue<int> q;\nstd::vector<int> g[10005];\n\nint main()\n{\n    scanf(\"%d%d\",&v,&e);\n    while(e--)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);\n        in[y]++;\n    }\n    for(int i=0;i<v;i++)\n        if(!in[i])\n            q.push(i);\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        printf(\"%d\\n\",now);\n        for(std::vector<int>::iterator it=g[now].begin();it!=g[now].end();it++)\n            if(!--in[*it])\n                q.push(*it);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Topological Sort\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing namespace std;\n\nvector<int> topologicalSort(int n, vector<vector<int>> &G) {\n    vector<int> indeg(n, 0);\n    for(int s=0; s<n; s++)\n        for(int t: G[s])\n            indeg[t]++;\n\n    queue<int> q;\n    for(int i=0; i<n; i++)\n        if(indeg[i] == 0) q.push(i);\n\n    vector<int> ans;\n    while(!q.empty()) {\n        int s = q.front(); q.pop();\n        ans.push_back(s);\n        for(int t: G[s]) {\n            if(--indeg[t] == 0) q.push(t);\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    int n, m, s, t;\n    cin >> n >> m;\n\n    vector<vector<int>> G(n);\n    for(int i = 0; i < m; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    vector<int> ans = topologicalSort(n, G);\n\n    for(auto a : ans) cout << a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n\ntypedef long long ll;\nstruct P{\n\tint pos,time;\n};\nbool operator<(P a,P b){return a.time<b.time;}\nint a[100000],n,m,u1,u2;\nP b[100000];\nvector<int>e[100000];\nint main() {\n\tcin>>m>>n;\n\tfor(int i=0;i<m;i++){\n\t\tb[i]=P{i,-1};\n\t\ta[i]=0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>u1>>u2;\n\t\te[u1].push_back(u2);\n\t\ta[u2]++;\n\t}\n\tqueue<int>p;\n\tfor(int i=0;i<m;i++){\n\t\tif(a[i]==0){\n\t\t\tp.push(i);\n\t\t\tb[i].time=0;\n\t\t}\n\t}\n\twhile(!p.empty()){\n\t\tint t=p.front();p.pop();\n\t\tfor(int i=0;i<e[t].size();i++){\n\t\t\tif(b[e[t][i]].time<b[t].time+1){\n\t\t\t\tb[e[t][i]].time=b[t].time+1;\n\t\t\t\tp.push(e[t][i]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(b,b+m);\n\tfor(int i=0;i<m;i++){\n\t\tcout<<b[i].pos<<endl;\n\t}\n\t//cout<<2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int WHITE = 0;\nstatic const int BLACK = 1;\n\nint n, e;\nint indeg[MAX], color[MAX];\nvector<int> L[MAX];\nvector<int> vec;\n\nvoid bfs(int u) {\n\tqueue<int> Q;\n\tQ.push(u);\n\tcolor[u] = BLACK;\n\twhile (!Q.empty()) {\n\t\tint uu = Q.front();\n\t\tQ.pop();\n\t\tvec.push_back(uu);\n\t\tfor (int i = 0; i < L[u].size(); i++) {\n\t\t\tint v = L[uu][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0) {\n\t\t\t\tcolor[v] = BLACK;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid TopoligicalSort() {\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (color[i] == WHITE && indeg[i] == 0) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> e;\n\tint s, t;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcolor[i] = WHITE;\n\t}\n\n\tfor (int i = 0; i < e; i++)\t{\n\t\tcin >> s >> t;\n\t\tindeg[t]++;\n\t\tL[s].push_back(t);\n\t}\n\n\tTopoligicalSort();\n\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (i) cout << ' ';\n\t\tcout << vec[i];\n\t}\n\tcout << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint V, E;\nvector<int> G[10010];\nvector<int> ans;\nint indeg[10010];\nbool used[10010];\n\nvoid bfs(int s) {\n    queue<int> que;\n    que.push(s);\n    used[s] = true;\n    while (!que.empty()) {\n        int u = que.front(); que.pop();\n        ans.push_back(u);\n        for (auto v: G[u]) {\n            indeg[v]--;\n            if (indeg[v] == 0 && !used[v]) {\n                used[v] = true;\n                que.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort() {\n    for (int u = 0; u < V; u++) {\n        used[u] = false;\n        indeg[u] = 0;\n    }\n\n    for (int u = 0; u < V; u++)\n        for (auto v: G[u]) indeg[v]++;\n\n    for (int u = 0; u < V; u++)\n        if (indeg[u] == 0 && !used[u]) bfs(u);\n}\n\n\nint main(void) {\n    cin >> V >> E;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n    for (auto i: ans) cout << i << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;(cnt)<(l);++(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-12\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) { return distance(begin, min_element(begin, end)); }\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) { return distance(begin, max_element(begin, end)); }\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(0); }\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif __GNUC__\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\nclass DGraph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n\n    DGraph(size_t n = 1) :n(n), vertex_to(n), vertex_from(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[(size_t)from].emplace_back(to);\n        vertex_from[(size_t)to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n        vertex_from.resize(_n);\n    }\n};\n\nvector<int> topological_sort(const DGraph& graph) {\n    const int n = graph.n;\n    vector<int> result; result.reserve(n);\n    vector<int> start; start.reserve(n);\n    vector<int> sync(n);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = graph.vertex_from[i].size();\n        if (x == 0)\n            start.push_back(i);\n        else\n            sync[i] = x;\n    }\n\n    function<void(int)> dfs = [&](int idx) {\n        result.push_back(idx);\n        for (int to : graph.vertex_to[idx]) {\n            if (--sync[to] <= 0)\n                dfs(to);\n        }\n    };\n    for (int s : start) dfs(s);\n    return result;\n}\n\n\n\nint main() {\n    ll m, n, kei;\n\n    scanner >> n >> m;\n\n    DGraph graph(n);\n    repeat(i, m) {\n        int a, b;\n        scanner >> a >> b;\n        graph.connect(a, b);\n    }\n\n    auto ans = topological_sort(graph);\n\n    printer.join(ALL(ans));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<list>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    list<pair<int, int> > edge;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        edge.push_back(make_pair(s, t));\n    }\n    vector<int> ans;\n    vector<int> state(V, 1);\n//0: edge[i].secondに載っているため設定できない\n//1: 設定できる状態\n//2: すでに設定済みなので除外\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] != 2) state[i] = 1;\n        }\n        for (auto it = edge.begin(); it != edge.end(); it++) {\n            state[it->second] = 0;\n        }\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 1) {\n                ans.push_back(i);\n                state[i] = 2;\n                for (auto it = edge.begin(); it != edge.end();) {\n                    if (it->first == i) {\n                        it = edge.erase(it);\n                        continue;\n                    }\n                    it++;\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define SORT(a) sort((a).begin(),(a).end())\n#define oorret 0\n#define oor(x) [&](){try{x;} catch(const out_of_range& oor){return oorret;} return x;}()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class Type>struct is_vector : std::false_type {};\ntemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\ntemplate <typename T> inline ostream& operator << (ostream& out, const vector<T>& v) {\n    if (v.empty())return out;\n    constexpr bool is_vector_v = is_vector<T>::value;\n    if (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr),out << ((++itr != v.end()) ? \"\\n\" : \"\");\n    else for (auto itr = v.begin(); itr != v.end();)out << (*itr),out << ((++itr != v.end()) ? \" \" : \"\");\n    return out;\n}\ninline void put() {}\ntemplate<class T> inline void put(const T& first) { std::cout << first; printf(\"\\n\"); }\ntemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first; printf(\" \"); put(rest...); }\ninline void putn() {}\ntemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first; printf(\"\\n\"); putn(rest...); }\n\nvector<int> topologicalSort(vector<vector<int>>& path){//pathが二重辺・自己ループなしのDAGであることが前提\n    int n = (int)path.size();\n    vector<int> res;\n    vector<int> entry(n,0);\n    queue<int> q;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<path[i].size();++j){\n            entry[path[i][j]]++;\n        }\n    }\n    for(int i=0;i<n;++i){\n        if(!entry[i]){\n            q.push(i);\n        }\n    }\n    while(!q.empty()){\n        int p = q.front();\n        q.pop();\n        res.push_back(p);\n        for(int i=0;i<path[p].size();++i){\n            if(entry[path[p][i]]!=0){\n                if(--entry[path[p][i]]==0){\n                    q.push(path[p][i]);\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> x(m),y(m);\n    vector<vector<int>> path(n);\n    REP(i,m){\n        cin >> x[i] >> y[i];\n        //x[i]--;\n        //y[i]--;\n        path[x[i]].push_back(y[i]);\n    }\n    vector<int> res = topologicalSort(path);\n    REP(i,res.size()){\n        put(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 10000\n\nclass Node;\nvoid dfs(int N);\n\nclass Node\n{\npublic:\n\tbool IsDone = false;\n\tvector<int> E;\n};\n\nlist<int> ans;\nNode nodes[MAX];\n\nvoid dfs(int N)\n{\n\tnodes[N].IsDone = true;\n\tfor (int i = 0; i<nodes[N].E.size(); i++)\n\t{\n\t\tif (nodes[nodes[N].E[i]].IsDone == false)\n\t\t{\n\t\t\tdfs(nodes[N].E[i]);\n\t\t}\n\t}\n\tans.push_front(N);\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tREP(i, E)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].E.push_back(t);\n\t}\n\tREP(i, V)if (nodes[i].IsDone == false)dfs(i);\n\tfor (auto var : ans)cout << var << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<functional>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\nvector<int>c[10000];\nbool used[10000];\nvector<int>V;\nvoid DFS(int a) {\n\tused[a] = true;\n\tfor (int i : c[a]) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tV.push_back(a);\n}\nint ans[10000];\nsigned main() {\n\tint a, b; scanf(\"%d%d\", &a, &b);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f; scanf(\"%d%d\", &e, &f);\n\t\tc[f].push_back(e);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tans[V[i]] = i;\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tcout<<ans[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  grl_4_b.cpp\n// Author: ymiyamoto\n//\n// Created on Fri Oct 20 01:00:42 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n#define SIZE 10000\n\nstatic vector<uint32_t> graph[SIZE];\nstatic vector<uint32_t> connected_num(SIZE, 0);\nstatic queue<uint32_t> q;\nstatic vector<uint32_t> sorted;\n\nint32_t main()\n{\n  uint32_t V, E;\n  cin >> V >> E;\n\n  for (uint32_t i = 0; i < E; i++) {\n    uint32_t s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n    connected_num[t]++;\n  }\n\n  for (uint32_t i = 0; i < V; i++) {\n    if (connected_num[i] == 0) {\n      q.push(i);\n    }\n  }\n\n  while (!q.empty()) {\n    uint32_t index = q.front();\n    q.pop();\n\n    sorted.push_back(index);\n    for (uint32_t i = 0; i < graph[index].size(); i++) {\n      connected_num[graph[index][i]]--;\n      if (connected_num[graph[index][i]] == 0) {\n        q.push(graph[index][i]);\n      }\n    }\n  }\n\n  for (uint32_t i = 0; i < sorted.size(); i++) {\n    if (i != 0) cout << \" \";\n    cout << sorted[i];\n  }\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#define MAX 10000\nusing namespace std;\nconst int WHITE = 0,GRAY =1,BLACK = 2;\n\nvector<int> G[MAX];\nint color[MAX] = {WHITE};\nvector<int> L;\n\nvoid visit(int n){\n    if(color[n] != BLACK){\n        color[n] = BLACK;\n        for(auto itr = G[n].begin();itr != G[n].end();++itr){\n            visit(*itr);\n        }\n        \n        L.insert(L.begin(),n);\n    }\n}\nvoid topological(int v){\n    while(1){\n        for(int i = 0;i < v;++i){\n            if(color[i] != BLACK){\n                visit(i);\n                break;\n            }\n            if(i == v-1) return;\n        }\n    }\n}\n\nint main(){\n    int v,e,s,t;\n    scanf(\"%d %d\\n\",&v,&e);\n    for(int i = 0;i < e;++i){\n        scanf(\"%d %d\\n\",&s,&t);\n        G[s].push_back(t);\n    }\n    topological(v);\n\n    for(int i = 0;i < v;++i){\n        printf(\"%d\\n\",L[i]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\nint n, e; vector<int> G[10005];\nint visited[10005], indeg[10005];\n\nvoid bfs(int i)\n{\n  queue<int> Q;\n  Q.push(i);\n  visited[i] = 0;\n  while(!Q.empty())\n  {\n    int u = Q.front(); Q.pop();\n    printf(\"%d\\n\", u);\n    for(int i=0; i<G[u].size(); i++)\n    {\n      int v = G[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && visited[v] == 0)\n      {\n        Q.push(v); visited[v] = 1;\n      }\n    }\n  }\n}\nvoid TopoSort()\n{\n  for(int i=0; i<n; i++)\n  {\n    if(visited[i] == 0 && indeg[i] == 0)\n      bfs(i);\n  }\n}\nint main()\n{\n  scanf(\"%d%d\", &n, &e);\n  for(int i=0; i<n; i++)\n  {\n    visited[i] = indeg[i] = 0;\n  }\n  int s, t;\n  for(int i=0; i<e; i++)\n  {\n    scanf(\"%d%d\", &s, &t);\n    G[s].push_back(t);\n    indeg[t]++;\n  }\n  TopoSort();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<functional>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\nvector<int>c[10000];\nbool used[10000];\nvector<int>V;\nvoid DFS(int a) {\n\tused[a] = true;\n\tfor (int i : c[a]) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tV.push_back(a);\n}\nint ans[10000];\nsigned main() {\n\tint a, b; scanf(\"%d%d\", &a, &b);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f; scanf(\"%d%d\", &e, &f);\n\t\tc[f].push_back(e);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tif (!used[i])DFS(i);\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tans[V[i]] = i;\n\t}\n\tfor (int i = 0; i < a; i++) {\n\t\tcout<<ans[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\n#define MAX_V 10000\n\nvector<int> G[MAX_V];\nlist<int> out;\nbool V[MAX_V];\nint N;//頂点数\nint indeg[MAX_V];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s] = true;\n    while(!q.empty()){\n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n        for(int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && !V[v]){\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i = 0; i < N; i++){\n        indeg[i] = 0;\n    }\n\n    for(int u = 0; u < N; u++){\n        for(int i = 0; i < G[u].size(); i++){\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n    \n    for(int u = 0; u < N; u++){\n        if(indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n}\n\nsigned main(){\n    int M;\n    cin >> N >> M;\n    int s,t;\n    REP(i,M){\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    tsort();\n    for(list<int>::iterator it = out.begin(); it != out.end(); it++){\n        cout << *it << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 10000;\n\nvector<int> g[MAX_V]; //??°??????\nvector<int> tp; //????????????????????????????????????\n\nvoid bfs(int s, int indeg[MAX_V], bool used[MAX_V]){\n    queue<int> q;\n\n    q.push(s);\n    used[s] = true;\n\n    while(not q.empty()){\n        int u = q.front(); q.pop();\n        tp.emplace_back(u);\n        rep(i,g[u].size()){\n            int v = g[u][i];\n            indeg[v]--;\n            if(indeg[v] == 0 && not used[v]){\n                used[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\n//??°??????????????????????????´??????0?????????\nbool topologicalSort(int v){\n    int indeg[MAX_V]; //??\\?¬???°\n    bool used[MAX_V];\n    memset(indeg, 0, sizeof(indeg));\n    memset(used, 0, sizeof(used));\n\n    rep(i,v) rep(j,g[i].size()) indeg[ g[i][j] ]++;\n    rep(i,v) if(indeg[i] == 0 && not used[i]) bfs(i, indeg, used);\n\n    for(auto it:tp) cout << it << endl;\n\n    if(tp.size() == v) return true;\n    else return false;\n}\n\nint main(){\n    int v, e;\n    cin >> v >> e;\n    rep(i,e){\n        int s, t;\n        cin >> s >> t;\n        g[s].emplace_back(t);\n    }\n    topologicalSort(v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\ntypedef struct data{int node,time;}data;\nint cmp(void const *a,void const *b){\n\treturn ((data*)a)->time < ((data*)b)->time;\n}\nint time = 0;\nint visited[10001];\ndata a[10001];\nvector<int> vec[10001];\nint dfs(int x){\n\tif(visited[x]==1){\n\t\treturn 0;\n\t}\n\telse{\n\t\tint i;\n\t\tvisited[x]=1;\n\t\tfor(i=0;i<vec[x].size();i++){\n\t\t\tdfs(vec[x][i]);\n\t\t}\n\t\ta[x].node = x;\n\t\ta[x].time = time++;\n\t}\n}\nint main(){\n\tint n,m,u,v,i;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tvec[u].push_back(v);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tvisited[i]=0;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tdfs(i);\n\t}\n\tqsort(a,n,sizeof(data),cmp);\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"%d\\n\",a[i].node);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nconst constexpr int MAX = 1e5;\nconst constexpr ll INF = 1LL<<32;\nvi G[MAX], indeg(MAX, 0), out;\nvb V(MAX, false);\nint n;\ninline void bfs(int s) {\n\tdeque<int> dq;\n\tdq.eb(s);\n\tV[s] = true;\n\tint u, v;\n\twhile(!dq.empty()) {\n\t\tu = dq.front(); dq.pop_front();\n\t\tout.eb(u);\n\t\trep(i, 0, len(G[u])) {\n\t\t\tv = G[u][i];\n\t\t\tif(--indeg[v] == 0 && !V[v]) {\n\t\t\t\tV[v] = true;\n\t\t\t\tdq.eb(v);\n\t\t\t}\n\t\t}\n\t}\n}\ninline void tsort() {\n\trep(u, 0, n) rep(i, 0, len(G[u])) ++indeg[G[u][i]];\n\trep(u, 0, n) if(indeg[u] == 0 && !V[u]) bfs(u);\n\trep(i, 0, len(out)) P(out[i]);\n}\nint main() {\n\tint m; cin >> n >> m;\n\tint s, t;\n\trep(i, 0, m) {\n\t\tcin >> s >> t;\n\t\tG[s].eb(t);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n\nusing namespace std;\n\nconst int MAXN=1010;\n\ntypedef vector<int> vec;\ntypedef vector<vec> Graph;\n\nGraph G(MAXN);\nvec d(MAXN);\n\nint main()\n{\n\tint n,e;\n\tscanf(\"%d%d\",&n,&e);\n\tfor(int i=0;i<e;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tG[s].push_back(t);\n\t\td[t]++;\n\t}\n\tqueue<int> que;\n\tfor(int i=0;i<n;i++)\n\t\tif(d[i]==0)\n\t\t\tque.push(i);\n\twhile(!que.empty())\n\t{\n\t\tint t=que.front();que.pop();\n\t\tprintf(\"%d\\n\",t);\n\t\td[t]=INT_MAX;\n\t\tfor(int i=0;i<G[t].size();i++)\n\t\t{\n\t\t\td[G[t][i]]--;\n\t\t\tif(d[G[t][i]]==0)\n\t\t\t\tque.push(G[t][i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid visit(const vector<vector<int>> &g, vector<int> &order, vector<bool> &mark, int pos){\n\tfor(auto next : g[pos]){\n\t\tif(mark[next]) continue;\n\t\tvisit(g, order, mark, next);\n\t}\n\tmark[pos] = true;\n\torder.push_back(pos);\n}\n\nvector<int> topologicalSort(const vector<vector<int>> &g){\n\tvector<int> res;\n\tvector<bool> mark(g.size(), false);\n\tfor(int i=0;i<g.size();i++){\n\t\tif(mark[i]) continue;\n\t\tvisit(g, res, mark, i);\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nvector<int> ts(const vector<vector<int>>& g){\n    vector<int> deg(g.size(), 0);\n    for(auto& v : g){\n        for(auto& t : v) ++deg[t];\n    }\n    vector<int> res;\n    for(int i=0;i<g.size();i++) if(!deg[i]) res.push_back(i);\n    for(int i=0;i<g.size();i++){\n        for(auto& t : g[res[i]]){\n            --deg[t];\n            if(!deg[t]) res.push_back(t);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> g(V);\n    for(int i=0;i<E;i++){\n        int s, t; cin >> s >> t;\n        g[s].push_back(t);\n    }\n    auto res = topologicalSort(g);\n    for(auto& t : res) cout << t << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n\tint num,E,from,to,table[10000],tmp;\n\tvector<int> V[10000];\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < 10000; i++)table[i] = 0;\n\n\tscanf(\"%d %d\",&num,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tV[from].push_back(to);\n\t\ttable[to]++;\n\t}\n\n\tfor(int i = 0; i < num; i++){\n\t\tif(table[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\t\tprintf(\"%d\\n\",tmp);\n\t\tfor(int i = 0; i < V[tmp].size(); i++){\n\t\t\ttable[V[tmp][i]]--;\n\t\t\tif(table[V[tmp][i]] == 0){\n\t\t\t\tQ.push(V[tmp][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#define N 10000\nusing namespace std;\n\nlist<int> l;\nbool color[N]={false};\nvector<int> adj[N];\nint n;\n\nvoid topo(int k){\n\tfor(int i=0;i<adj[k].size();i++) topo(adj[k][i]);\n\tif(!color[k])l.push_front(k);\n\tcolor[k]=true;\n}\n\nint main(void){\n\tint u,v;\n\tint e;\n\tcin>>n>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!color[i])topo(i);\n\t}\n\tfor(list<int>::iterator it=l.begin();it!=l.end();it++)cout<<*it<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <list>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=true;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        out.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0&&!V[v]){\n                V[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort(){\n    for(int i=0;i<N;i++){\n        indeg[i]=0;\n    }\n    \n    for(int u=0;u<N;u++){\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]++;\n        }\n    }\n    \n    for(int u=0;u<N;u++){\n        if(indeg[u]==0&&!V[u])bfs(u);\n    }\n    for(list<int>::iterator it=out.begin();it!=out.end();it++){\n        cout<<*it<<endl;\n    }\n}\n\nint main(void){\n    int s,t,M;\n    cin>>N>>M;\n    \n    for(int i=0;i<N;i++){\n        V[i]=false;\n    }\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    tsort();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=10000;\nconst int INF=123456789;\nvector<pair<int,int> > G[MAX];\nlist<int> out;\nint indeg[MAX];\nbool V[MAX];\nint n;\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i].first;\n      indeg[v]--;\n      if(indeg[v]==0&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\n\nvoid toposort(){\n  for(int i=0;i<n;i++){\n      indeg[i]=0;\n  }\n  for(int u=0;u<n;u++){\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i].first;\n      indeg[v]++;\n    }\n  }\n\n  for(int u=0;u<n;u++){\n    if(indeg[u]==0&&!V[u]){\n       bfs(u);\n    }\n  }\n}\n\nint main(){\n  int e;\n  cin>>n>>e;\n  for(int i=0;i<n;i++){\n    V[i]=false;\n  }\n\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    G[s].push_back(make_pair(t,1));\n  }\n\n  toposort();\n\n  for(list<int>::iterator p=out.begin();p!=out.end();p++){\n    cout<<*p<<endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<iomanip>\n#include<memory.h>\nusing namespace std;\nstruct node{\n\tint pos,ind;\n\tfriend bool operator < (node a,node b)\n\t{\n\t\treturn a.ind>b.ind;\n\t}\n};\npriority_queue<node> q;\nint n,m;\nvector<int> edge[10010];\nbool visited[10010];\nint indgree[10010];\nvector<int> ans;\nvoid init()\n{\n\tfor(int i=0;i<n;i++) visited[i]=false;\n\tfor(int i=0;i<n;i++)\n\tq.push({i,indgree[i]});\n\tans.clear();\n}\nvoid topological_sort()\n{\n\tinit();\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().pos,y=q.top().ind;\n\t\tif(visited[x])\n\t\t{\n\t\t\tq.pop();\n\t\t\tcontinue;\n\t\t}\n\t\tvisited[x]=true;q.pop();ans.push_back(x);\n\t\tfor(int i=0;i<edge[x].size();i++)\n\t\t{\n\t\t\tindgree[edge[x][i]]--;\n\t\t\tif(!visited[edge[x][i]]) q.push({edge[x][i],indgree[edge[x][i]]});\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tmemset(indgree,0,sizeof(indgree));\n\tint x,y; \n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tedge[x].push_back(y);\n\t\tindgree[y]++;\n\t}\n\ttopological_sort();\n\tfor(int i=0;i<ans.size();i++) cout<<ans[i]<<\" \";cout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    if(V == 2){\n        cout << 1 << endl << 0 << endl;\n        return 0;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<int> G[100100];\nbool used[100100];\nint V,E;\nvector<int> topo;\nvoid dfs(int v)\n{\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n\ttopo.pb(v);\n}\nvoid construct_topo()\n{\n\tmemset(used,false,sizeof(used));\n\tfor(int i=0;i<V;i++)if(!used[i])dfs(i);\n\treverse(all(topo));\n}\nint main()\n{\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tG[a].pb(b);\n\t}\n\tconstruct_topo();\n\tfor(int i=0;i<topo.size();i++)printf(\"%d\\n\",topo[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\nstatic const int MAXV = 10000, MAXE = 100000;\nint V, E;\nvector<int> G[MAXV];\nlist<int> ans;\nint col[MAXV];\nint indeg[MAXV];\n\nvoid bfs(int s) {\n\tqueue<int> Q;\n\tQ.push(s);\n\tcol[s] = GRAY;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tans.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && col[v] == WHITE) {\n\t\t\t\tQ.push(v);\n\t\t\t\tcol[v] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topologicalsort() {\n\tfor (int u = 0; u < V; u++) {\n\t\tif (indeg[u] == 0 && col[u] == WHITE) {\n\t\t\tbfs(u);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; i++) {\n\t\tcol[i] = WHITE;\n\t\tindeg[i] = 0;\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\ttopologicalsort();\n\tfor (int i = 0; i < V; i++) {\n\t\tcout << ans.front() << endl;\n\t\tans.pop_front();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint indeg[10005];\nint ts[10005], tt = 0;\nint q[10005], qh = 0, qt = 0;\nvector<int> G[10005];\n\nint main() {\n\tint v, e; cin >> v >> e;\n\tfor (int i = 1; i <= e; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tindeg[b]++;\n\t}\n\tfor (int i = 0; i < v; i++)\n\t\tif (!indeg[i])\n\t\t\tq[qt++] = i;\n\twhile (qh < qt) {\n\t\tint t = q[qh++];\n\t\tts[tt++] = t;\n\t\tfor (int h : G[t]) {\n\t\t\tindeg[h]--;\n\t\t\tif (!indeg[h]) q[qt++] = h;\n\t\t}\n\t}\n\tfor (int i = 0; i < tt; i++) cout << ts[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=2000000000;\n\n/* topologicalSort */\n#define topo_SIZE 1000\n\nvector<int> topologicalSort(vector<vector<int> > G,int n=-1){\n    int indeg[topo_SIZE] = {0},u;\n    vector<int> ret,ret2;\n    queue<int> que;\n    \n    if(n==-1) n=(int)G.size();\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        if(indeg[i]==0){\n            que.push(i);\n        }\n    }\n    \n    while(!que.empty()){\n        u = que.front();\n        que.pop();\n        \n        ret.push_back(u);\n        \n        for(int i=0;i<G[u].size();i++){\n            indeg[G[u][i]]--;\n            if(indeg[G[u][i]]==0){\n                que.push(G[u][i]);\n            }\n        }\n    }\n    \n    if(n==(int)ret.size()){\n        return ret;\n    }else{\n        return ret2;\n    }\n}\n\nint main(){\n    int v,e,a,b;\n    vector<int> ans;\n    vector<vector<int> > in(10000);\n    \n    scanf(\"%d%d\",&v,&e);\n    \n    for(int i=0;i<e;i++){\n        scanf(\"%d%d\",&a,&b);\n        \n        in[a].push_back(b);\n    }\n    \n    ans = topologicalSort(in,v);\n    \n    if(ans.size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    \n    for(int i=0;i<ans.size();i++){\n        printf(\"%d\\n\",ans[i]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nusing P = pair<int,int>;\n\n/* 大文字を小文字に変換 */\nchar tolower(char c) {return (c + 0x20);}\n/* 小文字を大文字に変換 */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n\n// イテレータ要素のインデックス\ndistance(A.begin(), itr);\n*/\n\nconst int MAX_N = 10100;\nconst int WHITE = 0, GRAY = 1;\n\nint indeg[MAX_N], color[MAX_N];\nvector<int> adl[MAX_N], out;\nint n;\n\nvoid init(){\n    rep(i,MAX_N){\n        color[i] = WHITE;\n        indeg[i] = 0;\n    }\n}\n\nvoid bfs(int u){\n    queue<int> Q;\n    Q.push(u);\n    color[u] = GRAY;\n\n    while(!Q.empty()){\n        u = Q.front(); Q.pop();\n        out.push_back(u);\n        for(auto v: adl[u]){\n            indeg[v]--;\n            if(indeg[v] == 0 && color[v] == WHITE){\n                Q.push(v);\n                color[v] = GRAY;\n            }\n        }\n    }\n}\n\nvoid topologicalSort(){\n    rep(u,n){\n        if(indeg[u] == 0 && color[u] == WHITE){\n            bfs(u);\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    int e; cin >> e;\n    init(); // 初期化\n    rep(_,e){\n        int u, v; cin >> u >> v;\n        adl[u].push_back(v);\n        indeg[v]++;\n    }\n    topologicalSort();\n    rep(i,n) cout << out[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <math.h>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 100\nstatic const long long FAR = (1L << 31);\n\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nvector<int> G[N];\nvector<int> out;\nbool Visited[N];\nint n, m;\nint indeg[N];\n\nvoid bfs(int s){\n\tqueue<int>q; q.push(s);\n\tVisited[s] = true;\n\twhile (!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (indeg[v] == 0 && !Visited[v]){\n\t\t\t\tVisited[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int i = 0; i < n; ++i) indeg[i] = 0;\n\n\tfor (int u = 0; u < n; ++u){\n\t\tfor (int j = 0; j < G[u].size(); ++j){\n\t\t\tint v = G[u][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < n; ++u) if (indeg[u] == 0 && !Visited[u]) bfs(u);\n\tfor (int i = 0; i < out.size(); ++i) cout << out[i] << endl;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) Visited[i] = false;\n\tfor (int i = 0; i < m; ++i){\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> topologicalSort(const Graph &g){\n    int n = g.size();\n    vector <int> res, inDegree(n);\n    queue <int> q;\n    for(auto &es : g) for(auto &e : es) ++inDegree[e.dst];\n    for(int i = 0; i < n; ++i) if(inDegree[i] == 0) q.push(i);\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        res.push_back(v);\n        for(auto &e : g[v]){\n            --inDegree[e.dst];\n            if(inDegree[e.dst] == 0) q.push(e.dst);\n        }\n    }\n    if((int)res.size() != n) return {};\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = topologicalSort(g);\n    assert(ord.size() == n);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nusing pii = pair<int, int>;\nint main() {\n  int v, e;\n  cin >> v >> e;\n\n  using Graph = vector<vector<int>>;\n\n  Graph G(v);\n  vector<int> d(v);\n\n  for (int i = 0; i < e; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a].push_back(b);\n    d[b]++;\n  }\n  vector<int> ans;\n\n  queue<int> que;\n  for (int i = 0; i < v; i++) {\n    if (d[i] == 0) {\n      que.push(i);\n    }\n  }\n\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i];\n      d[u]--;\n      if (d[u] == 0) que.push(u);\n    }\n    ans.push_back(v);\n  }\n\n  for (int i = 0; i < ans.size(); i++) {\n    cout << ans[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/11/22.\n//\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define MAXN 10000\nusing namespace std;\n\nint n, e;\nvector<int> graph[MAXN];\nqueue<int> q;\nvector<int> out;\nbool visited[MAXN];\nint indegree[MAXN];\n\nvoid init(){\n    fill(visited, visited+n, false);\n    find(indegree, indegree+n, 0);\n}\n\nvoid bfs(int node){\n    q.push(node);\n    visited[node] = true;\n    out.push_back(node);\n    while (!q.empty()){\n        int u = q.front();\n        q.pop();\n        vector<int>::iterator it;\n        for (it = graph[u].begin(); it != graph[u].end(); ++it){\n            visited[*it] = true;\n            indegree[*it]--;\n            if (!indegree[*it]){\n                out.push_back(*it);\n                q.push(*it);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d %d\", &n, &e);\n    init();\n    int u, v;\n    for (int i = 0; i < e; ++i) {\n        scanf(\"%d %d\", &u, &v);\n        graph[u].push_back(v);\n        indegree[v]++;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i] && !indegree[i]){\n            bfs(i);\n        }\n    }\n    vector<int>::iterator it;\n    for (it = out.begin(); it != out.end(); ++it){\n        printf(\"%d\\n\", *it);\n    }\n}\n/*\n6 6\n0 1\n1 2\n3 1\n3 4\n4 5\n5 2\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph {\n  int n;\n  int time;\n  vector<vector<int>> g;\n  vector<int> num, low;\n  vector<vector<int>> scc;\n  stack<int, deque<int>> S;\n  vector<bool> inS;\n\n  Graph(int n) : n(n), g(n), num(n, -1), low(n, -1), inS(n, false) {}\n\n  void addEdge(int u, int v) {\n    g[u].push_back(v);\n  }\n  void dfs(int u) {\n    num[u] = low[u] = time++;\n    S.push(u);\n    inS[u] = true;\n    for (auto&& v : g[u]) {\n      if (num[v] == -1) {\n        dfs(v);\n        low[u] = min(low[u], low[v]);\n      } else if (inS[v]) {\n        low[u] = min(low[u], num[v]);\n      }\n    }\n    if (low[u] == num[u]) {\n      scc.push_back({});\n      while (true) {\n        int v = S.top(); S.pop();\n        inS[v] = false;\n        scc.back().push_back(v);\n        if (u == v) break;\n      }\n    }\n  }\n  void stronglyConnectedComponents() {\n    for (int i = 0; i < n; ++i) {\n      if (num[i] == -1) dfs(i);\n    }\n  }\n};\n\nint main() {\n  int n, m; cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int s, t; cin >> s >> t;\n    g.addEdge(s, t);\n  }\n  g.stronglyConnectedComponents();\n  reverse(begin(g.scc), end(g.scc));\n  for (auto&& x : g.scc) cout << x[0] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit32(x) (1 << (x))\n#define bit64(x) (1ll << (x))\n#define sz(v) ((int) v.size())\n\nusing namespace std;\n\nusing i64 = long long;\nusing f80 = long double;\nusing vi32 = vector<int>;\nusing vi64 = vector<i64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\nvoid yes() { cout << \"Yes\" << endl; exit(0); }\nvoid no() { cout << \"No\" << endl; exit(0); }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> void amax(T &x, T y) { x = max(x, y); }\ntemplate <typename T> void amin(T &x, T y) { x = min(x, y); }\ntemplate <typename T> T exp(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\n\ntemplate <typename T, typename U>\nvector<U> make_vector(T&& n, U&& val) {\n  return vector<U>(forward<T>(n), forward<U>(val));\n}\ntemplate <typename T, typename... Args>\ndecltype(auto) make_vector(T&& n, Args&&... args) {\n  return vector<decltype(make_vector(forward<Args>(args)...))>(forward<T>(n), make_vector(forward<Args>(args)...));\n}\n\nconst int INF = 1001001001;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nvoid solve() {\n  int n, m;\n  cin >> n >> m;\n  vector<vi32> g(n);\n  vi32 deg(n);\n  rep(i, m) {\n    int u, v;\n    cin >> u >> v;\n    deg[v] += 1;\n    g[u].emplace_back(v);\n  }\n  vi32 history;\n  rep(i, n) if (deg[i] == 0) history.push_back(i);\n  int ptr = 0;\n  while (ptr < sz(history)) {\n    int u = history[ptr++];\n    for (int v : g[u]) {\n      deg[v] -= 1;\n      if (deg[v] == 0) history.push_back(v);\n    }\n  }\n  if (ptr == n) {\n    rep(i, n) cout << history[i] << '\\n';\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX=100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u){\n    V[u]=true;\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if (!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main(){\n    int s,t,M;\n    cin>>N>>M;\n    for(int i=0;i<N;i++) V[i]=false;\n    for(int i=0;i<M;i++){\n        cin>>s>>t;\n        G[s].push_back(t);\n    }\n    for(int i=0;i<N;i++){\n        if (!V[i]) dfs(i);\n    }\n    for(list<int>::iterator it =out.begin(); it!=out.end(); it++)\n        cout<<*it<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n\nconst int V_MAX = 10000;\n\nint main() {\n\tint v, e;\n\tint table[V_MAX] = { 0 };\n\tvector<int> edge[V_MAX];\n\tvector<int> ans;\n\n\tscanf(\"%d %d\", &v, &e);\n\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tedge[s].push_back(t);\n\t\ttable[t]++;\n\t}\n\t\n\tfor (int i = 0; i < v; i++) {\n\t\tif (table[i] == 0) {\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < ans.size();i++) {\n\t\tvector<int> e = edge[ans[i]];\n\t\tfor (int j = 0; j < e.size(); j++) {\n\t\t\tif (--(table[e[j]]) == 0) {\n\t\t\t\tans.push_back(e[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (vector<int>::iterator it = ans.begin(); it != ans.end(); it++) {\n\t\tprintf(\"%d\\n\", *it);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint v,e;\nvector<int> print;\nvector<int> edge[10000];\nint indeg[10000];\nbool alrdy[10000];\n\nvoid bfs(int start){\n\tqueue<int> next;\tnext.push(start);\n\twhile(!next.empty()){\n\t\tint ne=next.front();\tnext.pop();\n\t\tprint.push_back(ne);\n\t\talrdy[ne]=false;\n\t\tfor(int i=0;i<(int)edge[ne].size();i++){\n\t\t\tint tem=edge[ne][i];\n\t\t\tif(alrdy[tem]&&indeg[tem]>0){\n\t\t\t\tindeg[tem]--;\n\t\t\t\tif(indeg[tem]==0){\n\t\t\t\t\tnext.push(tem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>v>>e;\n\tfor(int i=0;i<10000;i++){\n\t\tindeg[i]=0;\talrdy[i]=true;\n\t}\n\tint s,t;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>s>>t;\n\t\tedge[s].push_back(t);\n\t\tindeg[t]++;\n\t}\n\tfor(int i=0;i<v;i++){\n\t\tif(alrdy[i]&&indeg[i]==0)\tbfs(i);\n\t}\n\tfor(vector<int>::iterator it=print.begin();it!=print.end();it++){\n\t\tcout<<*it<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nvector<int>topo_sort(const vector<vector<int>>&edges) {\n\tint size_ = edges.size();\n\tvector<int>nums(size_);\t\n\tfor(const auto& es:edges){\n\t\tfor (auto e : es) {\n\t\t\tnums[e]++;\n\t\t}\n\t}\n\tqueue<int>que;\n\tfor (int i = 0; i < size_; ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tvector<int>topo;\n\twhile (!que.empty()) {\n\t\tint ver(que.front());\n\t\ttopo.push_back(ver);\n\t\tque.pop();\n\t\tfor (auto e : edges[ver]) {\n\t\t\tnums[e]--;\n\t\t\tif (!nums[e])que.push(e);\n\t\t}\n\t}\n\tif (topo.size() == size_)return topo;\n\telse return vector<int>();\n}\nint main() {\n\tint V, E; cin >> V >> E;\n\tvector<vector<int>>edges(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint s, t; cin >> s >> t;\n\t\tedges[s].push_back(t);\n\t}\n\tauto vs=topo_sort(edges);\n\tfor (auto v : vs) {\n\t\tcout << v << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/GRL_4_B.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/GRL_4_B\"\n#line 1 \"test/aoj/../../graph/topological-sort.cpp\"\n#include <vector>\n#include <stack>\n#line 1 \"test/aoj/../../graph/template.cpp\"\n#include <vector>\n\nusing namespace std;\n\ntemplate< typename T >\nstruct Edge {\n  int from, to;\n  T cost;\n  Edge() {}\n  Edge(int f, int t) : from(f), to(t), cost(1) {}\n  Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n  friend bool operator < (const Edge& lhs, const Edge& rhs) { return lhs.cost < rhs.cost; };\n  friend bool operator > (const Edge& lhs, const Edge& rhs) { return rhs < lhs; };\n  friend bool operator <= (const Edge& lhs, const Edge& rhs) { return !(lhs > rhs); };\n  friend bool operator >= (const Edge& lhs, const Edge& rhs) { return !(lhs < rhs); };\n};\n\ntemplate< typename T >\nusing Edges = vector< Edge< T > >;\ntemplate< typename T >\nusing Graph = vector< Edges< T > >;\n#line 4 \"test/aoj/../../graph/topological-sort.cpp\"\nusing namespace std;\n\ntemplate< typename G >\nvector<int> topologicalSort(const G &g) {\n  // トポロジカルソートした結果を返す\n  const int V = g.size();\n  vector<int> indegree(V); // 200000とかだと遅い？ 厳しそうならグローバル変数にする\n  // 入次数の初期化. ほんとは読み込み時にやったほうが効率が良いけど許容する\n  for (int v = 0; v < V; ++v) {\n    for (auto& e: g[v]) ++indegree[e.to];\n  }\n\n  stack<int> st;\n  for (int v = 0; v < V; ++v) {\n    // 入次数0の点をstackにいれる\n    if (indegree[v] == 0) st.push(v);\n  }\n\n  vector<int> order;\n  while (!st.empty()) {\n    int v = st.top(); st.pop();\n    order.push_back(v);\n    for (auto& e: g[v]) {\n      --indegree[e.to];\n      if (indegree[e.to] == 0) st.push(e.to);\n    }\n  }\n\n  return order;\n}\n#line 3 \"test/aoj/GRL_4_B.test.cpp\"\n\n#include <iostream>\nusing namespace std;\n\nusing G = Graph<int>;\nint main() {\n  int V, E; cin >> V >> E;\n  G graph(V);\n  for (int i = 0; i < E; ++i) {\n    int s, t; cin >> s >> t;\n    graph[s].emplace_back(s, t);\n  }\n  vector<int> order = topologicalSort(graph);\n  for (int v: order) { cout << v << endl; }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass topological_sort {\n  const int n;\n  const vector<vector<int>>& grh;\n  vector<int> srd;\n  vector<int> ckd;\n  bool flg;\n\n  bool dfs (int crr) {\n    if (ckd[crr] == 1) return true;\n    if (ckd[crr] == 2) return false;\n    bool ret = false;\n    ckd[crr] = 1;\n    for (int nxt : grh[crr]) {\n      ret |= dfs(nxt);\n    }\n    ckd[crr] = 2;\n    srd.insert(srd.begin(), crr);\n    return ret;\n  }\n\n  public:\n    topological_sort (\n        const vector<vector<int>>& grh\n      ) :\n      n(grh.size()),\n      grh(grh),\n      srd(),\n      ckd(n, 0),\n      flg(false)\n      {\n        for (int i = 0; i < n; i++) {\n          flg |= (ckd[i] == 0 && dfs(i));\n        }\n      }\n    bool has_cycle () {return flg;}\n    auto sorted() const -> const vector<int>& {return srd;}\n    auto operator[](int i) const -> int {return srd[i];}\n};\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> grh(n);\n  for (int i = 0; i < m; i++) {\n    int s, t;\n    cin >> s >> t;\n    grh[s].push_back(t);\n  }\n  topological_sort tps(grh);\n  assert(!tps.has_cycle());\n  for (int i = 0; i < n; i++) {\n    cout << tps[i] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n    V[u] = true;\n    for(int i = 0; i < G[u].size(); i++) {\n        int v = G[u][i];\n        if(!V[v]) dfs(v);\n    }\n    out.push_front(u);\n}\n\nint main() {\n    int s, t, M;\n    \n    cin >> N >> M;\n    \n    for(int i = 0; i < N; i++) V[i] = false;\n    \n    for(int i = 0; i < M; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n    \n    for(int i = 0; i < N; i++) {\n        if(!V[i]) dfs(i);\n    }\n    \n    for(list<int>::iterator it = out.begin(); it != out.end(); it++) {\n        cout << *it << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// library\n#include<unordered_map>\n// using\n// template<typename Label, typename Weight>\n// using Graph = std::unordered_map<Label, std::unordered_map<Label, Weight>>;\ntypedef std::unordered_map<int, std::unordered_map<int, int>> Graph;\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\n#include<unordered_set>\nusing namespace std;\n\nvector<int> topological_sort(const Graph& reverse, int current, unordered_set<int>& unvisited) {\n  vector<int> result = {current};\n  unvisited.erase(current);\n  if(reverse.count(current)) for(const auto& e: reverse.at(current)) {\n    if(unvisited.count(e.first)) {\n      auto add = topological_sort(reverse, e.first, unvisited);\n      result.insert(begin(result), begin(add), end(add));\n    }\n  }\n  return result;\n}\nvector<int> topological_sort(const Graph& g) {\n  vector<int> result;\n  unordered_set<int> unvisited;\n  Graph reverse;\n  for(const auto& list: g) for(const auto& e: list.second) {\n    reverse[e.first][list.first] = e.second;\n    unvisited.insert(list.first);\n    unvisited.insert(e.first);\n  }\n  while(!unvisited.empty()) {\n    auto add = topological_sort(reverse, *begin(unvisited), unvisited);\n    result.insert(end(result), begin(add), end(add));\n  }\n  return result;\n}\n\nint main() {\n  int V, E;\n  cin >> V >> E;\n  Graph g;\n  for(int i = 0; i < E; ++i) {\n    int u, v;\n    cin >> u >> v;\n    g[u][v] = 1;\n  }\n  for(const auto& v: topological_sort(g)) cout << v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n\nusing ll = long long;\nusing namespace std;\n\nvector<int> G[1000000];\nint indeg[1000000] = {};\nint N;\nbool V[1000000];\nlist<int> out;\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()){\n        int u = q.front(); q.pop();\n        out.push_back(u);\n        for (int v : G[u]) {\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v]) {V[v] = true; q.push(v);}\n        }\n    }\n}\n\nvoid toporogicalsort() {\n    for (int i = 0; i < N; ++i) {\n        for (int v : G[i]) {\n            indeg[v]++;\n        }\n    }\n    for (int u = 0; u < N; ++u) {\n        if ( indeg[u] == 0 && !V[u]) bfs(u);\n    }\n    for (int &it : out) {\n        cout << it << \"\\n\";\n    }\n}\n\n\n\nint main() {\n    int s, t, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < N; ++i) {\n        V[i] = false;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    toporogicalsort();\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//幅優先探索によるトポロジカルソート\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<list>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int INFTY = (1 << 29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) // 幅優先探索\n{\n    queue<int> q;\n    q.push(s);\n    while( !q.empty() )\n    {\n        int u = q.front();\n        q.pop();\n        out.push_back(u);\n        for (int i = 0; i < G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && !V[v])\n            {\n                V[v] = true;\n                q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort()\n{\n    for (int i = 0; i < N; i++)\n    {\n        indeg[i] = 0;\n    }\n\n    for (int u = 0; u < N; u++)\n    {\n        for (int i = 0; i < G[u].size(); i++)\n        {\n            int v = G[u][i];\n            indeg[v]++;\n        }\n    }\n\n    for (int u = 0; u < N; u++)\n    {\n        if (indeg[u] == 0 && !V[u]) bfs(u);\n    }\n\n    for ( list<int>::iterator it = out.begin(); it != out.end(); it++) //Listの要素のポインタを先頭から末尾まで走らせる\n    {\n        cout << *it << endl;\n    }\n}\n\nint main()\n{\n    int s, t, M;\n\n    cin >> N >> M;\n\n    for (int i = 0; i < N; i++) V[i] = false;\n\n    for (int i = 0; i < M; i++)\n    {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INF=(1<<29);\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX]; int N,indeg[MAX];\n\nvoid bfs(int s){\n  queue<int> q;\n  q.push(s); V[s]=true;\n  while(!q.empty()){\n    int u=q.front(); q.pop();\n    out.push_back(u);\n    for(int i=0;i<G[u].size();i++){\n      int v=G[u][i];\n      indeg[v]--;\n      if(indeg[v]==0 && !V[v]){V[v]=true; q.push(v);}\n    }\n  }\n}\nvoid tsort(){\n  for(int i=0;i<N;i++)indeg[i]=0;\n  for(int u=0;u<N;u++){\n    for(int i=0;i<G[u].size();i++){int v=G[u][i]; indeg[v]++;}\n  }\n  for(int u=0;u<N;u++){if(indeg[u]==0 && !V[u])bfs(u);}\n  for(list<int>::iterator it=out.begin();it!=out.end();it++){cout << *it << endl;}\n}\n\nint main(){\n  int s,t,M;\n  cin >> N >> M;\n  for(int i=0;i<N;i++)V[i]=false;\n  for(int i=0;i<M;i++){\n    cin >> s >> t;\n    G[s].push_back(t);\n  }\n  tsort();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define MAX 10010\nvvi G(MAX);\nvi out;\nbool V[MAX];\nint n;\nint indeg[MAX];\nvoid bfs(int s){\n\tqueue<int>q;\n\tq.push(s);\n\tV[s]=true;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tout.pb(u);\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v]==0&&!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid tsort(){\n\tout=vi(0);\n\trep(i,n)indeg[i]=0;\n\trep(i,n)rep(j,G[i].size()){\n\t\tint v=G[i][j];\n\t\tindeg[v]++;\n\t}\n\trep(i,n)if(indeg[i]==0&&!V[i])bfs(i);\n\trep(i,n)cout<<out[i]<<endl;\n}\nint main(){\n\tint s,t,m;\n\tcin>>n>>m;\n\trep(i,n)V[i]=false;\n\twhile(m--){\n\t\tcin>>s>>t;\n\t\tG[s].pb(t);\n\t}\n\ttsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  //{{{\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) std::cerr << #x << ':' << x << '\\n';\n\ntypedef long long ll;\n// clang-format off\ntemplate<typename T,typename U>inline bool chmax(T&x,U a){if(x>=a)return 0;x=a;return 1;}\ntemplate<typename T,typename U>inline bool chmin(T&x,U a){if(x<=a)return 0;x=a;return 1;}\ninline int in(){int x;scanf(\"%d\", &x);return x;}\n// clang-format on\n// }}}\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  typedef int weight_type;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\ntypedef Edge::weight_type Weight;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Weights;\ntypedef std::vector<int> Path;\ntypedef std::vector<int> Nodes;\n}\ntypedef std::vector<graph::Edges> Graph;\n}\n#endif\n//}}}\n// {{{ topological_sort.cc\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n\nnamespace orliv {\nnamespace graph {\nnamespace topological_internal {\nstruct TopologicalImpl {\n  const Graph& G;\n  std::vector<int> color;\n  Nodes order;\n  TopologicalImpl(const Graph& g) : G(g), color(g.size()) {}\n  Nodes get() {\n    for (int v = 0; v < G.size(); v++) {\n      if (!color[v] && !dfs(v)) return Nodes();\n    }\n    reverse(order.begin(), order.end());\n    return std::move(order);\n  }\n\n private:\n  bool dfs(int v) {\n    color[v] = 1;\n    for (const auto& e : G[v]) {\n      int u = e.to;\n      if (color[u] == 2) continue;\n      if (color[u] == 1) return false;\n      if (!dfs(u)) return false;\n    }\n    order.emplace_back(v);\n    color[v] = 2;\n    return true;\n  }\n};\n}\n\nNodes topologicalSort(const Graph& g) {\n  return std::move(topological_internal::TopologicalImpl(g).get());\n}\n}\n}\n// }}}\n\nusing namespace std;\n\nint main() {\n  int V = in(), E = in();\n  orliv::Graph g(V);\n  for (int i = 0; i < E; i++) {\n    int s = in(), t = in();\n    g[s].emplace_back(s, t);\n  }\n  auto order = orliv::graph::topologicalSort(g);\n  for (auto v : order) {\n    cout << v << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(), (g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define INF 1 << 30\n#define pb push_back\n#define mp make_pair\n\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\ntypedef long long ll;\n\nstatic const int MAX = 100000;\n\n\nvector<int> G[MAX];\nvector<int> out;\nint V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s) {\n    queue<int> q;\n    q.push(s);\n    V[s] = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        out.push_back(u);\n\n        rep(i, G[u].size()) {\n            int v = G[u][i];\n            indeg[v]--;\n            if (indeg[v] == 0 && V[v] == 0) {\n                V[v] = 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\n\nvoid tsort(void) {\n    rep(i, N) {\n        V[i] = 0;\n        indeg[i] = 0;\n    }\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            indeg[G[i][j]]++;\n        }\n    }\n\n    rep(i, N) {\n        if (indeg[i] == 0 && V[i] == 0) bfs(i);\n    }\n}\n\n\nint main(void) {\n    int V, s, t;\n    scanf(\"%d %d\", &N, &V);\n\n    rep(i, N) {\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    rep(i, out.size()) printf(\"%d\\n\", out[i]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define PB push_back\n#define CLR(a) memset(a,0,sizeof a)\n#define VI vector<int>\n#define INT(x) int x; scanf(\"%d\",&x);\n#define SZ(a) ((int)(a.size()))\n\n#define MAX_V 100000\n\nint V;\nVI graph[MAX_V];\nbool vis[MAX_V];\nVI mlist;\nint indeg[MAX_V];\n\nvoid topologicalsort() {\n  CLR(indeg);\n  REP(i, V) {\n    REP (j, SZ(graph[i])) {\n      int p = graph[i][j];\n      indeg[p]++;\n    }\n  }\n\n  REP(i, V) {\n    if (indeg[i] == 0 && !vis[i]) {\n      queue<int> que;\n      que.push(i);\n      mlist.PB(i);\n      vis[i] = true;\n      while (!que.empty()) {\n\tint p = que.front(); que.pop();\n\n\tREP(j , SZ(graph[p])) {\n\t  int np = graph[p][j];\n\t  indeg[np]--;\n\t  if (vis[np]) continue;\n\t  if (indeg[np] == 0) {\n\t    vis[np] = true;\n\t    que.push(np);\n\t    mlist.PB(np);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> V;\n  INT(E);\n  REP(i, E) {\n    INT(s); INT(t);\n    graph[s].PB(t);\n  }\n  topologicalsort();\n\n  REP(i, SZ(mlist)) {\n    cout << mlist[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <queue>\n#define max 10005\n#define inf 0x3fffffff\n \nusing namespace std;\n \nint n,e;\nlist<int> out;\nvector<int> G[max];\nqueue<int> q;\nbool v[max];\nint indeg[max];\n \nvoid bfs() {\n    int i;\n    //queue<int> q;\n    //q.push(u);\n    //v[u]=true;\n    while(!q.empty()) {\n        int tmp=q.front();\n        q.pop();\n        out.push_back(tmp);\n        for(i=0;i<G[tmp].size();i++) {\n            int s=G[tmp][i];\n            indeg[s]--;\n            if(indeg[s]==0 && v[s]==false) {\n                q.push(s);\n                v[s]=true;\n            }\n        }\n    }\n}\n \nint main() {\n    int i;\n     \n    scanf(\"%d %d\",&n,&e);\n     \n    for(i=0;i<n;i++) {\n        v[i]=false;\n        indeg[i]=0;\n    }\n     \n    for(i=0;i<e;i++) {\n        int d1,d2;\n        scanf(\"%d %d\",&d1,&d2);\n        G[d1].push_back(d2);\n        indeg[d2]++;\n    }\n     \n    /*for(i=0;i<n;i++) {\n        if(indeg[i]==0 && v[i]==false) bfs(i);\n    }*/\n    \n    for(i=0;i<n;i++) {\n        if(indeg[i]==0 && v[i]==false) {\n        \tq.push(i);\n        \tv[i]=true;\n\t\t}\n    }\n    \n    bfs();\n     \n    for(list<int>::iterator it=out.begin();it!=out.end();it++) {\n        printf(\"%d\\n\",*it);\n    }\n     \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\nll MOD = 1000000007;\nll INFL = 1ll << 60;\nll INF = 1 << 28;\n\nvector<int> g[10010];\nbool went[10010];\nint topo[10010];\nint c;\n\nvoid dfs(int now) {\n  went[now] = true;\n  for (auto to : g[now])\n    if (!went[to]) dfs(to);\n  topo[now] = c;\n  c++;\n}\n\n// ====================================================================\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  for (int i = 0; i < m; i++) {\n    int from, to;\n    cin >> from >> to;\n    g[from].push_back(to);\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (!went[i])\n      dfs(i);\n  }\n\n  vector<pair<int, int>> v;\n  for (int i = 0; i < n; i++) {\n    v.push_back(make_pair(topo[i], i));\n  }\n  sort(v.rbegin(), v.rend());\n  for (int i = 0; i < n; i++) {\n    cout << v[i].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\n#define INF 1e18\n#define MOD 1000000007\n#define SIZE 100005\n\nusing namespace std;\ntypedef pair<int,int> P;\n\n//-----------------------------------------------------------------------\n\nint V,E;\nvector<int> G[10005];\nbool used[10005];\nvector<int> ans;\n\nvoid dfs(int v){\n    used[v]=true;\n    for(auto u:G[v]){\n        if(!used[u]) dfs(u);\n    }\n    ans.push_back(v);\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>V>>E;\n    REP(i,E){\n        int a,b; cin>>a>>b;\n        G[a].push_back(b);\n    }\n    REP(i,V){\n        if(!used[i]) dfs(i);\n    }\n    reverse(ALL(ans));\n    REP(i,V) cout<<ans[i]<<endl;\n    \n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxx=10010;\nconst int inf=INT_MAX;\n\nvector<int> A[maxx],ans;\nqueue<int> task;\nint f[maxx];\nbool flag[maxx];\nint v,e;\n\nint main (){\n\tint x,y;\n\tbool xx=false;\n\tcin>>v>>e;\n\tfor(int i=0;i<maxx;i++){\n\t\tf[i]=0;\n\t\tflag[i]=false;\n\t}\n\twhile(e--){\n\t\tcin>>x>>y;\n\t\tA[x].push_back(y);\n\t\tf[y]++;\n\t}\n\twhile(1){\n\t\txx=false;\n\t\tfor(int i=0;i<v;i++) {\n\t\t\tif(f[i]==0&&flag[i]==false) {\n\t\t\t\txx=true;\n\t\t\t\ttask.push(i);\n\t\t\t}\n\t\t}\n\t\tif(xx==false) break;\n\t\twhile(task.empty()==0){\n\t\t\tx=task.front();\n\t\t\tflag[x]=true;\n\t\t\tans.push_back(x);\n\t\t\tfor(int k=0;k<A[x].size();k++){\n\t\t\t\tf[A[x][k]]--;\n\t\t\t}\n\t\t\ttask.pop();\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<endl;\n\t}\n\treturn 0;\n\t\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define NUM 10000\nint v_num, e_num;\nvector<int> V[NUM];\nint d[NUM];\nqueue<int> Q;\n\nvoid init(){\n    for(int i = 0; i < v_num; i++){\n        d[i] = 0;\n    }\n\n    for(int i = 0; i < e_num; i++){\n        int s, t;\n        scanf(\"%d\", &s);\n        scanf(\"%d\", &t);\n        V[s].push_back(t);\n        d[t]++;\n    }\n\n    for(int i = 0; i < v_num; i++){\n        if(d[i] == 0)\n            Q.push(i);\n    }\n}\n\nvoid t_sort(){\n    while(!Q.empty()){\n        int f = Q.front(); Q.pop();\n        printf(\"%d\\n\", f);\n        for(int i = 0; i < V[f].size(); i++){\n            d[V[f][i]]--;\n            if (d[V[f][i]] == 0){\n                Q.push(V[f][i]);\n            }\n        }\n    }\n}\n\nint main(void){\n    scanf(\"%d\", &v_num);\n    scanf(\"%d\", &e_num);\n\n    init();\n\n    t_sort();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing ll = long long;\n\ntemplate <class T>\nusing vec = std::vector<T>;\n\ntemplate <class T>\nconstexpr T nil = static_cast<T>(-1);\n\ntemplate <class T>\nconstexpr T inf = std::numeric_limits<T>::max() / 2;\n\n\nconstexpr int NIL = nil<int>;\n\nvoid solve()\n{\n    using namespace std;\n\n    int n, m;\n    cin >> n >> m;\n\n    vec<vec<int>> edges(n);\n    vec<int> degIn(n, 0);\n\n    for (int i = 0, from, to; i < m; ++i)\n    {\n        cin >> from >> to;\n        edges[from].push_back(to);\n        ++degIn[to];\n    }\n\n    vec<int> sortedV;\n    queue<int> q;\n\n    for (int i = 0; i < n; ++i)\n        if (degIn[i] == 0)\n            q.push(i);\n    \n    while (!q.empty())\n    {\n        auto v = q.front(); q.pop();\n\n        sortedV.push_back(v);\n\n        for (int e : edges[v])\n            if (--degIn[e] == 0)\n                q.push(e);\n    }\n\n    for (int v : sortedV)\n        cout << v << endl;\n\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXV = 10010;\n\nint v, e;\nvector<int> g[MAXV];\nint visited[MAXV];\nint indegree[MAXV];\nlist<int> result;\n\nvoid DFS(int s) {\n  queue<int> q;\n  q.push(s);\n  visited[s] = 1;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    result.push_back(u);\n    for (auto v: g[u]) {\n      if (!--indegree[v]) {\n        q.push(v);\n        visited[v] = 1;\n      }\n    }\n  }\n}\n\nvoid TopologicalSort() {\n  memset(indegree, sizeof(int), 0);\n  memset(visited, sizeof(int), 0);\n  for (int i = 0; i < v; ++i) {\n    for (auto t: g[i]) {\n      ++indegree[t];\n    }\n  }\n  for (int i = 0; i < v; ++i) {\n    if (!indegree[i] && !visited[i]) {\n      DFS(i);\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d %d\", &v, &e);\n  for (int i = 0; i < e; ++i) {\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    g[s].push_back(t);\n  }\n\n  TopologicalSort();\n  for (int u: result) {\n    printf(\"%d\\n\", u);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint v,e;\nconst int MAX_V=10005;\n\nvector<int> rinsetu[MAX_V];\nbool visited[MAX_V];\nvector<int> ans;\n\nvoid dfs(int u){\n    visited[u]=true;\n    for(auto itr=rinsetu[u].begin();itr!=rinsetu[u].end();itr++){\n        if(!visited[*itr]){\n            dfs(*itr);\n        }\n    }\n    ans.push_back(u);\n}\n\nvoid topological_sort(){\n    for(int i=0;i<v;i++){\n        if(!visited[i]){\n            dfs(i);\n        }\n    }\n    reverse(ans.begin(),ans.end());\n}\n\nint main(){\n    cin>>v>>e;\n    for(int i=0;i<e;i++){\n        int s,t;\n        cin>>s>>t;\n        rinsetu[s].push_back(t);\n    }\n    for(int i=0;i<v;i++){\n        visited[i]=false;\n    }\n    topological_sort();\n    for(auto itr=ans.begin();itr!=ans.end();itr++){\n        cout<<*itr<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1010000000000000017LL;\nconst ll MOD = 1000000007LL;\n\n#define REP(i, n) for(ll i = 0 ; i < n; i++)\n\n//#define DEBUG(fmt, ...)\n#define DEBUG(fmt, ...) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__)\n\n/*\nvoid Method1(){\n    ll V, E;\n\n    cin >> V >> E;\n    vector<vector<int>> graph(V);\n    vector<int> incoming(V);\n\n    REP(i, E){\n        ll s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        incoming[t]++;\n    }\n\n    queue<int> zero_queue;\n    REP(i, V){\n        if(incoming[i] == 0){\n            zero_queue.push(i);\n        }\n    }\n\n    while(!zero_queue.empty()){\n        ll cur = zero_queue.front();\n        zero_queue.pop();\n        cout << cur << endl;\n        REP(i, graph[cur].size()){\n            incoming[graph[cur][i]]--;\n            if(incoming[graph[cur][i]] == 0 ){\n                zero_queue.push(graph[cur][i]);\n            }\n        }\n    }\n\n}\n*/\n\nbool DFS(vector<vector<int>>& graph, int v, vector<int>& visited, vector<int>& done, stack<int>& sorted){\n    if( visited[v] ){\n        return false;\n    }\n    if( done[v]) {\n        return true;\n    }\n\n    visited[v] = true;\n    REP(i, graph[v].size() ){\n        if( !DFS(graph, graph[v][i], visited, done, sorted) ){\n            return false;\n        }\n    }\n    visited[v] = false;\n    done[v] = true;\n    sorted.push(v);\n\n    return true;\n}\n\nint main(){\n    std::cout<<std::fixed<<std::setprecision(10);\n\n    ll V, E;\n    cin >> V >> E;\n    vector<vector<int>> graph(V);\n    vector<int> incoming(V);\n\n    REP(i, E){\n        ll s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        incoming[t]++;\n    }\n\n    vector<int> visited(V, false);\n    vector<int> done(V, false);\n    stack<int> sorted;\n    REP(i,V){\n        if(!DFS(graph, i, visited, done, sorted) ){\n            cout << \"not DAG\" << endl;\n            return 0;\n        }\n    }\n\n    while(!sorted.empty()){\n        cout << sorted.top() << endl;\n        sorted.pop();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nstatic const long long FAR = (1LL << 29);\nstatic const int N = 100000;\n\nint n, m;\nbool visited[N];\nint p[N];\n\nvector<int> G[N];\nvector<int> sorted;\n\nvoid bs(int i) {\n\tqueue<int> q; q.push(i);\n\tvisited[i] = true;\n\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tvisited[u] = true;\n\t\tsorted.push_back(u);\n\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v = G[u][i];\n\t\t\tp[v]--;\n\t\t\tif (p[v] == 0 && !visited[v]){\n\t\t\t\tq.push(v);\n\t\t\t\tvisited[v] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ts(){\n\tfor (int i = 0; i < n; ++i){\n\t\tvisited[i] = false;\n\t\tp[i] = 0;\n\t}\n\n\tfor (int u = 0; u < n; ++u) {\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tp[v]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i){\n\t\tif (p[i] == 0 && !visited[i]) bs(i);\n\t}\n\n\tfor (int i = 0; i < sorted.size(); ++i) cout << sorted[i] << endl;\n}\n\nint main() {\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v);\n\t}\n\n\tts();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long unsigned int ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n#define MAX 10000\n\nint V, E;\nvector<int> G[MAX];\nvector<int> out;\nint integ[MAX];\nbool color[MAX];\n\nvoid bfs(int s) {\n    queue<int> Q;\n    Q.push(s);\n    color[s] = true;\n\n    while(!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        \n        out.push_back(u);\n\n        for(int i=0; i<G[u].size(); i++) {\n            int v = G[u][i];\n            integ[v] --;\n\n            if( integ[v] ==  0 && color[v] == false) {\n                color[v] = true;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nvoid tsort() {\n    for(int i=0; i<V; i++) {\n        for(int j=0; j<G[i].size(); j++) {\n            integ[G[i][j]] ++;\n        }\n    }\n\n    for(int i=0; i<V; i++) {\n        if (integ[i] == 0 && color[i] == false) {\n            bfs(i);\n        }\n    }\n}\n\nint main() {\n    int s,t;\n\n    cin >> V >> E;\n\n    for(int i=0; i<V; i++) {\n        color[i] = false;\n    }\n\n    for(int i=0; i<E; i++) {\n        cin >> s >> t;\n        G[s].push_back(t);\n    }\n\n    tsort();\n\n    for(vector<int>::iterator it= out.begin(); it != out.end(); ++it) {\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline bool Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+\" \";\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nconstexpr const ll INF = 1e15;\nconstexpr const ll MOD = 1000000007;\nconstexpr const ll MAX = 1e9;\nconstexpr ll nx[4] = {1,0,-1,0};\nconstexpr ll ny[4] = {0,1,0,-1};\ntypedef pair<ll,ll> P;\nvector<int> t_sort(vector<vector<int>> &g){\n    vector<int> res,cnt(g.size(),0);\n    queue<int> q;\n    rep(i,g.size()){\n        for (int e:g[i]){\n            cnt[e]++;\n        }\n    }\n    rep(i,g.size()){\n        if (cnt[i] == 0) q.push(i);\n    }\n    while(!q.empty()){\n        int v = q.front();q.pop();\n        res.push_back(v);\n        for (int u:g[v]){\n            cnt[u]--;\n            if (cnt[u] == 0){\n                q.push(u);\n            }\n        }\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int v,e,s,t;\n    cin >> v >> e;\n    vector<vector<int>> g(v);\n    rep(i,e){\n        cin >> s >> t;\n        g[s].push_back(t);\n    }\n    vector<int> k = t_sort(g);\n    rep(i,v){\n        PRINT(k[i]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <tuple>\n#include <string.h>\n#include <map>\n#include <iomanip>\n#include <time.h>\nusing namespace std;\ntypedef long long ll;\n\nint n, m;\nbool vis[100010] = {};\nvector<int> G[100010], tp;\n\nvoid dfs(int v) {\n    if (!vis[v]) {\n        vis[v] = 1;\n        for (int i = 0; i < G[v].size(); i++) {\n            dfs(G[v][i]);\n        }\n        tp.push_back(v);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        G[a].push_back(b);\n    }\n\n    bool t[n + 5] = {};\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            t[G[i][j]] = 1;\n        }\n    }\n\n    int root = -1;\n    for (int i = 0; i < n; i++) {\n        if (!t[i]) {\n            root = i;\n            break;\n        }\n    }\n\n    for (int i = 0; i < n; i++) dfs(i);\n    reverse(tp.begin(), tp.end());\n\n    for (int i = 0; i < n; i++) cout << tp[i] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nsigned main(){\n\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> adj(v);\n  vector<int> deg(v);\n  for(int i=0;i<e;++i){\n    int s,t;cin>>s>>t;\n    adj[s].emplace_back(t);\n    deg[t]++;\n  }\n\n  queue<int> que;\n  for(int i=0;i<v;++i)if(deg[i]==0)que.emplace(i);\n  vector<int> res;\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    res.emplace_back(v);\n    for(auto nv:adj[v]){\n      deg[nv]--;\n      if(deg[nv]==0)que.emplace(nv);\n    }\n  }\n\n  for(auto a:res)cout<< a <<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o << \" \" << o << endl; }\n#define dumpc(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//dx[i],dy[i]???i?????????????§???????????????¢???\n//  3\n// 2 0\n//  1\n\n//??\\?????¨?????°\nint X, Y;\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\n\t/* ?????? */\n\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tconst int MAX = 1; //????????´???\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\t//???????????¢\n\tint d[MAX][MAX];\n\tmemset(d, 0x3f, sizeof(d));\n\td[sx][sy] = 0;\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (u == pii(gx, gy))break; //??´??????????????¢?´¢????????????\n\t\tfor (int i = 0; i < 4; i++) {//?§????4???????????¢?´¢\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\t\tif (d[nx][ny] != INF)continue; //??¢?´¢???????£???°???\n\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[gx][gy];\n}\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nstruct Edge {\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//prev: ???????????¨????????????\nvoid dijkstra(Graph g, int s, vector<Weight> &dist, vector<int> &prev) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tdist.assign(n, INFG); //distance\n\tprev.assign(n, -1);\n\tdist[s] = 0; PQ.push(State(0, s, -1)); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.push(State(dist[e.d], e.d, v));\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Bellman Ford O(|V||E|)\n//dist: ?§????????????????????????§??????????????¢\n//prev: ???????????¨????????????\n//?????????: ???????????????:true ??????:false\nbool bellmanFord(Graph g, int s, vector<Weight> &dist, vector<int> &prev) {\n\treturn false;\n}\n\n//?§?????????????????????§??????????????????\n//???????????????????????°?????????????§??????????????????§?????????????????¢????????????\nvector<int> getPath(int s, int g, vector<int> prev) {\n\tvector<int> path;\n\tpath.push_back(g);\n\tfor (int i = g; i != s; ) path.push_back(i = prev[i]);\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n\n//??¨????????????????????? All Pairs Shortest Path\n//Warshall Floyd O(|V|^3)\n//?????????: ???????????????:true ??????:false\nbool warshallFloyd(Graph g, Matrix &dist) {\n\tbool negative_cycle = false;\n\tint n = g.size();\n\tdist.assign(n, Array(n, INFG));\n\tfor (int i = 0; i < n; i++) dist[i][i] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto e : g[i])\n\t\t\tdist[e.s][e.d] = min(dist[e.s][e.d], e.w);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (dist[j][i] != INFG&&dist[i][k] != INFG)\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i][i] != 0)\n\t\t\tnegative_cycle = true;\n\treturn negative_cycle;\n}\n\n//???????????????\nvoid printPath(vector<int> path) {\n\tcout << \"Path: \";\n\tfor (auto p : path) cout << p << \" \";\n\tcout << endl;\n}\n\n//???????????????????????????\n//??\\?¬???°???0????????¨???????????????????????????ret????????£??????\nvector<int> topologicalSort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tvector<int> ret(n), indeg(n); //??\\?¬???°\n\tfor (auto &es : g) for (auto &e : es) indeg[e.d]++;\n\tqueue<int> Q;\n\tfor (int i = 0; i < n; i++) if (indeg[i] == 0) Q.push(i);\n\twhile (!Q.empty()) {\n\t\tint v = Q.front(); Q.pop(); ret[k++] = v;\n\t\tfor (auto &e : g[v]) if (--indeg[e.d] == 0) Q.push(e.d);\n\t}\n\treturn *max_element(indeg.begin(), indeg.end()) == 0 ? ret : vector<int>();\n}\n\nint main() {\n\tint V, E; cin >> V >> E;\n\tGraph g(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t; scanf(\"%d%d\", &s, &t);\n\t\tg[s].push_back(Edge(s, t));\n\t}\n\tvector<int> ans(topologicalSort(g));\n\tfor (auto &e : ans) {\n\t\tprintf(\"%d\\n\", e);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n\tqueue<int> q;\n\tq.push(s);\n\tV[s]=true;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\t//??\\?¬???°???0??????????????????????????\\?????????\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v=G[u][i];\n\t\t\t//???????¶?????????¨??????????????????\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v]==0&&!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int i = 0; i < N; ++i) {\n\t\tindeg[i]=0;\n\t}\n\tfor (int u = 0; u < N; ++u) {\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor (int u = 0; u < N; ++u) {\n\t\tif(indeg[u]==0&&!V[u])bfs(u);}\n\tfor (list<int>::iterator it=out.begin();it !=out.end();it++) {\n\t\tcout<<*it<<endl;\n\t}\n}\n\nint main(){\n\tint s,t,M;\n\tcin>>N>>M;\n\tfor (int i = 0; i < N; ++i) {V[i]=false;}\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n]}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n    int V, E;\n    cin >> V >> E;\n    vector<pair<int, int> > edge(E);\n    for (int i = 0; i < E; i++) {\n        cin >> edge[i].first >> edge[i].second;\n    }\n    vector<int> ans;\n    vector<int> state(V, 1);\n//0: edge[i].secondに載っているため設定できない\n//1: 設定できる状態\n//2: すでに設定済みなので除外\n\n    \n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            if (state[i] != 2) state[i] = 1;\n        }\n        for (int i = 0; i < edge.size(); i++) {\n            state[edge[i].second] = 0;\n        }\n        for (int i = 0; i < V; i++) {\n            if (state[i] == 1) {\n                ans.push_back(i);\n                state[i] = 2;\n                for (int j = 0; j < edge.size(); j++) {\n                    if (edge[j].first == i) {\n                        edge[j] = edge.back();\n                        edge.pop_back();\n                        j--;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> tsort(const Graph &g){\n    int n = g.size();\n    vector<int> ord(n), indeg(n);\n    for(auto &es : g) for(auto &e : es) indeg[e.dst]++;\n    queue<int> q;\n    for(int i = 0; i < n; ++i) if (indeg[i] == 0) q.push(i);\n    int k = 0;\n    while(q.size()){\n        int v = q.front(); q.pop();\n        ord[k++] = v;\n        for (auto &e : g[v]) {\n            indeg[e.dst]--;\n            if (indeg[e.dst] == 0) q.push(e.dst);\n        }\n    }\n    return ord;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < n; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<string.h>\n#include<set>\n\nconst int MAXN = 1e4;\n\nint degree[MAXN];\nint V, E;\nstd::vector<int> digrath[MAXN];\n\nvoid init() {\n\tmemset(degree, 0, sizeof(int) * V);\n}\n\nvoid input() {\n\tscanf(\"%d%d\", &V, &E);\n\tinit();\n\tfor (int i = 0; i < E; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tdigrath[s].push_back(t);\n\t\tdegree[t]++;\n\t}\n}\n\nvoid output() {\n\tstd::queue<int> q;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (degree[i] == 0) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (std::vector<int>::iterator it = digrath[u].begin(); it != digrath[u].end(); it++) {\n\t\t\tdegree[*it]--;\n\t\t\tif (degree[*it] == 0) {\n\t\t\t\tq.push(*it);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tinput();\n\toutput();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nvector<int>G[10005];\nint V,E,F[10005]={0};\nqueue<P>Q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint s,e;\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tG[s].push_back(e);\n\t\tF[e]=1;\n\t}\n\tfor(int i=0;i<V;i++)if(!F[i])Q.push(make_pair(i,0));\n\tmemset(F,0,sizeof(F));\n\twhile(!Q.empty())\n\t{\n\t\tP T=Q.front();Q.pop();\n\t\tint s=T.first,t;\n\t\tfor(int i=0;i<G[s].size();i++)\n\t\t{\n\t\t\tt=G[s][i];\n\t\t\tif(F[t]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[t]=F[s]+1;\n\t\t\t\tQ.push(make_pair(i,F[t]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tint t=-1;\n\t\tfor(int i=0;i<V;i++)\n\t\t{\n\t\t\tif(t==-1||F[t]>F[i])\n\t\t\t\tt=i;\n\t\t}\n\t\tprintf(\"%d\\n\",t);\n\t\tF[t]=100000;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\nusing edge_set = unordered_set<int>;\n\nint main() {\n\n    int V, E;\n    cin >> V >> E;\n\n    int count = 0;\n    pair<int, int> order[V];\n    edge_set indeg[V], outdeg[V];\n\n    for (int i = 0; i < V; i++) {\n        order[i].second = i;\n    }\n\n    int s, t;\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        indeg[t].insert(s);\n        outdeg[s].insert(t);\n    }\n\n    queue<int> que;\n\n    for (int i = 0; i < V; i++) {\n        if (indeg[i].empty()) {\n            que.push(i);\n        }\n    }\n\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        for (int v : outdeg[u]) {\n            indeg[v].erase(u);\n            if (indeg[v].empty()) {\n                que.push(v);\n            }\n        }\n        order[u].first = ++count;\n    }\n\n    //count < |V| なら閉路がある\n\n    sort(order, order + V);\n\n    for (int i = 0; i < V; i++) {\n        cout << order[i].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int MAX = 100000;\nconst int INF = 1<<29;\nvector<int> G[MAX];\nlist<int> out;\nint n;\nbool V[MAX];\nint indeg[MAX];\nvoid bfs(int s){\n  queue<int>q;\n  q.push(s);\n  V[s]=true;\n  while(!q.empty()){\n    int u=q.front();q.pop();\n    out.push_back(u);\n    r(i,G[u].size()){\n      int v=G[u][i];\n      indeg[v]--;\n      if(!indeg[v]&&!V[v]){\n        V[v]=true;\n        q.push(v);\n      }\n    }\n  }\n}\nvoid Tsort(){\n  //r(i,n)indeg[i]=0;\n  r(u,n)r(i,G[u].size())indeg[G[u][i]]++;\n  r(u,n)if(!indeg[u]&&!V[u])bfs(u);\n  for(list<int>::iterator it=out.begin();it!=out.end();it++)\n    cout<<*it<<endl;\n}\nint main(){\n  int s,t,m;\n  cin>>n>>m;\n  r(i,n){\n    //V[i]=false;\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  Tsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n\tV[u] = true;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (!V[v]) dfs(v);\n\t}\n\tout.push_front(u);\n}\n\nint main() {\n\tint s, t, M;\n\tcin >> N >> M;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tV[i] = false;\n\t}\n\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!V[i]) dfs(i);\n\t}\n\n\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {\n\t\tcout << *it << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\n\n/* topologicalSort */\n#define topo_SIZE 10000\n\nvector<int> topologicalSort(vector<vector<int> > G,int n=-1){\n    int indeg[topo_SIZE] = {0},u;\n    vector<int> ret,ret2;\n    queue<int> que;\n    \n    if(n==-1) n=(int)G.size();\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        if(indeg[i]==0){\n            que.push(i);\n        }\n    }\n    \n    while(!que.empty()){\n        u = que.front();\n        que.pop();\n        \n        ret.push_back(u);\n        \n        for(int i=0;i<G[u].size();i++){\n            indeg[G[u][i]]--;\n            if(indeg[G[u][i]]==0){\n                que.push(G[u][i]);\n            }\n        }\n    }\n    \n    if(n==(int)ret.size()){\n        return ret;\n    }else{\n        return ret2;\n    }\n}\n\nint main(){\n    int v,e,a,b;\n    vector<int> ans;\n    vector<vector<int> > in(10000);\n    \n    scanf(\"%d%d\",&v,&e);\n    \n    for(int i=0;i<e;i++){\n        scanf(\"%d%d\",&a,&b);\n        \n        in[a].push_back(b);\n    }\n    \n    ans = topologicalSort(in,v);\n    \n    if(ans.size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    \n    for(int i=0;i<ans.size();i++){\n        printf(\"%d\\n\",ans[i]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#define N 10000\nusing namespace std;\n\nlist<int> l;\nbool color[N]={false};\nvector<int> adj[N];\nint n;\n\nvoid topo(int k){\n\tfor(int i=0;i<adj[k].size();i++) topo(adj[k][i]);\n\t// cout<<\"hiking:\"<<k<<endl;\n\tif(!color[k])l.push_front(k);\n\tcolor[k]=true;\n}\n\nint main(void){\n\tint u,v;\n\tint e;\n\tcin>>n>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>u>>v;\n\t\tadj[u].push_back(v);\t// ??£??\\???????????????\n\t}\n\t// for(int i=0;i<n;i++){\n\t\t// cout<<i<<\":\";\n\t\t// for(int j=0;j<adj[i].size();j++){\n\t\t\t// cout<<adj[i][j]<<\" \";\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\tfor(int i=0;i<n;i++){\n\t\tif(!color[i])topo(i);\n\t}\n\tfor(list<int>::iterator it=l.begin();it!=l.end();it++)cout<<*it<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> a[10001];\nvector<int> b;\nlist<int> q;\nbool vis[10001];\nint v,e,x,y;\nvoid dfs(int x){\n\t vis[x]=true;\n\t for (int i=0; i<a[x].size(); i++){\n\t \t if (!vis[a[x][i]])\n\t \t    dfs(a[x][i]);\n\t }\n\t q.push_back(x);\n}\nint main(){\n\tmemset(vis,false,sizeof(vis));\n\tcin>>v>>e;\n\tfor (int i=0; i<e; i++){\n\t\tcin>>x>>y;\n\t\ta[x].push_back(y); \n\t}\n\tfor (int i=0; i<v; i++){\n\t\tif (!vis[i])\n\t\t   dfs(i); \n\t}\n\tfor (list<int>::iterator it=q.begin(); it!=q.end(); it++)\n\t     b.push_back(*it);\n\treverse(b.begin(),b.end());\n\tcout<<b[0];\n\tfor (int i=1; i<b.size(); i++)\n\t    cout<<' '<<b[i];\n\tcout<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\n// Edge {{{\ntemplate <class Weight>\nstruct Edge {\n    size_t from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(size_t from, size_t to, Weight weight = 1) :\n        from(from), to(to), weight(weight)\n    {}\n\n    bool operator<(const Edge &rhs) const {\n        return weight < rhs.weight;\n    }\n\n    bool operator>(const Edge &rhs) const {\n        return weight > rhs.weight;\n    }\n\n    operator size_t() const {\n        return to;\n    }\n};\n// }}}\n\n// Graph {{{\ntemplate <class Weight>\nclass Graph : public vector<vector<Edge<Weight>>> {\n    using graph = vector<vector<Edge<Weight>>>;\n\npublic:\n    Graph() {}\n    Graph(const size_t V) : graph(V) {}\n\n    void connect(size_t from, size_t to, Weight weight = 1) {\n        (*this)[from].emplace_back(from, to, weight);\n    }\n\n    friend ostream& operator<<(ostream &strm, const Graph &G) {\n        for (size_t v = 0; v < G.size(); ++v) {\n            strm << '[' << setw(2) << v << ']';\n            for (const auto &e: G[v]) {\n                strm << ' ' << setw(2) << e.to;\n            }\n            strm << '\\n';\n        }\n        return strm;\n    }\n};\n// }}}\n\n// topologicalSort {{{\ntemplate <class T>\nvector<size_t> topologicalSort(const Graph<T> &G) {\n    const size_t N = G.size();\n    vector<size_t> ord, indeg(N);\n    queue<size_t> que;\n    ord.reserve(N);\n    for (size_t v = 0; v < N; ++v) {\n        for (const auto e: G[v]) {\n            indeg[e.to]++;\n        }\n    }\n    for (size_t v = 0; v < N; ++v) {\n        if (indeg[v] == 0) {\n            que.push(v);\n        }\n    }\n    while (!que.empty()) {\n        const size_t cur = que.front();\n        que.pop();\n        ord.push_back(cur);\n        for (const auto e: G[cur]) {\n            if (--indeg[e.to] == 0) {\n                que.push(e.to);\n            }\n        }\n    }\n    return ord;\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n    var(size_t, V, E);\n    Graph<size_t> G(V);\n    rep(i, 0, E) {\n        var(size_t, s, t);\n        G.connect(s, t);\n    }\n    const auto res = topologicalSort(G);\n    for (const auto e: res) output(e);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define DEBUG(a) \"(\" << #a << \": \" << (a) << \")\"\n\ntemplate<typename T>\nvoid chmin(T &x, T y) { x = min(x, y); }\n\ntemplate<typename T>\nvoid chmax(T &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef tuple<int,int> P;\n\nconst int INF = INT_MAX/2 - 1;\nconst double EPS = 1e-14;\nconst int dx[4] = {0, 1, 0, -1}; // {-1,  0,  1, -1, 1, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0}; // {-1, -1, -1,  0, 0,  1, 1, 1};\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool dfs(const Graph &g, int v, vector<int> &order, vector<bool> &visited, vector<bool> &pushed) {\n  visited[v] = true;\n  for (Edge e : g[v]) {\n    int w = e.dest;\n    if (pushed[w]) continue;\n    if (visited[w]) return false;\n    if (!dfs(g, w, order, visited, pushed)) return false;\n  }\n  order.push_back(v);\n  pushed[v] = true;\n  return true;\n}\n\ntuple<bool,vector<int>> topological_sort(const Graph &g) {\n  vector<int> order;\n  vector<bool> visited(g.size(), false), pushed(g.size(), false);\n  REP(i, g.size()) {\n    if (!pushed[i] && !dfs(g, i, order, visited, pushed))\n      return make_tuple(false, vector<int>());\n  }\n  reverse(ALL(order));\n  return make_tuple(true, order);\n}\ntuple<bool,vector<int>> topological_sort_stack(const Graph &g) {\n  vector<int> order;\n  vector<bool> visited(g.size(), false), marked(g.size(), false);\n  REP(i, g.size()) {\n    if (marked[i]) continue;\n\n    stack<tuple<int,int,int>> jobs; // 0 = visit, 1 = child, 2 = push\n    jobs.push(make_tuple(0, i, -1));\n    while (!jobs.empty()) {\n      auto job = jobs.top(); jobs.pop();\n      int com = get<0>(job), v = get<1>(job), i = get<2>(job);\n      cout <<DEBUG(com) << DEBUG(v) << DEBUG(i) << endl;\n      switch (com) {\n        case 0: // visit\n          visited[v] = true;\n          jobs.push(make_tuple(1, v, 0));\n          break;\n        case 1: // child\n          if (i >= (int)g[v].size()) {\n            jobs.push(make_tuple(2, v, -1));\n          } else if (marked[g[v][i].dest]) {\n            jobs.push(make_tuple(1, v, i + 1));\n          } else if (visited[g[v][i].dest]) {\n            return make_tuple(false, vector<int>());\n          } else {\n            jobs.push(make_tuple(1, v, i + 1));\n            jobs.push(make_tuple(0, g[v][i].dest, -1));\n          }\n          break;\n        case 2: // push\n          order.push_back(v);\n          marked[v] = true;\n          break;\n        default:;\n      }\n    }\n  }\n  reverse(ALL(order));\n  return make_tuple(true, order);\n}\n\n\nint main() {\n  cout << fixed << setprecision(10);\n  int V, E;\n  cin >> V >> E;\n  Graph G(V);\n  REP(i, E) {\n    int s, t;\n    cin >> s >> t;\n    G[s].push_back(Edge(s, t));\n  }\n\n  auto res = topological_sort_stack(G);\n  for (int v : get<1>(res)) {\n    cout << v << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<algorithm>\n#define MAX 100000\nusing namespace std;\n\nvector<int> G[MAX];\nlist<int> ans;\nbool color[MAX];\nint v, e;\n\nvoid dfs(int u){\n    color[u] = true;\n    for(int i = 0; i < G[u].size(); i++){\n        int x = G[u][i];\n        if(!color[x]) dfs(x);\n    }\n    ans.push_front(u);\n}\n\nvoid tSort(){\n    for(int i = 0; i < v; i++){\n        if(!color[i]) dfs(i);\n    }\n}\n\nint main(){\n    int s, t;\n    scanf(\"%d %d\", &v, &e);\n    for( int i = 0; i < v; i++) color[i] = false;\n    for(int i = 0; i < e; i++){\n        scanf(\"%d %d\", &s, &t);\n        G[s].push_back(t);\n    }\n    \n    tSort();\n    std::list<int>::iterator itr;\n    for( itr = ans.begin(); itr != ans.end(); itr++){\n        cout << *itr << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <queue>\n#include <list>\nusing namespace std;\n\n//??\\?????????????????????????§???????\nstruct Edge {\n\tvector<int> in_n, out_n;\n\tvoid set_in(int a) { in_n.emplace_back(a); }\n\tvoid set_out(int a) { out_n.emplace_back(a); }\n};\n\nint main() {\n\t//Wiki:?????????????????????????????¢?????´??????????????????\n\n\tint V, E; cin >> V >> E;\n\tvector<Edge> edge(V + 1);\n\tlist<int> L;    //??????????????????????????????????????????????????????????????????\n\tqueue<int> S;   //??\\???????????????????????????????????????????????????\n\n\t\t\t\t\t//?????????\n\tfor (int i = 0; i < E;i++) {\n\t\tint s, t; cin >> s >> t;\n\t\tedge[s].set_out(t);\n\t\tedge[t].set_in(s);\n\t}\n\n\t//??\\???????????????????????????????????????????????¢?´¢\n\tfor (int i = 0; i < V;i++) {\n\t\tif (edge[i].in_n.size() == 0) { S.push(i); }\n\t}\n\n\twhile (!S.empty()) {\n\t\t//S???????????????n???????????????\n\t\tint n = S.front(); S.pop();\n\t\t//L???n???????????????\n\t\tL.push_back(n);\n\n\t\t/*\n\t\tfor each n ???????????? e ??¨????????????????????? m do\n\t\t??? e ?????°????????????????????????\n\t\tif m ?????????????????\\??????????????£?????????????????° then\n\t\tm ??? S ???????????????\n\t\t*/\n\n\t\tint size = edge[n].out_n.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint m = edge[n].out_n[0];\n\n\t\t\tedge[n].out_n.erase(edge[n].out_n.begin());\n\n\t\t\tfor (int j = 0; j < edge[m].in_n.size();j++) {\n\t\t\t\tif (edge[m].in_n[j] == n) {\n\t\t\t\t\tedge[m].in_n.erase(edge[m].in_n.begin() + j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (edge[m].in_n.size() == 0) {\n\t\t\t\tS.push(m);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int n : L) {\n\t\tcout << n << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nvector< vector<int> > G1, G2;\nint V;\nvector<bool> used;\nvoid init() {\n    G1.clear(); G1.resize(V);\n    G2.clear(); G2.resize(V);\n    used.clear(); used.resize(V);\n}\nvoid addEdge(int from, int to) {\n    G1[from].push_back(to);\n    G2[to].push_back(from);\n}\nvector<int> vs;\nvoid dfs1(int v) {\n    used[v] = true;\n    for (int i = 0; i < G1[v].size(); i++) {\n        if (!used[ G1[v][i] ]) dfs1(G1[v][i]);\n    }\n    vs.push_back(v);\n}\nvoid dfs2(int v, int k, vector<int>& order) {\n    used[v] = true;\n    order[v] = k;\n    for (int i = 0; i < G2[v].size(); i++) {\n        if (!used[ G2[v][i] ]) dfs2(G2[v][i], k, order);\n    }\n}\nint solve(vector<int>& ord) {\n    fill(whole(used), false);\n    vs.clear();\n    for (int v = 0; v < V; v++) {\n        if (!used[v]) dfs1(v);\n    }\n    fill(whole(used), false);\n    int k = 0;\n    ord.clear(); ord.resize(V, -1);\n    for (int i = vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) dfs2(vs[i], k++, ord);\n    }\n    return k;\n}\n\nint main() {\n    int E;\n    scanf(\"%d %d\\n\", &V, &E);\n    init();\n    for (int i = 0; i < E; i++) {\n        int s, t; scanf(\"%d %d\\n\", &s, &t);\n        addEdge(s, t);\n    }\n    vector<int> ord;\n    solve(ord);\n    vector< pair<int, int> > p;\n    for (int i = 0; i < V; i++) {\n        p.push_back(make_pair(ord[i], i));\n    }\n    sort(whole(p));\n    for (int i = 0; i < V; i++) {\n        printf(\"%d\\n\", p[i].second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define COMB(n, k)                                                             \\\n    for(ll bit = (1LL << k) - 1; bit < (1LL << n); bit = next_combination(bit))\n#define PERM2(n, k)                                                            \\\n    COMB(n, k) {                                                               \\\n        vector<int> sel;                                                       \\\n        for(int bitindex = 0; bitindex < n; bitindex++)                        \\\n            if(bit >> bitindex & 1) sel.emplace_back(bitindex);                \\\n        PERM(sel) { Printv(sel); }                                             \\\n    }\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << (head) << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << (head) << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nlong long next_combination(long long sub) {\n    long long x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\n// トポロジカルソートdfs\nint N, M;\nconst int NMAX = 1e5 + 10;\n\nvector<int> G[NMAX];\nbool used[NMAX];\n\nvector<int> v;\n\nvoid dfs(int u) {\n    if(used[u]) return;\n    used[u] = true;\n    for(int i : G[u]) dfs(i);\n    //帰りがけ順で追加\n    v.push_back(u);\n}\n\nvoid tsort() {\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(v.begin(), v.end());\n}\n\nsigned main() {\n    cin >> N >> M;\n    REP(i, M) {\n        LCIN(s, t);\n        G[s].emplace_back(t);\n    }\n    tsort();\n    FOREACH(x, v) cout << x << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nmain(){\n  ios_base::sync_with_stdio(false);\n  int v,e,s,t,lose[10001];\n  vector<int> vec[10001];\n  queue<int> que;\n  cin >> v >> e;\n  for(int i=0;i<e;i++){\n    cin >> s >> t;\n    lose[t]++;\n    vec[s].push_back(t);\n  }\n  for(int i=0;i<v;i++){\n    if(lose[i] == 0) que.push(i);\n  }\n  while(!que.empty()){\n    int point = que.front();\n    que.pop();\n    cout << point << endl;\n    for(int i=0;i<vec[point].size();i++){\n      lose[vec[point][i]]--;\n      if(!lose[vec[point][i]]) que.push(vec[point][i]);\n    }\n  }\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> tsort_Kahn(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<int> indeg(V,0);\n    stack<int>  S;\n\n    // ??¨???????????????????????????????????\\?¬???°????¨????\n    for(auto& u_out_edges : g)\n\tfor(auto& v : u_out_edges)\n\t    indeg[v]++;\n\n    // ??\\?¬???° == 0 ?????????????¨????\n    for(int i=0; i<V; ++i) \n\tif( indeg[i] == 0 )\n\t    S.push(i);\n\n    vector<int> ans;\n    while( S.size() > 0 ) {\n\tint u = S.top(); S.pop();\n\tans.emplace_back(u);\n\tfor(auto& v : g[u]) {\n\t    indeg[v]--;\n\t    if( indeg[v] == 0 ) S.push(v);\n\t}\n    }\n    return ans;\n}\n\nvoid visit(const vector<vector<int>>& g, int u, vector<bool>&used, vector<int>& ans) {\n\n    if( used[u] == false ) {\n\tused[u] = true;\n\tfor(auto& v : g[u]) {\n\t    visit(g, v, used, ans);\n\t}\n\tans.emplace_back(u);\n    }\n}\n\nvector<int> tsort_Tarjan(const vector<vector<int>>& g) {\n    const int V = g.size();\n\n    vector<bool> used(V,false);\n    vector<int> ans;\n    for (int u=0; u<V; ++u) {\n\tvisit(g, u, used, ans);\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n\n\n\nint main () {\n\n    int V,E;\n    cin >> V >> E;\n\n    vector<vector<int>> g(V);\n    for (int i=0; i<E; ++i) {\n\tint s,t;\n\tcin >> s >> t;\n\tg[s].emplace_back(t);\n    }\n\n    vector<int> ans = tsort_Tarjan(g);\n    for(auto& e : ans) {\n\tcout << e << endl;\n    }\n\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX = 100000;\nstatic const int INFTY = 1 << 29;\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];//入度\n\nvoid bfs(int s)\n{\n\tqueue<int> q;\n\tq.push(s);\n\tV[s] = true;\n\twhile (!q.empty()){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\t--indeg[v];\n\t\t\tif (indeg[v] == 0 && !V[v]){\n\t\t\t\tV[v] = true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int i = 0; i < N; ++i)indeg[i] = 0;\n\tfor (int u = 0; u < N; ++u){\n\t\tfor (int i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor (int u = 0; u < N; ++u)if (indeg[u] == 0 && !V[u])bfs(u);\n\tfor (auto it(out.begin()); it != out.end(); ++it)cout << *it << endl;\n}\n\nint main()\n{\n\tint s, t, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; ++i)V[i] = false;\n\tfor (int i = 0; i < M; ++i)\n\t{\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct TopologicalSort{\n  int n;\n  vector<set<int> > G;\n  vector<bool> used;\n  vector<int> indeg,p;\n  \n  TopologicalSort(){}\n  TopologicalSort(int sz):n(sz),G(n),used(n),indeg(n),p(0){}\n\n  void add_edge(int s,int t){\n    G[s].insert(t);\n  }\n  \n  void bfs(int s){\n    queue<int> q;\n    q.push(s);\n    used[s]=1;\n    while(!q.empty()){\n      int v=q.front();q.pop();\n      p.push_back(v);\n      for(int u:G[v]){\n\tindeg[u]--;\n\tif(indeg[u]==0&&!used[u]){\n\t  used[u]=1;\n\t  q.push(u);\n\t}\n      }\n    }\n  }\n  \n  vector<int>  build(){\n    fill(used.begin(),used.end(),0);\n    fill(indeg.begin(),indeg.end(),0);\n    \n    for(int i=0;i<n;i++)\n      for(int v:G[i]) indeg[v]++;\n    \n    for(int i=0;i<n;i++)\n      if(indeg[i]==0&&!used[i]) bfs(i);\n    \n    return p;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  TopologicalSort ts(n);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    ts.add_edge(s,t);\n  }\n  auto p=ts.build();\n  for(int i:p) cout<<i<<endl;\n  return 0;\n}\n\n/*\nverified on 2017/12/09\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "// BFSを用いたトポロジカルソート\n// 計算量 O(V + E) \n// reference Programming Contest Challenge Book Second Edition\n// verify https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/1/GRL_4_B\n\n#include <bits/stdc++.h>\n\nusing  ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\nconstexpr ll kINF = 1152921504606846976;//2^60\nconstexpr double kEPS = 1e-6;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define rep(i,n) REP(i,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep(i,n) RREP(i,n)\n#define mp make_pair\n#define fi first\n#define sc second\n\n// --!!!!ここからコピペする!!!!--\n\ntemplate<typename T> struct Edge {\n  int to;\n  Edge(int to_) : to(to_) {}\n};\n\ntemplate<typename T,template <typename ELEM> class EDGE> struct AdListGraph {\n  vector<vector<EDGE<T>>> G;\n\n  vector<bool> used;\n  vector<int> deg;\n  int V;//0,...,|V|-1\n\n  AdListGraph (int V_) {\n    Init(V_);\n  }\n\n  void Init(int V_) {\n    V = V_;\n\n    G.clear();\n    G.resize(V);\n  }\n\n  // https://faithandbrave.hateblo.jp/entry/20080310/1205149207\n  template <typename FROM, class... Args>\n  void AddEdge(FROM from, Args&&... arg) {\n    G[from].emplace_back(arg...);\n  }\n\n  template<typename ID_TYPE>\n  bool TopologicalSort (vector<ID_TYPE>& sorted) { // 成功ならtrue 失敗(DAG出ない)ならfalseを返す\n    used.clear();\n    used.resize(V, false);\n    deg.clear();\n    deg.resize(V, 0);\n    sorted.clear();\n\n    for (const auto& v : G) \n      for (const auto& e : v)\n        deg[e.to]++;\n\n    queue<int> que;\n\n    rep (i, V) if (deg[i] == 0) {used[i] = true; que.push(i);}\n\n\n    while(!que.empty()) {\n      int i = que.front();\n      que.pop();\n      sorted.emplace_back(i);\n\n      for (auto& e: G[i]) {\n        deg[e.to]--;\n        if (!used[e.to] && deg[e.to] == 0) {\n          used[e.to] = true;\n          que.push(e.to);\n        }\n      }\n    }\n\n    return !((int)sorted.size() == V);\n  }\n\n};\n\nusing ll = long long;\n\nint main() {\n  ll V,E;\n  cin >> V >> E;\n  AdListGraph<ll, Edge> G(V);\n  rep(i,E) {\n    ll s,t;\n    cin >> s >> t;\n    G.AddEdge(s,t);\n  }\n\n  vector<int> ans;\n\n  G.TopologicalSort(ans);\n\n  for (auto v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define INT(x) int x; scanf(\"%d\",&x)\n#define LL(x) ll x; scanf(\"%lld\",&x)\n#define INPUT(x) cin >> x\n#define REP1(x,n) for(int x = 0; x < n; x++)\n#define REP2(x,s,e) for(int x = s; x <= e; x++)\n#define RREP1(x,n) for(int x = n-1; x >= 0; x--)\n#define RREP2(x,s,e) for(int x = s; x >= e; x--)\n#define BR printf(\"\\n\")\n#define INF_INT 2147483647\n#define INF_LL 9223372036854775807\n\ntypedef long long ll;\n\nclass vertex{\npublic:\n    bool visit;\n    int id;\n    int count;\n    vector<int> toList;\n    \n    vertex(int _id){\n        visit = 0;\n        id = _id;\n        count = 0;\n    }\n};\n\nvector<vertex> glaph;\nqueue<int> q;\n\nint bfs_count;\n\nvoid BFS(){\n    bfs_count += 1;\n    //cout << endl << \"bfs_count: \" << bfs_count << \" queue_count: \" << q.size() << \" end: \";\n    if (q.size() == 0) return;\n    int i = q.front();\n    glaph[i].visit = 1;\n    q.pop();\n    \n    //?????????????????????\n    REP1(k,glaph[i].toList.size()){\n        int j = glaph[i].toList[k];\n        if (!glaph[j].visit){\n            glaph[j].count--;\n            if (glaph[j].count == 0) {\n                cout << j << endl;\n                q.push(j);\n            }\n        }\n    }\n    \n    BFS();\n}\n\nvoid disp(int v){\n    cout << \"glaph:\" << endl;\n    REP1(i, v){\n        cout << i << \": \";\n        REP1(j, glaph[i].toList.size()){\n            cout << ' ' << glaph[i].toList[j];\n        }\n        cout << endl;\n        cout << \"in count: \" << glaph[i].count << endl;\n    }\n}\n\nint main(){\n    INT(V);INT(E);\n    REP1(i,V){\n        vertex v(i);\n        glaph.push_back(v);\n    }\n    \n    REP1(i,E){\n        INT(s);INT(t);\n        glaph[s].toList.push_back(t);\n        glaph[t].count++;\n    }\n    \n    //disp(V);\n    \n    int start;\n    REP1(i,V){\n        if(glaph[i].count == 0){\n            q.push(i);\n            //cout << \"end: \" << i << endl;\n            cout << i << endl;\n        }\n    }\n    \n    q.push(start);\n    bfs_count = 0;\n    BFS();\n    \n    cout << glaph[2].count;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <math.h>\n#include <stack>\n#include <deque>\n\n#define mp                  make_pair\n#define F                   first\n#define S                   second\n#define pb                  push_back\n#define FOR(i,j,n)          for(int i=j;i<n;i++)\n#define F0R(i,j,n)          for(int i=j;i<=n;i++)\n#define RFOR(i,j,n)         for(int i=n-1;i>=j;i--)\n#define RF0R(i,j,n)         for(int i=n;i>=j;i--)\n#define FOREACH(x,v)        for(auto x:v)\n#define ITFOR(it,v)         for(__typeof(v.begin()) it =v.begin();it!=v.end();++it)\n#define __in_arr__(a,j,n)   FOR(i,j,n)cin >> a[i];\n#define __out_arr__(a,j,n)  FOR(i,j,n)cout << a[i];\n#define LOG                 cout << \"[ !\" << __LINE__ << \"L ] \" << endl;\n#define PLOG(x)             cout << \"[ !\" << __LINE__ << \"L ] \" <<x<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vl;\n\nconst int MAXN = 1e4 + 6.66;\nconst int MAXM = 1e6 + 6.66;\nvi g[MAXN];\nint d[MAXN];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);cout.tie(NULL);\n  int n,m;\n  cin >> n >> m;\n  FOR(i,0,m) {\n    int x,y;cin >> x >> y;\n    d[x]++;\n    g[y].pb(x);\n  }\n//  F0R(i,1,n) {\n//    sort(g[i].begin(),g[i].end());\n//    reverse(g[i].begin(),g[i].end());\n//  }\n  queue<int> q;\n  stack<int> ans;\n  RFOR(i,0,n) if( d[i]==0 ) q.push(i);\n  while(q.size()) {\n    ans.push(q.front());\n    int i = q.front();q.pop();\n    for(auto x : g[i])\n    {\n      d[x]--;\n      if(!d[x]) q.push(x);\n    }\n  }\n  if(ans.size()!=n) cout << \"Sandro fails.\" << endl;\n  else\n    while(ans.size()) cout << ans.top() << \"\\n\",ans.pop();\n  cout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) x.begin(),x.end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n\nvector<vector<int>> G;\n\nvector<bool> seen;\nvector<int> finished;\n\nvoid dfs(int v) {\n    seen[v] = true;\n    for (auto nv : G[v]) {\n        if (seen[nv]) continue;\n        dfs(nv);\n    }\n    finished.emplace_back(v);\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    G.resize(N);\n    rep(i,M) {\n        int s,t; cin >> s >> t;\n        G[s].emplace_back(t);\n    }\n\n    seen.assign(N, false);\n\n    rep(i,N) {\n        if (seen[i]) continue;\n        dfs(i);\n    }\n\n    reverse(all(finished));\n\n    rep(i,N) cout << finished[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define REP(i,n) for(ll i=0;i<n;++i)\nint MAX = 10000;\nvector<int> sorted,indegree(MAX,0);\nvector<vector<int>> graph(MAX);\nvector<bool> used(MAX);\nint n;//nodeの総数\nvoid dfs(int now){\n  used[now] = true;\n  REP(i,(ll)graph[now].size()){\n    if(!used[graph[now][i]]) dfs(graph[now][i]);\n  }\n  sorted.emplace_back(now);\n}\nvoid tsort(){\n  REP(i,n){\n    if(!used[i]) dfs(i);\n  }\n  reverse(sorted.begin(),sorted.end());\n}\nint main(){\n    int v,e;\n    cin >> v >> e;\n    n = v;\n    REP(i,e){\n        int s,t;\n        cin >> s >> t;\n        graph[s].emplace_back(t);\n    }\n    tsort();\n    REP(i,v) cout << sorted[i] << endl;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "/*BFS 的做法 */\n/*\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<list>\n#define N 10002  //憨批\nusing namespace std;\nvector<int> G[N+1];\nlist<int> ans;\nbool visited[N+1];\nint indeg[N+1];\nint n;\n\nvoid bfs(int node){\n    queue<int> q;\n    q.push(node);\n    visited[node]=true;\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        ans.push_back(u);\n        for(int i=0;i<G[u].size();i++){\n            int v=G[u][i];\n            indeg[v]--;\n            if(indeg[v]==0 && visited[v]==false){ //这里缺少了一个条件\n                q.push(v);\n                visited[v]=true;\n            }\n        }\n    }\n}\n\nvoid topologicalSort(){\n    for(int i=0;i<n;i++){\n        if(indeg[i]==0 && visited[i]==false){\n            bfs(i);\n        }\n    }\n    for(list<int>::iterator it=ans.begin();it!=ans.end();it++){\n        cout<<*it<<endl;\n    }\n}\n\n\nint main(){\n    int q;\n    cin>>n>>q;\n    for(int i=0;i<n;i++){\n        //G[i].clear();\n        visited[i]=false;\n        indeg[i]=0;\n    }\n    for(int i=0;i<q;i++){\n        int s,t;\n        cin>>s>>t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    topologicalSort();\n\n    return 0;\n}\n*/\n\n\n/* DFS 的做法 */\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<list>\n#define N 10002  //憨批\nusing namespace std;\nvector<int> G[N+1];\nlist<int> ans;\nbool visited[N+1];\nint indeg[N+1];\nint n;\n\nvoid dfs(int node){\n    visited[node]=true;\n    for(int i=0;i<G[node].size();i++){\n        int v=G[node][i];\n        if(visited[v]==false){\n            //visited[v]=true;\n            dfs(v);\n        }\n    }\n    ans.push_front(node);\n}\n\nint main(){\n    int q;\n    cin>>n>>q;\n    for(int i=0;i<n;i++){\n        //G[i].clear();\n        visited[i]=false;\n        indeg[i]=0;\n    }\n    for(int i=0;i<q;i++){\n        int s,t;\n        cin>>s>>t;\n        G[s].push_back(t);\n        indeg[t]++;\n    }\n\n    for(int i=0;i<n;i++){\n        if(visited[i]==false){\n            dfs(i);\n        }\n    }\n    for(list<int>::iterator it=ans.begin();it!=ans.end();it++){\n        cout<<*it<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int num = 10000;\nvector<int> ne[num];\nint pre[num], c[num], n;\nqueue<int> ans, q;\ninline void bfs(int a) {\n\tq.push(a);\n\tc[a] = 1;\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tans.push(x);\n\t\tq.pop();\n\t\tfor (int j = 0; j < ne[x].size(); j++) {\n\t\t\tint k = ne[x][j];\n\t\t\tpre[k]--;\n\t\t\tif (pre[k] == 0) {\n\t\t\t\tq.push(k); c[k] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\ninline void tp() {\n\tfor (int i = 0; i < n; i++)\n\t\tif (c[i] == 0 && pre[i] == 0) bfs(i);\n}\nint main() {\n\tint p, s, t;\n\tcin >> n >> p;\n\tfor (int i = 0; i < n; i++) pre[i] = 0;\n\tfor (int i = 0; i < p; i++) {\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tne[s].push_back(t);\n\t}\n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < ne[i].size(); j++) pre[ne[i][j]]++;\n\tfor (int i = 0; i < n; i++) c[i] = 0;\n\ttp();\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", ans.front());\n\t\tans.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\nint V,cmp[MAX];\nvector<int> G[MAX],rG[MAX],vs;\nbool used[MAX];\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(used[G[v][i]]==0) DFS(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rDFS(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++){\n        if(used[rG[v][i]]==0) rDFS(rG[v][i],k);\n    }\n}\n\nint scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(used[v]==0) DFS(v);\n    }\n    \n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(used[vs[i]]==0) rDFS(vs[i],k++);\n    }\n    return k;\n}\n\nint main(){\n\n    int E;cin>>V>>E;\n    for(int i=0;i<E;i++){\n        int a,b;cin>>a>>b;\n        add_edge(a,b);\n    }\n    \n    scc();\n    \n    for(int i=vs.size()-1;i>=0;i--){\n        cout<<vs[i]<<endl;\n    }\n    \n    \n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\n\nvector<int> g[10005];\nint v, e;\nint gt[10005] = { 0 };\nvector<int>res;\n\nvoid tsort(int s) {\n\tqueue<int>que;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint now = que.front();\n\t\tque.pop();\n\t\tres.pb(now);\n\t\tgt[now] = -1;\n\t\tfor (int u = 0; u < g[now].size(); u++) {\n\t\t\tint to = g[now][u];\n\t\t\tgt[to]--;\n\t\t\tif (gt[to] == 0) {\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin >> v >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tg[s].pb(t);\n\t\tgt[t]++;\n\t}\n\tfor (int i = 0; i < v; i++) {\n\t\tif (gt[i] == 0) tsort(i);\n\t}\n\tfor (int i = 0; i < v; i++) {\n\t\tout(res[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int V,E,cnt[10000];\n  vector<int> G[10000],ans;\n  scanf(\"%d %d\",&V,&E);\n  fill(cnt,cnt+V,0);\n  for(int i=0;i<E;i++){\n    int s,t;\n    scanf(\"%d %d\",&s,&t);\n    G[s].push_back(t);\n    cnt[t]++;\n  }\n  queue<int> q;\n  for(int i=0;i<V;i++){\n    if(cnt[i]==0) q.push(i);\n  }\n  while(!q.empty()){\n    int v = q.front(); q.pop();\n    ans.push_back(v);\n    for(int i=0;i<G[v].size();i++){\n      cnt[G[v][i]]--;\n      if(cnt[G[v][i]]==0) q.push(G[v][i]);\n    }\n  }\n  for(int i=0;i<V;i++) printf(\"%d\\n\",ans[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define pb push_back\n#define eb emplace_back\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 50;\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nusing namespace std;\n\nvector<vector<int>>g;\nvector<bool>visited;\nvector<int>tp;\n\nvoid dfs(int v){\n\tvisited[v]=true;\n\tfor(auto x:g[v]){\n\t\tif(visited[x])continue;\n\t\tdfs(x);\n\t}\n\ttp.pb(v);\n}\nvoid solve(){\n\tint v,e;\n\tcin>>v>>e;\n\tg.resize(v);\n\tvisited.resize(v,false);\n\trep(i,e){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tg[s].pb(t);\n\t}\n\trep(i,v){\n\t\tif(visited[i])continue;\n\t\tdfs(i);\n\t}\n\treverse(tp.begin(),tp.end());//逆順にするのを忘れない\n\tfor(auto x:tp){\n\t\tcout<<x<<endl;\n\t}\n\treturn ;\n}\n\nsigned main(){\n\tstd::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SCC {\n    void dfs(int v) {\n        if (used[v]) return;\n        used[v] = 1;\n        for (auto &u : g[v]) dfs(u);\n        ord.push_back(v);\n    }\n\n    void rdfs(int v) {\n        if (~cmp[v]) return;\n        cmp[v] = sz;\n        for (auto &u : rg[v]) rdfs(u);\n    }\n\npublic:\n    int sz;\n    vector<vector<int>> g, rg, dag, group;\n    vector<int> cmp, ord, used;\n\n    SCC (int n) : g(n), rg(n), cmp(n, -1), used(n, 0) {}\n    SCC (vector<vector<int>> &g) : g(g), rg(g.size()), cmp(g.size(), -1), used(g.size(), 0) {\n        for (int v = 0; v < (int)g.size(); ++v) for (int u : g[v]) rg[u].push_back(v);\n        build();\n    }\n\n    void add_edge(int s, int t) {\n        g[s].push_back(t);\n        rg[t].push_back(s);\n    }\n\n    void build() {\n        for (int i = 0; i < (int)g.size(); ++i) dfs(i);\n        reverse(ord.begin(), ord.end());\n        sz = 0;\n        for (int i : ord) if (!~cmp[i]) rdfs(i), ++sz;\n        dag.resize(sz); group.resize(sz);\n        for (int i = 0; i < (int)g.size(); ++i) {\n            for (int j : g[i]) {\n                int x = cmp[i], y = cmp[j];\n                if (x != y) dag[x].emplace_back(y);\n            }\n            group[cmp[i]].push_back(i);\n        }\n    }\n\n    // number of connected components\n    int size() { return sz; }\n\n    // the number of the component to which element x belongs\n    int operator[](int x) { return cmp[x]; }\n\n    bool same(int x, int y) { return cmp[x] == cmp[y]; }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    SCC scc(V);\n    for (int i = 0; i < E; ++i) {\n        int s, t;\n        cin >> s >> t;\n        scc.add_edge(s, t);\n    }\n    scc.build();\n    for (int i = 0; i < scc.ord.size(); ++i) {\n        cout << scc.ord[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1e4+10;\nvector<int> G[N];\nbool used[N];\nstack<int> order;\n\nvoid add(int s,int t)\n{\n    G[s].push_back(t);\n}\n\nvoid dfs(int v)\n{\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++)\n    {\n        int t=G[v][i];\n        if(!used[t])\n        {\n            dfs(t);\n        }\n    }\n    order.push(v);\n}\n\nint main()\n{\n    int v,e;\n    cin>>v>>e;\n\n    for(int i=0;i<e;i++)\n    {\n        int s,t;\n        cin>>s>>t;\n        add(s,t);\n    }\n\n    for(int i=0;i<v;i++)\n    {\n        if(!used[i])\n        {\n            dfs(i);\n        }\n    }\n\n    while(!order.empty())\n    {\n        cout<<order.top()<<endl;\n        order.pop();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//---------------------------------------------------------------\n// ------ graph ------ //\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) { }\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // pqが降順のため\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\nusing Edges = vector<Edge>;\nstruct Graph {\n    vector<Edges> adj;\n    Graph(int n) : adj(n) { }\n    int size() { return adj.size(); }\n    Edges operator [] (int v) { return adj[v]; }\n    void add_edge(int a, int b, Weight w = 1) { // graph\n        adj[a].emplace_back(a, b, w);\n        adj[b].emplace_back(b, a, w);\n    }\n    void add_arc(int a, int b, Weight w = 1) {  // digraph\n        adj[a].emplace_back(a, b, w);\n    }\n};\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n// ------ Topological Sort (Kahn) ------ //\nvector<int> tsort(Graph &g) {\n    int n = g.size(), k = 0;\n    vector<int> ord(n), in(n);\n    for (int i = 0; i < n; i++) for (Edge &e : g[i]) in[e.dst]++;\n    queue<int> q;\n    for (int i = 0; i < n; i++) if (in[i] == 0) q.push(i);\n    while (!q.empty()) {\n        int v = q.front(); q.pop();\n        ord[k++] = v;\n        for (Edge &e : g[v]) if (--in[e.dst] == 0) q.push(e.dst);\n    }\n    return *max_element(in.begin(), in.end()) == 0 ? ord : vector<int>();\n}\n//---------------------------------------------------------------\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int s, t; cin >> s >> t;\n        g.add_arc(s, t);\n    }\n    vector<int> ord = tsort(g);\n    for (int i = 0; i < V; i++) cout << ord[i] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nclass SCCD {\npublic:\n\tstack<int> post;\n\tvb used;\n\n\tvoid dfs(int pos, int par, const Graph &G) {\n\t\tused[pos] = true;\n\t\trep(i, G[pos].size()) {\n\t\t\tint to = G[pos][i].to;\n\t\t\tif (used[to])continue;\n\t\t\tdfs(to, pos, G);\n\t\t}\n\t\tpost.push(pos);\n\t}\n\n\tvoid dfsrev(int pos, int par, const Graph &rev, vi &group) {\n\t\tused[pos] = true;\n\t\tgroup.push_back(pos);\n\t\trep(i, rev[pos].size()) {\n\t\t\tint to = rev[pos][i].to;\n\t\t\tif (used[to])continue;\n\t\t\tdfsrev(to, pos, rev, group);\n\t\t}\n\t}\n\n\tvoid SCC(Graph G, vvi &scc, vi &n2g) {\n\t\tint N = G.size();\n\t\tGraph rev(N);\n\t\trep(i, N) {\n\t\t\trep(j, G[i].size()) {\n\t\t\t\tEdge e = G[i][j];\n\t\t\t\trev[e.to].push_back(Edge{ e.to,e.from,1 });\n\t\t\t}\n\t\t}\n\n\t\tused = vb(N, false);\n\t\trep(i, N) {\n\t\t\tif (!used[i])dfs(i, -1, G);\n\t\t}\n\n\t\tfill(all(used), false);\n\t\twhile (!post.empty()) {\n\t\t\tint pos = post.top();\n\t\t\tpost.pop();\n\t\t\tif (used[pos])continue;\n\t\t\tvi group;\n\t\t\tdfsrev(pos, -1, rev, group);\n\t\t\tscc.push_back(group);\n\t\t}\n\n\t\trep(i, scc.size()) {\n\t\t\trep(j, scc[i].size()) {\n\t\t\t\tn2g[scc[i][j]] = i;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tGraph G(V);\n\t\n\trep(i, E) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tG[s].push_back(Edge{ s,t,1 });\n\t}\n\n\tvvi scc;\n\tvi n2g(V);\n\n\tSCCD sccd;\n\tsccd.SCC(G, scc, n2g);\n\n\trep(i, V) {\n\t\tcout << scc[i][0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Topological sorted graph\nstruct TopologicalGraph\n{\n  vector< vector<int> > graph;\n  vector<int> order;\n  TopologicalGraph(int sz):graph(sz){}\n  TopologicalGraph(vector< vector<int> > graph):graph(graph){}\n  void add_edge(int from, int to)\n  {\n    graph[from].push_back(to);\n  }\n  bool visit(int u, vector<int>& color)\n  {\n    color[u] = 1;\n    for(int v : graph[u]) {\n      if(color[v] == 2) continue;\n      if(color[v] == 1) return false;\n      if(!visit(v, color)) return false;\n    }\n    order.push_back(u);\n    color[u] = 2;\n    return true;\n  }\n  bool sort()\n  {\n    vector<int> color((int)graph.size(), 0);\n    for(int i = 0; i < (int)color.size(); i++) {\n      if(color[i] == 0 && !visit(i, color)) return false;\n    }\n    reverse(order.begin(), order.end());\n    return true;\n  }\n  void print_order()\n  {\n    for(int i = 0; i < (int)order.size(); i++) cout << order[i] << endl;\n  }\n};\n\nint main()\n{\n  int V, E; cin >> V >> E;\n  TopologicalGraph graph(V);\n  while(E--) {\n    int s, t; cin >> s >> t;\n    graph.add_edge(s, t);\n  }\n  graph.sort();\n  graph.print_order();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n//#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n\n    std::vector<std::vector<int>> edges(V, std::vector<int>());\n    std::vector<int> ins(V, 0);\n    std::vector<bool> memo(V, false);\n\n    while(E--){\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n        ++ins[t];\n    }\n\n    std::vector<int> ans;\n    ans.reserve(V);\n\n    for(int i = 0; i < V; ++i) {\n        if(!memo[i] && ins[i] == 0) {\n\n            std::queue<int> que;\n            que.push(i);\n            while(!que.empty()) {\n                int v = que.front();\n                que.pop();\n                ans.push_back(v);\n                memo[v] = true;\n\n                for(auto val: edges[v]) {\n                    --ins[val];\n                    if(!memo[val] && ins[val] == 0) {\n                        que.push(val);\n                    }\n                }\n\n            }\n\n        }\n    }\n\n    for(int i = 0; i < ans.size(); ++i) {\n        std::cout << ans[i];\n        if(i < ans.size() - 1) std::cout << \" \";\n    }\n\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nstruct topological_sort{\n    const int V;\n    vector<vector<int>> board;\n    vector<int> into,list;\n    vector<bool> visited;\n    topological_sort(int v)\n        :V(v)\n        ,into(v,0)\n        ,visited(v,false)\n        {\n            board.assign(v,vector<int>());\n        }\n    // 入力\n    void add(int from,int to){\n        board[from].push_back(to);\n        into[to]++;\n    }\n    // トポロジカルソート\n    void build(){\n        for(int i=0;i<V;i++){\n            if(into[i]==0&&!visited[i]){\n                queue<int> q;\n                q.push(i);\n                while(q.size()){\n                    int from=q.front(); q.pop();\n                    list.push_back(from);\n                    visited[from]=true;\n                    for(int to:board[from]){\n                        into[to]--;\n                        if(into[to]==0&&!visited[to]){\n                            q.push(to);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // 取得\n    vector<int> get(){\n        return list;\n    }\n    // debug\n    // void debug(){\n    //     for(int x=1;x<(int)board.size()-1;x++){\n    //         for(int y=1;y<(int)board[0].size()-1;y++){\n    //             cout<<board[x][y]<<\" \";\n    //         }\n    //         cout<<endl;\n    //     }\n    // }\n};\n// verify\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\nint main(){\n    int V,E; cin>>V>>E;\n    topological_sort graph(V);\n    while(E--){\n        int s,t; cin>>s>>t;\n        graph.add(s,t);\n    }\n    graph.build();\n    vector<int> l=graph.get();\n    rep(i,V) cout<<l[i]<<(i==V-1?\"\\n\":\" \");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif // LOCAL_\n// #define dump() fprintf(stderr, \"#%s.%d\\n\", __func__, __LINE__);\n#define dumpl(x1) fprintf(stderr, \"#%s.%d (%s) = (%ld)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpll(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%ld, %ld)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define dumplll(x1, x2, x3) fprintf(stderr, \"#%s.%d (%s, %s, %s) = (%ld, %ld, %ld)\\n\", __func__, __LINE__, #x1, #x2, #x3, x1, x2, x3);\n#define dumpd(x1) fprintf(stderr, \"#%s.%d (%s) = (%lf)\\n\", __func__, __LINE__, #x1, x1);\n#define dumpdd(x1, x2) fprintf(stderr, \"#%s.%d (%s, %s) = (%lf, %lf)\\n\", __func__, __LINE__, #x1, #x2, x1, x2);\n#define loop for(;;)\n\ntemplate<typename T> void scan1(T& x) { fprintf(stderr, \"unknown type\\n\"); }\ntemplate<> void scan1(long& x) { if( scanf(\"%ld\", &x) < 0 ) exit(0); }\nvoid scan() {}\ntemplate<typename Head, typename... Tail>\nvoid scan(Head& x, Tail&... xs) {\n  scan1(x); scan(xs...);\n}\n\ntemplate<typename W>\nstruct N008 {\n   typedef std::vector<long> LI;\n   typedef std::vector<W>    LW;\n   long n, e;\n   const LI &ss, &ds;\n   const LW &ws;\n   std::vector<LI> fi;\n   std::vector<LI> ri;\n   N008(long n_, const LI& ss_, const LI& ds_, const LW& ws_)\n      : n(n_), e(ss_.size()), ss(ss_), ds(ds_), ws(ws_) {\n      ri.resize(n+1);\n      fi.resize(n+1);\n      for(long i = 0; i < e; ++i) {\n         fi[ss[i]].push_back(i);\n         ri[ds[i]].push_back(i);\n      }\n   }\n};\n\ntemplate<typename W>\nstruct N010 {\n   typedef std::vector<long> LI;\n   const N008<W>& g;\n   LI xs, ys;\n   long id;\n   N010(const N008<W>& g_) : g(g_), xs(g.n+1, -1), id(0) {\n      for(long i = 0; i < g.n + 1; ++i) dfs(i);\n      std::reverse(ys.begin(), ys.end());\n   }\n   void dfs(long t) {\n      if( xs[t] != -1 ) return;\n      for(long i : g.fi[t]) {\n         long to = g.ds[i];\n         dfs(to);\n      }\n      if( xs[t] == -1 ) xs[t] = id, id += 1, ys.push_back(t);\n   }\n};\n\nstruct Solver {\n   Solver() { fprintf(stderr, \"--------Solver begin--------\\n\"); }\n   ~Solver() { fprintf(stderr, \"--------Solver end--------\\n\"); }\n   void solve() {\n      long v, e;\n      scan(v, e);\n      std::vector<long> ss(e), ds(e), ws(e);\n      for(long i = 0; i < e; ++i) {\n         scan(ss[i], ds[i]);\n      }\n      N008<long> g(v, ss, ds, ws);\n      N010<long> topsort(g);\n      for(long y : topsort.ys) {\n         if( y < v ) printf(\"%ld\\n\", y);\n      }\n   }\n};\n\nint main() {\n  loop std::unique_ptr<Solver>(new Solver())->solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// トポソ\n// O(V + E)\n// [入力] 重みなし有効グラフ\n// [出力] ソートされた頂点列(0-indexed) DAG じゃ無い場合は空列を返す\nvector<int> toposort(vector<vector<int>> &g){\n    int n = (int)g.size();\n    vector<int> d(n, 0);     // 入次数\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < (int)g[i].size(); j++){\n            d[g[i][j]]++;\n        }\n    }\n     \n    // 入次数が 0 の頂点を queue に入れる\n    queue<int> que;\n    for(int i = 0; i < n; i++){\n        if(d[i] == 0) que.push(i);\n    }\n \n    vector<int> ret;\n    while(!que.empty()){\n        int cur = que.front();\n        que.pop();\n        ret.push_back(cur);\n \n        for(int i = 0; i < (int)g[cur].size(); i++){\n            int nxt = g[cur][i];\n            d[nxt]--;\n            if(d[nxt] == 0) que.push(nxt);\n        }\n    }\n \n    // DAG じゃなかったら、頂点列が不足しているはず\n    if(ret.size() == n) return ret;\n    else return vector<int>();\n \n}\n\nsigned main(){\n    \n    int n, m; cin >> n >> m;\n    vector<vector<int>> g(n);\n    for(int i = 0; i < m; i++){\n        int a, b; cin >> a >> b;\n        g[a].push_back(b);\n    }\n\n    auto ret = toposort(g);\n    for(auto x : ret) cout << x << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define ITR(v,c) for(auto v=begin(c);v!=end(c);v++)\n#define FOR(v,a,n) for(int v=a;v<(int)(n);v++)\n#define FORE(x,arr) for(auto &x:arr)\n#define REP(v,n) FOR(v,0,n)\n#define ALL(c) begin(c),end(c)\nconst int DX[4]={0,1,0,-1}, DY[4]={-1,0,1,0};\nconst int INF = 1e9;\ntemplate<class T,class U>ostream&operator<<(ostream &os,const pair<T,U> &p){\n    os<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream &os,const vector<T> &v){\n    ITR(i,v)os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\n//-----------------------------------------------------------\n\nstruct node {\n    int i;\n    int from;           // ??\\???????????°\n    vector<node*> to;   // ??\\?¶????????????????\n};\nvector<node*> topological_sort(vector<node> &g) {\n    vector<node*> sorted;\n    queue<node*> q;\n    FORE(nd,g) if(nd.from==0) q.push(&nd);\n    while(!q.empty()) {\n        node* v=q.front(); q.pop();\n        sorted.push_back(v);\n        FORE(u,v->to) {\n            (u->from)--;\n            if((u->from)==0) {\n                q.push(u);\n            }\n        }\n    }\n    return sorted;\n}\n\nint main(int argc, char const *argv[]) {\n    int V,E;\n    cin>>V>>E;\n    vector<node> g(V);\n    REP(i,V) g[i].i=i;\n\n    REP(i,E) {\n        int a,b;\n        cin>>a>>b;\n        g[a].to.push_back(&g[b]);\n        g[b].from++;\n    }\n\n    vector<node*> ans = topological_sort(g);\n    REP(i,V) {\n        cout<<ans[i]->i<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <cctype>\n#include <fstream>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, n) for(int i=0;i<(int)n;i++)\n#define ddd ifstream in(\"Text.txt\");cin.rdbuf(in.rdbuf());\n\nint V;\nvector<int> G[100010];//元のグラフ\nint indegree[100010];//頂点の入次数\nvector<int> sortnum;//トポロジカルソートした時の番号\n\nvoid pre_tsort(int from, int to) {\n    G[from].push_back(to);\n    indegree[to]++;//入次数\n}\n\nvoid tsort() {\n    queue<int> que;//入次数が0の頂点\n    rep(i, V) if (indegree[i] == 0)que.push(i);//入次数が最初から０\n    //トポロジカルソートは入次数が0の頂点から行っていく。\n    while (!que.empty()) {\n        int v_from = que.front();//入次数0の頂点に現在いる\n        que.pop();\n        sortnum.push_back(v_from);\n        for (auto& v_to : G[v_from]) {\n            //行き先の頂点の入次数を-1\n            indegree[v_to]--;\n            //入次数が0になれば次の処理対象に\n            if (indegree[v_to] == 0)que.push(v_to);\n        }\n    }\n}\n//Vを再定義しないように\n\nint main(){\n    int E;\n    cin >> V >> E;\n    rep(i, E) {\n        int s, t;\n        cin >> s >> t;\n        pre_tsort(s,t);\n    }\n\n    tsort();\n\n    rep(i,V)cout << sortnum[i] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 10000\n\nclass Node;\nvoid dfs(int N);\n\nclass Node\n{\npublic:\n\tbool IsDone = false;\n\tvector<int> E;\n};\n\nlist<int> ans;\nNode nodes[MAX];\n\nvoid dfs(int N)\n{\n\tnodes[N].IsDone = true;\n\tfor (int i = 0; i<nodes[N].E.size(); i++)\n\t{\n\t\tif (nodes[nodes[N].E[i]].IsDone == false)\n\t\t{\n\t\t\tdfs(nodes[N].E[i]);\n\t\t}\n\t}\n\tans.push_front(N);\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tREP(i, E)\n\t{\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tnodes[s].E.push_back(t);\n\t}\n\tREP(i, V)if (nodes[i].IsDone == false)dfs(i);\n\tfor (auto var : ans)cout << var << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\n\ntypedef map<int,vector<int> > Graph;\n\nbool visit(Graph &g, int v, vector<int> &order, map<int,int> &color) {\n  color[v] = 1;\n  FOR(e, g[v]) {\n    if (color[*e/*->dst*/] == 2) continue;\n    if (color[*e/*->dst*/] == 1) return false;\n    if (!visit(g, *e/*->dst*/, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(Graph &g, vector<int> &order) {\n  //int n = g.size();\n  map<int,int> color;//(n);\n  FOR(u, g) if (!color[u->first] && !visit(g, u->first, order, color))\n    return false;\n  reverse(ALL(order));\n  return true;\n}\n\nint main(){\n\tint i,V,E,s,t;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d\",&V,&E);\n\t\tGraph g;//(V);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(t);\n\t\tfor(;!g.empty();){\n\t\t\tvector<int> order;\n\t\t\ttopologicalSort(g,order);\n\t\t\tfor(i=0;i<order.size();i++){\n\t\t\t\tprintf(\"%d\\n\",order[i]);\n\t\t\t\tg.erase(order[i]);\n\t\t\t}\n\t\t}\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <stack>\n#include <limits>\n#include <array>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <numeric>\n//#include <tuple>\n\nconstexpr long long mod = static_cast<long long>(1e9 + 7);\n\nvoid dfs(int i, const std::vector<std::vector<int>>& edges, std::vector<bool>& memo, std::vector<int>& ans) {\n    memo[i] = true;\n    for(auto v: edges[i]) {\n        if(!memo[v])dfs(v, edges, memo, ans);\n    }\n    ans.push_back(i);\n}\n\nint main() {\n    int V, E;\n    std::cin >> V >> E;\n\n    std::vector<std::vector<int>> edges(V, std::vector<int>());\n    std::vector<bool> memo(V, false);\n\n    while(E--){\n        int s, t;\n        std::cin >> s >> t;\n        edges[s].push_back(t);\n    }\n\n    std::vector<int> ans;\n    ans.reserve(V);\n\n    for(int i = 0; i < V; ++i) {\n        if(!memo[i]) {\n\n            dfs(i, edges, memo, ans);\n\n        }\n    }\n\n    for(auto itr = rbegin(ans); itr != rend(ans); ++itr) {\n        std::cout << *itr;\n        if(itr + 1 != rend(ans)) std::cout << \" \";\n    }\n\n    std::cout << std::flush;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nstruct TopologicalSort {\nprivate:\n    int V;\n    int E;\n    vector<vector<int>> table;\npublic:\n    TopologicalSort(int v, int e) {\n        V = v;\n        E = e;\n        table.resize(v);\n    }\n\n    void add_edge(int from, int to) {\n        table[from].push_back(to);\n    }\n\n    vector<int> sort() {\n        vector<int> sorted_nodes;\n        stack<int> st;\n\n        vector<int> indegree(V, 0);\n        for (int i = 0; i < V; i++) {\n            for (int to : table[i]) {\n                indegree[to]++;\n            }\n        }\n\n        for (int i = 0; i < V; i++) {\n            if (indegree[i] == 0) st.push(i);\n        }\n\n        while (st.size() > 0) {\n            int popped = st.top();\n            st.pop();\n\n            sorted_nodes.push_back(popped);\n\n            for (int to : table[popped]) {\n                indegree[to]--;\n                if (indegree[to] == 0) st.push(to);\n            }\n        }\n\n        return move(sorted_nodes);\n    }\n};\n\nsigned main() {\n    int V, E;\n    cin >> V >> E;\n\n    TopologicalSort ts(V, E);\n\n    for (int i = 0; i < E; i++) {\n        int s, t;\n        cin >> s >> t;\n        ts.add_edge(s, t);\n    }\n\n    vector<int> sorted_nodes = ts.sort();\n    for (int node: sorted_nodes) cout << node << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef vector<ld> vd;\ntypedef vector<ll> vll;\ntypedef vector<string> vstr;\ntypedef vector<vll> vvll;\ntypedef vector<vvll> vvvll;\ntypedef vector<pair<ll, ll>> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i, a, b) for (ll i = (ll)a; i < (ll)b; i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); ++i)\n#define FI first\n#define SE second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define TS to_string\n#define NP next_permutation\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(x) (ll) x.size()\n#define endl \"\\n\"\n\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"Yes\" << endl;}\nvoid no(){ cout << \"No\" << endl;}\n\n//-----------------------------------------\nvll seen;\nvvll graph;\nvll indeg;\nvll ret;\n\n\nvoid init(ll n){\n  graph.resize(n);\n  indeg.resize(n,0);\n  seen.resize(n,0);\n  ret.resize(0);\n}\n\nvoid bfs(ll s){\n  queue<ll> que;\n  que.push(s);\n  seen[s] = 1;\n\n  while(!que.empty()){\n    ll u = que.front(); que.pop();\n    ret.push_back(u);\n    for(ll i=0;i<graph[u].size();i++){\n      ll v = graph[u][i];\n      indeg[v]--;\n      if(indeg[v] == 0 && seen[v] == 0){\n        seen[v] = 1;\n        que.push(v);\n      }\n    }\n  }\n}\n\nvoid T_sort(ll n){\n  for(ll i=0;i<n;i++){\n    for(ll j=0;j<graph[i].size();j++){\n      ll v = graph[i][j];\n      indeg[v]++;\n    }\n  }\n  for(ll i=0;i<n;i++){\n    if(indeg[i] == 0 && seen[i] == 0){\n      bfs(i);\n    }\n  }\n}\n//-----------------------------------------\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  ll n;\n  cin >> n;\n  init(n);\n  ll m;\n  cin >> m;\n  REP(i,m){\n    ll s, t;\n    cin >> s >> t;\n    graph[s].push_back(t);\n  }\n\n  T_sort(n);\n\n  REP(i,SZ(ret)) cout << ret[i] <<endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\nusing Weight = int;\nusing Capacity = int;\nstruct Edge {\n    int src, dst; Weight weight;\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvector<int> tsort(const Graph &g){\n    int n = g.size();\n    vector<int> res, vis(n);\n    function<bool(int)> dfs = [&](int v){\n        vis[v] = true;\n        for(auto &e : g[v]) if(!vis[e.dst] && !dfs(e.dst)) return false;\n        res.push_back(v);\n        return true;\n    };\n    for(int i = 0; i < n; ++i) if(!vis[i]) if(!dfs(i)) return {};\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int n,m;\n    cin >> n >> m;\n    Graph g(n);\n    for(int i = 0; i < m; i++){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(s,t,0);\n    }\n    vector<int> ord = tsort(g);\n    for(int i = 0; i < n; ++i){\n        cout << ord[i] << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nvector<vec> E;\nbool used[10000];\nvec vs;\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i=0;i<E[v].size();i++){\n        if(!used[E[v][i]]) dfs(E[v][i]);\n    }\n    vs.push_back(v);\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n\n    E.assign(n, vec());\n    for(int i=0;i<m;i++){\n        int s, t;\n        cin >> s >> t;\n        E[s].push_back(t);\n    }\n\n    fill(used, used+n, false);\n    vs.clear();\n    for(int i=0;i<n;i++){\n        if(!used[i]) dfs(i);\n    }\n\n    for(int i=0;i<n;i++){\n        cout << vs[n-1-i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=100000;\nstatic const int INFTY=(1<<29);\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\nint indeg[MAX];\n\nvoid bfs(int s){\n\tqueue<int> q;\n\tq.push(s);\n\tV[s]=true;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\t//??\\?¬???°???0??????????????????????????\\?????????\n\t\tout.push_back(u);\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v=G[u][i];\n\t\t\t//???????¶?????????¨??????????????????\n\t\t\tindeg[v]--;\n\t\t\tif(indeg[v]==0&&!V[v]){\n\t\t\t\tV[v]=true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tsort(){\n\tfor (int i = 0; i < N; ++i) {\n\t\tindeg[i]=0;\n\t}\n\tfor (int u = 0; u < N; ++u) {\n\t\tfor (int i = 0; i < G[u].size(); ++i) {\n\t\t\tint v=G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\tfor (int u = 0; u < N; ++u) {\n\t\tif(indeg[u]==0&&!V[u])bfs(u);}\n\tfor (list<int>::iterator it=out.begin();it !=out.end();it++) {\n\t\tcout<<*it<<endl;\n\t}\n}\n\nint main(){\n\tint s,t,M;\n\tcin>>N>>M;\n\tfor (int i = 0; i < N; ++i) {V[i]=false;}\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin>>s>>t;\n\t\tG[s].push_back(t);\n\t}\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 10005\nusing namespace std;\n\nqueue<int> S;// ??\\???????????????????????¨???????????????\nvector<int> in[MAX_N];// ??\\??????\nvector<int> out[MAX_N];// ?????????\nvector<int> G[MAX_N];// ??\\?????????????????????????????\\???\n\nvoid init(int V){// ?????°??????????????°\n  for(int i=0;i<V;i++)in[i].clear();\n  for(int i=0;i<V;i++){\n    out[i]=G[i];\n    for(int j=0;j<G[i].size();j++)\n      in[G[i][j]].push_back(i);\n  }\n  for(int i=0;i<V;i++)\n    if(!in[i].size())S.push(i);\n}\n\nvector<int> Topological_Sort(int V){\n  vector<int> res;\n  while(!S.empty()){\n    int pos=S.front(); S.pop();\n    res.push_back(pos);\n    for(int i=0;i<out[pos].size();i++){\n      int nx=out[pos][i];\n      if(in[nx].size()==1)S.push(nx);\n      for(int j=0;j<in[nx].size();j++)\n\tif(pos==in[nx][j]){\n\t  in[nx].erase(in[nx].begin()+j);\n\t  break;\n\t}\n      out[pos].erase(out[pos].begin()+i);\n      i--;\n    }\n  }\n  for(int i=0;i<V;i++)\n    if(in[i].size()||out[i].size())\n      res.clear();\n  return res;\n}\n\nint main(){\n  int v,e,s,t;\n  cin>>v>>e;\n  for(int i=0;i<e;i++){\n    cin>>s>>t;\n    G[s].push_back(t);\n  }\n  init(v);\n  vector<int> ans=Topological_Sort(v);\n  for(int i=0;i<ans.size();i++)\n    cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct TopologicalSort{\n  int n;\n  vector<set<int> > G;\n  vector<int> indeg,V,p;\n  TopologicalSort(){}\n  TopologicalSort(int n):n(n){init();}\n  \n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    indeg.clear();\n    V.clear();\n    p.clear();\n    G.resize(n);\n    indeg.resize(n);\n    V.resize(n);\n  }\n\n  void add_edge(int s,int t){\n    G[s].insert(t);\n  }\n  \n  void bfs(int s){\n    queue<int> q;\n    q.push(s);\n    V[s]=1;\n    while(!q.empty()){\n      int u=q.front();q.pop();\n      p.push_back(u);\n      for(int v:G[u]){\n\tindeg[v]--;\n\tif(indeg[v]==0&&!V[v]){\n\t  V[v]=1;\n\t  q.push(v);\n\t}\n      }\n    }\n  }\n  \n  void tsort(){\n    fill(V.begin(),V.end(),0);\n    fill(indeg.begin(),indeg.end(),0);\n    for(int u=0;u<n;u++)\n      for(int v:G[u])\n\tindeg[v]++;\n    for(int u=0;u<n;u++)\n      if(indeg[u]==0&&!V[u]) bfs(u);\n    for(int i=0;i<n;i++)\n      cout<<p[i]<<endl;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int n,e;\n  cin>>n>>e;\n  TopologicalSort ts(n);\n  for(int i=0;i<e;i++){\n    int s,t;\n    cin>>s>>t;\n    ts.add_edge(s,t);\n  }\n  ts.tsort();\n  return 0;\n}\n\n/*\nverified on 2017/06/29\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int v,e,s,t,a[10001]={};\n  vector<int> vec[10001];\n  cin >> v >> e;\n  for(int i=0;i<e;i++){\n    cin >> s >> t;\n    vec[s].push_back(t);\n    a[t]++;\n  }\n  stack<int> st;\n  for(int i=0;i<v;i++){\n    if(a[i] == 0) st.push(i);\n  }\n  while(!st.empty()){\n    cout << st.top() << endl;\n    int p = st.top();\n    st.pop();\n    for(int i=0;i<vec[p].size();i++){\n      a[ vec[p][i] ]--;\n      if(a[ vec[p][i] ] == 0) st.push( vec[p][i] );\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=2000000000;\n\n/* topologicalSort */\n#define topo_SIZE 1000\n\nvector<int> topologicalSort(vector<vector<int> > G,int n=-1){\n    int indeg[topo_SIZE] = {0},u;\n    vector<int> ret;\n    queue<int> que;\n    \n    if(n==-1) n=(int)G.size();\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<G[i].size();j++){\n            indeg[G[i][j]]++;\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        if(indeg[i]==0){\n            que.push(i);\n        }\n    }\n    \n    while(!que.empty()){\n        u = que.front();\n        que.pop();\n        \n        ret.push_back(u);\n        \n        for(int i=0;i<G[u].size();i++){\n            indeg[G[u][i]]--;\n            if(indeg[G[u][i]]==0){\n                que.push(G[u][i]);\n            }\n        }\n    }\n    \n    if(n==(int)ret.size()){\n        return ret;\n    }else{\n        return vector<int>();\n    }\n}\n\nint main(){\n    int v,e,a,b;\n    vector<int> ans;\n    vector<vector<int> > in(10000);\n    \n    scanf(\"%d%d\",&v,&e);\n    \n    for(int i=0;i<e;i++){\n        scanf(\"%d%d\",&a,&b);\n        \n        in[a].push_back(b);\n    }\n    \n    ans = topologicalSort(in,v);\n    \n    if(ans.size()==0){\n        puts(\"-1\");\n        return 0;\n    }\n    \n    for(int i=0;i<ans.size();i++){\n        printf(\"%d\\n\",ans[i]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxx=10010;\n\nvector<int> A[maxx],ans;\nqueue<int> task;\nint f[maxx];\nbool flag[maxx];\nint v,e;\n\nint main (){\n\tint x,y;\n\tbool xx=false;\n\tcin>>v>>e;\n\tfor(int i=0;i<maxx;i++){\n\t\tf[i]=0;\n\t\tflag[i]=false;\n\t}\n\twhile(e--){\n\t\tcin>>x>>y;\n\t\tA[x].push_back(y);\n\t\tf[y]++;\n\t}\n\twhile(1){\n\t\txx=false;\n\t\tfor(int i=0;i<v;i++) {\n\t\t\tif(f[i]==0&&flag[i]==false) {\n\t\t\t\txx=true;\n\t\t\t\ttask.push(i);\n\t\t\t}\n\t\t}\n\t\tif(xx==false) break;\n\t\twhile(task.empty()==0){\n\t\t\tx=task.front();\n\t\t\tflag[x]=true;\n\t\t\tans.push_back(x);\n\t\t\tfor(int k=0;k<A[x].size();k++){\n\t\t\t\tf[A[x][k]]--;\n\t\t\t}\n\t\t\ttask.pop();\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<endl;\n\t}\n\treturn 0;\n\t\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define UNIQUE(c) sort(ALL(c)), c.erase(unique(ALL(c)), c.end())\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nstruct StronglyConnectedComponents {\n  int V;\n  std::vector<std::vector<int>> G, rG;\n  std::vector<int> vs, cmp;\n  std::vector<bool> used;\n\n  StronglyConnectedComponents(int V) : V(V) {\n    used.assign(V, false);\n    G.resize(V), rG.resize(V);\n    cmp.resize(V);\n  }\n\n  void add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n\n  void dfs(int v) {\n    used[v] = true;\n    for (int c : G[v])\n      if (not used[c]) dfs(c);\n    vs.push_back(v);\n  }\n\n  void rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for (int c : rG[v])\n      if (not used[c]) rdfs(c, k);\n  }\n\n  int run() {\n    fill(used.begin(), used.end(), false);\n    vs.clear();\n    for (int v = 0; v < V; v++)\n      if (!used[v]) dfs(v);\n    fill(used.begin(), used.end(), false);\n    int k = 0;\n    for (int i = vs.size() - 1; i >= 0; i--)\n      if (!used[vs[i]]) rdfs(vs[i], k++);\n    return k;\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  int V, E; cin >> V >> E;\n  StronglyConnectedComponents scc(V);\n  REP(i, E) {\n    int s, t; cin >> s >> t;\n    scc.add_edge(s, t);\n  }\n  scc.run();\n  vector<int> order(V);\n  REP(i, V) order[scc.cmp[i]] = i;\n  REP(i, V) cout << order[i] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cmath>\n#include <list>\n\nconst int MOD = 1e9 + 7;\nconst int MAX = 100000;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing ll = long long int;\nusing namespace std;\n\nvector<int> graph[MAX];\nlist<int> out;\nbool visited[MAX];\nint N, M, cnt = 0;\n\nvoid dfs(int u)\n{\n    visited[u] = true;\n    for (int i = 0; i < graph[u].size(); i++)\n    {\n        int v = graph[u][i];\n        if (!visited[v])\n            dfs(v);\n    }\n\n    out.push_front(u);\n}\n\nint main()\n{\n    cin >> N >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n    }\n\n    for(int i = 0; i < N; i++)\n        visited[i] = false;\n\n    for (int i = 0; i < N; i++)\n        if (!visited[i])\n            dfs(i);\n\n    for(auto x : out)\n        cout << x << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\n\nconst long long MOD = 1000000007;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nvector<vec> E;\nbool used[10000];\nvec vs;\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i=0;i<E[v].size();i++){\n        if(!used[E[v][i]]) dfs(E[v][i]);\n    }\n    vs.push_back(v);\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n\n    E.assign(n, vec());\n    for(int i=0;i<m;i++){\n        int s, t;\n        cin >> s >> t;\n        E[s].push_back(t);\n    }\n\n    fill(used, used+n, false);\n    vs.clear();\n    for(int i=0;i<n;i++){\n        if(!used[i]) dfs(i);\n    }\n\n    for(int i=0;i<n;i++){\n        cout << vs[i] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list> \nusing namespace std;\nstatic const int MAX = 100000;\n\nvector<int> G[MAX];\nlist<int> out;\nbool V[MAX];\nint N;\n\nvoid dfs(int u) {\n    V[u] = true;\n    for(int i = 0; i < G[u].size(); i++) {\n    \tint v = G[u][i];\n    \tif(!V[v]) dfs(v);\n    }\n    list.push_front(u);\n}\n\n\nint main() {\n\tint s, t, M;\n\t\n\tcin >> N >> M;\n\t\n\tfor(int i = 0; i < N; i++) V[i] = false;\n\n    for(int i = 0; i < M; i++) {\n    \tcin >> s >> t;\n    \tG[s].push_back(t);\n    }\n    \n    for(int i = 0; i < N; i++) {\n    \tif(!V[i]) dfs(i);\n    }\n    \n    for(list<int> ::iterator it = out.begin(); it != out.end(); it++) {\n    \tcout << *it << endl;\n    }\n    \n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define llINF (long long) 9223372036854775807\n#define loINF (long) 2147483647\n#define shINF (short) 32767\n#define SORT(c) sort((c).begin(),(c).end())\n\nusing namespace std;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\n\n// グラフのdfs\nVI sorted_ver;\nVI used;\nVVI edge;\n\nlong dfs(long node){\n\tif (used[node] == 1) return (-1);\n\tif (used[node] == 2) return 0;\n\tused[node] = 1;\n\tREP(i,edge[node].size()) {\n\t\tif(dfs(edge[node][i]) == (-1)) return (-1);\n\t}\n\tused[node] = 2;\n\tsorted_ver.push_back(node);\n\treturn 0;\n}\n\nint main(void){\n\tlong V,E;\n\tcin >> V >> E;\n\tsorted_ver = VI(0);\n\tused = VI(V,0);\n\tedge = VVI(V,VI(0));\n\n\tREP(i,E){\n\t\tlong s,t;\n\t\tcin >> s >> t;\n\t\tedge[s].push_back(t);\n\t}\n\n\tREP(i,V){\n\t\tif (used[i] != 2) {\n\t\t\tif (dfs(i) == (-1)) {\n\t\t\t\tcout << \"CYCLE EXIST\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#ifdef DEBUG\n\t\tdump2d_arr(edge);\n\t\tdump1d_arr(sorted_ver);\n\t#endif\n\tREP(i,sorted_ver.size()) cout << sorted_ver[i] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing graph = vector<vector<int>>;\n\n\nvoid dfs(int v, const graph& G, vector<int>& res, vector<int>& used) {\n\tused[v] = 1;\n\tfor (auto to : G[v]) if (used[to] == 0) {\n\t\tdfs(to, G, res, used);\n\t}\n\tres.push_back(v);\n}\n\nvector<int> topo_sort(const graph& G) {\n\tint V = G.size();\n\tvector<int> ide(V);\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (auto to : G[i]) {\n\t\t\tide[to]++;\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<int> used(V);\n\tfor (int i = V - 1; i >= 0; i--) {\n\t\tif (ide[i] == 0) {\n\t\t\tdfs(i, G, res, used);\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nint main()\n{\n\tint V, E;\n\tcin >> V >> E;\n\tgraph G(V);\n\tfor (int i = 0, s, t; i < E; i++) {\n\t\tcin >> s >> t;\n\t\tG[s].push_back(t);\n\t}\n\tauto res = topo_sort(G);\n\tfor (int i = 0; i < V; i++) {\n\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define maxn 10000\nvector<int> G[maxn+10],ans;\nqueue<int> q;\nint biao[maxn+10];\nint color[maxn+10];\nvoid bfs(int s)\n{\n    q.push(s);\n    color[s]=true;\n    while(!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        ans.push_back(u);\n        for (int i=0;i<G[u].size();i++)\n        {\n            int v=G[u][i];\n            biao[v]--;\n            if(!color[v]&&biao[v]==0)\n            {\n                color[v]=true;\n                q.push(v);\n            }\n        }\n    }\n}\nint main()\n{\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    int x,y;\n    for (int i=0;i<v;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        G[x].push_back(y);\n    }\n    for(int i=0;i<u;i++)\n    {\n        for (int j=0;j<G[i].size();j++)\n            biao[G[i][j]]++;\n    }\n    for (int i=0;i<u;i++)\n    {\n        if(biao[i]==0&&!color[i])\n            bfs(i);\n    }\n    for (int i=0;i<ans.size();i++)\n        printf(\"%d\\n\",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<cstring>\nusing namespace std;\nconst int MAXN=10010,MAXM=100010;\nint n,m;\nint to[MAXM],head[MAXN],nex[MAXM],top;\nint sum[MAXN],dfn[MAXN],top1,hash[MAXN];\nstack<int> s;\nvoid add(int x,int y)\n{\n\tnex[x]=head[x];\n\thead[x]=top;\n\tto[top++]=y;\n\tsum[y]++;\n}\n\nvoid input()\n{\n\tmemset(nex,-1,sizeof(nex));\n\tmemset(head,-1,sizeof(head));\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t}\n}\n\nvoid tuopu()\n{\n\tfor(int i=0;i<n;i++)\n\t    if(!sum[i]) {s.push(i);dfn[top1++]=i;hash[i]=1;}\n\twhile(!s.empty())\n\t{\n\t\tint tmp=s.top();\n\t\ts.pop();\n\t\tint u=head[tmp];\n\t\twhile(u!=-1)\n\t\t{\n\t\t\tint tt=to[u];\n\t\t\tu=nex[u];\n\t\t\tif(hash[tt]) continue;\n\t\t\tsum[tt]--;\n\t\t\tif(sum[tt]==0) {s.push(tt);hash[tt]=1;dfn[top1++]=tt;}\n\t\t}\n\t}\n}\n\nvoid xxj()\n{\n\ttuopu();\n}\n\nvoid output()\n{\n\tfor(int i=0;i<top1;i++)\n\t    cout<<dfn[i]<<'\\n';\n}\n\nint main()\n{\n\tinput();\n\txxj();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define outl(x) cout<< (x) << '\\n'\nusing namespace std;\nusing let = const int;\n\nint V, E;\nbool vis[10005];\nvector <int> G[10005];\nvector <int> out;\n\nvoid bfs(let s, int *indeg)\n{\n   queue <int> que; que.emplace(s);\n   while (!que.empty()) {\n      let u = que.front(); que.pop();\n      out.emplace_back(u);\n      for(let x : G[u]) if( --indeg[x] == 0 && !vis[x]++ ) que.emplace(x);\n   }\n}\n\nvoid topologial_sort()\n{\n   static int indeg[10005] = {};\n   rep(i, V)\n      for(let x: G[i]) ++indeg[x];\n   rep(i, V)\n      if (indeg[i] == 0 && !vis[i]++) bfs(i, indeg);\n\n   for_each(out.cbegin(), out.cend(), [](let x) { outl( x ); });\n}\n\nsigned main()\n{\n   cin.tie(0), ios::sync_with_stdio(false);\n   cin >> V >> E;\n\n   while(E--) {\n      int s, t;\n      cin >> s >> t;\n      G[s].emplace_back(t);\n   }\n\n   topologial_sort();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, N) for (int i = 0; i < (int)N; i++)\n\nclass DAG {\n  vector<bool> visited;\n\n  void dfs(int u, vector<vector<int>> &G) {\n    if(visited[u]) return;\n    visited[u] = true;\n    for(int v: G[u]) dfs(v, G);\n    topologicalSorted.push_back(u);\n  }\n\npublic:\n  vector<int> topologicalSorted;\n  bool valid;\n\n  DAG(vector<vector<int>> G) {\n    int V = G.size();\n    visited.resize(V, false);\n\n    for(int i = 0; i < V; i++) dfs(i, G);\n\n    reverse(topologicalSorted.begin(), topologicalSorted.end());\n\n    valid = static_cast<int>(topologicalSorted.size()) == V;\n  }\n};\n\nint main () {\n  int V, E;\n  cin >> V >> E;\n\n  vector<vector<int>> adjacentList(V, vector<int>());\n\n  REP(i,E) {\n    int s, t;\n    cin >> s >> t;\n    adjacentList[s].push_back(t);\n  }\n\n  DAG dag(adjacentList);\n  for(auto u: dag.topologicalSorted) {\n    cout << u << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> G[10010];\nvector<int> L;\nint visited[10010];\n\nvoid dfs(int v)\n{\n    if (visited[v]) return;\n    visited[v]=true;\n    for(auto& u: G[v]) dfs(u);\n    L.push_back(v);\n}\n\nint main()\n{\n    int V, E; cin>>V>>E;\n    for(int i=0; i<E; ++i) {\n        int s, t; cin>>s>>t;\n        G[s].push_back(t);\n    }\n\n    for(int i=0; i<V; ++i) {\n        if (visited[i]) continue;\n        dfs(i);\n    }\n\n    for(int i=V-1; i>=0; --i) cout<<L[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector <int> vi;\ntypedef list <int> li;\n\nvi x[100001];\nint ind[100001];\nbool isvisited[100001];\nli y;\n\nvoid bfs(int a)\n{\n\tqueue <int> qqq;\n\tqqq.push(a);\n\tisvisited[a] = true;\n\twhile(!qqq.empty())\n\t{\n\t\tint p = qqq.front();\n\t\tqqq.pop();\n\t\ty.push_back(p);\n\t\tfor(int i = 0;i < x[p].size();i ++)\n\t\t{\n\t\t\tint xx = x[p][i];\n\t\t\tind[xx] --;\n\t\t\tif(!isvisited[xx] && ind[xx] == 0)\n\t\t\t{\n\t\t\t\tisvisited[xx] = true;\n\t\t\t\tqqq.push(xx);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topo (int v)\n{\n\tfor(int i = 0;i < v;i ++)\n\t\tfor(int j = 0;j < x[i].size();j ++)\n\t\t\tind[x[i][j]] ++;\n\tfor(int i = 0;i < v;i ++)\n\t\tif(!ind[i] && !isvisited[i])\n\t\t\tbfs(i);\n\tfor(list <int> :: iterator it = y.begin();it != y.end();it ++)\n\t{\n\t\tcout << * it << endl;\n\t}\n\t//cout << endl;\n}\n\nint main()\n{\n\tint v,e;\n\tint a,b;\n\tscanf(\"%d %d\",&v,&e);\n\tfor(int i = 1;i <= e;i ++)\n\t{\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tx[a].push_back(b);\n\t}\n\ttopo (v);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX = 10010;\n\nint g[MAX][MAX];\n\nvector<int> topological_sort(int n)\n{\n\tdeque<int> q;\n\tunordered_map<int, int> m;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint d = 0;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (g[j][i])\n\t\t\t\td++;\n\t\t}\n\n\t\tm[i] = d;\n\n\t\tif (!d)\n\t\t\tq.push_back(i);\n\t}\n\n\tvector<int> vs;\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop_front();\n\n\t\tvs.push_back(v);\n\n\t\tvector<int> adj;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (g[v][i]) {\n\t\t\t\tm[i]--;\n\t\t\t\tif (!m[i])\n\t\t\t\t\tq.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((int)vs.size() != n)\n\t\tthrow \"cycle detected!\";\n\n\treturn vs;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, m, x, y;\n\n\tcin >> n >> m;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tg[i][j] = 0;\n\t}\t\t\n\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x >> y;\n\t\tg[x][y] = 1;\n\t}\t\t\n\n\tauto vs = topological_sort(n);\n\n\tfor (const auto& v : vs)\n\t\tcout << v << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing ll = long long;\n\ntemplate <class T>\nusing vec = std::vector<T>;\n\ntemplate <class T>\nconstexpr T nil = static_cast<T>(-1);\n\ntemplate <class T>\nconstexpr T inf = std::numeric_limits<T>::max() / 2;\n\n\nconstexpr int NIL = nil<int>;\n\nvoid solve()\n{\n    using namespace std;\n\n    int n, m;\n    cin >> n >> m;\n\n    vec<vec<int>> edges(n, vec<int>(n, NIL));\n    vec<int> degIn(n, 0);\n\n    for (int i = 0, from, to; i < m; ++i)\n    {\n        cin >> from >> to;\n        edges[from][to] = 1;\n        ++degIn[to];\n    }\n\n    vec<int> sortedV;\n    queue<int> q;\n\n    for (int i = 0; i < n; ++i)\n        if (degIn[i] == 0)\n            q.push(i);\n    \n    while (!q.empty())\n    {\n        auto v = q.front(); q.pop();\n\n        sortedV.push_back(v);\n\n        for (int i = 0; i < n; ++i)\n            if (edges[v][i] != NIL)\n                if (--degIn[i] == 0)\n                    q.push(i);\n    }\n\n    for (int v : sortedV)\n        cout << v << endl;\n\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>; //to, cost\nusing WeightedGraph = vector<vector <P>>; //to cost\nusing UnweightedGraph = vector<vector <int>>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n//https://www.creativ.xyz/dump-cpp-652/\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n \n// vector\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n \n#define DUMPOUT cerr\n \nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n\nvector <int> toposort(WeightedGraph g){\n    int n = g.size();\n    stack<int> st;\n    vector <int> topo(n);\n    int x = 0;\n    vector <int> deg(n); \n    rep(i,n){\n        rep(j,g[i].size()){\n            deg[g[i][j].F]++;\n        }\n    }\n    rep(i,n) {if(!deg[i]) st.push(i);}\n    while(!st.empty()){\n        int v = st.top(); st.pop();\n        topo[x++] = v;\n        for(int i=0;i<g[v].size();i++){\n            int nv = g[v][i].F;\n            deg[nv]--;\n            if(!deg[nv]) st.push(nv);\n        }\n    }\n    return topo;\n}\n    \nsigned main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    itn n,m; cin>>n>>m;\n    WeightedGraph g(n);\n    rep(i,m){\n      int a,b; cin>>a>>b; \n      g[a].push_back({b,0});\n    }\n    auto ans = toposort(g);\n    for(auto i: ans) cout<<i<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//广度优先搜索拓扑排序\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n\nint n;//点数 \n\nvector<int> *Graph; //图的邻接表 \nbool *color;//标记顶点是否访问结束\nint *indeg; //顶点的入度\n\nvector<int> ans;\n\n\nvoid bfs(int u) { //广度优先搜索实现的拓扑排序 \n\tqueue<int> Q;\n\tQ.push(u);\n\tcolor[u] = true;\n\twhile (!Q.empty()) {\n\t\tu = Q.front();\n\t\tans.push_back(u);\n\t\tQ.pop();\n\t\tfor (int i=0;i<Graph[u].size();i++) {\n\t\t\tint v = Graph[u][i];\n\t\t\tindeg[v]--;\n\t\t\tif (!color[v] && indeg[v] == 0) {\n\t\t\t\tQ.push(v);\n\t\t\t\tcolor[v] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid topSort() { //拓扑排序 \n\tfor (int i=0;i<n;i++) {\n\t\t//入度为0的点即为起点 \n\t\tif (!color[i] && indeg[i] == 0) {\n\t\t\tbfs(i);\n\t\t}\n\t}\n}\n\nint main() {\n\tint e;\n\tcin >> n >> e;\n\tGraph = new vector<int>[n];\n\tcolor = new bool[n];\n\tindeg = new int[n];\n\t\n\tfor (int i=0;i<n;i++) {\n\t\tcolor[i] = false;\n\t\tindeg[i] = 0;\n\t}\n\t\n\tfor (int i=0;i<e;i++) {\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\tGraph[s].push_back(t);\n\t\tindeg[t]++; //t的入度加一 \n\t}\n\ttopSort();\n\t\n\tfor (int i=0;i<ans.size();i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\n#include <math.h>\n#include <string.h>\n#include <iomanip>\n#include <numeric>\n#include <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <functional>\n#include <limits>\n#include <cassert>\n\nusing namespace std;\n\n/* template */\n\nusing ll = long long;\n\nvoid debug_out() { std::cout << std::endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cout << H << \" \";\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cout << \"debug: \"; debug_out(__VA_ARGS__)\n#else\n#define debug(...) \n#endif\n\n#define rep(i, a, n) for (int i = (int)(a); i < (int)(n); i++)\n#define rrep(i, a, n) for (int i = ((int)(n-1)); i >= (int)(a); i--)\n#define Rep(i, a, n) for (long long i = (long long)(a); i< (long long)(n); i++)\n#define RRep(i, a, n) for (long long i = ((long long)(n-1ll)); i>=(long long)(a); i--)\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (std::size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n\nstruct Edge{\n    int to;\n    int weight;\n    Edge(int t, int w) : to(t), weight(w){ }\n};\n\nstruct edge{\n    int from;\n    int to;\n    int weight;\n    edge(int f,int t,int w) : from(f), to(t), weight(w){ }\n};\n\n\nusing Graph = vector<vector<Edge>>;\nusing graph = vector<vector<int>>;\nusing edges = vector<edge>;\n\ntemplate <class T>\ninline bool chmin(T &a, T b){\n    if (a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\ninline bool chmax(T &a, T b){\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class T>\nT lcm(T a, T b){\n    return (a*b)/gcd(a,b);\n}\n\nbool isPalindrome(string s){\n    string t = s;\n    reverse(all(t));\n    return s==t;\n}\n\nconstexpr ll LNF = 1e18+7;\n\nconstexpr int INF = 1e9+7;\n\nvector<int> dx = {-1,0,1,0,-1,1,-1,1};\nvector<int> dy = {0,-1,0,1,1,-1,-1,1};\n\n/* template */\n\nvector<int> TopologicalSort(const graph &g){\n    int V = g.size();\n    vector<int> indeg(V,0);\n    for(auto &in_edge: g){\n        for(auto &e: in_edge){\n            indeg[e]++;\n        }\n    }\n    queue<int> que;\n    for(int i = 0; i<V; i++){\n        if(indeg[i]==0) que.push(i);\n    }\n    vector<int> t_sort;\n    while(!que.empty()){\n        int v = que.front(); que.pop();\n        for(auto &nv: g[v]){\n            indeg[nv]--;\n            if(indeg[nv]==0) que.push(nv);\n        }\n        t_sort.emplace_back(v);\n    }\n    return t_sort;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int v,e; cin >> v >> e;\n    graph g(v);\n    rep(i,0,e){\n        int s,t;\n        cin >> s >> t;\n        g[s].emplace_back(t);\n    }\n    auto t_sort = TopologicalSort(g);\n    rep(i,0,v){\n        cout << t_sort[i] << endl;\n    }\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.ST\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport           Data.Primitive.MutVar\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\n\nmain :: IO ()\nmain = do\n    [v, e] <- map read.words <$> getLine\n    edges <- U.unfoldrN e (readInt2.B.dropWhile isSpace) <$> B.getContents\n    putStr . unlines . map show . solve $ directedGraph v edges\n\nsolve :: Graph -> [Vertex]\nsolve gr = U.toList $ topologicalSort gr\n\n------------------------------------------------------------------------------\n\nreadInt2 :: B.ByteString -> Maybe ((Int,Int), B.ByteString)\nreadInt2 bs = Just ((x,y),bsy)\n  where\n    Just (x, bsx) = B.readInt bs\n    Just (y, bsy) = B.readInt $ B.unsafeTail bsx\n\nunlessM :: Monad m => m Bool -> m () -> m ()\nunlessM mb f = mb >>= flip unless f\n{-# INLINE unlessM #-}\n\ntype Vertex = Int\ntype Edge = (Int, Int)\ntype Graph = V.Vector (U.Vector Vertex)\n\ndirectedGraph :: Int -> U.Vector Edge -> Graph\ndirectedGraph numV edges = V.map U.fromList\n    . V.unsafeAccumulate (flip (:)) (V.replicate numV [])\n    $ U.convert edges\n\nvertices :: Graph -> U.Vector Vertex\nvertices gr = U.generate (V.length gr) id\n\ntopologicalSort :: Graph -> U.Vector Vertex\ntopologicalSort gr = runST $ do\n    visited <- UM.replicate (V.length gr) False\n    sorted <- newMutVar []\n    U.forM_ (vertices gr) . fix $ \\dfs v ->\n        unlessM (UM.unsafeRead visited v) $ do\n            UM.unsafeWrite visited v True\n            U.mapM_ dfs $ V.unsafeIndex gr v\n            modifyMutVar' sorted (v:)\n    U.fromList <$> readMutVar sorted"
  },
  {
    "language": "Haskell",
    "code": "import           Control.Applicative\nimport           Control.Monad\nimport qualified Data.ByteString.Char8 as B\n\nimport           Control.Monad.ST\nimport           Data.Array.IArray\nimport           Data.Array.MArray\nimport           Data.Array.ST\nimport           Data.Array.Unboxed\nimport           Data.STRef\n\nreadi :: B.ByteString -> Int\nreadi b | Just (n, _) <- B.readInt b = n\n\nsolve :: Array Int [Int] -> ST s [Int]\nsolve grp = do\n    clr <- newArray (s, t) False :: ST s (STUArray s Int Bool)\n    out <- newSTRef []\n    forM_ [s .. t] $ \\i -> do\n        cv <- readArray clr i\n        when (cv == False) $ dfs clr out i\n    return =<< readSTRef out\n  where\n    (s, t) = bounds grp\n\n    dfs :: STUArray s Int Bool -> STRef s [Int] -> Int -> ST s ()\n    dfs clr out i = do\n        writeArray clr i True\n        forM_ (grp ! i) $ \\v -> do\n            c <- readArray clr v\n            when (c == False) $ dfs clr out v\n        modifySTRef' out (i :)\n\nmain :: IO ()\nmain = do\n    [v, e] <- fmap readi . B.words <$> B.getLine\n    xss <- replicateM e $ do\n        [a, b] <- fmap readi . B.words <$> B.getLine\n        return (a, b)\n    let g = accumArray (flip (:)) [] (0, v-1) xss :: Array Int [Int]\n    let ans = runST $ solve g\n    mapM_ print ans\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Wmax 1000\n#define Rmax 1000\n\nvoid order(int i, int w);\n\nint A[Wmax][Wmax];/*[??????no.][0:?????£??????, 1~n-2:???no.]*/\nint c[Rmax];/*????????°*/\nint p[Wmax];/*???????????????*/\n\nint t;\n\nint main(void)\n{\n  int i, j, k, w, r, n;\n  scanf(\"%d\", &w);/*????????°*/\n  scanf(\"%d\", &r);/*?????¶??°*/\n\n  for(i=0; i<w; i++)\n    {\n      c[i]=0;\n      for(j=0; j<w+1; j++)\n\t{\n\t  A[i][j]=w+1;\n\t}\n    }  \n  for(i=0; i<r; i++)\n    {\n      scanf(\"%d\", &n);\n      c[n]++;\n      scanf(\"%d\", &A[n][c[n]]);\n    }\n\n  t=0;\n  for(i=0; i<w; i++)\n    {\n      if(A[i][0]!=0)\n\t{\n         for(j=c[i]; j>0; j--)\n            {\n              if(A[A[i][j]][0]!=0)\n                {\n                  break;\n                }\n\t    }\n          if(j==0)\n\t    {\n\t      order(i, w);\n\t    }\n\t}\n    }\n\n  for(i=w; i>0; i--)\n    {\n      printf(\"%d\\n\", p[i-1]);\n    }\n\n  return 0;\n}\n\nvoid order(int i, int w)\n{\n  int j, k;\n\n  A[i][0]=0;\n  p[t]=i;\n  t++;\n  for(j=0; j<w; j++)\n    {\n      if(A[j][0]!=0)\n\t{\n\t  for(k=c[j]; k>0; k--)\n\t    {\n\t      if(A[j][k]==i)\n\t\t{\n\t\t  order(j, w);\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      if(A[j][k]==i)\n\t{\n\t  break;\n\t}\n    }\n  return;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10\n#define E_NUM 100000\n\nstruct queue{\n  char data[N];\n  int head;\n  int tail;\n};\n\nvoid initialize(struct queue *q){\n  int i;\n\n  q->head=0;\n  q->tail=0;\n  for(i=0; i < N; ++i){\n    q->data[i]=' ';\n  }\n}\n\nvoid enqueue(struct queue *q, int item){\n  if (q->tail >= N) {\n    printf(\"This queue is full! \\n\");\n  }else{\n    q->data[q->tail]=item;\n    q->tail++;\n  }\n}\n\nint dequeue(struct queue *q){\n  int tmp;\n\n  if(q->head == q->tail){\n    return -1;\n  }else{\n    tmp=q->data[q->head];\n    q->head++;\n    return tmp;\n  }\n}\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      //visit(z);\n      enqueue;\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "// トポロジカルソート\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#include<queue>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int MAX_E = 100000;\n\nconst int NO = 0;\nconst int MID = 1;\nconst int YES = 2;\n\n// 各辺のつながりを格納する動的配列\nvector<int> v_connection[MAX_V];\n// 訪問情報を保持する配列\nint ary_visit[MAX_V];\n// 入力辺の数を格納する配列\nint ary_inputEdge[MAX_V];\n// トポロジカルソートの結果を格納するキュー\nqueue<int> topo_que;\n\nvoid TopologicalSort(int v);\n\nint main(void)\n{\n\n    int n, edge;\n    int first, second;\n\n    cin >> n >> edge;\n\n    for(int i = 0; i < n; i++)\n    {\n        // 配列の初期化\n        ary_inputEdge[i] = 0;\n        ary_visit[i] = NO;\n    }\n\n    for(int i = 0; i < edge; i++)\n    {\n        cin >> first >> second;\n\n        // 入力辺の数を記憶する\n        ary_inputEdge[second]++;\n        // 各辺のつながりを記憶する\n        v_connection[first].push_back(second);\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n        if( ary_visit[i] == NO )\n        {\n            // 頂点を順番に訪れる\n            TopologicalSort(i);\n        }\n    }\n\n    // 結果の表示\n    int size = topo_que.size();\n\n    int *result = new int[size];\n\n    for(int i = size - 1; i >= 0; i--)\n    {\n        int val = topo_que.front();\n        topo_que.pop();\n\n        result[i] = val;\n    }\n\n    for(int i = 0; i < size; i++)\n    {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    return 0;\n}\n\n// トポロジカルソートを実施するためのメソッド\n// v : 訪問する頂点\nvoid TopologicalSort(int v)\n{\n    int connect_v;\n\n    if( ary_inputEdge[v] >= 0 && ary_visit[v] == NO )\n    {\n        // 訪問途中を記録\n        ary_visit[v] = MID;\n\n        for(unsigned int i = 0; i < v_connection[v].size(); i++ )\n        {\n            // 接続先の頂点No.の格納\n            connect_v = v_connection[v][i];\n\n            // vから接続している頂点の入力辺の次数を減算する\n            ary_inputEdge[connect_v]--;\n            // 接続している頂点を順番に訪れる\n            TopologicalSort(connect_v);\n        }\n    }\n\n    //if( ary_inputEdge[v] == 0 )\n    if( ary_visit[v] == MID )\n    {\n        // 入力辺が無くなった頂点をトポロジカルキューに追加する\n        topo_que.push(v);\n        ary_inputEdge[v]--;\n        ary_visit[v] = YES;\n    }\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint V,E,G[10005][10005],i,j,s,e,F[10005]={0},Q[1000000][2]={0},p,q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(i=0;i<E;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tF[e]=1;\n\t\tG[s][e]=1;\n\t}\n\tfor(i=0,q=0;i<V;i++)\n\t\tif(!F[i])\n\t\t\tQ[q++][0]=i;\n\tmemset(F,0,sizeof(F));\n\tfor(p=0;p<q;p++)\n\t{\n\t\ts=Q[p][0];\n\t\tif(F[s]>Q[p][1])continue;\n\t\tfor(i=0;i<V;i++)\n\t\t\tif(G[s][i]&&F[i]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[i]=F[s]+1;\n\t\t\t\tQ[q][0]=i;\n\t\t\t\tQ[q][1]=F[i];\n\t\t\t\tq++;\n\t\t\t}\n\t}\n\tfor(i=0;i<V;i++)\n\t{\n\t\tq=-1;\n\t\tfor(j=0;j<V;j++)\n\t\t\tif(q==-1||F[q]>F[j])q=j;\n\t\tprintf(\"%d\\n\",q);\n\t\tF[q]=1000000;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint get_int2(int *a1, int *a2) {\n  scanf(\"%d %d\", a1, a2);\n  return 0;\n}\n\n\n#define VERTEX_MAX 10000\n#define EDGE_MAX 100000\nstruct list {\n    struct list *next;\n    int dst;\n};\n\nstruct list *create_graph(int vs) {\n    static struct list graph[VERTEX_MAX];\n    int i;\n    for(i = 0; i < vs; i++) {\n        graph[i].next = &graph[i];\n    }\n    return graph;\n}\n\nstruct list lpool[EDGE_MAX];\nint lidx = 0;\n\nvoid add_list(struct list *head, int v) {\n    struct list *elem = &lpool[lidx++];\n    elem->dst = v;\n    elem->next = head->next;\n    head->next = elem;\n    return;\n}\n\nstatic int ans[VERTEX_MAX];\nstatic int pos = 0;\nstatic char checked[VERTEX_MAX];\nvoid dfs(struct list *graph, int *outdeg, int node) {\n#ifdef DEBUG\n    printf(\"dfs(%d)\\n\", node);\n#endif\n    struct list *head = &graph[node];\n    struct list *elem;\n    ans[pos++] = node;\n    checked[node] = 1;\n    for(elem = head->next; elem != head; elem = elem->next) {\n        int dst = elem->dst;\n        outdeg[dst]--;\n        if(outdeg[dst]) continue;\n        dfs(graph, outdeg, dst);\n    }\n}\n\nint main(void) {\n    int vs, es;\n    get_int2(&vs, &es);\n    struct list *graph = create_graph(vs);\n    static int outdeg[VERTEX_MAX];\n\n    int i;\n    for(i = 0; i < es; i++) {\n        int src, dst;\n        get_int2(&src, &dst);\n        add_list(&graph[src], dst);\n        outdeg[dst]++;\n    }\n\n    for(i = 0; i < vs; i++) {\n        if(!outdeg[i] && !checked[i]) dfs(graph, outdeg, i);\n#ifdef DEBUG\n        int j;\n        printf(\"%d: \", i);\n        for(j = 0; j < vs; j++) {\n            printf(\"%d \", outdeg[j]);\n        }\n        putchar('\\n');\n#endif\n    }\n\n    // presentation\n    for(i = 0; i < vs; i++) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nstruct node{\n    int to,next;\n}e[100100];\nint cnt=0,head[10100],vis[10100],stack[10100],top=0;\nvoid addedge(int u,int v){\n    cnt++,e[cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n}\nvoid dfs(int x){\n    int b,v;\n    vis[x]=1;\n    for(b=head[x];b;b=e[b].next){\n        v=e[b].to;\n        if(vis[v]==0)\n            dfs(v);\n    }\n    stack[++top]=x;//1 此?写成 stack[++top]=v; ?了会，真是大失水准 \n}\nint main(){\n    int n,m,i,j,u,v;\n    memset(head,0,sizeof(head));\n    memset(vis,0,sizeof(vis));\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&u,&v);\n        addedge(u,v);\n    }\n    for(i=0;i<n;i++)\n        if(vis[i]==0)\n            dfs(i);\n    while(top){\n        printf(\"%d\\n\",stack[top--]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10000\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint q[100010];\nint topo(int v,int e,int *a,int *b){\n  int ta[100010],nt[200010];\n  int i,t,r,c[200010]={0};\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    ta[i]=-1;\n    if(c[i]==0)q[r++]=i;\n  }\n  for(i=0;i<v;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  for(t=0;t<v;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      c[b[i]]--;\n      if(c[b[i]]==0)q[r++]=b[i];\n    }\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n * zyobusuku.c\n *\n *  Created on: 2016/03/18\n *      Author: Owner\n */\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\ntypedef struct Numbers{\n\tint turn; //?????????(??????????????????????????????)\n\tint flag; //flag==1????????????????????¶?´?????????£?????????\n\tint read; //read==1???????????¢?´¢??????\n\tint num; //?????????\n}str;\n\n\nint N,K,Turn_now;\nint **job;//job[????????°???][????????°????????????????????°???]\nstr *Number;//??????????????????????????±\n\n//?????????????°??????????????????????????????????\nint compare(const void *arg1,const void *arg2){\n\treturn ((str*)arg1)->turn - ((str*)arg2)->turn;\n}\n\n//??±???????????¢?´¢??§????????£?????\\?????¨????????????????????°??????\nvoid Check_Number(int Node){\n\tint i,t;\n\t//???????????£?????¨?????????????????????\n\tif(Number[Node].read == 1){\n\t\treturn;\n\t}\n\tNumber[Node].read = 1;\n\n\t//????????????????????????\n\tfor(i=0;job[Node][i] != 0;i++){\n\t\tt = job[Node][i];\n\t\t//printf(\"??????%d??§??????????¬????%d????????§??????????\\n\",Node,t);\n\t\tCheck_Number(t);\n\t}\n\n\tNumber[Node].turn = Turn_now; //??????????????????\n\tTurn_now++;\n\treturn;\n}\n\n//????????????????????????????????¨????????????????§????\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d %d\",&N,&K);\n\t//job[????????°???][????????°????????????????????°???]\n\tjob = malloc(sizeof(int*)*N);\n\tNumber = (str*)malloc(sizeof(str)*N);\n\tfor(i=0;i<N;i++){\n\t\tjob[i] = malloc(sizeof(int)*N);\n\t}\n\t//?????????\n\tfor(i=0;i<N;i++){\n\t\tNumber[i].flag = 0;\n\t\tNumber[i].turn = 0;\n\t\tNumber[i].read = 0;\n\t\tNumber[i].num = i;\n\n\t\tfor(j=0;j<N;j++){\n\t\t\tjob[i][j] = 0;\n\t\t}\n\t}\n\n\t//job?????£??\\\n\tfor(i=0;i<K;i++){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tfor(j=0;j<N;j++){\n\t\t\tif(job[m][j] == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjob[m][j] = n;\n\t\t//printf(\"%d???%d?????????%d???????´??????????????\\n\",n,j,m);\n\t\tNumber[n].flag = 1;\n\t}\n\tfor(i=0;i<N;i++){\n\t\t//????????????????????????????????¶?´?????????£?????????????????°\n\t\tif(Number[i].flag == 0){\n\t\t\tCheck_Number(i); //???????????????????????????????????°\n\t\t}\n\t}\n\n\n    //?????????????????????\n\tqsort(&(Number[0]),N,sizeof(str),compare);\n\n\tfor(i=0;i<N;i++){\n\t\tprintf(\"%d \",Number[i].num);\n\t\tprintf(\"%d?\\n\",Number[i].turn);\n\t}\n\n\t//?§£???\n\tfree(Number);\n\tfor(i=0;i<N;i++){\n\t\tfree(job[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint q[10010];\nint topo(int v,int e,int *a,int *b){\n  int ta[10010],nt[100010];\n  int i,t,r,c[10010]={0};\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    ta[i]=-1;\n    if(c[i]==0)q[r++]=i;\n  }\n  for(i=0;i<v;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  for(t=0;t<v;t++){//printf(\"%d:\",q[t]);\n    //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      c[b[i]]--;\n      if(c[b[i]]==0)q[r++]=b[i];\n    }\n  }\n  //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef struct directed_edge {\n  int32_t vertex;\n  int32_t next;\n} graph_edge;\n\ntypedef struct directedGraph {\n  graph_edge *edge;\n  int32_t *start;\n  int32_t pointer;\n  int32_t vertex_num;\n  int32_t edge_max_size;\n} graph;\n\ngraph* new_graph (const int vertex_num) {\n  graph *g = (graph *) calloc (1, sizeof (graph));\n  g->edge = (graph_edge *) calloc (1, sizeof (graph_edge));\n  g->start = (int32_t *) calloc (vertex_num, sizeof (int32_t));\n  g->pointer = 0;\n  g->vertex_num = vertex_num;\n  g->edge_max_size = 1;\n  for (int32_t i = 0; i < vertex_num; ++i) {\n    g->start[i] = -1;\n  }\n  return g;\n}\n\nvoid add_edge (graph *g, int32_t from, int32_t to) {\n  if (g->pointer == g->edge_max_size) {\n    g->edge_max_size *= 2;\n    g->edge = (graph_edge *) realloc (g->edge, sizeof (graph_edge) * g->edge_max_size);\n  }\n  g->edge[g->pointer] = (graph_edge) {to, g->start[from]};\n  g->start[from] = g->pointer++;\n}\n\nint topological_sort (graph *g, int32_t *q) {\n  int32_t n = g->vertex_num;\n  int32_t *cnt = (int32_t *) calloc (n, sizeof (int32_t));\n  for (int32_t i = 0; i < n; ++i) {\n    for (int32_t p = g->start[i]; p != -1; p = g->edge[p].next) {\n      const int32_t u = g->edge[p].vertex;\n      cnt[u]++;\n    }\n  }\n  int32_t front = 0;\n  int32_t last = 0;\n  for (int32_t i = 0; i < n; ++i) {\n    if (cnt[i] == 0) {\n      q[last++] = i;\n    }\n  }\n  while (front < last && last < n) {\n    const int32_t v = q[front++];\n    for (int32_t p = g->start[v]; p != -1; p = g->edge[p].next) {\n      const int32_t u = g->edge[p].vertex;\n      cnt[u]--;\n      if (cnt[u] == 0) {\n\tq[last++] = u;\n      }\n    }\n  }\n  free (cnt);\n  return last == n;\n}\n\ntypedef int32_t i32;\n\nvoid run (void) {\n  i32 v, e;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &v, &e);\n  graph *g = new_graph (v);\n  while (e--) {\n    i32 s, t;\n    scanf (\"%\" SCNi32 \"%\" SCNi32, &s, &t);\n    add_edge (g, s, t);\n  }\n  i32 *q = (i32 *) calloc (v, sizeof (i32));\n  topological_sort (g, q);\n  for (i32 i = 0; i < v; ++i) {\n    printf (\"%\" PRIi32 \"\\n\", q[i]);\n  }\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_4_B Path/Cycle - Topological Sort\n// 2018.4.26 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_V 10002\nint V;   // 頂点数\nint *to[MAX_V], hi[MAX_V];\nint q[MAX_V], top, end;\nint count[MAX_V];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid topological_sort()\n{\n    int i, j, k;\n\n//  for (i = 0; i < V; i++) for (j = 0; j < hi[i]; j++) count[to[i][j]]++;\n\n    top = end = 0;\n    for (i = 0; i < V; i++) if (!count[i]) q[end++] = i;\n    while (top < end) {\n\t\ti = q[top++];\n        printf(\"%d\\n\", i);\n        for (j = 0; j < hi[i]; j++) {\n            k = to[i][j];\n            if (--count[k] == 0) q[end++] = k;\n        }\n    }\n}\n\nint main()\n{\n\tint E, s, t, i, j;\n\tint *memo;\n\n\tV = in(), E = in();\n\tmemo = malloc(E<<3);\n\tj = 0; for (i = 0; i < E; i++) {\n\t\tmemo[j++] = s = in(), memo[j++] = t = in();\n\t\thi[s]++;\n\t}\n\tfor (i = 0; i < V; i++) if (hi[i]) to[i] = malloc(hi[i]<<2);\n\tmemset(hi, 0, V<<2);\n\tj = 0; while (E--) {\n\t\ts = memo[j++], t = memo[j++];\n\t\tto[s][hi[s]++] = t;\n\t\tcount[t]++;\n\t}\n\n\ttopological_sort();\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n * zyobusuku.c\n *\n *  Created on: 2016/03/18\n *      Author: Owner\n */\n\n\n\n#include<stdio.h>\n#include<stdlib.h>\n\n\ntypedef struct Numbers{\n\tint turn; //?????????(??????????????????????????????)\n\tint flag; //flag==1????????????????????¶?´?????????£?????????\n\tint read; //read==1???????????¢?´¢??????\n\tint num; //?????????\n}str;\n\n\nint N,K,Turn_now;\nint **job;//job[????????°???][????????°????????????????????°???]\nstr *Number;//??????????????????????????±\n\n//?????????????°??????????????????????????????????\nint compare(const void *arg1,const void *arg2){\n\treturn ((str*)arg1)->turn - ((str*)arg2)->turn;\n}\n\n//??±???????????¢?´¢??§????????£?????\\?????¨????????????????????°??????\nvoid Check_Number(int Node){\n\tint i,t;\n\t//???????????£?????¨?????????????????????\n\tif(Number[Node].read == 1){\n\t\treturn;\n\t}\n\tNumber[Node].read = 1;\n\n\t//????????????????????????\n\tfor(i=0;job[Node][i] != 0;i++){\n\t\tt = job[Node][i];\n\t\t//printf(\"??????%d??§??????????¬????%d????????§??????????\\n\",Node,t);\n\t\tCheck_Number(t);\n\t}\n\n\tNumber[Node].turn = Turn_now; //??????????????????\n\tTurn_now++;\n\treturn;\n}\n\n//????????????????????????????????¨????????????????§????\nint main(){\n\tint i,j,n,m;\n\tscanf(\"%d %d\",&N,&K);\n\t//job[????????°???][????????°????????????????????°???]\n\tjob = malloc(sizeof(int*)*N);\n\tNumber = (str*)malloc(sizeof(str)*N);\n\tfor(i=0;i<N;i++){\n\t\tjob[i] = malloc(sizeof(int)*N);\n\t}\n\t//?????????\n\tfor(i=0;i<N;i++){\n\t\tNumber[i].flag = 0;\n\t\tNumber[i].turn = 0;\n\t\tNumber[i].read = 0;\n\t\tNumber[i].num = i;\n\n\t\tfor(j=0;j<N;j++){\n\t\t\tjob[i][j] = 0;\n\t\t}\n\t}\n\n\t//job?????£??\\\n\tfor(i=0;i<K;i++){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tfor(j=0;j<N;j++){\n\t\t\tif(job[m][j] == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjob[m][j] = n;\n\t\t//printf(\"%d???%d?????????%d???????´??????????????\\n\",n,j,m);\n\t\tNumber[n].flag = 1;\n\t}\n\tfor(i=0;i<N;i++){\n\t\t//????????????????????????????????¶?´?????????£?????????????????°\n\t\tif(Number[i].flag == 0){\n\t\t\tCheck_Number(i); //???????????????????????????????????°\n\t\t}\n\t}\n\n\n    //?????????????????????\n\tqsort(&(Number[0]),N,sizeof(str),compare);\n\n\tfor(i=0;i<N;i++){\n\t\tprintf(\"%d \",Number[i].num);\n\t\tprintf(\"%d?\\n\",Number[i].turn);\n\t}\n\n\t//?§£???\n\tfree(Number);\n\tfor(i=0;i<N;i++){\n\t\tfree(job[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[200010];//適宜変える(ecnt)\n\tint id[10010];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nvoid readgraph(){\n\t//適宜変える\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,0,m){\n\t\tll x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tg.e[i].s=x;\n\t\tg.e[i].g=y;\n\t}\n\tg.vcnt=n;\n\tg.ecnt=m;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\nint flag[10010],toposo[10010],cnt;\nvoid dfs(int v){\n\tif(flag[v]++)return;\n\trep(i,g.id[v],g.id[v+1])dfs(g.e[i].g);\n\ttoposo[cnt++]=v;\n}\n\nint main(){\n\treadgraph();\n\trep(i,0,g.vcnt)dfs(i);\n\tfor(int i=cnt-1;i>=0;i--)printf(\"%d\\n\",toposo[i]);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MN 10005\nint V,E,G[MN][MN],i,j,s,e,F[MN]={0},Q[MN][2]={0},p,q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(i=0;i<E;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tF[e]=1;\n\t\tG[s][e]=1;\n\t}\n\tfor(i=0,q=0;i<V;i++)\n\t\tif(!F[i])\n\t\t\tQ[q++][0]=i;\n\tmemset(F,0,sizeof(F));\n\tfor(p=0;p<q;p=(p+1)%MN)\n\t{\n\t\ts=Q[p][0];\n\t\tif(F[s]>Q[p][1])continue;\n\t\tfor(i=0;i<V;i++)\n\t\t\tif(G[s][i]&&F[i]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[i]=F[s]+1;\n\t\t\t\tQ[q%MN][0]=i;\n\t\t\t\tQ[q%MN][1]=F[i];\n\t\t\t\tq++;\n\t\t\t}\n\t}\n\tfor(i=0;i<V;i++)\n\t{\n\t\tq=-1;\n\t\tfor(j=0;j<V;j++)\n\t\t\tif(q==-1||F[q]>F[j])q=j;\n\t\tprintf(\"%d\\n\",q);\n\t\tF[q]=MN;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint q[100010];\nint topo(int v,int e,int *a,int *b){\n  int ta[100010],nt[100010];\n  int i,t,r,c[100010]={0};\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    ta[i]=-1;\n    if(c[i]==0)q[r++]=i;\n  }\n  for(i=0;i<v;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  for(t=0;r<v;t++){//printf(\"%d:\",q[t]);\n    //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      c[b[i]]--;\n      if(c[b[i]]==0)q[r++]=b[i];\n    }\n  }\n  //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint q[10010];\nint topo(int v,int e,int *a,int *b){\n  int ta[10010],nt[100010];\n  int i,t,r,c[10010]={0};\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    ta[i]=-1;\n    if(c[i]==0)q[r++]=i;\n  }\n  for(i=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  for(t=0;t<v;t++){//printf(\"%d:\",q[t]);\n    //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      c[b[i]]--;\n      if(c[b[i]]==0)q[r++]=b[i];\n    }\n  }\n  //for(i=0;i<v;i++)printf(\"%d \",c[i]);printf(\"\\n\");\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10000\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\nint i ,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \nint z;\n  for(z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\nint i,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\nint i ;\n  for(i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MN 10001\nint V,E,G[MN][MN],i,j,s,e,F[MN]={0},Q[20001][2]={0},p,q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(i=0;i<E;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tF[e]=1;\n\t\tG[s][e]=1;\n\t}\n\tfor(i=0,q=0;i<V;i++)\n\t\tif(!F[i])\n\t\t\tQ[q++][0]=i;\n\tmemset(F,0,sizeof(F));\n\tfor(p=0;p<q;p++)\n\t{\n\t\te=p%20001;\n\t\ts=Q[e][0];\n\t\tif(F[s]>Q[e][1])continue;\n\t\tfor(i=0;i<V;i++)\n\t\t\tif(G[s][i]&&F[i]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[i]=F[s]+1;\n\t\t\t\tQ[q%20001][0]=i;\n\t\t\t\tQ[q%20001][1]=F[i];\n\t\t\t\tq++;\n\t\t\t}\n\t}\n\tfor(i=0;i<V;i++)\n\t{\n\t\tq=-1;\n\t\tfor(j=0;j<V;j++)\n\t\t\tif(q==-1||F[q]>F[j])q=j;\n\t\tprintf(\"%d\\n\",q);\n\t\tF[q]=MN;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define QUE_SIZE 100\n\nint G[MAX_V][1000];\nint nG[MAX_V];\nbool visited[MAX_V];\nint indeg[MAX_V];\nint V;\nint n_out;\n\nint queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_size()\n{\n\tif (que_in >= que_out)\n\t\treturn que_in - que_out;\n\n\treturn que_in + QUE_SIZE - que_out;\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x)\n{\n\tqueue[que_in] = x;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nint\nque_front()\n{\n\treturn queue[que_out];\n}\n\nvoid\nbfs(int s)\n{\n\tint i;\n\n\tque_push(s);\n\tvisited[s] = true;\n\twhile (!que_empty())\n\t{\n\t\tint u = que_front(); que_pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tque_push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tint u;\n\tint i;\n\n\tfor (i = 0; i < V; ++i)\n\t\tindeg[i] = 0;\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t;\n\tint i;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tnG[i] = 0;\n\t\tvisited[i] = false;\n\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s][nG[s]++] = t;\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define QUE_SIZE 100\n\nint G[MAX_V][MAX_V];\nint nG[MAX_V];\nbool visited[MAX_V];\nint indeg[MAX_V];\nint V;\nint n_out;\n\nint queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_size()\n{\n\tif (que_in >= que_out)\n\t\treturn que_in - que_out;\n\n\treturn que_in + QUE_SIZE - que_out;\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x)\n{\n\tqueue[que_in] = x;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nint\nque_front()\n{\n\treturn queue[que_out];\n}\n\nvoid\nbfs(int s)\n{\n\tint i;\n\n\tque_push(s);\n\tvisited[s] = true;\n\twhile (!que_empty())\n\t{\n\t\tint u = que_front(); que_pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tque_push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tint u;\n\tint i;\n\n\tfor (i = 0; i < V; ++i)\n\t\tindeg[i] = 0;\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t;\n\tint i;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tnG[i] = 0;\n\t\tvisited[i] = false;\n\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s][nG[s]++] = t;\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint q[10010];\nint topo(int v,int e,int *a,int *b){\n  int ta[10010],nt[100010];\n  int i,t,r,c[10010]={0};\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    ta[i]=-1;\n    if(c[i]==0)q[r++]=i;\n  }\n  for(i=0;i<e;i++){\n    nt[i]=ta[a[i]];\n    ta[a[i]]=i;\n  }\n  for(t=0;t<v;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(--c[b[i]]==0)q[r++]=b[i];\n    }\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10000\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\nint i ,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \nint z;\n  for(z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\nint i,j;\n  for(i = 0 ; i < V_NUM; i++){\n    for(j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\nint i ;\n  for(i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node {\n  int id;\n  struct node *next;\n};\n\nstruct node **list;\nint *indeg, *visit, *stack, sp;\nvoid Insert(int, int);\nvoid bfs(int, int);\nint main(void)\n{\n  int i, v, e, s, t;\n  scanf(\"%d %d\", &v, &e);\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  indeg = (int*)calloc(v, sizeof(int));\n  visit = (int*)calloc(v, sizeof(int));\n  stack = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) list[i] = NULL;\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(s, t);\n  }\n  for (i = 0; i < v; i++) {\n    struct node *n;\n    for (n = list[i]; n != NULL; n = n->next) indeg[n->id]++;\n  }\n  for (i = 0; i < v; i++) {\n    if (!(indeg[i] || visit[i])) bfs(i, v);\n  }\n  for (i = 0; i < sp; i++) printf(\"%d\\n\", stack[i]);\n  for (i = 0; i < v; i++) free(list[i]);\n  free(list);\n  free(indeg);\n  free(visit);\n  free(stack);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->next=list[a];\n  list[a] = p;\n}\nvoid bfs(int point, int size)\n{\n  int ptr_front = 0, ptr_back = 0, *queue = (int*)malloc(sizeof(int) * size);\n  queue[ptr_back++] = point;\n  visit[point] = 1;\n  while (ptr_front != ptr_back) {\n    int u = queue[ptr_front++];\n    struct node *n;\n    stack[sp++] = u;\n    for (n = list[u]; n != NULL; n = n->next) {\n      indeg[n->id]--;\n      if (!(indeg[n->id] || visit[n->id])) {\n        visit[n->id] = 1;\n        queue[ptr_back++] = n->id;\n      }\n    }\n  }\n  free(queue);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MN 10001\nint V,E,G[MN][MN],i,j,s,e,F[MN]={0},Q[20001][2]={0},p,q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(i=0;i<E;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tF[e]=1;\n\t\tG[s][e]=1;\n\t}\n\tfor(i=0,q=0;i<V;i++)\n\t\tif(!F[i])\n\t\t\tQ[q++][0]=i;\n\tmemset(F,0,sizeof(F));\n\tfor(p=0;p<q;p++)\n\t{\n\t\te=p%20001;\n\t\ts=Q[e][0];\n\t\tif(F[s]>Q[e][1])continue;\n\t\tfor(i=0;i<V;i++)\n\t\t\tif(G[s][i]&&F[i]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[i]=F[s]+1;\n\t\t\t\tQ[q%2000][0]=i;\n\t\t\t\tQ[q%2000][1]=F[i];\n\t\t\t\tq++;\n\t\t\t}\n\t}\n\tfor(i=0;i<V;i++)\n\t{\n\t\tq=-1;\n\t\tfor(j=0;j<V;j++)\n\t\t\tif(q==-1||F[q]>F[j])q=j;\n\t\tprintf(\"%d\\n\",q);\n\t\tF[q]=MN;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      //visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}\n  \n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define LARGE 10000\n\n\nint V,E;\nint color=0;\n\ntypedef struct list{\n\tint id;\n\tstruct list *next;\n}list;\n\ntypedef struct node{\n\tint id;\n\tint in_num;\n}node;\n\nlist * makelist(int x){\n\tlist *new=malloc(sizeof(list));\n\tnew->id=x;\n\tnew->next=NULL;\n\treturn new;\n}\n\nvoid list_insert(list* L[],int x,list *new){\n\tlist **p=&L[x];\n\t\n\twhile((*p)!=NULL){\n\t\tp=&((*p)->next);\n\t}\n\t(*p)=new;\n\t\n\treturn;\n}\n\nvoid swap(node h[],int x,int y){\n\tnode temp=h[x];\n\th[x]=h[y];\n\th[y]=temp;\n\treturn;\n}\n\n\nvoid heapsort(node heap[],int num){\n\n\tfor(int i=num-1;i>0;i--){\n\t\tif(i%2==0){\n\t\t\tif(heap[i].in_num < heap[i/2-1].in_num)swap(heap,i,i/2-1);\n\t\t}else {\n\t\t\tif(heap[i].in_num < heap[i/2].in_num)swap(heap,i,i/2);\n\t\t}\n\t}\n\t\n\treturn;\n\n}\n\nint update_heap(node heap[],int num,list *L[]){\n\tint u=heap[0].id;\n\tlist *p=L[u];\n\t\n\tswap(heap,0,num-1);\n\tnum--;\n\t\n\t\n\twhile(p!=NULL){\n\t\tfor(int i=0;i<num;i++){\n\t\t\tif(heap[i].id==p->id){\n\t\t\t\theap[i].in_num--;\n\t\t\t}\n\t\t}\n\t\tp=p->next;\n\t}\n\t\n\t\n\treturn num;\n}\n\nint main(){\n\tint i,j;\n\tint s,t;\n\tint num;\n\tlist *L[LARGE];\n\tlist *new;\n\tnode heap[LARGE];\n\t\n\tscanf(\"%d %d\",&V,&E);\n\tnum=V;\n\t\n\tfor(i=0;i<V;i++){\n\t\tL[i]=NULL;\n\t\theap[i].id=i;\n\t\theap[i].in_num=0;\n\t}\n\t\n\tfor(i=0;i<E;i++){\n\t\tscanf(\"%d %d\",&s,&t);\n\t\tnew=makelist(t);\n\t\tlist_insert(L,s,new);\n\t\theap[t].in_num++;\n\t}\n\t\n\theapsort(heap,num);\n\t\n\twhile(num!=0){\n\t\tprintf(\"%d\\n\",heap[0].id);\n\t\tnum=update_heap(heap,num,L);\n\t\theapsort(heap,num);\n\t}\n\t\n\treturn 0;\n\t\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define MAX_E 100000\n#define QUE_SIZE 200\n\ntypedef struct list_tbl\n{\n\tint t;\n\tint next;\n} list_t;\n\nint V;\nint G[MAX_V];\nlist_t list[MAX_E];\nbool visited[MAX_V];\nint indeg[MAX_V];\n\nint queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_size()\n{\n\tif (que_in >= que_out)\n\t\treturn que_in - que_out;\n\n\treturn que_in + QUE_SIZE - que_out;\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x)\n{\n\tqueue[que_in] = x;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nint\nque_front()\n{\n\treturn queue[que_out];\n}\n\nvoid\nbfs(int s)\n{\n\tque_in = 0;\n\tque_out = 0;\n\n\tque_push(s);\n\tvisited[s] = true;\n\twhile (!que_empty())\n\t{\n\t\tint u = que_front(); que_pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (int l = G[u]; l != -1; l = list[l].next)\n\t\t{\n\t\t\tint v = list[l].t;\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tque_push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tvisited[u] = false;\n\t\tindeg[u] = 0;\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tfor (int l = G[u]; l != -1; l = list[l].next)\n\t\t{\n\t\t\tint v = list[l].t;\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int u = 0; u < V; ++u)\n\t\tG[u] = -1;\n\n\tint nl = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tif (nl >= MAX_E)\n\t\t{\n\t\t\tfprintf(stderr, \"graph area overflow. size:%d\\n\", MAX_E);\n\t\t\tcleanup(1);\n\t\t}\n\n\t\tlist[nl].t = t;\n\t\tlist[nl].next = G[s];\n\t\tG[s] = nl++;\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ta[100010],nt[200010],to[200010],co[200010],q[100010];\nvoid mklsd(int v,int e,int *a,int *b,int *c){\n  int i;\n  for(i=0;i<v;i++)ta[i]=-1;\n  for(i=0;i<v;i++){\n    nt[i]=ta[a[i]];\n    to[i]=b[i];\n    co[ta[a[i]]=i]=c[i];\n  }\n}\nint topo(int v,int e,int *a,int *b){\n  int i,t,r,c[200010]={0};\n  mklsd(v,e,a,b,c);\n  for(i=0;i<e;i++)c[b[i]]++;\n  for(i=r=0;i<v;i++){\n    if(c[i]==0)q[r++]=i;\n  }\n  for(t=0;t<v;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      c[to[i]]--;\n      if(c[to[i]]==0)q[r++]=to[i];\n    }\n  }\n}\nint main(){\n  int v,e,m,i,s,a[100010],b[100010],c[100010];\n  scanf(\"%d %d\",&v,&e);\n  for(i=0;i<e;i++)scanf(\"%d %d\",&a[i],&b[i]);\n  topo(v,e,a,b);\n  for(i=0;i<v;i++)printf(\"%d\\n\",q[i]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define MAX_E 100000\n#define QUE_SIZE 100\n\ntypedef struct list_tbl\n{\n\tint t;\n\tint next;\n} list_t;\n\nint V;\nint G[MAX_V];\nlist_t list[MAX_E];\nbool visited[MAX_V];\nint indeg[MAX_V];\n\nint queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_size()\n{\n\tif (que_in >= que_out)\n\t\treturn que_in - que_out;\n\n\treturn que_in + QUE_SIZE - que_out;\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x)\n{\n\tqueue[que_in] = x;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nint\nque_front()\n{\n\treturn queue[que_out];\n}\n\nvoid\nbfs(int s)\n{\n\tque_in = 0;\n\tque_out = 0;\n\n\tque_push(s);\n\tvisited[s] = true;\n\twhile (!que_empty())\n\t{\n\t\tint u = que_front(); que_pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (int l = G[u]; l != -1; l = list[l].next)\n\t\t{\n\t\t\tint v = list[l].t;\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tque_push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tvisited[u] = false;\n\t\tindeg[u] = 0;\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tfor (int l = G[u]; l != -1; l = list[l].next)\n\t\t{\n\t\t\tint v = list[l].t;\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (int u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int u = 0; u < V; ++u)\n\t\tG[u] = -1;\n\n\tint nl = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tif (nl >= MAX_E)\n\t\t{\n\t\t\tfprintf(stderr, \"graph area overflow. size:%d\\n\", MAX_E);\n\t\t\tcleanup(1);\n\t\t}\n\n\t\tlist[nl].t = t;\n\t\tlist[nl].next = G[s];\n\t\tG[s] = nl++;\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint V,E,G[10005][10005],i,j,s,e,F[10005]={0},Q[500000][2]={0},p,q;\nint main()\n{\n\tscanf(\"%d%d\",&V,&E);\n\tfor(i=0;i<E;i++)\n\t{\n\t\tscanf(\"%d%d\",&s,&e);\n\t\tF[e]=1;\n\t\tG[s][e]=1;\n\t}\n\tfor(i=0,q=0;i<V;i++)\n\t\tif(!F[i])\n\t\t\tQ[q++][0]=i;\n\tmemset(F,0,sizeof(F));\n\tfor(p=0;p<q;p++)\n\t{\n\t\ts=Q[p][0];\n\t\tif(F[s]>Q[p][1])continue;\n\t\tfor(i=0;i<V;i++)\n\t\t\tif(G[s][i]&&F[i]<F[s]+1)\n\t\t\t{\n\t\t\t\tF[i]=F[s]+1;\n\t\t\t\tQ[q][0]=i;\n\t\t\t\tQ[q][1]=F[i];\n\t\t\t\tq++;\n\t\t\t}\n\t}\n\tfor(i=0;i<V;i++)\n\t{\n\t\tq=-1;\n\t\tfor(j=0;j<V;j++)\n\t\t\tif(q==-1||F[q]>F[j])q=j;\n\t\tprintf(\"%d\\n\",q);\n\t\tF[q]=1000000;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define V_NUM 10\n#define E_NUM 100000\n\nstruct node {\n  int state;\n};\n\nstruct node vertex[V_NUM];\nint M[V_NUM][V_NUM];\nint N;\n\nvoid init(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      if(i == j){\n\tM[i][j] =1;\n      }else{\n\tM[i][j] = 0;\n      }\n    }\n  }\n}\n\nvoid visit(int v){\n  vertex[v].state = 1;  \n  for(int z = 0; z < N ; z++){\n    //printf(\"M[%d][%d]:%d , vetex[%d]:%d\\n\",v,z,M[v][z],z,vertex[z].state);\n    if(M[v][z] && (vertex[z].state) == 0){\n      //visit(z);\n    }\n  }\n  printf(\"%d\\n\",v);\n}\n\nvoid printMap(){\n  for(int i = 0 ; i < V_NUM; i++){\n    for(int j = 0 ; j < V_NUM; j++){\n      printf(\"%d \", M[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\n\nvoid print(){\n  for(int i =0; i < N; i++){\n    printf(\"%d \", vertex[i].state);\n  }\n  printf(\"\\n\");\n}\n\nint main(void){\n  int v=0;\n  int e=0;\n  scanf(\"%d %d\",&v,&e);\n  N = v;\n  init();\n  for(int i = 0 ; i < v; i++){\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    M[a][b] = 1;\n    vertex[i].state = 0;\n  }\n  //print();\n  for(int i = 0 ; i < N; i++){\n    if(vertex[i].state == 0){\n      visit(i);\n    }\n  }\n\n  return 1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define MAX_E 100000\n\ntypedef struct list_tbl\n{\n\tint t;\n\tint next;\n} list_t;\n\nint V;\nint G[MAX_V];\nlist_t list[MAX_E];\nbool visited[MAX_V];\nint out[MAX_V];\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nvoid\ndfs(int v)\n{\n\tvisited[v] = true;\n\tfor (int l = G[v]; l != -1; l = list[l].next)\n\t{\n\t\tint u = list[l].t;\n\t\tif (!visited[u])\n\t\t\tdfs(u);\n\t}\n\n\tout[--ix] = v;\n}\n\nvoid\ntsort()\n{\n\tfor (int v = 0; v < V; ++v)\n\t\tvisited[v] = false;\n\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (!visited[v])\n\t\t\tdfs(v);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d\", &V);\n\tfor (int i = 0; i < V; ++i)\n\t\tG[i] = -1;\n\n\tint E;\n\tscanf(\"%d\", &E);\n\n\n\tint nl = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tif (nl >= MAX_E)\n\t\t{\n\t\t\tfprintf(stderr, \"graph area overflow. size:%d\\n\", MAX_E);\n\t\t\tcleanup(1);\n\t\t}\n\n\t\tlist[nl].t = t;\n\t\tlist[nl].next = G[s];\n\t\tG[s] = nl++;\n\t}\n\n\tix = V;\n\ttsort();\n\n\tfor (; ix < V; ++ix)\n\t\tprintf(\"%d\\n\", out[ix]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define MAX_V 10000\n#define QUE_SIZE 100\n\nint G[MAX_V][500];\nint nG[MAX_V];\nbool visited[MAX_V];\nint indeg[MAX_V];\nint V;\nint n_out;\n\nint queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_size()\n{\n\tif (que_in >= que_out)\n\t\treturn que_in - que_out;\n\n\treturn que_in + QUE_SIZE - que_out;\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x)\n{\n\tqueue[que_in] = x;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nint\nque_front()\n{\n\treturn queue[que_out];\n}\n\nvoid\nbfs(int s)\n{\n\tint i;\n\n\tque_push(s);\n\tvisited[s] = true;\n\twhile (!que_empty())\n\t{\n\t\tint u = que_front(); que_pop();\n\t\tprintf(\"%d\\n\", u);\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]--;\n\n\t\t\tif (indeg[v] == 0 && !visited[v])\n\t\t\t{\n\t\t\t\tvisited[v] = true;\n\t\t\t\tque_push(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntsort()\n{\n\tint u;\n\tint i;\n\n\tfor (i = 0; i < V; ++i)\n\t\tindeg[i] = 0;\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tfor (i = 0; i < nG[u]; ++i)\n\t\t{\n\t\t\tint v = G[u][i];\n\t\t\tindeg[v]++;\n\t\t}\n\t}\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tif (indeg[u] == 0 && !visited[u])\n\t\t\tbfs(u);\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint E;\n\tint s, t;\n\tint i;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tscanf(\"%d %d\", &V, &E);\n\tfor (i = 0; i < V; ++i)\n\t{\n\t\tnG[i] = 0;\n\t\tvisited[i] = false;\n\n\t}\n\n\tfor (i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tG[s][nG[s]++] = t;\n\t}\n\n\ttsort();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define UNKNOWN_ID -1\n#define DEFAULT_VARR_SIZE 8\n#define EMPTY_QUEUE(q) (q->size == 0)\n#define FULL_QUEUE(q) (q->size == q->max)\n\ntypedef struct { int head, tail, size, max, *arr; } queue_t;\ntypedef struct { int size, i, *arr; } varr_t;\n\nstatic queue_t *new_queue(int size) {\n  queue_t *q;\n  int i;\n\n  q = (queue_t *) malloc(sizeof(queue_t));\n  q->head = q->tail = q->size = 0;\n  q->max = size;\n  q->arr = (int *) malloc(sizeof(int) * size);\n  for (i = 0; i < size; ++i) q->arr[i] = UNKNOWN_ID;\n  return q;\n}\n\nstatic void free_queue(queue_t *q) {\n  free(q->arr);\n  free(q);\n}\n\nstatic void enqueue(queue_t *q, int n) {\n  if (FULL_QUEUE(q)) return;\n  q->arr[q->tail] = n;\n  q->tail = (q->tail + 1) % q->max;\n  q->size--;\n}\n\nstatic int dequeue(queue_t *q) {\n  int n;\n\n  if (EMPTY_QUEUE(q)) return UNKNOWN_ID;\n  n = q->arr[q->head];\n  q->arr[q->head] = UNKNOWN_ID;\n  q->head = (q->head + 1) % q->max;\n  q->size++;\n  return n;\n}\n\nstatic void topological_sort(int size, int *vt, int *ig, varr_t *ts, varr_t *g) {\n  int i, j, m, n;\n  queue_t *q;\n\n  for (i = 0; i < size; ++i) {\n    if (vt[i] == 0 && ig[i] == 0) {\n      q = new_queue(size);\n      enqueue(q, i);\n      while (!EMPTY_QUEUE(q)) {\n        m = dequeue(q);\n        vt[m] = 1;\n        ts->arr[ts->i++] = m;\n        for (j = 0; j < g[m].i; ++j) {\n          n = g[m].arr[j];\n          if (vt[n] == 1) continue;\n          if (--ig[n] == 0) enqueue(q, n);\n        }\n      }\n      free_queue(q);\n    }\n  }\n}\n\nint main(int argc, char **argv) {\n  int v, e, i, k, l, *vt, *ig; // visited, in-degree\n  varr_t ts, *g; // topological sorted array, graph\n\n  scanf(\"%d %d\", &v, &e);\n  vt = (int *) malloc(sizeof(int) * v);\n  ig = (int *) malloc(sizeof(int) * v);\n  ts.size = v;\n  ts.i = 0;\n  ts.arr = (int *) malloc(sizeof(int) * ts.size);\n  g = (varr_t *) malloc(sizeof(varr_t) * v);\n  for (i = 0; i < v; ++i) {\n    vt[i] = ig[i] = 0;\n    g[i].size = DEFAULT_VARR_SIZE;\n    g[i].i = 0;\n    g[i].arr = (int *) malloc(sizeof(int) * g[i].size);\n  }\n  for (i = 0; i < e; ++i) {\n    scanf(\"%d %d\", &k, &l);\n    if (g[k].i == g[k].size) {\n      g[k].size *= 2;\n      g[k].arr = (int *) realloc(g[k].arr, sizeof(int) * g[k].size);\n    }\n    g[k].arr[g[k].i++] = l;\n    ig[l]++;\n  }\n  topological_sort(v, vt, ig, &ts, g);\n  for (i = 0; i < ts.i; ++i) printf(\"%d\\n\", ts.arr[i]);\n  free(vt); free(ig); free(ts.arr);\n  for (i = 0; i < v; ++i) free(g[i].arr);\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "/**\n * 幅優先でトポロジカルソート\n */\nfun main(args: Array<String>) {\n\n    Main.init()\n\n    Main.execute()\n\n    Main.display()\n}\n\nclass Main {\n\n    companion object {\n\n        // 連結リスト\n        private val graphMatrix = arrayListOf<ArrayList<Int>>()\n\n        private val nodeList = arrayListOf<Node>()\n        private val out = arrayListOf<Int>()\n\n        private val Q = Queue(arrayListOf())\n\n        fun init() {\n            val (nodeNum, lineNum) = readLine()!!.split(\" \")\n\n            for (index in 1..nodeNum.toInt()) {\n                graphMatrix.add(arrayListOf())\n                nodeList.add(Node())\n            }\n\n            for (index in 1..lineNum.toInt()) {\n                val (from, to) = readLine()!!.split(\" \")\n                // 連結リストに保存\n                graphMatrix[from.toInt()].add(to.toInt())\n                // 入次数を記録\n                nodeList[to.toInt()].indeg++\n            }\n        }\n\n        fun execute() {\n            for (index in 0 until graphMatrix.size) {\n                // 入次数が0の場合は、計算できる\n                if (nodeList[index].color == Node.COLOR.WHITE && nodeList[index].indeg == 0) {\n                    nodeList[index].color = Node.COLOR.GRAY\n                    Q.enqueue(index)\n                    bfs()\n                }\n            }\n        }\n\n        fun bfs() {\n            while(!Q.isEmpty()) {\n                val dequedIndex = Q.dequeue()!!\n\n                out.add(dequedIndex)\n\n                graphMatrix[dequedIndex].forEach {\n                    // つながりを切る\n                    nodeList[it].indeg--\n\n                    // 入次数が0の場合は、計算できる\n                    if (nodeList[it].color == Node.COLOR.WHITE && nodeList[it].indeg == 0) {\n                        // 計算済みとする\n                        nodeList[it].color = Node.COLOR.GRAY\n                        // 計算候補に追加\n                        Q.enqueue(it)\n                    }\n                }\n            }\n        }\n\n        fun display() {\n            println(out.joinToString(\"\\n\"))\n        }\n\n    }\n}\n\nclass Node {\n    /**\n     * GRAYは計算完了済。\n     */\n    enum class COLOR {\n        WHITE,\n        GRAY\n    }\n\n    var indeg: Int = 0\n\n    var color: COLOR = COLOR.WHITE\n}\n\nclass Queue(list: MutableList<Int>) {\n\n    var items: MutableList<Int> = list\n\n    fun isEmpty(): Boolean = items.isEmpty()\n\n\n    fun contains(i: Int): Boolean = items.contains(i)\n\n    fun size(): Int = items.count()\n\n    override fun toString() = items.toString()\n\n    fun enqueue(element: Int) {\n        items.add(element)\n    }\n\n    fun dequeue(): Int? {\n        if (this.isEmpty()) {\n            return null\n        } else {\n            return items.removeAt(0)\n        }\n    }\n\n    fun peek(): Int? {\n        return items[0]\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nclass Node(val Id:Int) {\n    private var mEdgesTo:LinkedList<Node> = LinkedList()\n    private var mCountEdgesFromOther:Int = 0\n    companion object {\n        fun SetEdge(from:Node, to:Node):Unit {\n            from.mEdgesTo.push(to)\n            ++to.mCountEdgesFromOther\n        }\n    }\n    fun CanBeFirst():Boolean = mCountEdgesFromOther == 0\n    fun UseNode():List<Node> {\n        return mEdgesTo.filter { --it.mCountEdgesFromOther == 0}\n    }\n}\nfun main(args:Array<String>):Unit{\n    val (v, e) = readLine()!!.split(' ').map(String::toInt)\n    val nodes = Array(v){Node(it)}\n    for (i in 0 until e){\n        val (s, t) = readLine()!!.split(' ').map(String::toInt)\n        Node.SetEdge(nodes[s], nodes[t])\n    }\n    val canBeFirst = nodes.filter{it.CanBeFirst()}.toMutableList()\n    while (!canBeFirst.isEmpty()){\n        val first = canBeFirst.first()\n        canBeFirst.removeAt(0)\n        println(first.Id)\n        canBeFirst += first.UseNode()\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Iterator;\n\nclass Graph {\n\tprivate int totalVertex;\n\tint[] path;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\t//adjacency list of edges\n\tpublic Graph() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tint edges = in.nextInt();\n\t\tpath = new int[totalVertex];\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t\tpath[i] = 0;\n\t\t\t}\t\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint vert = in.nextInt();\n\t\t\t\tint edge = in.nextInt();\n\t\t\t\tpath[edge] += 1;\n\t\t\t\tadjList.get(vert).add(edge);\n\t\t\t\t\n\t\t}\n\t\tin.close();\n\t}\n\tpublic void printAdjMatrix() {\n\t\tQueue<Integer> vertices = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < adjList.size(); i++) {\n\t\t\tif(path[i] == 0) {\n\t\t\t\tvertices.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(vertices.size() != 0) {\n\t\t\tint vertice = vertices.poll();\n\t\t\tSystem.out.println(vertice);\n\t\t\tfor(Integer v :adjList.get(vertice)) {\n\t\t\t\tpath[v] = path[v] - 1;\n\t\t\t\tif(path[v] == 0) {\n\t\t\t\t\tvertices.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//change class name GraphRepresentation to Main() for submission to AIZU\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\tg.printAdjMatrix();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Stack;\nimport java.util.Queue;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Iterator;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate ArrayList<LinkedList<Integer>> adjList;\n\tprivate int[][] adjMatrix;\n\t//adjacency list of edges\n\tpublic Graph() { totalVertex = 0; }\n\t/*\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tint idx1 = in.nextInt() - 1;\n\t\t\tint degree = in.nextInt();\n\t\t\t//System.out.println(\"mark idx1 = \" + idx1 + \" degree = \" + degree);\n\t\t\tfor(int j = 0; j < degree; j ++) {\n\t\t\t\tint idx2 = in.nextInt() - 1;\n\t\t\t\ttmp.add(idx2);\n\t\t\t}\t\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\tin.close();\n\t}\n\n\tpublic void BfsSP() {\n\t\tint[] distances = new int[totalVertex];\n\t\tboolean[] visited = new boolean[totalVertex];\n\t\tfor (int i = 1; i < distances.length; i++) {\n\t\t\tdistances[i] = -1;\n\t\t}\n\n\t\tQueue<Integer> unvisitedNodes = new LinkedList<>();\n\t\tunvisitedNodes.add(0);\n\n\t\twhile (!unvisitedNodes.isEmpty()) {\n\t\t\tint currVertex = unvisitedNodes.poll();\n\t\t\tvisited[currVertex] = true;\n\t\t\tLinkedList<Integer> neighborList = adjList.get(currVertex);\n\t\t\tfor (Integer neighbor : neighborList) {\n\t\t\t\tif (!visited[neighbor]) {\n\t\t\t\t\tunvisitedNodes.add(neighbor);\n\t\t\t\t\tint newDistance = distances[currVertex] + 1;\n\t\t\t\t\tdistances[neighbor] = distances[neighbor] == -1 ? newDistance : Math.min(distances[neighbor], newDistance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < distances.length; i++) {\n\t\t\tSystem.out.println((i + 1) + \" \" + distances[i]);\n\t\t}\n\t}\n\t*/\n\n\tpublic void loadAdjList() {\n\t\tScanner input = new Scanner(System.in);\n\t\ttotalVertex = input.nextInt();\n\t\tint totalEdges = input.nextInt();\n\n\t\tadjList = new ArrayList<>(totalVertex);\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tadjList.add(new LinkedList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < totalEdges; i++) {\n\t\t\tint src = input.nextInt();\n\t\t\tint dest = input.nextInt();\n\t\t\tadjList.get(src).add(dest);\n\t\t}\n\t\tinput.close();\n\t}\n\n\tpublic void loadAdjMatrix() {\n\t\tadjMatrix = new int[totalVertex][totalVertex];\n\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tLinkedList<Integer> neighborList = adjList.get(i);\n\t\t\tfor (Integer neighbor : neighborList) {\n\t\t\t\tadjMatrix[i][neighbor] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void topologicalSort() {\n\t\tint[] indegree = new int[totalVertex];\n\t\tQueue<Integer> eligibleNodes = new LinkedList<>();\n\n\t\tfor (int i = 0; i < adjList.size(); i++) {\n\t\t\tLinkedList<Integer> neighborList = adjList.get(i);\n\t\t\tfor (Integer neighbor : neighborList) {\n\t\t\t\tindegree[neighbor]++;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\teligibleNodes.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!eligibleNodes.isEmpty()) {\n\t\t\tint currVertex = eligibleNodes.poll();\n\t\t\tSystem.out.println(currVertex);\n\n\t\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\t\tif (adjMatrix[currVertex][i] == 1) {\n\t\t\t\t\tindegree[i]--;\n\t\t\t\t\tif (indegree[i] == 0) {\n\t\t\t\t\t\teligibleNodes.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void recursiveTopological() {\n\t\tStack<Integer> output = new Stack<>();\n\t\tboolean[] visited = new boolean[totalVertex];\n\t\t\n\t\tfor (int i = 0 ; i < totalVertex; i++) {\n\t\t\tif (!visited[i]) {\n\t\t\t\thelperRecursiveTop(i, visited, output);\n\t\t\t}\n\t\t}\n\n\t\twhile (!output.isEmpty()) {\n\t\t\tSystem.out.println(output.pop());\n\t\t}\n\t}\n\n\tpublic void helperRecursiveTop(int vertex, boolean[] visited, Stack<Integer> output) {\n\t\tvisited[vertex] = true;\n\t\tLinkedList<Integer> neighborList = adjList.get(vertex);\n\n\t\tfor (Integer neighbor : neighborList) {\n\t\t\tif (!visited[neighbor]) {\n\t\t\t\thelperRecursiveTop(neighbor, visited, output);\n\t\t\t}\n\t\t}\n\n\t\toutput.push(vertex);\n\t}\n}\n\n//change class name GraphRepresentation to Main() for submission to AIZU\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\tg.loadAdjMatrix();\n\t\t// g.BfsSP();\n\t\t// g.topologicalSort();\n\t\tg.recursiveTopological();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*; \nimport java.util.*; \n  \nclass Graph { \n    ArrayList<Integer> adjArr[];\n  \n    @SuppressWarnings(\"unchecked\")\n\tGraph(int v) {\n        adjArr = new ArrayList[v]; \n        for (int i=0; i < v; ++i) \n            adjArr[i] = new ArrayList<Integer>(); \n    } \n  \n    // Add directed pair to graph\n    void addToGraph(int id, int neighbor) { \n    \tadjArr[id].add(neighbor); \n    \t}\n    \n    // Topologically sorts adjacency list graph into a stack\n    void topsort(int v, boolean visited[], Stack<Integer> stack) {  \n        // Mark current as visited\n    \tvisited[v] = true; \n        int i; \n\n        Iterator<Integer> it = adjArr[v].iterator(); \n        while (it.hasNext()) { \n            i = it.next(); \n            // Topsort through all unvisited adjacent vertices before adding to stack\n            if (!visited[i]) \n                topsort(i, visited, stack); \n        } \n        stack.push(v); \n    }\n}\n\npublic class Main {\n  \n    public static void main(String args[]) \n    { \n    \tScanner in = new  Scanner(System.in);\n\n\t\tint totalVertex = in.nextInt();\n\t\tGraph adj = new Graph(totalVertex);\n\t\t\n\t\tint totalConnections = in.nextInt();\n\t\t\n\t\tint id, neighbor;\n\t\t\n\t\tfor (int i = 0; i < totalConnections; i++) {\n\t\t\tid = in.nextInt();\n\t\t\tneighbor = in.nextInt();\n\t\t\tadj.addToGraph(id, neighbor);\n\t\t}\n\t\t\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\n\t\tboolean[] visited = new boolean[totalVertex];\n\t\t// Initialize visited array with false\n\t\tfor(int i = 0; i < totalVertex; i++){\n\t\t\tvisited[i] = false;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tadj.topsort(i, visited, stack);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!stack.isEmpty()) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n int[][] e=new int[E][],re=new int[E][];\n for(int i=0;i<E;i++){\n  e[i]=new int[]{ir.nextInt(),ir.nextInt(),1};\n  re[i]=new int[]{e[i][1],e[i][0],e[i][2]};\n }\n int[][][] g=make_graph(V,e),rg=make_graph(V,re);\n ArrayList<Integer> ord=new ArrayList<>();\n boolean[] vis=new boolean[V];\n for(int i=0;i<V;i++) if(rg[i].length==0) TopologicalSort(i,g,vis,ord);\n for(int v : ord) out.println(v);\n}\n\npublic static void TopologicalSort(int now,int[][][] g,boolean[] vis,ArrayList<Integer> ord){\n for(int i=0;i<g[now].length;i++){\n  if(!vis[g[now][i][0]]) TopologicalSort(g[now][i][0],g,vis,ord);\n }\n ord.add(now);\n}\n\npublic static int[][][] make_graph(int n,int[][] e){\n int[][][] ret=new int[n][][];\n int[] cnt=new int[n];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  cnt[e[i][0]]++;\n }\n for(int i=0;i<n;i++)\n  ret[i]=new int[cnt[i]][];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  ret[e[i][0]][ret[e[i][0]].length-cnt[e[i][0]]--]=new int[]{e[i][1],e[i][2]};\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<edgeCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList<Integer> result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        \n        int V = Integer.parseInt(sc.next());\n        int E = Integer.parseInt(sc.next());\n        \n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for(int i = 0; i < V; i++){\n            graph.put(i, new ArrayList<>());\n        }\n        int[] indeg = new int[V];\n        for(int i = 0; i < E; i++){\n            int s = Integer.parseInt(sc.next());\n            int t = Integer.parseInt(sc.next());\n            graph.get(s).add(t);\n            indeg[t]++;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\n        for(int i = 0; i < V; i++){\n            if(indeg[i] == 0) queue.add(i);\n        }\n        while(!queue.isEmpty()){\n            int u = queue.poll();\n            list.add(u);\n            for (Integer v : graph.get(u)) {\n                indeg[v]--;\n                if(indeg[v] == 0) queue.add(v);\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < V; i++){\n            sb.append(list.get(i)).append(System.lineSeparator());\n        }\n        System.out.print(sb);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    static class Vertex {\n        int v;\n        Set<Integer> vs;\n\n        public Vertex(int v) {\n            this.v = v;\n            this.vs = new HashSet<>();\n        }\n    }\n\n    public static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n    \n            Vertex[] g = new Vertex[n];\n            for (int i = 0; i < n; i++)\n                g[i] = new Vertex(i);\n\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g[f].vs.add(t);\n            }\n\n            topologicalSort(g, n);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n    private static int getIndegree(Vertex[] g, int v) {\n        int c = 0;\n        for (int i = 0; i < g.length; i++) {\n            if (g[i].vs.contains(v))\n                c++;\n        }\n\n        return c;\n    }\n\n    private static List<Integer> getAdjacentVertices(Vertex[] g, int v) {\n        List<Integer> vs = new ArrayList<>(g[v].vs);\n        vs.sort((x, y) -> Integer.compare(x, y));\n\n        return vs;\n    }\n\n    private static void topologicalSort(Vertex[] g, int n) {\n        Queue<Integer> q = new ArrayDeque<>();\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int d = getIndegree(g, i);\n\n            if (d == 0)\n                q.add(i);\n\n            m.put(i, d);\n        }\n\n        List<Integer> vs = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int v = q.remove();\n            out.println(v);\n\n            for (int vv : getAdjacentVertices(g, v)) {\n                int d = m.get(vv)-1;\n\n                if (d == 0)\n                    q.add(vv);\n\n                m.replace(vv, d);\n            }\n        }\n\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\t\n\tint totalVertex;\n\tArrayList<LinkedList<Integer>> adjList;\n\t\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tint totalEdges = in.nextInt();\n\t\tadjList = new ArrayList<>();\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tadjList.add(new LinkedList<Integer>());\n\t\t}\n\t\tfor(int i = 0; i < totalEdges; i++) {\n\t\t\tint source = in.nextInt();\n\t\t\tint edge = in.nextInt();\n\t\t\tadjList.get(source).add(edge);\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tpublic void topoSort() {\n\t\tStack<Integer> stack = new Stack<>();\n\t\tboolean[] visited = new boolean[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(!visited[i]) { //runs DFS on all nodes (even unconnected graphs)\n\t\t\t\tDFS(i, visited, stack);\n\t\t\t}\n\t\t}\n\t\twhile(!stack.isEmpty()) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n\t}\n\tpublic void DFS(int node, boolean[] visited, Stack<Integer> stack) {\n\t\tvisited[node] = true;\n\t\tLinkedList<Integer> neighbors = adjList.get(node);\n\t\tfor(Integer n : neighbors){ //alwasy use enhanced for loop for LL bc otherwise running n squared\n\t\t\tif(!visited[n]) {\n\t\t\t\tDFS(n, visited, stack); //this callse dfs on all unvisited neighbors\n\t\t\t}\n\t\t}\n\t\tstack.push(node); //now we are allowed to put the original node on the stack bc we finished traversing the childresn\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain Graph = new Main();\n\t\tGraph.loadAdjList();\n\t\tGraph.topoSort();\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tvis = new boolean[V];\n\t\tord = new int[V];\n\t\tpending = new boolean[V];\n\n\t\ttopologialSort();\n\n\t\tfor (int i = V - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\n\t}\n\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int V, E;\n\tstatic int[] ord;\n\tstatic int now = 0;\n\n\tstatic void topologialSort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tpending[cur]=true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to] && pre != cur){\n\t\t\t\tif(pending[to])throw new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tvis[cur] = true;\n\t\tord[now++] = cur;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static ArrayList<LinkedList<Integer>> graph;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.add(new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n        }\n\n        boolean[] visited = new boolean[V];\n        ArrayList<Integer> result = new ArrayList<>(V);\n\n        for(int i = 0; i < V; ++i){\n            if(!visited[i]){\n                dfs(i, visited, result);\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(int i = V - 1; i >= 0; --i){\n            printWriter.println(result.get(i));\n        }\n        printWriter.flush();\n    }\n\n    private static void dfs(int u, boolean[] visited, ArrayList<Integer> result){\n        visited[u] = true;\n        for(Integer v : graph.get(u)){\n            if(!visited[v]){\n                dfs(v, visited, result);\n            }\n        }\n\n        result.add(u);\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n    public static class TopologicalSort_DFS {\n\n        boolean hasCycle;\n        LinkedList<Integer> sortedOrder;\n        TreeSet<Integer> unmarkedV;\n        int[] markStatus;\n        final int MARK_TEMP = 1;\n        final int MARK_PERM = 2;\n\n        public TopologicalSort_DFS(WeightedDigraph graph) {\n            markStatus = new int[graph.numVertex];\n            unmarkedV = new TreeSet<Integer>();\n            for (int v = 0; v < graph.numVertex; v++) {\n                unmarkedV.add(v);\n            }\n            sortedOrder = new LinkedList<Integer>();\n\n            try {\n                while (!unmarkedV.isEmpty()) {\n                    int v = unmarkedV.first();\n                    dfs(v, graph);\n                }\n            } catch (Exception ex) {\n                hasCycle = true;\n                sortedOrder.clear();\n            }\n        }\n\n        private void dfs(int vert, WeightedDigraph graph) throws Exception {\n            if (markStatus[vert] == MARK_TEMP) {\n                throw new Exception(\"cycle deteced v:\" + vert);\n            }\n            if (unmarkedV.contains(vert)) {\n                markStatus[vert] = MARK_TEMP;\n                for (WeightedDigraph.Edge edge : graph.srcEdges[vert]) {\n                    dfs(edge.targetVertex, graph);\n                }\n                unmarkedV.remove(vert);\n                markStatus[vert] = 0;\n                sortedOrder.addFirst(vert);\n            }\n        }\n\n        public boolean hasCycle() {\n            return hasCycle;\n        }\n\n        public Iterator<Integer> sortedOrder() {\n            return sortedOrder.iterator();\n        }\n    }\n\n    public static class WeightedDigraph {\n\n        int numVertex;\n        int numEdge;\n\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedDigraph(int numV, int numE) {\n            this.numVertex = numV;\n            this.numEdge = numE;\n            srcEdges = new List[numV];\n\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n        }\n\n        public static class Edge {\n\n            int srcVertex;\n            int targetVertex;\n            int weight;\n\n            public Edge(int srcVertex, int targetVertex, int weight) {\n                this.srcVertex = srcVertex;\n                this.targetVertex = targetVertex;\n                this.weight = weight;\n            }\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int v = in.nextInt();\n        int e = in.nextInt();\n        WeightedDigraph graph = new WeightedDigraph(v, e);\n        while (e-- > 0) {\n            graph.addEdge(in.nextInt(), in.nextInt(), 1);\n        }\n        TopologicalSort_DFS topSort = new TopologicalSort_DFS(graph);\n        Iterator<Integer> it = topSort.sortedOrder();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor (int i = lis.size() - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre, ArrayList<Integer>[] g) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (pre != cur && !vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tvis[cur] = true;\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class\nMain\n{\n  @SuppressWarnings(\"unchecked\")\n  public void\n  run (\n    java.io.InputStream in,\n    java.io.PrintStream out\n    )\n  {\n    java.util.Scanner sc = new java.util.Scanner ( in );\n    java.util.List[ ] G;\n    int[ ] res;\n    int n, m;\n    int i;\n\n    n = sc.nextInt ( );\n    m = sc.nextInt ( );\n\n    G  = new java.util.List[ n ];\n    for ( i = 0; i < G.length; ++i )\n      G[ i ] = new java.util.LinkedList ( );\n    for ( i = 0; i < m; ++i )\n    {\n      int s, t;\n\n      s = sc.nextInt ( );\n      t = sc.nextInt ( );\n      G[ s ].add ( t );\n    }\n\n    res = topologicalSort ( convertGraph ( G ) );\n    for ( i = 0; i < res.length; ++i )\n      out.println ( res[ i ] );\n\n    sc.close ( );\n  }\n\n  /** ??°?????????List ??¨???????¨?????????????????????? */\n  private static int[ ][ ]\n  convertGraph (\n    java.util.List[ ] G\n    )\n  {\n    int[ ][ ] r = new int[ G.length ][ ];\n    java.util.Iterator it;\n    int i, j;\n   \n    for ( i = 0; i < r.length; ++i )\n    {\n      r[ i ] = new int[ G[ i ].size ( ) ];\n      for ( j = 0, it = G[ i ].iterator ( ); it.hasNext ( ); ++j )\n        r[ i ][ j ] = ( (Integer)it.next ( ) ).intValue ( );\n    }\n   \n    return ( r );\n  }\n\n  private static int[ ]\n  topologicalSort (\n    int[ ][ ] G\n    )\n  {\n    java.util.Queue<Integer> lis = new java.util.LinkedList<Integer> ( );\n    int[ ] deg = new int[ G.length ];\n    int[ ] res = new int[ G.length ];\n    int sp = 0;\n    int i, j;\n\n    for ( i = 0; i < G.length; ++i )\n    for ( j = 0; j < G[ i ].length; ++j )\n      ++deg[ G[ i ][ j ] ];\n\n    for ( i = 0; i < G.length; ++i )\n    {\n      lis.add ( i );\n      while ( !lis.isEmpty ( ) )\n      {\n        final int s = lis.poll ( );\n        if ( deg[ s ] == 0 )\n        {\n          res[ sp++ ] = s;\n          deg[ s ] = -1;\n          for ( j = 0; j < G[ s ].length; ++j )\n          {\n            --deg[ G[ s ][ j ] ];\n            lis.add ( G[ s ][ j ] );\n          }\n        }\n      }\n    }\n\n    return ( res );\n  }\n\n  public static void\n  main (\n    String[ ] args\n    )\n  {\n    ( new Main ( ) ).run ( System.in, System.out );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static LinkedList[] graph;\n    private static int[] in;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new LinkedList[V];\n        in = new int[V];\n        for(int i = 0; i < V; ++i){\n            graph[i] = new LinkedList<Integer>();\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            ++in[v];\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(in[i] == 0){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Object adj : graph[u]){\n                int v = ((Integer) adj).intValue();\n                --in[v];\n                if(in[v] == 0){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    public static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n            int[][] g = new int[n][n];\n    \n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g[f][t] = 1;\n            }\n\n            topologicalSort(g, n);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n    private static int getIndegree(int[][] g, int v) {\n        int c = 0;\n        for (int i = 0; i < g.length; i++) {\n            if (g[i][v] == 1)\n                c++;\n        }\n\n        return c;\n    }\n\n    private static void topologicalSort(int[][] g, int n) {\n        Queue<Integer> q = new ArrayDeque<>();\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int d = getIndegree(g, i);\n\n            if (d == 0)\n                q.add(i);\n\n            m.put(i, d);\n        }\n\n        while (!q.isEmpty()) {\n            int v = q.remove();\n            out.println(v);\n\n            for (int i = 0; i < n; i++) {\n                if (g[v][i] == 1) {\n                    int d = m.get(i)-1;\n\n                    if (d == 0)\n                        q.add(i);\n\n                    m.replace(i, d);\n                }\n            }\n        }\n\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayDeque<Integer> ans=topological_sort(e,0);\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tSystem.out.println(ans.poll());\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayDeque<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayDeque<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Iterator;\nimport java.util.Stack;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tprivate boolean[] visited;\n\tprivate int[] inDegree;\n\tStack<Integer> myStack = new Stack<Integer>(); \n\t\n\t//adjacency list of edges\n\tpublic Graph() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tinDegree = new int[totalVertex];\n\t\tvisited = new boolean[totalVertex]; // default value is false\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i< totalEdge; i++) {\n\t\t\tint source = in.nextInt();\n\t\t\tint target = in.nextInt();\n\t\t\tadjList.get(source).add(target);\n\t\t\tinDegree[target] += 1;\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tpublic void printAdjMatrix() {\n\t\tInteger[][] adjMatrix = new Integer[totalVertex][totalVertex];\n\t\tLinkedList<Integer> tempNode;\n\t\tIterator<LinkedList<Integer>> outer = adjList.iterator();\n\t\tint  rw = 0;\n\t\twhile (outer.hasNext()) {\n\t\t\ttempNode = outer.next();\n\t\t\tIterator<Integer> inner = tempNode.iterator();\n\t\t\twhile(inner.hasNext()) {\n\t\t\t\tadjMatrix[rw][inner.next()] = 1;\n\t\t\t}\n\t\t\trw++;\n\t\t}\n\t\t\t\n\t\tfor(int i = 0; i<totalVertex;i++) {\n\t\t\tfor (int j = 0; j < totalVertex; j++) {\n\t\t\t\tif (adjMatrix[i][j] != null) {\n\t\t\t\t\tSystem.out.print(adjMatrix[i][j]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(0);\n\t\t\t\t}\n\t\t\t\tif (j != totalVertex-1) {\n\t\t\t\t\tSystem.out.print(\" \");\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(); \n\t\t}\n\t}\n\t\n\tpublic LinkedList<Integer> initialNode() {\n\t\tLinkedList<Integer> initialNode = new LinkedList<Integer>();\n\t\t// get a node with inDegree = 0\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\tinitialNode.add(i);\n\t\t\t}\n\t\t}\n\t\treturn initialNode;\n\t}\n\t\n\tpublic void DFS(int row) {\n\t\tvisited[row] = true;\n\t\tLinkedList<Integer> neighbors = adjList.get(row);\n\t\tfor(int i = 0; i < neighbors.size(); i ++) {\n\t\t\tint v1 = neighbors.get(i);\n\t\t\tif(visited[v1] == false) {\n\t\t\t\tDFS(v1);\n\t\t\t}\n\t\t}\n\t\tmyStack.add(row);\n\t}\n\tpublic int getVertex() {\n\t\treturn totalVertex;\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\t// g.printAdjMatrix();\n\t\t// System.out.println();\n\t\t\n\t\tLinkedList<Integer>  myInitial = g.initialNode();\n\t\tfor (int i = 0; i < myInitial.size(); i++) {\n\t\t\tg.DFS(myInitial.get(i)); // check every inDegree = 0 node\n\t\t}\n\t\t\n\t\twhile(!g.myStack.empty()) {\n\t\t\tSystem.out.println(g.myStack.pop());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic List<Integer> g[];\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void solve() {\n\t\tint v = ni(), e = ni();\n\t\tg = new ArrayList[v];\n\t\tfor(int i=0;i<v;i++)g[i] = new ArrayList<>();\n\t\tfor(int i=0;i<e;i++) {\n\t\t\tint s = ni(), t = ni();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tused = new boolean[v];\n\t\tfor(int i=0;i<v;i++) {\n\t\t\tif(!used[i])dfs(i);\t\t\t\n\t\t}\n\t\treverse(ans);\n\t\tfor(int t:ans) {\n\t\t\tout.println(t);\n\t\t}\n\t}\n\t\n\tstatic boolean used[];\n\tstatic List<Integer> ans = new ArrayList<>();\n\tstatic void dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int to:g[v]) {\n\t\t\tif(!used[to])dfs(to);\n\t\t}\n\t\tans.add(v);\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilderに改行文字をappendする\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:数値でないリストを二分探索しています。\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:数値でないリストを二分探索しています。\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:数値でないリストを二分探索しています。\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:数値でないリストを二分探索しています。\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Node {\n\tpublic int id;\n\tpublic LinkedList<Node> sources;\n\tpublic LinkedList<Node> targets;\n\t\n\tpublic Node(int id) {\n\t\tthis.id = id;\n\t\tsources = new LinkedList<>();\n\t\ttargets = new LinkedList<>();\n\t}\n}\n\npublic class Main {\n\tpublic static boolean[] visited = null;\n\t\n\tpublic static Stack<Integer> topologicalSort(Stack<Node> nodes, int overallLength) {\n\t\tStack<Integer> result = new Stack<Integer>();\n\t\tboolean[] visited = new boolean[overallLength];\n\t\t\n\t\t//go up the graph\n\t\twhile (!nodes.isEmpty()) {\n\t\t\tNode currentNode = nodes.pop();\n\t\t\tresult.push(currentNode.id);\n\t\t\tvisited[currentNode.id] = true;\n\t\t\t\n\t\t\t//go through sources. If we have visited all the targets, we can add it to stack\n\t\t\tfor (int i = 0; i < currentNode.sources.size(); i++) {\n\t\t\t\tNode currentSource = currentNode.sources.get(i);\n\t\t\t\tboolean isGood = true;\n\t\t\t\tfor (int j = 0; j < currentSource.targets.size(); j++) {\n\t\t\t\t\tif (!visited[currentSource.targets.get(j).id]) {\n\t\t\t\t\t\tisGood = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isGood) nodes.push(currentSource);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint numVerticies = scanner.nextInt();\n\t\tint numEdges = scanner.nextInt();\n\t\tNode[] nodes = new Node[numVerticies];\n\t\tvisited = new boolean[numVerticies];\n\t\t\n\t\t//creating all nodes as empty\n\t\tfor (int i = 0; i < numVerticies; i++) {\n\t\t\tnodes[i] = new Node(i);\n\t\t}\n\t\t\n\t\t//creating all relations to nodes\n\t\tfor (int i = 0; i < numEdges; i++) {\n\t\t\tint source = scanner.nextInt();\n\t\t\tint target = scanner.nextInt();\n\t\t\t\n\t\t\tnodes[source].targets.add(nodes[target]);\n\t\t\tnodes[target].sources.add(nodes[source]);\n\t\t}\n\t\tscanner.close();\n\t\t\n\t\t//create Stack with only nodes that doesn't point to anything\n\t\tStack<Node> rootNodes = new Stack<>();\n\t\tfor (int i = 0; i < nodes.length; i++) {\n\t\t\tif (nodes[i].targets.isEmpty()) {\n\t\t\t\trootNodes.push(nodes[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//topological sort\n\t\tStack<Integer> results = topologicalSort(rootNodes, nodes.length);\n\t\twhile (!results.isEmpty()) {\n\t\t\tSystem.out.println(results.pop());\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Iterator;\nimport java.util.Stack;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tGraph g = new Graph();\n\t\tg.load_from_edgelist();\n\t\tg.helper();\n\t\twhile(!g.get_order().isEmpty()) {\n\t\t\tSystem.out.println(g.get_order().pop());\n\t\t}\n\t}\n}\n\nclass Graph {\n\t\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tprivate boolean[] if_visited;\n\tprivate int[] discover_time;\n\tprivate int[] complete_time;\n\tprivate int[] id;\n\tprivate static int timestamp = 1;\n\tprivate int[] dist;\n\tprivate Stack<Integer> order = new Stack<>();\n\t\n\tpublic Stack<Integer> get_order(){\n\t\treturn order;\n\t}\n\t\n\tpublic boolean[] getVisited() {\n\t\treturn if_visited;\n\t}\n\t\n\tpublic int[] getDistance() {\n\t\treturn dist;\n\t}\n\t\n\t//adjacency list of edges\n\tpublic Graph() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\ttotalVertex = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tif_visited = new boolean[totalVertex];\n\t\tdiscover_time = new int[totalVertex];\n\t\tcomplete_time = new int[totalVertex];\n\t\tid = new int[totalVertex];\n\t\tdist = new int[totalVertex];\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tint idx1 = in.nextInt() - 1;\n\t\t\tif_visited[idx1] = false;\n\t\t\tid[idx1] = i;\n\t\t\tdist[idx1] = 0;\n\t\t\tint degree = in.nextInt();\n\t\t\t//System.out.println(\"mark idx1 = \" + idx1 + \" degree = \" + degree);\n\t\t\tfor(int j = 0; j < degree; j ++) {\n\t\t\t\tint idx2 = in.nextInt() - 1;\n\t\t\t\ttmp.add(idx2);\n\t\t\t}\t\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tpublic void load_from_edgelist() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tint totalEdges = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tif_visited = new boolean[totalVertex];\n\t\t//discover_time = new int[totalVertex];\n\t\t//complete_time = new int[totalVertex];\n\t\tid = new int[totalVertex];\n\t\t\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tif_visited[i] = false;\n\t\t\tid[i] = i;\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < totalEdges; i++) {\n\t\t\tint idx1 = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tadjList.get(idx1).add(v);\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tpublic void printAdjMatrix() {\n\t\tInteger[][] adjMatrix = new Integer[totalVertex][totalVertex];\n\t\t//complete the following\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tfor (int j = 0; j< totalVertex; j++) {\n\t\t\t\tif (adjList.get(i).contains(j)) {\n\t\t\t\t\tadjMatrix[i][j] = 1;\n\t\t\t\t}else {\n\t\t\t\t\tadjMatrix[i][j] = 0;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif (j == totalVertex - 1) {\n\t\t\t\t\tSystem.out.println(adjMatrix[i][j]);\n\t\t\t\t\t\n\t\t\t\t}else {\n\t\t\t\t\tSystem.out.print(adjMatrix[i][j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void DFS(int id) {\n\t\t\tif_visited[id] = true;\n\t\t\t//discover_time[id] = timestamp;\n\t\t\t//timestamp += 1;\n\t\t\tIterator<Integer> i = adjList.get(id).listIterator();\n\t\t\twhile(i.hasNext()) {\n\t\t\t\tint n = i.next();\n\t\t\t\tif ( !if_visited[n]) {\n\t\t\t\t\tDFS(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\torder.add(id);\n\t\t\t//complete_time[id] = timestamp++;\n\n\t\t\n\t}\n\t\n\tpublic void helper() {\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(!if_visited[i]) {\n\t\t\t\tDFS(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic void show_result() {\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tSystem.out.print(id[i] + 1 + \" \");\n\t\t\tSystem.out.print(discover_time[id[i]] + \" \");\n\t\t\tSystem.out.print(complete_time[id[i]] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic void BFS(int src) {\n\t\tif_visited[src] = true;\n\t\tQueue<Integer> q = new LinkedList<>();\n\t\tq.add(src);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint u = q.remove();\n\t\t\t//if_visited[u] = true;\n\t\t\tLinkedList<Integer> tmp = adjList.get(u);\n\t\t\tfor(int i = 0; i < tmp.size(); i++) {\n\t\t\t\tif(!if_visited[tmp.get(i)]) {\n\t\t\t\t\tif_visited[tmp.get(i)] = true;\n\t\t\t\t\t//if(!q.contains(tmp.get(i))){\n\t\t\t\t\tq.add(tmp.get(i));\n\t\t\t\t\tdist[tmp.get(i)] = dist[u] + 1;\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tvis = new boolean[V];\n\t\tord = new int[V];\n\t\tpending = new boolean[V];\n\n\t\ttopologialSort();\n\n\t\tfor (int i = V - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\n\t}\n\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int V, E;\n\tstatic int[] ord;\n\tstatic int now = 0;\n\n\tstatic void topologialSort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tpending[cur]=true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to] && pre != cur){\n\t\t\t\tif(pending[to])throw new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tvis[cur] = true;\n\t\tord[now++] = cur;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\n\tstatic class TaskX {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint v = in.nextInt(), e = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[v];\n\t\t\tg = Stream.generate(ArrayList::new).limit(v).toArray(List[]::new);\n\t\t\tint[] count = new int[v];\n\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt();\n\t\t\t\tg[s].add(t);\n\t\t\t\tcount[t]++;\n\t\t\t}\n\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tList<Integer> topologicalSortList = new ArrayList<>();\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tif (count[i] == 0) {\n\t\t\t\t\tq.add(i);\n\t\t\t\t\ttopologicalSortList.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint from = q.remove();\n\t\t\t\tfor (int i = 0; i < g[from].size(); i++) {\n\t\t\t\t\tint to = g[from].get(i);\n\t\t\t\t\tcount[to]--;\n\t\t\t\t\tif (count[to] == 0) {\n\t\t\t\t\t\tq.add(to);\n\t\t\t\t\t\ttopologicalSortList.add(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Integer num : topologicalSortList) {\n\t\t\t\tout.println(num);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static HashMap<Integer, List<Integer>> graph;\n    private static HashMap<Integer, List<Integer>> temp;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        temp = new HashMap<>(V);\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n            temp.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n            temp.get(v).add(u);\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(temp.get(i).isEmpty()){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Integer v : graph.get(u)){\n                temp.get(v).remove(u);\n                if(temp.get(v).isEmpty()){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[] kahn(int[][][] g) {\n\t\tint n = g.length, pos = 0;\n\t\tint[] res = new int[n];\n\t\tint[] in = new int[n];\n\t\tfor (int cur=0; cur<n; cur++) {\n\t\t\tfor (int[] to : g[cur]) {\n\t\t\t\tin[to[0]]++;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (in[i] == 0) {\n\t\t\t\tque.add(i);\n\t\t\t}\n\t\t}\n\t\twhile (!que.isEmpty()) {\n\t\t\tint cur = que.pollFirst();\n\t\t\tres[pos++] = cur;\n\t\t\tfor (int[] to : g[cur]) {\n\t\t\t\tif (--in[to[0]] == 0) {\n\t\t\t\t\tque.add(to[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint max = -1;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tmax = Math.max(max, in[i]);\n\t\t}\n\n\t\treturn max == 0 ? res : null;\n\t}\n\n\tstatic int[][][] directedGraph(int n, int[] from, int[] to, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic void solve() {\n\t\tint v = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e];\n\t\tint[] t = new int[e];\n\t\tint[] c = new int[e];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt();\n\t\t\tc[i] = 0;\n\t\t}\n\t\tint[][][] g = directedGraph(v, s, t, c);\n\n\t\tint[] tp = kahn(g);\n\t\tfor (int i=0; i<v; i++) {\n\t\t\tout.println(tp[i]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tList<Integer> g[] = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tTopologicalSort ts = new TopologicalSort(n, m, g);\n\t\tts.init();\n\t\tts.execute();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tSystem.out.println(ts.res[i]);\n\t\t}\n\t}\n\n\tclass TopologicalSort {\n\t\tint N, M, index;\n\t\tint[] indeg, res;\n\t\tboolean[] V;\n\t\tList<Integer> G[];\n\n\t\tpublic TopologicalSort(int n, int m, List<Integer> g[]) {\n\t\t\tsuper();\n\t\t\tN = n;\n\t\t\tM = m;\n\t\t\tG = g;\n\t\t}\n\n\t\tvoid init() {\n\t\t\tindeg = new int[N];\n\t\t\tV = new boolean[N];\n\t\t\tres = new int[N];\n\t\t\tindex = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int e : G[i]) {\n\t\t\t\t\tindeg[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] execute() {\n\t\t\tfor (int u = 0; u < N; u++) {\n\t\t\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\t\t\tbfs(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid bfs(int s) {\n\t\t\tV[s] = true;\n\t\t\tLinkedList<Integer> que = new LinkedList<>();\n\t\t\tque.add(s);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint u = que.poll();\n\t\t\t\tres[index++] = u;\n\t\t\t\tfor (int v : G[u]) {\n\t\t\t\t\tindeg[v]--;\n\t\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\t\tque.add(v);\n\t\t\t\t\t\tV[v] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Iterator;\nimport java.util.Queue;\n\nclass Graph01 {\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tpublic Graph01() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tint totalH = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\tfor(int i = 0; i < totalH; i++) {\n\t\t\tint input1 = in.nextInt();\n\t\t\tint input2 = in.nextInt();\n\t\t\tadjList.get(input1).add(input2);\n\t\t}\n\t\tin.close();\n\t}\n\tpublic void tp() {\n\t\tint[] C = new int[totalVertex];\n\t\tQueue<Integer> Q = new LinkedList<Integer>();\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tLinkedList<Integer> q = adjList.get(i);\n\t\t\tfor(Integer neighbor:q) {\n\t\t\t\tC[neighbor] = C[neighbor] + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <totalVertex; i++) {\n\t\t\tif(C[i] == 0) {\n\t\t\t\tQ.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint answer = Q.poll();\n\t\t\tSystem.out.println(answer);\n\t\t\tLinkedList<Integer> w = adjList.get(answer);\n\t\t\tfor(Integer neig:w) {\n\t\t\t\tC[neig] = C[neig] - 1;\n\t\t\t\tif(C[neig] == 0) {\n\t\t\t\t\tQ.add(neig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n}\n\n//change class name GraphRepresentation to Main() for submission to AIZU\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph01 g = new Graph01();\n\t\tg.loadAdjList();\n\t\tg.tp();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList<Integer> result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class Main{\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tvis = new boolean[V];\n\t\tord = new int[V];\n\n\t\ttopologialSort();\n\n\t\tfor (int i = V - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\n\t}\n\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic int V, E;\n\tstatic int[] ord;\n\tstatic int now = 0;\n\n\tstatic void topologialSort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to] && pre != cur)\n\t\t\t\tdfs(to, cur);\n\t\t}\n\t\tvis[cur] = true;\n\t\tord[now++] = cur;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Iterator;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate int[][] adjList;\n\tprivate int[] degree1;\n\tprivate int[] degree2;\n\tprivate int[] visited;\n\tprivate LinkedList<Integer> previsit = new LinkedList<Integer>();\n\tprivate LinkedList<Integer> postvisit = new LinkedList<Integer>();\n\tpublic Graph() {\n\t\tdegree1 = null;\n\t\tdegree2 = null;\n\t\ttotalVertex = 0;\n\t\ttotalEdge = 0;\n\t\ttotalVertex = 0;\n\t\tadjList = null;\n\t}\n\n\tpublic void loadList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tdegree1 = new int[totalVertex];\n\t\tdegree2 = new int[totalVertex];\n\t\tadjList = new int[totalVertex][totalVertex];\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tdegree1[i] = 0;\n\t\t\tdegree2[i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < totalEdge; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\tint y = in.nextInt();\n\t\t\tadjList[x][degree2[x]] = y;\n\t\t\tdegree1[y]++;\n\t\t\tdegree2[x]++;\n\t\t}\n\t\tin.close();\n\t\tvisited = new int[totalVertex];\n\t\tfor (int i = 0; i < totalVertex; i++)\n\t\t\tvisited[i] = 0;\n\t}\n\t\n\tpublic void DFS(int vertex) {\n\t\tprevisit.add(vertex);\n\t\tvisited[vertex] = 1;\n\t\tfor (int i = 0; i < degree2[vertex]; i++)\n\t\t\tif (visited[adjList[vertex][i]] == 0)\n\t\t\t\tDFS(adjList[vertex][i]);\n\t\tpostvisit.add(vertex);\n\t}\n\tpublic void DFStopological() {\n\t\tfor (int i = 0; i < totalVertex; i++)\n\t\t\tif (degree1[i] == 0)\n\t\t\t\tDFS(i);\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\tIterator<Integer> iterator = postvisit.iterator();\n\t\twhile (iterator.hasNext())\n\t\t\tlist.add(0, iterator.next());\n\t\tdisplay(list);\n\t}\n\tpublic void display (LinkedList<Integer> list) {\n\t\tIterator<Integer> iterator = list.iterator();\n\t\twhile(iterator.hasNext())\n\t\t\tSystem.out.println(iterator.next());\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadList();\n\t\tg.DFStopological();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList queue = new LinkedList();\n\t\tArrayList result = new ArrayList();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\n\t\tList<List<Integer>> rinsetuList = new ArrayList<List<Integer>>();\n\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\trinsetuList.add(new ArrayList<Integer>());\n\t\t}\n\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\trinsetuList.get(nextInt()).add(nextInt());\n\t\t}\n\n\t\tint[] indegrees = new int[v];\n\t\tfor (List<Integer> node : rinsetuList) {\n\t\t\tfor (Integer i : node) {\n\t\t\t\tindegrees[i]++;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < indegrees.length; i++) {\n\t\t\tif (indegrees[i] == 0) {\n\t\t\t\tqueue.addLast(i);\n\t\t\t}\n\t\t}\n\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tint cnt = 0;\n\t\twhile (queue.size() != 0) {\n\t\t\tint index = queue.removeLast();\n\t\t\tres.add(index);\n\n\t\t\tfor (Integer nextDegree : rinsetuList.get(index)) {\n\t\t\t\tint nextCnt = --indegrees[nextDegree];\n\t\t\t\tif (nextCnt == 0) {\n\t\t\t\t\tqueue.addLast(nextDegree);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt > v) {\n\t\t\t\tout.println(\"This graph includes the Cycle\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Integer integer : res) {\n\t\t\tout.println(integer);\n\t\t}\n\n\t}\n\n\t/**\n\t * http://www.thothchildren.com/chapter/5bcc8bc051d9305189030f9f\n\t * https://tubo28.me/algorithm/tsort/\n\t * http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad09/ad09-13.pdf\n\t * https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/\n\t * トポロジカルソート\n\t */\n\tprivate void solveA2() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\n\t\t/*\n\t\t *隣接リストの作成\n\t\t */\n\t\tList<List<Integer>> adj = new ArrayList<List<Integer>>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj.add(new ArrayList<Integer>());\n\t\t}\n\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\tadj.get(from).add(to);\n\t\t}\n\t\t// 入次数が0のものを判定するための配列\n\t\tint indegree[] = new int[v];\n\t\t// 入次数0を判定\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tList<Integer> temp = adj.get(i);\n\t\t\t//iをfromとするnode達\n\t\t\tfor (int node : temp) {\n\t\t\t\t//入次数の個数\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * queueの作成\n\t\t * 入次数0のものをqueueに詰める\n\t\t * 入次数0から調査していく\n\t\t */\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\tq.addLast(i);\n\t\t\t}\n\t\t}\n\n\t\t//訪問済み頂点数\n\t\tint cnt = 0;\n\n\t\t// トポロジカルソートの結果\n\t\tList<Integer> res = new ArrayList<Integer>();\n\n\t\t/*\n\t\t * BFS\n\t\t */\n\t\twhile (!q.isEmpty()) {\n\t\t\t// 接続先の頂点を探索開始\n\t\t\tint u = q.removeFirst();\n\t\t\t//入次数0なのでリザルトにadd\n\t\t\tres.add(u);\n\n\t\t\t/*\n\t\t\t * この頂点の次の接続先の入次数を-する\n\t\t\t * その結果、入次数=0となる場合はソートリザルトに追加し、次の探索に利用する\n\t\t\t */\n\t\t\tfor (int node : adj.get(u)) {\n\n\t\t\t\tindegree[node]--;\n\t\t\t\tif (indegree[node] == 0) {\n\t\t\t\t\tq.addFirst(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt > v) {\n\t\t\t\tSystem.out.println(\"graph内に循環有\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i : res) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n//template code, C343, 2019\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nclass Graph2 {\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\t//adjacency list of edges\n\tpublic Graph2() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\t\n\t\tint edges = in.nextInt();\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < edges; i++) {\n\t\t\tint v1 = in.nextInt();\n\t\t\tint v2 = in.nextInt();\n\t\t\t\n\t\t\tadjList.get(v1).add(v2);\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\t\n\tpublic void printAdjMatrix() {\n\t\tInteger[][] adjMatrix = new Integer[totalVertex][totalVertex];\n\t\t\n\t\tfor (int i = 0; i < adjMatrix.length; i++) {\n\t\t\tfor (int j = 0; j < adjMatrix[0].length; j++) {\n\t\t\t\tadjMatrix[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tLinkedList<Integer> list = adjList.get(i);\n\t\t\t\n\t\t\tIterator<Integer> itr = list.iterator();\n\t\t\twhile(itr.hasNext()) {\n\t\t\t\tadjMatrix[i][itr.next()] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tString ans = \"\";\n\t\tfor (int i = 0; i < adjMatrix.length; i++) {\n\t\t\tfor (int j = 0; j < adjMatrix[0].length; j++) {\n\t\t\t\tif (j == adjMatrix[0].length - 1) {\n\t\t\t\t\tans += adjMatrix[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tans += adjMatrix[i][j] + \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += \"\\n\";\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n\t\n\tpublic static int time = 1;\n\tpublic void dfs(int idx, int[] discover, int[] finish, int[] visited) {\n\t\t\t\n\t\t\t\n\t\t\tdiscover[idx] = time;\n\t\t\ttime++;\n\t\t\tvisited[idx] = 1;\n\t\t\t\n\t\t\tLinkedList<Integer> list = adjList.get(idx);\n\t\t\t\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tint next = list.get(i);\n\t\t\t\t\n\t\t\t\tif (visited[next] == 0) {\n\t\t\t\t\tdfs(next, discover, finish, visited);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfinish[idx] = time;\n\t\t\ttime++;\n\t\t}\n\n\t\n\tpublic int getTotalVertex() {\n\t\treturn totalVertex;\n\t}\n}\n\n//change class name GraphRepresentation to Main() for submission to AIZU\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph2 g = new Graph2();\n\t\tg.loadAdjList();\n\t\t\n\t\t\n\t\tint[] discover = new int[g.getTotalVertex()];\n\t\tint[] finish = new int[g.getTotalVertex()];\n\t\tint[] visited = new int[g.getTotalVertex()];\n\t\t\n\t\tg.dfs(0, discover, finish, visited);\n\t\t\n//\t\tSystem.out.println(Arrays.toString(visited));\n\t\tfor (int i = 0; i < g.getTotalVertex(); i++) {\n\t\t\tif (visited[i] == 0) {\n\t\t\t\tg.dfs(i, discover, finish, visited);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t\t\n\t\tboolean[] vis = new boolean[g.getTotalVertex()];\n\t\t\n\t\tfor (int i = 0; i < g.getTotalVertex(); i++) {\n\t\t\tint max = -1;\n\t\t\tint maxIdx = -1;\n\t\t\t\n\t\t\tfor (int j = 0; j < g.getTotalVertex(); j++) {\n\t\t\t\tif(finish[j] > max && vis[j] == false) {\n\t\t\t\t\tmax = finish[j];\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(Arrays.toString(vis));\n\t\t\t\t\tmaxIdx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvis[maxIdx] = true;\n\t\t\tSystem.out.println(maxIdx);\n\t\t}\n\t\t\n\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\t\tList<Integer>[] adj = new List[v];\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t// Create a array to store indegrees of all\n\t\t// vertices. Initialize all indegrees as 0.\n\t\tint indegree[] = new int[v];\n\n\t\t// Traverse adjacency lists to fill indegrees of\n\t\t// vertices. This step takes O(V+E) time\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tList<Integer> temp = adj[i];\n\t\t\tfor (int node : temp) {\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t// Create a queue and enqueue all vertices with\n\t\t// indegree 0\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0)\n\t\t\t\tq.addLast(i);\n\t\t}\n\n\t\t// Initialize count of visited vertices\n\t\tint cnt = 0;\n\n\t\t// Create a vector to store result (A topological\n\t\t// ordering of the vertices)\n\t\tVector<Integer> topOrder = new Vector<Integer>();\n\t\twhile (!q.isEmpty()) {\n\t\t\t// Extract front of queue (or perform dequeue)\n\t\t\t// and add it to topological order\n\t\t\tint u = q.removeFirst();\n\t\t\ttopOrder.add(u);\n\n\t\t\t// Iterate through all its neighbouring nodes\n\t\t\t// of dequeued node u and decrease their in-degree\n\t\t\t// by 1\n\t\t\tfor (int node : adj[u]) {\n\t\t\t\t// If in-degree becomes zero, add it to queue\n\t\t\t\tif (--indegree[node] == 0)\n\t\t\t\t\tq.addFirst(node);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\t// Check if there was a cycle\n\t\tif (cnt != v) {\n\t\t\tSystem.out.println(\"There exists a cycle in the graph\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Print topological order\n\t\tfor (int i : topOrder) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint N, M;\n\tint[] indeg;\n\tboolean[] V;\n\tArrayList<Integer>[] G;\n\tArrayList<Integer> res;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tindeg = new int[N];\n\t\tG = new ArrayList[N];\n\t\tV = new boolean[N];\n\t\tres = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tG[i] = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tG[s].add(t);\n\t\t\tindeg[t]++;\n\t\t}\n\t\ttopologicalSort();\n\t}\n\n\tvoid topologicalSort() {\n\t\tfor (int u = 0; u < N; u++) {\n\t\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\t\tbfs(u);\n\t\t\t}\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (int i = 0; i < N; i++) out.append(res.get(i) + \"\\n\");\n\t\tSystem.out.print(out);\n\t}\n\n\tvoid bfs(int s) {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tque.add(s);\n\t\tV[s] = true;\n\t\twhile (!que.isEmpty()) {\n\t\t\tint u = que.poll();\n\t\t\tres.add(u);\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u].get(i);\n\t\t\t\tindeg[v]--;\n\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\tque.add(v);\n\t\t\t\t\tV[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(char[] x, int a, int b) {\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n G g=new G(V,false);\n for(int i=0;i<E;i++) g.addEdge(ir.nextInt(),ir.nextInt());\n int[] tpo=g.buildTPO();\n for(int i=0;i<V;i++) out.println(tpo[i]);\n}\n\nstatic class G{\n\n AL[] g;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++){\n   g[i]=new AL();\n  }\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public void addEdge(int u,int v){\n  addEdge(u,v,0);\n }\n\n public int[] dijkstra(int s,int[] prev){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=g[v].get(i)[0],cost=g[v].get(i)[1];\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] buildTPO(){\n  boolean[] vis=new boolean[this.V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<this.V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=g[now].get(i)[0];\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tList<Integer> g[] = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tTopologicalSort ts = new TopologicalSort(n, m, g);\n\t\tts.init();\n\t\tts.execute();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tSystem.out.println(ts.res[i]);\n\t\t}\n\t}\n\n\tclass TopologicalSort {\n\t\tint N, M, index;\n\t\tint[] indeg, res;\n\t\tboolean[] V;\n\t\tList<Integer> G[];\n\n\t\tpublic TopologicalSort(int n, int m, List<Integer> g[]) {\n\t\t\tsuper();\n\t\t\tN = n;\n\t\t\tM = m;\n\t\t\tG = g;\n\t\t}\n\n\t\tvoid init() {\n\t\t\tindeg = new int[N];\n\t\t\tV = new boolean[N];\n\t\t\tres = new int[N];\n\t\t\tindex = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int e : G[i]) {\n\t\t\t\t\tindeg[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] execute() {\n\t\t\tfor (int u = 0; u < N; u++) {\n\t\t\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\t\t\tbfs(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid bfs(int s) {\n\t\t\tV[s] = true;\n\t\t\tLinkedList<Integer> que = new LinkedList<>();\n\t\t\tque.add(s);\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tint u = que.poll();\n\t\t\t\tres[index++] = u;\n\t\t\t\tfor (int v : G[u]) {\n\t\t\t\t\tindeg[v]--;\n\t\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\t\tque.add(v);\n\t\t\t\t\t\tV[v] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\t// AOJ GRL_4_B Topological Sort\n\tprivate static void solve() {\n\t\tint v = sc.nextInt();\n\t\tint ee = sc.nextInt();\n\n\t\tList<List<Integer>> edges = new ArrayList<>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tedges.add(new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < ee; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\n\t\t\tedges.get(s).add(t);\n\t\t}\n\n\t\tList<Integer> ts = new ArrayList<>();\n\t\tint[] used = new int[v];  // 0:White, 1:Gray, 2:Black\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (used[i] != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tDeque<Integer> st = new ArrayDeque<>();\n\t\t\tst.push(i);\n\t\t\twhile (!st.isEmpty()) {\n\t\t\t\tint e = st.peek();\n\n\t\t\t\tif (used[e] == 2) {\n\t\t\t\t\tst.pop();\n\t\t\t\t} else if (used[e] == 1) {\n\t\t\t\t\t// postorder\n\t\t\t\t\tts.add(e);\n\t\t\t\t\tused[e] = 2;\n\t\t\t\t\tst.pop();\n\t\t\t\t} else {\n\t\t\t\t\t// preorder\n\t\t\t\t\tused[e] = 1;\n\t\t\t\t\tfor (int next : edges.get(e)) {\n\t\t\t\t\t\tif (used[next] == 2) {\n\t\t\t\t\t\t\t// 前進辺または横断辺\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (used[next] == 1) {\n\t\t\t\t\t\t\t// 後退辺\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tst.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(ts);\n\n\t\tfor (int e : ts) {\n\t\t\tpr.println(e);\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\n\tstatic int dp[] = new int[100100];\n\tstatic ArrayList<ArrayList<Integer>> edge = new ArrayList<>();\n\tstatic ArrayList<Integer> list = new ArrayList<>();\n\n\tstatic ArrayList<Integer> ans = new ArrayList<>();\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString str[] = br.readLine().split(\" \");\n\n\t\tint N = Integer.parseInt(str[0]);\n\t\tint M = Integer.parseInt(str[1]);\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tedge.add(new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstr = br.readLine().split(\" \");\n\t\t\tint x = Integer.parseInt(str[0]);\n\t\t\tint y = Integer.parseInt(str[1]);\n\t\t\tedge.get(x).add(y);\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvisit(i);\n\t\t}\n\t\tfor (int i : ans) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\n\tstatic void visit(int now) {\n\t\tif (list.indexOf(now) == -1) {\n\t\t\tlist.add(now);\n\t\t\tfor (int i : edge.get(now)) {\n\t\t\t\tvisit(i);\n\t\t\t}\n\t\t\tans.add(0, now);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String [] args){\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int [][] List = new int[V][V];\n        int [] list = new int[V];\n        for(int [] L:List) Arrays.fill(L,0);\n        Arrays.fill(list,0);\n        for(int i=0;i<E;i++){\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            List[s][t]=1;\n            list[t]++;\n        }\n        ArrayList<Integer> L = new ArrayList<>();\n        Deque<Integer> S = new ArrayDeque<>();\n        for(int i=0;i<list.length;i++) if(list[i]==0) S.add(i);\n        while(S.size()!=0){\n            int v = S.poll();\n            L.add(v);\n            for(int i=0;i<V;i++){\n                if(List[v][i]==1){\n                    List[v][i]=0;\n                    list[i]--;\n                    if(list[i]==0)S.add(i);\n                }\n            }\n        }\n        for(int i:L) System.out.println(i);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "/*\n@author James Fisher\n@date\n@version\n*/\n\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\nclass Graph2 {\n    private int totalVertex;\n    private LinkedList<LinkedList<Integer>> adjList;\n    private int[] completion;\n    private boolean[] seen;\n    private int[] indegree;\n\n    // adjacency list of edges\n    Graph2() {\n        totalVertex = 0;\n    }\n\n    void loadAdjList() {\n        Scanner in = new Scanner(System.in);\n        totalVertex = in.nextInt();\n        completion = new int[totalVertex];\n        seen = new boolean[totalVertex];\n        indegree = new int[totalVertex];\n\n        int totalEdges = in.nextInt();\n        adjList = new LinkedList<LinkedList<Integer>>();\n\n        for(int i = 0; i < totalVertex ; i++) {\n            LinkedList<Integer> tmp = new LinkedList<Integer>();\n            adjList.add(tmp);\n        }\n\n        for (int i = 0; i < totalEdges; i++) {\n            int vert = in.nextInt();\n            int out = in.nextInt();\n            adjList.get(vert).add(out);\n            indegree[out]++;\n        }\n\n        in.close();\n    }\n\n\n    void isEligible() {\n        Queue<Integer> eligible = new LinkedList<Integer>();\n        for(int i = 0; i < totalVertex; i++) {\n            if(indegree[i] == 0) {\n                eligible.add(i);\n            }\n        }\n\n        while(!eligible.isEmpty()) {\n            int cur = eligible.poll();\n            System.out.println(cur);\n            for(Integer n : adjList.get(cur)) {\n                indegree[n]--;\n                if(indegree[n] == 0) {\n                    eligible.add(n);\n                }\n            }\n        }\n    }\n}\npublic class Main{\n    public static void main(String argv[]) {\n        Graph2 g = new Graph2();\n        g.loadAdjList();\n        g.isEligible();\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\nclass GraphTopological2 {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate int [] indegree;\n\tprivate Set<Integer> s = new HashSet<Integer>();\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tpublic GraphTopological2() {\n\t\ttotalVertex = 0; \n\t}\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tindegree = new int[totalVertex];\n\t\tfor(int i=0; i<totalVertex; i++){\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t\ts.add(i);\n\t\t}\n\t\tfor(int i = 0; i < totalEdge; i++) {\n\t\t\tint v = in.nextInt();\n\t\t\tint neighbor = in.nextInt();\n\t\t\tadjList.get(v).add(neighbor); // add its neighbor to its list\n\t\t\tindegree[neighbor]++; // increase its indegree by 1\t\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tpublic void Topological(){\n\t\twhile(!s.isEmpty()){\n\t\t\tIterator<Integer> itr = s.iterator();\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tint k = itr.next();\n\t\t\t\tif(indegree[k]==0){\n\t\t\t\t\tSystem.out.println(k);\n\t\t\t\t\tIterator<Integer> it = adjList.get(k).iterator();\n\t\t\t\t\twhile (it.hasNext()) {\n\t\t\t\t    \tint neib = it.next();// get all neighbors of the current node that has no incoming edges\n\t\t\t\t    \tindegree[neib]--;\t\t\t\t\t    \t\n\t\t\t\t   }\n\t\t    \t   s.remove(k);\n\t\t    \t   break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraphTopological2 g = new GraphTopological2();\n\t\tg.loadAdjList();\n\t\tg.Topological();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor (int i = lis.size() - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre, ArrayList<Integer>[] g) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (pre != cur && !vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tvis[cur] = true;\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static LinkedList<Integer>[] graph;\n    private static int[] in;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new LinkedList[V];\n        in = new int[V];\n        for(int i = 0; i < V; ++i){\n            graph[i] = new LinkedList<Integer>();\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            ++in[v];\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(in[i] == 0){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Integer v : graph[u]){\n                --in[v];\n                if(in[v] == 0){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n\tprivate int totalVertex, totalEdges;\n\tprivate int[] degree;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tpublic Graph() {\n\t\ttotalVertex = 0;\n\t\ttotalEdges = 0;\n\t}\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdges = in.nextInt();\n\t\tdegree = new int[totalVertex];\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\t\n\t\tfor(int i = 0; i < totalVertex ; i++) {\n\t\t\tLinkedList<Integer> vert = new LinkedList<Integer>();\n\t\t\tadjList.add(vert);\n\t\t\tdegree[i] = 0;\n\t\t}\n\t\t\n\t\tint row, col;\n\t\tfor (int i = 0; i < totalEdges; i++) {\n\t\t\trow = in.nextInt();\n\t\t\tcol = in.nextInt();\n\t\t\tadjList.get(row).add(col);\n\t\t\tdegree[col] += 1;\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tpublic void print() {\n\t\tQueue<Integer> vert = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(degree[i] == 0) {\n\t\t\t\tvert.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!vert.isEmpty()) {\n\t\t\tint num = vert.poll();\n\t\t\tSystem.out.println(num);\n\t\t\tfor(Integer n : adjList.get(num)) {\n\t\t\t\tdegree[n] -= 1;\n\t\t\t\tif(degree[n] == 0) {\n\t\t\t\t\tvert.add(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\tg.print();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n G g=new G(V,false);\n for(int i=0;i<E;i++) g.addEdge(ir.nextInt(),ir.nextInt());\n int[] tpo=g.buildTPO();\n for(int i=0;i<V;i++) out.println(tpo[i]);\n}\n\nstatic class G{\n\n AL[] g;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++){\n   g[i]=new AL();\n  }\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public int[] dijkstra(int s,int[] prev){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=g[v].get(i)[0],cost=g[v].get(i)[1];\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] buildTPO(){\n  boolean[] vis=new boolean[this.V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<this.V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=g[now].get(i)[0];\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class main{\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TopologicalSort solver = new TopologicalSort();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TopologicalSort {\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            int V = in.Int();\n            int E = in.Int();\n            TopologicalSort.Topological top = new TopologicalSort.Topological(V);\n            for (int i = 0; i < E; i++) {\n                int s = in.Int();\n                int t = in.Int();\n                top.addEdge(s, t);\n            }\n            top.sort();\n            top.list.forEach(out::println);\n        }\n\n        static class Topological {\n            int n;\n            List<Integer> list = new ArrayList<>();\n            int[] in;\n            Map<Integer, List<Integer>> out;\n\n            Topological(int n) {\n                this.n = n;\n                this.in = new int[n];\n                this.out = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                    out.put(i, new ArrayList<>());\n                }\n            }\n\n            public void addEdge(int x, int y) {\n                in[y]++;\n                out.get(x).add(y);\n            }\n\n            public void sort() {\n                list.clear();\n                Deque<Integer> que = new ArrayDeque<>();\n                for (int i = 0; i < n; i++) {\n                    if (in[i] == 0) {\n                        que.add(i);\n                    }\n                }\n                while (!que.isEmpty()) {\n                    int i = que.poll();\n                    list.add(i);\n                    for (int j : out.get(i)) {\n                        in[j]--;\n                        if (in[j] == 0) {\n                            que.add(j);\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tvis = new boolean[V];\n\t\tord = new int[V];\n\n\t\ttopologialSort();\n\n\t\tfor (int i = V - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\n\t}\n\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic int V, E;\n\tstatic int[] ord;\n\tstatic int now = 0;\n\n\tstatic void topologialSort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to] && pre != cur)\n\t\t\t\tdfs(to, cur);\n\t\t}\n\t\tvis[cur] = true;\n\t\tord[now++] = cur;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    public static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n            int[][] g = new int[n][n];\n    \n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g[f][t] = 1;\n            }\n\n            topologicalSort(g, n);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n    private static int getIndegree(int[][] g, int v) {\n        int c = 0;\n        for (int i = 0; i < g.length; i++) {\n            if (g[i][v] == 1)\n                c++;\n        }\n\n        return c;\n    }\n\n    private static List<Integer> getAdjacentVertices(int[][] g, int v) {\n        List<Integer> vs = new ArrayList<>();\n        for (int i = 0; i < g[0].length; i++) {\n            if (g[v][i] == 1)\n                vs.add(i);\n        }\n\n        vs.sort((x, y) -> Integer.compare(x, y));\n\n        return vs;\n    }\n\n    private static void topologicalSort(int[][] g, int n) {\n        Queue<Integer> q = new ArrayDeque<>();\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int d = getIndegree(g, i);\n\n            if (d == 0)\n                q.add(i);\n\n            m.put(i, d);\n        }\n\n        List<Integer> vs = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int v = q.remove();\n            out.println(v);\n\n            for (int vv : getAdjacentVertices(g, v)) {\n                int d = m.get(vv)-1;\n\n                if (d == 0)\n                    q.add(vv);\n\n                m.replace(vv, d);\n            }\n        }\n\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Iterator;\n\nclass Graph2 {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate int[][] adjList;\n\tprivate int[] inDegree;\n\tprivate int[] outDegree;\n\tprivate LinkedList<Integer> pre = new LinkedList<Integer>();\n\tprivate int[] visited;\n\tprivate LinkedList<Integer> post = new LinkedList<Integer>();\n\t//adjacency list of edges\n\tpublic Graph2() { \n\t\ttotalVertex = 0; \n\t\ttotalEdge = 0; \n\t\tadjList = null;\n\t\tinDegree = outDegree = null;\n\t}\n\t//given graph is in edge list\n\tpublic void loadEdgeList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tadjList = new int[totalVertex][totalVertex];\n\t\toutDegree = new int[totalVertex];\n\t\tinDegree = new int[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i ++) outDegree[i] = inDegree[i] = 0;\n\t\tfor(int i = 0; i < totalEdge; i ++) {\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tadjList[u][outDegree[u]] = v;\n\t\t\toutDegree[u] ++;\n\t\t\tinDegree[v] ++;\n\t\t}\n\t\tin.close();\n\t\tvisited = new int[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tvisited[i] = 0;\n\t\t}\n\t}\n\tpublic void DFS(int s) {\n\t\tpre.add(s); //ordering of the vertices based on when they are \"discovered\"\n\t\tvisited[s] = 1;\n\t\tfor(int i = 0; i < outDegree[s]; i ++) {\n\t\t\tint w = adjList[s][i]; \n\t\t\t//if(!pre.contains(w)) { //using this won't pass the last test case (time exceeds)\n\t\t\tif(visited[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t}\n\t\t}\n\t\tpost.add(s); //ordering of the vertices after completion of DFS\n\t}\n\tpublic LinkedList<Integer> topSortDFS() {\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tif(inDegree[i] == 0) DFS(i);\n\t\t}\t\n\t\tLinkedList<Integer> s = new LinkedList<Integer>();\n\t\tIterator<Integer> it = post.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tint u = it.next();\n\t\t\ts.add(0, u);\n\t\t}\n\t\treturn s;\n\t}\n\tpublic LinkedList<Integer> topSortQueue() {\n\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\tLinkedList<Integer> s = new LinkedList<Integer>();\n\t\tint i;\n\t\tfor(i = 0; i < totalVertex; i ++) {\n\t\t\tif(inDegree[i] == 0) q.add(i);\n\t\t}\n\t\twhile(!q.isEmpty()) {\n\t\t\tint u = q.remove(0); //take the first one\n\t\t\ts.add(u);\n\t\t\tfor(i = 0; i < outDegree[u]; i ++) {\n\t\t\t\tint v = adjList[u][i];\n\t\t\t\tinDegree[v] --; \n\t\t\t\tif(inDegree[v] <= 0) {\n\t\t\t\t\tq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\t\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph2 g = new Graph2();\n\t\tg.loadEdgeList();\n\t\tLinkedList<Integer> s = g.topSortDFS();\n\t\t//LinkedList<Integer> s = g.topSortQueue();\n\t\tIterator<Integer> it = s.iterator();\n\t\twhile(it.hasNext()) System.out.println(it.next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\t\tList<Integer>[] adj = new List[v];\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t// Create a array to store indegrees of all\n\t\t// vertices. Initialize all indegrees as 0.\n\t\tint indegree[] = new int[v];\n\n\t\t// Traverse adjacency lists to fill indegrees of\n\t\t// vertices. This step takes O(V+E) time\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tList<Integer> temp = adj[i];\n\t\t\tfor (int node : temp) {\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t// Create a queue and enqueue all vertices with\n\t\t// indegree 0\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0)\n\t\t\t\tq.addLast(i);\n\t\t}\n\n\t\t// Initialize count of visited vertices\n\t\tint cnt = 0;\n\n\t\t// Create a vector to store result (A topological\n\t\t// ordering of the vertices)\n\t\tVector<Integer> topOrder = new Vector<Integer>();\n\t\twhile (!q.isEmpty()) {\n\t\t\t// Extract front of queue (or perform dequeue)\n\t\t\t// and add it to topological order\n\t\t\tint u = q.removeFirst();\n\t\t\ttopOrder.add(u);\n\n\t\t\t// Iterate through all its neighbouring nodes\n\t\t\t// of dequeued node u and decrease their in-degree\n\t\t\t// by 1\n\t\t\tfor (int node : adj[u]) {\n\t\t\t\t// If in-degree becomes zero, add it to queue\n\t\t\t\tif (--indegree[node] == 0)\n\t\t\t\t\tq.addFirst(node);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\t// Check if there was a cycle\n\t\tif (cnt != v) {\n\t\t\tSystem.out.println(\"There exists a cycle in the graph\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Print topological order\n\t\tfor (int i : topOrder) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayList<Integer> ans=topological_sort(e,0);\n\t\tfor(int i=0;i<V;i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\t\n\tArrayList<Integer> topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayList<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayList<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.add(i);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayList<Integer> ans=topological_sort(e,0);\n\t\tfor(int i=0;i<V;i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t}\n\t\n\tArrayList topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayList<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayList<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.add(i);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\n\npublic class Main {\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor (int i = lis.size() - 1; i >= 0; --i) {\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre, ArrayList<Integer>[] g) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (pre != cur && !vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tvis[cur] = true;\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tprivate static void solve() {\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\tint V = ni();\n\t\tint E = ni();\n\t\tint[] from = new int[E];\n\t\tint[] to = new int[E];\n\t\tfor(int i=0;i<E;i++){\n\t\t\tfrom[i] = ni();\n\t\t\tto[i] = ni();\n\t\t}\n\t\tint[][] g = packD(V, from, to);\n\t\tint[] result = sortTopologically(g);\n\t\tfor(int i:result){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\tpublic static int[] sortTopologically(int[][] g)\n\t{\n\t\tint n = g.length;\n\t\tint[] ec = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int to : g[i])ec[to]++;\n\t\t}\n\t\tint[] ret = new int[n];\n\t\tint q = 0;\n\n\t\t// sources\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ec[i] == 0)ret[q++] = i;\n\t\t}\n\n\t\tfor(int p = 0;p < q;p++){\n\t\t\tfor(int to : g[ret[p]]){\n\t\t\t\tif(--ec[to] == 0)ret[q++] = to;\n\t\t\t}\n\t\t}\n\t\t// loop\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ec[i] > 0)return null;\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[][] packD(int n, int[] from, int[] to)\n\t{\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = Integer.parseInt(sc.next());\n\t\tint E = Integer.parseInt(sc.next());\n\t\tint[] cnt = new int[V];\n\t\tArrayList<ArrayList<Integer>> edge = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tArrayList<Integer> add = new ArrayList<Integer>();\n\t\t\tedge.add(add);\n\t\t}\n\t\tfor (int i=0;i<E;i++) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint t = Integer.parseInt(sc.next());\n\t\t\tedge.get(s).add(t);\n\t\t\tcnt[t]++;\n\t\t}\n\n\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\tArrayDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tif (cnt[i]==0) {\n\t\t\t\tans.add(i);\n\t\t\t\tqueue.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tInteger rem = queue.remove();\n\t\t\tfor (Integer i : edge.get(rem)) {\n\t\t\t\tcnt[i]--;\n\t\t\t\tif (cnt[i]==0) {\n\t\t\t\t\tans.add(i);\n\t\t\t\t\tqueue.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Integer i : ans) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int totalVertex;\n\tprivate int totalEdges;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\t//adjacency list of edges\n\tpublic Main() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdges = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tadjList.add(new LinkedList<Integer>());\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < totalEdges; i++) {\n\t\t\tint s = in.nextInt();\n\t\t\tint t = in.nextInt();\n\t\t\tLinkedList<Integer> tmp = adjList.get(s);\n\t\t\ttmp.add(t);\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tpublic LinkedList<Integer> getTopSort() {\n\t\tLinkedList<Integer> L = new LinkedList<Integer>();\n\t\tint[] C = new int[totalVertex];\n\t\tLinkedList<Integer> Q = new LinkedList<Integer>();\n\t\t\n\t\t\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tLinkedList<Integer> neighbors = adjList.get(i);\n\t\t\tfor (int j : neighbors) {\n\t\t\t\tC[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tif (C[i] == 0) {\n\t\t\t\tQ.add(i);\n\t\t\t}\n\t\t}\n\t\twhile (Q.size() > 0) {\n\t\t\tint u = Q.remove(0);\n\t\t\tL.add(u);\n\t\t\tLinkedList<Integer> neighbors = adjList.get(u);\n\t\t\tfor (int v : neighbors) {\n\t\t\t\tC[v]--;\n\t\t\t\tif (C[v] == 0) {\n\t\t\t\t\tQ.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn L;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tMain s = new Main();\n\t\ts.loadAdjList();\n\t\tLinkedList<Integer> result = s.getTopSort();\n\t\tfor (Integer i : result) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n    public static class TopologicalSort_Kahn {\n\n        boolean hasCycle;\n        LinkedList<Integer> sortedOrder;\n\n        public TopologicalSort_Kahn(WeightedDigraph graph) {\n            sortedOrder = new LinkedList<Integer>();\n            TreeSet<Integer> zeroInVerts = new TreeSet<Integer>();\n            int[] inEdge = new int[graph.numVertex];\n            for (List<WeightedDigraph.Edge> edges : graph.srcEdges) {\n                for (WeightedDigraph.Edge edge : edges) {\n                    inEdge[edge.targetVertex]++;\n                }\n            }\n            for (int v = 0; v < graph.numVertex; v++) {\n                if (inEdge[v] == 0) {\n                    zeroInVerts.add(v);\n                }\n            }\n\n            while (!zeroInVerts.isEmpty()) {\n                int vert = zeroInVerts.pollFirst();\n                sortedOrder.add(vert);\n                List<WeightedDigraph.Edge> edges = graph.srcEdges[vert];\n                for (WeightedDigraph.Edge edge : edges) {\n                    inEdge[edge.targetVertex]--;\n                    if (inEdge[edge.targetVertex] == 0) {\n                        zeroInVerts.add(edge.targetVertex);\n                    }\n                }\n            }\n\n            for (int v = 0; v < graph.numVertex; v++) {\n                if (inEdge[v] != 0) {\n                    sortedOrder.clear();\n                    hasCycle = true;\n                    return;\n                }\n            }\n\n        }\n\n        public boolean hasCycle() {\n            return hasCycle;\n        }\n\n        public Iterator<Integer> sortedOrder() {\n            return sortedOrder.iterator();\n        }\n    }\n\n    public static class WeightedDigraph {\n\n        int numVertex;\n        int numEdge;\n\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedDigraph(int numV, int numE) {\n            this.numVertex = numV;\n            this.numEdge = numE;\n            srcEdges = new List[numV];\n\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n        }\n\n        public static class Edge {\n\n            int srcVertex;\n            int targetVertex;\n            int weight;\n\n            public Edge(int srcVertex, int targetVertex, int weight) {\n                this.srcVertex = srcVertex;\n                this.targetVertex = targetVertex;\n                this.weight = weight;\n            }\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int v = in.nextInt();\n        int e = in.nextInt();\n        WeightedDigraph graph = new WeightedDigraph(v, e);\n        while (e-- > 0) {\n            graph.addEdge(in.nextInt(), in.nextInt(), 1);\n        }\n        TopologicalSort_Kahn topSort = new TopologicalSort_Kahn(graph);\n        Iterator<Integer> it = topSort.sortedOrder();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayList<Integer> ans=topological_sort(e,0);\n\t\tfor(int i=0;i<V;i++){\n\t\t\tSystem.out.println(ans.get(i));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tArrayList<Integer> topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayList<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayList<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.add(i);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*; \nimport java.util.*; \n  \nclass Graph { \n\t\n    ArrayList<Integer> adjArr[];\n  \n\t@SuppressWarnings(\"unchecked\")\n\tGraph(int v) {\n        adjArr = new ArrayList[v]; \n        for (int i=0; i <v; i++) \n            adjArr[i] = new ArrayList<Integer>(); \n    } \n  \n \n    void addToGraph(int id, int neighbor) { \n    \tadjArr[id].add(neighbor); \n    \t}\n    \n \n    void topoSort(int v, boolean visited[], Stack<Integer> s) {  \n      \n    \tvisited[v] = true; \n        int i; \n\n        Iterator<Integer> next = adjArr[v].iterator(); \n        while (next.hasNext()) { \n            i = next.next(); \n\n            if (!visited[i]) \n            \ttopoSort(i, visited, s); \n        } \n        s.push(v); \n    }\n}\n\npublic class Main{\n  \n    public static void main(String args[]) \n    { \n    \tScanner sc = new  Scanner(System.in);\n\n\t\tint totalVertex = sc.nextInt();\n\t\tGraph adj = new Graph(totalVertex);\n\t\t\n\t\tint total = sc.nextInt();\n\t\t\n\t\tint id;\n\t\tint neighbor;\n\t\t\n\t\tfor (int j = 0; j < total; j++) {\n\t\t\tid = sc.nextInt();\n\t\t\tneighbor = sc.nextInt();\n\t\t\tadj.addToGraph(id, neighbor);\n\t\t}\n\t\t\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\n\t\tboolean[] visited = new boolean[totalVertex];\n\n\t\tfor(int k = 0; k < totalVertex; k++){\n\t\t\tvisited[k] = false;\n\t\t}\n\t\t\n\t\tfor(int l = 0; l < totalVertex; l++) {\n\t\t\tif(!visited[l]) {\n\t\t\t\tadj.topoSort(l, visited, stack);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!stack.isEmpty()) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class Main{\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList<Integer> result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\t\tList<Integer>[] adj = new List[v];\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\tadj[from].add(to);\n\t\t}\n\t\t// Create a array to store indegrees of all\n\t\t// vertices. Initialize all indegrees as 0.\n\t\tint indegree[] = new int[v];\n\n\t\t// Traverse adjacency lists to fill indegrees of\n\t\t// vertices. This step takes O(V+E) time\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tList<Integer> temp = adj[i];\n\t\t\tfor (int node : temp) {\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t// Create a queue and enqueue all vertices with\n\t\t// indegree 0\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0)\n\t\t\t\tq.addLast(i);\n\t\t}\n\n\t\t// Initialize count of visited vertices\n\t\tint cnt = 0;\n\n\t\t// Create a vector to store result (A topological\n\t\t// ordering of the vertices)\n\t\tVector<Integer> topOrder = new Vector<Integer>();\n\t\twhile (!q.isEmpty()) {\n\t\t\t// Extract front of queue (or perform dequeue)\n\t\t\t// and add it to topological order\n\t\t\tint u = q.removeFirst();\n\t\t\ttopOrder.add(u);\n\n\t\t\t// Iterate through all its neighbouring nodes\n\t\t\t// of dequeued node u and decrease their in-degree\n\t\t\t// by 1\n\t\t\tfor (int node : adj[u]) {\n\t\t\t\t// If in-degree becomes zero, add it to queue\n\t\t\t\tif (--indegree[node] == 0)\n\t\t\t\t\tq.addFirst(node);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\t// Check if there was a cycle\n\t\tif (cnt != v) {\n\t\t\tSystem.out.println(\"There exists a cycle in the graph\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Print topological order\n\t\tfor (int i : topOrder) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static List<Integer>[] graph;\n    private static int[] in;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new List[V];\n        in = new int[V];\n        for(int i = 0; i < V; ++i){\n            graph[i] = new LinkedList<>();\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            ++in[v];\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(in[i] == 0){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Integer v : graph[u]){\n                --in[v];\n                if(in[v] == 0){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint id;\n\t\tSet<Integer> adj;\n\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.adj = new HashSet<>();\n\t\t}\n\n\t\tpublic void addEdge(int v) {\n\t\t\tadj.add(v);\n\t\t}\n\n\t\tpublic boolean contains(int v) {\n\t\t\treturn adj.contains(v);\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices() {\n\t\t\tList<Integer> vs = new ArrayList<>(adj);\n\n//\t\t\tvs.sort((x, y) -> x-y);\n\n\t\t\treturn vs;\n\t\t}\n\t}\n\n\tstatic class Graph {\n\t\tprivate List<Vertex> vertices;\n\t\tprivate int n;\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tthis.vertices = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvertices.add(new Vertex(i));\n\t\t}\n\n\t\tpublic int getNumVertices() {\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic int getIndegree(int v) {\n\t\t\tif (v < 0 || v >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (vertices.get(i).contains(v))\n\t\t\t\t\td++;\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices(int v) {\n\t\t\treturn vertices.get(v).getAdjacentVertices();\n\t\t}\n\n\t\tpublic void addEdge(int v1, int v2) {\n\t\t\tif (v1 < 0 || v2 < 0 || v1 >= n|| v2 >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tvertices.get(v1).addEdge(v2);\n\t\t}\t\t\t\t\t\t\t\n\t}\n\n\tpublic static List<Integer> sort(Graph g) {\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tMap<Integer, Integer> m = new HashMap<>();\n\n\t\tint n = g.getNumVertices();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d = g.getIndegree(i);\n\t\t\tm.put(i, d);\n\n\t\t\tif (d == 0)\n\t\t\t\tq.add(i);\n\t\t}\n\n\t\tList<Integer> vs = new ArrayList<>();\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = q.remove();\n\n\t\t\tvs.add(v);\n\t\t\tList<Integer> adj = g.getAdjacentVertices(v);\n\t\t\tfor (int a : adj) {\n\t\t\t\tm.replace(a, m.get(a)-1);\n\t\t\t\tif (m.get(a) == 0)\n\t\t\t\t\tq.add(a);\n\t\t\t}\n\t\t}\n\n\t\tif (vs.size() != n)\n\t\t\tthrow new IllegalStateException(\"cycle detected!\");\n\n\t\treturn vs;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tGraph g = new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\n\t\t\t\tg.addEdge(x, y);\n\t\t\t}\n\n\t\t\tList<Integer> vs = sort(g);\n\t\t\tfor (int v : vs)\n\t\t\t\tSystem.out.println(v);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static HashMap<Integer, List<Integer>> graph;\n    private static int[] in;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new HashMap<>(V);\n        in = new int[V];\n        for(int i = 0; i < V; ++i){\n            graph.put(i, new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n            ++in[v];\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(in[i] == 0){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Integer v : graph.get(u)){\n                --in[v];\n                if(in[v] == 0){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList<Integer> result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate int totalEdges;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tint[] discover;\n\tint[] finish;\n\t\n\t//adjacency list of edges\n\tpublic Graph() { \n\t\t\ttotalVertex = 0;\n\t\t\ttotalEdges = 0;\n\t\t}\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdges = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tadjList.add(new LinkedList<Integer>());\n\t\t}\n\t\t//int previdx = -1;\n\t\tfor(int i = 0; i < totalEdges; i++) {\n\t\t\tint idx1 = in.nextInt();\n\t\t\tint idx2 = in.nextInt();\n\t\t\tadjList.get(idx1).add(idx2);\n\t\t}\n//\t\tfor(int i = 0; i < totalVertex; i ++) {\n//\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n//\t\t\tint idx1 = in.nextInt() - 1;\n//\t\t\tint degree = in.nextInt();\n//\t\t\t//System.out.println(\"mark idx1 = \" + idx1 + \" degree = \" + degree);\n//\t\t\tfor(int j = 0; j < degree; j ++) {\n//\t\t\t\tint idx2 = in.nextInt() - 1;\n//\t\t\t\ttmp.add(idx2);\n//\t\t\t}\t\n//\t\t\tadjList.add(tmp);\n//\t\t}\n\t\tin.close();\n\t}\n\tpublic void printAdjMatrix() {\n\t\tInteger[][] adjMatrix = new Integer[totalVertex][totalVertex];\n\t\t\n\t\tfor(int i = 0; i < adjMatrix.length; i++) {\n\t\t\tfor(int j = 0; j < totalVertex ; j++) {\n\t\t\t\tadjMatrix[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint z = 0;\n\t\t//int j = 0;\n\t\t\n\t\tfor(LinkedList<Integer> ll: this.adjList) {\n\t\t\tfor(Integer ele : ll) {\n\t\t\t\tadjMatrix[z][ele] = 1;\n\t\t\t}\n\t\t\tz++;\n\t\t}\n\t\t\n\t\tfor(int m = 0; m < adjMatrix.length; m++) {\n\t\t\tfor(int n = 0; n < totalVertex; n++) {\n\t\t\t\tif(n == totalVertex - 1) {\n\t\t\t\t\tSystem.out.println(adjMatrix[m][n]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(adjMatrix[m][n] + \" \");\n\t\t\t\t}\n\t\t\t\t//System.out.print(adjMatrix[m][n] + \" \");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int DFS(int v, int time) {\n\t    \n//\t\tif(discover[v] != -1) {\n//\t\t\treturn time;\n//\t\t}\n\t\t\n\t\tdiscover[v] = time;\n\t\tfor(Integer ele : this.adjList.get(v)) {\n\t\t\tif(discover[ele] == -1) {\n\t\t\t\ttime += 1;\n\t\t\t\ttime = DFS(ele, time);\n\t\t\t}\n\t\t}\n\t\t\t//finish[v] = time + 1;\n\t\t\n\t\tfinish[v] = time + 1;\n\t\treturn time + 1;\n\t}\n\t\n\tpublic void DFS(int v, ArrayList<Integer> arr) {\n\t\tdiscover[v] = 1;\n\t\t\n\t\tfor(Integer ele: this.adjList.get(v)) {\n\t\t\tif(discover[ele] == -1) {\n\t\t\t\tDFS(ele, arr);\n\t\t\t}\n\t\t}\n\t\tarr.add(v);\n\t}\n\t\n\tpublic void BFS() {\n\t\t//int iter = 0;\n\t\tQueue<Integer> q = new LinkedList<>();\n\t\tq.add(0);\n\t\tint[] distances = new int[totalVertex];\n\t\tdistances[0] = 0;\n\t\tfor(int i = 1; i < distances.length; i++) {\n\t\t\tdistances[i] = -1;\n\t\t}\n\t\twhile(q.isEmpty() != true) {\n\t\t\tint u = q.remove();\n\t\t\t//System.out.println(u+1);\n\t\t\t//iter += 1;\n\t\t\tfor(Integer ele : this.adjList.get(u)) {\n\t\t\t\t//System.out.println(u);\n\t\t\t\tif(distances[ele] == -1) {\n\t\t\t\t\tq.add(ele);\n\t\t\t\t\tdistances[ele] = distances[u]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < distances.length; i++) {\n\t\t\tSystem.out.println(i + 1 + \" \" + distances[i]);\n\t\t}\n\t}\n\t\n\tpublic void searchGraph() {\n\t\tthis.discover = new int[totalVertex];\n\t\tfor(int i = 0; i < discover.length; i++) {\n\t\t\tdiscover[i] = -1;\n\t\t}\n\t\tthis.finish = new int[totalVertex];\n\t\t\n\t\tint dis_time = 0;\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++){\n\t\t\tif(discover[i] == -1) {\n\t\t\t\tdis_time = DFS(i, dis_time);\n\t\t\t\tdis_time += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tSystem.out.println(i + 1 + \" \" + (discover[i] + 1) + \" \" + (finish[i] + 1));\n\t\t}\n\t}\n\t\n\t\n\tpublic void toposort() {\n\t\tArrayList<Integer> arr = new ArrayList<Integer>();\n\t\tthis.discover = new int[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tdiscover[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < totalVertex; i++){\n\t\t\tif(discover[i] == -1) {\n\t\t\t\tDFS(i, arr);\n\t\t\t}\n\t\t}\n\t\tfor(int i = arr.size() - 1; i >= 0; i--) {\n\t\t\tSystem.out.println(arr.get(i) + \" \");\n\t\t}\n\t\t\n\t}\n}\n\n\n//change class name GraphRepresentation to Main() for submission to AIZU\nclass Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\t//g.BFS();\n\t\t//g.printAdjMatrix();\n\t\t//g.searchGraph();\n\t\tg.toposort();\n\t\t\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\t// AOJ GRL_4_B Topological Sort\n\tprivate static void solve() {\n\t\tint v = sc.nextInt();\n\t\tint ee = sc.nextInt();\n\n\t\tList<List<Integer>> edges = new ArrayList<>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tedges.add(new ArrayList<>());\n\t\t}\n\n\t\tint[] cnt = new int[v];  // 入次数\n\t\tfor (int i = 0; i < ee; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\n\t\t\tedges.get(s).add(t);\n\t\t\tcnt[t]++;\n\t\t}\n\n\t\tList<Integer> ts = new ArrayList<>();\n\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (cnt[i] == 0) {\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tint e = q.remove();\n\n\t\t\tts.add(e);\n\n\t\t\tfor (int d : edges.get(e)) {\n\t\t\t\tcnt[d]--;\n\t\t\t\tif (cnt[d] == 0) {\n\t\t\t\t\tq.add(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int e : ts) {\n\t\t\tpr.println(e);\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n int[][] e=new int[E][],re=new int[E][];\n for(int i=0;i<E;i++){\n  e[i]=new int[]{ir.nextInt(),ir.nextInt(),1};\n }\n int[][][] g=make_graph(V,e);\n ArrayList<Integer> ord=new ArrayList<>();\n boolean[] vis=new boolean[V];\n for(int i=0;i<V;i++) if(g[i].length==0) TopologicalSort(i,g,vis,ord);\n for(int v : ord) out.println(v);\n}\n\npublic static void TopologicalSort(int now,int[][][] g,boolean[] vis,ArrayList<Integer> ord){\n for(int i=0;i<g[now].length;i++){\n  if(!vis[g[now][i][0]]) TopologicalSort(g[now][i][0],g,vis,ord);\n }\n ord.add(now);\n}\n\npublic static int[][][] make_graph(int n,int[][] e){\n int[][][] ret=new int[n][][];\n int[] cnt=new int[n];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  cnt[e[i][0]]++;\n }\n for(int i=0;i<n;i++)\n  ret[i]=new int[cnt[i]][];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  ret[e[i][0]][ret[e[i][0]].length-cnt[e[i][0]]--]=new int[]{e[i][1],e[i][2]};\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n int[][] e=new int[E][],re=new int[E][];\n for(int i=0;i<E;i++){\n  e[i]=new int[]{ir.nextInt(),ir.nextInt(),1};\n }\n int[][][] g=make_graph(V,e);\n ArrayList<Integer> ord=new ArrayList<>();\n boolean[] vis=new boolean[V];\n for(int i=0;i<V;i++) if(g[i].length==0) TopologicalSort(i,g,vis,ord);\n for(int v : ord) out.println(v);\n}\n\npublic static void TopologicalSort(int now,int[][][] g,boolean[] vis,ArrayList<Integer> ord){\n vis[now]=true;\n for(int i=0;i<g[now].length;i++){\n  if(!vis[g[now][i][0]]) TopologicalSort(g[now][i][0],g,vis,ord);\n }\n ord.add(now);\n}\n\npublic static int[][][] make_graph(int n,int[][] e){\n int[][][] ret=new int[n][][];\n int[] cnt=new int[n];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  cnt[e[i][0]]++;\n }\n for(int i=0;i<n;i++)\n  ret[i]=new int[cnt[i]][];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  ret[e[i][0]][ret[e[i][0]].length-cnt[e[i][0]]--]=new int[]{e[i][1],e[i][2]};\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\t@SuppressWarnings(\"unchecked\")\n\tstatic class TaskX {\n\n\t\tboolean[] V;\n\t\tList<Integer>[] g;\n\t\tList<Integer> list;\n\t\tint v, e;\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tv = in.nextInt(); e = in.nextInt();\n\t\t\tg = new ArrayList[v];\n\t\t\tg = Stream.generate(ArrayList::new).limit(v).toArray(List[]::new);\n\t\t\tlist = new ArrayList<>();\n\n\t\t\tV = new boolean[v];\n\t\t\tfor (int i = 0; i < e; i++) {\n\t\t\t\tint s = in.nextInt(), t = in.nextInt();\n\t\t\t\tg[s].add(t);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tif (!V[i]) dfs(i);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tout.println(list.get(v-1-i));\n\t\t\t}\n\n\t\t}\n\n\t\tvoid dfs(int s) {\n\t\t\tV[s] = true;\n\t\t\tfor (int t : g[s]) {\n\t\t\t\tif (!V[t]) dfs(t);\n\t\t\t}\n\t\t\tlist.add(s);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(int n) {\n\t\t\tint[] res = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(int n) {\n\t\t\tlong[] res = new long[n + 1];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i + 1] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList result = new ArrayList();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n    public static class TopologicalSort_DFS {\n\n        boolean hasCycle;\n        LinkedList<Integer> sortedOrder;\n        TreeSet<Integer> unmarkedV;\n        boolean[] tempMark;\n\n        public TopologicalSort_DFS(WeightedDigraph graph) {\n            tempMark = new boolean[graph.numVertex];\n            unmarkedV = new TreeSet<Integer>();\n            for (int v = 0; v < graph.numVertex; v++) {\n                unmarkedV.add(v);\n            }\n            sortedOrder = new LinkedList<Integer>();\n\n            try {\n                while (!unmarkedV.isEmpty()) {\n                    int v = unmarkedV.first();\n                    dfs(v, graph);\n                }\n            } catch (Exception ex) {\n                hasCycle = true;\n                sortedOrder.clear();\n            }\n        }\n\n        private void dfs(int vert, WeightedDigraph graph) throws Exception {\n            if (tempMark[vert]) {\n                throw new Exception(\"cycle deteced v:\" + vert);\n            }\n            if (unmarkedV.contains(vert)) {\n                tempMark[vert] = true;\n                for (WeightedDigraph.Edge edge : graph.srcEdges[vert]) {\n                    dfs(edge.targetVertex, graph);\n                }\n                unmarkedV.remove(vert);\n                tempMark[vert] = false;\n                sortedOrder.addFirst(vert);\n            }\n        }\n\n        public boolean hasCycle() {\n            return hasCycle;\n        }\n\n        public Iterator<Integer> sortedOrder() {\n            return sortedOrder.iterator();\n        }\n    }\n\n    public static class WeightedDigraph {\n\n        int numVertex;\n        int numEdge;\n\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedDigraph(int numV, int numE) {\n            this.numVertex = numV;\n            this.numEdge = numE;\n            srcEdges = new List[numV];\n\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n        }\n\n        public static class Edge {\n\n            int srcVertex;\n            int targetVertex;\n            int weight;\n\n            public Edge(int srcVertex, int targetVertex, int weight) {\n                this.srcVertex = srcVertex;\n                this.targetVertex = targetVertex;\n                this.weight = weight;\n            }\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int v = in.nextInt();\n        int e = in.nextInt();\n        WeightedDigraph graph = new WeightedDigraph(v, e);\n        while (e-- > 0) {\n            graph.addEdge(in.nextInt(), in.nextInt(), 1);\n        }\n        TopologicalSort_DFS topSort = new TopologicalSort_DFS(graph);\n        Iterator<Integer> it = topSort.sortedOrder();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class Main{\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t// get topological order from edge-list format,\n\t// such as 0: <1, 2>, 1: <>, 2: <3>, 3: <>\n\t// (expecting vetex-number starts from 0)\n\t// if there is no topological order, it returns null.\n\tstatic ArrayList<Integer> getTopologicalOrder(ArrayList<ArrayList<Integer>> es) {\n\t\tint n = es.size(); // number of vertexes\n\t\tint[] deg = new int[n];\n\t\tArrayList<Integer> ret = new ArrayList<>(n);\n\t\tQueue<Integer> q = new ArrayDeque<Integer>(n);\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int to : es.get(i)) {\n\t\t\t\tdeg[to]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(deg[i]==0) q.add(i);\n\t\t}\n\t\tint cnt = 0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint from = q.poll();\n\t\t\tret.add(from);\n\t\t\tfor(int to : es.get(from)) {\n\t\t\t\tdeg[to]--;\n\t\t\t\tif(deg[to]==0) {\n\t\t\t\t\tq.add(to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt!=n) return null;\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(); int m = sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> es = new ArrayList<>();\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tes.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint s = sc.nextInt(); int t = sc.nextInt();\n\t\t\tes.get(s).add(t);\n\t\t}\n\t\tArrayList<Integer> tord = getTopologicalOrder(es);\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tSystem.out.println(tord.get(i));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class main{\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint id;\n\t\tSet<Integer> adj;\n\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.adj = new HashSet<>();\n\t\t}\n\n\t\tpublic void addEdge(int v) {\n\t\t\tadj.add(v);\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices() {\n\t\t\tList<Integer> vs = new ArrayList<>(adj);\n\n\t\t\tvs.sort((x, y) -> x-y);\n\n\t\t\treturn vs;\n\t\t}\n\t}\n\n\tstatic class Graph {\n\t\tprivate List<Vertex> vertices;\n\t\tprivate int n;\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tthis.vertices = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvertices.add(new Vertex(i));\n\t\t}\n\n\t\tpublic int getNumVertices() {\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic int getIndegree(int v) {\n\t\t\tif (v < 0 || v >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (vertices.get(i).getAdjacentVertices().contains(v))\n\t\t\t\t\td++;\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices(int v) {\n\t\t\treturn vertices.get(v).getAdjacentVertices();\n\t\t}\n\n\t\tpublic void addEdge(int v1, int v2) {\n\t\t\tif (v1 < 0 || v2 < 0 || v1 >= n|| v2 >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tvertices.get(v1).addEdge(v2);\n\t\t}\t\t\t\t\t\t\t\n\t}\n\n\tpublic static List<Integer> sort(Graph g) {\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tMap<Integer, Integer> m = new HashMap<>();\n\n\t\tint n = g.getNumVertices();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d = g.getIndegree(i);\n\t\t\tm.put(i, d);\n\n\t\t\tif (d == 0)\n\t\t\t\tq.add(i);\n\t\t}\n\n\t\tList<Integer> vs = new ArrayList<>();\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = q.remove();\n\n\t\t\tvs.add(v);\n\t\t\tList<Integer> adj = g.getAdjacentVertices(v);\n\t\t\tfor (int a : adj) {\n\t\t\t\tm.replace(a, m.get(a)-1);\n\t\t\t\tif (m.get(a) == 0)\n\t\t\t\t\tq.add(a);\n\t\t\t}\n\t\t}\n\n\t\tif (vs.size() != n)\n\t\t\tthrow new IllegalStateException(\"cycle detected!\");\n\n\t\treturn vs;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tGraph g = new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\n\t\t\t\tg.addEdge(x, y);\n\t\t\t}\n\n\t\t\tList<Integer> vs = sort(g);\n\t\t\tfor (int v : vs)\n\t\t\t\tSystem.out.println(v);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic int[] diag;\n\tstatic ArrayList<ArrayList<Integer>> vector = new ArrayList<ArrayList<Integer>>();\n\tpublic static void topological(int v) {\n\t\tDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor(int i=0; i<v; i++) {\n\t\t\tif(diag[i] == 0) {\n\t\t\t\tq.addLast(i);\n\t\t\t}\n\t\t}\n\n\t\twhile(!q.isEmpty()) {\n\t\t\tint n = q.removeFirst();\n\t\t\tSystem.out.println(n);\n\t\t\tArrayList<Integer> lst = vector.get(n);\n\t\t\tfor(int i=0; i<lst.size(); i++) {\n\t\t\t\tint k = lst.get(i);\n\t\t\t\tdiag[k]--;\n\t\t\t\tif(diag[k] == 0) q.addLast(k);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint v = r.nextInt();\n\t\tint e = r.nextInt();\n\t\tdiag = new int[v];\n\t\tfor(int i=0; i<v; i++) {\n\t\t\tvector.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<e; i++) {\n\t\t\tint s = r.nextInt();\n\t\t\tint t = r.nextInt();\n\t\t\tvector.get(s).add(t);\n\t\t\tdiag[t]++;\n\t\t}\n\t\ttopological(v);\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Queue;\n\npublic class Main {\n\n\tpublic static final int BIG_NUM  = 2000000000;\n\tpublic static final int MOD  = 1000000007;\n\n\tpublic static void main(String[] args) {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\ttry {\n\t\t\tString input_str[] = new String[2];\n\t\t\tinput_str = br.readLine().split(\"\\\\s+\");\n\t\t\tint V = Integer.parseInt(input_str[0]);\n\t\t\tint E = Integer.parseInt(input_str[1]);\n\n\t\t\tNode nodes[] = new Node[V];\n\t\t\tfor(int i = 0; i < V; i++)nodes[i] = new Node();\n\n\t\t\tint in_num[] = new int[V];\n\t\t\tfor(int i = 0; i < V; i++)in_num[i] = 0;\n\n\t\t\tint from,to;\n\t\t\tStringBuilder ans = new StringBuilder();\n\n\t\t\tfor(int loop = 0; loop < E; loop++){\n\t\t\t\tinput_str = br.readLine().split(\"\\\\s+\");\n\t\t\t\tfrom = Integer.parseInt(input_str[0]);\n\t\t\t\tto = Integer.parseInt(input_str[1]);\n\t\t\t\tin_num[to]++;\n\t\t\t\tnodes[from].list.add(to);\n\t\t\t}\n\n\t\t\tQueue<Integer> Q = new ArrayDeque<Integer>();\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tif(in_num[i] == 0){\n\t\t\t\t\tQ.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint tmp,tmp2;\n\n\t\t\twhile(!Q.isEmpty()){\n\t\t\t\ttmp = Q.peek();\n\t\t\t\tQ.poll();\n\n\t\t\t\tans.append(Integer.toString(tmp)).append(\"\\n\");\n\n\t\t\t\tfor(int i = 0; i < nodes[tmp].list.size(); i++){\n\t\t\t\t\ttmp2 = nodes[tmp].list.get(i);\n\t\t\t\t\tin_num[tmp2]--;\n\t\t\t\t\tif(in_num[tmp2] == 0){\n\t\t\t\t\t\tQ.add(tmp2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(ans.toString());\n\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n}\n\nclass Node{\n\tpublic ArrayList<Integer> list;\n\n\tNode(){\n\t\tlist = new ArrayList<Integer>();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tprivate static Node[] V;\n\tprivate static ArrayList<Integer> sort = new ArrayList<>();\n\t\n\tpublic static void main(String[] args) {\n\t\tint Vn = sc.nextInt();\n\t\tint En = sc.nextInt();\n\t\t\n\t\tV = new Node[Vn];\n\t\tfor(int i=0; i<Vn; i++) {\n\t\t\tV[i] = new Node();\n\t\t\tV[i].id = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<En; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tV[s].nbr.add(t);\n\t\t}\n\t\t\n\t\tfor(int i=0; i<Vn; i++) {\n\t\t\tif(V[i].visited == 0) {\n\t\t\t\tV[i].visit();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=sort.size()-1; i>=0; i--) {\n\t\t\tSystem.out.println(sort.get(i));\n\t\t}\n\t}\n\t\n\tstatic class Node {\n\t\tint id;\n\t\tHashSet<Integer> nbr = new HashSet<>();\n\t\tint visited = 0;\n\t\t\n\t\tvoid visit() {\n\t\t\tif(visited == 1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\tSystem.exit(0);\n\t\t\t} else if(visited == 0) {\n\t\t\t\tvisited = 1;\n\t\t\t\tfor(int x : nbr) {\n\t\t\t\t\tV[x].visit();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited = 2;\n\t\t\t\tsort.add(id);\n\t\t\t} \n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n G g=new G(V,false);\n for(int i=0;i<E;i++) g.addEdge(ir.nextInt(),ir.nextInt());\n int[] tpo=g.buildTPO();\n for(int i=0;i<V;i++) out.println(tpo[i]);\n}\n\nstatic class G{\n\n AL[] g;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++){\n   g[i]=new AL();\n  }\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public int[] dijkstra(int s,int[][][] g,int[] prev){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=g[v].get(i)[0],cost=g[v].get(i)[1];\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] buildTPO(){\n  boolean[] vis=new boolean[this.V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<this.V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n private void ts(int now,booelan[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=g[now].get(i)[0];\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\t// AOJ GRL_4_B Topological Sort\n\tprivate static void solve() {\n\t\tint v = sc.nextInt();\n\t\tint ee = sc.nextInt();\n\n\t\tList<List<Integer>> edges = new ArrayList<>();\n\t\tList<List<Integer>> redges = new ArrayList<>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tedges.add(new ArrayList<>());\n\t\t\tredges.add(new ArrayList<>());\n\t\t}\n\n\t\tfor (int i = 0; i < ee; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\n\t\t\tedges.get(s).add(t);\n\t\t\tredges.get(t).add(s);\n\t\t}\n\n\t\tList<Integer> ts = new ArrayList<>();\n\n\t\tint[] cnt = new int[v];\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tcnt[i] = edges.get(i).size();\n\t\t\tif (cnt[i] == 0) {\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!q.isEmpty()) {\n\t\t\tint e = q.remove();\n\n\t\t\tts.add(e);\n\n\t\t\tfor (int d : redges.get(e)) {\n\t\t\t\tcnt[d]--;\n\t\t\t\tif (cnt[d] == 0) {\n\t\t\t\t\tq.add(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(ts);\n\n\t\tfor (int e : ts) {\n\t\t\tpr.println(e);\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tString[] firstLine = s.nextLine().split(\" \");\n\t\tint vertexCnt = Integer.parseInt(firstLine[0]);\n\t\tint edgeCnt = Integer.parseInt(firstLine[1]);\n\t\tArrayList<Integer>[] input = new ArrayList[vertexCnt];\n\t\tfor(int j=0 ; j<vertexCnt ; j++) {\n\t\t\tinput[j] = new ArrayList<Integer>();\n\t\t}\n\t\tint[] inputEdgeCnt = new int[vertexCnt];\n\t\tfor(int i=0 ; i<vertexCnt ; i++) {\n\t\t\tString[] line = s.nextLine().split(\" \");\n\t\t\tint start = Integer.parseInt(line[0]);\n\t\t\tint end = Integer.parseInt(line[1]);\n\t\t\tinput[start].add(new Integer(end));\n\t\t\tinputEdgeCnt[end]++;\n\t\t}\n\t\tArrayList<Integer> result = solve(input, inputEdgeCnt);\n\t\tObject[] list = result.toArray();\n\t\tfor(int i=0 ; i<list.length ; i++) {\n\t\t\tSystem.out.println(list[i]);\n\t\t}\n\t}\n\n\tpublic static ArrayList solve(ArrayList[] input, int[] inputEdgeCnt) {\n\t\tboolean[] already = new boolean[input.length];\n\t\tint index = 0 ;\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\toutter : while(true) {\n\t\t\tinner : for(int i=0 ; i<already.length ; i++) {\n\t\t\t\tif(already[i] == false) {\n\t\t\t\t\tbreak inner;\n\t\t\t\t}\n\t\t\t\tif(i+1 == already.length)\n\t\t\t\t\tbreak outter;\n\t\t\t}\n\n\t\t\tif(inputEdgeCnt[index]==0 && !already[index]) {\n\t\t\t\tObject[] list = input[index].toArray();\n\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t}\n\t\t\t\talready[index] = true;\n\t\t\t\tresult.add(new Integer(index));\n\t\t\t}\n\t\t\tindex++;\n\t\t\twhile(!queue.isEmpty()) {\n\t\t\t\tInteger neig = (Integer) queue.poll();\n\t\t\t\tinputEdgeCnt[neig.intValue()]--;\n\t\t\t\tif(inputEdgeCnt[neig.intValue()] == 0 && !already[neig.intValue()]) {\n\t\t\t\t\tObject[] list = input[neig.intValue()].toArray();\n\t\t\t\t\tfor(int a=0 ; a<list.length ; a++) {\n\t\t\t\t\t\tqueue.offer((Integer) list[a]);\n\t\t\t\t\t}\n\t\t\t\t\talready[neig.intValue()] = true;\n\t\t\t\t\tresult.add(new Integer(neig.intValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint id;\n\t\tSet<Integer> adj;\n\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.adj = new HashSet<>();\n\t\t}\n\n\t\tpublic void addEdge(int v) {\n\t\t\tadj.add(v);\n\t\t}\n\n\t\tpublic boolean contains(int v) {\n\t\t\treturn adj.contains(v);\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices() {\n\t\t\tList<Integer> vs = new ArrayList<>(adj);\n\n//\t\t\tvs.sort((x, y) -> x-y);\n\n\t\t\treturn vs;\n\t\t}\n\t}\n\n\tstatic class Graph {\n\t\tprivate Vertex[] vertices;\n\t\tprivate int n;\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tthis.vertices = new Vertex[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvertices[i] = new Vertex(i);\n\t\t}\n\n\t\tpublic int getNumVertices() {\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic int getIndegree(int v) {\n\t\t\tif (v < 0 || v >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (vertices[i].contains(v))\n\t\t\t\t\td++;\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices(int v) {\n\t\t\treturn vertices[v].getAdjacentVertices();\n\t\t}\n\n\t\tpublic void addEdge(int v1, int v2) {\n\t\t\tif (v1 < 0 || v2 < 0 || v1 >= n|| v2 >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tvertices[v1].addEdge(v2);\n\t\t}\t\t\t\t\t\t\t\n\t}\n\n\tpublic static List<Integer> sort(Graph g) {\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tMap<Integer, Integer> m = new HashMap<>();\n\n\t\tint n = g.getNumVertices();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d = g.getIndegree(i);\n\t\t\tm.put(i, d);\n\n\t\t\tif (d == 0)\n\t\t\t\tq.add(i);\n\t\t}\n\n\t\tList<Integer> vs = new ArrayList<>();\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = q.remove();\n\n\t\t\tvs.add(v);\n\t\t\tList<Integer> adj = g.getAdjacentVertices(v);\n\t\t\tfor (int a : adj) {\n\t\t\t\tm.replace(a, m.get(a)-1);\n\t\t\t\tif (m.get(a) == 0)\n\t\t\t\t\tq.add(a);\n\t\t\t}\n\t\t}\n\n\t\tif (vs.size() != n)\n\t\t\tthrow new IllegalStateException(\"cycle detected!\");\n\n\t\treturn vs;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tGraph g = new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\n\t\t\t\tg.addEdge(x, y);\n\t\t\t}\n\n\t\t\tList<Integer> vs = sort(g);\n\t\t\tfor (int v : vs)\n\t\t\t\tSystem.out.println(v);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tint N=sc.nextInt();\n\t\tint M=sc.nextInt();\n\t\tVertex[] graph=new Vertex[N];\n\t\tint[] ans=new int[N];\n\t\tint ansptr=0;\n\t\tint[] to=new int[N];\t//矢印の方向が向いている矢印の個数\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgraph[i]=new Vertex();\n\t\t\tto[i]=0;\n\t\t\tans[i]=0;\n\t\t}\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint graph_from=sc.nextInt();\n\t\t\tint graph_to=sc.nextInt();\n\t\t\tgraph[graph_from].add(graph_to,1);\n\t\t\tto[graph_to]++;\n\t\t}\n\t\tQueue<Integer> q=new LinkedList<Integer>();\n\t\tfor(int i=N-1; i>=0; i--) {\n\t\t\tif(to[i]==0) {\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!q.isEmpty()) {\n\t\t\tint siraberu=q.poll();\n\t\t\tans[ansptr]=siraberu;\n\t\t\tansptr++;\n\t\t\tfor(int i=0; i<graph[siraberu].size(); i++) {\n\t\t\t\tint tmp=graph[siraberu].getKey(i);\n\t\t\t\tto[tmp]--;\n\t\t\t\tif(to[tmp]==0) {\n\t\t\t\t\tq.add(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpl(ans[i]);\n\t\t}\n\t}\n\tpublic static final class Pair<K, V> {\t\t//powered by mikit\n\t\tpublic K key;\n\t\tpublic V value;\n\n\t\tpublic Pair(K key, V value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic static int getValue(Pair<Integer,Integer> a) {\n\t\t\treturn a.value;\n\t\t}\n\n\t\tpublic static int getKey(Pair<Integer,Integer> a) {\n\t\t\treturn a.key;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) return true;\n\t\t\tif (o == null || getClass() != o.getClass()) return false;\n\t\t\tPair<?, ?> pair = (Pair<?, ?>) o;\n\t\t\treturn Objects.equals(key, pair.key) &&\n\t\t\t\t\tObjects.equals(value, pair.value);\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash(key, value);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"Pair{\" +\n\t\t\t\t\t\"x=\" + key +\n\t\t\t\t\t\", y=\" + value +\n\t\t\t\t\t'}';\n\t\t}\n\t}\n\tpublic static class Vertex{\t\t//今回は2つの頂点の矢印が向いている方のリストに矢印のソースが来る\n\t\tArrayList <Pair<Integer,Integer>> rinsetu=new ArrayList<Pair<Integer,Integer>>();\n\t\tpublic void add(int V,int cost) {\n\t\t\trinsetu.add(new Pair<Integer, Integer>(V,cost));\n\t\t}\n\t\tpublic void show() {\t\t//隣接リストを出力\n\t\t\tfor(int i=0; i<rinsetu.size(); i++) {\n\t\t\t\tSystem.out.println(rinsetu.get(i));\n\t\t\t}\n\t\t}\n\t\tpublic void sort_by_cost() {\t\t//コストの低い順にソートします\n\t\t\trinsetu.sort(Comparator.comparing(p -> p.value));\n\t\t}\n\t\tpublic void sort_by_Vertex() {\t\t//向かう頂点の番号順にソートします\n\t\t\trinsetu.sort(Comparator.comparing(p -> p.key));\n\t\t}\n\t\tpublic int getValue(int i) {\n\t\t\treturn Pair.getValue(rinsetu.get(i));\t//Valueを取り出す\n\t\t}\n\t\tpublic int getKey(int i) {\n\t\t\treturn Pair.getKey(rinsetu.get(i));\t//Valueを取り出す\n\t\t}\n\t\tpublic int size() {\t\t//次数（無向なら）　でていく数（有向なら）を返す\n\t\t\treturn rinsetu.size();\n\t\t}\n\t\tpublic int find_Vertex(int a) {\t\t//ある頂点から本当に特定の辺に行くか？\n\t\t\tfor(int i=0; i<rinsetu.size(); i++) {\n\t\t\t\tif(a==Pair.getKey(rinsetu.get(i))) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nclass Graph2 {\n\tprivate int[] dist;\n\tprivate int[] visited;\n\tprivate int[] indgree;\n\tLinkedList<Integer> sorting = new LinkedList<Integer>();\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\t//adjacency list of edges\n\t/*public void addEdges(int i, int j) {\n\t\tadjList.get(i).add(j);\n\t}*/\n\tpublic Graph2() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tdist = new int[totalVertex];\n\t\tindgree = new int[totalVertex];\n\t\t/*for (int i = 0; i < dist.length; i++) {\n\t\t\tdist[i] = -1;\n\t\t}*/\n\t\tvisited = new int[totalVertex];\n\t\tfor (int j = 0; j < visited.length; j++) {\n\t\t\tvisited[j] = 0;\n\t\t}\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\tint totalEdges = in.nextInt(); \n\t\tfor (int k = 0; k < totalEdges; k++) {\n\t\t\tint source = in.nextInt();\n\t\t\tint target = in.nextInt();\n\t\t\tadjList.get(source).add(target);\n\t\t\tindgree[target]++;\n\t\t}\n\t\tin.close();\n\t}\n\tpublic void DFS(int v) {\n\t\tfor(int k : adjList.get(v)) {\n\t\t\tif (visited[k] == 0) {\n\t\t\t\tvisited[k] = 1;\n\t\t\t\tDFS(k);\n\t\t\t}\n\t\t}\n\t\tsorting.addFirst(v);\n\t}\n\tpublic void ST() {\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif (indgree[i] == 0) {\n\t\t\t\tDFS(i);\n\t\t\t}\t\n\t\t}\n\t\twhile(!sorting.isEmpty()) {\n\t\t\t System.out.println(sorting.remove());\t\n\t}\n\t}\n}\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph2 g = new Graph2();\n\t\tg.loadAdjList();\n\t\tg.ST();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n         \n        int v = sc.nextInt();\n        int e = sc.nextInt();\n        DGraph g = new DGraph(v);\n        \n        for(int i=0;i<e;i++){\n        \tg.addEdge(sc.nextInt(), sc.nextInt());\n        }\n        \n        for(int i:g.topologicalSort()){\n        \tSystem.out.println(i);\n        }\n    }\n\t\n}\n\nclass DGraph {\n\n\tNodeList[] nlist; //隣接リスト\n\t\n\tpublic DGraph(int vnum){\n\t\tthis.nlist = new NodeList[vnum];\n\t\tfor(int i=0;i<vnum;i++){\n\t\t\tnlist[i] = new NodeList();\n\t\t}\n\t}\n\t\n\t//辺の追加（同じ辺を複数回追加すると多重辺になる）\n\tvoid addEdge(int n, int m){\n\t\tnlist[n].add(m);\n\t}\n\t\n\t//頂点数を返す\n\tint vnum(){\n\t\treturn nlist.length;\n\t}\n\t\n\t//辺数を返す\n\tint edgeNum(){\n\t\tint sum = 0;\n\t\tfor(NodeList l:nlist){\n\t\t\tsum += l.size();\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\t//到達判定\n\tboolean isNext(int n, int m){\n\t\treturn nlist[n].contains(m);\n\t}\n\t\n\t//1歩で到達可能な全ての頂点を返す\n\tNodeList nextList(int n){\n\t\treturn nlist[n];\n\t}\n\n\t//トポロジカルソート（ans.size()!=vnum()ならDAGでなく、出力に意味はない））\n\tArrayList<Integer> topologicalSort(){\n\t\tint idig[] = new int[vnum()]; //入次数\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\tfor(int j:nextList(i)){\n\t\t\t\tidig[j] ++;\n\t\t\t}\n\t\t}\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\n\t\tfor(int i=0;i<vnum();i++){\n\t\t\tif(idig[i]==0){\n\t\t\t\tq.add(i); //入次数が0ならキューに入れる（DAGなら必ず存在）\n\t\t\t}\n\t\t}\n\t\t\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.pollFirst();\n\t\t\tans.add(now);\n\t\t\t\n\t\t\tfor(int j:nextList(now)){\n\t\t\t\tidig[j] --;\n\t\t\t\tif(idig[j]==0){\n\t\t\t\t\tq.add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\t//サイクルを持つか（DAGか）\n\tboolean hasCycle(){\n\t\treturn !(topologicalSort().size() == vnum());\n\t}\n\t\n\tclass NodeList extends ArrayList<Integer>{\n\t\tprivate static final long serialVersionUID = -4461479015945373120L;\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\npublic class main{\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\t\tvis = new boolean[V];\n\t\tsort(g);\n\t\tfor(int i=lis.size()-1;i>=0;--i){\n\t\t\tSystem.out.println(lis.get(i));\n\t\t}\n\t}\n\n\tstatic boolean[] vis;\n\tstatic ArrayList<Integer> lis = new ArrayList<>();\n\n\tstatic void sort(ArrayList<Integer>[] g) {\n\t\tint n = g.length;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, -1, g);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void dfs(int cur,int pre, ArrayList<Integer>[] g) {\n\t\tvis[cur] = true;\n\t\tfor (int to : g[cur]) {\n\t\t\tif (!vis[to]) {\n\t\t\t\tdfs(to, cur, g);\n\t\t\t}\n\t\t}\n\t\tlis.add(cur);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\nclass Graph2 {\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tprivate boolean[] visited = new boolean[totalVertex];\n\tprivate int[] indegree = new int[totalVertex];\n\tpublic Graph2() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tvisited = new boolean[totalVertex];\n\t\tindegree = new int[totalVertex];\n\t\tfor (int i = 0; i < visited.length; i++) {\n\t\t\tvisited[i] = false ;\n\t\t}\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t\t}\n\t\tint totalEdge = in.nextInt();\n\t\tfor (int i = 0; i < totalEdge; i++) {\n\t\t\tint root = in.nextInt(); //get the root\n\t\t\tint node = in.nextInt(); //get the node root connect to\n\t\t\tadjList.get(root).add(node); //add the node to\n\t\t\tindegree[node]++; // update the indegree of the node\n\t\t}\n\t\tin.close();\n\t}\n\tLinkedList<Integer> result = new LinkedList<Integer>();\n\tpublic void DFS(int v) {\n\t\tLinkedList<Integer> nb = adjList.get(v);\n\t\tfor(Integer i : nb) {\n\t\t\tif(visited[i] == false) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tDFS(i);\n\t\t\t}\n\t\t}\n\t\tresult.addFirst(v);\n\t\t}\n\n\tpublic void toposort() {\n\t\tfor (int i = 0; i < totalVertex; i++) {\n\t\t\tif(indegree[i] == 0) {\n\t\t\t\tDFS(i);\n\t\t\t}\n\t\t}\n\t\tfor(Integer i : result)\n\t        System.out.println(i);\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph2 g = new Graph2();\n\t\tg.loadAdjList();\n\t\tg.toposort();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\t\t//\t\tList<Integer>[] adj = new List[v];\n\t\tList<List<Integer>> adj = new ArrayList<List<Integer>>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\t//\t\t\tadj[from].add(to);\n\t\t\tadj.get(from).add(to);\n\t\t}\n\t\t// Create a array to store indegrees of all\n\t\t// vertices. Initialize all indegrees as 0.\n\t\tint indegree[] = new int[v];\n\n\t\t// Traverse adjacency lists to fill indegrees of\n\t\t// vertices. This step takes O(V+E) time\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\t//\t\t\tList<Integer> temp = adj[i];\n\t\t\tList<Integer> temp = adj.get(i);\n\t\t\tfor (int node : temp) {\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t// Create a queue and enqueue all vertices with\n\t\t// indegree 0\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0)\n\t\t\t\tq.addLast(i);\n\t\t}\n\n\t\t// Initialize count of visited vertices\n\t\tint cnt = 0;\n\n\t\t// Create a vector to store result (A topological\n\t\t// ordering of the vertices)\n\t\tVector<Integer> topOrder = new Vector<Integer>();\n\t\twhile (!q.isEmpty()) {\n\t\t\t// Extract front of queue (or perform dequeue)\n\t\t\t// and add it to topological order\n\t\t\tint u = q.removeFirst();\n\t\t\ttopOrder.add(u);\n\n\t\t\t// Iterate through all its neighbouring nodes\n\t\t\t// of dequeued node u and decrease their in-degree\n\t\t\t// by 1\n\t\t\t//\t\t\tfor (int node : adj[u]) {\n\t\t\tfor (int node : adj.get(u)) {\n\t\t\t\t// If in-degree becomes zero, add it to queue\n\t\t\t\tif (--indegree[node] == 0)\n\t\t\t\t\tq.addFirst(node);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\n\t\t// Check if there was a cycle\n\t\tif (cnt != v) {\n\t\t\tSystem.out.println(\"There exists a cycle in the graph\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Print topological order\n\t\tfor (int i : topOrder) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n            \n            List<Set<Integer>> g = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                g.add(new HashSet<>());\n\n            Queue<Integer> q = new ArrayDeque<>();\n            Map<Integer, Integer> mm = new HashMap<>();\n            for (int i = 0; i < n; i++)\n                mm.put(i, 0);\n            \n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g.get(f).add(t);\n                mm.replace(t, mm.get(t)+1);\n            }\n\n            for (Map.Entry<Integer, Integer> e : mm.entrySet()) {\n                if (e.getValue() == 0)\n                    q.add(e.getKey());\n            }\n\n            while (!q.isEmpty()) {\n                int v = q.remove();\n                out.printf(\"%d\\n\", v);\n\n                for (int vv : g.get(v)) {\n                    int d = mm.get(vv)-1;\n\n                    if (d == 0)\n                        q.add(vv);\n                    mm.replace(vv, d);\n                }\n            }\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n int[][] e=new int[E][],re=new int[E][];\n for(int i=0;i<E;i++){\n  e[i]=new int[]{ir.nextInt(),ir.nextInt(),1};\n }\n int[][][] g=make_graph(V,e);\n ArrayList<Integer> ord=new ArrayList<>();\n boolean[] vis=new boolean[V];\n for(int i=0;i<V;i++) if(!vis[i]) TopologicalSort(i,g,vis,ord);\n for(int v : ord) out.println(v);\n}\n\npublic static void TopologicalSort(int now,int[][][] g,boolean[] vis,ArrayList<Integer> ord){\n vis[now]=true;\n for(int i=0;i<g[now].length;i++){\n  if(!vis[g[now][i][0]]) TopologicalSort(g[now][i][0],g,vis,ord);\n }\n ord.add(now);\n}\n\npublic static int[][][] make_graph(int n,int[][] e){\n int[][][] ret=new int[n][][];\n int[] cnt=new int[n];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  cnt[e[i][0]]++;\n }\n for(int i=0;i<n;i++)\n  ret[i]=new int[cnt[i]][];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  ret[e[i][0]][ret[e[i][0]].length-cnt[e[i][0]]--]=new int[]{e[i][1],e[i][2]};\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().solver();\n\t}\n\tvoid solver(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tint E=sc.nextInt();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] e=new ArrayList[V];\n\t\tfor(int i=0;i<V;i++){\n\t\t\te[i]=new ArrayList<Integer>();\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s=sc.nextInt();\n\t\t\tint t=sc.nextInt();\n\t\t\te[s].add(t);\n\t\t}\n\t\tArrayDeque<Integer> ans=topological_sort(e,0);\n\t\twhile(!ans.isEmpty()){\n\t\t\tSystem.out.println(ans.poll());\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tArrayDeque<Integer> topological_sort(ArrayList<Integer>[] edges,int s){\n\t\tord=new ArrayDeque<Integer>();\n\t\tvisit=new boolean[edges.length];\n\t\tfor(int i=0;i<edges.length;i++){\n\t\t\tif(!visit[i]){\n\t\t\t\tdfs(edges,i);\n\t\t\t}\n\t\t}\n\t\treturn ord;\n\t}\n\tboolean[] visit;//true:?¨??????????false:?¨????????????????\n\tArrayDeque<Integer> ord;\n\tvoid dfs(ArrayList<Integer>[] edges,int i){\n\t\tvisit[i]=true;\n\t\tfor(int j:edges[i]){\n\t\t\tif(!visit[j]){\n\t\t\t\tdfs(edges,j);\n\t\t\t}\n\t\t}\n\t\tord.addFirst(i);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tint N, M;\n\tint[] indeg;\n\tboolean[] V;\n\tArrayList<Integer>[] G;\n\tArrayList<Integer> res;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tindeg = new int[N];\n\t\tG = new ArrayList[N];\n\t\tV = new boolean[N];\n\t\tres = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tG[i] = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tG[s].add(t);\n\t\t\tindeg[t]++;\n\t\t}\n\t\ttopologicalSort();\n\t}\n\n\tvoid topologicalSort() {\n\t\tfor (int u = 0; u < N; u++) {\n\t\t\tif (indeg[u] == 0 && !V[u]) {\n\t\t\t\tbfs(u);\n\t\t\t}\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tfor (int i = 0; i < N; i++) out.append(res.get(i) + \"\\n\");\n\t\tSystem.out.print(out);\n\t}\n\n\tvoid bfs(int s) {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tque.add(s);\n\t\tV[s] = true;\n\t\twhile (!que.isEmpty()) {\n\t\t\tint u = que.poll();\n\t\t\tres.add(u);\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u].get(i);\n\t\t\t\tindeg[v]--;\n\t\t\t\tif (indeg[v] == 0 && !V[v]) {\n\t\t\t\t\tque.add(v);\n\t\t\t\t\tV[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(char[] x, int a, int b) {\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int V=ir.nextInt();\n int E=ir.nextInt();\n int[][] e=new int[E][];\n for(int i=0;i<E;i++){\n  e[i]=new int[]{ir.nextInt(),ir.nextInt(),1};\n }\n int[][][] g=make_graph(V,e);\n ArrayList<Integer> ord=new ArrayList<>();\n boolean[] vis=new boolean[V];\n for(int i=0;i<V;i++) if(!vis[i]) TopologicalSort(i,g,vis,ord);\n for(int i=ord.size()-1;i>=0;i--) out.println(ord.get(i));\n}\n\npublic static void TopologicalSort(int now,int[][][] g,boolean[] vis,ArrayList<Integer> ord){\n vis[now]=true;\n for(int i=0;i<g[now].length;i++){\n  if(!vis[g[now][i][0]]) TopologicalSort(g[now][i][0],g,vis,ord);\n }\n ord.add(now);\n}\n\npublic static int[][][] make_graph(int n,int[][] e){\n int[][][] ret=new int[n][][];\n int[] cnt=new int[n];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  cnt[e[i][0]]++;\n }\n for(int i=0;i<n;i++)\n  ret[i]=new int[cnt[i]][];\n for(int i=0;i<e.length;i++){\n  if(e[i]==null) break;\n  ret[e[i][0]][ret[e[i][0]].length-cnt[e[i][0]]--]=new int[]{e[i][1],e[i][2]};\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * http://www.thothchildren.com/chapter/5bcc8bc051d9305189030f9f\n\t * https://tubo28.me/algorithm/tsort/\n\t * http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad09/ad09-13.pdf\n\t * https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/\n\t * トポロジカルソート\n\t */\n\tprivate void solveA() {\n\t\tint v = nextInt();\n\t\tint e = nextInt();\n\n\t\t/*\n\t\t *隣接リストの作成\n\t\t */\n\t\tList<List<Integer>> adj = new ArrayList<List<Integer>>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tadj.add(new ArrayList<Integer>());\n\t\t}\n\n\t\tfor (int i = 0; i < e; i++) {\n\t\t\tint from = nextInt();\n\t\t\tint to = nextInt();\n\t\t\tadj.get(from).add(to);\n\t\t}\n\t\t// 入次数が0のものを判定するための配列\n\t\tint indegree[] = new int[v];\n\t\t// 入次数0を判定\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tList<Integer> temp = adj.get(i);\n\t\t\t//iをfromとするnode達\n\t\t\tfor (int node : temp) {\n\t\t\t\t//入次数の個数\n\t\t\t\tindegree[node]++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * queueの作成\n\t\t * 入次数0のものをqueueに詰める\n\t\t * 入次数0から調査していく\n\t\t */\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tfor (int i = 0; i < v; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\tq.addLast(i);\n\t\t\t}\n\t\t}\n\n\t\t//訪問済み頂点数\n\t\tint cnt = 0;\n\n\t\t// トポロジカルソートの結果\n\t\tList<Integer> res = new ArrayList<Integer>();\n\n\t\t/*\n\t\t * BFS\n\t\t */\n\t\twhile (!q.isEmpty()) {\n\t\t\t// 接続先の頂点を探索開始\n\t\t\tint u = q.removeFirst();\n\t\t\t//入次数0なのでリザルトにadd\n\t\t\tres.add(u);\n\n\t\t\t// Iterate through all its neighbouring nodes\n\t\t\t// of dequeued node u and decrease their in-degree\n\t\t\t// by 1\n\t\t\tfor (int node : adj.get(u)) {\n\n\t\t\t\tindegree[node]--;\n\t\t\t\tif (indegree[node] == 0) {\n\t\t\t\t\tq.addFirst(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt > v) {\n\t\t\t\tSystem.out.println(\"graph内に循環有\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i : res) {\n\t\t\tout.println(i);\n\t\t}\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    static class Vertex {\n        int v;\n        Set<Integer> vs;\n\n        public Vertex(int v) {\n            this.v = v;\n            this.vs = new HashSet<>();\n        }\n    }\n\n    public static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n    \n            Vertex[] g = new Vertex[n];\n            for (int i = 0; i < n; i++)\n                g[i] = new Vertex(i);\n\n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g[f].vs.add(t);\n            }\n\n            List<Integer> vs = topologicalSort(g, n);\n            for (int v : vs)\n                out.printf(\"%d\\n\", v);\n            out.println();\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n    private static int getIndegree(Vertex[] g, int v) {\n        int c = 0;\n        for (int i = 0; i < g.length; i++) {\n            if (g[i].vs.contains(v))\n                c++;\n        }\n\n        return c;\n    }\n\n    private static List<Integer> getAdjacentVertices(Vertex[] g, int v) {\n        List<Integer> vs = new ArrayList<>(g[v].vs);\n        vs.sort((x, y) -> Integer.compare(x, y));\n\n        return vs;\n    }\n\n    private static List<Integer> topologicalSort(Vertex[] g, int n) {\n        Queue<Integer> q = new ArrayDeque<>();\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int d = getIndegree(g, i);\n\n            if (d == 0)\n                q.add(i);\n\n            m.put(i, d);\n        }\n\n        List<Integer> vs = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int v = q.remove();\n            vs.add(v);\n\n            for (int vv : getAdjacentVertices(g, v)) {\n                int d = m.get(vv)-1;\n\n                if (d == 0)\n                    q.add(vv);\n\n                m.replace(vv, d);\n            }\n        }\n\n        if (vs.size() != n)\n            throw new IllegalStateException(\"cycle detected\");\n\n        return vs;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint id;\n\t\tSet<Integer> adj;\n\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.adj = new HashSet<>();\n\t\t}\n\n\t\tpublic void addEdge(int v) {\n\t\t\tadj.add(v);\n\t\t}\n\n\t\tpublic boolean contains(int v) {\n\t\t\treturn adj.contains(v);\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices() {\n\t\t\tList<Integer> vs = new ArrayList<>(adj);\n\n\t\t\tvs.sort((x, y) -> x-y);\n\n\t\t\treturn vs;\n\t\t}\n\t}\n\n\tstatic class Graph {\n\t\tprivate List<Vertex> vertices;\n\t\tprivate int n;\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tthis.vertices = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvertices.add(new Vertex(i));\n\t\t}\n\n\t\tpublic int getNumVertices() {\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic int getIndegree(int v) {\n\t\t\tif (v < 0 || v >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (vertices.get(i).contains(v))\n\t\t\t\t\td++;\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic List<Integer> getAdjacentVertices(int v) {\n\t\t\treturn vertices.get(v).getAdjacentVertices();\n\t\t}\n\n\t\tpublic void addEdge(int v1, int v2) {\n\t\t\tif (v1 < 0 || v2 < 0 || v1 >= n|| v2 >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tvertices.get(v1).addEdge(v2);\n\t\t}\t\t\t\t\t\t\t\n\t}\n\n\tpublic static List<Integer> sort(Graph g) {\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tMap<Integer, Integer> m = new HashMap<>();\n\n\t\tint n = g.getNumVertices();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d = g.getIndegree(i);\n\t\t\tm.put(i, d);\n\n\t\t\tif (d == 0)\n\t\t\t\tq.add(i);\n\t\t}\n\n\t\tList<Integer> vs = new ArrayList<>();\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = q.remove();\n\n\t\t\tvs.add(v);\n\t\t\tList<Integer> adj = g.getAdjacentVertices(v);\n\t\t\tfor (int a : adj) {\n\t\t\t\tm.replace(a, m.get(a)-1);\n\t\t\t\tif (m.get(a) == 0)\n\t\t\t\t\tq.add(a);\n\t\t\t}\n\t\t}\n\n\t\tif (vs.size() != n)\n\t\t\tthrow new IllegalStateException(\"cycle detected!\");\n\n\t\treturn vs;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tGraph g = new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\n\t\t\t\tg.addEdge(x, y);\n\t\t\t}\n\n\t\t\tList<Integer> vs = sort(g);\n\t\t\tfor (int v : vs)\n\t\t\t\tSystem.out.println(v);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tNewGraph g = new NewGraph();\n\t\tg.loadAdjList();\n\t\tg.topSort();\n\t}\n}\n\nclass NewGraph {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tLinkedList<LinkedList<Integer>> adjList;\n\t//adjacency list of edges\n\tpublic NewGraph() { totalVertex = 0; }\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < totalEdge; i++) {\n\t\t\tint base = in.nextInt();\n\t\t\tint end = in.nextInt();\n\t\t\tadjList.get(base).add(end);\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\tpublic void topSort() {\n\t\tStack<Integer> stack = new Stack<>();\n\t\t\n\t\tboolean[] visted = new boolean[totalVertex];\n\t\t\n\t\tfor (int i = 0; i < totalVertex; i ++) {\n\t\t\tif (visted[i] == false) {\n\t\t\t\ttopSortRecur(i, visted, stack);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(stack.isEmpty() == false) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n\t}\n\t\n\tpublic void topSortRecur(int tgt, boolean[] visted, Stack<Integer> stack) {\n\t\tvisted[tgt] = true;\n\t\tList<Integer> tgtlist = adjList.get(tgt);\n\t\tfor(int i = 0; i < tgtlist.size(); i++) {\n\t\t\tif (visted[tgtlist.get(i)] == false) {\n\t\t\t\ttopSortRecur(tgtlist.get(i), visted, stack);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstack.push(tgt);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.Iterator;\n\nclass Graph2 {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate int[][] adjList;\n\tprivate int[] inDegree;\n\tprivate int[] outDegree;\n\tprivate LinkedList<Integer> pre = new LinkedList<Integer>();\n\tprivate int[] visited;\n\tprivate LinkedList<Integer> post = new LinkedList<Integer>();\n\t//adjacency list of edges\n\tpublic Graph2() { \n\t\ttotalVertex = 0; \n\t\ttotalEdge = 0; \n\t\tadjList = null;\n\t\tinDegree = outDegree = null;\n\t}\n\t//given graph is in edge list\n\tpublic void loadEdgeList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\ttotalEdge = in.nextInt();\n\t\tadjList = new int[totalVertex][totalVertex];\n\t\toutDegree = new int[totalVertex];\n\t\tinDegree = new int[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i ++) outDegree[i] = inDegree[i] = 0;\n\t\tfor(int i = 0; i < totalEdge; i ++) {\n\t\t\tint u = in.nextInt();\n\t\t\tint v = in.nextInt();\n\t\t\tadjList[u][outDegree[u]] = v;\n\t\t\toutDegree[u] ++;\n\t\t\tinDegree[v] ++;\n\t\t}\n\t\tin.close();\n\t\tvisited = new int[totalVertex];\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tvisited[i] = 0;\n\t\t}\n\t}\n\tpublic void DFS(int s) {\n\t\tpre.add(s); //ordering of the vertices based on when they are \"discovered\"\n\t\tvisited[s] = 1;\n\t\tfor(int i = 0; i < outDegree[s]; i ++) {\n\t\t\tint w = adjList[s][i]; \n\t\t\t//if(!pre.contains(w)) { //using this won't pass the last test case (time exceeds)\n\t\t\tif(visited[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t}\n\t\t}\n\t\tpost.add(s); //ordering of the vertices after completion of DFS\n\t}\n\tpublic LinkedList<Integer> topSortDFS() {\n\t\tfor(int i = 0; i < totalVertex; i ++) {\n\t\t\tif(inDegree[i] == 0) DFS(i);\n\t\t}\t\n\t\tLinkedList<Integer> s = new LinkedList<Integer>();\n\t\tIterator<Integer> it = post.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tint u = it.next();\n\t\t\ts.add(0, u);\n\t\t}\n\t\treturn s;\n\t}\n\tpublic LinkedList<Integer> topSortQueue() {\n\t\tLinkedList<Integer> q = new LinkedList<Integer>();\n\t\tLinkedList<Integer> s = new LinkedList<Integer>();\n\t\tint i;\n\t\tfor(i = 0; i < totalVertex; i ++) {\n\t\t\tif(inDegree[i] == 0) q.add(i);\n\t\t}\n\t\twhile(!q.isEmpty()) {\n\t\t\tint u = q.remove(0); //take the first one\n\t\t\ts.add(u);\n\t\t\tfor(i = 0; i < outDegree[u]; i ++) {\n\t\t\t\tint v = adjList[u][i];\n\t\t\t\tinDegree[v] --; \n\t\t\t\tif(inDegree[v] <= 0) {\n\t\t\t\t\tq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\t\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph2 g = new Graph2();\n\t\tg.loadEdgeList();\n\t\tLinkedList<Integer> s = g.topSortDFS();\n\t\t//LinkedList<Integer> s = g.topSortQueue();\n\t\tIterator<Integer> it = s.iterator();\n\t\twhile(it.hasNext()) System.out.println(it.next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] ve = scanner.nextLine().split(\" \", 2);\n        int v = Integer.parseInt(ve[0]);\n        int e = Integer.parseInt(ve[1]);\n\n        Map<Integer, List<Integer>> vEdges = new HashMap<>();\n\n        for (int i = 0; i < e; i++) {\n            String[] st = scanner.nextLine().split(\" \", 2);\n            int s = Integer.parseInt(st[0]);\n            int t = Integer.parseInt(st[1]);\n\n            List<Integer> edges = vEdges.get(s);\n            if (edges == null) {\n                edges = new ArrayList<>();\n                vEdges.put(s, edges);\n            }\n            edges.add(t);\n        }\n\n        Set<Integer> visited = new HashSet<>();\n        List<Integer> sorted = new ArrayList<>();\n        for (int i = 0; i < v; i++) {\n            visit(visited, sorted, vEdges, i, 0);\n        }\n\n        for (Integer vertex : sorted) {\n            System.out.println(vertex);\n        }\n    }\n\n    private static void visit(Set<Integer> visited, List<Integer> sorted, Map<Integer, List<Integer>> vEdges, int vertex, int depth) {\n        if (visited.contains(vertex)) return;\n        visited.add(vertex);\n\n        if (vEdges.containsKey(vertex)) {\n            for (Integer edge : vEdges.get(vertex)) {\n                visit(visited, sorted, vEdges, edge, depth + 1);\n            }\n        }\n        sorted.add(0, vertex);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\nimport static java.lang.System.out;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            int n = in.nextInt();\n            \n            List<Set<Integer>> g = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                g.add(new HashSet<>());\n\n            Queue<Integer> q = new ArrayDeque<>();\n            Map<Integer, Integer> mm = new HashMap<>();\n            for (int i = 0; i < n; i++)\n                mm.put(i, 0);\n            \n            int m = in.nextInt();\n            for (int i = 0; i < m; i++) {\n                int f = in.nextInt();\n                int t = in.nextInt();\n\n                g.get(f).add(t);\n                mm.replace(t, mm.get(t)+1);\n            }\n\n            for (Map.Entry<Integer, Integer> e : mm.entrySet()) {\n                if (e.getValue() == 0)\n                    q.add(e.getKey());\n            }\n\n            while (!q.isEmpty()) {\n                int v = q.remove();\n                out.printf(\"%d\\n\", v);\n\n                for (int vv : g.get(v)) {\n                    int d = mm.get(vv)-1;\n\n                    if (d == 0)\n                        q.add(vv);\n                    mm.replace(vv, d);\n                }\n            }\n        } \n            catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n    private static int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        final Scanner scanner = new Scanner(System.in);\n        solve(scanner);\n    }\n\n    static void solve(Scanner scanner) {\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        scanner.nextLine();\n\n        TopologicalSort ts = new TopologicalSort(V);\n        for (int i = 0; i < E; i++) {\n            int[] e = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n            ts.addEdge(e[0], e[1]);\n        }\n\n        List<Integer> sortedNodes = ts.run();\n        for (int n: sortedNodes) {\n            System.out.println(n);\n        }\n    }\n}\n\n\nclass TopologicalSort {\n\n    private int size;\n    private int[] inDeg;\n    public Map<Integer, Set<Edge>> edges;\n\n    public TopologicalSort(int size) {\n        this.size = size;\n        inDeg = new int[size];\n        edges = new HashMap<>();\n    }\n\n    public void addEdge(int from, int to) {\n        inDeg[to]++;\n        if (!edges.containsKey(from)) {\n            edges.put(from, new HashSet<>());\n        }\n        edges.get(from).add(new Edge(from, to, 1));\n    }\n\n    public List<Integer> run() {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < size; i++) {\n            if (inDeg[i] == 0) {\n                stack.push(i);\n            }\n        }\n\n        List<Integer> sortedNodes = new ArrayList<>();\n        while (!stack.isEmpty()) {\n            int node = stack.pop();\n            sortedNodes.add(node);\n            for (Edge e: edges.getOrDefault(node, Collections.emptySet())) {\n                inDeg[e.to]--;\n                if (inDeg[e.to] == 0) {\n                    stack.push(e.to);\n                }\n            }\n        }\n\n        // Not DAG\n        if (sortedNodes.size() < size) {\n            return Collections.emptyList();\n        }\n        return sortedNodes;\n    }\n}\n\n\nclass Edge {\n    public final int from;\n    public final int to;\n    public final int cost;\n\n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Edge edge = (Edge) o;\n        return from == edge.from &&\n                to == edge.to &&\n                cost == edge.cost;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(from, to, cost);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tg = new ArrayList[V];\n\t\tfor (int i = 0; i < V; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tg[s].add(t);\n\t\t}\n\n\t\tord = new int[V];\n\t\tvis = new boolean[V];\n\t\tpending = new boolean[V];\n\n\t\tsort();\n\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tSystem.out.println(ord[i]);\n\t\t}\n\t}\n\n\tstatic int[] ord;\n\tstatic boolean[] vis;\n\tstatic boolean[] pending;\n\tstatic int now = 0;\n\n\tstatic void sort() {\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!vis[i])\n\t\t\t\tdfs(i, -1);\n\t\t}\n\t}\n\n\tstatic void dfs(int cur, int pre) {\n\t\tfor (int to : g[cur]) {\n\t\t\tif (to != pre && !vis[to]) {\n\t\t\t\tif (pending[to])\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tdfs(to, cur);\n\t\t\t}\n\t\t}\n\t\tord[V - now - 1] = cur;\n\t\tvis[cur] = true;\n\t\t++now;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//template code, C343, 2019\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tprivate int[] completion;\n\tprivate boolean[] seen;\n\tprivate int[] indegree;\n\n\t// adjacency list of edges\n\tpublic Graph() {\n\t\ttotalVertex = 0;\n\t}\n\n\tpublic void loadAdjList() {\n\t\tScanner in = new Scanner(System.in);\n\t\ttotalVertex = in.nextInt();\n\t\tcompletion = new int[totalVertex];\n\t\tseen = new boolean[totalVertex];\n\t\tindegree = new int[totalVertex];\n\t\t\n\t\tint totalEdges = in.nextInt();\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\t\n\t\tfor(int i = 0; i < totalVertex ; i++) {\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tadjList.add(tmp);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < totalEdges; i++) {\n\t\t\tint vert = in.nextInt();\n\t\t\tint out = in.nextInt();\n\t\t\tadjList.get(vert).add(out);\n\t\t\tindegree[out]++;\n\t\t}\n\t\t\n\t\tin.close();\n\t}\n\t\n\t/**\n\t * performs DFS on the graph, populating completion starting with \n\t * pos by order of completion and returns the next available pos\n\t */\n\tpublic int topSortDFS(int start, int pos) {\n\t\tLinkedList<Integer> neighbors = adjList.get(start);\n\t\tseen[start] = true;\n\t\t\n\t\tfor(Integer n : neighbors) {\n\t\t\tif(!seen[n]) {\n\t\t\tpos = topSortDFS(n, pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcompletion[pos] = start;\n\t\treturn pos + 1;\n\t}\n\n\tpublic void printTopological() {\n\t\tint pos = 0;\n\t\tfor(int i = 0; i<totalVertex; i++) {\n\t\t\tif(!seen[i]) {\n\t\t\t\tpos = topSortDFS(i, pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = totalVertex - 1; i >= 0; i--) {\n\t\t\tSystem.out.println(completion[i]);\n\t\t}\n\t}\n\t\n\tpublic void eligibleMethod() {\n\t\tQueue<Integer> eligible = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(indegree[i] == 0) {\n\t\t\t\teligible.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!eligible.isEmpty()) {\n\t\t\tint cur = eligible.poll();\n\t\t\tSystem.out.println(cur);\n\t\t\tfor(Integer n : adjList.get(cur)) {\n\t\t\t\tindegree[n]--;\n\t\t\t\tif(indegree[n] == 0) {\n\t\t\t\t\teligible.add(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n//change class name GraphRepresentation to Main() for submission to AIZU\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\t// g.updateTimes();\n\t\t// g.printTimeStamps();\n\t\t// g.printAdjMatrix();\n\t\t//g.printShortestPaths();\n\t\tg.eligibleMethod();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static ArrayList<LinkedList<Integer>> graph;\n    private static int[] in;\n    public static void main(String[] args) throws Exception{\n        FastScanner scanner = new FastScanner();\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        graph = new ArrayList<>(V);\n        in = new int[V];\n        for(int i = 0; i < V; ++i){\n            graph.add(new LinkedList<>());\n        }\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n            ++in[v];\n        }\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for(int i = 0; i < V; ++i){\n            if(in[i] == 0){\n                queue.add(i);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>(V);\n        while(!queue.isEmpty()){\n            Integer u = queue.remove();\n            result.add(u);\n            for(Integer v : graph.get(u)){\n                --in[v];\n                if(in[v] == 0){\n                    queue.add(v);\n                }\n            }\n        }\n\n        PrintWriter printWriter = new PrintWriter(System.out);\n        for(Integer n : result){\n            printWriter.println(n);\n        }\n        printWriter.flush();\n    }\n\n    private static class FastScanner{\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*; \nimport java.util.*; \n  \nclass Graph { \n    ArrayList<Integer> adjArr[];\n  \n    @SuppressWarnings(\"unchecked\")\n\tGraph(int v) {\n        adjArr = new ArrayList[v]; \n        for (int i=0; i < v; ++i) \n            adjArr[i] = new ArrayList<Integer>(); \n    } \n  \n    // Add directed pair to graph\n    void addToGraph(int id, int neighbor) { \n    \tadjArr[id].add(neighbor); \n    \t}\n    \n    // Topologically sorts adjacency list graph into a stack\n    void topsort(int v, boolean visited[], Stack<Integer> stack) {  \n        // Mark current as visited\n    \tvisited[v] = true; \n        int i; \n\n        Iterator<Integer> it = adjArr[v].iterator(); \n        while (it.hasNext()) { \n            i = it.next(); \n            // Topsort through all unvisited adjacent vertices before adding to stack\n            if (!visited[i]) \n                topsort(i, visited, stack); \n        } \n        stack.push(v); \n    }\n}\n\npublic class Main {\n  \n    public static void main(String args[]) \n    { \n    \tScanner in = new  Scanner(System.in);\n\n\t\tint totalVertex = in.nextInt();\n\t\tGraph adj = new Graph(totalVertex);\n\t\t\n\t\tint totalConnections = in.nextInt();\n\t\t\n\t\tint id, neighbor;\n\t\t\n\t\tfor (int i = 0; i < totalConnections; i++) {\n\t\t\tid = in.nextInt();\n\t\t\tneighbor = in.nextInt();\n\t\t\tadj.addToGraph(id, neighbor);\n\t\t}\n\t\t\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\n\t\tboolean[] visited = new boolean[totalVertex];\n\t\t// Initialize visited array with false\n\t\tfor(int i = 0; i < totalVertex; i++){\n\t\t\tvisited[i] = false;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tadj.topsort(i, visited, stack);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!stack.isEmpty()) {\n\t\t\tSystem.out.println(stack.pop());\n\t\t}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tint id;\n\t\tSet<Integer> adj;\n\n\t\tpublic Vertex(int id) {\n\t\t\tthis.id = id;\n\t\t\tthis.adj = new HashSet<>();\n\t\t}\n\n\t\tpublic void addEdge(int v) {\n\t\t\tadj.add(v);\n\t\t}\n\n\t\tpublic boolean contains(int v) {\n\t\t\treturn adj.contains(v);\n\t\t}\n\n\t\tpublic Integer[] getAdjacentVertices() {\n\t\t\tInteger[] vs = new Integer[adj.size()];\n\t\t\tadj.toArray(vs);\n\n\t\t\treturn vs;\n\t\t}\n\t}\n\n\tstatic class Graph {\n\t\tprivate Vertex[] vertices;\n\t\tprivate int n;\n\n\t\tpublic Graph(int n) {\n\t\t\tthis.n = n;\n\n\t\t\tthis.vertices = new Vertex[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tvertices[i] = new Vertex(i);\n\t\t}\n\n\t\tpublic int getNumVertices() {\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic int getIndegree(int v) {\n\t\t\tif (v < 0 || v >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tint d = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (vertices[i].contains(v))\n\t\t\t\t\td++;\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\t\tpublic Integer[] getAdjacentVertices(int v) {\n\t\t\treturn vertices[v].getAdjacentVertices();\n\t\t}\n\n\t\tpublic void addEdge(int v1, int v2) {\n\t\t\tif (v1 < 0 || v2 < 0 || v1 >= n|| v2 >= n)\n\t\t\t\tthrow new IllegalArgumentException(\"invalid vertex\");\n\n\t\t\tvertices[v1].addEdge(v2);\n\t\t}\t\t\t\t\t\t\t\n\t}\n\n\tpublic static List<Integer> sort(Graph g) {\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tMap<Integer, Integer> m = new HashMap<>();\n\n\t\tint n = g.getNumVertices();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d = g.getIndegree(i);\n\t\t\tm.put(i, d);\n\n\t\t\tif (d == 0)\n\t\t\t\tq.add(i);\n\t\t}\n\n\t\tList<Integer> vs = new ArrayList<>();\n\t\twhile (!q.isEmpty()) {\n\t\t\tint v = q.remove();\n\n\t\t\tvs.add(v);\n\t\t\tInteger[] adj = g.getAdjacentVertices(v);\n\t\t\tfor (int a : adj) {\n\t\t\t\tm.replace(a, m.get(a)-1);\n\t\t\t\tif (m.get(a) == 0)\n\t\t\t\t\tq.add(a);\n\t\t\t}\n\t\t}\n\n\t\tif (vs.size() != n)\n\t\t\tthrow new IllegalStateException(\"cycle detected!\");\n\n\t\treturn vs;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tGraph g = new Graph(n);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\n\t\t\t\tg.addEdge(x, y);\n\t\t\t}\n\n\t\t\tList<Integer> vs = sort(g);\n\t\t\tfor (int v : vs)\n\t\t\t\tSystem.out.println(v);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nclass Graph {\n\tprivate int totalVertex;\n\tprivate int totalEdge;\n\tprivate LinkedList<LinkedList<Integer>> adjList;\n\tprivate int[] degree;\n\n\tpublic Graph() {\n\t\ttotalVertex = 0;\n\t\ttotalEdge = 0;\n\t}\n\n\tpublic void loadAdjList() {\n\t\tScanner sc = new Scanner(System.in);\n\t\ttotalVertex = sc.nextInt();\n\t\ttotalEdge = sc.nextInt();\n\t\tdegree = new int[totalVertex];\n\t\tadjList = new LinkedList<LinkedList<Integer>>();\n\t\t\n\t\tfor(int i = 0; i < totalVertex ; i++) {\n\t\t\tLinkedList<Integer> vert = new LinkedList<Integer>();\n\t\t\tadjList.add(vert);\n\t\t\tdegree[i] = 0;\n\t\t}\n\t\t\n\t\tint row;\n\t\tint col;\n\t\tfor (int i = 0; i < totalEdge; i++) {\n\t\t\trow = sc.nextInt();\n\t\t\tcol = sc.nextInt();\n\t\t\tadjList.get(row).add(col);\n\t\t\tdegree[col] += 1;\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic void eligible() {\n\t\tQueue<Integer> eligibleQ = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < totalVertex; i++) {\n\t\t\tif(degree[i] == 0) {\n\t\t\t\teligibleQ.add(i);\n\t\t\t}\n\t\t}\n\t\twhile(!eligibleQ.isEmpty()) {\n\t\t\tint num = eligibleQ.poll();\n\t\t\tSystem.out.println(num);\n\t\t\tfor(Integer n : adjList.get(num)) {\n\t\t\t\tdegree[n] -= 1;\n\t\t\t\tif(degree[n] == 0) {\n\t\t\t\t\teligibleQ.add(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String argv[]) {\n\t\tGraph g = new Graph();\n\t\tg.loadAdjList();\n\t\tg.eligible();\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.Out.Flush();\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var sorted = new List<int>();\n        var mark = new byte[E.Length];\n        var stack = new Stack<int>();\n\n        for (int v = E.Length - 1; v >= 0; v--)\n            if (mark[v] == 0)\n            {\n                stack.Push(v);\n                while (stack.Count > 0)\n                {\n                    int a = stack.Pop();\n                    if (a < 0) { sorted.Add(~a); mark[~a] = 2; continue; }\n                    if (mark[a] == 1) return null; // has cycle\n                    if (mark[a] == 2) continue;\n                    mark[a] = 1;\n                    stack.Push(~a);\n                    for (int i = E[a].Count - 1; i >= 0; i--)\n                        stack.Push(E[a][i]);\n                }\n            }\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Competitive\n{\n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            int[] values = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            int N = values[0];\n            int E = values[1];\n\n            var G = new Graph<int>();\n            for(int i = 0; i < N; i++) G.AddNode(i);\n            for (int i = 0; i < E; i++)\n            {\n                int[] _edges = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                G.AddEdge(_edges[0], _edges[1]);\n            }\n\n            var ret = G.TopologicalSort();\n            for (int i = 0; i < ret.Count; i++)\n            {\n                Console.WriteLine(ret[i]);\n            }\n\n        }\n    }\n    \n     // 有向グラフ\n    internal class Graph<T>\n    {\n        private List<Node> nodes;\n        private List<Edge> edges;\n        private Dictionary<T, Node> dic;\n\n        private Node this[int index]\n        {\n            get { return nodes[index]; }\n        }\n\n        internal class Node\n        {\n            public int No;\n            public T Obj;\n            public List<Edge> Edges;\n\n            public Node(int no, T obj)\n            {\n                No = no;\n                Obj = obj;\n                Edges = new List<Edge>();\n            }\n        }\n\n        internal class Edge\n        {\n            public int From;\n            public int To;\n        }\n        \n        public Graph()\n        {\n            nodes = new List<Node>();\n            edges = new List<Edge>();\n            dic = new Dictionary<T, Node>();\n        }\n\n        public List<T> Nodes()\n        {\n            return nodes.Select(n => n.Obj).ToList();\n        }\n\n        public List<T> Successors(T obj)\n        {\n            var node = dic[obj];\n            return node.Edges.Select(e => this[e.To].Obj).Distinct().ToList();\n        }\n\n        public void AddNode(T obj)\n        {\n            // TODO: 重複処理\n            if (dic.ContainsKey(obj))\n            {\n                throw new Exception(\"既にノードに存在します\");\n            }\n            int no = nodes.Count;\n            var node = new Node (no, obj);\n            dic.Add(obj, node);\n            nodes.Add(node);\n        }\n\n        public void AddEdge(T fm, T to)\n        {\n            if (!dic.ContainsKey(fm) || !dic.ContainsKey(to)) throw new Exception(\"ノードが存在しません\");\n            var fmIdx = dic[fm].No;\n            var toIdx = dic[to].No;\n            var edge = new Edge {From = fmIdx, To = toIdx};\n            edges.Add(edge);\n            this[fmIdx].Edges.Add(edge);\n        }\n\n        public List<List<T>> Condensation()\n        {\n            throw new NotImplementedException();\n        }\n        \n        public List<T> TopologicalSort()\n        {\n            // DFSを行う\n            // TODO: 辞書式トポロジカルソートの方が安定するか？\n            // 閉路が存在した場合、nullを返す\n            // 閉路が存在しない場合、探索済のノードから順にセットしていく。それを反転したものを返り値とする。\n            // http://www.prefield.com/algorithm/graph/topological_sort.html\n\n            int n = nodes.Count;\n            var color = Util.EmptyList<int>(n);\n            var order = new List<int>();\n\n            for (int i = 0; i < n; i++)\n                if (color[i] == 0)\n                {\n                    bool visitSuccess = Visit(i);\n                    if (!visitSuccess) return null;\n                }\n\n            order.Reverse();\n            return order.Select(i => this[i].Obj).ToList();\n\n            bool Visit(int i)\n            {\n                color[i] = 1; // 探索中\n                var node = this[i]; \n                foreach (var e in node.Edges)\n                {\n                    if (color[e.To] == 2) continue; // 探索済\n                    if (color[e.To] == 1) return false; // 探索中Nodeに到達してしまった\n                    bool visitSuccess = Visit(e.To);\n                    if (!visitSuccess) return false;\n                }\n                order.Add(i);\n                color[i] = 2; // 探索済\n                return true;\n            }\n           \n        }\n        \n        internal static class Util\n        {\n            public static List<T> EmptyList<T>(int count)\n            {\n                return Enumerable.Range(0, count).Select(i => default(T)).ToList();\n            }\n        }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Competitive\n{\n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            int[] values = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            int N = values[0];\n            int E = values[1];\n\n            var G = new Graph<int>();\n            for (int i = 0; i < N; i++) G.AddNode(i);\n            for (int i = 0; i < E; i++)\n            {\n                int[] _edges = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                G.AddEdge(_edges[0], _edges[1]);\n            }\n\n            var ret = G.TopologicalSort();\n            for (int i = 0; i < ret.Count; i++)\n            {\n                Console.WriteLine(ret[i]);\n            }\n\n        }\n    }\n\n    // 有向グラフ\n    internal class Graph<T>\n    {\n        private List<Node> nodes;\n        private List<Edge> edges;\n        private Dictionary<T, Node> dic;\n\n        private Node this[int index]\n        {\n            get { return nodes[index]; }\n        }\n\n        internal class Node\n        {\n            public int No;\n            public T Obj;\n            public List<Edge> Edges;\n\n            public Node(int no, T obj)\n            {\n                No = no;\n                Obj = obj;\n                Edges = new List<Edge>();\n            }\n        }\n\n        internal class Edge\n        {\n            public int From;\n            public int To;\n        }\n\n        public Graph()\n        {\n            nodes = new List<Node>();\n            edges = new List<Edge>();\n            dic = new Dictionary<T, Node>();\n        }\n\n        public List<T> Nodes()\n        {\n            return nodes.Select(n => n.Obj).ToList();\n        }\n\n        public List<T> Successors(T obj)\n        {\n            var node = dic[obj];\n            return node.Edges.Select(e => this[e.To].Obj).Distinct().ToList();\n        }\n\n        public void AddNode(T obj)\n        {\n            // TODO: 重複処理\n            if (dic.ContainsKey(obj))\n            {\n                throw new Exception(\"既にノードに存在します\");\n            }\n\n            int no = nodes.Count;\n            var node = new Node(no, obj);\n            dic.Add(obj, node);\n            nodes.Add(node);\n        }\n\n        public void AddEdge(T fm, T to)\n        {\n            if (!dic.ContainsKey(fm) || !dic.ContainsKey(to)) throw new Exception(\"ノードが存在しません\");\n            var fmIdx = dic[fm].No;\n            var toIdx = dic[to].No;\n            var edge = new Edge {From = fmIdx, To = toIdx};\n            edges.Add(edge);\n            this[fmIdx].Edges.Add(edge);\n        }\n\n        public List<List<T>> Condensation()\n        {\n            throw new NotImplementedException();\n        }\n\n        public List<T> TopologicalSort()\n        {\n            // DFSを行う\n            // TODO: 辞書式トポロジカルソートの方が安定するか？\n            // 閉路が存在した場合、nullを返す\n            // 閉路が存在しない場合、探索済のノードから順にセットしていく。それを反転したものを返り値とする。\n            // http://www.prefield.com/algorithm/graph/topological_sort.html\n\n            int n = nodes.Count;\n            var color = Util.EmptyList<int>(n);\n            var order = new List<int>();\n\n            for (int i = 0; i < n; i++)\n                if (color[i] == 0)\n                {\n                    bool visitSuccess = Visit(i, color, order);\n                    if (!visitSuccess) return null;\n                }\n\n            order.Reverse();\n            return order.Select(i => this[i].Obj).ToList();\n\n        }\n\n        bool Visit(int i, List<int> color, List<int> order)\n        {\n            color[i] = 1; // 探索中\n            var node = this[i];\n            foreach (var e in node.Edges)\n            {\n                if (color[e.To] == 2) continue; // 探索済\n                if (color[e.To] == 1) return false; // 探索中Nodeに到達してしまった\n                bool visitSuccess = Visit(e.To, color, order);\n                if (!visitSuccess) return false;\n            }\n\n            order.Add(i);\n            color[i] = 2; // 探索済\n            return true;\n        }\n\n      \n    }\n    \n    internal static class Util\n    {\n        public static List<T> EmptyList<T>(int count)\n        {\n            return Enumerable.Range(0, count).Select(i => default(T)).ToList();\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var inputs = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n        var vSize = inputs[0];\n        var eSize = inputs[1];\n\n        // 0, ... , vSize - 1のラベルがついた頂点\n        var graph = new Graph<int>(Enumerable.Range(0, vSize));\n        \n        for(int  i = 0; i < eSize; i++)\n        {\n            var edge = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            graph.AddEdges(edge[0], edge[1]);\n        }\n\n        foreach (var item in TopologicalSort<int>.Excute(graph))\n            Console.WriteLine(item);\n    }\n}\n\npublic static class TopologicalSort<T>\n{\n    // 入力されたノード\n    private static Dictionary<T, List<T>> _nodes;\n\n    // 既に訪問したかどうかを記録しておく\n    private static Dictionary<T, bool> _seenVertexes;\n\n    // トポロジカルソートされた結果を格納する\n    private static Stack<T> _sortedNodes;\n\n    public static IEnumerable<T> Excute(Graph<T> graph)\n    {\n        _seenVertexes = new Dictionary<T, bool>();\n        _nodes = graph.Nodes;\n        _sortedNodes = new Stack<T>(_nodes.Count);\n\n        foreach (var node in _nodes)\n            Visit(node.Key);\n\n        _nodes = null;\n        _seenVertexes = null;\n\n        foreach (var node in _sortedNodes)\n            yield return node;\n\n        _sortedNodes = null;\n    }\n\n    private static void Visit(T node)\n    {\n        if (!_seenVertexes.ContainsKey(node))\n        {\n            _seenVertexes[node] = true;\n            foreach (var to in _nodes[node])\n                Visit(to);\n            _sortedNodes.Push(node);\n        }\n    }\n}\n\npublic class Graph<T>\n{\n    // <頂点, 接続先の頂点>\n    public Dictionary<T, List<T>> Nodes { get; private set; }\n\n    /// <summary>\n    /// グラフ作成\n    /// </summary>\n    /// <param name=\"nodes\">頂点のラベルのコレクション</param>\n    public Graph(IEnumerable<T> nodes)\n    {\n        Nodes = new Dictionary<T, List<T>>();\n        foreach (var node in nodes)\n            Nodes[node] = new List<T>();\n    }\n\n    /// <summary>\n    /// 頂点を追加する\n    /// </summary>\n    /// <param name=\"node\">追加する頂点のラベル</param>\n    /// <returns>追加できたか</returns>\n    public bool AddVertex(T node)\n    {\n        if (Nodes.ContainsKey(node)) return false;\n\n        Nodes[node] = new List<T>();\n        return true;\n    }\n\n    /// <summary>\n    /// 辺を追加する\n    /// </summary>\n    /// <param name=\"from\">接続元の頂点</param>\n    /// <param name=\"to\">接続先の頂点</param>\n    /// <returns>追加できたか</returns>\n    public bool AddEdges(T from, T to)\n    {\n        if (!Nodes.ContainsKey(from) || !Nodes.ContainsKey(to)) return false;\n\n        Nodes[from].Add(to);\n        return true;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Threading.Tasks;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int V = cin.nextint;\n        int E = cin.nextint;\n        var SCC = new StronglyConnectedComponents();\n        var G = SCC.Input(V, E, 0);\n        SCC.Run(G);\n        foreach (var v in SCC.order)\n        {\n            WriteLine(v);\n        }\n    }\n\n}\n\nclass StronglyConnectedComponents\n{\n    List<int>[] gg, rg;\n    public List<int>[] dag;\n    public int[] comp;\n    bool[] used;\n    public List<int> order;\n    int[] size;\n    int[] cont;\n\n    public List<int>[] Input(int n, int m, int indexed = 1)\n    {\n        var cin = new Scanner();\n        var G = new List<int>[n];\n        for (int i = 0; i < G.Length; i++)\n        {\n            G[i] = new List<int>();\n        }\n        for (int i = 0; i < m; i++)\n        {\n            int a = cin.nextint - indexed;\n            int b = cin.nextint - indexed;\n            G[a].Add(b);\n        }\n        return G;\n    }\n    public int Run(List<int>[] G)\n    {\n        int n = G.Length;\n        comp = new int[n];\n        used = new bool[n];\n        order = new List<int>();\n        gg = new List<int>[n];\n        rg = new List<int>[n];\n        for (int i = 0; i < n; i++)\n        {\n            gg[i] = new List<int>();\n            rg[i] = new List<int>();\n            comp[i] = -1;\n        }\n        for (int i = 0; i < n; i++)\n        {\n            foreach (var v in G[i])\n            {\n                gg[i].Add(v);\n                rg[v].Add(i);\n            }\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            dfs(i);\n        }\n        order.Reverse();\n        int ptr = 0;\n        foreach (var i in order)\n        {\n            if (comp[i] != -1) continue;\n            rdfs(i, ptr);\n            ptr++;\n        }\n\n        cont = new int[ptr];\n        size = new int[ptr];\n        dag = new List<int>[ptr];\n        for (int i = 0; i < dag.Length; i++)\n        {\n            dag[i] = new List<int>();\n        }\n        for (int i = 0; i < n; i++)\n        {\n            cont[comp[i]] = i;\n            size[comp[i]]++;\n            foreach (var to in G[i])\n            {\n                int x = comp[i];\n                int y = comp[to];\n                if (x == y) continue;\n                dag[x].Add(y);\n            }\n        }\n\n        return ptr;\n    }\n    void dfs(int idx)\n    {\n        if (used[idx]) return;\n        used[idx] = true;\n        foreach (var to in gg[idx])\n        {\n            dfs(to);\n        }\n        order.Add(idx);\n    }\n    void rdfs(int idx, int cnt)\n    {\n        if (comp[idx] != -1) return;\n        comp[idx] = cnt;\n        foreach (var to in rg[idx])\n        {\n            rdfs(to, cnt);\n        }\n    }\n    public int this[int id] => comp[id];\n    /// <summary>\n    /// トポロジカル順序がkである頂点の数\n    /// </summary>\n    /// <param name=\"k\">トポロジカル順序の番号</param>\n    /// <returns>頂点数</returns>\n    public int Size(int k) => size[k];\n    /// <summary>\n    /// トポロジカル順序がkを代表する頂点\n    /// </summary>\n    /// <param name=\"k\">トポロジカル順序の番号</param>\n    /// <returns>頂点番号</returns>\n    public int Cont(int k) => cont[k];\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Practice\n{\n    class Program\n    {\n        private static int ReadAndParseInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n        private static int[] ReadAndParseIntArr()\n        {\n            return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n        }\n        private static long ReadAndParseLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n        private static long[] ReadAndParseLongArr()\n        {\n            return Array.ConvertAll(Console.ReadLine().Split(' '), long.Parse);\n        }\n        static void Main(string[] args)\n        {\n            SolveA(args);\n            //SolveB(args);\n            //SolveC(args);\n            //SolveD(args);\n\n\n        }\n        private static void SolveA(string[] args)\n        {\n            int[] ve = ReadAndParseIntArr();\n            int v = ve[0];\n            int e = ve[1];\n            List<int>[] graph = new List<int>[v];\n            // 初期化\n            for (int i = 0; i < v; ++i)\n            {\n                var list = new List<int>();\n\n                graph[i] = list;\n            }\n            int[] indeg = new int[v];\n\n            for (int i=0;i<e;++i)\n            {\n                int[] st = ReadAndParseIntArr();\n                graph[st[0]].Add(st[1]);\n                //graph[st[1]].Add(st[0]);\n\n                indeg[st[1]]++;\n            }\n\n            List<int> outList = new List<int>();\n            topologicalSort(graph, indeg, outList);\n\n            foreach(int u in outList)\n            {\n                Console.WriteLine(u);\n            }\n        }\n        private const int kWhite = 0;\n        private const int kGray = 1;\n        private const int kBlack = 2;\n        private static void topologicalSort(List<int>[] graph, int[] indeg, List<int> outList)\n        {\n            int v = graph.Length;\n            int[] color = new int[v];\n\n            for(int u = 0; u < v; ++u)\n            {\n                if( indeg[u] == 0 && color[u] == kWhite)\n                {\n                    bfs(u, graph, color, indeg, outList);\n                }\n            }\n        }\n        private static Queue<int> Q = new Queue<int>();\n        private static void bfs(int s, List<int>[] graph, int[] color, int[] indeg, List<int> outList)\n        {\n            Q.Enqueue(s);\n            color[s] = kGray;\n            while(Q.Count >= 1)\n            {\n                int u = Q.Dequeue();\n                outList.Add(u);\n\n                List<int> list = graph[u];\n                foreach(int v in list)\n                {\n                    indeg[v]--;\n                    if(indeg[v] == 0 && color[v] == kWhite)\n                    {\n                        color[v] = kGray;\n                        Q.Enqueue(v);\n                    }\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<int>[] li;\n\tstatic bool[] b;\n\tstatic int k=0;\n\tstatic int[] ans;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tli=new List<int>[s[0]];\n\t\tb=new bool[s[0]];\n\t\tk=s[0]-1;\n\t\tfor(int i=0;i<s[0];i++){li[i]=new List<int>();}\n\t\tfor(int i=0;i<s[1];i++){\n\t\t\tint[] e=sc.Ia;\n\t\t\tli[e[0]].Add(e[1]);\n\t\t}\n\t\tans=new int[s[0]];\n\t\tfor(int i = 0;i<s[0];i++) {\n\t\t\tif(!b[i]){Fu(i);}\n\t\t}\n\t\tConsole.WriteLine(String.Join(\"\\n\",ans));\n\t}\n\tstatic void Fu(int a){\n\t\tb[a]=true;\n\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i]]){Fu(li[a][i]);}\n\t\t}\n\t\tans[k]=a;\n\t\tk--;\n\t}\n}\n\npublic class Sc{\n\tprivate string[] a;\n\tprivate int n=-1,m=0;\n\tpublic int I{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return int.Parse(a[n]);}}\n\tpublic long L{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return long.Parse(a[n]);}}\n\tpublic double D{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return double.Parse(a[n]);}}\n\tpublic string S{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return a[n];}}\n\tpublic int[] Ia{get{if(n!=-1&&n!=a.Length-1){m=n;n=-1;return Array.ConvertAll(a.Skip(m+1).ToArray(),int.Parse);}return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic string[] Sa2{get{return (\"# \"+Console.ReadLine()).Split();}}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\n\nnamespace SolveSpace\n{\n    using static System.Console;\n    using static System.Convert;\n    using static System.Math;\n    using Pi = Pair<int, int>;\n    using Number = System.Int64;\n\n    class Solver\n    {\n        public void Solve()\n        {\n            int v, e;\n            Input.Make(out v, out e);\n            var g = new TopologicalSort(v);\n            for (var i = 0; i < e; i++)\n                g.AddEdge(Input.Next<int>(), Input.Next<int>());\n\n            Console.WriteLine(string.Join(\"\\n\", g.Execute()));\n        }\n    }\n    public class TopologicalSort\n    {\n        private List<int>[] g;\n        private int[] indeg;\n        private List<int> list;\n        public TopologicalSort(int count)\n        { g = Create(count, () => new List<int>()); indeg = new int[count]; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void AddEdge(int from, int to)\n        {\n            g[from].Add(to);\n            indeg[to]++;\n        }\n        public List<int> Execute()\n        {\n            list = new List<int>(g.Length);\n            var q = new Queue<int>();\n            for (var i = 0; i < g.Length; i++)\n                if (indeg[i] == 0)\n                    q.Enqueue(i);\n            while (q.Any())\n            {\n                var p = q.Dequeue();\n                list.Add(p);\n                foreach (var e in g[p])\n                    if (--indeg[e] == 0)\n                        q.Enqueue(e);\n            }\n            return list;\n        }\n    }\n}\n\n#region Template\npublic class Template\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == 1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == -1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T v1, ref T v2)\n    { var t = v2; v2 = v1; v1 = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n        => Enumerable.Repeat(0, n).Select(_ => f()).ToArray();\n    public static void Fail() => Fail(\"No\");\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n    static void Main(string[] args)\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        var p = new SolveSpace.Solver();\n        for (var i = 1; i > 0; --i)\n            p.Solve();\n        Console.Out.Flush();\n    }\n}\n\npublic class Input\n{\n    public static string read => Console.ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => Convert.ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => Convert.ToInt64(read);\n    public static char[][] grid(int h)\n        => Create(h, () => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => Create(n, () => num);\n    public static long[] arL1D(int n)\n        => Create(n, () => numL);\n    public static string[] strs(int n)\n        => Create(n, () => read);\n    public static int[][] ar2D(int n)\n        => Create(n, () => ar);\n    public static long[][] arL2D(int n)\n        => Create(n, () => arL);\n    public static List<T>[] edge<T>(int n)\n        => Create(n, () => new List<T>());\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    static Input()\n    {\n        sc = new Queue<string>();\n        dic = new Dictionary<Type, Func<string, object>>();\n        dic[typeof(int)] = s => int.Parse(s);\n        dic[typeof(long)] = s => long.Parse(s);\n        dic[typeof(char)] = s => char.Parse(s);\n        dic[typeof(double)] = s => double.Parse(s);\n        dic[typeof(uint)] = s => uint.Parse(s);\n        dic[typeof(ulong)] = s => ulong.Parse(s);\n        dic[typeof(string)] = s => s;\n    }\n    private static Dictionary<Type, Func<string, object>> dic;\n    private static Queue<string> sc;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T Next<T>() { if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item); return (T)dic[typeof(T)](sc.Dequeue()); }\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        var stack = new Stack<int>();\n\n        for (int v = E.Length - 1; v >= 0; v--)\n            if (!seen[v])\n            {\n                stack.Push(v);\n                while (stack.Count > 0)\n                {\n                    int a = stack.Pop();\n                    if (a < 0) { sorted.Add(~a); continue; }\n                    stack.Push(~a);\n                    seen[a] = true;\n                    for (int i = E[a].Count - 1; i >= 0; i--)\n                        if (!seen[E[a][i]])\n                            stack.Push(E[a][i]);\n                }\n            }\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public List<int> from { get; set; }\n    public List<int> to { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var e = int.Parse(line[1]);\n        var d = new Dictionary<int, P>();\n        for (int i = 0; i < n; i++) d[i] = new P { from = new List<int>(), to = new List<int>() };\n        for (int i = 0; i < e; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            var s = int.Parse(line[0]);\n            var t = int.Parse(line[1]);\n            d[s].to.Add(t);\n            d[t].from.Add(s);\n        }\n        foreach (var x in tsort(d, n)) Console.WriteLine(x);\n    }\n    public static List<int> tsort(Dictionary<int, P> d, int n)\n    {\n        var ret = new List<int>();\n        var q = new Queue<int>();\n        for (int i = 0; i < n; i++) q.Enqueue(i);\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (d[w].from.Count == 0)\n            {\n                ret.Add(w);\n                foreach (var x in d[w].to) d[x].from.Remove(w);\n            }\n            else q.Enqueue(w);\n        }\n        return ret;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        Console.WriteLine(string.Join(\"\\n\", sorted));\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        Action<int> DFS = null;\n        DFS = a =>\n        {\n            if (seen[a]) return;\n            seen[a] = true;\n            for (int i = E[a].Count - 1; i >= 0; i--)\n                DFS(E[a][i]);\n            sorted.Add(a);\n        };\n        for (int a = E.Length - 1; a >= 0; a--)\n            DFS(a);\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n\n        //15.2 トポロジカルソート\n        static void Main(string[] args)\n        {\n            //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n            var NE = Sarray();\n            var N = NE[0];\n            var E = NE[1];\n            var G = new List<long>[N];\n            var InCnt = new long[N];\n            for (var i = 0; i < N; ++i) G[i] = new List<long>();\n            for (var i = 0; i < E; ++i)\n            {\n                var std = Sarray();\n                G[std[0]].Add(std[1]);\n                ++InCnt[std[1]];\n            }\n            var q = new Queue<long>();\n            for (var i = 0; i < N; ++i)\n                if (0 == InCnt[i])\n                {\n                    q.Enqueue(i);\n                    --InCnt[i];\n                }\n            while(q.Any())\n            {\n                var v = q.Dequeue();\n                WriteLine(v);\n                foreach(var t in G[v])\n                {\n                    if (--InCnt[t] == 0)\n                        q.Enqueue(t);\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.Out.Flush();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        var stack = new Stack<int>();\n\n        for (int v = E.Length - 1; v >= 0; v--)\n            if (!seen[v])\n            {\n                stack.Push(v);\n                while (stack.Count > 0)\n                {\n                    int a = stack.Pop();\n                    if (a < 0) { sorted.Add(~a); continue; }\n                    if (seen[a]) continue;\n                    seen[a] = true;\n                    stack.Push(~a);\n                    for (int i = E[a].Count - 1; i >= 0; i--)\n                        stack.Push(E[a][i]);\n                }\n            }\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');//Splitで区切り文字を指定して複数個受け取る。\nstatic int v = int.Parse(input[0]);\nstatic int e = int.Parse(input[1]);\nstatic bool[] checkedVertex = new bool[v];//頂点が確認済みか？\nstatic List<int> answers = new List<int>();\nstatic List<int>[] nextList = new List<int>[v];\nstatic int[] inDegree = new int[v];//入次数\n\n\n\tstatic void Main()\n\t{\n    \n    for(int i = 0; i < v; i++) \n    {\n      nextList[i] = new List<int>();//リストの宣言が必要\n    }\n\n    for(int i = 0; i < e; i++)\n    {\n      string[] inputa = Console.ReadLine().Split(' ');\n      int b = int.Parse(inputa[0]);\n      int c = int.Parse(inputa[1]);\n      nextList[b].Add(c);//隣接リストの作成\n    }\n\n    TopologicalSort();\n\t}\n\n  static void TopologicalSort()//トポロジカルソート\n  {\n    for(int i = 0; i < v; i++) inDegree[i] = 0;//初期化\n    \n    for(int i = 0; i < v; i++)\n    {\n      for(int j = 0; j < nextList[i].Count(); j++)\n      {\n        inDegree[nextList[i][j]]++;//入次数の計算\n      }\n    }\n\n    for(int i = 0; i < v; i++)\n    {\n      if(inDegree[i] == 0 && !(checkedVertex[i])) BFS(i);\n    }\n\n    var answerText = new StringBuilder();\n    for(int i = 0; i < answers.Count(); i++)\n    {\n      answerText.AppendLine(answers[i].ToString());\n    }\n    Console.Write(answerText);\n  }\n\n  static void BFS(int startVertex)//幅優先探索\n  {\n    Queue<int> que = new Queue<int>();\n    que.Enqueue(startVertex);//追加\n    checkedVertex[startVertex] = true;\n    while(que.Count > 0)\n    {\n      int poppedMemo = que.Peek();//一番上を見る\n      que.Dequeue();//取り出し\n      answers.Add(poppedMemo);//追加\n      for(int i = 0; i < nextList[poppedMemo].Count(); i++)\n      {\n        int aimVertex = nextList[poppedMemo][i];\n        inDegree[aimVertex]--;\n        if(inDegree[aimVertex] == 0 && !(checkedVertex[aimVertex]))\n        {\n          checkedVertex[aimVertex] = true;\n          que.Enqueue(aimVertex);\n        }\n      }\n    }\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        Action<int> DFS = null;\n        DFS = a =>\n        {\n            if (seen[a]) return;\n            seen[a] = true;\n            for (int i = E[a].Count - 1; i >= 0; i--)\n                DFS(E[a][i]);\n            sorted.Add(a);\n        };\n        for (int a = E.Length - 1; a >= 0; a--)\n            DFS(a);\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Competitive\n{\n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            int[] values = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            int N = values[0];\n            int E = values[1];\n\n            var G = new Graph<int>();\n            for (int i = 0; i < N; i++) G.AddNode(i);\n            for (int i = 0; i < E; i++)\n            {\n                int[] _edges = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                G.AddEdge(_edges[0], _edges[1]);\n            }\n\n            var ret = G.TopologicalSort();\n            for (int i = 0; i < ret.Count; i++)\n            {\n                Console.WriteLine(ret[i]);\n            }\n\n        }\n    }\n\n    // 有向グラフ\n    internal class Graph<T>\n    {\n        private List<Node> nodes;\n        private List<Edge> edges;\n        private Dictionary<T, Node> dic;\n\n        private Node this[int index]\n        {\n            get { return nodes[index]; }\n        }\n\n        internal class Node\n        {\n            public int No;\n            public T Obj;\n            public List<Edge> Edges;\n\n            public Node(int no, T obj)\n            {\n                No = no;\n                Obj = obj;\n                Edges = new List<Edge>();\n            }\n        }\n\n        internal class Edge\n        {\n            public int From;\n            public int To;\n        }\n\n        public Graph()\n        {\n            nodes = new List<Node>();\n            edges = new List<Edge>();\n            dic = new Dictionary<T, Node>();\n        }\n\n        public List<T> Nodes()\n        {\n            return nodes.Select(n => n.Obj).ToList();\n        }\n\n        public List<T> Successors(T obj)\n        {\n            var node = dic[obj];\n            return node.Edges.Select(e => this[e.To].Obj).Distinct().ToList();\n        }\n\n        public void AddNode(T obj)\n        {\n            // TODO: 重複処理\n            if (dic.ContainsKey(obj))\n            {\n                throw new Exception(\"既にノードに存在します\");\n            }\n\n            int no = nodes.Count;\n            var node = new Node(no, obj);\n            dic.Add(obj, node);\n            nodes.Add(node);\n        }\n\n        public void AddEdge(T fm, T to)\n        {\n            if (!dic.ContainsKey(fm) || !dic.ContainsKey(to)) throw new Exception(\"ノードが存在しません\");\n            var fmIdx = dic[fm].No;\n            var toIdx = dic[to].No;\n            var edge = new Edge {From = fmIdx, To = toIdx};\n            edges.Add(edge);\n            this[fmIdx].Edges.Add(edge);\n        }\n\n        public List<List<T>> Condensation()\n        {\n            throw new NotImplementedException();\n        }\n\n        public List<T> TopologicalSort()\n        {\n            // DFSを行う\n            // TODO: 辞書式トポロジカルソートの方が安定するか？\n            // 閉路が存在した場合、nullを返す\n            // 閉路が存在しない場合、探索済のノードから順にセットしていく。それを反転したものを返り値とする。\n            // http://www.prefield.com/algorithm/graph/topological_sort.html\n\n            int n = nodes.Count;\n            var color = Util.EmptyList<int>(n);\n            var order = new List<int>();\n\n            for (int i = 0; i < n; i++)\n                if (color[i] == 0)\n                {\n                    bool visitSuccess = Visit(i, color, order);\n                    if (!visitSuccess) return null;\n                }\n\n            order.Reverse();\n            return order.Select(i => this[i].Obj).ToList();\n\n        }\n\n        bool Visit(int i, List<int> color, List<int> order)\n        {\n            color[i] = 1; // 探索中\n            var node = this[i];\n            foreach (var e in node.Edges)\n            {\n                if (color[e.To] == 2) continue; // 探索済\n                if (color[e.To] == 1) return false; // 探索中Nodeに到達してしまった\n                bool visitSuccess = Visit(e.To, color, order);\n                if (!visitSuccess) return false;\n            }\n\n            order.Add(i);\n            color[i] = 2; // 探索済\n            return true;\n        }\n\n      \n    }\n    \n    internal static class Util\n    {\n        public static List<T> EmptyList<T>(int count)\n        {\n            return Enumerable.Range(0, count).Select(i => default(T)).ToList();\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        var stack = new Stack<int>();\n\n        for (int v = E.Length - 1; v >= 0; v--)\n            if (!seen[v])\n            {\n                stack.Push(v);\n                while (stack.Count > 0)\n                {\n                    int a = stack.Pop();\n                    if (a < 0) { sorted.Add(~a); continue; }\n                    if (seen[a]) continue;\n                    seen[a] = true;\n                    stack.Push(~a);\n                    for (int i = E[a].Count - 1; i >= 0; i--)\n                        if (!seen[E[a][i]])\n                            stack.Push(E[a][i]);\n                }\n            }\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Node\n    {\n        internal List<int> target;\n        internal int inDegree;\n        internal bool isVisit;\n\n        public Node()\n        {\n            target = new List<int>();\n        }\n    }\n\n    class Program\n    {\n        static List<int> result;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int V = int.Parse(input[0]);\n            int E = int.Parse(input[1]);\n\n            Node[] nodeList = Enumerable.Range(0, V).Select(a => new Node()).ToArray();\n\n            int s, t;\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                s = int.Parse(input[0]);\n                t = int.Parse(input[1]);\n\n                nodeList[s].target.Add(t);\n                nodeList[t].inDegree++;\n            }\n\n            result = new List<int>();\n            TopologicalSort(nodeList);\n        }\n\n        static void TopologicalSort(Node[] NL)\n        {\n            for (int i = 0; i < NL.Length; i++)\n            {\n                if (NL[i].inDegree == 0 && !NL[i].isVisit)\n                {\n                    BFS(NL, i);\n                }\n            }\n\n            StringBuilder sb = new StringBuilder();\n            foreach (int node in result)\n            {\n                sb.AppendLine(node.ToString());\n            }\n            Console.Write(sb);\n        }\n\n        static void BFS(Node[] NL, int s)\n        {\n            Queue<int> que = new Queue<int>();\n            que.Enqueue(s);\n\n            NL[s].isVisit = true;\n\n            while (que.Count > 0)\n            {\n                int u = que.Dequeue();\n                result.Add(u);\n\n                for (int i = 0; i < NL[u].target.Count; i++)\n                {\n                    int v = NL[u].target[i];\n                    NL[v].inDegree--;\n\n                    if (NL[v].inDegree == 0 && !NL[v].isVisit)\n                    {\n                        NL[v].isVisit = true;\n                        que.Enqueue(v);\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public List<int> from { get; set; }\n    public List<int> to { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var e = int.Parse(line[1]);\n        var d = new Dictionary<int, P>();\n        for (int i = 0; i < n; i++) d[i] = new P { from = new List<int>(), to = new List<int>() };\n        for (int i = 0; i < e; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            var s = int.Parse(line[0]);\n            var t = int.Parse(line[1]);\n            d[s].to.Add(t);\n            d[t].from.Add(s);\n        }\n        tsort(d, n);\n    }\n    public static void tsort(Dictionary<int, P> d, int n)\n    {\n        var q = new Queue<int>();\n        for (int i = 0; i < n; i++) q.Enqueue(i);\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (d[w].from.Count == 0)\n            {\n                Console.WriteLine(w);\n                foreach (var x in d[w].to) d[x].from.Remove(w);\n            }\n            else q.Enqueue(w);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace GRL4_B\n{\n    class Program\n    {\n        const int MAX = 10000;\n        static int v, e;\n        static int[] indeg = new int[MAX];\n        static List<int>[] L = Enumerable.Range(0, MAX).Select(n => new List<int>()).ToArray();\n        static bool[] color = new bool[MAX];\n        static Queue<int> Q = new Queue<int>(); \n        static void Main(string[] args)\n        {\n            var t = scan;\n            v = t[0];\n            e = t[1];\n            for (int i = 0; i < e; i++)\n            {\n                var k = scan;\n                L[k[0]].Add(k[1]);\n                indeg[k[1]]++;\n            }\n\n            for (int i = 0; i < v; i++)\n            {\n                if (indeg[i] == 0 && !color[i]) bfs(i);\n            }\n        }\n        static void bfs(int s)\n        {\n            Q.Enqueue(s);\n            color[s] = true;\n            while (Q.Any())\n            {\n                Console.WriteLine(Q.Peek());\n                int u = Q.Dequeue();\n\n                foreach (var v in L[u])\n                {\n                    indeg[v]--;\n                    if(indeg[v]==0&&!color[v])\n                    {\n                        color[v] = true;\n                        Q.Enqueue(v);\n                    }\n                }\n            }\n        }\n        static int[] scan { get { return Array.ConvertAll(Console.ReadLine().Split(), int.Parse); } }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Math;\n \nclass Program\n{\n    static void Main()\n    {\n        var VE = ReadLine().Split().Select(int.Parse).ToArray();\n        var V = VE[0];\n        var E = VE[1];\n \n        var G = new List<int>[V];\n        for (int i = 0; i < G.Length; i++) G[i] = new List<int>();\n \n        for (int i = 0; i < E; i++)\n        {\n            var st = ReadLine().Split().Select(int.Parse).ToArray();\n            G[st[0]].Add(st[1]);\n        }\n \n        SetOut(new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        foreach (var i in TopologicalSort(G)) WriteLine(i);\n        Out.Flush();\n    }\n \n    static public int[] TopologicalSort(List<int>[] G)\n    {\n         var r = new int[G.Length];\n        var visited = new bool[G.Length];\n        var a = G.Length;\n\n\n        Action<int> DFS = null;\n        DFS = v =>\n          {\n              if (visited[v]) return;\n              visited[v] = true;\n              foreach (var u in G[v])\n              {\n                  DFS(u);\n              }\n              r[--a] = v;\n          };\n\n\n        for (int i = 0; i < G.Length; i++)\n        {\n            DFS(i);\n        }\n        return r;\n\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "\n\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Program {\n\n    static int MAX = 6;\n    const int wht = 6, gry = 1, blk = 2;\n    const int inf = int.MaxValue;\n\n    static List<int>[] g = null;\n    static List<int> srtLst = new List<int>();\n    static bool[] added = null;\n\n    static int[] stt = null;\n    static int[] indeg = null;\n\n\n    static void bfs(int s) {\n        Queue<int> q = new Queue<int>();\n        q.Enqueue(s);\n        added[s] = true;\n\n        while (q.Count > 0) {\n            int u = q.Dequeue();\n            srtLst.Add(u);\n\n            for (int i = 0; i < g[u].Count; i++) {\n                int v = g[u][i];\n                indeg[v]--;\n\n                if (indeg[v] == 0 && !added[v]) {\n                    added[v] = true;\n                    q.Enqueue(v);\n                }\n            }\n        }\n    }\n\n    static void tsort() {\n        indeg = indeg.Select(e => e = 0).ToArray();\n\n        for (int i = 0; i < MAX; i++) {\n            for (int j = 0; j < g[i].Count; j++) {\n                int v = g[i][j];\n                indeg[v]++;\n            }\n        }\n\n        for (int i = 0; i < MAX; i++) {\n            if (indeg[i] == 0 && !added[i]) bfs(i);\n        }\n\n\n    }\n\n    static void Main(string[] args) {\n\n\n        var inp = Console.ReadLine().Split(' ').Select(z => int.Parse(z)).ToArray();\n        int v, e; v = inp[0]; e = inp[1];\n\n        MAX = v;\n        indeg = new int[MAX];\n        stt = new int[MAX];\n        added = new bool[MAX];\n        g = new List<int>[MAX];\n\n\n        added = added.Select(i => false).ToArray();\n\n        g = g.Select(i => new List<int>()).ToArray();\n\n\n        for (int i = 0; i < e; i++) {\n            var c = Console.ReadLine().Split(' ').Select(z => int.Parse(z)).ToArray();\n\n            g[c[0]].Add(c[1]);\n        }\n\n\n        tsort();\n\n        foreach (var item in srtLst) {\n            Console.WriteLine(item);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Competitive\n{\n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            int[] values = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            int N = values[0];\n            int E = values[1];\n\n            var G = new Graph<int>();\n            for (int i = 0; i < N; i++) G.AddNode(i);\n            for (int i = 0; i < E; i++)\n            {\n                int[] _edges = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                G.AddEdge(_edges[0], _edges[1]);\n            }\n\n            var ret = G.TopologicalSort();\n            for (int i = 0; i < ret.Count; i++)\n            {\n                Console.WriteLine(ret[i]);\n            }\n\n        }\n    }\n\n    // 有向グラフ\n    internal class Graph<T>\n    {\n        private List<Node> nodes;\n        private List<Edge> edges;\n        private Dictionary<T, Node> dic;\n\n        private Node this[int index]\n        {\n            get { return nodes[index]; }\n        }\n\n        internal class Node\n        {\n            public int No;\n            public T Obj;\n            public List<Edge> Edges;\n\n            public Node(int no, T obj)\n            {\n                No = no;\n                Obj = obj;\n                Edges = new List<Edge>();\n            }\n        }\n\n        internal class Edge\n        {\n            public int From;\n            public int To;\n        }\n\n        public Graph()\n        {\n            nodes = new List<Node>();\n            edges = new List<Edge>();\n            dic = new Dictionary<T, Node>();\n        }\n\n        public List<T> Nodes()\n        {\n            return nodes.Select(n => n.Obj).ToList();\n        }\n\n        public List<T> Successors(T obj)\n        {\n            var node = dic[obj];\n            return node.Edges.Select(e => this[e.To].Obj).Distinct().ToList();\n        }\n\n        public void AddNode(T obj)\n        {\n            // TODO: 重複処理\n            if (dic.ContainsKey(obj))\n            {\n                throw new Exception(\"既にノードに存在します\");\n            }\n\n            int no = nodes.Count;\n            var node = new Node(no, obj);\n            dic.Add(obj, node);\n            nodes.Add(node);\n        }\n\n        public void AddEdge(T fm, T to)\n        {\n            if (!dic.ContainsKey(fm) || !dic.ContainsKey(to)) throw new Exception(\"ノードが存在しません\");\n            var fmIdx = dic[fm].No;\n            var toIdx = dic[to].No;\n            var edge = new Edge {From = fmIdx, To = toIdx};\n            edges.Add(edge);\n            this[fmIdx].Edges.Add(edge);\n        }\n\n        public List<List<T>> Condensation()\n        {\n            throw new NotImplementedException();\n        }\n\n        public List<T> TopologicalSort()\n        {\n            // DFSを行う\n            // TODO: 辞書式トポロジカルソートの方が安定するか？\n            // 閉路が存在した場合、nullを返す\n            // 閉路が存在しない場合、探索済のノードから順にセットしていく。それを反転したものを返り値とする。\n            // http://www.prefield.com/algorithm/graph/topological_sort.html\n\n            int n = nodes.Count;\n            var color = Util.EmptyList<int>(n);\n            var order = new List<int>();\n\n            for (int i = 0; i < n; i++)\n                if (color[i] == 0)\n                {\n                    bool visitSuccess = Visit(i);\n                    if (!visitSuccess) return null;\n                }\n\n            order.Reverse();\n            return order.Select(i => this[i].Obj).ToList();\n\n            bool Visit(int i)\n            {\n                color[i] = 1; // 探索中\n                var node = this[i];\n                foreach (var e in node.Edges)\n                {\n                    if (color[e.To] == 2) continue; // 探索済\n                    if (color[e.To] == 1) return false; // 探索中Nodeに到達してしまった\n                    bool visitSuccess = Visit(e.To);\n                    if (!visitSuccess) return false;\n                }\n\n                order.Add(i);\n                color[i] = 2; // 探索済\n                return true;\n            }\n\n        }\n\n      \n    }\n    \n    internal static class Util\n    {\n        public static List<T> EmptyList<T>(int count)\n        {\n            return Enumerable.Range(0, count).Select(i => default(T)).ToList();\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public List<int> from { get; set; }\n    public List<int> to { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var e = int.Parse(line[1]);\n        var d = new Dictionary<int, P>();\n        for (int i = 0; i < n; i++) d[i] = new P { from = new List<int>(), to = new List<int>() };\n        for (int i = 0; i < e; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            var s = int.Parse(line[0]);\n            var t = int.Parse(line[1]);\n            d[s].to.Add(t);\n            d[t].from.Add(s);\n        }\n        tsort(d, n);\n    }\n    public static void tsort(Dictionary<int, P> d, int n)\n    {\n        var ret = new List<int>();\n        var q = new Queue<int>();\n        for (int i = 0; i < n; i++) q.Enqueue(i);\n        while (q.Count() > 0)\n        {\n            var w = q.Dequeue();\n            if (d[w].from.Count == 0)\n            {\n                Console.WriteLine(w);\n                foreach (var x in d[w].to) d[x].from.Remove(w);\n            }\n            else q.Enqueue(w);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass B\n{\n\tstatic int[] Read() => Console.ReadLine().Split().Select(int.Parse).ToArray();\n\tstatic void Main()\n\t{\n\t\tvar h = Read();\n\t\tvar n = h[0];\n\t\tvar es = new int[h[1]].Select(_ => Read()).ToArray();\n\n\t\tvar map = Array.ConvertAll(new int[n], _ => new List<int[]>());\n\t\tvar indeg = new int[n];\n\t\tforeach (var e in es)\n\t\t{\n\t\t\tmap[e[0]].Add(e);\n\t\t\tindeg[e[1]]++;\n\t\t}\n\n\t\tvar svs = Enumerable.Range(0, n).Where(v => indeg[v] == 0).ToArray();\n\t\tvar seq = new List<int>();\n\t\tvar q = new Queue<int>();\n\n\t\tforeach (var sv in svs)\n\t\t{\n\t\t\tseq.Add(sv);\n\t\t\tq.Enqueue(sv);\n\n\t\t\twhile (q.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = q.Dequeue();\n\t\t\t\tforeach (var e in map[v])\n\t\t\t\t{\n\t\t\t\t\tif (--indeg[e[1]] > 0) continue;\n\t\t\t\t\tseq.Add(e[1]);\n\t\t\t\t\tq.Enqueue(e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(string.Join(\"\\n\", seq));\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var E = Enu.Range(0, N).Select(i => new List<int>()).ToArray();\n        for (int i = 0; i < M; i++)\n        {\n            int a = Reader.Int(), b = Reader.Int();\n            E[a].Add(b);\n        }\n        var sorted = TopologicalSort(E);\n        foreach (int a in sorted) Console.WriteLine(a);\n        Console.ReadLine();\n    }\n\n\n    int[] TopologicalSort(List<int>[] E)\n    {\n        var seen = new bool[E.Length];\n        var sorted = new List<int>();\n        var stack = new Stack<int>();\n\n        for (int v = E.Length - 1; v >= 0; v--)\n            if (!seen[v])\n            {\n                stack.Push(v);\n                while (stack.Count > 0)\n                {\n                    int a = stack.Pop();\n                    if (a < 0) { sorted.Add(~a); continue; }\n                    if (seen[a]) continue;\n                    seen[a] = true;\n                    stack.Push(~a);\n                    for (int i = E[a].Count - 1; i >= 0; i--)\n                        stack.Push(E[a][i]);\n                }\n            }\n\n        sorted.Reverse();\n        return sorted.ToArray();\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');//Splitで区切り文字を指定して複数個受け取る。\nstatic long v = long.Parse(input[0]);\nstatic long e = long.Parse(input[1]);\nstatic bool[] checkedVertex = new long[v];//頂点が確認済みか？\nstatic List<long[]>[] nextList = new List<long[]>[n];\nstatic long[] inDegree = new long[v];//入次数\nstatic List<long> answers = new List<long>;\n\n\tstatic void Main()\n\t{\n    \n    for(long i = 0; i < v; i++) \n    {\n      nextList[i] = new List<long[]>();//リストの宣言が必要\n    }\n\n    for(long i = 0; i < e; i++)\n    {\n      string[] inputa = Console.ReadLine().Split(' ');\n      long b = long.Parse(inputa[0]);\n      long c = long.Parse(inputa[1]);\n      nextList[b].Add(c);//隣接リストの作成\n    }\n\n    TopologicalSort();\n\t}\n\n  static void TopologicalSort()//トポロジカルソート\n  {\n    for(long i = 0; i < v; i++) inDegree[i] = 0;//初期化\n    \n    for(long i = 0; i < v; i++)\n    {\n      for(long j = 0; j < nextList[i].Count(); j++)\n      {\n        inDegree[nextList[i][j]]++;//入次数の計算\n      }\n    }\n\n    for(long i = 0; i < v; i++)\n    {\n      if(inDegree[i] == 0 && !(checkedVertex[i])) BFS(i);\n    }\n\n    var answerText = new StringBuilder();\n    for(long i = 0; i < answers.Length; i++)\n    {\n      answerText.AppendLine(answers[i].ToString());\n    }\n    Console.Write(answerText);\n  }\n\n  static void BFS(long startVertex)//幅優先探索\n  {\n    Queue<long> que = new Queue<long>();\n    que.Enqueue(startVertex);//追加\n    checkedVertex[startVertex] = true;\n    while(que.Count > 0)\n    {\n      poppedMemo = que.Peek();//一番上を見る\n      que.Dequeue();//取り出し\n      answers.Enqueue(poppedMemo);//追加\n      for(long i = 0; i < nextList[poppedMemo].Count(); i++)\n      {\n        long aimVertex = nextList[poppedMemo][i];\n        inDegree[aimVertex]--;\n        if(inDegree[aimVertex] == 0 && !(checkedVertex[aimVertex]))\n        {\n          checkedVertex[aimVertex] = true;\n          que.Enqueue(aimVertex);\n        }\n      }\n    }\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Competitive\n{\n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            int[] values = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            int N = values[0];\n            int E = values[1];\n\n            var G = new Graph<int>();\n            for (int i = 0; i < N; i++) G.AddNode(i);\n            for (int i = 0; i < E; i++)\n            {\n                int[] _edges = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                G.AddEdge(_edges[0], _edges[1]);\n            }\n\n            var ret = G.TopologicalSort();\n            for (int i = 0; i < ret.Count; i++)\n            {\n                Console.WriteLine(ret[i]);\n            }\n\n        }\n    }\n\n    // 有向グラフ\n    internal class Graph<T>\n    {\n        private List<Node> nodes;\n        private List<Edge> edges;\n        private Dictionary<T, Node> dic;\n\n        private Node this[int index]\n        {\n            get { return nodes[index]; }\n        }\n\n        internal class Node\n        {\n            public int No;\n            public T Obj;\n            public List<Edge> Edges;\n\n            public Node(int no, T obj)\n            {\n                No = no;\n                Obj = obj;\n                Edges = new List<Edge>();\n            }\n        }\n\n        internal class Edge\n        {\n            public int From;\n            public int To;\n        }\n\n        public Graph()\n        {\n            nodes = new List<Node>();\n            edges = new List<Edge>();\n            dic = new Dictionary<T, Node>();\n        }\n\n        public List<T> Nodes()\n        {\n            return nodes.Select(n => n.Obj).ToList();\n        }\n\n        public List<T> Successors(T obj)\n        {\n            var node = dic[obj];\n            return node.Edges.Select(e => this[e.To].Obj).Distinct().ToList();\n        }\n\n        public void AddNode(T obj)\n        {\n            // TODO: 重複処理\n            if (dic.ContainsKey(obj))\n            {\n                throw new Exception(\"既にノードに存在します\");\n            }\n\n            int no = nodes.Count;\n            var node = new Node(no, obj);\n            dic.Add(obj, node);\n            nodes.Add(node);\n        }\n\n        public void AddEdge(T fm, T to)\n        {\n            if (!dic.ContainsKey(fm) || !dic.ContainsKey(to)) throw new Exception(\"ノードが存在しません\");\n            var fmIdx = dic[fm].No;\n            var toIdx = dic[to].No;\n            var edge = new Edge {From = fmIdx, To = toIdx};\n            edges.Add(edge);\n            this[fmIdx].Edges.Add(edge);\n        }\n\n        public List<List<T>> Condensation()\n        {\n            throw new NotImplementedException();\n        }\n\n        public List<T> TopologicalSort()\n        {\n            // DFSを行う\n            // TODO: 辞書式トポロジカルソートの方が安定するか？\n            // 閉路が存在した場合、nullを返す\n            // 閉路が存在しない場合、探索済のノードから順にセットしていく。それを反転したものを返り値とする。\n            // http://www.prefield.com/algorithm/graph/topological_sort.html\n\n            int n = nodes.Count;\n            var color = Util.EmptyList<int>(n);\n            var order = new List<int>();\n\n            for (int i = 0; i < n; i++)\n                if (color[i] == 0)\n                {\n                    bool visitSuccess = Visit(i);\n                    if (!visitSuccess) return null;\n                }\n\n            order.Reverse();\n            return order.Select(i => this[i].Obj).ToList();\n\n            bool Visit(int i)\n            {\n                color[i] = 1; // 探索中\n                var node = this[i];\n                foreach (var e in node.Edges)\n                {\n                    if (color[e.To] == 2) continue; // 探索済\n                    if (color[e.To] == 1) return false; // 探索中Nodeに到達してしまった\n                    bool visitSuccess = Visit(e.To);\n                    if (!visitSuccess) return false;\n                }\n\n                order.Add(i);\n                color[i] = 2; // 探索済\n                return true;\n            }\n\n        }\n\n      \n    }\n    \n    internal static class Util\n    {\n        public static List<T> EmptyList<T>(int count)\n        {\n            return Enumerable.Range(0, count).Select(i => default(T)).ToList();\n        }\n    }\n\n}\n"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nvst = [false]*v\ng = v.times.map{[]}\nrg = v.times.map{[]}\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\ncnt = 0\nwhile vst.any?{ |e| !e }\n  rg.each_with_index do |arr, i|\n    if arr.empty? && !vst[i]\n      vst[i] = cnt\n      g[i].each{|t| rg[t].delete(i)}\n      break\n    end\n  end\n  cnt += 1\nend\nvst.map.with_index{|e, i| [e, i]}.sort.each{|a| p a[1]}"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nvst = [false]*v\ng = v.times.map{[]}\nrg = v.times.map{[]}\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\ncnt = 0\nwhile vst.any?{ |e| !e }\n  (0...v).each do |i|\n    if rg[i].empty? && !vst[i]\n      vst[i] = cnt\n      g[i].each{|t| rg[t].delete(i)}\n      break\n    end\n  end\n  cnt += 1\nend\nvst.map.with_index{|e, i| [e, i]}.sort.each{|a| p a[1]}"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nvst = [false]*v\ng = v.times.map{[]}\nrg = v.times.map{[]}\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\narr = rg.map.with_index{|a, i| i if a.empty? }.compact\ncnt = 0\nwhile vst.any?{ |e| !e }\n  i = arr.shift\n  vst[i] = cnt\n  g[i].each{|t| rg[t].delete(i); arr << t if rg[t].empty?}\n  cnt += 1\nend\nvst.map.with_index{|e, i| [e, i]}.sort.each{|a| p a[1]}"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\nrequire 'tsort'\ninclude Math\ndef max(a,b);              a > b ? a : b                              end\ndef min(a,b);              a < b ?  a : b                             end\ndef swap(a,b);             a, b = b, a                                end\ndef gif;                   gets.to_i                                  end\ndef gff;                   gets.to_f                                  end\ndef gsf;                   gets.chomp                                 end\ndef gi;                    gets.split.map(&:to_i)                     end\ndef gf;                    gets.split.map(&:to_f)                     end\ndef gs;                    gets.chomp.split.map(&:to_s)               end\ndef gc;                    gets.chomp.split('')                       end\ndef pr(num);               num.prime_division                         end\ndef digit(num);            num.to_s.length                            end\ndef array(s,ini=nil);      Array.new(s){ini}                          end\ndef darray(s1,s2,ini=nil); Array.new(s1){Array.new(s2){ini}}          end\ndef rep(num);              num.times{|i|yield(i)}                     end\ndef repl(st,en,n=1);       st.step(en,n){|i|yield(i)}                 end\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\nhash = Hash.new\nv,e = gi\nrep v do |i|\n\thash[i] = []\nend\nrep v do\n\ts,t = gi\n\n\thash[t] << s\nend \nputs hash.tsort"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\nrequire 'tsort'\ninclude Math\ndef max(a,b);              a > b ? a : b                              end\ndef min(a,b);              a < b ?  a : b                             end\ndef swap(a,b);             a, b = b, a                                end\ndef gif;                   gets.to_i                                  end\ndef gff;                   gets.to_f                                  end\ndef gsf;                   gets.chomp                                 end\ndef gi;                    gets.split.map(&:to_i)                     end\ndef gf;                    gets.split.map(&:to_f)                     end\ndef gs;                    gets.chomp.split.map(&:to_s)               end\ndef gc;                    gets.chomp.split('')                       end\ndef pr(num);               num.prime_division                         end\ndef digit(num);            num.to_s.length                            end\ndef array(s,ini=nil);      Array.new(s){ini}                          end\ndef darray(s1,s2,ini=nil); Array.new(s1){Array.new(s2){ini}}          end\ndef rep(num);              num.times{|i|yield(i)}                     end\ndef repl(st,en,n=1);       st.step(en,n){|i|yield(i)}                 end\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\nhash = Hash.new\nv,e = gi\nrep v do |i|\n\thash[i] = []\nend\nrep v do\n\ts,t = gi\n\n\thash[t] << s\nend \np hash\nputs hash.tsort"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\ng = v.times.map{[]}\nrg = v.times.map{[]}\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\narr = rg.map.with_index{|a, i| i if a.empty? }.compact\nuntil arr.empty?\n  s = arr.shift\n  p s\n  g[s].each{|t| rg[t].delete(s); arr << t if rg[t].empty?}\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\n\nn, m = gets.split.map &:to_i\n\ng = Hash[*(0..n-1).map{|i| [i, []]}.flatten(1)]\nclass << g\n    include TSort\n    alias :tsort_each_node :each_key\n    def tsort_each_child(i, &block)\n        self[i].each do |j|\n            block.call(j)\n        end\n    end\nend\n\nm.times do\n    i, j = gets.split.map &:to_i\n    g[i] << j\nend\n\nputs g.tsort.reverse"
  },
  {
    "language": "Ruby",
    "code": "module Color\n  WHITE = 0\n  GRAY = 1\n  BLACK = 2\nend\ndef topological_sort(n)\n  $color = Array.new(n, Color::WHITE)\n  n.times do |u|\n    if $indeg[u].zero? && $color[u] == Color::WHITE\n      bfs(u)\n    end\n  end\nend\n\ndef bfs(s)\n  q = []\n  q << s\n  $color[s] = Color::GRAY\n  while !q.empty?\n    u = q.shift\n\n    $out << u\n\n    for v in $g[u]\n      $indeg[v] -= 1\n      if $indeg[v].zero? && $color[v] == Color::WHITE\n        $color[v] = Color::GRAY\n        q.push(v)\n      end\n    end\n  end\nend\n\n\n\nv, e = gets.split.map(&:to_i)\n$g = Array.new(v) { [] }\n$indeg = Array.new(v, 0)\ne.times do\n  s, t = gets.split.map(&:to_i)\n  $g[s] << t\n  $indeg[t] += 1\nend\n$out = []\n\ntopological_sort(v)\n\nfor u in $out\n  puts u\nend\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\n\nV, E = gets.split.map(&:to_i)\ng = Hash.new\n\n(0...V).each do |i|\n  g[i] = []\nend\n\nE.times do\n  from, to = gets.split.map(&:to_i)\n  g[from] << to\nend\n\neach_node = -> (&b) { g.each_key(&b) }\neach_child = -> (n, &b) { g[n].each(&b) }\norder = TSort.tsort(each_node, each_child).reverse\n\nputs order\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n$works, $seiyaku = gets.split.map(&:to_i)\n\n$conditions = []\nfor i in 1..$works do\n\tbefore,after= gets.split.map(&:to_i)\n\tcondition = {before:before,after:after}\n\t$conditions.push(condition)\nend\n\n$node = []\n \ndef search(condition)\n\tif $node.size == $works then\n\t\treturn\n\telsif $node.include?(condition[:before]) then\n\t\tfor k in 1..$node.size do\n\t\t\tif $node[k-1] == condition[:before] then\n\t\t\t\t$node.insert(k, condition[:after])\n\t\t\tend\n\t\tend\n\telsif $node.include?(condition[:after]) then\n\t\tfor m in 1..$node.size do\n\t\t\tif $node[m-1] == condition[:after] then\n\t\t\t\t$node.insert(m, condition[:before])\n\t\t\tend\n\t\tend\n\telse\n\t\t$node.push(condition[:before])\n\t\t$node.push(condition[:after])\n\tend\n\treturn\nend\n\nfor j in 1..$works do\n\tsearch($conditions[j-1])\nend\n\nfor l in 1..$works do\n\tputs $node[l-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "def get_i() #空白区切の入力を数値(整数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_i)\nend\ndef get_f() #空白区切の入力を数値(実数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_f)\nend\ndef get() #空白区切の入力を文字列の配列で返す\n  return gets.chomp.split(\" \")\nend\ndef get_nsp() #入力されたものを一文字ずつに区切った文字列の配列で返す\n  return gets.chomp.split(\"\")\nend\ndef yn_judge(bool,y=\"Yes\",n=\"No\") #boolに真偽を投げることで、trueならy、falseならnの値を出力する\n  return bool ? y : n \nend\ndef array(size1,init=nil,size2=1) #size2に二次元配列時の最初の要素数、size1に次の配列の大きさ、initに初期値を投げることでその配列を返す\n  if size2==1\n    return Array.new(size1){init}\n  else\n    return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\nV,E=get_i\nind=array(V,0)\ng=array(V)\nE.times do|i|\n  s,t=get_i\n  g[s]=[] if g[s].nil?\n  g[s].push(t)\n  ind[t]+=1\nend\n\ndef tps(g,ind)\n  ans=[]\n  queue=[]\n  V.times do|i|\n    queue.push(i) if ind[i].zero?\n  end\n  until queue==[]\n      curr=queue.shift\n      ans.push(curr)\n      next if g[curr].nil?\n      g[curr].each do|v|\n          ind[v]-=1\n          queue.push(v) if ind[v].zero?\n      end\n  end\n  return ans\nend\nputs tps(g,ind).join(\"\\n\")\n"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\nrequire 'tsort'\ninclude Math\ndef max(a,b);              a > b ? a : b                              end\ndef min(a,b);              a < b ?  a : b                             end\ndef swap(a,b);             a, b = b, a                                end\ndef gif;                   gets.to_i                                  end\ndef gff;                   gets.to_f                                  end\ndef gsf;                   gets.chomp                                 end\ndef gi;                    gets.split.map(&:to_i)                     end\ndef gf;                    gets.split.map(&:to_f)                     end\ndef gs;                    gets.chomp.split.map(&:to_s)               end\ndef gc;                    gets.chomp.split('')                       end\ndef pr(num);               num.prime_division                         end\ndef digit(num);            num.to_s.length                            end\ndef array(s,ini=nil);      Array.new(s){ini}                          end\ndef darray(s1,s2,ini=nil); Array.new(s1){Array.new(s2){ini}}          end\ndef rep(num);              num.times{|i|yield(i)}                     end\ndef repl(st,en,n=1);       st.step(en,n){|i|yield(i)}                 end\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\nhash = Hash.new\nv,e = gi\nrep v do |i|\n\thash[i] = []\nend\nrep e do\n\ts,t = gi\n\n\thash[t] << s\nend \nputs hash.tsort"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :child, :parent\n  def initialize\n    @child = {}\n    @parent = {}\n  end\nend\n\nv, e = gets.split.map(&:to_i)\ng = Array.new(v){Node.new}\n\nedges = {}\ne.times{\n  s, t = gets.split.map(&:to_i)\n  g[s].child[t] = 1\n  g[t].parent[s] = 1\n  edges[[s,t]] = true\n}\n\nlist = []\nstart = []\nv.times{|i|\n  if g[i].parent.size == 0\n    start << i\n  end\n}\n\nwhile start.size > 0\n  n = start.shift\n  list << n\n  ed = g[n].child.clone\n  ed.each{|m, val|\n    g[n].child.delete(m)\n    g[m].parent.delete(n)\n    edges.delete([n,m])\n    start << m if g[m].parent.size == 0\n  }\nend\n\nputs list"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nret = []\nset = Array.new(v){ |i| i }\ng = Array.new(v){ Array.new }\nrg = Array.new(v){ Array.new }\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\nempset = []\nv.times{ |i| empset << i if rg[i].empty? }\nuntil set.empty?\n  n = empset.shift\n  set.delete(n)\n  ret << n\n  g[n].each do |m|\n    rg[m].delete(n)\n    if rg[m].empty?\n      set << m\n      empset << m\n    end\n  end\nend\nret.each{|v| p v}"
  },
  {
    "language": "Ruby",
    "code": "class TopologicalSort\n\n  class Node\n    attr_accessor :id, :indeg, :to, :color\n    def initialize(id)\n      @id = id\n      @indeg = 0\n      @to = []\n      @color = \"WHITE\"\n    end\n  end\n\n  def initialize\n    v, e = gets.split.map &:to_i\n    @nodes = Array.new(v).map.with_index { |n, i| Node.new(i) }\n    @result = []\n    @q = []\n    e.times do\n      s, t = gets.split.map &:to_i\n      @nodes[t].indeg += 1\n      @nodes[s].to << @nodes[t]\n    end\n  end\n\n  def bfs(s)\n    @q.push s\n    s.color = \"GRAY\"\n    while !@q.empty?\n      u = @q.shift\n      @result.push u.id\n      u.to.each do |v|\n        v.indeg -= 1\n        if v.indeg == 0 && v.color == \"WHITE\"\n          v.color = \"GRAY\"\n          @q.push v\n        end\n      end\n    end\n  end\n\n  def solve\n    @nodes.each do |n|\n      bfs(n) if n.indeg == 0 && n.color == \"WHITE\"\n    end\n  end\n\n  def dump\n    @result.each do |o|\n      puts o\n    end\n  end\nend\n\n# main\nt = TopologicalSort.new\nt.solve\nt.dump"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nret = []\nset = Array.new(v){ |i| i }\ng = Array.new(v){ Array.new }\nrg = Array.new(v){ Array.new }\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\nempset = rg.map.each_with_index{|a, i| i if a.empty? }.compact\nuntil set.empty?\n  n = empset.shift\n  set.delete(n)\n  ret << n\n  g[n].each do |m|\n    rg[m].delete(n)\n    if rg[m].empty?\n      set << m\n      empset << m\n    end\n  end\nend\nret.each{|v| p v}"
  },
  {
    "language": "Ruby",
    "code": "require 'tsort'\nclass Hash\n\tinclude TSort\n\talias tsort_each_node each_key\n\tdef tsort_each_child(node, &block)\n\t\tfetch(node).each(&block)\n\tend\nend\nV,E=gets.split.map(&:to_i)\nh={}\nE.times{\n\tk,v=gets.split.map(&:to_i)\n\th[k]||=[]\n\th[v]||=[]\n\th[v]<<k\n}\nputs [*0...V]-h.keys\nputs h.tsort"
  },
  {
    "language": "Ruby",
    "code": "# initialize\n@v, e = gets.split.map &:to_i\n@indeg = Array.new(@v, 0)\n@g = Array.new(@v).map { Array.new(@v, 0) }\n@color = Array.new(@v, \"WHITE\")\n@que = []\n@out = []\n\ne.times do\n  s, t = gets.split.map &:to_i\n  @indeg[t] += 1\n  @g[s][t] = 1\nend\n\n# bfs\ndef bfs(s)\n  @que.push s\n  @color[s] = \"GRAY\"\n  while !@que.empty?\n    u = @que.shift\n    @out.push u\n\n    (0..@v-1).each do |v|\n      if @g[u][v] == 1\n        @indeg[v] -= 1\n        if @indeg[v] == 0 && @color[v] == \"WHITE\"\n          @color[v] = \"GRAY\"\n          @que.push v\n        end\n      end\n    end\n  end\nend\n\n# main\n(0..@v-1).each do |u|\n  bfs(u) if @indeg[u] == 0 && @color[u] == \"WHITE\"\nend\n\n@out.each do |o|\n  puts o\nend"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nret = []\nset = Array.new(v){ |i| i }\ng = Array.new(v){ Array.new }\nrg = Array.new(v){ Array.new }\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\nuntil set.empty?\n  n = -1\n  set.each do |i|\n    if rg[i].empty?\n      n = i\n      break\n    end\n  end\n  set.delete(n)\n  ret << n\n  g[n].each do |m|\n    rg[m].delete(n)\n    if rg[m].empty?\n      set << m\n    end\n  end\nend\nret.each{|v| p v}"
  },
  {
    "language": "Ruby",
    "code": "v, e = gets.split.map(&:to_i)\nret = []\nset = Array.new(v){ |i| i }\ng = Array.new(v){ Array.new }\nrg = Array.new(v){ Array.new }\ne.times do\n  s,t = gets.split.map(&:to_i)\n  g[s] << t\n  rg[t] << s\nend\nempset = rg.map.each_with_index{|a, i| i if a.empty? }.compact\nuntil set.empty?\n  n = empset.shift\n  set.delete(n)\n  ret << n\n  g[n].each do |m|\n    rg[m].delete(n)\n    empset << m if rg[m].empty?\n  end\nend\nret.each{|v| p v}"
  },
  {
    "language": "Go",
    "code": "// Package main provides\n//\n// File:  topologicalsort.go\n// Author: ymiyamoto\n//\n// Created on Tue Jan 29 03:12:10 2019\n//\npackage main\n\nimport \"fmt\"\n\ntype graph [][]int\n\nfunc (g graph) topologicalSortBFS(n int, indeg []int, visited []bool) (sorted []int) {\n\tq := []int{n}\n\tfor len(q) > 0 {\n\t\tm := q[0]\n\t\tsorted = append(sorted, m)\n\t\tvisited[m] = true\n\n\t\tq = q[1:]\n\t\tfor i := range g[m] {\n\t\t\tto := g[m][i]\n\t\t\tindeg[to]--\n\t\t\tif indeg[to] == 0 && !visited[to] {\n\t\t\t\tq = append(q, to)\n\t\t\t}\n\t\t}\n\t}\n\treturn sorted\n}\n\nfunc (g graph) topologicalSort() (sorted []int) {\n\tindeg := make([]int, len(g))\n\tfor i := range g {\n\t\tfor j := range g[i] {\n\t\t\tin := g[i][j]\n\t\t\tindeg[in]++\n\t\t}\n\t}\n\n\tvisited := make([]bool, len(g))\n\tfor i := range indeg {\n\t\tif indeg[i] == 0 && !visited[i] {\n\t\t\tt := g.topologicalSortBFS(i, indeg, visited)\n\t\t\tsorted = append(sorted, t...)\n\t\t}\n\t}\n\n\treturn sorted\n}\n\nfunc main() {\n\tvar V, E int\n\tfmt.Scan(&V, &E)\n\n\tg := make(graph, V)\n\tfor i := 0; i < E; i++ {\n\t\tvar s, t int\n\t\tfmt.Scan(&s, &t)\n\t\tg[s] = append(g[s], t)\n\t}\n\n\tsorted := g.topologicalSort()\n\tfor _, s := range sorted {\n\t\tfmt.Println(s)\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+11))\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n/*********** DP sub-functions ***********/\n\n// ChMin accepts a pointer of integer and a target value.\n// If target value is SMALLER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMin(updatedValue *int, target int) bool {\n\tif *updatedValue > target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NthBit returns nth bit value of an argument.\n// n starts from 0.\nfunc NthBit(num, nth int) int {\n\treturn num >> uint(nth) & 1\n}\n\n// OnBit returns the integer that has nth ON bit.\n// If an argument has nth ON bit, OnBit returns the argument.\nfunc OnBit(num, nth int) int {\n\treturn num | (1 << uint(nth))\n}\n\n// OffBit returns the integer that has nth OFF bit.\n// If an argument has nth OFF bit, OffBit returns the argument.\nfunc OffBit(num, nth int) int {\n\treturn num & ^(1 << uint(nth))\n}\n\n// PopCount returns the number of ON bit of an argument.\nfunc PopCount(num int) int {\n\tres := 0\n\n\tfor i := 0; i < 70; i++ {\n\t\tif ((num >> uint(i)) & 1) == 1 {\n\t\t\tres++\n\t\t}\n\t}\n\n\treturn res\n}\n\n/*********** Arithmetic ***********/\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Min returns the min integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Min(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m > integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// DigitSum returns digit sum of a decimal number.\n// DigitSum only accept a positive integer.\nfunc DigitSum(n int) int {\n\tif n < 0 {\n\t\treturn -1\n\t}\n\n\tres := 0\n\n\tfor n > 0 {\n\t\tres += n % 10\n\t\tn /= 10\n\t}\n\n\treturn res\n}\n\n// DigitNumOfDecimal returns digits number of n.\n// n is non negative number.\nfunc DigitNumOfDecimal(n int) int {\n\tres := 0\n\n\tfor n > 0 {\n\t\tn /= 10\n\t\tres++\n\t}\n\n\treturn res\n}\n\n// Sum returns multiple integers sum.\nfunc Sum(integers ...int) int {\n\ts := 0\n\n\tfor _, i := range integers {\n\t\ts += i\n\t}\n\n\treturn s\n}\n\n// Kiriage returns Ceil(a/b)\n// a >= 0, b > 0\nfunc Kiriage(a, b int) int {\n\treturn (a + (b - 1)) / b\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n// AbsInt is integer version of math.Abs\nfunc AbsInt(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// Gcd returns the Greatest Common Divisor of two natural numbers.\n// Gcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Gcd uses the Euclidean Algorithm.\nfunc Gcd(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\tif a < b {\n\t\ta, b = b, a\n\t}\n\n\t// Euclidean Algorithm\n\tfor b > 0 {\n\t\tdiv := a % b\n\t\ta, b = b, div\n\t}\n\n\treturn a\n}\n\n// Lcm returns the Least Common Multiple of two natural numbers.\n// Lcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Lcd uses the Euclidean Algorithm indirectly.\nfunc Lcm(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\n\t// a = a'*gcd, b = b'*gcd, a*b = a'*b'*gcd^2\n\t// a' and b' are relatively prime numbers\n\t// gcd consists of prime numbers, that are included in a and b\n\tgcd := Gcd(a, b)\n\n\t// not (a * b / gcd), because of reducing a probability of overflow\n\treturn (a / gcd) * b\n}\n\n// Strtoi is a wrapper of `strconv.Atoi()`.\n// If `strconv.Atoi()` returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst MOD = 1000000000 + 7\nconst ALPHABET_NUM = 26\nconst INF_INT64 = math.MaxInt64\nconst INF_BIT60 = 1 << 60\n\nconst MAX_EDGE_NUM = 100000 + 5\nconst MAX_NODE_NUM = 10000 + 5\n\nvar v, e int\nvar edges [MAX_NODE_NUM][]int\n\nfunc main() {\n\tv, e = ReadInt2()\n\tfor i := 0; i < e; i++ {\n\t\ts, t := ReadInt2()\n\t\tedges[s] = append(edges[s], t)\n\t}\n\n\tok, ans := tsort(v, edges[:])\n\n\tif ok {\n\t\tfor _, nid := range ans {\n\t\t\tfmt.Println(nid)\n\t\t}\n\t}\n}\n\n// O(|E| + |V|)\n// ノードIDは0-based\n// ok, ans := tsort(v, edges[:])\n// https://onlinejudge.u-aizu.ac.jp/problems/GRL_4_B\nfunc tsort(nn int, edges [][]int) (bool, []int) {\n\tres := []int{}\n\n\tdegin := make([]int, nn)\n\tfor s := 0; s < nn; s++ {\n\t\tfor _, t := range edges[s] {\n\t\t\tdegin[t]++\n\t\t}\n\t}\n\n\tst := []int{}\n\tfor nid := 0; nid < nn; nid++ {\n\t\tif degin[nid] == 0 {\n\t\t\tst = append(st, nid)\n\t\t}\n\t}\n\n\tfor len(st) > 0 {\n\t\tcid := st[len(st)-1]\n\t\tres = append(res, cid)\n\t\tst = st[:len(st)-1]\n\n\t\tfor _, nid := range edges[cid] {\n\t\t\tdegin[nid]--\n\t\t\tif degin[nid] == 0 {\n\t\t\t\tst = append(st, nid)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(res) != nn {\n\t\treturn false, nil\n\t}\n\n\treturn true, res\n}\n\n// MODはとったか？\n// 遷移だけじゃなくて最後の最後でちゃんと取れよ？\n\n/*******************************************************************/\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t\tif len(os.Args) > 2 {\n\t\t\twfp, _ = os.Create(os.Args[2])\n\t\t}\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\n\tv := getNextInt(scanner)\n\te := getNextInt(scanner)\n\n\tee := make([][]int, v)\n\tseg := Segment{}\n\tseg.init(v)\n\n\tfor i := 0; i < v; i++ {\n\t\tee[i] = make([]int, 0)\n\t}\n\n\tfor i := 0; i < e; i++ {\n\t\ts := getNextInt(scanner)\n\t\tt := getNextInt(scanner)\n\t\tee[s] = append(ee[s], t)\n\t\tseg.minimize(t, seg.bucket[0][t]+1)\n\t}\n\n\tfor i := 0; i < v; i++ {\n\t\tt := seg.top()\n\t\tfmt.Fprintln(writer, t)\n\t\tfor j := 0; j < len(ee[t]); j++ {\n\t\t\tseg.minimize(ee[t][j], seg.bucket[0][ee[t][j]]-1)\n\t\t}\n\t\tseg.minimize(t, math.MaxInt32)\n\t}\n\n\twriter.Flush()\n}\n\n// Segment ...\ntype Segment struct {\n\tn, h, i, chunk, inf int\n\tunit                []int\n\tbucket              [][]int\n}\n\nfunc (seg *Segment) init(n int) {\n\tseg.n = n\n\tseg.unit = make([]int, 1)\n\tseg.unit[0] = 1\n\tseg.bucket = make([][]int, 1)\n\tseg.bucket[0] = make([]int, n)\n\n\tchunk := 8\n\tfor i := 0; n > 1; i++ {\n\t\tn = (n-1)/chunk + 1\n\t\tseg.bucket = append(seg.bucket, make([]int, n))\n\t\tseg.unit = append(seg.unit, seg.unit[i]*chunk)\n\t}\n\tseg.h = len(seg.unit)\n\tseg.chunk = chunk\n\tseg.inf = math.MaxInt32\n}\n\nfunc (seg *Segment) minimize(index, value int) {\n\tseg.bucket[0][index] = value\n\tfor seg.i = 0; seg.i < seg.h-1; seg.i++ {\n\t\ts := index - index%seg.chunk\n\t\tt := s + seg.chunk\n\t\tif t > len(seg.bucket[seg.i]) {\n\t\t\tt = len(seg.bucket[seg.i])\n\t\t}\n\t\tparent := index / seg.chunk\n\t\tmin := seg.inf\n\t\tfor i := s; i < t; i++ {\n\t\t\tif min > seg.bucket[seg.i][i] {\n\t\t\t\tmin = seg.bucket[seg.i][i]\n\t\t\t}\n\t\t}\n\t\tseg.bucket[seg.i+1][parent] = min\n\t\tindex /= seg.chunk\n\t}\n}\n\nfunc (seg *Segment) top() int {\n\tindex := 0\n\tfor seg.i = seg.h - 2; seg.i >= 0; seg.i-- {\n\t\ts := index * seg.chunk\n\t\tt := s + seg.chunk\n\t\tif t > len(seg.bucket[seg.i]) {\n\t\t\tt = len(seg.bucket[seg.i])\n\t\t}\n\t\tfor i := s; i < t; i++ {\n\t\t\tif seg.bucket[seg.i][i] == seg.bucket[seg.i+1][index] {\n\t\t\t\tindex = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn index\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tMAX   = 100000\n\tINFTY = 1 << 29\n)\n\nvar (\n\tout   []int\n\tV     []bool\n\tindeg [MAX]int\n)\n\ntype Graph [][]int\n\nfunc (g *Graph) bfs(s int) {\n\tvar q []int\n\tq = append(q, s)\n\tV[s] = true\n\tfor len(q) != 0 {\n\t\tu := q[0]\n\t\tq = q[1:]\n\t\tout = append(out, u)\n\t\tfor i := 0; i < len((*g)[u]); i++ {\n\t\t\tv := (*g)[u][i]\n\t\t\tindeg[v]--\n\t\t\tif indeg[v] == 0 && !V[v] {\n\t\t\t\tV[v] = true\n\t\t\t\tq = append(q, v)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (g *Graph) tsort(n int) string {\n\tfor i := 0; i < n; i++ {\n\t\tindeg[i] = 0\n\t}\n\n\tfor u := 0; u < n; u++ {\n\t\tfor i := 0; i < len((*g)[u]); i++ {\n\t\t\tv := (*g)[u][i]\n\t\t\tindeg[v]++\n\t\t}\n\t}\n\n\tfor u := 0; u < n; u++ {\n\t\tif indeg[u] == 0 && !V[u] {\n\t\t\tg.bfs(u)\n\t\t}\n\t}\n\n\tvar buf bytes.Buffer\n\tfor _, o := range out {\n\t\tbuf.WriteString(fmt.Sprintln(o))\n\t}\n\n\treturn strings.TrimRight(buf.String(), \"\\n\")\n}\n\nfunc answer(reader io.Reader) string {\n\tsc := bufio.NewScanner(reader)\n\tsc.Split(bufio.ScanWords)\n\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\tsc.Scan()\n\tm, _ := strconv.Atoi(sc.Text())\n\n\tV = make([]bool, n)\n\tg := make(Graph, n)\n\n\tfor i := 0; i < m; i++ {\n\t\tsc.Scan()\n\t\ts, _ := strconv.Atoi(sc.Text())\n\t\tsc.Scan()\n\t\tt, _ := strconv.Atoi(sc.Text())\n\t\tg[s] = append(g[s], t)\n\t}\n\n\treturn g.tsort(n)\n}\n\nfunc main() {\n\tfmt.Println(answer(os.Stdin))\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.numeric;\nimport std.range, std.array, std.math, std.typecons, std.container, core.bitop;\n\nvoid main() {\n    int n, m;\n\n    scan(n, m);\n\n    auto visited = new bool[](n);\n    auto adj = new int[][](n, 0);\n    auto rank = new int[](n);\n    auto indeg = new int[](n);\n\n    foreach (i ; 0 .. m) {\n        int si, ti;\n        scan(si, ti);\n        adj[si] ~= ti;\n        indeg[ti]++;\n    }\n\n    int num = 0;\n\n    void bfs(int s) {\n        auto q = Queue!(int)(n + 1);\n\n        q.push(s);\n        rank[num++] = s;\n        visited[s] = true;\n\n        while (!q.empty) {\n            int v = q.front;\n            q.pop;\n\n            foreach (u ; adj[v]) {\n                indeg[u]--;\n\n                if (indeg[u] == 0 && !visited[u]) {\n                    q.push(u);\n                    rank[num++] = u;\n                    visited[u] = true;\n                }\n            }\n        }\n    }\n\n    foreach (i ; 0 .. n) {\n        if (!visited[i] && indeg[i] == 0) bfs(i);\n    }\n\n    writefln(\"%(%s\\n%)\", rank);\n}\n\nstruct Queue(T) {\n    private {\n        int N, head, tail;\n        T[] data;\n    }\n\n    this(int n) {\n        N = n + 1;\n        data = new T[](N);\n    }\n\n    bool empty() {\n        return head == tail;\n    }\n\n    bool full() {\n        return (tail + 1) % N == head;\n    }\n\n    T front() {\n        return data[head];\n    }\n\n    void push(T x) {\n        assert(!full);\n        data[tail++] = x;\n        tail %= N;\n    }\n\n    void pop() {\n        assert(!empty);\n        head = (head + 1) % N;\n    }\n\n    void clear() {\n        head = tail = 0;\n    }\n}\n\n\n\nvoid scan(T...)(ref T args) {\n    string[] line = readln.split;\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.numeric;\nimport std.range, std.array, std.math, std.typecons, std.container, core.bitop;\n\nvoid main() {\n    int n, m;\n\n    scan(n, m);\n\n    auto visited = new bool[](n);\n    auto adj = new int[][](n, 0);\n    auto rank = new int[](n);\n\n    foreach (i ; 0 .. m) {\n        int si, ti;\n        scan(si, ti);\n        adj[si] ~= ti;\n    }\n\n    int num = n - 1;\n\n    void dfs(int v) {\n        visited[v] = true;\n\n        foreach (u ; adj[v]) {\n            if (!visited[u]) dfs(u);\n        }\n\n        rank[num--] = v;\n    }\n\n    foreach (i ; 0 .. n) {\n        if (!visited[i]) dfs(i);\n    }\n\n    writefln(\"%(%s\\n%)\", rank);\n}\n\n\nvoid scan(T...)(ref T args) {\n    string[] line = readln.split;\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom sys import stdin\nfrom collections import deque\n\nUNVISITED, VISITED_IN_QUEUE, POPPED_OUT = 0, 1, 2\n\n\ndef generate_adj_matrix(_v_info, _input_adj_table, _in_deg_list):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        _input_adj_table[v_from].append(v_to)\n        _in_deg_list[v_to] += 1\n    return _input_adj_table, _in_deg_list\n\n\ndef topological_sort():\n    for v in range(vertices):\n        if not in_deg_list[v] and status[v] is UNVISITED:\n            bfs(v)\n\n    return ans\n\n\ndef bfs(v):\n    v_queue.append(v)\n    status[v] = VISITED_IN_QUEUE\n\n    while v_queue:\n        current = v_queue.popleft()\n\n        ans.append(current)\n\n        for v_adj in adj_table[current]:\n            in_deg_list[v_adj] -= 1\n            if not in_deg_list[v_adj] and status[v_adj] is UNVISITED:\n                status[v_adj] = VISITED_IN_QUEUE\n                v_queue.appendleft(v_adj)\n\n        status[current] = POPPED_OUT\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    status = [UNVISITED] * vertices\n    v_queue = deque()\n    init_adj_table = tuple([] for _ in range(vertices))\n    init_in_deg_list = [0] * vertices\n\n    ans = []\n    adj_table, in_deg_list = generate_adj_matrix(v_info, init_adj_table, init_in_deg_list)\n    print(*topological_sort())"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef topological_sort(n,G):\n    seq_sorted = []\n    st = deque()\n\n    ct_to_edges = [0]*n\n    for edges in G:\n        for node in edges:\n            ct_to_edges[node]+=1\n    \n    for i,ct in enumerate(ct_to_edges):\n        if ct==0:\n            st.append(i)\n    \n    while st:\n        node = st.pop()\n        seq_sorted.append(node)\n        for node in G[node]:\n            ct_to_edges[node]-=1\n            if ct_to_edges[node]==0:\n                st.append(node)\n    \n    return seq_sorted\ndef main():\n    n,m = map(int,input().split())\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        s,t = map(int,input().split())\n        G[s].append(t)\n\n    topo_seq =  topological_sort(n,G)\n    for i in topo_seq:\n        print(i)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nn, e = map(int, stdin.readline().split())\nG = [[] for _ in [0] * n]\nindeg = [0] * n\nout = []\nV = [False] * n\ndef bfs(s):\n    dq = deque([s])\n    V[s] = True\n    while dq:\n        u = dq.popleft()\n        out.append(u)\n        for i in range(len(G[u])):\n            v = G[u][i]\n            indeg[v] -= 1\n            if indeg[v] == 0 and not V[v]:\n                V[v] = True\n                dq.append(v)\ndef tsort():\n    for u in range(n):\n        for i in range(len(G[u])):\n            indeg[G[u][i]] += 1\n    for u in range(n):\n        if indeg[u] == 0 and not V[u]:\n            bfs(u)\n    print(*out, sep='\\n')\nfor _ in [0] * e:\n    s, t = map(int, stdin.readline().split())\n    G[s].append(t)\ntsort()"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n# 1:shortest path\n# 1_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n                print(dist, q)\n    return dist\n\nv,e,r = map(int, input().split(\" \"))\nadj = [[] for i in range(v)]\nfor i in range(e):\n    s,t,d = map(int, input().split(\" \"))\n    adj[s].append([t, d])\nlis = dijkstra(v, r)\nprint(lis)\nfor i in lis:\n    print(str(i).upper())\n\"\"\"\n\n# 1_B\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for j, k, l in adj:\n                if dist[k] > dist[j] + l:\n                    dist[k] = dist[j] + l\n                    update = True\n                    if i == num-1:\n                        return False\n        if not update:\n            break\n    return dist\n\nv,e,r = map(int, input().split(\" \"))\nadj = []\nfor i in range(e):\n    s,t,d = map(int, input().split(\" \"))\n    adj.append([s, t, d])\nlis = bellman_ford(v, r)\nif not lis:\n    print(\"NEGATIVE CYCLE\")\nelse:\n    for i in lis:\n        print(str(i).upper())\n\"\"\"\n\n# 1_C\n\"\"\"\ndef warshallfloyd(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                d[j][k] = min(d[j][k], d[j][i]+d[i][k])\nv,e = map(int, input().split())\nd = [[float(\"inf\") for j in range(v)] for i in range(v)]\nfor i in range(v):\n    d[i][i] = 0\nfor i in range(e):\n    s, t, c = map(int, input().split())\n    d[s][t] = c\nwarshallfloyd(v)\nfor i in range(v):\n    if d[i][i] < 0:\n        print(\"NEGATIVE CYCLE\")\n        quit()\nfor i in d:\n    for j in range(v):\n        if j < v-1:\n            print(str(i[j]).upper(), end = \" \")\n        else:\n            print(str(i[j]).upper())\n\"\"\"\n\n# 2:spanning tree\n# 2_A\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\nv,e = LI()\nc = LIR(e)\nc.sort(key = lambda x:x[2])\npar = [i for i in range(v)]\nrank = [0 for i in range(v)]\nk = 0\nans = 0\nfor a,b,w in c:\n    if not same(a,b):\n        k += 1\n        unite(a,b)\n        ans += w\n    if k == v-1:\n        break\nprint(ans)\n\"\"\"\n\n#2_B\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank(x) < rank(y):\n        par[x] = y\n    else:\n        par[y] = x\n        if rank(x) == rank(y):\n            rank[x] += 1\n\"\"\"\n\n#3:connected components\n#3_A\n\n#3_B\n\n#3_C\n\n\n#4:path/cycle\n#4_A\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for j, k, l in adj:\n            if dist[k] > dist[j] + l:\n                dist[k] = dist[j] + l\n                update = True\n                if i == num-1:\n                    return False\n        if not update:\n            break\n    return True\n\nv, e = map(int, input().split(\" \"))\nadj = []\nfor i in range(e):\n    s,t = map(int, input().split(\" \"))\n    adj.append([s, t, -1])\nfor i in range(v):\n    if not bellman_ford(v,i):\n        print(1)\n        quit()\nprint(0)\n\"\"\"\n\n#4_B\ndef visit(s):\n    if f[s]:\n        f[s] = 0\n        for t in v[s]:\n            visit(t)\n        l.append(s)\nn,e = LI()\nv = [[] for i in range(n)]\nfor i in range(e):\n    s,t = LI()\n    v[s].append(t)\nl = []\nf = [1 for i in range(n)]\nfor i in range(n):\n    visit(i)\nl = l[::-1]\nfor i in l:\n    print(i)\n\n#5:tree\n#5_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = II()\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s,t,w = LI()\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nd = dijkstra(n,0)\ni = d.index(max(d))\nd2 = dijkstra(n,i)\nprint(max(d2))\n\"\"\"\n\n#5_B\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s, t, w = map(int, input().split(\" \"))\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nfor i in range(n):\n    s = dijkstra(n,i)\n    print(max(s))\n\"\"\"\n#5_C\n\n#5_D\n\n#5_E\n\n\n#6\n#6_A_maximum_flow\n\"\"\"\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in range(n):\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return [None,0]\n    path = [None for i in range(bfs_map[g]+1)]\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in range(n+1):\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return [path,m]\n\ndef ford_fulkerson(s,g,c,n):\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return sum(c[g])\n\nn,e = LI()\nc = [[0 for i in range(n)] for j in range(n)]\nfor i in range(e):\n    a,b,w = LI()\n    if a != n-1:\n        c[a][b] = w\nprint(ford_fulkerson(0,n-1,c,n))\n\"\"\"\n#6_B\n\n\n#7\n#7_A\n\"\"\"\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in range(n):\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return [None,0]\n    path = [None for i in range(bfs_map[g]+1)]\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in range(n+1):\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return [path,m]\n\ndef ford_fulkerson(s,g,c,n):\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return sum(c[g])\n\nx,y,e = LI()\nc = [[0 for i in range(x+y+2)] for j in range(x+y+2)]\nfor i in range(x):\n    c[0][i+1] = 1\nfor i in range(y):\n    c[x+i+1][x+y+1] = 1\nfor i in range(e):\n    a,b = LI()\n    c[a+1][x+b+1] = 1\nprint(ford_fulkerson(0,x+y+1,c,x+y+2))\n\"\"\"\n\n"
  },
  {
    "language": "Python",
    "code": "#topologivcal sort\n\nfrom collections import deque\n\nn, k = map(int, input().split())\n\na = [[] for i in range(n)]\nin_num = [0]*n\nfor _ in range(k):\n    p, q = map(int, input().split())\n    a[p] += [q]\n    in_num[q] += 1\n# print(a)\n# print(in_num)\n# a = [[1],[2],[],[1,4],[5],[2]]\n# n = len(a)\n# in_num = [0, 2, 2, 0, 1, 1]\ncolor = [0]*n\nresult = deque()\naa = deque()\n\ndef topologicalSort_w(s):\n    aa.append(s)\n    color[s] = 1\n    while aa:\n#         print(aa)\n#         print(in_num)\n        u = aa.popleft()\n        result.append(u)\n        for v in a[u]:\n            in_num[v] -= 1\n            if in_num[v] == 0 and color[v] == 0:\n                color[v] = 1\n                aa.append(v)\n        \n\nfor i in range(n):\n    if in_num[i] == 0 and color[i] == 0:\n        topologicalSort_w(i)\n        \n\n                \nfor i in range(len(result)):\n    print(result.popleft())\n    \n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ndef topological_sort(V, E):\n    '''\n    Kahn's Algorithm (O(|V| + |E|) time)\n    Input:\n    V = [0, 1, ..., N-1]: a list of vertices of the digraph\n    E: the adjacency list of the digraph (dict)\n    Output:\n    If the input digraph is acyclic, then return a topological sorting of the digraph.\n    Else, return None.\n    '''\n    indeg = {v: 0 for v in V}\n    for ends in E.values():\n        for v in ends:\n            indeg[v] += 1\n    \n    q = deque([v for v in V if indeg[v] == 0])\n    top_sorted = []\n    while q:\n        v = q.popleft()\n        top_sorted.append(v)\n        \n        for u in E[v]:\n            indeg[u] -= 1\n            if indeg[u] == 0:\n                q.append(u)\n    if len(top_sorted) == len(V): # The input digraph is acyclic.\n        return top_sorted\n    else: # There is a directed cycle in the digraph.\n        return None\n\nN, M = map(int, input().split())\nE = defaultdict(list)\nfor _ in range(M):\n    s, t = map(int, input().split())\n    E[s].append(t)\nprint(*topological_sort(V, E), sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\"\"\"\nPerforms topological sorting of the given DAG using Kahn's algorithm.\n\nVerification: []()\n\"\"\"\n\nimport heapq\n\n\nclass TopologicalSortError(Exception):\n    \"\"\"This exception is raised when something gets wrong while performing `topological_sort`.\n    \"\"\"    \n    pass\n\n\ndef topological_sort(num_vs, adj_vs):\n    \"\"\"Performs topological sorting of the given DAG.\n\n    This function computes the lexicographically least\n    topological order of the given DAG.\n\n    Parameters:\n\n    - `num_vs`: The number of vertices of the DAG.\n    - `adj_vs` The adjacency list of the DAG.\n\n    Returns: the lexicographically least topological order as a list.\n    \n    Raises `TopologicalSortError` if the given graph is not a DAG.\n    \"\"\"\n    \n    in_deg = [0 for _ in range(num_vs)]\n    for dests in adj_vs:\n        for dest in dests:\n            in_deg[dest] += 1\n    sorted_vs = []\n    pq = []\n    for s in range(num_vs):\n        if in_deg[s] == 0:\n            heapq.heappush(pq, s)\n    while pq:\n        u = heapq.heappop(pq)\n        sorted_vs.append(u)\n        for v in adj_vs[u]:\n            in_deg[v] -= 1\n            if in_deg[v] == 0:\n                heapq.heappush(pq, v)\n    if all(x == 0 for x in in_deg):\n        return sorted_vs\n    else:\n        raise TopologicalSortError(\"The graph has a cycle\")\n\n\ndef main():\n    v, e = map(int, input().split())\n    adj_vs = [set() for _ in range(v)]\n    for _ in range(e):\n        s, t = map(int, input().split())\n        adj_vs[s].add(t)\n    for u in topological_sort(v, adj_vs):\n        print(u)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nV, E = map(int, raw_input().split())\ng = [[] for i in xrange(V)]\ndeg = [0]*V\nfor i in xrange(E):\n    s, t = map(int, raw_input().split())\n    g[s].append(t)\n    deg[t] += 1\n\nans = list(v for v in xrange(V) if deg[v]==0)\ndeq = deque(ans)\nused = [0]*V\n\nwhile deq:\n    v = deq.popleft()\n    for t in g[v]:\n        deg[t] -= 1\n        if deg[t]==0:\n            deq.append(t)\n            ans.append(t)\nprint \"\\n\".join(map(str, ans))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef topologicalSort(v,e):\n    global color,out,indeg\n    color=[\"white\" for _ in range(v)]\n    indeg=[[0,[]] for _ in range(v)]\n    out=[]\n\n    for i in range(e):\n        s,t=map(int,input().split())\n        indeg[s][0] +=1\n        indeg[t][1] +=[s]\n\n    for i in range(v):\n        if indeg[i][0]==0 and color[i]==\"white\":\n            BFS(i)\n\n    return out[::-1]\n\n\ndef BFS(s):\n    Q=deque([])\n    Q.append(s)\n    color[s]=\"gray\"\n    while len(Q)!=0:\n        u=Q.popleft()\n        out.append(u)\n\n        for i in indeg[u][1]:\n            indeg[i][0] -=1\n            if indeg[i][0]==0 and color[i]==\"white\":\n                color[i]=\"gray\"\n                Q.append(i)\n\n\nv,e=map(int,input().split())\nfor i in topologicalSort(v,e):\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport pprint\nfrom queue import Queue\n\n\"\"\"Topological Sort\"\"\"\n\n#fd = os.open('GRL_4_B.txt', os.O_RDONLY)\n#os.dup2(fd, sys.stdin.fileno())\n\nV, E = list(map(int, input().split()))\nG = [[] for i in range(V)]\nindig = [0] * V # ??\\?¬???°\nfor i in range(V):\n    s, t = list(map(int, input().split()))\n    G[s].append(t)\n    indig[t] += 1\n\nq = Queue()\nout = []\n\ndef bfs(node_index):\n    q.put(node_index)\n\n    while not q.empty():\n        u = q.get()\n        out.append(u)\n\n        # u?????????????????§u?????????indig????????????\n        for index in G[u]:\n            indig[index] -= 1\n            if indig[index] == 0:\n                q.put(index)\n\n# bfs?????????\nindig_copy = indig[:]\nfor i in range(V):\n    if indig_copy[i] == 0:\n        bfs(node_index=i)\n\n\nprint(out)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef Topologicalsort(start):\n    for i in start:\n        color[i]=2\n        q.append(i)\n    while len(q)>0:\n        i=q.popleft()\n        color[i]=2\n        ans.append(i)\n        for j in xrange(v):\n            if m[i][j]!=-1 and color[j]==0:\n                if ct[j]>1:\n                    ct[j]-=1\n                else:\n                    q.append(m[i][j])\n                    color[j]=1\n\nv,e=map(int,raw_input().split())\nm=[[-1]*v for i in xrange(v)]\nmr=[[-1]*v for i in xrange(v)]\nct=[0]*v\ncolor=[0]*v\nstart=[]\nans=deque()\nq=deque()\nfor i in xrange(v):\n    s,t=map(int,raw_input().split())\n    m[s][t]=t\n    mr[t][s]=1\n    ct[t]+=1\n\nfor i in xrange(v):\n    if mr[i]==[-1]*v:\n        start.append(i)\nTopologicalsort(start)\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "# GRL_4_B: Topological Sort\nimport sys\n\n\n# input\nv, e = map(int, sys.stdin.readline().strip().split())\nG = [[] for _ in range(v)]\nindeg = [0] * v\nfor i in range(e):\n    s, t = map(int, sys.stdin.readline().strip().split())\n    G[s].append(t)\n    indeg[t] += 1\n# print('G : {}\\nindeg : {}'.format(G, indeg))\n\n# calc\nans = []\n\n\ndef dfs(u):\n    if indeg[u] == 0:\n        ans.append(u)\n        for i in G[u]:\n            indeg[i] -= 1\n            dfs(i)\n\n\nindeg_start = indeg.copy()\nfor i in range(v):\n    if indeg_start[i] == 0:  # 入ってくる辺がない = 最初のノードからスタート\n        dfs(i)\n\n# print(indeg)\nfor i in ans:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\ndef topologicalSort():\n    input = sys.stdin.readline\n    V, E = map(int, input().split())\n    Parent_node = [0 for _ in range(V)]\n    Son_node = [set() for _ in range(V)]\n    for _ in range(E):\n        a, b = map(int, input().split()) #default: 0-indexed\n        Son_node[a] |= {b}\n        Parent_node[b] += 1\n\n    stack = deque() #入次数が0のノードを格納する\n    for i, p in enumerate(Parent_node):\n        if p == 0: stack.append(i)\n\n    sortedArray = []\n    while stack:\n        nowNode = stack.popleft()\n        sortedArray.append(nowNode)\n        for nextNode in Son_node[nowNode]:\n            Parent_node[nextNode] -= 1\n            if Parent_node[nextNode] == 0: stack.append(nextNode)\n\n    for a in sortedArray: print(a)\n\n    return len(sortedArray) == V\n\nif __name__ == \"__main__\":\n    topologicalSort()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nV,E = map(int,input().split())\n\ndic = {}\npnum = [0] * V\n\nfor i in range(E):\n\n    s,t = map(int,input().split())\n\n    pnum[t] += 1\n    \n    if s not in dic:\n        dic[s] = []\n    dic[s].append(t)\n\nq = deque([])\nans = []\n\nfor i in range(V):\n\n    if pnum[i] == 0:\n        q.append(i)\n        ans.append(i)\n\nwhile len(q) > 0:\n\n    now = q.popleft()\n\n    if now not in dic:\n        continue\n\n    for i in dic[now]:\n        pnum[i] -= 1\n\n        if pnum[i] == 0:\n            q.append(i)\n            ans.append(i)\n\nfor i in range(V):\n    print (ans[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef Topologicalsort():\n    for i in xrange(v):\n        if indeg[i]==0 and color[i]==0:\n            bfs(i)\n\ndef bfs(s):\n    color[s]=2\n    q.append(s)\n    while len(q)>0:\n        i=q.popleft()\n        ans.append(i)\n        for j in xrange(v):\n            if m[i][j]!=-1 and color[j]==0 :\n                indeg[j]-=1\n                if indeg[j]==0:\n                    q.append(m[i][j])\n                    color[j]=1\n\nv,e=map(int,raw_input().split())\nm=[[-1]*v for i in xrange(v)]\nindeg=[0]*v\ncolor=[0]*v\nstart=[]\nans=deque()\nq=deque()\nfor i in xrange(v):\n    s,t=map(int,raw_input().split())\n    m[s][t]=t\n    indeg[t]+=1\nTopologicalsort()\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "import queue\n\ndef bfs(u):\n    q = queue.Queue()\n    q.put(u)\n    \n    while not q.empty():\n        v = q.get()\n        color[v] = 'black'\n        ans.append(v)\n        for w in Adj[v]:\n            indeg[w] -= 1\n            if indeg[w] == 0 and color[w] == 'white':\n                q.put(w)\n                \n    return\n        \n\nn,m = map(int,input().split())\ncolor = ['white' for _ in range(n)]\nAdj = [[] for _ in range(n)]\nindeg = [0]*n\nans = []\nfor i in range(m):\n    s,t = map(int,input().split())\n    Adj[s].append(t)\n    indeg[t] += 1\n    \nfor i in range(n):\n    if indeg[i] == 0 and color[i] == 'white':\n        bfs(i)\n        \nfor i in range(n):\n    print(ans[i])\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    nvertices, nedges = map(int, input().split())\n    Adj = [[] * nvertices for i in range(nvertices)]\n    for i in range(nedges):\n        u, v = map(int, input().split())\n        Adj[u].append(v)\n\n    visited = [False] * nvertices\n    ordering = []\n    for u in range(nvertices):\n        if not visited[u]:\n            dfs(Adj, u, visited, ordering)\n\n    for u in reversed(ordering):\n        print(u)\n\n\ndef dfs(Adj, u, visited, ordering):\n    visited[u] = True\n    for v in Adj[u]:\n        if not visited[v]:\n            dfs(Adj, v, visited, ordering)\n\n    ordering.append(u)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def topological_sort(G):\n  d = {}\n  nodes = set()\n  for i in G:\n    if i not in d:\n      d[i] = set()\n    for j in G[i]:\n      if j not in d:\n        d[j] = set()\n      d[j].add(i)\n  for i in d:\n    if len(d[i]) == 0:\n      nodes.add(i)\n  visited = set()\n  ret = []\n  while len(visited) < len(G):\n    n = nodes.pop()\n    if n not in visited:\n      for j in G[n]:\n        d[j].discard(n)\n        if len(d[j]) == 0 and j not in visited:\n          nodes.add(j)\n      ret.append(n)\n      visited.add(n)\n  return ret\n\n\n\n\nn,m = list(map(int, input().split(' ')))\nG = {}\nfor i in range(n):\n  G[i] = set()\nfor _ in range(m):\n  s,t = list(map(int, input().split(' ')))\n  G[s].add(t)\n\nL = topological_sort(G)\n\nfor n in L:\n  print(n)"
  },
  {
    "language": "Python",
    "code": "from sys import exit\nimport queue\nV,E = [int(n) for n in input().split()]\nans = []\n\n# N = int(input())\ngraph = [[] for _ in range(V)]\nindeg = [0]*E\nyet = [True]*E\ndef bfs(s):\n    q = queue.Queue()\n    q.put(s)\n    while(not q.empty()):\n        u = q.get()\n        ans.append(u)\n        yet[u]=False\n        for v in graph[u]:\n            indeg[v]-=1\n            if(indeg[v]==0):\n                q.put(v)\n\nfor i in range(E):\n    s, t = [int(n) for n in input().split()]\n    graph[s].append(t)\n    indeg[t]+=1\nfor i in range(E):\n    if(indeg[i]==0 and yet[i]):\n        bfs(i)\nfor a in ans:\n    print(a)\n# a = [int(input()) for _ in range(N)]\n# S = str(input())\n# L = len(S)\n# T = str(input())\n# exit()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, id):\n        self.id = id\n        self.adj = []\n        self.indeg = 0\n        self.passed = False\n\n    def is_start(self):\n        return self.indeg == 0\n\n    def __repr__(self):\n        return \"Node({},{},{},{})\".format(\n            self.id, self.passed,\n            [v.id for v in self.adj],\n            [v.id for v in self.radj])\n\n\ndef read_edges(ne, V):\n    for _ in range(ne):\n        s, t = [int(x) for x in input().split()]\n        V[s].adj.append(V[t])\n        V[t].indeg += 1\n\n\ndef sort(V):\n    W = []\n\n    def visit(v):\n        S = []\n        S.append(v)\n\n        while S:\n            v = S.pop()\n            v.passed = True\n            W.append(v)\n            for a in v.adj:\n                a.indeg -= 1\n                if a.is_start():\n                    S.append(a)\n\n    for v in V:\n        if v.is_start() and not v.passed:\n            visit(v)\n\n    return W\n\n\ndef main():\n    nv, ne = [int(x) for x in input().split()]\n    V = [Node(id) for id in range(nv)]\n    read_edges(ne, V)\n    W = sort(V)\n    [print(v.id) for v in W]\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nV, E = list(map(int, input().split()))\nedge = [[] for i in range(V)]\nin_num = [0] * V\n\nfor i in range(E):\n    s, t = list(map(int, input().split()))\n    edge[s].append(t)\n    in_num[t] += 1\n    \nq = deque()\n\nfor i in range(V):\n    if in_num[i] == 0: q.append(i)\n\nans = deque()\n\nwhile q:\n    v = q.popleft()\n    \n    ans.append(v)\n    \n    for u in edge[v]:\n        in_num[u] -= 1\n        if in_num[u] == 0: q.append(u)\n        \nfor a in ans: print(a)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN,E=map(int,input().split())\nG=[[] for i in range(N)]\nIn=[0]*N\nfor i in range(E):\n    s,t=map(int,input().split())\n    G[s].append(t)\n    In[t]+=1\nS=deque([i for i in range(N) if In[i]==0])\nres=[]\nwhile S:\n    b=S.popleft()\n    for nv in G[b]:\n        In[nv]-=1\n        if(In[nv]==0):\n            S.append(nv)\n    res.append(b)\nprint(*res,sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "v, e = map(int, input().split())\n\nadjacency_list = [[] for i in range(v)]\n\nqueue = []\ndeg = [0] * v\n\nfor _ in range(e):\n    s, t = map(int, input().split())\n    adjacency_list[s].append(t)\n    deg[t] += 1\n    \nfor i in range(v):\n    if deg[i] == 0:\n        queue.append(i)\n        print(i)\n        \nwhile queue:\n    vertex = queue.pop(0)\n    for v in adjacency_list[vertex]:\n        deg[v] -= 1\n        if deg[v] == 0:\n            queue.append(v)\n            print(v)\n"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\nfrom decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nV, E = MAP()\nst = [LIST() for _ in range(E)]\n\ngraph = [[] for _ in range(V)]\ndag = [0]*V\nfor s, t in st:\n\tgraph[s].append(t)\n\tdag[t] += 1\n\nans = [i for i, x in enumerate(dag) if x == 0]\nq = deque([i for i, x in enumerate(dag) if x == 0])\nwhile q:\n\tS = q.popleft()\n\tfor node in graph[S]:\n\t\tdag[node] -= 1\n\t\tif dag[node] == 0:\n\t\t\tans.append(node)\n\t\t\tq.append(node)\n\nif sum(dag):\n\tprint(-1)\nelse:\n\tprint(*ans, sep=\"\\n\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\n\nV, E = map(int, input().split())\nG = defaultdict(list)\n\nfor i in range(E):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nans = deque([])\nvisited = defaultdict(bool)\ndef visit(v):\n    if visited[v]: return\n    visited[v] = True\n    for k in G[v]:\n        visit(k)\n    ans.appendleft(v)\n\nfor v in range(V):\n    visit(v)\n\nprint('\\n'.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom collections import deque\n\ndef inpl(): return tuple(map(int, input().split()))\n\nV, E = inpl()\nindeg = [0] * V\nadj = {k: [] for k in range(V)}\n\nfor _ in range(E):\n    s, t = inpl()\n    adj[s].append(t)\n    indeg[t] += 1\n\nQ = deque([i for i, ind in enumerate(indeg) if ind == 0])\nres = []\n\nwhile Q:\n    q = Q.popleft()\n    for i in adj[q]:\n        indeg[i] -= 1\n        if indeg[i] == 0:\n            Q.append(i)\n    res.append(q)\n\nfor r in res:\n    print(r)"
  },
  {
    "language": "Python",
    "code": "def topologicalSortBfs(n):\n    for i in range(n):\n        color[i] = WHITE\n\n    for i in range(0, n):\n        if indeg[i] == 0 and color[i] == WHITE:\n            bfs(i)\n\n\ndef bfs(s):\n    Q.appendleft(s)\n    color[s] = GRAY\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and color[v] == WHITE:\n                color[v] = GRAY\n                Q.append(v)\n\n\ndef topologicalSortDfs(n):\n    for i in range(n):\n        color[i] = WHITE\n\n    for s in range(0, n):\n        if color[s] == WHITE:\n            dfs(s)\n\n\ndef dfs(u):\n    color[u] = GRAY\n    for v in G[u]:\n        if color[v] == WHITE:\n            dfs(v)\n    out.appendleft(u)\n\n\nn, e = map(int, input().split())\nG = {}\nfor i in range(n):\n    G[i] = []\nindeg = [0] * n\nfor i in range(e):\n    s, t = map(int, input().split())\n    indeg[t] += 1\n    G[s].append(t)\ncolor = [None] * n\nout = deque([])\nWHITE = 0\nGRAY = 1\nQ = deque([])\n\ntopologicalSortDfs(n)\nprint(*out)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\ndef topological_sort(N, edges):\n    def dfs(u):\n        used[u] = True\n        for v in edges[u]:\n            if not used[v]:\n                dfs(v)\n        result.append(u)\n\n    used = [False] * N\n    result = []\n    for i in range(N):\n        if not used[i]:\n            dfs(i)\n\n    return result[::-1]\n\n\ndef main():\n    N, M = map(int, input().split())\n    edges = defaultdict(list)\n    for _ in range(M):\n        s, t = map(int, input().split())\n        edges[s].append(t)\n\n    ans = topological_sort(N, edges)\n    print(*ans)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10**7)\n\nV, E = map(int, input().split())\nG = [[] for _ in range(V)]\n\nfor _ in range(E):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nvisited = [0]*V\nans = deque([])\n\ndef dfs(u):\n    visited[u] = 1\n    for i in G[u]:\n        if visited[i] == 0:\n                dfs(i)\n    ans.appendleft(u)\n\nfor s in range(V):\n    if visited[s] == 0:\n        dfs(s)\n\nfor a in ans:\n    print(a)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom collections import defaultdict\nV, E = map(int, input().split())\nd = [0]*V\nG = defaultdict(list)\nfor i in range(E):\n    s, t = map(int, input().split())\n    d[t] += 1\n    G[s].append(t)\nq = deque([])\nfor i in range(V):\n    if d[i] == 0:\n        q.append(i)\nans = []\nwhile q:\n    s = q.popleft()\n    ans.append(s)\n    for t in G[s]:\n        d[t] -= 1\n        if d[t] == 0:\n            q.append(t)\nfor x in ans:\n    print(x)    \n        \n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef topological(N, LIST):  # トポロジカルソート:DAGに適用可\n    incnt = [0] * N\n    CHILD = [set() for _ in range(N)]\n    for a, b in LIST:\n        CHILD[a].add(b)\n        incnt[b] += 1\n\n    TPLGSORT = []\n    que = deque([i for i, num in enumerate(incnt) if num == 0])\n    while len(que) > 0:\n        q = que.popleft()\n        for i in CHILD[q]:\n            incnt[i] -= 1\n            if incnt[i] == 0:\n                que.append(i)\n        TPLGSORT.append(q)\n    return TPLGSORT\n\n\nn, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\ntplg = topological(n, ab)\nprint(*tplg, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport os\nimport sys\n\n\ndef main():\n    sys.setrecursionlimit(100000)\n    V, E = read_ints()\n    G = [set() for _ in range(V)]\n    for _ in range(E):\n        s, t = read_ints()\n        G[s].add(t)\n    print(*solve(V, E, G), sep='\\n')\n\n\ndef solve(V, E, G):\n    topo = []\n    done = [False] * V\n\n    def dfs(i):\n        if done[i]:\n            return\n        for j in G[i]:\n            dfs(j)\n        done[i] = True\n        topo.append(i)\n\n    for i in range(V):\n        if not done[i]:\n            dfs(i)\n\n    topo.reverse()\n    return topo\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\nN,M = inpl()\nlines = defaultdict(set)\nhh = [0]*N\nfor _ in range(M):\n    x,y = inpl()\n    lines[x].add(y)\n    hh[y] += 1\n\nq = queue.Queue()\nfor t in range(N):\n    if hh[t] == 0:\n        q.put(t)\n\ntopological = []\nwhile not q.empty():\n    s = q.get()\n    topological.append(s)\n    for t in lines[s]:\n        hh[t] -= 1\n        if hh[t] == 0:\n            q.put(t)\n\nfor x in topological:\n    print(x)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nfrom collections import deque\ndef topological_sort(g, v):\n    in_count = Counter(y for x in g.values() for y in x)\n    s = deque([i for i in range(v) if in_count[i] == 0])\n    while s:\n        n = s.popleft()\n        yield n\n        for m in g[n]:\n            in_count[m] -= 1\n            if in_count[m] <= 0:\n                s.append(m)\n\nfrom sys import stdin\nfrom collections import defaultdict\nreadline = stdin.readline\n\nv, e = map(int, readline().split())\ng = defaultdict(set)\nfor _ in range(e):\n    s, t = map(int, readline().split())\n    g[s] |= {t}\nfor i in topological_sort(g, v):\n    print(i)"
  },
  {
    "language": "Python",
    "code": "nv, ne = map(int, input().split(' '))\nin_degs = [0] * nv\nq = []\nouts = {}\no = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n\n    if s in outs: outs[s].append(t)\n    else: outs[s] = [t]\n\n    in_degs[t] += 1\n\nfor i in range(nv):\n    if in_degs[i] == 0: q.append(i)\n\nwhile len(q) > 0:\n    v = q.pop(0)\n    o.append(v)\n\n    if v in outs:\n        for out in outs[v]:\n            in_degs[out] -= 1\n            if in_degs[out] == 0: q.append(out)\n\n[print(v) for v in o]"
  },
  {
    "language": "Python",
    "code": "import heapq\ndef topologicalsort(N,E):\n    V = [0]*N\n    for i in range(N):\n        for y in E[i]:\n            V[y] += 1\n    S = [ i for i in range(N) if V[i] == 0]\n    SORTED = []\n    while S:\n        s = S.pop(0)\n        SORTED.append(s)\n        for t in E[s]:\n            V[t] -= 1\n            if V[t] == 0:\n                S.append(t)\n    return SORTED\n    \nN, M = map( int, input().split())\nE = [ [] for _ in range(N)]\nfor _ in range(M):\n    x, y = map( int, input().split())\n    # x, y = x-1, y-1\n    E[x].append(y)\nANS = topologicalsort(N, E)\nfor i in range(N):\n    print(ANS[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef topological_sort(indeg, tonodes, v):\n    nodes = deque([])\n    visited = deque([])\n    for i in range(v):\n        if indeg[i] == 0:\n            nodes.append(i)\n    while len(nodes) > 0:\n        i = nodes.popleft()\n        visited.append(i)\n        for j in tonodes[i]:\n            indeg[j] -= 1\n            if indeg[j] == 0:\n                nodes.append(j)\n    return visited\n\n\ndef main():\n    ve = input().split()\n    v, e = tuple(map(int, ve))\n    indeg = [0 for _ in range(v)]\n    tonodes = [[] for _ in range(v)]\n\n    for _ in range(e):\n        st = input().split()\n        s, t = tuple(map(int, st))\n        indeg[t] += 1\n        tonodes[s].append(t)\n    visited = topological_sort(indeg, tonodes, v)\n    while len(visited) > 0:\n        print(visited.popleft())\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\nMax = sys.maxsize\ndef l(): #intのlist\n\treturn list(map(int,input().split()))\ndef m(): #複数文字\n\treturn map(int,input().split())\ndef onem(): #Nとかの取得\n\treturn int(input())\ndef s(x): #圧縮\n\ta = []\n\taa = x[0]\n\tsu = 1\n\tfor i in range(len(x)-1):\n\t\tif aa == x[i+1]:\n\t\t\ta.append([aa,su])\n\t\t\taa = x[i+1]\n\t\t\tsu = 1\n\t\telse:\n\t\t\tsu += 1\n\ta.append([aa,su])\n\treturn a\ndef jo(x): #listをスペースごとに分ける\n\treturn \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n\treturn max(map(max,x))\n\ndef Topo_sort(x,y):\n\tco = cl.Counter(n for m in x.values() for n in m)\n\tS = cl.deque([i for i in range(y) if co[i] == 0])\n\twhile S:\n\t\tn = S.popleft()\n\t\tyield n\n\t\tfor i in x[n]:\n\t\t\tco[i] -= 1\n\t\t\tif co[i] <= 0:\n\t\t\t\tS.append(i)\n# g = cl.dafaultdict(set)に有向グラフを作成し(g[~] != ~) リストが帰ってくる\n\nv,e = m()\n\ng = cl.defaultdict(set)\n\nfor i in range(e):\n\ts,t = m()\n\tg[s] |= {t}\na = Topo_sort(g,v)\n#print(list(a))\nfor i in Topo_sort(g,v):\n\tprint(i)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\n\nv, n = map(int, input().split())  #v:頂点数 n:辺の数\nes = [[int(x) for x in input().split()] for _ in range(n)]\n\nouts = defaultdict(list)\nins = defaultdict(int)\nfor v1, v2 in es:\n    outs[v1].append(v2)\n    ins[v2] += 1\n\nq = deque(v1 for v1 in range(v) if ins[v1] == 0)\nres = []\nwhile q:\n    v1 = q.popleft()\n    res.append(v1)\n    for v2 in outs[v1]:\n        ins[v2] -= 1\n        if ins[v2] == 0:\n            q.append(v2)\n\nfor i in res:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\n# 幅優先と深さ優先でトポロジカルソート\ndef set_indeg(u):\n    # t = uとなる数を求める。\n    ans = 0\n    for line in G:\n        if line[u] == 1:\n            ans += 1\n    return ans\n\n\ndef topologicalSortBfs(n):\n    for i in range(n):\n        color[i] = WHITE\n        indeg[i] = set_indeg(i)\n\n    for i in range(0, n):\n        if indeg[i] == 0 and color[i] == WHITE:\n            bfs(i)\n\n\ndef bfs(s):\n    Q.appendleft(s)\n    color[s] = GRAY\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for v in range(n):\n            if G[u][v] != 1:\n                continue\n            indeg[v] -= 1\n            if indeg[v] == 0 and color[v] == WHITE:\n                color[v] = GRAY\n                Q.append(v)\n\n\ndef topologicalSortDfs(n):\n    for i in range(n):\n        color[i] = WHITE\n        indeg[i] = set_indeg(i)\n\n    for s in range(0, n):\n        if color[s] == WHITE:\n            dfs(s)\n\n\ndef dfs(u):\n    color[u] = GRAY\n    for v in range(n):\n        if color[v] == WHITE and G[u][v] == 1:\n            dfs(v)\n    out.appendleft(u)\n\n\nn, e = map(int, input().split())\nG = [[0] * n for _ in range(n)]\nfor i in range(e):\n    s, t = map(int, input().split())\n    G[s][t] = 1\ncolor = [None] * n\nout = deque([])\nindeg = [None] * n\nWHITE = 0\nGRAY = 1\nQ = deque([])\n\ntopologicalSortBfs(n)\nprint(*out)\n# 031452\n# dfsがおかしい\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nV, E = map(int, stdin.readline().split())\nadj_list = deque([[] for _ in [0] * V])\nis_visited = [False] * V\nfor _ in [0] * E:\n    s, t = map(int, stdin.readline().split())\n    adj_list[s].append(t)\nout = deque()\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\nprint(*out, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "def main():\n    nvertices, nedges = map(int, input().split())\n    Adj = [[] for i in range(nvertices)]\n    for i in range(nedges):\n        s, t = map(int, input().split())\n        Adj[s].append(t)\n\n    visited = [False] * nvertices\n    ordering = []\n    for u in range(nvertices):\n        if not visited[u]:\n            dfs(u, Adj, visited, ordering)\n\n    for v in reversed(ordering):\n        print(v)\n\n\ndef dfs(u, Adj, visited, ordering):\n    visited[u] = True\n    for v in Adj[u]:\n        if not visited[v]:\n            dfs(v, Adj, visited, ordering)\n    ordering.append(u)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef Topologicalsort():\n    for i in xrange(v):\n        if indeg[i]==0 and color[i]==0:\n            bfs(i)\n\ndef bfs(s):\n    color[s]=2\n    q.append(s)\n    while len(q)>0:\n        i=q.popleft()\n        ans.append(i)\n        for j in xrange(v):\n            if m[i][j]!=-1:\n                indeg[j]-=1\n                if indeg[j]==0  and color[j]==0:\n                    q.append(m[i][j])\n                    color[j]=1\n\nv,e=map(int,raw_input().split())\nm=[[-1]*v for i in xrange(v)]\nindeg=[0]*v\ncolor=[0]*v\nans=deque()\nq=deque()\nfor i in xrange(e):\n    s,t=map(int,raw_input().split())\n    m[s][t]=t\n    indeg[t]+=1\nTopologicalsort()\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[] for i in range(N)]\nfor i in range(M):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nans = []\nV = set()\n\ndef dfs(n):\n    for e in G[n]:\n        if e not in V:\n            dfs(e)\n    if n not in V:\n        ans.append(n)\n        V.add(n)\n\n\nfor i in range(N):\n    if i not in V:\n        if i not in V:\n            dfs(i)\n            print()\n\nprint(*ans[::-1], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nV, E = map(int, stdin.readline().split())\nadj_list = [[] for _ in [0] * V]\nis_visited = [False] * V\nfor _ in [0] * E:\n    s, t = map(int, stdin.readline().split())\n    adj_list[s].append(t)\nout = deque()\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\nprint(*out, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom sys import stdin\nfrom collections import deque\n\nUNVISITED, VISITED_IN_QUEUE, POPPED_OUT = 0, 1, 2\n\n\ndef generate_adj_matrix(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        init_in_deg_list[v_to] += 1\n    return init_adj_table, init_in_deg_list\n\n\ndef topological_sort():\n    for v in range(vertices):\n        if not in_deg_list[v] and status[v] is UNVISITED:\n            bfs(v)\n\n    return ans\n\n\ndef bfs(v):\n    v_queue.append(v)\n    status[v] = VISITED_IN_QUEUE\n\n    while v_queue:\n        current = v_queue.popleft()\n\n        ans.append(current)\n\n        for v_adj in adj_table[current]:\n            in_deg_list[v_adj] -= 1\n            if not in_deg_list[v_adj] and status[v_adj] is UNVISITED:\n                status[v_adj] = VISITED_IN_QUEUE\n                v_queue.appendleft(v_adj)\n\n        status[current] = POPPED_OUT\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    status = [UNVISITED] * vertices\n    v_queue = deque()\n    init_adj_table = tuple([] for _ in range(vertices))\n    init_in_deg_list = [0] * vertices\n\n    ans = []\n    adj_table, in_deg_list = generate_adj_matrix(v_info)\n    print(*topological_sort())"
  },
  {
    "language": "Python",
    "code": "def topological_sort(G, revG):\n  n = len(revG)\n  S = set()\n  for u in revG:\n    if len(revG[u]) == 0:\n      S.add(u)\n  L = []\n  while len(S) > 0:\n    u = S.pop()\n    L.append(u)\n    for v in G[u]:\n      revG[v].remove(u)\n      if len(revG[v]) == 0:\n        S.add(v)\n  return L\n\n\nn, m = [int(i) for i in input().strip().split(' ')]\nG = {}\nrevG = {}\nfor i in range(n):\n  G[i] = set()\n  revG[i] = set()\nfor _ in range(n):\n  s, t = [int(i) for i in input().strip().split(' ')]\n  G[s].add(t)\n  revG[t].add(s)\n\n\nL = topological_sort(G, revG)\nfor n in L:\n  print(n)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[] for i in range(N)]\nfor i in range(M):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\n\ndef topological_sort(g):\n    topological_list = []\n    visited = set()\n\n    def dfs(n):\n        for e in g[n]:\n            if e not in visited:\n                dfs(e)\n        topological_list.append(n)\n        visited.add(n)\n\n    for i in range(len(g)):\n        if i not in visited:\n            dfs(i)\n\n    return topological_list[::-1]\n\n\nprint(*topological_sort(G), sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "#\n# 　　  ⋀_⋀　 \n#　　  (･ω･)  \n# .／ Ｕ ∽ Ｕ＼\n#  │＊　合　＊│\n#  │＊　格　＊│ \n#  │＊　祈　＊│ \n#  │＊　願　＊│ \n#  │＊　　　＊│ \n#      ￣\n#\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nfrom math import floor,ceil,sqrt,factorial,log #log2ないｙｐ\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\ninf=float('inf')\nmod = 10**9+7\ndef pprint(*A): \n    for a in A:     print(*a,sep='\\n')\ndef INT_(n): return int(n)-1\ndef MI(): return map(int,input().split())\ndef MF(): return map(float, input().split())\ndef MI_(): return map(INT_,input().split())\ndef LI(): return list(MI())\ndef LI_(): return [int(x) - 1 for x in input().split()]\ndef LF(): return list(MF())\ndef LIN(n:int): return [I() for _ in range(n)]\ndef LLIN(n: int): return [LI() for _ in range(n)]\ndef LLIN_(n: int): return [LI_() for _ in range(n)]\ndef LLI(): return [list(map(int, l.split() )) for l in input()]\ndef I(): return int(input())\ndef F(): return float(input())\ndef ST(): return input().replace('\\n', '')\ndef main():\n    N,M = MI()\n    edge = [[]for _ in range(N)]\n    indegree = [0]*N #入次数\n    for _ in range(M):\n        a,b = MI()\n        edge[a].append(b)\n        indegree[b] += 1\n    #print(indegree)\n    #入次数が0の点からあれしていく\n    queue = deque() \n    for i,x in enumerate(indegree):\n        if not x:\n            queue.append(i)\n\n    pop = queue.popleft\n    topological_index = []\n    while queue:\n        v = pop()\n        topological_index.append(v)\n\n        for to in edge[v]:\n            indegree[to] -= 1\n            if not indegree[to]:\n                queue.append(to)\n    if tuple(1 for i in indegree if i!=0):\n        print(\"loop\")\n\n    print(*topological_index,sep=\"\\n\")\n\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\n\n\ndef dfs(i):\n    global visited, edges, counter, finish_order\n    visited[i] = True\n    for edge in edges[i]:\n        if visited[edge]:\n            continue\n        dfs(edge)\n    finish_order[i] = (counter, i)\n    counter += 1\n\n\nn, m = map(int, input().split())\n\nedges = [set() for _ in range(n)]\n\nfor _ in range(m):\n    s, t = map(int, input().split())\n    edges[s].add(t)\n\nvisited = [False] * n\nfinish_order = [None] * n\ncounter = 0\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\nfor d, i in sorted(finish_order, reverse=True):\n    print(i)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\n\ndef read_graph(n, k):\n    A = [ [] for _ in range(n) ]\n    for _ in range(k):\n        line = stdin.readline().strip().split()\n        A[int(line[0])].append(int(line[1]))\n    return A\n\ndef topological_sort(n, A):\n    color = [\"WHITE\"] * n\n    Q = deque([])\n    out = []\n\n    indeg = [0] * n\n    for i in range(n):\n        for j in A[i]:\n            indeg[j] = indeg[j] + 1\n\n    def bfs(s):\n        nonlocal color\n        nonlocal indeg\n        nonlocal Q\n        color[s] = \"GRAY\"\n        Q.append(s)\n\n        while Q:\n            u = Q.popleft()\n            out.append(u)\n\n            for v in A[u]:\n                indeg[v] = indeg[v] - 1\n                if indeg[v] == 0 and color[v] == \"WHITE\":\n                    color[v] = \"GRAY\"\n                    Q.append(v)\n\n    for i in range(n):\n        if indeg[i] == 0 and color[i] == \"WHITE\":\n            bfs(i)\n\n    return out\n\nn, k = [int(i) for i in input().split()]\nA = read_graph(n, k)\nB = topological_sort(n, A)\nfor i in B:\n    print(i)\n\n"
  },
  {
    "language": "Python",
    "code": "v,e=map(int,input().split())\nfrom collections import defaultdict\nincnt=defaultdict(int)\nedges=[[] for i in range(0+v)]\nfor i in range(e):\n    \"\"\"#weighted->erase_,__,___=map(int,input().split())\n    edges[_].append((__,___))\n    incnt[__]+=1\n    \"\"\"\n    _,__=map(int,input().split())\n    edges[_].append(__)\n    incnt[__]+=1\n    \"\"\"\n\"\"\"#weighted->erase\nfrom collections import deque\ndq=deque([])\ntopo=[]\nfor i in range(v):\n    if incnt[i]==0:\n        dq.append(i)\nwhile dq:\n    a=dq.popleft()\n    for to in edges[a]:\n        incnt[to]-=1\n        if incnt[to]==0:dq.append(to)\n    topo.append(a)\nprint(*topo,sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "V,E = list(map(int,input().split()))\n\n#訪問済の頂点を保持\nvisit=[]\nno_visit=list(range(V))\n\n#各頂点の入次数\nenter=[0]*V\n\n#隣接リスト\nad_list=[[] for _ in range(V)]\n\nfor e in range(E):\n    start,end=list(map(int,input().split()))\n    ad_list[start].append(end)\n    enter[end]+=1\n    \nenter , ad_list\n\nwhile True:\n    if len(visit)==V:\n        break\n        \n    for n_v_idx,n_v in enumerate(no_visit):\n        e=enter[n_v]\n        if e == 0:\n            v=no_visit.pop(n_v_idx)\n            visit.append(v)\n            for a in ad_list[n_v]:\n                enter[a]=enter[a]-1\nfor v in visit:\n    print(v)\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nnv, ne = map(int, input().split(' '))\nin_degrees = [[] for _ in range(nv)]\nq = queue.Queue()\no = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n    in_degrees[t].append(s)\n\nfor i in range(nv):\n    if len(in_degrees[i]) == 0: q.put(i)\n\nwhile not q.empty():\n    v = q.get()\n    o.append(v)\n\n    for i in range(nv):\n        if v in in_degrees[i]:\n            in_degrees[i].remove(v)\n            if len(in_degrees[i]) == 0: q.put(i)\n\n[print(v) for v in o]"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[] for i in range(N)]\nfor i in range(M):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nans = []\nV = set()\n\ndef dfs(n):\n    for e in G[n]:\n        dfs(e)\n    if n not in V:\n        ans.append(n)\n        V.add(n)\n\n\nfor i in range(N):\n    if i not in V:\n        if i not in V:\n            dfs(i)\n\nprint(*ans[::-1], sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \ttopological_sort\n# CreatedDate:  2020-05-18 14:33:31 +0900\n# LastModified: 2020-05-18 14:50:54 +0900\n#\n\n\nimport os\nimport sys\n#import numpy as np\n#import pandas as pd\n\n\ndef main():\n    v,e = map(int,input().split())\n    path_list = [[] for _ in range(v)]\n    to_there = [0]*v\n    for _ in range(e):\n        s,t = map(int,input().split())\n        path_list[s].append(t)\n        to_there[t]+=1\n\n    stack_list = [i for i,x in enumerate(to_there) if x==0]\n#    print(to_there)\n    while stack_list:\n        u = stack_list.pop()\n        for v in path_list[u]:\n            to_there[v]-=1\n            if to_there[v]==0:\n                stack_list.append(v)\n        print(u)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp\n\n\"\"\"\nimport sys\nfrom collections import deque\n\n\ndef bfs(u, result, out_edge, in_degree, processed):\n    q = deque()\n    q.append(u)\n    processed[u] = True\n    while q:\n        u = q.popleft()\n        result.append(u)\n        for e in out_edge[u]:\n            in_degree[e] -= 1\n            if in_degree[e] == 0 and processed[e] == False:\n                processed[e] = True\n                q.append(e)\n\n\n\n\n\ndef solve(V, in_degree, out_edge):\n    result = []\n    processed = [False for _ in range(V)]\n\n    for i, u in enumerate(in_degree):\n        if u == 0 and processed[i] == False:\n            bfs(i, result, out_edge, in_degree, processed)\n    return result\n\n\ndef main(args):\n    V, E = [int(x) for x in input().split(' ')]\n    in_degree = [0 for _ in range(V)]\n    out_edge = [[] for _ in range(V)]\n    for _ in range(E):\n        s, t = [int(x) for x in input().split(' ')]\n        out_edge[s].append(t)\n        in_degree[t] += 1\n\n    result = solve(V, in_degree, out_edge)\n    print('\\n'.join(map(str, result)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import queue\n\nnv, ne = map(int, input().split(' '))\nin_degs = [0] * nv\nq = queue.Queue()\nouts = {}\no = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n\n    if s in outs: outs[s].append(t)\n    else: outs[s] = [t]\n\n    in_degs[t] += 1\n\nfor i in range(nv):\n    if in_degs[i] == 0: q.put(i)\n\nwhile not q.empty():\n    v = q.get()\n    o.append(v)\n\n    if v in outs:\n        for out in outs[v]:\n            in_degs[out] -= 1\n            if in_degs[out] == 0: q.put(out)\n\n[print(v) for v in o]"
  },
  {
    "language": "Python",
    "code": "import sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj_list = [[] for i in range(V)]\n\nis_visited = [False] * V\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj_list[s].append(t)\n\nimport collections\n\nout = collections.deque()\n\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\n\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\n\nprint(*out, sep = '\\n')"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom typing import List, Optional\n\n\ndef topological_sort(\n    graph: List[List[int]], in_degrees: List[int], first_index: int = 0\n) -> Optional[List[int]]:\n    \"\"\"Topological sort that uses Kahn's algorithm and is able to detect cycles.\n    Returns:\n        If the given graph is DAG, a list of sorted vertices is returned.\n        Otherwise, if loops are detected, None is returned.\n    \"\"\"\n    V = len(graph) + first_index\n    order = [i for i in range(first_index, V) if not in_degrees[i]]\n    queue = deque(order)\n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if not in_degrees[v]:\n                queue.append(v), order.append(v)\n\n    return order if len(order) + first_index == V else None\n\n\ndef grl_4_b():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/4/GRL_4_B\n    V, _, *ST = map(int, open(0).read().split())\n    graph = [[] for _ in range(V)]\n    in_degrees = [0] * V\n    for s, t in zip(*[iter(ST)] * 2):\n        graph[s].append(t)\n        in_degrees[t] += 1\n\n    res = topological_sort(graph, in_degrees)\n    print(\"\\n\".join(map(str, res)))\n\n\nif __name__ == \"__main__\":\n    grl_4_b()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_4_B: Path/Cycle - Topological Sort\n\nfrom collections import namedtuple\n\n\nDirectedEdge = namedtuple('DirectedEdge', ('src', 'dest'))\n\n\ndef revert(edge):\n    return edge._replace(src=edge.dest, dest=edge.src)\n\n\nclass Digraph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, edge):\n        self._edges[edge.src].append(edge)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n    def reversed(self):\n        g = self.__class__(self.v)\n        for e in self.edges():\n            g.add(revert(e))\n\n        return g\n\n\ndef sorted_topological(graph):\n    return reverse_post(graph)\n\n\ndef reverse_post(graph):\n    def visit(v):\n        if not visited[v]:\n            visited[v] = True\n            return True\n        else:\n            return False\n\n    def leave(v):\n        if not left[v]:\n            left[v] = True\n            vs.append(v)\n        return False\n\n    visited = [False] * graph.v\n    left = [False] * graph.v\n    vs = []\n\n    for i in range(graph.v):\n        if not visited[i]:\n            stack = [(i, leave)]\n            stack.extend((e.dest, visit) for e in graph.adj(i))\n            while stack:\n                v, f = stack.pop()\n                if f(v):\n                    stack.append((v, leave))\n                    for e in graph.adj(v):\n                        stack.append((e.dest, visit))\n    return reversed(vs)\n\n\ndef run():\n    v, e = [int(i) for i in input().split()]\n    g = Digraph(v)\n\n    for _ in range(e):\n        s, t = [int(i) for i in input().split()]\n        g.add(DirectedEdge(s, t))\n\n    for v in sorted_topological(g):\n        print(v)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom sys import stdin\nfrom collections import deque\n\nUNVISITED, VISITED_IN_QUEUE, POPPED_OUT = 0, 1, 2\n\n\ndef generate_adj_matrix(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        init_in_deg_list[v_to] += 1\n    return init_adj_table, init_in_deg_list\n\n\ndef topological_sort():\n    for v in range(vertices):\n        if not in_deg_list[v] and status[v] is UNVISITED:\n            bfs(v)\n\n    return ans\n\n\ndef bfs(v):\n    v_queue.append(v)\n    status[v] = VISITED_IN_QUEUE\n\n    while v_queue:\n        current = v_queue.popleft()\n\n        ans.append(current)\n\n        for v_adj in adj_table[current]:\n            in_deg_list[v_adj] -= 1\n            if not in_deg_list[v_adj] and status[v_adj] is UNVISITED:\n                status[v_adj] = VISITED_IN_QUEUE\n                v_queue.appendleft(v_adj)\n\n        status[current] = POPPED_OUT\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    status = [UNVISITED] * vertices\n    v_queue = deque()\n    init_adj_table = tuple([] for _ in range(vertices))\n    init_in_deg_list = [0] * vertices\n\n    ans = []\n    adj_table, in_deg_list = generate_adj_matrix(v_info)\n    print(*topological_sort(), sep='\\n')"
  },
  {
    "language": "Python",
    "code": "def main():\n    N, M = (int(i) for i in input().split())\n    G = [[] for _ in range(N)]\n    deg = [0]*N\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        G[a].append(b)\n        deg[b] += 1\n\n    from collections import deque\n\n    def topological_sort():\n        que = deque()\n        ans = []*N\n        for i in range(N):\n            if deg[i] == 0:\n                que.append(i)\n                ans.append(i)\n\n        while que:\n            u = que.popleft()\n            for v in G[u]:\n                deg[v] -= 1\n                if deg[v] == 0:\n                    que.append(v)\n                    ans.append(v)\n        return ans\n\n    print(*topological_sort(), sep=\"\\n\")\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef topological_sort(graph: list) -> list:\n    \"\"\"入力した重みなしDAGに対してトポロジカルソートする\n    計算量: O(|V|+|E|)\n    入力条件: グラフGはDAGである、グラフGに多重辺はない、グラフGに自己ループはない\n    \"\"\"\n    n = len(graph)\n    degree = [0] * n\n    for g in graph:\n        for next_pos in g:\n            degree[next_pos] += 1\n    \n    # 次数が0、つまり入力の無い頂点を初期値状態とする\n    ans = [i for i in range(n) if degree[i] == 0]\n\n    q = deque(ans)\n    while q:\n        pos = q.popleft()\n        for next_pos in graph[pos]:\n            degree[next_pos] -= 1\n            if degree[next_pos] == 0:\n                q.append(next_pos)\n                ans.append(next_pos)\n    return ans\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(m)]\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = info[i]\n    graph[a].append(b)\nans = topological_sort(graph)\nfor pos in ans:\n    print(pos)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass Graph(): #directed\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        self.rev = [[] for _ in range(n)]\n        self.deg = [0 for _ in range(n)]\n        for e in edge:\n            self.graph[e[0] - indexed].append(e[1] - indexed)\n            self.rev[e[1] - indexed].append(e[0] - indexed)\n            self.deg[e[1] - indexed] += 1\n\n    def topological_sort(self):\n        deg = self.deg[:]\n        res = [i for i in range(self.n) if deg[i] == 0]\n        queue = deque(res)\n        used = [False for _ in range(self.n)]\n        while queue:\n            node = queue.popleft()\n            for adj in self.graph[node]:\n                deg[adj] -= 1\n                if deg[adj] == 0:\n                    queue.append(adj)\n                    res.append(adj)\n        return res\n\n\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nE = [tuple(map(int, input().split())) for _ in range(M)]\n\ng = Graph(N, E, 0)\nprint('\\n'.join(map(str, g.topological_sort())))\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nfrom collections import deque\nfrom enum import Enum\nimport sys\nimport math\nfrom _heapq import heappush, heappop\n\nBIG_NUM = 2000000000\nMOD = 1000000007\nEPS = 0.000000001\n\n\nV,E = map(int,input().split())\n\nin_num = [0]*V\nG = [[] for i in range(V)]\n\nfor loop in range(E):\n    tmp_from,tmp_to = map(int,input().split())\n    G[tmp_from].append(tmp_to)\n    in_num[tmp_to] += 1\n\nQ = deque()\n\nfor i in range(V):\n    if in_num[i] == 0:\n        Q.append(i)\n\nwhile len(Q) > 0:\n    node_id = Q.popleft()\n    print(\"%d\"%(node_id))\n    for adj in G[node_id]:\n        in_num[adj] -= 1\n        if in_num[adj] == 0:\n            Q.append(adj)\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef Topologicalsort():\n    for i in xrange(v):\n        if indeg[i]==0 and color[i]==0:\n            bfs(i)\n\ndef bfs(s):\n    color[s]=2\n    q.append(s)\n    while len(q)>0:\n        i=q.popleft()\n        ans.append(i)\n        for j in xrange(v):\n            if m[i][j]!=-1:\n                indeg[j]-=1\n                if indeg[j]==0  and color[j]==0:\n                    q.append(m[i][j])\n                    color[j]=1\n\nv,e=map(int,raw_input().split())\nm=[[-1]*v for i in xrange(v)]\nindeg=[0]*v\ncolor=[0]*v\nans=deque()\nq=deque()\nfor i in xrange(v):\n    s,t=map(int,raw_input().split())\n    m[s][t]=t\n    indeg[t]+=1\nTopologicalsort()\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\n\nv, n = map(int, input().split())\nes = [[int(x) for x in input().split()] for _ in range(n)]\n\nouts = defaultdict(list)\nins = defaultdict(int)\nfor v1, v2 in es:\n    outs[v1].append(v2)\n    ins[v2] += 1\n\nq = deque(v1 for v1 in range(v) if ins[v1] == 0)\nres = []\nwhile q:\n    v1 = q.popleft()\n    res.append(v1)\n    for v2 in outs[v1]:\n        ins[v2] -= 1\n        if ins[v2] == 0:\n            q.append(v2)\n\nfor i in res:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "v, e = map(int, input().split())\nindeg = [0]*v\nuv = [[] for _ in range(v)]\nfor i in range(e):\n    s, t = map(int, input().split())\n    uv[s].append(t)\n    indeg[t] += 1\n\n'''\ntopologicalSort\nトポロジカルソート\n'''\nvisited = [False]*v\nans = []\nfor i in range(v):\n    if indeg[i] == 0 and not visited[i]:\n        q = [i]\n        visited[i] = True\n        while len(q) > 0:\n            u = q.pop(0)\n            ans.append(u)\n            for v in uv[u]:\n                indeg[v] -= 1\n                if indeg[v] == 0 and not visited[v]:\n                    visited[v] = True\n                    q.append(v)\n\nfor v in ans:\n    print(v)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nv, e = map(int,input().split())\nedges = [[] for _ in range(v)]\nin_num = [0 for _ in range(v)]\n\nfor _ in range(e):\n    s,t = map(int, input().split())\n    edges[s].append(t)\n    in_num[t] += 1\n\nq = deque()\n\nfor i in range(len(in_num)):\n    if in_num[i] == 0:\n        q.append(i)\n\nans = []\nwhile q:\n    node = q.popleft()\n    ans.append(node)\n    for v in edges[node]:\n        in_num[v] -= 1\n        if in_num[v] == 0:\n            q.append(v)\n\nfor i in ans:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\n# 幅優先と深さ優先でトポロジカルソート\n\n\ndef topologicalSortBfs(n):\n    for i in range(n):\n        color[i] = WHITE\n\n    for i in range(0, n):\n        if indeg[i] == 0 and color[i] == WHITE:\n            bfs(i)\n\n\ndef bfs(s):\n    Q.appendleft(s)\n    color[s] = GRAY\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and color[v] == WHITE:\n                color[v] = GRAY\n                Q.append(v)\n\n\ndef topologicalSortDfs(n):\n    for i in range(n):\n        color[i] = WHITE\n\n    for s in range(0, n):\n        if color[s] == WHITE:\n            dfs(s)\n\n\ndef dfs(u):\n    color[u] = GRAY\n    for v in G[u]:\n        if color[v] == WHITE:\n            dfs(v)\n    out.appendleft(u)\n\n\nn, e = map(int, input().split())\nG = {}\nfor i in range(n):\n    G[i] = []\nindeg = [0] * n\nfor i in range(e):\n    s, t = map(int, input().split())\n    indeg[t] += 1\n    G[s].append(t)\ncolor = [None] * n\nout = deque([])\nWHITE = 0\nGRAY = 1\nQ = deque([])\n\ntopologicalSortDfs(n)\nprint(*out)\n# 031452\n# dfsがおかしい\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7 # 998244353\ninput=lambda:sys.stdin.readline().rstrip()\nres = []\ndef recursion(v, E, state) -> bool:\n    # base case\n    if state[v]:\n        return state[v] == 1\n    # recursion\n    state[v] = -1\n    flag = all(recursion(nv, E, state) for nv in E[v])\n    if flag:\n        state[v] = 1\n        res.append(v)\n    return flag\n\ndef resolve():\n    n, m = map(int,input().split())\n    E = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int,input().split())\n        E[u].append(v)\n    state = [0] * n # 0 : unvisited, -1 : visited & uncalculated, 1 : calculated\n    for v in range(n):\n        recursion(v, E, state)\n    print(*res[::-1], sep = '\\n')\nresolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nv, e  = map(int, input().split())\n\nEdg = [[] for _ in range(v)]\ninDeg = [0 for _ in range(v)]\nDone = [0 for _ in range(v)]\nfor _ in range(e):\n    s,t = map(int, input().split( ))\n    Edg[s].append(t)\n    inDeg[t] += 1\n\nQ= deque()\n\nans = []\nfor u in range(v):\n    if not inDeg[u]:\n        Q.append(u)\n\nwhile Q:\n    u = Q.popleft()\n    ans.append(u)\n    for t in Edg[u]:\n        inDeg[t] -= 1\n        if inDeg[t] == 0 and not Done[t]:\n            Q.append(t)\n            Done[t] = 1\n\n    \nfor i in ans:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\n\n\ndef dfs(i: int) -> None:\n    global visited, edges, counter, finish_order\n    visited[i] = True\n    for edge in edges[i]:\n        if visited[edge]:\n            continue\n        dfs(edge)\n    finish_order[i] = (counter, i)\n    counter += 1\n\n\nif __name__ == \"__main__\":\n    V, E = map(int, input().split())\n    edges = [set() for _ in range(V)]  # type: ignore\n\n    for _ in range(E):\n        s, t = map(lambda x: int(x), input().split())\n        edges[s].add(t)\n\n    visited = [False] * V\n    finish_order = [(0, 0)] * V\n    counter = 0\n\n    for i in range(V):\n        if not visited[i]:\n            dfs(i)\n\n    for d, i in sorted(finish_order, reverse=True):  # type: ignore\n        print(i)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef bfs(s, g, color, indeg, out):\n    q = deque()\n    q.append(s)\n    color[s] = True\n    while len(q) != 0:\n        u = q.popleft()\n        out.append(u)\n        for i in range(len(g[u])):\n            v = g[u][i]\n            indeg[v] -= 1\n            if indeg[v] == 0 and not color[v]:\n                color[v] = True\n                q.append(v)\n\n\ndef tsort(n, g):\n    color = [False] * n\n    indeg = [0] * n\n    for u in range(n):\n        for i in range(len(g[u])):\n            v = g[u][i]\n            indeg[v] += 1\n\n    out = []\n    for u in range(n):\n        if indeg[u] == 0 and not color[u]:\n            bfs(u, g, color, indeg, out)\n\n    for line in out:\n        print(line)\n\n\nif __name__ == '__main__':\n    n, m = [int(v) for v in input().split()]\n    g = [[] for i in range(n)]\n    for i in range(m):\n        s, t = [int(v) for v in input().split()]\n        g[s].append(t)\n\n    tsort(n, g)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\n\nimport queue\n\nWHITE = 0\nGRAY = 1\nBLACK= 2\n\ndef topologicalSort(s):\n    Q.put(s)\n    color[s] = GRAY\n    while not Q.empty():\n        u = Q.get()\n        out.append(u)\n        \n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and color[v] == WHITE:\n                color[v] = GRAY\n                Q.put(v)\n            \n\n\n\nnums=list(map(int,input().split()))\nn = nums[0]\ne = nums[1]\n\ncolor = [WHITE] * n\nG = [[] for i in range(n)]\nindeg = [0] * n\n\nfor i in range(e):\n    nums=list(map(int,input().split()))\n    G[nums[0]].append(nums[1])\n    indeg[nums[1]] += 1\n\nQ = queue.Queue()\nout = []\n\nfor i in range(n):\n    if indeg[i] == 0 and color[i] == WHITE:\n        topologicalSort(i)\n\nfor i in range(n):\n    print(out[i])\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "Vnum = 0\nEnum = 0\nEdge = {}\nL = []\nV = []\n\ndef visit(n):\n    if V[n] == 1:\n        sys.exit()\n    elif V[n] == 0:\n        V[n] = 1\n        if n in Edge.keys():\n            for m in Edge[n]:\n                visit(m)\n        V[n] = 2\n        L.append(n)\n        return True\n\nVnum,Enum = map(int,input().split())\nV = [ 0 for v in range(Vnum) ]\nfor _ in range(Enum):\n    s,t = map(int,input().split())\n    if s in Edge.keys():\n        Edge[s].append(t)\n    else:\n        Edge[s] = [t]\n#print(Edge)\n\nfor n in range(Vnum):\n    if V[n] == 0:\n        visit(n)\n#print(V)\nL.reverse()\nfor a in L:\n    print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys,collections\nV,E = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n#sdw = [[src1 dist1 d1][src1 dist1 d1]...]# vect source1 -> distance1 distances\nINF = float(\"inf\")\n\nst = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(E)) # multi line with multi param\n\nG = [[] for _ in range(V)]\n\nfor s,t in st:\n    G[s].append(t)\n\nvisited = set()\nindeg = [0]*V\nret = []\ndef bfs(s):\n    q = collections.deque([s])\n    visited.add(s)\n    while q:\n        u = q.popleft()\n        ret.append(u)\n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and not v in visited:\n                visited.add(v)\n                q.append(v)\n\ndef topologicalSort_bfs():\n    for a in G:\n        for t in a:\n            indeg[t] += 1\n    #print(G,indeg)\n    for i in range(V):\n        if indeg[i] == 0 and not i in visited:\n            bfs(i)\n\ndef dfs(s):\n    #print(\"s:\",s)\n    if s in visited:\n        return\n    for e in G[s]:\n        dfs(e)\n    ret.append(s)\n    visited.add(s)\n\ndef topologicalSort_dfs():\n    for i in range(V):\n        dfs(i)\n    ret.reverse()\n\ntopologicalSort_bfs()\n#topologicalSort_dfs()\nprint(*ret,sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "nv, ne = map(int, input().split(' '))\nin_degs = [0] * nv\nq = []\nouts = {}\no = []\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n\n    if s in outs: outs[s].append(t)\n    else: outs[s] = [t]\n\n    in_degs[t] += 1\n\nfor i in range(nv):\n    if in_degs[i] == 0: q.append(i)\n\nwhile q:\n    v = q.pop(0)\n    o.append(v)\n\n    if v in outs:\n        for out in outs[v]:\n            in_degs[out] -= 1\n            if in_degs[out] == 0: q.append(out)\n\n[print(v) for v in o]"
  },
  {
    "language": "Python",
    "code": "#https://qiita.com/drken/items/996d80bcae64649a6580 3-3. 二部グラフ判定\nfrom collections import deque\n\n# 頂点数と辺数\nN, M = map(int, input().split())\n\n# グラフ入力受取\nG = [[] for _ in range(N)]\ndeg = [0]*N # 各頂点の出次数\nfor i in range(M):\n    a, b = map(int, input().split())\n    G[b].append(a) # 逆向きに辺を張る\n    deg[a]+=1 # 出次数\n\n# シンクたちをキューに挿入する\nque = deque()\nfor i in range(N):\n    if deg[i] == 0:\n        que.append(i)\n\n# 探索開始\norder = []\nwhile len(que)!=0:\n    # キューから頂点を取り出す\n    v = que.popleft()\n    order.append(v)\n\n    # v へと伸びている頂点たちを探索する\n    for nv in G[v]:\n        # 辺 (nv, v) を削除する\n        deg[nv]-=1\n\n        # それによって nv が新たにシンクになったらキューに挿入\n        if deg[nv] == 0:\n            que.append(nv)\n\n# 答えをひっくり返す\norder.reverse()\nfor i in order:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\ninput = stdin.readline\n\nfrom collections import deque, defaultdict\n\ndef bfs(s):\n    Q.append(s)\n    color[s] = 1\n\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for edge in range(e):\n            s, t = list(map(int, lines[edge+1].split()))\n            if s == u:\n                indeg[t] -= 1\n                if indeg[t] == 0 and color ==0:\n                    color[t] = 1\n                    Q.append(t)\n\n\nlines = stdin.readlines()\n\nv, e = list(map(int, lines[0].split()))\n\nout = []\nouts = defaultdict(list)\n\n\ncolor = [0] * v\nindeg = [0] * v\n\nfor i in range(e):\n    s, t = list(map(int, lines[i+1].split()))\n    outs[s].append(t)\n    indeg[t] += 1\n\nQ = deque(v1 for v1 in range(v) if indeg[v1] == 0)\n\nwhile Q:\n    v1 = Q.popleft()\n    out.append(v1)\n\n    for v2 in outs[v1]:\n        indeg[v2] -= 1\n        if indeg[v2] == 0:\n            Q.append(v2)\n\nfor i in out:\n    print(i)\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n# sts -> start topological sort   \ndef sts():\n    for i in g:\n        for j in i:\n            incnt[j]+=1 \n    for i in range(v):\n        if incnt[i]==0:\n            q.append(i)\n    # Now start deleting elements\n    while q:\n        e=q.popleft()\n        ans.append(e)\n        for i in g[e]:\n            incnt[i]-=1\n            if incnt[i]==0:\n                q.append(i)\n    for i in ans:\n        print(i)\n            \nv,e=map(int,input().split())\ng=[[] for i in range(v)]\n# incnt -> no of indirected edges to a vertex\nincnt=[0]*v\n# q -> queue containing nodes with 0 indirected edges\nq=deque()\n# ans -> topological sorted array\nans=[]\nfor i in range(e):\n    x,y=map(int,input().split())\n    g[x].append(y)\nsts()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport array\nimport heapq\n\n\ndef topological_sort(num_vs, adj_vs):\n    \"\"\" Performs topological sorting of the given DAG.\n\n    This function computes the lexicographically least\n    topological order of the given DAG.\n\n    :param num_vs int: The number of vertices.\n    :param adj_vs list: The adjacency list.\n    :return: The lexicographically least topological order.\n    :rtype: :obj:`array.array`\n    :raises TopologicalSortError: if the given graph is not a DAG\n    \"\"\"\n    in_deg = array.array(\"L\", (0 for _ in range(num_vs)))\n    for dests in adj_vs:\n        for dest in dests:\n            in_deg[dest] += 1\n    sorted_vs = array.array(\"L\")\n    pq = []\n    for s in range(num_vs):\n        if in_deg[s] == 0:\n            heapq.heappush(pq, s)\n    while pq:\n        u = heapq.heappop(pq)\n        sorted_vs.append(u)\n        for v in adj_vs[u]:\n            in_deg[v] -= 1\n            if in_deg[v] == 0:\n                heapq.heappush(pq, v)\n    if all(x == 0 for x in in_deg):\n        return sorted_vs\n    else:\n        raise TopologicalSortError(\"The graph has a cycle\")\n\n\ndef main():\n    v, e = map(int, input().split())\n    adj_vs = [set() for _ in range(v)]\n    for _ in range(e):\n        s, t = map(int, input().split())\n        adj_vs[s].add(t)\n    for u in topological_sort(v, adj_vs):\n        print(u)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\n# トポロジカルソート(頂点数、辺集合(DAG, 0-indexed))\ndef topological_sort(N: int, edges: list) -> list:\n    # ここからトポロジカルソート準備\n    incnts = [0] * N\n    outnodes = [[] for i in range(N)]\n    for i in range(len(edges)):\n        # 流入するノード数\n        incnts[edges[i][1]] += 1\n        # 流出先ノードのリスト\n        outnodes[edges[i][0]].append(edges[i][1])\n    # 流入ノード数が0であるノードのセットS\n    S = set()\n    for i in range(N):\n        if incnts[i] == 0:\n            S.add(i)\n\n    # ここからトポロジカルソート\n    L = []\n    # 暫定セットが空になるまでループ\n    while S:\n        # 暫定セットから結果リストへ1つ入れる\n        L.append(S.pop())\n        # 確定させたノードから流出するノードでループ\n        for node in outnodes[L[-1]]:\n            # 流入ノード数を1減らす\n            incnts[node] -= 1\n            # 流入ノードが0なら暫定セットへ\n            if incnts[node] == 0:\n                S.add(node)\n    # ソートされた頂点のリストを返却\n    return L\n\nN,M=MAP()\nedges=[None]*M\nfor i in range(M):\n    s,t=MAP()\n    edges[i]=(s, t)\n\nans=topological_sort(N, edges)\nfor i in range(N):\n    print(ans[i])\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\n\nV, E = map(int, input().split())\nAdj_list = [[] for _ in range(V)]\nIndeg = [0] * V #??\\?¬???°\nisVisited = [False] * V\nans = []\n\nfor i in range(E):\n    u, v = map(int, input().split())\n    Adj_list[u].append(v)\n    Indeg[v] += 1\n\ndef BFS(u):\n    dq = collections.deque()\n    dq.append(u)\n    isVisited[u] = True\n    \n    while dq:\n        v = dq.popleft()\n        ans.append(v)\n        \n        for s in Adj_list[v]:\n            Indeg[s] -= 1\n            if Indeg[s] == 0 and isVisited[s] != True:\n                isVisited[s] = True\n                dq.append(s)\n    return ans\n\nfor i in range(V):\n    if Indeg[i] == 0 and isVisited[i] != True:\n        BFS(i)\n\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nv,e = map(int,input().split())\nL = []\nins = [0]*v\nDAG = [[] for i in range(v)]\nans = []\nfor i in range(e):\n    a,b = map(int,input().split())\n    DAG[a].append(b)\n    ins[b] += 1\nstart = 0\nS = deque([])\nfor i in range(v):\n    if ins[i] == 0:\n        S.append(i)\nwhile len(S) > 0:\n    cur = S.popleft()\n    ans.append(cur)\n    for e in DAG[cur]:\n        ins[e] -= 1\n        if ins[e] == 0:\n            S.append(e)\nfor i in range(v):\n  print(ans[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nG = [[] for _ in [0]*N]\ndeg = [0]*N\nfor _ in [0]*M:\n    a, b = map(int, input().split())\n    G[a].append(b)\n    deg[b] += 1\n\nq = deque()\n\nfor v, d in enumerate(deg):\n    if d == 0:\n        print(v)\n        q.append(v)\n\nwhile q:\n    v = q.popleft()\n    for u in G[v]:\n        deg[u] -= 1\n        if deg[u] == 0:\n            print(u)\n            q.append(u)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit\nimport queue\nV,E = [int(n) for n in input().split()]\nans = []\n\n# N = int(input())\ngraph = [[] for _ in range(V)]\nindeg = [0]*V\nyet = [True]*V\ndef bfs(s):\n    q = queue.Queue()\n    q.put(s)\n    while(not q.empty()):\n        u = q.get()\n        ans.append(u)\n        yet[u]=False\n        for v in graph[u]:\n            indeg[v]-=1\n            if(indeg[v]==0):\n                q.put(v)\n\nfor i in range(E):\n    s, t = [int(n) for n in input().split()]\n    graph[s].append(t)\n    indeg[t]+=1\nfor i in range(V):\n    if(indeg[i]==0 and yet[i]):\n        bfs(i)\nfor a in ans:\n    print(a)\n# a = [int(input()) for _ in range(N)]\n# S = str(input())\n# L = len(S)\n# T = str(input())\n# exit()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nv, e = map(int, input().split())\nadj = [[] for _ in range( v)]\ninflow = [0] * v\nfor _ in range(e):\n    s, t = map(int, input().split())\n    inflow[t] += 1\n    adj[s].append(t)\n\ndef topological_sort(adj, inflow):\n    is_visited = [False] * len(inflow)\n    res = []\n\n    def bfs(s):\n        #sを始点とする\n        q = deque([s])\n        is_visited[s] = True\n        res.append(s)\n        while q:\n            p = q.popleft()\n          \n            for r in adj[p]:\n                inflow[r] -= 1\n                if (inflow[r] == 0) and (not is_visited[r]):\n                    q.append(r)\n                    is_visited[r] = True\n                    res.append(r)\n\n    for x in range(len(inflow)):\n        if (inflow[x] == 0) and (not is_visited[x]):\n            bfs(x)\n    return res\n\nfor i in topological_sort(adj, inflow):\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from typing import List, Tuple\n\ndef topological_sort(n: int, m: int, G: List[List[int]]) -> List[int]:\n\tfor u in range(n):\n\t\tif color[u] == \"WHITE\":\n\t\t\tdfs(u)\n\treturn L[::-1]\n\ndef dfs(u: int) -> None:\n\tif color[u] == \"GRAY\":\n\t\tprint(\"Graph is not DAG\")\n\t\texit()\n\tif color[u] == \"BLACK\":\n\t\treturn\n\tcolor[u] = \"GRAY\"\n\tfor v in G[u]:\n\t\tdfs(v)\n\tcolor[u] = \"BLACK\"\n\tL.append(u)\n\n\nif __name__ == \"__main__\":\n\tn, m = map(int, input().split())\n\tG = [[] for _ in range(n)]\n\tcolor: List[str] = [\"WHITE\" for _ in range(n)]\n\tL: List[int] = []\n\tfor _ in range(m):\n\t\ts, t = map(int, input().split())\n\t\tG[s].append(t)\n\tL = topological_sort(n, m, G)\n\tfor v in L:\n\t\tprint(v)\n"
  },
  {
    "language": "Python",
    "code": "\nV, E = map(int, input().split())\n\nadjacents = []\n\nfor i in range(V):\n  adjacents.append([])\n\nfor i in range(E):\n  s, t = map(int, input().split())\n  adjacents[t].append(s)\n\ndef topological_sort(num, adjacents):\n  colors = [\"white\"] * num\n  result = []\n\n  def dfs(u):\n    if colors[u] == \"black\":\n      return\n\n    colors[u] = \"black\"\n\n    for a in adjacents[u]:\n      if colors[a] != \"black\":\n        dfs(a)\n\n    result.append(u)\n\n  for n in range(num):\n    dfs(n)\n\n  return result\n\nfor i in topological_sort(V, adjacents):\n  print(i)\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nV, E = map(int, input().split())\n\nG = [[] for _ in range(V)]\nvisited = [False] * V\nindeg = [0] * V\nout = []\n\nfor _ in range(E):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nfor i in range(V):\n    for j in range(len(G[i])):\n        indeg[G[i][j]] += 1\n\nq = queue.Queue()\nfor i in range(V):\n    if indeg[i] == 0 and not visited[i]:\n        q.put(i)\n        visited[i] = True\n        while not q.empty():\n            u = q.get()\n            out.append(u)\n            for j in range(len(G[u])):\n                v = G[u][j]\n                indeg[v] -= 1\n                if indeg[v] == 0 and not visited[v]:\n                    visited[v] = True\n                    q.put(v)\n\nfor el in out:\n    print(el)\n\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\nG = [[] for i in range(n)]\ndeg = [0 for _ in range(n)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    G[b].append(a)\n    deg[a] += 1\n\nfrom collections import deque\nq = deque()\nadd,pop=q.append,q.popleft\nfor i in range(n):\n    if deg[i]==0:\n        add(i)\n\norder = []\nwhile q:\n    v = pop()\n    order.append(v)\n    for nv in G[v]:\n        deg[nv] -= 1\n        if deg[nv] == 0:\n            add(nv)\n\nfor i in order[::-1]:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nV, E = map(int, stdin.readline().split())\nadj_list = [[] for _ in [] * V]\nis_visited = [False] * V\nfor _ in [] * E:\n    s, t = map(int, stdin.readline().split())\n    adj_list[s].append(t)\nout = deque()\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\nprint(*out, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "\n# -*- coding: utf-8 -*-\n# 文字列の入力\nimport math\n\nV,E = map(int ,input().split())\nX = []\n\nfor i in range(E):\n\ts_i, t_i = map(int , input().split())\n\tif(s_i in X):\n\t\tif(t_i in X):\n\t\t\tt = X.index(t_i)\n\t\t\ts = X.index(s_i)\n\t\t\tif(s > t):\n\t\t\t\tX.remove(t_i)\n\t\t\t\tX.insert(s,t_i)\n\t\telse:\n\t\t\tX.append(t_i)\n\telse:\n\t\tif(t_i in X):\n\t\t\tt = X.index(t_i)\n\t\t\tX.insert(t, s_i)\n\t\telse:\n\t\t\tX.append(s_i)\n\t\t\tX.append(t_i)\nfor i in range(V):\n\tprint(X[i])\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\ndef topological_sort(graph):\n    \"\"\"\n    :param list of (list of int) graph:\n    :return:\n    \"\"\"\n    # 入次数\n    ins = [0] * len(graph)\n    for vs in graph:\n        for v in vs:\n            ins[v] += 1\n\n    # 入次数がゼロのやつ\n    zeros = []\n    for v, cnt in enumerate(ins):\n        if cnt == 0:\n            zeros.append(v)\n\n    # 入次数がゼロのやつから順に追加してく\n    ret = []\n    while zeros:\n        v = zeros.pop()\n        ret.append(v)\n        for u in graph[v]:\n            ins[u] -= 1\n            if ins[u] == 0:\n                zeros.append(u)\n    return ret\n\n\nV, E = list(map(int, sys.stdin.readline().split()))\nST = [list(map(int, sys.stdin.readline().split())) for _ in range(E)]\n\ngraph = [[] for _ in range(V)]\nfor s, t in ST:\n    graph[s].append(t)\n\nans = topological_sort(graph)\nprint(*ans, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\ninput:\n6 6\n0 1\n1 2\n3 1\n3 4\n4 5\n5 2\n\noutput:\n0\n3\n1\n4\n5\n2\n\"\"\"\n\nfrom sys import stdin\nfrom collections import deque\n\nUNVISITED, VISITED_IN_QUEUE, POPPED_OUT = 0, 1, 2\n\n\ndef generate_adj_matrix(_v_info):\n    for v_detail in _v_info:\n        v_from, v_to = map(int, v_detail)\n        init_adj_table[v_from].append(v_to)\n        init_in_deg_list[v_to] += 1\n    return init_adj_table, init_in_deg_list\n\n\ndef topological_sort():\n    for v in range(vertices):\n        if not in_deg_list[v] and status[v] is UNVISITED:\n            bfs(v)\n    return ans\n\n\ndef bfs(v):\n    queue = deque()\n\n    queue.append(v)\n    status[v] = VISITED_IN_QUEUE\n\n    while queue:\n        current = queue.popleft()\n        ans.append(current)\n\n        for v_adj in adj_table[current]:\n            in_deg_list[v_adj] -= 1\n            if not in_deg_list[v_adj] and status[v_adj] is UNVISITED:\n                status[v_adj] = VISITED_IN_QUEUE\n                queue.appendleft(v_adj)\n\n        status[current] = POPPED_OUT\n\n    return None\n\n\nif __name__ == '__main__':\n    _input = stdin.readlines()\n    vertices, edges = map(int, _input[0].split())\n    v_info = map(lambda x: x.split(), _input[1:])\n\n    status = [UNVISITED] * vertices\n    init_adj_table = tuple([] for _ in range(vertices))\n    init_in_deg_list = [0] * vertices\n\n    ans = []\n    adj_table, in_deg_list = generate_adj_matrix(v_info)\n    print(*topological_sort(), sep='\\n')"
  },
  {
    "language": "Python",
    "code": "V,E = map(int, input().split())\nadj = [[] for _ in range(V)]\nfor _ in range(E):\n    s,t = map(int, input().split())\n    adj[s].append(t)\n\ncolor = [0 for _ in range(V)]\ntopo = []\n\ndef topo_dfs(s):\n    color[s] = 1\n    if adj[s]:\n        for next in adj[s]:\n            if color[next] == 0:\n                topo_dfs(next)\n    topo.append(s)\n    return\n\nfor i in range(V):\n    if color[i] == 0:\n        topo_dfs(i)\nprint(\"\\n\".join(map(str, topo[::-1])))"
  },
  {
    "language": "Python",
    "code": "def main():\n    nvertices, nedges = map(int, input().split())\n    indegrees = [0 for i in range(nvertices)]\n    adj = [[] for i in range(nvertices)]\n    for i in range(nedges):\n        s, t = map(int, input().split())\n        adj[s].append(t)\n        indegrees[t] += 1\n\n    S = []\n    for i in range(nvertices):\n        if indegrees[i] == 0:\n            S.append(i)\n    ordering = []\n    while S:\n        u = S.pop(0)\n        ordering.append(u)\n        for v in adj[u]:\n            indegrees[v] -= 1\n            if indegrees[v] == 0:\n                S.append(v)\n\n    for v in ordering:\n        print(v)\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nimport collections\ninput = lambda: sys.stdin.buffer.readline()[:-1].decode('utf-8')\nsys.setrecursionlimit(10**8)\ninf = float('inf')\nmod = 10**9+7\n\nans=[]\nV,E = map(int,input().split())\nG=[[] for i in range(V)]\n# div=[0]*V\nfor i in range(E):\n    s,t=map(int,input().split())\n    G[s].append(t)\n#     div[t]+=1\n# used=[0]*V\n\ndef Topological_Sort(G):\n    # DAGの隣接リストを受け取って、トポロジカルソートしたリストを返す\n    V=len(G)\n    div=[0]*V\n    for gi in G:\n        for ei  in gi:\n            div[ei]+=1\n    used=[0]*V\n    result=[]\n\n    def bfs(node):\n        que = collections.deque([node])\n        used[node] = 1\n        while que:\n            tmp = que.popleft()\n            result.append(tmp)\n            for v in G[tmp]:\n                div[v] -= 1\n                if div[v] == 0 and not used[v]:\n                    que.append(v)\n                    used[v] = 1\n\n    for i in range(V):\n        if div[i]==0 and not used[i]:\n            bfs(i)\n    return result\n\n    \nans=Topological_Sort(G)\nprint(*ans,sep=\"\\n\")\n\n# def bfs(node):\n#     que=collections.deque([node])\n#     used[node]=1\n#     while que:\n#         tmp=que.popleft()\n#         ans.append(tmp)\n#         for v in G[tmp]:\n#             div[v]-=1\n#             if div[v]==0 and not used[v]:\n#                 que.append(v)\n#                 used[v]=1\n    \n\n\n\n# for i in range(V):\n#     if div[i]==0 and not used[i]:\n#         bfs(i)\n\n# for a in ans:\n    # print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\n\nif __name__ == '__main__':\n\n    n, m = [int(s) for s in input().split()]\n    E = [set() for _ in range(n)]\n    for _ in range(m):\n        s, t = [int(s) for s in input().split(\" \")]\n        E[s].add(t)\n\n    color = [0] * n\n    indeg = [0] * n\n    for s in range(n):\n        for t in E[s]:\n            indeg[t] += 1\n\n    Q = deque()\n    out = []\n\n    def bfs(s):\n        Q.append(s)\n        color[s] = 1\n        while Q:\n            u = Q.popleft()\n            out.append(u)\n            for v in E[u]:\n                indeg[v] -= 1\n                if indeg[v] == 0 and color[v] == 0:\n                    color[v] = 1\n                    Q.append(v)\n\n    for u in range(n):\n        if indeg[u] == 0 and color[u] == 0:\n            bfs(u)\n\n    print(\"\\n\".join(map(str, out)))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nre = sys.stdin\nvertice, edge = (int(n) for n in re.readline().split(\" \"))\nconnect = defaultdict(list)\nindegree = [0 for n in range(vertice)]\nfor _ in range(edge):\n    s, t = (int(n) for n in re.readline().split(\" \"))\n    connect[s].append(t)\n    indegree[t] += 1\nanswer = []\nzeroin = []\nfor i, n in enumerate(indegree):\n    if n == 0:\n        zeroin.append(i)\nwhile len(zeroin) > 0:\n    next_v = zeroin.pop()\n    indegree[next_v] -= 1\n    answer.append(next_v)\n    for c in connect[next_v]:\n        indegree[c] -= 1\n        if indegree[c] == 0:\n            zeroin.append(c)\nfor a in answer:\n    print(a)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nans = deque()\nV,E = map(int,input().split())\nC = [[] for _ in range(V)]\nfor _ in range(E):\n    tmp = list(map(int,input().split()))\n    C[tmp[0]].append(tmp[1])\n\nvisited = [False]*V\n\n\ndef DFS(node):\n    visited[node] = True\n    for adj in C[node]:\n        if not visited[adj]:\n            DFS(adj)\n    ans.appendleft(node)\n\n\nfor i in range(V):\n    if not visited[i]:\n        DFS(i)\n\n\nfor node in ans:\n    print(node)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport pprint\nfrom queue import Queue\n\n\"\"\"Topological Sort\"\"\"\n\n#fd = os.open('GRL_4_B.txt', os.O_RDONLY)\n#os.dup2(fd, sys.stdin.fileno())\n\nV, E = list(map(int, input().split()))\nG = [[] for i in range(V)]\nindig = [0] * V # ??\\?¬???°\nfor i in range(V):\n    s, t = list(map(int, input().split()))\n    G[s].append(t)\n    indig[t] += 1\n\nq = Queue()\nout = []\n\ndef bfs(node_index):\n    q.put(node_index)\n\n    while not q.empty():\n        u = q.get()\n        out.append(u)\n\n        # u?????????????????§u?????????indig????????????\n        for index in G[u]:\n            indig[index] -= 1\n            if indig[index] == 0:\n                q.put(index)\n\n# bfs?????????\nindig_copy = indig[:]\nfor i in range(V):\n    if indig_copy[i] == 0:\n        bfs(node_index=i)\n\nfor v in out:\n    print(v)"
  },
  {
    "language": "Python",
    "code": "def zadanie_2():\n\n    # n - liczba wierzchołków, m - liczba łuków\n    [n, m] = list(map(int, input().strip().split(\" \")))\n\n    sasiedzi = [[] for _ in range(n)]\n    stopnie = [0 for _ in range(n)]\n    kolejka = []\n    kolejnosc = []\n\n    for i in range(m):\n        luk = list(map(int, input().strip().split(\" \")))\n        sasiedzi[luk[0]].append(luk[1])\n        stopnie[luk[1]] += 1\n\n    for i in range(n):\n        if stopnie[i] == 0:\n            kolejka.append(i)\n\n    while len(kolejka) > 0:\n        wierzcholek = kolejka.pop(0)\n        kolejnosc.append(wierzcholek)\n        for sasiad in sasiedzi[wierzcholek]:\n            stopnie[sasiad] -= 1\n            if stopnie[sasiad] == 0:\n                kolejka.append(sasiad)\n\n    for i in range(len(kolejnosc)):\n        print(str(kolejnosc[i]), end=\"\")\n        if i < len(kolejnosc) - 1:\n            print(\"\")\n\n\nzadanie_2()\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef topological_sort(nodes, edges) -> []:\n    visited = set()\n    result = []\n\n    def dfs(v):\n        if v not in visited:\n            visited.add(v)\n            for u in edges[v]:\n                dfs(u)\n            result.append(v)\n\n    for s in nodes:\n        dfs(s)\n\n    return result\n\ndef aoj_system_test():\n    \"\"\"\n    The problem of aoj for topological sort use special judge.\n    So, I can't verify using online-judge-tools. (T T)\n    \"\"\"\n    V, E = map(int, input().split())\n    nodes = []\n    edges = []\n    for i in range(V):\n        nodes.append(i)\n        edges.append([])\n    for _ in range(E):\n        a, b = map(int, input().split())\n        edges[b].append(a)\n    ret = topological_sort(nodes, edges)\n    for v in ret:\n        print(v)\n\nif __name__ == '__main__':\n    aoj_system_test()\n"
  },
  {
    "language": "Python",
    "code": "V,E=map(int,input().split())\nEDGE=[list(map(int,input().split())) for i in range(E)]\n\n#Tarjanのアルゴリズム\n\nfrom collections import deque\nQUE = deque(list(range(V)))\nEDGEOUTLIST=[[] for i in range(V)]\n\nfor x,y in EDGE:\n    EDGEOUTLIST[x].append(y)\n\ncheck=[0]*V\nTOP_SORT=[]\n\ndef dfs(x):\n    if check[x]==1:\n        return\n    \n    for to in EDGEOUTLIST[x]:\n        if check[to]==0:\n            dfs(to)\n\n    TOP_SORT.append(x)\n    check[x]=1\n\nwhile QUE:\n    x=QUE.pop()\n    dfs(x)\n\nTOP_SORT.reverse()\nfor v in TOP_SORT:\n    print(v)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nV,E = map(int,input().split())\nG = [[] for _ in range(V)]\nreached = [False]*V\nindeg = [0]*V\nfor _ in range(E):\n    s,t = map(int,input().split())\n    G[s].append(t)\n    indeg[t] += 1\nout = []\n\ndef bfs(s):\n    Q = deque()\n    Q.append(s)\n    reached[s] = True\n    while Q:\n        u = Q.popleft()\n        out.append(u)\n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and reached[v] == False:\n                reached[v] = True\n                Q.append(v)\n\ndef topologicalSort():\n    for u in range(V):\n        if indeg[u] == 0 and reached[u] == False: bfs(u)\n\ntopologicalSort()\nfor i in out: print(i)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nV, E = map(int, stdin.readline().split())\nadj_list = [[] for _ in [] * V]\nis_visited = [False] * V\nfor _ in [0] * E:\n    s, t = map(int, stdin.readline().split())\n    adj_list[s].append(t)\nout = deque()\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\nprint(*out, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "def bfs(s):\n    que = [s]\n    used[s] = True\n    while que:\n        u = que.pop(0)\n        ans.append(u)\n\n        for v in G[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and not used[v]:\n                used[v] = True\n                que.append(v)\n\ndef tsort():\n    for u in xrange(V):\n        if indeg[u] == 0 and not used[u]:\n            bfs(u)\n\nV, E = map(int, raw_input().split())\nindeg = [0] * V\nused = [False] * V\nG = [[] for i in xrange(V)]\nans = []\n\nfor i in xrange(E):\n    s, t = map(int, raw_input().split())\n    indeg[t] += 1\n    G[s].append(t)\n\ntsort()\nfor i in ans:\n    print i"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nV, E = map(int, input().split())\n\n#グラフを格納\ng = [[] for _ in range(V)]\n\n#点に入ってくる矢印の数を記録\nin_E = [0 for _ in range(V)]\n\nfor _ in range(E):\n    s, t = map(int, input().split())\n    g[s].append(t)\n    in_E[t] += 1\n\n# print(in_E)\n\nd = deque()\n#in_Eが0をdequeに格納\nfor i in range(V):\n    if in_E[i] == 0:\n        d.append(i)\n\nans = []\n\nwhile d:\n    # print(\"d\", d)\n    v = d.popleft()\n    # print(\"v\", v)\n    # print(\"in_E\", in_E)\n    for u in g[v]:\n        # print(\"u\", u)\n        in_E[u] -= 1\n        if in_E[u] == 0:\n            d.append(u)\n    ans.append(v)\n\nfor i in ans:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_4_B: Path/Cycle - Topological Sort\n\nfrom collections import namedtuple\n\n\nDirectedEdge = namedtuple('DirectedEdge', ('src', 'dest'))\n\n\ndef revert(edge):\n    return edge._replace(src=edge.dest, dest=edge.src)\n\n\nclass Digraph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, edge):\n        self._edges[edge.src].append(edge)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n    def reversed(self):\n        g = self.__class__(self.v)\n        for e in self.edges():\n            g.add(revert(e))\n\n        return g\n\n\ndef sorted_topological(graph):\n    return reversed(list(reverse_post(graph.reversed())))\n\n\ndef reverse_post(graph):\n    def visit(v):\n        if not visited[v]:\n            visited[v] = True\n            return True\n        else:\n            return False\n\n    def leave(v):\n        if not left[v]:\n            left[v] = True\n            vs.append(v)\n        return False\n\n    visited = [False] * graph.v\n    left = [False] * graph.v\n    vs = []\n\n    for i in range(graph.v):\n        if not visited[i]:\n            stack = [(i, leave)]\n            stack.extend((e.dest, visit) for e in graph.adj(i))\n            while stack:\n                v, f = stack.pop()\n                if f(v):\n                    stack.append((v, leave))\n                    for e in graph.adj(v):\n                        stack.append((e.dest, visit))\n    return reversed(vs)\n\n\ndef run():\n    v, e = [int(i) for i in input().split()]\n    g = Digraph(v)\n\n    for _ in range(e):\n        s, t = [int(i) for i in input().split()]\n        g.add(DirectedEdge(s, t))\n\n    for v in sorted_topological(g):\n        print(v)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\nimport pprint\nfrom queue import Queue\n\n\"\"\"Topological Sort\"\"\"\n\n#fd = os.open('GRL_4_B_5.txt', os.O_RDONLY)\n#os.dup2(fd, sys.stdin.fileno())\n\nV, E = list(map(int, input().split()))\nG = [[] for i in range(V)]\nindig = [0] * V # ??\\?¬???°\nfor i in range(E):\n    s, t = list(map(int, input().split()))\n    G[s].append(t)\n    indig[t] += 1\n\nq = Queue()\nout = []\n\ndef bfs(node_index):\n    q.put(node_index)\n\n    while not q.empty():\n        u = q.get()\n        out.append(u)\n\n        # u?????????????????§u?????????indig????????????\n        for index in G[u]:\n            indig[index] -= 1\n            if indig[index] == 0:\n                q.put(index)\n\n# bfs?????????\nindig_copy = indig[:]\nfor i in range(V):\n    if indig_copy[i] == 0:\n        bfs(node_index=i)\n\nfor v in out:\n    print(v)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nn, e = map(int, stdin.readline().split())\nG = [[] for _ in [0] * n]\nindeg = [0] * n\nout = []\nV = [False] * n\ndef bfs(s):\n    dq = deque([s])\n    V[s] = True\n    while dq:\n        u = dq.popleft()\n        out.append(u)\n        for i in range(len(G[u])):\n            v = G[u][i]\n            indeg[v] -= 1\n            if indeg[v] == 0 and not V[v]:\n                V[v] = True\n                dq.append(v)\ndef tsort():\n    for u in range(n):\n        for i in range(len(G[u])):\n            indeg[G[u][i]] += 1\n    for u in range(n):\n        if indeg[u] == 0 and not V[u]:\n            bfs(u)\n    for i in range(len(out)):\n        print(out[i])\nfor _ in [0] * e:\n    s, t = map(int, stdin.readline().split())\n    G[s].append(t)\ntsort()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(int(1e6))\n\nn, m = map(int, input().split())\n\nedges = {}\n\nfor i in range(m):\n    s, t = map(int, input().split())\n    if s not in edges:\n        edges[s] = set()\n    edges[s].add(t)\n\nstack = []\nvisited = set()\n\n\ndef visit(v):\n    if v in visited:\n        return\n    visited.add(v)\n    if v in edges:\n        for t in edges[v]:\n            visit(t)\n    stack.append(v)\n\n\nfor i in range(n):\n    visit(i)\n\nwhile len(stack) > 0:\n    print(stack.pop())\n\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[] for i in range(N)]\nfor i in range(M):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\nans = []\nV = set()\n\ndef dfs(n):\n    for e in G[n]:\n        if e not in V:\n            dfs(e)\n    ans.append(n)\n    V.add(n)\n\n\nfor i in range(N):\n    if i not in V:\n        if i not in V:\n            dfs(i)\n            print()\n\nprint(*ans[::-1], sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "V, E = map(int,input().split())\n\nL = []\nvisited = [0 for i in range(V)]\nedges = [[] for i in range(V)]\nflag = 0\n\ndef visit(x):\n  if visited[x] == 1:\n    flag = 1\n  elif not visited[x]:\n    visited[x] = 1\n    for e in edges[x]:\n      visit(e)\n    visited[x] = 2\n    L.insert(0,x)\n\nfor i in range(E):\n  s, t = map(int,input().split())\n  edges[s].append(t)\n\nfor i in range(V):\n  if not visited[i]:\n    visit(i)\n\nfor i in L:\n  print(i)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit\nimport queue\nV,E = [int(n) for n in input().split()]\nans = []\n\n# N = int(input())\ngraph = [[] for _ in range(E)]\nindeg = [0]*E\nyet = [True]*E\ndef bfs(s):\n    q = queue.Queue()\n    q.put(s)\n    while(not q.empty()):\n        u = q.get()\n        ans.append(u)\n        yet[u]=False\n        for v in graph[u]:\n            indeg[v]-=1\n            if(indeg[v]==0):\n                q.put(v)\n\nfor i in range(E):\n    s, t = [int(n) for n in input().split()]\n    graph[s].append(t)\n    indeg[t]+=1\nfor i in range(E):\n    if(indeg[i]==0 and yet[i]):\n        bfs(i)\nfor a in ans:\n    print(a)\n# a = [int(input()) for _ in range(N)]\n# S = str(input())\n# L = len(S)\n# T = str(input())\n# exit()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\n# 幅優先と深さ優先でトポロジカルソート\ndef set_indeg(u):\n    # t = uとなる数を求める。\n    ans = 0\n    for line in G:\n        if line[u] == 1:\n            ans += 1\n    return ans\n\n\ndef topologicalSortBfs(n):\n    for i in range(n):\n        color[i] = WHITE\n        indeg[i] = set_indeg(i)\n\n    for i in range(0, n):\n        if indeg[i] == 0 and color[i] == WHITE:\n            bfs(i)\n\n\ndef bfs(s):\n    Q.appendleft(s)\n    color[s] = GRAY\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for v in range(n):\n            if G[u][v] != 1:\n                continue\n            indeg[v] -= 1\n            if indeg[v] == 0 and color[v] == WHITE:\n                color[v] = GRAY\n                Q.append(v)\n\n\ndef topologicalSortDfs(n):\n    for i in range(n):\n        color[i] = WHITE\n        indeg[i] = set_indeg(i)\n\n    for s in range(0, n):\n        if color[s] == WHITE:\n            dfs(s)\n\n\ndef dfs(u):\n    color[u] = GRAY\n    for v in range(n):\n        if color[v] == WHITE and G[u][v] == 1:\n            dfs(v)\n    out.appendleft(u)\n\n\nn, e = map(int, input().split())\nG = [[0] * n for _ in range(n)]\nfor i in range(e):\n    s, t = map(int, input().split())\n    G[s][t] = 1\ncolor = [None] * n\nout = deque([])\nindeg = [None] * n\nWHITE = 0\nGRAY = 1\nQ = deque([])\n\ntopologicalSortDfs(n)\nprint(*out)\n# 031452\n# dfsがおかしい\n\n"
  },
  {
    "language": "Python",
    "code": "def input(f):\n    V, E = map(int, f.readline().split())\n    s = [None for _ in range(E)]\n    t = [None for _ in range(E)]\n    for i in range(E):\n        s[i], t[i] = map(int, f.readline().split())\n    return V, E, s, t\n\ndef solve(V, E, s, t):\n    graph = [[] for _ in range(V)]\n    for i in range(E):\n        graph[s[i]].append(t[i])\n    \n    order = []\n    used = [False for _ in range(V)]\n    def visit(cur):\n        if used[cur]:\n            return\n        used[cur] = True\n        for nxt in graph[cur]:\n            visit(nxt)\n        order.append(cur)\n    \n    for i in range(V):\n        visit(i)\n    \n    for v in reversed(order):\n        print(v)\n\nwith open('/dev/stdin') as f:\n    solve(*input(f))\n"
  },
  {
    "language": "Python",
    "code": "def topological_sort(G, revG):\n  n = len(revG)\n  S = set()\n  for u in revG:\n    if len(revG[u]) == 0:\n      S.add(u)\n  L = []\n  while len(S) > 0:\n    u = S.pop()\n    L.append(u)\n    for v in G[u]:\n      revG[v].remove(u)\n      if len(revG[v]) == 0:\n        S.add(v)\n  return L\n\n\nn, m = [int(i) for i in input().strip().split(' ')]\nG = {}\nrevG = {}\nfor i in range(n):\n  G[i] = set()\n  revG[i] = set()\nfor _ in range(m):\n  s, t = [int(i) for i in input().strip().split(' ')]\n  G[s].add(t)\n  revG[t].add(s)\n\n\nL = topological_sort(G, revG)\nfor n in L:\n  print(n)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\n\ndef dfs(u, used, edges, result):\n    used[u] = True\n    for v in edges[u]:\n        if not used[v]:\n            dfs(v, used, edges, result)\n    result.append(u)\n\n\ndef main():\n    N, M = map(int, input().split())\n\n    used = [False] * N\n    edges = defaultdict(list)\n    for _ in range(M):\n        s, t = map(int, input().split())\n        edges[s].append(t)\n\n    result = []\n    for i in range(N):\n        if not used[i]:\n            dfs(i, used, edges, result)\n\n    print(*result[::-1])\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# ????????????????????°???????????°????????????????????\\??????????????¢?????´???????????¨??????????§???????\n\nimport array\nimport collections\n\n\nclass TopologicalSortError(Exception):\n    pass\n\n\ndef topological_sort(num_vs, adj_vs):\n    in_deg = array.array(\"L\", (0 for _ in range(num_vs)))\n    for dests in adj_vs:\n        for dest in dests:\n            in_deg[dest] += 1\n    visited = array.array(\"B\", (False for _ in range(num_vs)))\n    sorted_vs = array.array(\"L\")\n    for s in range(num_vs):\n        if in_deg[s] == 0 and not visited[s]:\n            q = collections.deque()\n            q.append(s)\n            visited[s] = True\n            while q:\n                u = q.popleft()\n                sorted_vs.append(u)\n                for v in adj_vs[u]:\n                    in_deg[v] -= 1\n                    if in_deg[v] == 0 and not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n    if all(x == 0 for x in in_deg):\n        return sorted_vs\n    else:\n        raise TopologicalSortError(\"The graph has a cycle\")\n\n\ndef main():\n    v, e = map(int, input().split())\n    adj_vs = [set() for _ in range(v)]\n    for _ in range(e):\n        s, t = map(int, input().split())\n        adj_vs[s].add(t)\n    for u in topological_sort(v, adj_vs):\n        print(u)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#??±???????????¢?´¢\nimport collections\n\nV, E = map(int, input().split())\nAdj_list = [[] for _ in range(V)]\nisVisited = [False] * V\n\nfor i in range(E):\n    u, v = map(int, input().split())\n    Adj_list[u].append(v)\n\nOut = collections.deque()\n\n\ndef DFS(u):\n    isVisited[u] = True\n    for v in Adj_list[u]:\n        if isVisited[v] != True:\n            DFS(v)\n    Out.appendleft(u)\n\nfor i in range(V):\n    if isVisited[i] != True:\n        DFS(i)\n        \nprint(*Out, sep = '\\n')"
  },
  {
    "language": "Python",
    "code": "def tsort(G):\n    def bfs(s):\n        que = [s]\n        used[s] = True\n        while que:\n            u = que.pop(0)\n            res.append(u)\n\n            for v in G[u]:\n                indeg[v] -= 1\n                if indeg[v] == 0 and not used[v]:\n                    used[v] = True\n                    que.append(v)\n\n    indeg = [0] * V\n    used = [False] * V\n    res = []\n    for u in xrange(V):\n        for v in G[u]:\n            indeg[v] += 1\n    for u in xrange(V):\n        if indeg[u] == 0 and not used[u]:\n            bfs(u)\n    return res\n\n\nV, E = map(int, raw_input().split())\nG = [[] for i in xrange(V)]\nfor i in xrange(E):\n    s, t = map(int, raw_input().split())\n    G[s].append(t)\n\nans = tsort(G)\nfor i in ans:\n    print i"
  },
  {
    "language": "Python",
    "code": "def topologicalSort(g: list, deg: list):\n\tret = []\n\tq = []\n\tfor i, d in enumerate(deg):\n\t\tif not d:\n\t\t\tret.append(i)\n\t\t\tq.append(i)\n\twhile q:\n\t\tcur = q.pop(0)\n\t\tfor nxt in g[cur]:\n\t\t\tdeg[nxt] -= 1\n\t\t\tif not deg[nxt]:\n\t\t\t\tret.append(nxt)\n\t\t\t\tq.append(nxt)\n\treturn ret\n\ndef main():\n\tv, e, *L = map(int, open(0).read().split())\n\tg = [[] for _ in range(v)]\n\tdeg = [0] * v\n\tfor s, t in zip(*[iter(L)] * 2):\n\t\tg[s].append(t)\n\t\tdeg[t] += 1\n\tprint(\"\\n\".join(map(str, topologicalSort(g, deg))))\n\nif __name__ == \"__main__\":\n\tmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nvertice, edge = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nindegree = [0 for n in range(vertice)]\nfor _ in range(edge):\n    s, t = (int(n) for n in input().split(\" \"))\n    connect[s].append(t)\n    indegree[t] += 1\nanswer = []\nzeroin = []\nfor i, n in enumerate(indegree):\n    if n == 0:\n        zeroin.append(i)\nwhile len(zeroin) > 0:\n    next_v = zeroin.pop()\n    indegree[next_v] -= 1\n    answer.append(next_v)\n    for c in connect[next_v]:\n        indegree[c] -= 1\n        if indegree[c] == 0:\n            zeroin.append(c)\nfor a in answer:\n    print(a)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef Topologicalsort():\n    for i in xrange(v):\n        if indeg[i]==0 and color[i]==0:\n            bfs(i)\n\ndef bfs(s):\n    color[s]=2\n    q.append(s)\n    while len(q)>0:\n        i=q.popleft()\n        ans.append(i)\n        for j in m[i]:\n            indeg[j]-=1\n            if indeg[j]==0  and color[j]==0:\n                q.append(j)\n                color[j]=1\n\nv,e=map(int,raw_input().split())\nm=[[]for i in xrange(v)]\nindeg=[0]*v\ncolor=[0]*v\nans=deque()\nq=deque()\nfor i in xrange(e):\n    s,t=map(int,raw_input().split())\n    m[s].append(t)\n    indeg[t]+=1\nTopologicalsort()\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nINF = 10**30\nsys.setrecursionlimit(10000000)\nfrom collections import deque\nG = []\ninto = [] # 入次数\n\n\ndef topological_sort(n):\n    global into\n    ans = []\n    unvisited = [True] * n\n    for i in range(n):\n        if into[i] == 0 and unvisited[i]:\n            q = deque()\n            q.append(i)\n            while len(q) > 0:\n                node = q.popleft()\n                ans.append(node)\n                unvisited[node] = False\n                for v in G[node]:\n                    into[v] -= 1\n                    if into[v] == 0:\n                        q.append(v)\n    return ans\n\nvisited = []\nanswer = deque()\ndef rec(v):\n    global visited\n    visited[v] = True\n\n    for node in G[v]:\n        if not visited[node]:\n            rec(node)\n    answer.appendleft(v)\n\ndef dfs_topolo(n):\n    for i in range(n):\n        if not visited[i]:\n            rec(i)\n\ndef main():\n    global G, into, visited\n    v, e = list(map(int, input().strip().split()))\n    G = [[] for _ in range(v)]\n    visited = [False] * v\n    into = [0] * v\n    for i in range(e):\n        s, t = list(map(int, input().strip().split()))\n        G[s].append(t)\n        into[t] += 1\n    # ans = topological_sort(v)\n    # for p in ans:\n    #     print(p)\n    dfs_topolo(v)\n    for p in answer:\n        print(p)\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_4_B\n# 仕組みは単純ゆえに、本では解説がバッサリ省略されている。操作の可視化を行うと図のようになる。\n# ここでは隣接リストを用いて実装する。\n\nfrom collections import deque\n# 隣接リストはdefaultdictで管理すると楽です。\nfrom collections import defaultdict\nadj = defaultdict(lambda: [])\n\n# input data\nn_V, n_E = list(map(int, input().split()))\nindeg = [0] * n_V  # 流入量管理\nfor _ in range(n_E):\n    s, t = list(map(int, input().split()))\n    indeg[t] += 1  # 流入量更新\n    adj[s].append(t)\n\n\n# Topological Sort by BFS\ndef topological_sort(dag, indeg):\n    '''\n    dag ... default dictで定義された隣接リスト(DAGを想定)\n    indeg ... 各ノードについての流入量のリスト(inputのときについでにやったほうが計算量若干少なく済むでしょ？本質じゃないけど)\n    '''\n    is_visited = [False] * len(indeg)  # 訪問間利用\n    ret = []  # グラフをソートしたあとに返す答え\n    perm = [-1] * len(indeg)  # できる処理を一気にしようとしたときの順番\n\n    que = deque()  # 各要素はノード, 処理回数\n    for i, deg in enumerate(indeg):\n        if deg == 0:\n            que.append((i, 0))\n            is_visited[i] = True\n\n    while que:\n        u, cnt = que.popleft()  # uは流入量0のノード\n        ret.append(u)  # なので答えに加えていく\n        perm[u] = cnt\n        for to in dag[u]:  # uに隣接するノードtoについて深さ優先探索\n            indeg[to] -= 1  # 隣接するノードは流入量を減らす\n            if indeg[to] or is_visited[to]:\n                continue  # 流入待ちか訪問済みだったら飛ばす\n            que.append((to, cnt + 1))  # 次の訪問候補に追加\n            is_visited[to] = True\n\n    if False in is_visited:\n        print(is_visited)\n        raise ValueError('inputted graph is not DAG')\n\n    return ret, perm\n\n\nans, _ = topological_sort(adj, indeg)\nprint(*ans, sep='\\n')\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ndef topological_sort(V, E):\n    '''\n    Kahn's Algorithm (O(|V| + |E|) time)\n    Input:\n    V = [0, 1, ..., N-1]: a list of vertices of the digraph\n    E: the adjacency list of the digraph (dict)\n    Output:\n    If the input digraph is acyclic, then return a topological sorting of the digraph.\n    Else, return None.\n    '''\n    indeg = {v: 0 for v in V}\n    for ends in E.values():\n        for v in ends:\n            indeg[v] += 1\n    \n    q = deque([v for v in V if indeg[v] == 0])\n    top_sorted = []\n    while q:\n        v = q.popleft()\n        top_sorted.append(v)\n        \n        for u in E[v]:\n            indeg[u] -= 1\n            if indeg[u] == 0:\n                q.append(u)\n    if len(top_sorted) == len(V): # The input digraph is acyclic.\n        return top_sorted\n    else: # There is a directed cycle in the digraph.\n        return None\n\nN, M = map(int, input().split())\nV = range(N)\nE = defaultdict(list)\nfor _ in range(M):\n    s, t = map(int, input().split())\n    E[s].append(t)\nprint(*topological_sort(V, E), sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nf_i = sys.stdin\n\nV, E = map(int, f_i.readline().split())\n\nadj_list = [[] for i in range(V)]\n\nis_visited = [False] * V\n\nindeg = [0] * V\n\nfor l_i in f_i:\n    s, t = map(int, l_i.split())\n    adj_list[s].append(t)\n    indeg[t] += 1\n\nimport collections\n\nQ = collections.deque()\nout = collections.deque()\n\n\ndef bfs(s):\n    Q.append(s)\n    is_visited[s] = True\n    while Q:\n        u = Q.popleft()\n\n        out.append(u)\n\n        for v in adj_list[u]:\n            indeg[v] -= 1\n            if indeg[v] == 0 and is_visited[v] == False:\n                is_visited[v] = True\n                Q.append(v)\n\n\n# Topological Sort\nfor u in range(V):\n    if indeg[u] == 0 and is_visited[u] == False:\n        bfs(u)\n\nprint(*out, sep = '\\n')"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef bfs(s):\n  q = deque()\n  q.append(s)\n  while len(q) > 0:\n    u = q.popleft()\n    searched[u] = True\n    res.append(u)\n    for v in adj[u]:\n      indeg[v] -= 1\n      if indeg[v] == 0 and not searched[v]:\n        q.append(v)\n\nV, E = map(int, input().split())\nadj = [[] for i in range(V)]\nindeg = [0 for i in range(V)]\n\nfor i in range(E):\n  u, v = map(int, input().split())\n  adj[u].append(v)\n  indeg[v] += 1\n\nsearched = [False for i in range(V)]\nres = []\n\nfor u in range(V):\n  if indeg[u] == 0 and not searched[u]:\n    bfs(u)\n\nfor u in res:\n  print(u)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nV, E = map(int, stdin.readline().split())\nadj_list = [[] for _ in [0] * V]\nis_visited = [False] * V\nfor _ in [0] * E:\n    s, t = map(int, stdin.readline().split())\n    adj_list[s].append(t)\nout = deque()\ndef dfs(u):\n    is_visited[u] = True\n    for v in adj_list[u]:\n        if not is_visited[v]:\n            dfs(v)\n    out.appendleft(u)\nfor s in range(V):\n    if not is_visited[s]:\n        dfs(s)\nprint(*out, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\ndef Topologicalsort(n):     #n??????????????°\n    start=deque()\n    for i in xrange(n):\n        if indeg[i]==0 :\n            start.append(i)\n    while len(start)>0:\n        i=start.popleft()\n        ans.append(i)\n        for j in g[i]:\n            indeg[j]-=1\n            if indeg[j]==0:\n                start.append(j)\n    return ans\n\nv,e=map(int,raw_input().split())\ng=[[]for i in xrange(v)]\nindeg=[0]*v\nans=[]\nfor i in xrange(e):\n    s,t=map(int,raw_input().split())\n    g[s].append(t)\n    indeg[t]+=1\n    \nans=Topologicalsort(v)\nfor i in ans:\n    print(i)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate, product, combinations_with_replacement\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n\ndef I(): return int(input())\ndef S(): return input()\ndef MI(): return map(int, input().split())\ndef MS(): return map(str, input().split())\ndef LI(): return [int(i) for i in input().split()]\ndef LI_(): return [int(i)-1 for i in input().split()]\ndef StoI(): return [ord(i)-97 for i in input()]\ndef ItoS(nn): return chr(nn+97)\ndef input(): return sys.stdin.readline().rstrip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\nyn = {False: 'No', True: 'Yes'}\nYN = {False: 'NO', True: 'YES'}\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**19\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\nshow_flg = False\n# show_flg = True\n\n\ndef main():\n    V, E = MI()\n    edges = []\n\n    for i in range(E):\n        edges.append(tuple(MI()))\n\n    in_cnt = defaultdict(int)\n    outs = defaultdict(list)\n    for a, b in edges:\n        in_cnt[b] += 1\n        outs[a].append(b)\n\n    res = []\n    queue = deque([i for i in range(V) if in_cnt[i] == 0])\n    while len(queue) != 0:\n        v = queue.popleft()\n        res.append(v)\n        for nxt_v in outs[v]:\n            in_cnt[nxt_v] -= 1\n            if in_cnt[nxt_v] == 0:\n                queue.append(nxt_v)\n\n    for i in range(V):\n        print(res[i])\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nG = [[] for i in range(N)]\nfor i in range(M):\n    s, t = map(int, input().split())\n    G[s].append(t)\n\ndef topological_sort(g):\n    topological_list　= []\n    visited = set()\n\n    def dfs(n):\n        for e in g[n]:\n            if e not in visited:\n                dfs(e)\n        topological_list.append(n)\n        visited.add(n)\n\n    for i in range(len(g)):\n        if i not in visited:\n            dfs(i)\n\n    return topological_list[::-1]\n\n\nprint(*topological_sort(G), sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\n\n#入力⇒V：頂点の数、E：辺の数\nV,E = map(int,input().split())\n#入力⇒s：開始点、e：終了点\nse_list = [list(map(int,input().split())) for _ in range(E)]\n\n#定義⇒{s1:[end1,end2,...],s2:[],...}\ns_dic = {}\n\n#定義⇒[頂点0に入ってくる矢印の数,頂点1に入ってくる矢印の数,.....]\ne_list = [0 for _ in range(V)]\n\n#s_dic,e_listを作成\nfor s,e in se_list:\n    if s in s_dic:\n        s_dic[s].append(e)\n    else:\n        s_dic[s] = [e]\n    e_list[e] += 1\n\n#キューの初期化（入ってくる矢印が0のものをキューに追加）\ndfs_q = deque()\nfor v in range(V):\n    if e_list[v] == 0:\n        dfs_q.append(v)\n\n#トポロジカルソートされた配列（今回の答え）\ntopological_sort = []\n\n#キューがなくなるまで実行\nwhile dfs_q:\n    v_from = dfs_q.pop()\n    topological_sort.append(v_from)\n    if v_from in s_dic:\n        for v_to in s_dic[v_from]:\n            e_list[v_to] -= 1\n            if e_list[v_to] == 0:\n                dfs_q.append(v_to)\n\n#答えの出力\nfor v in topological_sort:\n    print(v)\n"
  },
  {
    "language": "Rust",
    "code": "mod utils {\n    use std::error::Error;\n    use std::io::stdin;\n    use std::str::FromStr;\n\n    #[allow(dead_code)]\n    pub fn read_line<T>() -> Result<Vec<T>, Box<Error>>\n    where\n        T: FromStr,\n        T::Err: 'static + Error,\n    {\n        let mut line = String::new();\n        let _ = stdin().read_line(&mut line)?;\n        let parsed_line = line.split_whitespace()\n            .map(|x| x.parse::<T>())\n            .collect::<Result<Vec<T>, T::Err>>()?;\n\n        Ok(parsed_line)\n    }\n\n    #[allow(dead_code)]\n    pub fn read_lines<T>(n: usize) -> Result<Vec<Vec<T>>, Box<Error>>\n    where\n        T: FromStr,\n        T::Err: 'static + Error,\n    {\n        (0..n).map(|_| read_line()).collect()\n    }\n}\n\ntype NodeId = usize;\nuse std::collections::VecDeque;\n\nstruct TopologicalSort {\n    n_nodes: usize,\n    n_edges: usize,\n    edges: Vec<Vec<usize>>,\n    indegrees: Vec<usize>,\n    outdegrees_list: Vec<Vec<usize>>,\n    colors: Vec<usize>, // WHITE := 1, GRAY := 0\n    result: Vec<NodeId>,\n    queue: VecDeque<usize>,\n}\n\nimpl TopologicalSort {\n    fn sort(&mut self) {\n        for i_node in 0..self.n_nodes {\n            if self.indegrees[i_node] == 0 && self.colors[i_node] == 1 {\n                self.search(i_node);\n            }\n        }\n    }\n\n    fn search(&mut self, i_node: usize) {\n        self.queue.push_back(i_node);\n        self.colors[i_node] = 0;\n\n        while !self.queue.is_empty() {\n            let front = self.queue.pop_front().unwrap();\n            self.result.push(front);\n\n            for &neighbor in &self.outdegrees_list[front] {\n                self.indegrees[neighbor] -= 1;\n\n                if self.indegrees[neighbor] == 0 && self.colors[neighbor] == 1 {\n                    self.colors[neighbor] = 0;\n                    self.queue.push_back(neighbor);\n                }\n            }\n        }\n    }\n}\n\nstruct TopologicalSortBuilder {\n    n_nodes: usize,\n    edges: Vec<Vec<usize>>,\n}\n\nimpl TopologicalSortBuilder {\n    fn new(n_nodes: usize, edges: Vec<Vec<usize>>) -> TopologicalSortBuilder {\n        TopologicalSortBuilder {\n            n_nodes: n_nodes,\n            edges: edges,\n        }\n    }\n\n    fn finalize(self) -> TopologicalSort {\n        let mut indegrees = vec![0 as usize; self.n_nodes];\n        for edge in &self.edges {\n            indegrees[edge[1]] += 1;\n        }\n\n        let mut outdegrees = vec![vec![]; self.n_nodes];\n        for edge in &self.edges {\n            outdegrees[edge[0]].push(edge[1]);\n        }\n\n        TopologicalSort {\n            n_nodes: self.n_nodes,\n            n_edges: self.edges.len(),\n            edges: self.edges,\n            indegrees: indegrees,\n            outdegrees_list: outdegrees,\n            result: Vec::new(),\n            colors: vec![1; self.n_nodes],\n            queue: VecDeque::new(),\n        }\n    }\n}\n\nfn solve() -> Result<(), Box<std::error::Error>> {\n    let header = utils::read_line::<usize>()?;\n    let n_nodes = header[0];\n    let n_edges = header[1];\n    let edges = utils::read_lines::<usize>(n_edges)?;\n\n    let mut tp = TopologicalSortBuilder::new(n_nodes, edges).finalize();\n    tp.sort();\n    for x in tp.result {\n        println!(\"{}\", x);\n    }\n    Ok(())\n}\n\nfn main() {\n    match solve() {\n        Err(err) => panic!(\"{}\", err),\n        _ => (),\n    };\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let (n, m) = get!(usize, usize);\n    let st = get!(usize, usize; m);\n\n    let mut g = vec![Vec::new(); n];\n    let mut g_rev = vec![HashSet::new(); n];\n\n    for (s, t) in st {\n        g[s].push(t);\n        g_rev[t].insert(s);\n    }\n\n    let mut stack: Vec<usize> = (0..n).filter(|&i| g_rev[i].is_empty()).collect();\n    let mut order = Vec::new();\n\n    while let Some(i) = stack.pop() {\n        order.push(i);\n\n        for &to in &g[i] {\n            if g_rev[to].remove(&i) && g_rev[to].is_empty() {\n                stack.push(to);\n            }\n        }\n    }\n\n    util::with_bufwriter(|mut out| {\n        for i in order {\n            writeln!(out, \"{}\", i).unwrap();\n        }\n    });\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(dead_code)]\n\nuse std::thread;\nuse std::io::{ self, Read };\nuse std::fmt;\nuse std::iter::Iterator;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::str::{ self, * };\n\n#[derive(Default)]\nstruct Input {\n    buf: Vec<String>\n}\n\nimpl Input {\n    fn new() -> Input {\n        Input { buf: Vec::new() }\n    }\n\n    fn read<T: FromStr>(&mut self) -> T \n    where <T as FromStr>::Err: fmt::Debug {\n        self.next().unwrap().parse::<T>().unwrap()\n    }\n\n    fn read_n<T: FromStr>(&mut self, n: usize) -> Vec<T>\n    where <T as FromStr>::Err: fmt::Debug {\n        let mut v = Vec::new();\n        for _ in 0..n { v.push(self.read::<T>()); }\n        v\n    }\n}\n\nimpl Iterator for Input {\n    type Item = String;\n    fn next(&mut self) -> Option<String> {\n        while self.buf.is_empty() {\n            let mut s = String::new();\n            let _res = io::stdin().read_line(&mut s);\n            self.buf = s.split_whitespace().map(|s| s.to_owned()).collect::<Vec<_>>();\n            self.buf.reverse();\n        }\n        self.buf.pop()\n    }\n}\n/*\ninput!{n: i64, s: String}\n\nmacro_rules! input_init {\n    () => {\n        let mut _input = Input::new();\n    }\n}\n\nmacro_rules! input {\n    ($var: v : $ty: t) => {\n        let v = t;\n    };\n}\n*/\n\nfn dfs(u: usize, e: &[Vec<usize>], r: &mut Vec<usize>, f: &mut[bool]) {\n    if f[u] { return; }\n    f[u] = true;\n    for v in &e[u] {\n        dfs(*v, e, r, f);\n    }\n    r.push(u);\n}\n\nfn run() {\n    let mut ip = Input::new();\n    let n = ip.read::<usize>();\n    let m = ip.read::<usize>();\n    let mut e = vec![Vec::<usize>::new(); n];\n    for _ in 0..m {\n        let u = ip.read::<usize>();\n        let v = ip.read::<usize>();\n        e[u].push(v);\n    }\n    let mut r = Vec::<usize>::new();\n    let mut f = vec![false; n];\n    for u in 0..n {\n        dfs(u, &e, &mut r, &mut f);\n    }\n    r.reverse();\n    for u in r {\n        println!(\"{}\", u);\n    }\n}\n\nfn main() {\n    let _ = thread::Builder::new()\n        .stack_size(10 * 1024 * 1024)\n        .spawn(run).unwrap()\n        .join();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(dead_code)]\n\nuse std::thread;\nuse std::io::{ self, Read };\nuse std::fmt;\nuse std::iter::Iterator;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::str::*;\n\n#[derive(Default)]\nstruct Input {\n    buf: Vec<String>\n}\n\nimpl Input {\n    fn new() -> Input {\n        Input { buf: Vec::new() }\n    }\n\n    fn read<T: FromStr>(&mut self) -> T \n    where <T as FromStr>::Err: fmt::Debug {\n        self.next().unwrap().parse::<T>().unwrap()\n    }\n\n    fn read_n<T: FromStr>(&mut self, n: usize) -> Vec<T>\n    where <T as FromStr>::Err: fmt::Debug {\n        let mut v = Vec::new();\n        for _ in 0..n { v.push(self.read::<T>()); }\n        v\n    }\n}\n\nimpl Iterator for Input {\n    type Item = String;\n    fn next(&mut self) -> Option<String> {\n        while self.buf.is_empty() {\n            let mut s = String::new();\n            let _res = io::stdin().read_line(&mut s);\n            self.buf = s.split_whitespace().map(|s| s.to_owned()).collect::<Vec<_>>();\n            self.buf.reverse();\n        }\n        self.buf.pop()\n    }\n}\n/*\ninput!{n: i64, s: String}\n\nmacro_rules! input_init {\n    () => {\n        let mut _input = Input::new();\n    }\n}\n\nmacro_rules! input {\n    ($var: v : $ty: t) => {\n        let v = t;\n    };\n}\n*/\n\nfn dfs(u: usize, e: &[Vec<usize>], r: &mut Vec<usize>, f: &mut[bool]) {\n    if f[u] { return; }\n    f[u] = true;\n    for v in &e[u] {\n        dfs(*v, e, r, f);\n    }\n    r.push(u);\n}\n\nfn run() {\n    let mut ip = Input::new();\n    let n = ip.read::<usize>();\n    let m = ip.read::<usize>();\n    let mut e = vec![Vec::<usize>::new(); n];\n    for _ in 0..m {\n        let u = ip.read::<usize>();\n        let v = ip.read::<usize>();\n        e[u].push(v);\n    }\n    let mut r = Vec::<usize>::new();\n    let mut f = vec![false; n];\n    for u in 0..n {\n        dfs(u, &e, &mut r, &mut f);\n    }\n    r.reverse();\n    for u in r {\n        println!(\"{}\", u);\n    }\n}\n\nfn main() {\n    let _ = thread::Builder::new()\n        .stack_size(10 * 1024 * 1024)\n        .spawn(run).unwrap()\n        .join();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// ここまで\n\nuse std::io::Write;\n\nfn run() {\n    input! {\n        n: usize,\n        m: usize,\n        e: [(usize, usize); m],\n    }\n    let mut d = vec![0; n];\n    let mut g = vec![vec![]; n];\n    for (s, t) in e {\n        d[t] += 1;\n        g[s].push(t);\n    }\n    let mut s = vec![];\n    let mut ans = vec![];\n    for (v, &d) in d.iter().enumerate() {\n        if d == 0 {\n            s.push(v);\n        }\n    }\n    while let Some(v) = s.pop() {\n        ans.push(v);\n        for &u in g[v].iter() {\n            d[u] -= 1;\n            if d[u] == 0 {\n                s.push(u);\n            }\n        }\n    }\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for v in ans {\n        writeln!(out, \"{}\", v).unwrap();\n    }\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\nuse std::iter::FromIterator;\nuse std::cmp::max;\n\nfn main() {\n    let cin = stdin();\n    let mut scan = Scanner::new(cin.lock());\n    let v = scan.read::<usize>();\n    let e = scan.read::<usize>();\n    let mut g = vec![vec![];v];\n    for _ in 0..e {\n        let s = scan.read::<usize>();\n        let t = scan.read::<usize>();\n        g[s].push(t);\n    }\n    let mut dag = Dag::new(&g);\n    dag.tsort();\n    for i in 0..v { println!(\"{}\", dag.vs[i]);}\n}\n\nstruct Dag {\n    g: Vec<Vec<usize>>,\n    used: Vec<bool>,\n    vs: Vec<usize>,\n    n: usize\n}\n\n#[allow(dead_code)]\nimpl Dag {\n    fn new(g: &Vec<Vec<usize>>) -> Dag {\n        let n = g.len();\n        Dag {n: n, g: g.clone(), used: vec![false; n], vs: vec![]}\n    }\n\n    fn dfs(&mut self, v: usize) {\n        self.used[v] = true;\n        for m in self.g[v].clone() {\n            if !self.used[m] { self.dfs(m) }\n        }\n        self.vs.push(v);\n    }\n\n    fn tsort(&mut self) {\n        for i in 0..self.n { if !self.used[i] { self.dfs(i) } }\n        self.vs.reverse();\n    }\n\n    fn is_acyclic(&self) -> bool {\n        self.vs.len() == self.n\n    }\n\n    fn longest_path(&self) -> usize {\n        let mut dp = vec![0;self.n];\n        for &p in &self.vs {\n            for &v in &self.g[p] {\n                dp[v] = max(dp[v], dp[p] + 1);\n            }\n        }\n        dp.into_iter().max().unwrap()\n    }\n}\n\n// region template\n#[allow(dead_code)]\nfn iu(i: isize) -> usize { i as usize }\n\n#[allow(dead_code)]\nfn ui(i: usize) -> isize { i as isize }\n\n#[allow(dead_code, deprecated)]\nfn join<T: std::fmt::Display>(slice: &[T], sep: &str) -> String {\n    let strings = slice.iter().map(|t| format!(\"{}\", t)).collect::<Vec<_>>();\n    strings.connect(sep)\n}\n\n#[allow(dead_code)]\nfn arr<'a, S, T>(n: usize, mut f: S) -> Vec<T> where S: FnMut(usize) -> T + 'a {\n    (0..n).map(|i| f(i)).collect::<Vec<T>>()\n}\n\n#[allow(dead_code)]\nfn alt<S, T>(v: Vec<S>) -> T where T: FromIterator<S> {\n    v.into_iter().collect::<T>()\n}\n\n#[allow(dead_code)]\nfn dup<S, T>(v: &[S]) -> T where T: FromIterator<S>, S: Clone {\n    v.iter().cloned().collect::<T>()\n}\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n\n    fn readn<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n        let mut ret = vec![];\n        for _ in 0..n { ret.push(self.read::<T>()) }\n        ret\n    }\n\n    fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n// endregion\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, Read};\nuse std::str::FromStr;\npub struct Scanner<R: Read> {\n    reader: R,\n}\nimpl<R: Read> Scanner<R> {\n    pub fn new(reader: R) -> Scanner<R> {\n        Scanner { reader: reader }\n    }\n    pub fn read<T: FromStr>(&mut self) -> T {\n        let s = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|c| c.expect(\"failed to read char\") as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        s.parse::<T>().ok().expect(\"failed to parse token\")\n    }\n}\n\nuse std::collections::VecDeque;\n\n// 幅優先探索によるトポロジカルソート\nfn toploogical_sort(v_num: usize, edges: &Vec<(usize, usize)>) -> Vec<usize> {\n    let mut result = Vec::with_capacity(v_num);\n    let mut in_num = vec![0; v_num];    // 頂点に対する入力辺の数を表す\n\n    // 入力辺の数を数える\n    for &(_,t) in edges.iter() {\n        in_num[t] += 1;\n    }\n\n    // 入力数0の頂点をQueueに\n    let mut que = VecDeque::new();\n    for i in 0..v_num {\n        if in_num[i] == 0 {\n            que.push_back(i);\n        }\n    }\n\n    // 幅優先探索で入力数0のものから順にresultに追加\n    while let Some(v) = que.pop_front() {\n        result.push(v);\n        // 頂点vから繋がる頂点の入力数を1減らす\n        for &(s,t) in edges.iter() {\n            if s == v {\n                in_num[t] -= 1;\n                // 減らした際に入力数が0となったら、Queueに追加する\n                if in_num[t] == 0 {\n                    que.push_back(t);\n                }\n            }\n        }\n    }\n    result\n}\n\n\nfn main() {\n    let sin = io::stdin();\n    let sin = sin.lock();\n    let mut sc = Scanner::new(sin);\n\n    let v: usize = sc.read();\n    let e: usize = sc.read();\n    let edges: Vec<(usize, usize)> = (0..e)\n        .map(|_| {\n            (sc.read::<usize>(), sc.read::<usize>())\n        }).collect();\n\n    let results = toploogical_sort(v, &edges);\n    \n    for v in results {\n        println!(\"{}\", v);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertexes(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\nimpl Graph {\n    pub fn topological_sort(&self) -> Vec<usize> {\n        let mut indeg = vec![0; self.vsize];\n        let mut res = vec![];\n        for v in self.vertexes().flat_map(|u| self.adjacency(u)) {\n            indeg[v.to] += 1;\n        }\n        let mut stack = self\n            .vertexes()\n            .filter(|&u| indeg[u] == 0)\n            .collect::<Vec<_>>();\n        while let Some(u) = stack.pop() {\n            res.push(u);\n            for v in self.adjacency(u) {\n                indeg[v.to] -= 1;\n                if indeg[v.to] == 0 {\n                    stack.push(v.to);\n                }\n            }\n        }\n        res\n    }\n}\nfn main() {\n    input! { n, m, edges: [(usize, usize); m] };\n    let mut g = Graph::new(n);\n    for &(u, v) in &edges {\n        g.add_edge(u, v);\n    }\n    let vs = g.topological_sort();\n    for v in vs.into_iter() {\n        println!(\"{}\", v);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "mod utils {\n    use std::error::Error;\n    use std::io::stdin;\n    use std::str::FromStr;\n\n    #[allow(dead_code)]\n    pub fn read_line<T>() -> Result<Vec<T>, Box<Error>>\n    where\n        T: FromStr,\n        T::Err: 'static + Error,\n    {\n        let mut line = String::new();\n        let _ = stdin().read_line(&mut line)?;\n        let parsed_line = line.split_whitespace()\n            .map(|x| x.parse::<T>())\n            .collect::<Result<Vec<T>, T::Err>>()?;\n\n        Ok(parsed_line)\n    }\n\n    #[allow(dead_code)]\n    pub fn read_lines<T>(n: usize) -> Result<Vec<Vec<T>>, Box<Error>>\n    where\n        T: FromStr,\n        T::Err: 'static + Error,\n    {\n        (0..n).map(|_| read_line()).collect()\n    }\n}\n\ntype NodeId = usize;\nuse std::collections::VecDeque;\n\nstruct TopologicalSort {\n    n_nodes: usize,\n    n_edges: usize,\n    edges: Vec<Vec<usize>>,\n    indegrees: Vec<usize>,\n    outdegrees_list: Vec<Vec<usize>>,\n    checked: Vec<usize>,\n    result: Vec<NodeId>,\n    queue: VecDeque<usize>,\n}\n\nimpl TopologicalSort {\n    fn sort(&mut self) {\n        for i_node in 0..self.n_nodes {\n            if self.indegrees[i_node] == 0 && self.checked[i_node] == 0 {\n                self.search(i_node);\n            }\n        }\n    }\n\n    fn search(&mut self, i_node: usize) {\n        self.queue.push_back(i_node);\n        self.checked[i_node] = 1;\n\n        while !self.queue.is_empty() {\n            let front = self.queue.pop_front().unwrap();\n            self.result.push(front);\n\n            for &neighbor in &self.outdegrees_list[front] {\n                self.indegrees[neighbor] -= 1;\n\n                if self.indegrees[neighbor] == 0 && self.checked[neighbor] == 0 {\n                    self.checked[neighbor] = 1;\n                    self.queue.push_back(neighbor);\n                }\n            }\n        }\n    }\n}\n\nstruct TopologicalSortBuilder {\n    n_nodes: usize,\n    edges: Vec<Vec<usize>>,\n}\n\nimpl TopologicalSortBuilder {\n    fn new(n_nodes: usize, edges: Vec<Vec<usize>>) -> TopologicalSortBuilder {\n        TopologicalSortBuilder {\n            n_nodes: n_nodes,\n            edges: edges,\n        }\n    }\n\n    fn finalize(self) -> TopologicalSort {\n        let mut indegrees = vec![0 as usize; self.n_nodes];\n        for edge in &self.edges {\n            indegrees[edge[1]] += 1;\n        }\n\n        let mut outdegrees = vec![vec![]; self.n_nodes];\n        for edge in &self.edges {\n            outdegrees[edge[0]].push(edge[1]);\n        }\n\n        TopologicalSort {\n            n_nodes: self.n_nodes,\n            n_edges: self.edges.len(),\n            edges: self.edges,\n            indegrees: indegrees,\n            outdegrees_list: outdegrees,\n            result: Vec::new(),\n            checked: vec![0; self.n_nodes],\n            queue: VecDeque::new(),\n        }\n    }\n}\n\nfn solve() -> Result<(), Box<std::error::Error>> {\n    let header = utils::read_line::<usize>()?;\n    let n_nodes = header[0];\n    let n_edges = header[1];\n    let edges = utils::read_lines::<usize>(n_edges)?;\n\n    let mut tp = TopologicalSortBuilder::new(n_nodes, edges).finalize();\n    tp.sort();\n    for x in tp.result {\n        println!(\"{}\", x);\n    }\n    Ok(())\n}\n\nfn main() {\n    match solve() {\n        Err(err) => panic!(\"{}\", err),\n        _ => (),\n    };\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "fn solve(graph:Vec<Vec<usize>>){\n    let size = graph.len();\n    let mut reached:Vec<_> = vec![false;size];\n    let mut topological = vec![];\n    for i in 0..size{\n        if reached[i]{\n            continue;\n        }\n        let mut stack = vec![];\n        stack.push(i);\n        'dfs: while !stack.is_empty(){\n            let from = *stack.last().unwrap();\n            if !reached[from]{\n                reached[from] = true;\n                // preorder\n            }\n            for &to in &graph[from]{\n                if !reached[to]{\n                    stack.push(to);\n                    continue 'dfs;\n                }\n                // Other operation.\n            }\n            // Postorder\n            let from = stack.pop().unwrap();\n            topological.push(from);\n        }\n    }\n    topological.reverse();\n    for t in topological{\n        println!(\"{}\",t);\n    }\n}\n\nuse std::io::{BufRead, BufReader};\nfn main() {\n    let mut read = BufReader::new(std::io::stdin())\n        .lines()\n        .filter_map(|e| e.ok());\n    let (v, e) = {\n        let line = read.next().unwrap();\n        let line: Vec<&str> = line.split(' ').collect();\n        let v: usize = line[0].parse().unwrap();\n        let e: usize = line[1].parse().unwrap();\n        (v, e)\n    };\n    let graph = {\n        let mut graph: Vec<Vec<_>> = vec![vec![]; v]; // Adj list\n        for _ in 0..e {\n            let edge = read.next().unwrap();\n            let mut edge = edge.split(' ');\n            let start: usize = edge.next().unwrap().parse().unwrap();\n            let end: usize = edge.next().unwrap().parse().unwrap();\n            graph[start].push(end);\n        }\n        graph\n    };\n    solve(graph);\n}\n\n\n"
  }
]