[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ATTRIBUTES 15\n#define MOD 1000000007\n\nint n, m;\nbool compatible[MAX_ATTRIBUTES][MAX_ATTRIBUTES];\nbool used[MAX_ATTRIBUTES];\nlong long dp[1 << MAX_ATTRIBUTES];\n\nlong long countCharacters(int mask) {\n    if (dp[mask] != -1) return dp[mask];\n    \n    dp[mask] = 1;\n    \n    for (int i = 0; i < n; i++) {\n        if (!(mask & (1 << i))) continue;\n        \n        for (int j = i + 1; j < n; j++) {\n            if ((mask & (1 << j)) && !compatible[i][j]) {\n                dp[mask] = 0;\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!(mask & (1 << i))) {\n            bool canAdd = true;\n            for (int j = 0; j < n; j++) {\n                if ((mask & (1 << j)) && !compatible[i][j]) {\n                    canAdd = false;\n                    break;\n                }\n            }\n            \n            if (canAdd) {\n                dp[mask] += countCharacters(mask | (1 << i));\n                dp[mask] %= MOD;\n            }\n        }\n    }\n    \n    return dp[mask];\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    memset(compatible, true, sizeof(compatible));\n    memset(dp, -1, sizeof(dp));\n    \n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        compatible[a-1][b-1] = false;\n        compatible[b-1][a-1] = false;\n    }\n    \n    printf(\"%lld\\n\", countCharacters(0));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 200010\n\ntypedef struct {\n    int parent;\n    int rank;\n} DSU;\n\nDSU dsu[MAXN * 2];\n\nvoid initDSU(int n) {\n    for (int i = 0; i <= n; ++i) {\n        dsu[i].parent = i;\n        dsu[i].rank = 0;\n    }\n}\n\nint find(int u) {\n    if (dsu[u].parent != u) {\n        dsu[u].parent = find(dsu[u].parent);\n    }\n    return dsu[u].parent;\n}\n\nvoid unionSets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (dsu[u].rank < dsu[v].rank) {\n        dsu[u].parent = v;\n    } else {\n        dsu[v].parent = u;\n        if (dsu[u].rank == dsu[v].rank) {\n            dsu[u].rank++;\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    initDSU(2 * n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        unionSets(a, b + n);\n        unionSets(a + n, b);\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) == find(i + n)) {\n            printf(\"0\\n\");\n            return 0;\n        }\n    }\n    int cnt = 0;\n    int visited[MAXN * 2] = {0};\n    for (int i = 1; i <= n; ++i) {\n        int u = find(i);\n        int v = find(i + n);\n        if (!visited[u] && !visited[v]) {\n            cnt++;\n            visited[u] = visited[v] = 1;\n        }\n    }\n    long long res = 1;\n    for (int i = 0; i < cnt; ++i) {\n        res = (res * 2) % MOD;\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nstruct DSU {\n    vector<int> parent;\n    vector<int> size;\n\n    DSU(int n) {\n        parent.resize(n);\n        size.resize(n, 1);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    void unite(int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v) return;\n        if (size[u] < size[v]) swap(u, v);\n        parent[v] = u;\n        size[u] += size[v];\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M;\n    cin >> N >> M;\n\n    DSU dsu(2 * N);\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        dsu.unite(a, b + N);\n        dsu.unite(a + N, b);\n    }\n\n    unordered_set<int> components;\n    for (int i = 0; i < N; ++i) {\n        if (dsu.find(i) == dsu.find(i + N)) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        components.insert(dsu.find(i));\n    }\n\n    long long result = 1;\n    for (int i = 0; i < components.size() / 2; ++i) {\n        result = (result * 2) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    static void union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV) return;\n        if (rank[rootU] > rank[rootV]) {\n            parent[rootV] = rootU;\n        } else if (rank[rootU] < rank[rootV]) {\n            parent[rootU] = rootV;\n        } else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        parent = new int[N + 1];\n        rank = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            union(u, v);\n        }\n\n        Map<Integer, Integer> componentSizes = new HashMap<>();\n        for (int i = 1; i <= N; i++) {\n            int root = find(i);\n            componentSizes.put(root, componentSizes.getOrDefault(root, 0) + 1);\n        }\n\n        long result = 1;\n        for (int size : componentSizes.values()) {\n            result = (result * size) % MOD;\n        }\n\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:46:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int countCharacters(int n, List<List<Integer>> specialPairs) {\n        // Create adjacency list to represent attribute compatibility\n        List<Set<Integer>> graph = new ArrayList<>(n + 1);\n        for (int i = 0; i < n + 1; i++) {\n            graph.add(new HashSet<>());\n        }\n\n        // Build graph of compatible attributes\n        for (List<Integer> pair : specialPairs) {\n            int u = pair.get(0), v = pair.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        // Use bitset to track unique character configurations \n        Set<Integer> uniqueConfigs = new HashSet<>();\n        \n        // Explore all possible character configurations using bitmask\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (isValidConfiguration(mask, graph)) {\n                uniqueConfigs.add(mask);\n            }\n        }\n\n        // Return number of unique configurations modulo MOD\n        return uniqueConfigs.size() % MOD;\n    }\n\n    private boolean isValidConfiguration(int mask, List<Set<Integer>> graph) {\n        for (int i = 0; i < graph.size(); i++) {\n            if ((mask & (1 << i)) != 0) {\n                // Check compatibility for attributes currently in light state\n                for (int j : graph.get(i)) {\n                    if ((mask & (1 << j)) != 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:47:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int characterFormations(int n, vector<vector<int>>& specialPairs) {\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> graph(n);\n        vector<int> indegree(n, 0);\n        \n        for (auto& pair : specialPairs) {\n            graph[pair[0]].push_back(pair[1]);\n            indegree[pair[1]]++;\n        }\n        \n        vector<long long> dp(n, 1);\n        queue<int> q;\n        \n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            \n            for (int next : graph[curr]) {\n                dp[next] = (dp[next] + dp[curr]) % MOD;\n                indegree[next]--;\n                \n                if (indegree[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        \n        long long result = 1;\n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 0) {\n                result = (result * dp[i]) % MOD;\n            }\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 21:47:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1_000_000_007\n\ndef find_parent(x, parent):\n    if parent[x] != x:\n        parent[x] = find_parent(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank):\n    rootX = find_parent(x, parent)\n    rootY = find_parent(y, parent)\n\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef count_essentially_different(n, pairs):\n    parent = list(range(n))\n    rank = [0] * n\n\n    for x, y in pairs:\n        union(x, y, parent, rank)\n\n    root_present = set(find_parent(i, parent) for i in range(n))\n    return len(root_present)\n\n# Example usage\nn = 5  # Number of attributes\nspecial_pairs = [(0, 1), (1, 2), (3, 4)]\nresult = count_essentially_different(n, special_pairs)\nprint(result)  # Output the result",
    "timestamp": "2025-08-13 07:28:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class EverlastingOne {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // number of attributes\n        int m = scanner.nextInt(); // number of special pairs\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        boolean[] visited = new boolean[n];\n        long result = 1;\n\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                int componentSize = dfs(i, adj, visited);\n                result = result * 2 % MOD;\n            }\n        }\n        \n        System.out.println(result);\n    }\n\n    private static int dfs(int node, List<List<Integer>> adj, boolean[] visited) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(node);\n        visited[node] = true;\n        int componentSize = 0;\n\n        while (!stack.isEmpty()) {\n            int current = stack.pop();\n            componentSize++;\n\n            for (int neighbor : adj.get(current)) {\n                if (!visited[neighbor]) {\n                    stack.push(neighbor);\n                    visited[neighbor] = true;\n                }\n            }\n        }\n\n        return componentSize;\n    }\n}",
    "timestamp": "2025-08-13 07:28:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MODULO 1000000007\n\ntypedef struct {\n    int parent;\n    int rank;\n} DisjointSet;\n\nvoid initialize(DisjointSet *ds, int n) {\n    for (int i = 0; i < n; i++) {\n        ds[i].parent = i;\n        ds[i].rank = 0;\n    }\n}\n\nint find(DisjointSet *ds, int x) {\n    if (ds[x].parent != x) {\n        ds[x].parent = find(ds, ds[x].parent);\n    }\n    return ds[x].parent;\n}\n\nvoid unite(DisjointSet *ds, int x, int y) {\n    int rootX = find(ds, x);\n    int rootY = find(ds, y);\n    if (rootX != rootY) {\n        if (ds[rootX].rank < ds[rootY].rank) {\n            ds[rootX].parent = rootY;\n        } else if (ds[rootX].rank > ds[rootY].rank) {\n            ds[rootY].parent = rootX;\n        } else {\n            ds[rootY].parent = rootX;\n            ds[rootX].rank++;\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    DisjointSet *ds = (DisjointSet *)malloc(n * sizeof(DisjointSet));\n    initialize(ds, n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        unite(ds, a, b);\n    }\n\n    int *uniqueRepresentatives = (int *)calloc(n, sizeof(int));\n    int differentCharacters = 0;\n\n    for (int i = 0; i < n; i++) {\n        int representative = find(ds, i);\n        if (!uniqueRepresentatives[representative]) {\n            uniqueRepresentatives[representative] = 1;\n            differentCharacters++;\n        }\n    }\n\n    free(ds);\n    free(uniqueRepresentatives);\n\n    printf(\"%d\\n\", differentCharacters % MODULO);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:28:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def characterCount(self, n, pairs):\n        MOD = 10**9 + 7\n        \n        # Create adjacency list representation of compatible attributes\n        graph = [[] for _ in range(n)]\n        for a, b in pairs:\n            graph[a-1].append(b-1)\n            graph[b-1].append(a-1)\n        \n        # Track visited attributes and current component\n        visited = [False] * n\n        components = []\n        \n        # Depth-first search to find connected components\n        def dfs(node, component):\n            visited[node] = True\n            component.append(node)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, component)\n        \n        # Find all connected components\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                dfs(i, component)\n                components.append(component)\n        \n        # Calculate result using bipartite graph coloring\n        result = 1\n        for component in components:\n            color = [0] * len(component)\n            \n            def color_component(index, current_color):\n                color[index] = current_color\n                for neighbor in graph[component[index]]:\n                    neighbor_index = component.index(neighbor)\n                    if color[neighbor_index] == current_color:\n                        return False\n                    if color[neighbor_index] == 0:\n                        if not color_component(neighbor_index, -current_color):\n                            return False\n                return True\n            \n            is_valid = False\n            for initial_color in [1, -1]:\n                color = [0] * len(component)\n                if color_component(0, initial_color):\n                    is_valid = True\n                    break\n            \n            if not is_valid:\n                return 0\n            \n            result = (result * 2) % MOD\n        \n        return result",
    "timestamp": "2025-08-13 07:29:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    \n    parent = [i for i in range(2 * N + 2)]\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    for _ in range(M):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        # a and b are connected, so a and b+N are in different sets\n        union(a, b + N)\n        union(a + N, b)\n    \n    # Check for contradiction\n    for i in range(1, N + 1):\n        if find(i) == find(i + N):\n            print(0)\n            return\n    \n    # Count the number of unique roots\n    roots = set()\n    for i in range(1, N + 1):\n        roots.add(find(i))\n    \n    answer = pow(2, len(roots) // 2, MOD)\n    print(answer)\n\nsolve()",
    "timestamp": "2025-08-13 07:29:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint find(int x, vector<int>& parent) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x], parent); // Path compression\n    }\n    return parent[x];\n}\n\nvoid unionSets(int x, int y, vector<int>& parent, vector<int>& rank) {\n    int rootX = find(x, parent);\n    int rootY = find(y, parent);\n    \n    if (rootX != rootY) {\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nint countDistinctCharacters(int n, const vector<pair<int, int>>& specialPairs) {\n    vector<int> parent(n);\n    vector<int> rank(n, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n    \n    for (const auto& p : specialPairs) {\n        unionSets(p.first, p.second, parent, rank);\n    }\n    \n    int distinctSets = 0;\n    for (int i = 0; i < n; ++i) {\n        if (find(i, parent) == i) {\n            distinctSets++;\n        }\n    }\n    \n    // Calculate the number of distinct configurations\n    long long result = 1;\n    for (int i = 0; i < distinctSets; ++i) {\n        result = (result * 2) % MOD;\n    }\n    \n    return static_cast<int>(result);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<pair<int, int>> specialPairs(m);\n    \n    for (int i = 0; i < m; ++i) {\n        cin >> specialPairs[i].first >> specialPairs[i].second;\n    }\n    \n    cout << countDistinctCharacters(n, specialPairs) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:48"
  }
]