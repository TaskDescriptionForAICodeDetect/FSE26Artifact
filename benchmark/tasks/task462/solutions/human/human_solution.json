[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n \nint uf[100100], r[100100];\n \nvoid init(int n){\n  rep(i,n)uf[i] = i, r[i] = 0;\n}\n \nint find(int a){\n  if(uf[a] == a)return a;\n  return uf[a] = find(uf[a]);\n}\n \nvoid unite(int a,int b){\n  a = find(a); b = find(b);\n  if(a==b)return;\n  if(r[a] < r[b])uf[a] = b;\n  else{\n    uf[b] = a;\n    if(r[a] == r[b])r[b]++;\n  }\n}\n \nll pow(ll a, ll n){\n  ll res = 1;\n  while(n){\n    if(n&1)(res *= a) %= mod;\n    (a *= a) %= mod; n>>=1;\n  }\n  return res;\n}\n \nint n,m,a,b;\n \nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n \n  while(cin >> n >> m, n){\n    init(n);\n \n    rep(i,m){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n \n    map<int,int> g;\n    rep(i,n)g[find(i)]++;\n     \n    ll ans = pow(2,g.size());\n    if(m>0)ans++, ans%=mod;\n    cout << ans << endl;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,m;\nvvi g;\nvi a;\n\nvoid dfs(int v){\n\ta[v]++;\n\tfor(auto u:g[v]) if(!a[u]) dfs(u);\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n) break;\n\t\tg=vvi(n);\n\t\ta=vi(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v;\n\t\t\tcin>>u>>v;\n\t\t\tu--;v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tint t=1;\n\t\tfor(int i=0;i<n;i++) if(!a[i]) dfs(i),(t*=2)%=mod;\n\t\tcout<<t+(m?1:0)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tll x=1;\n\tper(i,32){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\trep(i,m){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tint one=0; // サイズ1の連結成分の数\n\t\trep(i,n) one+=uf.data[i]==-1;\n\t\tint two=cc-one; // サイズ2以上の連結成分の数\n\t\t\n\t\tll res=ModPow(2,one,MOD);\n\t\tif(two) res=(res*ModPow(2,two,MOD)+1)%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n#define ASSERT(x) { _assert(x); cout << #x << endl; }\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nbool link[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint mark(int num) {\n    if (!link[num]) {\n        link[num] = true;\n        return 1;\n    }\n    return 0;\n}\n\nvoid solve(int n, int m) {\n    fill(link, link+n, false);\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        total += mark(a) + mark(b);\n    }\n    int ans = 0;\n    if (total > 0) {\n        ans = 1 + 2 * power_modulo(2, n - total, MOD_BASE);\n    } else {\n        ans += power_modulo(2, n - total, MOD_BASE);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int long long\n\nint union_tree[200000];\n\nint uf(int now) {\n    if (union_tree[now] == now) return now;\n    return union_tree[now] = uf(union_tree[now]);\n}\nint um(int a, int b) {\n    a = uf(a);\n    b = uf(b);\n    union_tree[a] = b;\n    return 1;\n}\n\nvoid solve() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) return;\n        if (m == 0) {\n            modint now = pows<modint>(modint(2, MAX_MOD), n);\n            cout << now << endl;\n            continue;\n        }\n        REP(i, n) {\n            union_tree[i] = i;\n        }\n        REP(i, m) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            um(a, b);\n        }\n        set<int> cnter;\n        REP(i, n) {\n            cnter.insert(uf(i));\n        }\n        modint now = (modint(1, MAX_MOD) + pows<modint>(modint(2, MAX_MOD), cnter.size()));\n        cout << now << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rank Gacho_0716\n#define M 1000000007\nusing namespace std;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nset<int> memo;\n\nint main(){\n  \n  while(1){\n    \n    int n, m;\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    UF uf = UF(n);\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      a--, b--;\n      uf.unite(a,b);\n    }\n    \n    memo.clear();\n    \n    for(int i=0;i<n;i++) memo.insert(uf.find(i));\n    \n    int x=1, y=1;\n    \n    for(int i=0;i<n;i++) x=x*2%M;\n    \n    for(int i=0;i<memo.size();i++) y=y*2%M;\n\n    cout<<(y%M + (x!=y))%M<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nint backet[100005];\n\nint parent[100005];\nvoid init()\n{\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t}\n}\n\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2) return ((a % mod) * (pow(a, n-1) % mod)) % mod;\n\tllint t = pow(a, n/2);\n\treturn ( (t%mod) * (t%mod) ) % mod;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tinit();\n\t\t\n\t\tint a, b;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> a >> b;\n\t\t\tunite(a, b);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tbacket[i] = 0;\n\t\t\troot(i);\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) backet[parent[i]]++;\n\t\t\n\t\tllint X = 0, Xmul = 0;\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(backet[i]) X++;\n\t\t\tif(backet[i] >= 2) Xmul++;\n\t\t}\n\t\t\n\t\tcout << (Xmul + pow(2, X)) % mod << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nll inf = 1e9+7;\nclass UnionFind{\nprivate:\n    vector<int> p,s;\n\tint cnt;\npublic:\n\tUnionFind(){}\n\tUnionFind(int N){\n\t\tcnt = N;\n\t\tp = s = vector<int>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(p[x]==x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(s[x]>s[y]){\n\t\t\tp[y] = x;\n\t\t\ts[x] += s[y];\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\ts[y] += s[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tbool is_same_set(int x,int y) {return find(x)==find(y);}\n\tint size(int x) {return s[find(x)];}\n\tint compnents_number(){return cnt;}\n};\n\nint N,M;\nint main(){\n\twhile(cin >> N >> M && N>0){\n\t\tvector<ll> p2(N+1,1);\n\t\tvector<int> checked(N+1,0);\n\t\tfor(int i=1;i<=N;i++) p2[i] = 2*p2[i-1]%inf;\n\t\tint a,b;\n\t\tUnionFind uf(N);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin >> a >> b;\n\t\t\tuf.unite(a,b);\n\t\t}\n\t\tll ans = 1,num = 0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(!checked[uf.find(i)]){\n\t\t\t\tchecked[uf.find(i)] = 1;\n\t\t\t\tif(uf.size(i)>=2) num++;\n\t\t\t}\n\t\t}\n\t\tint s = uf.compnents_number();\n\t\tif(s==1) cout << (N==1? 2:3) << endl;\n\t\telse if(s==N) cout << p2[N] << endl;\n\t\telse cout << (p2[s]+1)%inf << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100001\n#define MOD 1000000007\ntypedef long long ll;\n \nint par[MAX],rank[MAX];\n \nvoid init(int N){\n    for(int i = 0 ; i < N ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }\n    return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n\tif(rank[x] == rank[y]){\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return (find(x) == find(y));\n}\n \nll mod_pow(ll x,ll n){\n    if(n == 0) return 1;\n    ll res = mod_pow(x*x%MOD,n/2);\n    if(n & 1) res = res*x%MOD;\n    return res;\n}\n \nint main(){\n    int N,M,a,b;\n    while(cin >> N >> M,N){\n\tinit(N);\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a >> b; a--; b--;\n\t    unite(a,b);\n\t}\n\tll cnt = 0;\n\tbool visited[MAX] = {false};\n\tfor(int i = 0 ; i < N ; i++){\n\t    int x = find(i);\n\t    if(!visited[x]){\n\t\tvisited[x] = true;\n\t\tcnt++;\n\t    }\n\t}\n\tll res = mod_pow(2,cnt);\n\tif(cnt != N) ++res;\n\tcout << res%MOD << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tlong long x=1;\n\tfor(int i=32;i--;){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tconstexpr int MOD=1e9+7;\n\t\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m) && n|m;){\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\twhile(m--){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b); a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tint res=ModPow(2,cc,MOD);\n\t\tif(cc<n) res=(res+1)%MOD;\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nint modPow(int x, int n) {\n  int res = 1;\n  while(n > 0) {\n    if(n&1) (res *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  while(cin >> n >> m, n) {\n    UnionFind uf(n);\n    rep(i, m) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      uf.unite(a, b);\n    }\n    int kind = 0;\n    rep(i, n) kind += (uf.find(i) == i);\n    if(kind == n) cout << modPow(2, kind) << endl;\n    else cout << modPow(2, kind)+1 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n \nint uf[100100], r[100100];\n \nvoid init(int n){\n  rep(i,n)uf[i] = i, r[i] = 0;\n}\n \nint find(int a){\n  if(uf[a] == a)return a;\n  return uf[a] = find(uf[a]);\n}\n \nvoid unite(int a,int b){\n  a = find(a); b = find(b);\n  if(a==b)return;\n  if(r[a] < r[b])uf[a] = b;\n  else{\n    uf[b] = a;\n    if(r[a] == r[b])r[b]++;\n  }\n}\n \nll pow(ll a, ll n){\n  ll res = 1;\n  while(n){\n    if(n&1)(res *= a) %= mod;\n    (a *= a) %= mod; n>>=1;\n  }\n  return res;\n}\n \nint n,m,a,b;\n \nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n \n  while(cin >> n >> m, n){\n    init(n);\n \n    rep(i,m){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n \n    map<int,int> g;\n    rep(i,n)g[find(i)]++;\n     \n    ll ans = pow(2,g.size());\n    if(m>0)ans++;\n    cout << ans%mod << endl;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  while (cin >> n >> m && n + m){\n    UnionFind uf(n);\n\n    int a, b;\n    REP(i, m){\n      cin >> a >> b;\n      uf.unite(a - 1, b - 1);\n    }\n\n    ll res = 1;\n    const ll mod = 1000 * 1000 * 1000 + 7;\n\n    REP(i, uf.count()){\n      res *= 2;\n      res %= mod;\n    }\n    \n    if (m > 0) res = (res + 1) % mod;\n\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n \nint uf[100100], r[100100];\n \nvoid init(int n){\n  rep(i,n)uf[i] = i, r[i] = 0;\n}\n \nint find(int a){\n  if(uf[a] == a)return a;\n  return uf[a] = find(uf[a]);\n}\n \nvoid unite(int a,int b){\n  a = find(a); b = find(b);\n  if(a==b)return;\n  if(r[a] < r[b])uf[a] = b;\n  else{\n    uf[b] = a;\n    if(r[a] == r[b])r[b]++;\n  }\n}\n \nll pow(ll a, ll n){\n  ll res = 1;\n  while(n){\n    if(n&1)(res *= a) %= mod;\n    (a *= a) %= mod; n>>=1;\n  }\n  return res;\n}\n \nint n,m,a,b;\n \nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n \n  while(cin >> n >> m, n){\n    init(n);\n \n    rep(i,m){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n \n    map<int,int> g;\n    rep(i,n)g[find(i)]++;\n     \n    ll ans = pow(2,g.size());\n    if(m>0)ans++;\n    cout << ans%mod << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 1e9+7;\n\nstruct UF{\n    int n;\n    //正だったらその頂点の親,負だったら根で連結成分の個数\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nconst int N = 100010;\nll pw[N];\n\nint main(){\n    pw[0] = 1;\n    rep(i,N-1) pw[i+1] = (pw[i]*2)%mod;\n\n    int n,m;\n    while(scanf(\" %d %d\", &n, &m),n){\n        UF uf(n);\n\n        rep(i,m){\n            int a,b;\n            scanf(\" %d %d\", &a, &b);\n            --a;\n            --b;\n            uf.unite(a,b);\n        }\n\n        int ct = 0;\n        int add = 0;\n        vector<bool> vis(n);\n\n        rep(i,n){\n            int v = uf.root(i);\n            if(vis[v]) continue;\n\n            int sz = uf.size(v);\n            if(sz>1) add = 1;\n            ++ct;\n            vis[v] = true;\n        }\n\n        ll ans = pw[ct];\n        (ans += add) %= mod;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn (a*mypow(a, n / 2) % MOD)*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n, 0);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tint c = 0;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] > 0)c++;\n\t\t}\n\t\tll res = mypow(2, c) % MOD;\n\t\tif (m != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\n#define rank Asdfiasofsad\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,num;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),num(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]) par[x] = y, num[y] += num[x], num[x] = 0;\n    else{\n      par[y]=x, num[x] += num[y], num[y] = 0;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint mod_pow(int x,int y){\n  int res = 1;\n  for(int i=0;i<y;i++) res = res * x % mod;\n  return res;\n}\n\nsigned main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n && !m) break;\n    UF U(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b; a--,b--;\n      U.unite(a,b);\n    }\n  \n    set<int> grp;\n    for(int i=0;i<n;i++) grp.insert(U.find(i));\n    int ans = (mod_pow(2,grp.size()) + ((int)grp.size() != n)) % mod;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M, N) {\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> L >> R;\n\t\t\tL--, R--;\n\t\t\tuf.Unite(L, R);\n\t\t}\n\t\tvector<int>v(N);\n\t\tfor (int i = 0; i < N; i++)v[uf.Find(i)]++;\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (v[i] >= 1)num++;\n\t\t}\n\t\tif (num == N) {\n\t\t\tcout << power(2, N, MOD) << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << power(2, num, MOD) + 1 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        baba[find_baba(b)] = find_baba(a);\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nstruct UnionFind\n{\n  vector< int > data;\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n  int find(int k)\n  {\n    if(data[k] < 0) return(k);\n    return(data[k] = find(data[k]));\n  }\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n};   \nint main()\n{\n  int N, M, power[100001];\n  power[0] = 1;\n  for(int i = 1; i < 100001; i++) {\n    power[i] = 1LL * power[i - 1] * 2 % mod;\n  }\n  while(scanf(\"%d %d\", &N, &M), N) {\n    UnionFind tree(N);\n    for(int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      tree.unite(--x, --y);\n    }\n    int group = 0;\n    for(int i = 0; i < N; i++) {\n      group += tree.find(i) == i;\n    }\n    printf(\"%d\\n\", power[group] + (group != N));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nconstexpr int Mod = 1e9 + 7;\n\nstruct UnionFind {\n\tstd::vector<int> parent;\n\tint size = 0;\n\n\tint root(int x) {\n\t\treturn (parent[x] == x ? x : parent[x] = root(parent[x]));\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y)\n\t\t\treturn;\n\n\t\t--size;\n\t\tparent[y] = x;\n\t}\n\n\tvoid reset(int n) {\n\t\tparent.resize(n);\n\t\tsize = n;\n\t\tstd::iota(parent.begin(), parent.end(), 0);\n\t}\n};\n\nint pow2[100001];\n\nint main() {\n\tpow2[0] = 1;\n\tfor (int i = 1; i < 100001; ++i)\n\t\tpow2[i] = (2 * pow2[i - 1]) % Mod;\n\n\tint n, m;\n\tUnionFind uf;\n\twhile (true) {\n\t\tstd::cin >> n >> m;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\n\t\tuf.reset(n);\n\t\t\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tstd::cin >> a >> b;\n\t\t\t--a, --b;\n\n\t\t\tuf.unite(a, b);\n\t\t}\n\n\t\tint ans = pow2[uf.size];\n\t\tif (uf.size != n)\n\t\t\tans = (ans + 1) % Mod;\n\n\t\tstd::cout << ans << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint a[100001],b[100001];\nvector<int> G[100001];\nint group[100001];\nint gcnt[100001];\n\nvoid dfs(int v,int cnt){\n\tgroup[v]=cnt;\n\tgcnt[cnt]++;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(group[G[v][i]]==-1)dfs(G[v][i],cnt);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tG[a[i]].push_back(b[i]);\n\t\t\tG[b[i]].push_back(a[i]);\n\t\t}\n\t\tmemset(gcnt,0,sizeof(gcnt));\n\t\tmemset(group,-1,sizeof(group));\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(group[i]==-1){\n\t\t\t\tdfs(i,cnt++);\n\t\t\t}\n\t\t}\n\t\tll res=1;\n\t\tbool flag=false;\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(gcnt[i]>1){\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tres=(ll)res*2%mod;\n\t\t}\n\t\tif(flag)res=(res+1)%mod;\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nconst ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nll beki[200000];\nint main() {\n    ll N, M;\n    beki[0] = 1;\n    for(ll i = 1; i <= 1e5; i++) {\n        beki[i] = beki[i-1] * 2 % mod;\n    }\n    while(cin >> N >> M) {\n        if(N == 0) break;\n        UnionFind uni(N);\n        set<ll> st;\n        while(M--) {\n            ll a, b;\n            cin >> a >> b;\n            a--;\n            b--;\n            uni.merge(a, b);\n        }\n        ll ans = 0;\n        ll num = 0;\n        bool two = false;\n        for(int i = 0; i < N; i++) {\n            if(uni.root(i) != i) continue;\n            num++;\n            if(uni.size(i) >= 2) two = true;\n        }\n        ans = beki[num];\n        if(two) ans++;\n        ans %= mod;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tll res = 1;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] == 1)res *= 2;\n\t\t\telse if (cnt[i] > 0)res *= 3;\n\t\t\tres %= MOD;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define HH 100002\n#define MOD 1000000007\n\nint n, m;\nint two[HH];\nbool del[HH];\nint ans;\n\nint mod(int x) {\n\twhile (x < 0)\n\t\tx += MOD;\n\treturn x % MOD;\n}\n\nint parent[HH];\nint find(int x) {\n\treturn x == parent[x] ? x : parent[x] = find(parent[x]);\n}\nvoid merge(int x, int y) {\n\tif (find(x) != find(y))\n\t\tparent[parent[x]] = parent[y];\n}\n\nvoid sol() {\n\tfor (int i = 0; i <= n; i++)\n\t\tparent[i] = i;\n\tint iso = n;\n\n\tint hit = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\n\t\tif ((!del[a] || !del[b]) || (del[a] && del[b] && find(a) != find(b))) {\n\t\t\tiso--;\n\t\t\tmerge(a, b);\n\t\t}\n\n\t\tdel[a] = del[b] = true;\n\t}\n\n\tans = two[iso] + (iso == n ? 0 : 1);\n\tans = mod(ans);\n\tcout << ans << endl;\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tparent[i] = i;\n\t\tdel[i] = false;\n\t}\n}\n\nint main() {\n\ttwo[0] = 1;\n\tfor (int i = 1; i < HH; i++)\n\t\ttwo[i] = (two[i - 1] * 2) % MOD;\n\t\n\twhile (cin >> n >> m && (n || m))\n\t\tsol();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,a,b,ans;\n\nsigned main(){\n  while(cin>>n>>m,n){\n    ans=1;\n    UnionFind U(n);\n    r(i,m){\n      cin>>a>>b;\n      a--;b--;\n      U.unite(a,b);\n    }\n    r(i,n)if(U.find(i)==i)ans=(ans*2)%1000000007;\n    if(m)ans=(ans+1)%1000000007;\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#define ll long long\nusing namespace std;\n\nint n,m;\nconst int mod = 1000000007;\nint cal(int x,int y)\n{\n    int ret = 1;\n    for (int i = 0; i < y; i++)\n        ret = ret * x % mod;\n    return ret;\n}\nint fa[100010];\nint find(int u)\n{\n    if (u == fa[u]) return u;\n    return fa[u] = find(fa[u]);\n}\nint main()\n{\n    while (scanf(\"%d%d\",&n,&m)!=EOF) {\n        if (n == 0 && m == 0) return 0;\n        for (int i = 1; i <= n; i++) fa[i] = i;\n        for (int i = 0; i < m; i++) {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            if (find(u) == find(v)) continue;\n            fa[fa[u]] = fa[v];\n        }\n        int cnt = 0;\n        for (int i = 1; i <= n; i++)\n        if (find(i) == i)\n            cnt++;\n        int ans = 0;\n        if (cnt == n) {\n            ans = cal(2,n);\n        }\n        else\n            ans = (cal(2,cnt) + 1) % mod;\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a){return parent[a]!=a?parent[a]=find(parent[a]):a;}\n\tbool same(int a,int b){return find(a)==find(b);}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n\tint size(int a){return rank[find(a)];}\n};\nint N,M;\nlong mod=1e9+7;\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nmain()\n{\n\twhile(cin>>N>>M,N)\n\t{\n\t\tUF uf(N);\n\t\tint cnt=N;\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint u,v;cin>>u>>v;\n\t\t\tu--,v--;\n\t\t\tif(uf.unite(u,v))cnt--;\n\t\t}\n\t\tlong ans=power(2,cnt);\n\t\tif(M!=0)ans=(ans+1)%mod;\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<vector<lli> > Graph;\nconst lli mod = 1000000007LL;\nconst lli MAXN = 100005;\n\nlli N, M;\nGraph G;\nlli vis[MAXN];\n\nvoid dfs(lli v) {\n  vis[v] = true;\n  for(lli i = 0; i < G[v].size(); ++i) {\n    lli nv = G[v][i];\n    if(!vis[nv]) dfs(nv);\n  }\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    G = Graph(N);\n    for(lli i = 0; i < M; ++i) {\n      lli a, b; cin >> a >> b;\n      --a; --b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    memset(vis, 0, sizeof(vis));\n    lli cnt = 0, res = 1;\n    for(lli i = 0; i < N; ++i) {\n      if(!vis[i]) {\n        dfs(i);\n        ++cnt;\n        res = res * 2LL % mod;\n      }\n    }\n    cout << res + (cnt != N) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define RESET(c,a) memset(c, a, sizeof(c))\n#define REP(a,b,c) for (int a=b, _c=c; a<_c; ++a)\n#define MOD 1000000007LL\n\ntypedef long long ll;\n\nint N, M;\nint par[100005];\nbool counted[100005];\n\nvoid solve();\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (!N && !M) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n\nint findPar(int cur)\n{\n\tif (par[cur] == -1) return cur;\n\treturn par[cur] = findPar(par[cur]);\n}\n\nvoid solve()\n{\n\tRESET(par, -1);\n\tRESET(counted, 0);\n\twhile (M--)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpar[b] = a;\n\t}\n\tint countPar = 0;\n\tREP(x,1,N+1)\n\t{\n\t\tint rootPar = findPar(x);\n\t\tif (!counted[rootPar])\n\t\t{\n\t\t\t++countPar;\n\t\t\tcounted[rootPar] = true;\n\t\t}\n\t}\n\tll ans = 1LL;\n\tREP(x,0,countPar)\n\t{\n\t\tans <<= 1;\n\t\tif (ans > MOD) ans %= MOD;\n\t}\n\tif (countPar < N) ans = (ans+1LL) % MOD;\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\n#define rank Asdfiasofsad\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,num;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),num(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]) par[x] = y, num[y] += num[x], num[x] = 0;\n    else{\n      par[y]=x, num[x] += num[y], num[y] = 0;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint mod_pow(int x,int y){\n  int res = 1;\n  for(int i=0;i<y;i++) res = res * x % mod;\n  return res;\n}\n\nsigned main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n && !m) break;\n    UF U(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b; a--,b--;\n      U.unite(a,b);\n    }\n  \n    set<int> grp;\n    for(int i=0;i<n;i++) grp.insert(U.find(i));\n    int ans = (mod_pow(2,grp.size()) + ((int)grp.size() != n)) % mod;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tll x=1;\n\tper(i,32){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tdump(ModPow(3,5,MOD));\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\trep(i,m){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tint one=0; // サイズ1の連結成分の数\n\t\trep(i,n) one+=uf.data[i]==-1;\n\t\tint two=cc-one; // サイズ2以上の連結成分の数\n\t\t\n\t\tll res=ModPow(2,one,MOD);\n\t\tif(two) res=(res*ModPow(2,two,MOD)+1)%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct UnionFind {\n  vector<ll> par; \n  vector<ll> siz; \n\n    \n  UnionFind(ll sz_): par(sz_), siz(sz_, 1) {\n    for (ll i = 0; i < sz_; ++i) par[i] = i; \n  }\n  void init(ll sz_) {\n    par.resize(sz_);\n    siz.resize(sz_, 1);\n    for (ll i = 0; i < sz_; ++i) par[i] = i;\n  }\n\n  ll root(ll x) { \n    while (par[x] != x) {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(ll x, ll y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (siz[x] < siz[y]) swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(ll x, ll y) {\n    return root(x) == root(y);\n  }\n\n  ll size(ll x) {\n    return siz[root(x)];\n  }\n};\n\nll n, m;\n\nvoid solve() {\n  UnionFind uf(n);\n  while (m--) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n\n    uf.merge(a, b);\n  }\n  ll ans = 1, ok = 0;\n  vector<bool> visited(n, false);\n  rep(i, n) {\n    int v = uf.root(i);\n    if (visited[v]) continue;\n    visited[v] = true;\n    ans = (ans * 2) % mod;\n    if (uf.size(v) > 1) ok = 1;\n  }\n  ans = (ans + ok) % mod;\n  cout << ans << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n >> m, n || m) {\n    solve();\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nstruct UnionFind{\n    int num;\n    vector<int> par,rank;\n    UnionFind(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        return (par[x]==x?x:par[x]=root(par[x]));\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n};\n\nvoid solve(int N,int M){\n    UnionFind uf(N);\n    for (int i=0;i<M;++i){\n        int a,b; cin >> a >> b;\n        uf.merge(--a,--b);\n    }\n    mint ans=pow((mint)2,uf.count());\n    for (int i=0;i<N;++i){\n        if (uf.size(i)>1){\n            ++ans; break;\n        }\n    }\n    cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,M;\n    while(cin >> N >> M,N){\n        solve(N,M);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n#include <cstdint>\n\nnamespace n91 {\n\n  constexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n    using u64 = std::uint_fast64_t;\n    u64 ret = x;\n    for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n      if (x % i == static_cast<u64>(0)) {\n        ret -= ret / i;\n        x /= i;\n        while (x % i == static_cast<u64>(0)) {\n          x /= i;\n        }\n      }\n    }\n    if (x != static_cast<u64>(1)) {\n      ret -= ret / x;\n    }\n    return ret;\n  }\n\n  template <std::uint_fast64_t Modulus,\n    std::uint_fast64_t InverseExp =\n    totient(Modulus) - static_cast<std::uint_fast64_t>(1)>\n    class modint {\n    using u64 = std::uint_fast64_t;\n\n    static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n      \"Modulus must be less than 2**32\");\n\n    u64 a;\n\n    constexpr modint& negate() noexcept {\n      if (a != static_cast<u64>(0)) {\n        a = Modulus - a;\n      }\n      return *this;\n    }\n\n    public:\n      constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n        : a(x% Modulus) {}\n      constexpr u64& value() noexcept { return a; }\n      constexpr const u64& value() const noexcept { return a; }\n      constexpr modint operator+() const noexcept { return modint(*this); }\n      constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n      constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n      }\n      constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n      }\n      constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n      }\n      constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n      }\n      constexpr modint& operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n          a -= Modulus;\n        }\n        return *this;\n      }\n      constexpr modint& operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n          a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n      }\n      constexpr modint& operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n      }\n      constexpr modint& operator/=(modint rhs) noexcept {\n        u64 exp = InverseExp;\n        while (exp) {\n          if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n            *this *= rhs;\n          }\n          rhs *= rhs;\n          exp /= static_cast<u64>(2);\n        }\n        return *this;\n      }\n      constexpr bool operator==(const modint rhs) const noexcept {\n        return a == rhs.a;\n      }\n      constexpr bool operator!=(const modint rhs) const noexcept {\n        return a != rhs.a;\n      }\n  };\n\n  template <class T, std::uint_fast64_t v> class modint_constant {\n  public:\n    static constexpr T value = static_cast<T>(v);\n\n    using value_type = T;\n  };\n\n} // namespace n91\n#include <cassert>\n#include <cstddef>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  class incremental_connectivity {\n  protected:\n    class node_type;\n\n  public:\n    using container_type = std::vector<node_type>;\n    using size_type = typename container_type::size_type;\n    class connected_component {\n      friend incremental_connectivity;\n      const node_type& root;\n      constexpr connected_component(const node_type& root) noexcept\n        : root(root) {}\n\n    public:\n      constexpr size_type representative() const noexcept { return root.parent; }\n      constexpr size_type size() const noexcept { return root.size; }\n      constexpr bool operator==(const connected_component& rhs) const noexcept {\n        return &root == &rhs.root;\n      }\n      constexpr bool operator!=(const connected_component& rhs) const noexcept {\n        return &root != &rhs.root;\n      }\n    };\n\n  protected:\n    class node_type {\n    public:\n      size_type parent, size;\n    };\n    container_type tree;\n\n  public:\n    incremental_connectivity() : tree() {}\n    explicit incremental_connectivity(const size_type size) : tree(size, { 0, 1 }) {\n      for (size_type i = 0; i < size; ++i)\n        tree[i].parent = i;\n    }\n\n    bool empty() const { return tree.empty(); }\n    size_type size() const { return tree.size(); }\n\n    connected_component find_cc(size_type x) {\n      while (tree[x].parent != x) {\n        x = tree[x].parent = tree[tree[x].parent].parent;\n      }\n      return connected_component(tree[x]);\n    }\n\n    std::pair<size_type, size_type> unite(size_type x, size_type y) {\n      assert(x < size());\n      assert(y < size());\n      x = find_cc(x).representative();\n      y = find_cc(y).representative();\n      if (x != y) {\n        if (tree[x].size < tree[y].size)\n          std::swap(x, y);\n        tree[x].size += tree[y].size;\n        tree[y].parent = x;\n      }\n      return { x, y };\n    }\n  };\n\n} // namespace n91\n#include <functional>\n#include <utility>\n\nnamespace n91 {\n\n  template <class T, class U, class Operate = std::multiplies<T>>\n  constexpr T power(T base, U exp, const Operate & oper = Operate(),\n    T iden = static_cast<T>(1)) {\n    while (exp != static_cast<U>(0)) {\n      if (exp % static_cast<U>(2) != static_cast<U>(0)) {\n        iden = oper(iden, base);\n      }\n      exp /= static_cast<U>(2);\n      base = oper(base, base);\n    }\n    return iden;\n  }\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <tuple>\n#include <utility>\n\nnamespace n91 {\n\n  void main_() {\n    using mint = modint<1000000007>;\n    while (true) {\n\n      const usize n{ scan<usize>() };\n      const usize m{ scan<usize>() };\n      if (n == 0) {\n        return;\n      }\n      incremental_connectivity uf(n);\n      usize cnt = n;\n      for (const auto i : rep(0, m)) {\n        usize a{ scan<usize>() - 1 };\n        usize b{ scan<usize>() - 1 };\n        std::tie(a, b) = uf.unite(a, b);\n        if (a != b) {\n          --cnt;\n        }\n      }\n      mint ans = power(static_cast<mint>(2), cnt);\n      if (cnt != n) {\n        ans += static_cast<mint>(1);\n      }\n      std::cout << ans.value() << std::endl;\n    }\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst ll mod=1000000007;\nbool used[nmax];\n\n\n\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b%mod;\n}\n\nint par[nmax],ranks[nmax],sz[nmax];\n\nvoid init(int n){rep(i,n) par[i]=i,ranks[i]=sz[i]=0;}\nint find(int x){return (x==par[x])?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){\n\ta=find(a),b=find(b);\n\tif(ranks[a]<ranks[b])\n\t\tpar[a]=b;\n\telse{\n\t\tpar[b]=a;\n\t\tif(ranks[a]==ranks[b]) ranks[a]++;\n\t}\n\treturn ;\n}\nbool same(int a,int b){return find(a)==find(b);}\n\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(n==0&&m==0) break;\n\t\trep(i,n) used[i]=false;\n\t\tinit(n);\n\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\trep(i,n) sz[find(i)]++;\n\n\t\tif(m==0)\n\t\t\tcout << power(2,n) << endl;\n\t\telse{\n\t\t\tll ans=1LL,num=0,res=0;\n\t\t\trep(i,n){\n\t\t\t\tif(sz[i]>=2)\n\t\t\t\t\tnum++;\n\t\t\t\tif(sz[i]==1)\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t\tans*=power(2,res);\n\t\t\tans%=mod;\n\t\t\tans*=power(2,num);\n\t\t\tans%=mod;\n\t\t\tans=(ans+1)%mod;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    const ll mod=1000000007;\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        if(m==0){\n            cout << mod_pow(2,n) << endl;\n            continue;\n        }\n\n        union_find uf(n);\n\n        set<int> s;\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            --a;\n            --b;\n            uf.unite(a,b);\n            s.insert(a);\n            s.insert(b);\n        }\n        ll ans=1;\n        rep(i,0,n){\n            if(s.find(i)!=s.end()) continue;\n            ans=ans*2%mod;\n        }\n        ans=(ans+n-uf.cnt)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nint n, m;\nvoid solve() {\n\tif (m == 0) {\n\t\tcout << mod_pow(2, n) << endl; return;\n\t\t\n\t}\n\tuf u; u.init(n + 1);\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b;\n\t\tu.unite(a, b);\n\t}\n\tint tmp = 0;\n\trep1(i, n) {\n\t\tif (!u.same(0, i)) {\n\t\t\ttmp++; u.unite(0, i);\n\t\t}\n\t}\n\tll ans = mod_pow(2, tmp) + 1;\n\tcout << ans % mod << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <numeric>\n#include <cstring>\n#include <utility>\n#include <bitset>\n#include <ctime>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > vvint;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef const P &rP;\n\n#define ALL(v) (v).begin(),(v).end()\n\n#define MOD 1000000007LL\n#define INF 1010101010\n\n\nLL powmod(LL x, LL y){\n\tLL a = 1;\n\twhile(y){\n\t\tif(y & 1){ a = a * x % MOD; }\n\t\ty >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn a;\n}\n\n\nstruct UF{\n\tvector<int> par;\n\n\tUF(int n) : par(n + 1){\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\treturn x != par[x] ? par[x] = find(par[x]) : x;\n\t}\n\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){ return false; }\n\t\tif(rand() & 512){ swap(x, y); }\n\t\tpar[x] = y;\n\t\treturn true;\n\t}\n};\n\n\nint main(){\n\tsrand(time(0));\n\t\n\tint n, m, a, b;\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tUF uf(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tuf.unite(a, b);\n\t\t}\n\n\t\tint c = 0;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tif(uf.find(i) == i){ ++c; }\n\t\t}\n\n\t\tLL ans = 0;\n\n\t\tif(c == n){\n\t\t\tans = powmod(2, n);\n\t\t}\n\t\telse{\n\t\t\tans = (powmod(2, c) + 1) % MOD;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst ll mod=1000000007;\n\nll mod_pow(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1) res=res*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        if(m==0){\n            cout << mod_pow(2,n) << endl;\n            continue;\n        }\n\n        vector<pii> ps(m);\n        for(auto& p:ps){\n            cin >> p.first >> p.second;\n            --p.first;\n            --p.second;\n        }\n        sort(ps.begin(),ps.end());\n\n        vector<pii> intervals;\n        ll l=ps[0].first;\n        rep(i,1,m){\n            if(ps[i-1].second!=ps[i].first){\n                intervals.emplace_back(make_pair(l,ps[i-1].second));\n                l=ps[i].first;\n            }\n        }\n        intervals.emplace_back(make_pair(l,ps[m-1].second));\n        sort(intervals.begin(),intervals.end());\n\n        ll ans=0;\n        rep(i,0,intervals.size()){\n            if(i>0) ans=ans*mod_pow(2,intervals[i].first-intervals[i-1].second-1)%mod;\n            ans=(ans+2)%mod;\n        }\n        ans=(ans+1)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst ll mod=1000000007;\nbool used[nmax];\n\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b%mod;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(n==0&&m==0) break;\n\t\trep(i,n) used[i]=false;\n\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tused[a]=true,used[b]=true;\n\t\t}\n\n\t\tif(m==0)\n\t\t\tcout << power(2,n) << endl;\n\t\telse{\n\t\t\tll ans=1LL;\n\t\t\tans+=2*power(2,count(used,used+n,false));\n\t\t\tans%=mod;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\n#define rank Asdfiasofsad\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,num;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),num(V,1){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]) par[x] = y, num[y] += num[x], num[x] = 0;\n    else{\n      par[y]=x, num[x] += num[y], num[y] = 0;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint mod_pow(int x,int y){\n  int res = 1;\n  for(int i=0;i<y;i++) res = res * x % mod;\n  return res;\n}\n\nsigned main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n && !m) break;\n    UF U(n);\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b; a--,b--;\n      U.unite(a,b);\n    }\n  \n    set<int> grp;\n    for(int i=0;i<n;i++) grp.insert(U.find(i));\n    int ans = mod_pow(2,n);\n    for(int g:grp){\n      int num = U.num[g];\n      if(num == 1) continue;\n      int a = mod_pow(2,num) - 3;\n      ans = (ans + mod - a)%mod;\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\nconst long long mod = (1e9) + 7;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N){\n    UnionFind uf(N);\n    for(int i = 0; i < M; ++i){\n      int a, b;\n      cin >> a >> b;\n      --a,--b;\n      uf.unite(a,b);\n    }\n    long long ans = 1;\n    set<int> S;\n    for(int i = 0; i < N; ++i) S.insert(uf.find(i));\n    for(size_t i = 0; i < S.size(); ++i) ans *= 2, ans %= mod;\n    ans += (N != (int)S.size());\n    ans %= mod;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\nint n,parent[100000],mod=1000000007;\nset<int> st;\nvoid init(){\n\tfor(int i=0;i<n;i++) parent[i]=i;\n\tst.clear();\n}\nint find(int id){\n\tif(id==parent[id]) return id;\n\tparent[id]=find(parent[id]);\n\treturn parent[id];\n}\nvoid unite(int a, int b){\n\tif(find(a)==find(b)) return;\n\tparent[find(a)]=find(b);\n\treturn;\n}\nint main(){\n\twhile(true){\n\t\tint m;\n\t\tcin >> n >> m;\n\t\tif(!n) break;\n\t\tinit();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;b--;\n\t\t\tunite(a,b);\n\t\t}\n\t\tfor(int i=0;i<n;i++) st.insert(find(i));\n\t\tlong long ans=1;\n\t\tfor(int i=0;i<st.size();i++){\n\t\t\tans*=2;\n\t\t\tans%=mod;\n\t\t}\n\t\tif(m!=0){\n\t\t\tans++;\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst ll mod = 1e9+7;\n\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nll power(ll x, ll n) {\n\tll res = 1;\n\tfor (ll i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) {\n\t\t\tres = mul(res, x);\n\t\t}\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tset<int> s;\n\t\tREP(i, M) {\n\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint scnt = (int)s.size();\n\t\tll ans = power(2, N-scnt);\n\t\tif (scnt > 0) {\n\t\t\tans = mul(ans, 2);\n\t\t\tans = add(ans, 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct UnionFind {\n    vector<int> data;\n    int size;\n    UnionFind(int N) : \n        data(N, -1), size(N) {}\n    int root(int x){\n        if(data[x] < 0) return x;\n        return data[x] = root(data[x]);\n    }\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(-data[x] < -data[y]) swap(x, y);\n        size--;\n        data[x] += data[y];\n        data[y] = x;\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N, M;\n    while(cin >> N >> M && N > 0){\n        UnionFind uf(N);\n        REP(i, M){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            uf.unite(a, b);\n        }\n        int s = uf.size;\n        int ans = 1;\n        REP(i, s) ans = (2LL * ans) % MOD;\n        if(s < N) {\n            ans = (ans + 1) % MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100001\n#define MOD 1000000007\ntypedef long long ll;\n \nint par[MAX],rank[MAX];\n \nvoid init(int N){\n    for(int i = 0 ; i < N ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }\n    return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n\tif(rank[x] == rank[y]){\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return (find(x) == find(y));\n}\n \nll mod_pow(ll x,ll n){\n    if(n == 0) return 1;\n    ll res = mod_pow(x*x%MOD,n/2);\n    if(n & 1) res = res*x%MOD;\n    return res;\n}\n \nint main(){\n    int N,M,a,b;\n    while(cin >> N >> M,N){\n\tinit(N);\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a >> b; a--; b--;\n\t    unite(a,b);\n\t}\n\tll cnt = 0;\n\tbool visited[MAX] = {false};\n\tfor(int i = 0 ; i < N ; i++){\n\t    int x = find(i);\n\t    if(!visited[x]){\n\t\tvisited[x] = true;\n\t\tcnt++;\n\t    }\n\t}\n\tll res = mod_pow(2,cnt);\n\tif(cnt != N) ++res;\n\tcout << res%MOD << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\n//end of lib\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tunionfind uf(n);\n\t\tint g = 0;\n\t\trep(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (!uf.same(a, b)) {\n\t\t\t\tg++;\n\t\t\t\tuf.unite(a, b);\n\t\t\t}\n\t\t}\n\t\tif (g == 0)cout << pow(2, n, mod) << endl;\n\t\telse if (g == n - 1)cout << 3 << endl;\n\t\telse cout << (pow(2, n - g, mod) + 1) % mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst ll mod=1000000007;\n\nll mod_pow(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1) res=res*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=0;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n        if(rank[x]==0 and rank[y]==0) ++cnt;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        union_find uf(n);\n        set<int> s;\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            --a;\n            --b;\n            uf.unite(a,b);\n            s.insert(a);\n            s.insert(b);\n        }\n        ll ans=1;\n        rep(i,0,n){\n            if(s.find(i)!=s.end()) continue;\n            ans=ans*2%mod;\n        }\n        ans=ans*mod_pow(2,uf.cnt)%mod;\n        if(uf.cnt>0) ans=(ans+1)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tUnionFind uni(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tuni.unionSet(a, b);\n\t\t}\n\t\tset<int>roots;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\troots.emplace(uni.root(i));\n\n\t\t}\n\t\tMod ans(1);\n\t\tfor (auto r : roots) {\n\t\t\tans *= uni.size(r) == 1 ? 2 : 3;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100001\n#define MOD 1000000007\ntypedef long long ll;\n \nint par[MAX],rank[MAX];\n \nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n \nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n \nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y){ return; }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n \nbool same(int x,int y){\n  return (find(x) == find(y));\n}\n \nll mod_pow(ll x,ll n){\n  if(n == 0){ return 1; }\n  ll res = mod_pow(x*x%MOD,n/2);\n  if(n & 1){ res = res*x%MOD; }\n  return res;\n}\n \nint main(){\n  int N,M,a,b;\n  while(cin >> N >> M,N){\n    init(N);\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n    ll cnt = 0;\n    bool visited[MAX] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int x = find(i);\n      if(!visited[x]){\n        visited[x] = true;\n        cnt++;\n      }\n    }\n    ll res = mod_pow(2,cnt);\n    if(cnt != N){ ++res; }\n    cout << res%MOD << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, m;\nUF uf;\n\nvoid solve(){\n\tuf.init(n);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tuf.unite(a,b);\n\t}\n\tlong long ans = 1;\n\trep(i,n){\n\t\tif(uf.par[i] != i) continue;\n\t\tif(uf.rank[i] > 0) ans *= 3;\n\t\telse ans *= 2;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin>>n >> m ){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,a,b,ans;\nvector<int>v;\n\nsigned main(){\n  while(cin>>n>>m,n){\n    ans=0;\n    v.clear();\n    UnionFind U(n);\n    r(i,m){\n      cin>>a>>b;\n      a--;b--;\n      U.unite(a,b);\n    }\n    r(i,n)if(U.find(i)==i){\n      if(U.sum(i)>1)v.push_back(U.sum(i));\n    }\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++){\n      int res=v[i];\n      for(int j=i+1;j<v.size();j++) res=(res*v[i])%1000000007;\n      ans+=res;\n    }\n    if(ans)cout<<ans<<endl;\n    else{\n      ans=1;\n      r(i,n)ans=(ans*2)%1000000007;\n      cout<<ans<<endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) { parent.assign(n, -1); }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nconst int MOD = 1000000007;\n\nint p2(int n){\n  if(n==0) return 1;\n  else return (p2(n-1)*2)%MOD;\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    UnionFind uf(n);\n    REP(i,m){\n      int a,b;\n      cin>>a>>b;\n      --a;--b;\n      uf.merge(a,b);\n    }\n    set<int> s;\n    REP(i,n) s.insert(uf.root(i));\n    if(s.size()==n){\n      cout<<p2(n)<<endl;\n    }else{\n      int p=p2(s.size())+1;\n      p%=MOD;\n      cout<<p<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nint p[100001];\nint r[100001];\nvoid init() {\n  for(int i=0; i<100001; i++) {\n    p[i]=i;\n    r[i]=0;\n  }\n}\nint find(int x) {\n  if(p[x]==x) return x;\n  else return p[x]=find(p[x]);\n}\nvoid unite(int x,int y) {\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n\n  if(r[x]<r[y]) p[x]=y;\n  else {\n    p[y]=x;\n    if(r[x]==r[y]) r[x]++;\n  }\n}\nbool same(int x, int y) {\n  return find(x)==find(y);\n}\n\nll mod_pow(ll x,ll n,ll mod){\n  if(n == 0) return 1;\n  ll res = mod_pow(x * x % mod,n / 2,mod);\n  if(n & 1) res = res * x % mod;\n  return res;\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    init();\n    rep(i,m) {\n      int x,y;\n      cin >> x >> y;\n      unite(x,y);\n    }\n    set<int> s;\n    REP(i,1,n+1) s.insert(find(i));\n    cout << (mod_pow(2,s.size(),MAX)+(m?1:0))%MAX << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        baba[find_baba(b)] = find_baba(a);\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    const ll mod=1000000007;\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        union_find uf(n);\n\n        set<int> s;\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            --a;\n            --b;\n            uf.unite(a,b);\n            s.insert(a);\n            s.insert(b);\n        }\n        ll ans=1;\n        rep(i,0,n){\n            if(s.find(i)!=s.end()) continue;\n            ans=ans*2%mod;\n        }\n        ans=(ans+n-uf.cnt)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst ll mod=1000000007;\nbool used[nmax];\n\n\n\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b%mod;\n}\n\nint par[nmax],ranks[nmax],sz[nmax];\n\nvoid init(){rep(i,nmax) par[i]=i,ranks[i]=sz[i]=0;}\nint find(int x){return (x==par[x])?x:find(par[x]);}\nvoid unite(int a,int b){\n\ta=find(a),b=find(b);\n\tif(ranks[a]<ranks[b])\n\t\tpar[b]=a;\n\telse{\n\t\tpar[a]=b;\n\t\tif(ranks[a]==ranks[b]) ranks[a]++;\n\t}\n\treturn ;\n}\nbool same(int a,int b){return find(a)==find(b);}\n\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(n==0&&m==0) break;\n\t\trep(i,n) used[i]=false;\n\t\tinit();\n\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\trep(i,n) sz[find(i)]++;\n\n\t\tif(m==0)\n\t\t\tcout << power(2,n) << endl;\n\t\telse{\n\t\t\tll ans=1LL,num=0,res=0;\n\t\t\trep(i,n){\n\t\t\t\tif(sz[i]>=2)\n\t\t\t\t\tnum++;\n\t\t\t\tif(sz[i]==1)\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t\tans*=power(2,res);\n\t\t\tans%=mod;\n\t\t\tans*=power(2,num);\n\t\t\tans%=mod;\n\t\t\tans=(ans+1)%mod;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tuf.unionSet(a, b);\n\t\t}\n\t\tMod ans(1);\n\t\tbool kake3 = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (uf.size(i) >= 2) {\n\t\t\t\tkake3 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 2;\n\t\t\t}\n\t\t}\n\t\tif (kake3) {\n\t\t\tans = ans * 2 + 1ll;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD =  1e9+7;\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nLL powM(LL a, LL b){\n  if(b == 0) return 1;\n  return powM(a*a%MOD,b/2) * (b&1? a: 1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tUnionFind uf(N);\n\tvector<PII> special(M);\n\tREP(i,M) cin >> special[i].first >> special[i].second;\n\tREP(i,M) uf.unite(special[i].first-1, special[i].second-1);\n\n\tVI vis(N, 0);\n\tREP(i,N) vis[uf.find(i)]++;\n\tLL ans = 1, cnt = 0;\n\tREP(i,N){\n\t  if(uf.find(i) == i)\n\t\tans = ans * 2 % MOD, ++cnt;\n\t}\n\tif(cnt < N) ++ans;\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tuf.unionSet(a, b);\n\t\t}\n\t\tMod ans(1);\n\t\tbool kake3 = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (uf.size(i) >= 2) {\n\t\t\t\tkake3 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 2;\n\t\t\t}\n\t\t}\n\t\tif (kake3) {\n\t\t\tans = ans * 2 + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<numeric>\n\nusing namespace std;\n\nint par[123456];\n\nint find(int x){\n  return (x==par[x])?x:find(par[x]);\n}\n\nvoid unite(int a,int b){\n  par[find(a)]=find(b);\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N|M;){\n    iota(begin(par),end(par),0);\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;\n      b--;\n      unite(a,b);\n    }\n    set<int> s;\n    for(int i=0;i<N;i++){\n      s.insert(find(i));\n    }\n    int ans=1;\n    for(int i=0;i<s.size();i++){\n      ans=(ans*2)%1000000007;\n    }\n    cout<<(ans+!!M)%1000000007<<endl;\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept {\n        lint v;\n        is >> v;\n        x = v;\n        return is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nstruct UnionFind {\n    std::vector<int> par, sz;\n    int gnum;\n\n    explicit UnionFind(int n)\n        : par(n), sz(n, 1), gnum(n) {\n        std::iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return (par[v] == v) ? v : (par[v] = find(par[v]));\n    }\n\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n\n        if (sz[u] < sz[v]) std::swap(u, v);\n        sz[u] += sz[v];\n        par[v] = u;\n        --gnum;\n    }\n\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool ispar(int v) { return v == find(v); }\n    int size(int v) { return sz[find(v)]; }\n};\n\nconstexpr int MOD = 1000000007;\nusing mint = ModInt<MOD>;\n\nbool solve() {\n    int n, m;\n    std::cin >> n >> m;\n    if (n == 0) return false;\n\n    UnionFind uf(n);\n    while (m--) {\n        int u, v;\n        std::cin >> u >> v;\n        uf.unite(--u, --v);\n    }\n\n    mint ans = mint(2).pow(uf.gnum);\n    if (uf.gnum < n) ans += 1;\n\n    std::cout << ans << \"\\n\";\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007;\nll mod_pow(ll n, ll k) {\n  ll ret = 1;\n  for(; k>0; k>>=1) {\n    if(k & 1) (ret *= n) %= MOD;\n    (n *= n) %= MOD;\n  }\n  return ret;\n}\n\nconst int S = 100010;\nstruct UnionFind {\n  vector<int> node;\n  int size_;\n  UnionFind(int n) {\n    node.resize(n, -1);\n    size_ = n;\n  }\n  void reset() {\n    fill(node.begin(), node.end(), -1);\n  }\n  int find(int x) {\n    return node[x] < 0 ? x : node[x] = find(node[x]);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    size_--;\n    node[x] += node[y];\n    node[y] = x;\n    return true;\n  }\n  int size() {\n    return size_;\n  }\n};\n  \nint main() {\n  ll N, M;\n  while(cin >> N >> M, N || M) {\n    UnionFind uf(N);\n    for(int i=0; i<M; i++) {\n      int a, b; cin >> a >> b;\n      a--; b--;\n      uf.unite(a, b);\n    }\n\n    int ans = mod_pow(2, uf.size());\n    if(uf.size() != N) ans++;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tunionfind uf(n);\n\t\tint g = 0;\n\t\trep(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (!uf.same(a, b)) {\n\t\t\t\tg++;\n\t\t\t\tuf.unite(a, b);\n\t\t\t}\n\t\t}\n\t\tif (g == 0)cout << pow(2, n, mod) << endl;\n\t\telse if (g == n)cout << 1 << endl;\n\t\telse cout << 3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <stack>\n#include <bitset>\n#define maxn 100009\nusing namespace std;\nconst int MOD=1e9+7;\nint p[maxn];\nlong long bin[maxn];\nint findset(int x)\n{\n\treturn x==p[x]?x:p[x]=findset(p[x]);\n}\nvoid unionset(int x,int y)\n{\n\t p[findset(x)]=findset(y);\n}\nint main()\n{\n\tint n,m,x,y;\n\tbin[0]=1;\n\tfor(int i=1;i<maxn;i++)\n\t\tbin[i]=2*bin[i-1]%MOD;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF&&n+m)\n\t{\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tp[i]=i;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tunionset(x,y);\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(p[i]==i)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tint ans=bin[cnt];\n\t\tif(cnt!=n)\n\t\t\tans=(ans+1)%MOD;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n#define ASSERT(x) { _assert(x); cout << #x << endl; }\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b, smaller;\n        cin >> a >> b;\n        baba[b] = a;\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,a,b,ans;\n\nsigned main(){\n  while(cin>>n>>m,n){\n    ans=1;\n    UnionFind U(n);\n    r(i,m){\n      cin>>a>>b;\n      a--;b--;\n      U.unite(a,b);\n    }\n    r(i,n)if(U.find(i)==i)ans=(ans*2)%1000000007;\n    if(m)ans=(ans+1)%1000000007;\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int V_MAX=100000;\nconst int M=1000000007;\n\nint main(){\n\tfor(int n,m;~scanf(\"%d%d\",&n,&m);){\n\t\tif(n==0) break;\n\n\t\tstatic vector<int> G[V_MAX];\n\t\trep(u,n) G[u].clear();\n\n\t\trep(i,m){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\n\t\t// BFS\n\t\tint cc=0; // number of connected components of G\n\t\tstatic bool vis[V_MAX];\n\t\trep(u,n) vis[u]=false;\n\t\trep(u,n) if(!vis[u]) {\n\t\t\tcc++;\n\t\t\tvis[u]=true;\n\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[V_MAX];\n\t\t\tQ[tail++]=u;\n\t\t\twhile(head<tail){\n\t\t\t\tint v=Q[head++];\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tint w=G[v][i];\n\t\t\t\t\tif(!vis[w]){\n\t\t\t\t\t\tvis[w]=true;\n\t\t\t\t\t\tQ[tail++]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1;\n\t\trep(i,cc) ans=2*ans%M;\n\t\tif(m>0) ans=(ans+1)%M;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b, smaller;\n        cin >> a >> b;\n        baba[b] = a;\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    // cout << ans << endl;\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100001\n#define MOD 1000000007\ntypedef long long ll;\n\nint par[MAX],rank[MAX];\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y){ return; }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return (find(x) == find(y));\n}\n\nll mod_pow(ll x,ll n){\n  if(n == 0){ return 1; }\n  ll res = mod_pow(x*x%MOD,n/2);\n  if(n & 1){ res = res*x%MOD; }\n  return res;\n}\n\nint main(){\n  int N,M,a,b;\n  while(cin >> N >> M,N){\n    init(N);\n    for(int i = 0 ; i < M ; i++){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n    ll cnt = 0;\n    bool visited[MAX] = {false};\n    for(int i = 0 ; i < N ; i++){\n      int x = find(i);\n      if(!visited[x]){\n        visited[x] = true;\n        cnt++;\n      }\n    }\n    ll res = mod_pow(2,cnt);\n    if(cnt != N){ ++res; }\n    cout << res%MOD << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rank Gacho_0716\n#define M 1000000007\nusing namespace std;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nset<int> memo;\n\nint main(){\n  \n  while(1){\n    \n    int n, m;\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    UF uf = UF(n);\n    \n    for(int i=0;i<m;i++){\n      int a, b;\n      cin>>a>>b;\n      a--, b--;\n      uf.unite(a,b);\n    }\n    \n    memo.clear();\n    \n    for(int i=0;i<n;i++) memo.insert(uf.find(i));\n    \n    int x=1, y=1;\n    \n    for(int i=0;i<n;i++) x=x*2%M;\n    \n    for(int i=0;i<memo.size();i++) y=y*2%M;\n\n    cout<<(y%M + (x!=y))%M<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        if (baba[b] != b) {\n            baba[baba[b]] = a;\n        } else {\n            baba[b] = a;\n        }\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        int n, m; cin >> n >> m;\n        if(n == 0 and m == 0) break;\n\n        UnionFind uf(n);\n        rep(i, m){\n            int a, b; cin >> a >> b; a--, b--;\n            uf.unionSet(a, b);\n        }\n\n        int num = 0;\n        rep(i, n){\n            if(uf.root(i) == i){\n                num++;\n            }\n        }\n\n        ll res = 1LL;\n        rep(i, num){\n            res = MUL(res, 2LL, mod);\n        }\n        if(num < n){\n            res = ADD(res, 1LL, mod);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll mod = 1e9+7;\n\nvoid dfs(int v, vector<bool>& used, vector<vector<int>> const& g) {\n    used[v] = true;\n    for(auto to : g[v]) {\n        if(!used[to]) {\n            dfs(to, used, g);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        vector<vector<int>> g(N);\n        for(int i=0; i<M; ++i) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        int cnt = 0;\n        vector<bool> used(N);\n        for(int i=0; i<N; ++i) {\n            if(!used[i]) {\n                cnt++;\n                dfs(i, used, g);\n            }\n        }\n        ll res = 1;\n        while(cnt-- > 0) {\n            (res *= 2) %= mod;\n        }\n        cout << res + (M != 0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint pow_mod(ll x, ll n, int m) {\n\tll res = 1;\n\tfor (; n > 0; n >>= 1) {\n\t\tif (n & 1) res = (res * x) % m;\n\t\tx = (x * x) % m;\n\t}\n\treturn res;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0) break;\n\t\tvector<bool> v(N);\n\t\twhile (M--) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tv[a - 1] = v[b - 1] = true;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tif (!v[i]) cnt++;\n\t\tif (cnt == N)\n\t\t\tcout << pow_mod(2, cnt, MOD) << endl;\n\t\telse\n\t\t\tcout << (pow_mod(2, cnt + 1, MOD) + 1) % MOD << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n \nll pow(ll a, ll n){\n  ll res = 1;\n  while(n){\n    if(n&1)(res *= a) %= mod;\n    (a *= a) %= mod; n>>=1;\n  }\n  return res;\n}\n \nint n,m,a,b;\n \nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n \n  while(cin >> n >> m, n){\n    ll ans = pow(2,g.size());\n    if(m>0)ans++, ans%=mod;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\nconst lli mod = 1000000007LL;\n\nint N, M;\nvector<vector<int> > G;\nvector<int> vis;\n\nvoid dfs(int v) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    if(vis[G[v][i]]) continue;\n    dfs(G[v][i]);\n  }\n}\n\nlli mod_pow(lli x, lli n) {\n  if(n == 0) return 1;\n  lli y = mod_pow(x, n/2);\n  if(n & 1) return y * y % mod * x % mod;\n  else return y * y % mod;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    G = vector<vector<int> >(N);\n    for(int i = 0; i < M; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    lli n_cmp = 0;\n    vis = vector<int>(N);\n    for(int i = 0; i < N; ++i) {\n      if(vis[i]) continue;\n      ++n_cmp;\n      dfs(i);\n    }\n    cout << (mod_pow(2LL, n_cmp) + (n_cmp != N)) % mod << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0) break;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t}\n\t\tif (M == 0) {\n\t\t\tll ans = 1;\n\t\t\twhile (N--) ans = (ans * 2) % MOD;\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse if (M == 1) {\n\t\t\tll ans = 1;\n\t\t\tN--;\n\t\t\twhile (N--) ans = (ans * 2) % MOD;\n\t\t\tcout << (ans + 1) % MOD << endl;\n\t\t}\n\t\telse cout << 3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tuf.unionSet(a, b);\n\t\t}\n\t\tMod ans(1);\n\t\tbool kake3 = false;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (uf.size(i) >= 2) {\n\t\t\t\tkake3 = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 2;\n\t\t\t}\n\t\t}\n\t\tans *= kake3 ? 3 : 1;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn a*mypow(a, n / 2) % MOD*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tint c = 0, d = 0;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] == 1)c++;\n\t\t\tif (cnt[i] > 1)d++;\n\t\t}\n\t\tll res = mypow(2,d)*mypow(2,c)%MOD;\n\t\tif (d != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tlong long x=1;\n\tfor(int i=32;i--;){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tconstexpr int MOD=1e9+7;\n\t\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\twhile(m--){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tint res=ModPow(2,cc,MOD);\n\t\tif(cc<n) res=(res+1)%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b, smaller;\n        cin >> a >> b;\n        baba[b] = a;\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n#define ASSERT(x) { _assert(x); cout << #x << endl; }\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nbool marked[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint mark(int num) {\n    if (!marked[num]) {\n        marked[num] = true;\n        return 1;\n    }\n    return 0;\n}\n\nvoid solve(int n, int m) {\n    fill(marked, marked+n, false);\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        total += mark(a) + mark(b);\n    }\n    int ans = 0;\n    if (total > 0) {\n        ans = 1 + 2 * power_modulo(2, n - total, MOD_BASE);\n    } else {\n        ans += power_modulo(2, n - total, MOD_BASE);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst ll mod = 1e9+7;\nll add(ll a, ll b) { return (a + b) % mod; }\nll mul(ll a, ll b) { return a * b % mod; }\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (n & i) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n    int N, M;\n    while ( cin >> N >> M, N || M ) {\n        set<int> s;\n        REP(i, M) {\n            int a, b; cin >> a >> b; --a, --b;\n            s.insert(a);\n            s.insert(b);\n        }\n        int Y = s.size();\n        int X = N - Y;\n        ll ans = 0;\n        if (Y == 0) {\n            ans = power(2, N);\n        }\n        else {\n            ans = add(power(2, 2*X+1), 1);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint pow_mod(ll x, ll n, int m) {\n\tll res = 1;\n\tfor (; n > 0; n >>= 1) {\n\t\tif (n & 1) res = (res * x) % m;\n\t\tx = (x * x) % m;\n\t}\n\treturn res;\n}\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0) break;\n\t\tunion_find uf(N);\n\t\tint k = N;\n\t\twhile (M--) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (uf.same(a, b)) continue;\n\t\t\tuf.unite(a, b);\n\t\t\tk--;\n\t\t}\n\t\tif (k == N) cout << pow_mod(2, N, MOD) << endl;\n\t\telse cout << (pow_mod(2, k, MOD) + 1) % MOD << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn a*mypow(a, n / 2) % MOD*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n, 0);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tint c = 0, d = 0;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] == 1)c++;\n\t\t\tif (cnt[i] > 1)d++;\n\t\t}\n\t\tll res = mypow(2, d)*mypow(2, c) % MOD;\n\t\tif (m != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint UF[1000000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\nint mod=1000000007;\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint c,d;\n\t\t\tscanf(\"%d%d\",&c,&d);\n\t\t\tc--;d--;\n\t\t\tUNION(c,d);\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(UF[i]<0)count++;\n\t\t}\n\t\tint ret=1;\n\t\tfor(int i=0;i<count;i++)ret=ret*2%mod;\n\t\tif(count!=a)ret=(ret+1)%mod;\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst ll mod = 1e9+7;\n\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nll power(ll x, ll n) {\n\tll res = 1;\n\tfor (ll i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) {\n\t\t\tres = mul(res, x);\n\t\t}\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tset<int> s;\n\t\tREP(i, M) {\n\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint scnt = (int)s.size();\n\t\tll ans = 0;\n\t\tif (scnt > 0) {\n\t\t\tans = power(2, N-scnt+1);\n\t\t\tans = add(ans, 1);\n\t\t}\n\t\telse {\n\t\t\tans = power(2, N);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn (a*mypow(a, n / 2) % MOD)*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tint cnt = 0;\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (!u.same(a, b)) {\n\t\t\t\tu.unite(a, b);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tll res = mypow(2, n-cnt);\n\t\tif (m != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn a*mypow(a, n / 2) % MOD*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n,0);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tint c = 0, d = 0;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] == 1)c++;\n\t\t\tif (cnt[i] > 1)d++;\n\t\t}\n\t\tll res = mypow(2,d)*mypow(2,c)%MOD;\n\t\tif (d != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n \nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n \n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)///\nll mypow(ll a, ll n) {\n    if (n == 0)return 1;\n    if (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n    return (a*mypow(a, n / 2) % MOD)*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n    vector<int> par;\n    vector<int> ran;\n \n    UnionFind(int n) {\n        par.resize(n);\n        ran.resize(n);\n        REP(i, n) {\n            par[i] = i;\n            ran[i] = 0;\n        }\n    }\n \n    int root(int a) {\n        return par[a] == a ? a : par[a] = root(par[a]);\n    }\n \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n \n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (ran[x] < ran[y]) {\n            par[x] = y;\n        }\n        else {\n            par[y] = x;\n            if (ran[x] == ran[y]) ran[x]++;\n        }\n    }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n)break;\n        UnionFind u(n);\n     \n        REP(i, m) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n \n            u.unite(a, b);\n        }\n        vi cnt(n, 0);\n        REP(i, n) {\n            cnt[u.root(i)]++;\n        }\n        int c = 0;\n        REP(i, n) {\n            if (cnt[i] > 0)c++;\n        }\n        ll res = mypow(2, c);\n        if (m != 0)res++;\n        cout << res%MOD << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD =  1e9+7;\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nLL powM(LL a, LL b){\n  if(b == 0) return 1;\n  return powM(a*a%MOD,b/2) * (b&1? a: 1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tUnionFind uf(N);\n\tvector<PII> special(M);\n\tREP(i,M) cin >> special[i].first >> special[i].second;\n\tREP(i,M) uf.unite(special[i].first-1, special[i].second-1);\n\n\tVI vis(N, 0);\n\tREP(i,N) vis[uf.find(i)]++;\n\tLL ans = 1, cnt = 0;\n\tREP(i,N){\n\t  if(uf.find(i) == i)\n\t\tans = ans * 2 % MOD, ++cnt;\n\t}\n\tif(cnt == 1) ans = 3;\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        baba[find_baba(b)] = baba[a];\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst ll mod=1000000007;\n\nll mod_pow(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1) res=res*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n        --cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        union_find uf(n);\n        set<int> s;\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            --a;\n            --b;\n            uf.unite(a,b);\n            s.insert(a);\n            s.insert(b);\n        }\n        ll ans=mod_pow(2,uf.cnt);\n        if(uf.cnt>0) ans=(ans+1)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<30;\n\nstruct UF{\n    int n;\n    vector<int> par,size;\n    \n    void init(int n_){\n        n=n_;\n        par.assign(n,-1);\n        size.assign(n,1);\n        \n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    \n    int root(int a){\n        if(par[a]==a) return a;\n        else return par[a]=root(par[a]);\n    }\n    \n    void unite(int a,int b){\n        if(root(a)!=root(b)){\n            size[root(a)]+=size[root(b)];\n            par[root(b)]=root(a);\n        }\n    }\n    \n    bool check(int a,int b){\n        return root(a)==root(b);\n    }\n};\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N==0) break;\n        UF uf;\n        uf.init(N);\n        \n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            uf.unite(a,b);\n        }\n        \n        int cnt=0,cnt2=0;\n        for(int i=0;i<N;i++){\n            if(uf.root(i)==i){\n                if(uf.size[i]>=2) cnt2=1;\n                cnt++;\n            }\n        }\n        \n        cout<<(cnt2+rui(2,cnt))%mod<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a),b=Find(b);\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\tdata[a]+=data[b];\n\t\tdata[b]=a;\n\t\treturn true;\n\t}\n\tint Size(int i){\n\t\treturn -data[Find(i)];\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tll x=1;\n\tper(i,32){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tdump(ModPow(3,5,MOD));\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tif(m==0){\n\t\t\tcout<<ModPow(2,n,MOD)<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\trep(i,m){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tint one=0;\n\t\trep(i,n) one+=uf.data[i]==-1;\n\t\t\n\t\tint res=(cc-one+2*ModPow(2,one,MOD))%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst ll mod=1000000007;\n\nll mod_pow(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1) res=res*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        union_find uf(n);\n\n        set<int> s;\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            --a;\n            --b;\n            uf.unite(a,b);\n            s.insert(a);\n            s.insert(b);\n        }\n        ll ans=1;\n        rep(i,0,n){\n            if(s.find(i)!=s.end()) continue;\n            ans=ans*2%mod;\n        }\n        ans=ans*mod_pow(2,n-uf.cnt-1)%mod;\n        ans=(ans+n-uf.cnt-1)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if (i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nll modpow(ll x, ll y) {\n  ll res = 1;\n  while (y > 0) {\n    if (y & 1) {\n      (res *= x) %= MOD;\n    }\n    (x *= x) %= MOD;\n    y /= 2;\n  }\n  return res;\n}\n\nstruct UnionFind {\n  vi par;\n\n  UnionFind(int n) {\n    par.resize(n, -1);\n  }\n\n  int root(int x) {\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n\n    if(x == y) return;\n    if(par[x] < par[y]) {\n      swap(x, y);\n    }\n\n    par[y] += par[x];\n    par[x] = y;\n  }\n\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  int size(int x) {\n    return -par[root(x)];\n  }\n};\n\nbool solve() {\n  int n, m;\n  cin >> n >> m;\n  if(n == 0) return false;\n  UnionFind uf(n);\n  REP(i, m) {\n    int a, b; cin >> a >> b;\n    a--; b--;\n    uf.unite(a, b);\n  }\n\n\n  map<int, int> mp;\n  REP(i, n) {\n    mp[uf.root(i)] = uf.size(i);\n  }\n\n  int cnt = 0;\n  for(auto &e: mp) {\n    if(e.second > 1) cnt++;\n  }\n\n  ll ans = 1;\n  for(auto &e: mp) {\n    ans *= 2;\n    ans %= MOD;\n  }\n\n  if(cnt == 1) cout << (ans + 1) % MOD << endl;\n  else if(cnt >= 2) cout << (ans + 1) % MOD << endl;\n  else cout << ans << endl;\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while(solve()) {}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        int new_baba = find_baba(baba[i]);\n        baba[i] = new_baba;\n        return new_baba;\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        if (baba[b] != b) {\n            if (baba[b] < a) baba[a] = baba[b];\n            else baba[baba[b]] = a;\n        } else {\n            baba[b] = a;\n        }\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst ll mod=1000000007;\n\nll mod_pow(ll x,ll y){\n    ll res=1;\n    while(y>0){\n        if(y&1) res=res*x%mod;\n        x=x*x%mod;\n        y>>=1;\n    }\n    return res;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank;\n\tint size;\n\tpublic:\n    int cnt;\n\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcnt=n;\n\t\tparent.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i=0; i<size; ++i){\n\t\t\tparent[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n\t\t} else {\n\t\t\tparent[y]=x;\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n        --cnt;\n\t}\n\n\tbool is_same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nvoid solve(){\n    while(true){\n        ll n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n\n        union_find uf(n);\n        rep(i,0,m){\n            int a,b;\n            cin >> a >> b;\n            uf.unite(a-1,b-1);\n        }\n        ll ans=mod_pow(2,uf.cnt);\n        if(uf.cnt!=n) ans=(ans+1)%mod;\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int i){\n\t\treturn data[i]<0?i:(data[i]=Find(data[i]));\n\t}\n\tbool Unite(int a,int b){\n\t\ttie(a,b)=mt(Find(a),Find(b));\n\t\tif(a==b) return false;\n\t\tif(-data[a]<-data[b]) swap(a,b);\n\t\ttie(data[a],data[b])=mt(data[a]+data[b],a);\n\t\treturn true;\n\t}\n};\n\nint ModPow(int a,int r,int m)\n{\n\tll x=1;\n\tper(i,32){\n\t\tx=x*x%m;\n\t\tif(r>>i&1)\n\t\t\tx=x*a%m;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tUnionFind uf(n);\n\t\tint cc=n;\n\t\trep(i,m){\n\t\t\tint a,b; cin>>a>>b; a--,b--;\n\t\t\tcc-=uf.Unite(a,b);\n\t\t}\n\t\tll res=ModPow(2,cc,MOD);\n\t\tif(cc<n) res=(res+1)%MOD;\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nint N,M;\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0)break;\n    UnionFind uf(N);\n    rep(i,M){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      uf.unite(a,b);\n    }\n    vector<bool> used(N,false);\n    int sum=0;\n    ll p=1;\n    rep(i,N){\n      if(used[uf.find(i)])continue;\n      used[uf.find(i)]=true;\n      if(uf.size(i)>1){\n        sum+=uf.size(i);\n        (p*=2)%=mod;\n      }\n    }\n    ll res=mod_pow(2,N-sum);\n    if(sum>0){\n      (res*=p)%=mod;\n      (res+=1)%=mod;\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint mod = 1000000007;\nint n,m,a[100001],b[100001],n1,n2;\nint used[100001];\nint main(){\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    cin>>m;\n    r(i,m)cin>>a[i]>>b[i],a[i]--,b[i]--;\n    n1=n2=1;\n    r(i,n)n1=n1*2,n1=n1%mod;\n    r(i,n-2)n2=n2*2,n2=n2%mod;\n    if(m==0)cout<<n1<<endl;\n    else if(n==1)cout<<2<<endl;\n    else{\n      set<int>s[100001];\n      int ans=0;\n      r(i,m){\n\tif(!i) ans+=n2;\n\telse{\n\t  int x=n2-1;\n\t  set<int>st;\n\t  set_union(s[a[i]].begin(),s[a[i]].end(),s[b[i]].begin(),s[b[i]].end(),inserter(st,end(st)));\n\t  x-=st.size();\n\t  if(!x)x++;\n\t  ans+=x;\n\t  //cout<<x<<endl;\n\t}\n\ts[a[i]].insert(b[i]);\n\ts[b[i]].insert(a[i]);\n\tans=ans%mod;\n      }\n      cout<<ans<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst ll mod = 1e9+7;\n\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nll power(ll x, ll n) {\n\tll res = 1;\n\tfor (ll i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) {\n\t\t\tres = mul(res, x);\n\t\t}\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tset<int> s;\n\t\tREP(i, M) {\n\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint scnt = (int)s.size();\n\t\tll ans = power(2, N-M);\n\t\tif (M != 0) {\n\t\t\tans = add(ans, 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn (a*mypow(a, n / 2) % MOD)*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n, 0);\n\t\tREP(i, n) {\n\t\t\tcnt[u.par[i]]++;\n\t\t}\n\t\tint c = 0;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] > 0)c++;\n\t\t}\n\t\tll res = mypow(2, c);\n\t\tif (m != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nint n,m;\nint dat[125252];\n\nint root(int x){\n\treturn dat[x]<0?x:dat[x]=root(dat[x]);\n}\nvoid unite(int a, int b){\n\ta=root(a); b=root(b);\n\tif(a==b)return;\n\tif(dat[a]>dat[b])swap(a,b);\n\tdat[a]+=dat[b];\n\tdat[b]=a;\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfill(dat,dat+n,-1);\n\t\tREP(i,m){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t--a; --b;\n\t\t\tunite(a,b);\n\t\t}\n\t\tint c = 0;\n\t\tREP(i,n)if(root(i)==i)c++;\n\t\tll ans = 1;\n\t\tREP(i,c)ans=ans*2%MOD;\n\t\tif(c != n){\n\t\t\tans = (ans+1)%MOD;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define GET_BIT(n, i) (((n) & (1 << ((i)-1))) >> ((i)-1)) // i start from 1\n#define SET_BIT(n, i) ((n) | (1 << ((i)-1)))\n#define CLR_BIT(n, i) ((n) & ~(1 << ((i)-1)))\n#define SHOW_A(x) {cout << #x << \" = \" << x << endl;}\n#define SHOW_B(x, y) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << endl;}\n#define SHOW_C(x, y, z) {cout << #x << \" = \" << x << \", \" << #y << \" = \" << y << \", \" << #z << \" = \" << z << endl;}\n#define REACH_HERE {cout << \"REACH_HERE! line: \" << __LINE__ << endl;}\n\nconst double E = 1e-8;\nconst double PI = acos(-1);\n\nusing namespace std;\n\nconst int MAX_N = 100005, MAX_M = 10005;\nconst int MOD_BASE = 1000000007;\n\nint baba[MAX_N];\n\nint power_modulo(int n, int p, int M) {\n    int result = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            result = ((long long)result*n) % M;\n        p /= 2;\n        n = ((long long)n*n) % M;\n    }\n    return result;\n}\n\nint find_baba(int i) {\n    if (baba[i] != i) {\n        return find_baba(baba[i]);\n    }\n    return i;\n}\n\nvoid solve(int n, int m) {\n    for (int i = 1; i <= n; i++) {\n        baba[i] = i;\n    }\n    bool unstable = false;\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        baba[find_baba(b)] = find_baba(a);\n        unstable = true;\n    }\n    int group = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find_baba(i) == i) {\n            group ++;\n        }\n    }\n    int ans = unstable ? 1 : 0;\n    ans += power_modulo(2, group, MOD_BASE);\n    cout << ans << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        solve(n, m);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mod=1e9+7;\nll add(ll a,ll b){return (a+b)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\n\nll pow(ll a,ll b){\n  if(b==0)return 1;\n  else if(b%2==0)return pow(a*a%mod,b/2);\n  else return pow(a*a%mod,b/2)*a%mod;\n}\n\n\n\n#define MAX 100005\nint pa[MAX];\nint ra[MAX];\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    pa[i]=i;\n    ra[i]=0;\n  }\n}\n\nint find(int x){\n  if(pa[x]==x)return x;\n  else return pa[x]=find(pa[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(ra[x]<ra[y])swap(x,y);\n  pa[y]=x;\n  if(ra[x]==ra[y])ra[x]++;\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\nint n,m,a,b;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d\",&a,&b);\n      unite(a,b);\n    }\n    ll cnt=0;\n    for(int i=1;i<=n;i++)\n      if(find(i)==i)\n        cnt++;\n    \n    cout<<add(pow(2LL,cnt),(cnt==n?0:1))<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct UnionFind {\n    vector<int> data;\n    int size;\n    UnionFind(int N) : \n        data(N, -1), size(N) {}\n    int root(int x){\n        if(data[x] < 0) return x;\n        return data[x] = root(data[x]);\n    }\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        size--;\n        data[x] += data[y];\n        data[y] = x;\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N, M;\n    while(cin >> N >> M && N > 0){\n        UnionFind uf(N);\n        REP(i, M){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            uf.unite(a, b);\n        }\n        int s = uf.size;\n        int ans = 1;\n        REP(i, s) ans = (2LL * ans) % MOD;\n        if(s < N) {\n            ans = (ans + 1) % MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nint uf[100100], r[100100];\n\nvoid init(int n){\n  rep(i,n)uf[i] = i, r[i] = 0;\n}\n\nint find(int a){\n  if(uf[a] == a)return a;\n  return uf[a] = find(uf[a]);\n}\n\nvoid unite(int a,int b){\n  a = find(a); b = find(b);\n  if(a==b)return;\n  if(r[a] < r[b])uf[a] = b;\n  else{\n    uf[b] = a;\n    if(r[a] == r[b])r[b]++;\n  }\n}\n\nll pow(ll a, ll n){\n  ll res = 1;\n  while(n){\n    if(n&1)(res *= a) %= mod;\n    (a *= a) %= mod; n>>=1;\n  }\n  return res;\n}\n\nint n,m,a,b;\n\nint main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  while(cin >> n >> m, n){\n    init(n);\n\n    rep(i,m){\n      cin >> a >> b; a--; b--;\n      unite(a,b);\n    }\n\n    map<int,int> g;\n    rep(i,n)g[find(i)]++;\n    \n    ll ans = pow(2,g.size());\n    for(map<int,int>::iterator it=g.begin();it!=g.end();it++){\n      if(it->second != 1){\n\tans++; ans %= mod;\n\tbreak;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct UnionFind{\n  int n;\n  vector<int> ran,p,cnt;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),ran(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(ran[x]<ran[y]) swap(x,y);\n    ran[x]+=ran[y];\n    p[y]=x;\n  }\n  int sum(int x){\n    return ran[find(x)];\n  }\n};\n\nint n,m,a,b,ans;\nvector<int>v;\n\nsigned main(){\n  while(cin>>n>>m,n){\n    ans=0;\n    v.clear();\n    UnionFind U(n);\n    r(i,m){\n      cin>>a>>b;\n      a--;b--;\n      U.unite(a,b);\n    }\n    r(i,n)if(U.find(i)==i){\n      if(U.sum(i)>1)v.push_back(U.sum(i));\n    }\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++){\n      int res=v[i];\n      for(int j=i+1;j<v.size();j++) res=(res*v[i])%1000000007;\n      ans+=res;\n    }\n    if(ans)cout<<ans<<endl;\n    else{\n      ans=1;\n      r(i,n)ans=(ans*2)%1000000007;\n      cout<<ans<<endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n\ntypedef long long LL;\n\nint n, m;\nint par[100002];\n\nint f(int x) {\n    if (x == par[x]) return x;\n    return par[x] = f(par[x]);\n}\n\nLL cnt[100002];\n\nint main () {\n    while (scanf(\"%d %d\", &n, &m)) {\n        if (n == 0 && m == 0) return 0;\n\n        for (int i=0; i<n; i++) par[i] = i;\n\n        int u, v;\n        for (int i=0; i<m; i++) {\n            scanf(\"%d %d\", &u, &v);\n            u--, v--;\n            par[f(u)] = f(v);\n        }\n\n        for (int i=0; i<n; i++) cnt[i] = 0;\n        for (int i=0; i<n; i++) cnt[f(i)]++;\n\n        int satu = 0;\n        int dua = 0;\n        for (int i=0; i<n; i++) {\n            if (cnt[i] == 0) continue;\n            if (cnt[i] > 1) satu++;\n            dua++;\n        }\n\n        int ans = 1;\n        for (int i=0; i<dua; i++) {\n            ans *= 2;\n            if (ans >= MOD) ans -= MOD;\n        }\n\n        ans += satu;\n        if (ans >= MOD) ans -= MOD;\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\npublic:\n\texplicit union_find(int n):uf(n, -1) {}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif(x == y) return;\n\n\t\tif(uf[x] > uf[y]) swap(x, y);\n\n\t\tuf[x] += uf[y];\n\t\tuf[y] = x;\n\t}\n\n\tint number_of_sets() const {\n\t\treturn count_if(begin(uf), end(uf), [](int x) { return x < 0; });\n\t}\n};\n\nconstexpr long long mod = 1000000007;\n\nlong long mod_pow(long long n, long long k) {\n\tlong long res = 1;\n\n\twhile(k > 0) {\n\t\tif(k & 1) res = (res * n) % mod;\n\t\tn = (n * n) % mod;\n\t\tk >>= 1;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tunion_find uf(n);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tuf.unite(a - 1, b - 1);\n\t\t}\n\n\t\tconst int S = uf.number_of_sets();\n\t\tconst auto ans = mod_pow(2, S);\n\n\t\tcout << (n == S ? ans : (ans + 1) % mod) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct UF{\n\tint par[100000];\n\tint rank[100000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n, m;\nUF uf;\n\nvoid solve(){\n\tuf.init(n);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tuf.unite(a,b);\n\t}\n\tlong long ans = 1;\n\tbool check = false;\n\trep(i,n){\n\t\tif(uf.par[i] != i) continue;\n\t\tif(uf.rank[i] > 0){\n\t\t\tans *= 2;\n\t\t\tcheck = true;\n\t\t}\n\t\telse ans *= 2;\n\t\tans %= MOD;\n\t}\n\tif(check) ans += 1;\n\tans %= MOD;\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin>>n >> m ){\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\nclass UnionFind {\n\tstd::vector<int> vec;\npublic:\n\tUnionFind(int size) : vec(size, -1) {}\n\tint find(int a) {\n\t\treturn vec[a] < 0 ? a : vec[a] = find(vec[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a != b) {\n\t\t\tif (vec[a] > vec[b]) std::swap(a, b);\n\t\t\tvec[a] += vec[b];\n\t\t\tvec[b] = a;\n\t\t}\n\t}\n\tint size_of(int a) {\n\t\treturn -vec[find(a)];\n\t}\n\n};\n\nint main(){\n\tconstexpr long long int MOD = 1000000007;\n\twhile (true) {\n\t\tint n, m; std::cin >> n >> m; if (n == 0 && m == 0) break;\n\t\tUnionFind uft(n + 1);\n\t\tfor (auto i = 0; i < m; ++i) {\n\t\t\tint a, b; std::cin >> a >> b; --a; --b;\n\t\t\tuft.unite(a, b);\n\t\t}\n\t\tlong long int result = 1;\n\t\tfor (auto i = 0; i < n; ++i) if (!uft.same(i, n)){\n\t\t\tresult <<= 1;\n\t\t\tresult %= MOD;\n\t\t\tuft.unite(i, n);\n\t\t}\n\t\tif (m != 0) ++result;\n\t\tstd::cout << result << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct UnionFind{\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\nsigned main(){\n  int n,m;\n  int MOD=1000000007LL;\n  while(cin>>n>>m,n||m){\n    UnionFind uf(n);\n    for(int i=0;i<m;i++){\n      int x,y;\n      cin>>x>>y;\n      x--;y--;\n      uf.unite(x,y);\n    }\n    int ans=1;\n    for(int i=0;i<n;i++) if(uf.find(i)==i) (ans*=2)%=MOD;\n    if(m) (ans+=1)%=MOD;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,M,com,x,y;\nint height[100000],parent[100000];\n\nint find(int x){\n\tif(x == parent[x])return x;\n\telse{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n\nbool isSame(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)return;\n\n\tif(height[x] < height[y]){\n\t\tparent[x] = y;\n\t}else{\n\t\tparent[y] = x;\n\t\tif(height[x] == height[y])height[x]++;\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\theight[i] = 0;\n\t\t\tparent[i] = i;\n\t\t}\n\n\t\tint a,b;\n\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t\ta--,b--;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(parent[i] == i)count++;\n\t\t}\n\n\t\tll ans = 1;\n\t\tfor(int i = 0; i < count; i++)ans = ans*2%MOD;\n\n\t\tif(count != N){\n\t\t\tans = (ans+1)%MOD;\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans%MOD);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint n,m;\nvector<int> G[100010];\nbool used[100010];\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int to : G[v]){\n\t\tif(!used[to]) dfs(to);\n\t}\n}\n\nvoid solve(){\n\tfor(int i = 0;i < n;i++){\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint k = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tif(!used[i]){\n\t\t\tk++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tint ans = 1;\n\tfor(int i = 0;i < k;i++) ans = ans * 2 % MOD;\n\tcout << (ans + !!m) % MOD << endl;\n}\n\nsigned main(){\n\twhile(cin >> n >> m,n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind{\n    vector<int> par;\n    vector<int> rank;\n    public:\n    UnionFind(int n):par(n),rank(n){\n        iota(par.begin(),par.end(),0);\n    }\n    int find(int x){\n        if(par[x]==x) return x;\n        else return par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]) par[x]=y;\n        else{\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }\n    }\n};\nusing ll=long long;\nconst ll MOD=1e9+7;\nll powm(ll x,ll k){\n    ll res=1;\n    for(int i=0;i<k;i++) res=(res*x)%MOD;\n    return res;\n}\nll solve(int n,int m){\n    UnionFind u(n);\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        u.unite(a,b);\n    }\n    vector<int> cnt(n);\n    for(int i=0;i<n;i++){\n        cnt[u.find(i)]++;\n    }\n    int maxV=*max_element(cnt.begin(),cnt.end());\n    if(maxV>=2){\n        int rest=count(cnt.begin(),cnt.end(),1);\n        int chunk=0;\n        for(int i=0;i<n;i++) if(cnt[i]>1) chunk++;\n        return (powm(2,rest)*powm(2,chunk)+1)%MOD;\n    }\n    else{\n        return powm(2,n);\n    }\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tUnionFind uf(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tuf.unionSet(a, b);\n\t\t}\n\t\tMod ans(1);\n\t\tset<int>twomore;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (uf.size(i) >= 2) {\n\t\t\t\ttwomore.emplace(uf.root(i));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans *= 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < twomore.size(); ++i) {\n\t\t\tans *= 2;\n\t\t}\n\t\tif (!twomore.empty())ans += 1;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long; using ll = LL;\nusing PLL = pair<LL, LL>; using pll = PLL;\nusing PII = pair<int, int>; using pii = PII;\nconst int INF = 1e9; const LL LINF = 1e18;\n#define SZ(a) (int)a.size()\n#define FOR(i,s,t) for(int i= s; i<t;i++)\n#define ALL(a) a.begin(),a.end()\nusing VL = vector<LL>; using VLL = vector<VL>;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) { init(size); }\n\tvoid init(int size) { data.clear(); data.resize(size, -1); }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nvoid solve() {\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tUnionFind uf(N);\n\t\tFOR(i, 0, M) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tuf.unite(a, b);\n\t\t}\n\t\tVL used(N, 0);\n\t\tint isgroup = 0;\n\t\tint cnt = 0;\n\t\tFOR(i, 0, N) {\n\t\t\tint root = uf.root(i);\n\t\t\tif (used[root])continue;\n\t\t\tcnt++;\n\t\t\tif (uf.size(root) != 1)isgroup=1;\n\t\t\tused[root] = 1;\n\t\t}\n\t\tLL nene = 1;\n\t\tconst LL mod = 1e9 + 7;\n\n\t\tFOR(i, 0, cnt) {\n\t\t\tnene *= 2;\n\t\t\tnene %= mod;\n\t\t}\n\t\tnene += isgroup;\n\t\tnene %= mod;\n\t\tcout << nene << endl;\n\t}\n\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9+7;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    int numgroup;\n     \n    UnionFindTree(int n): v(n, -1), rank(n, 0), numgroup(n){}\n    int Find(int x){\n        if(v[x] < 0) return x;\n        return v[x] = Find(v[x]);\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]) swap(a, b);\n        if(rank[a] == rank[b]) rank[a]++;\n        v[b] = a;\n        numgroup--;\n    }\n};\n\nlli modpow(lli n, lli p, lli mod){\n    lli res = 1;\n    for(int i=63; i>=0; i--){\n        res = res*res %mod;\n        if((p & 1LL<<i) != 0) res = res*n %mod;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n\n        UnionFindTree uft(n);\n        for(int i=0; i<m; i++){\n            int a,b;\n            cin >> a >> b;\n            uft.Union(a, b);\n        }\n        if(m == 0){\n            cout << modpow(2, n, mod) << endl;\n        }else{\n            cout << (modpow(2, uft.numgroup, mod) +1)%mod << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst ll mod=1000000007;\nbool used[nmax];\n\n\n\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b%mod;\n}\n\nint par[nmax],ranks[nmax],sz[nmax];\n\nvoid init(int n){rep(i,n) par[i]=i,ranks[i]=sz[i]=0;}\nint find(int x){return (x==par[x])?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){\n\ta=find(a),b=find(b);\n\tif(ranks[a]<ranks[b])\n\t\tpar[a]=b;\n\telse{\n\t\tpar[b]=a;\n\t\tif(ranks[a]==ranks[b]) ranks[a]++;\n\t}\n\treturn ;\n}\nbool same(int a,int b){return find(a)==find(b);}\n\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(n==0&&m==0) break;\n\t\trep(i,n) used[i]=false;\n\t\tinit(n);\n\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\trep(i,n) sz[find(i)]++;\n\n\t\tif(m==0)\n\t\t\tcout << power(2,n) << endl;\n\t\telse{\n\t\t\tll ans=1LL,num=0,res=0;\n\t\t\trep(i,n){\n\t\t\t\tif(sz[i]>=2)\n\t\t\t\t\tnum++;\n\t\t\t\tif(sz[i]==1)\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t\tans*=power(2,res);\n\t\t\tans%=mod;\n\t\t\tans*=power(2,num);\n\t\t\tans%=mod;\n\t\t\tans=(ans+1)%mod;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9+7;\n\nstruct UnionFindTree{\n    vector<int> v;\n    vector<int> rank;\n    int numgroup;\n     \n    UnionFindTree(int n): v(n, -1), rank(n, 0), numgroup(n){}\n    int Find(int x){\n        if(v[x] < 0) return x;\n        return v[x] = Find(v[x]);\n    }\n    void Union(int a, int b){\n        a = Find(a);\n        b = Find(b);\n        if(a == b) return;\n        if(rank[a] < rank[b]) swap(a, b);\n        if(rank[a] == rank[b]) rank[a]++;\n        v[b] = a;\n        numgroup--;\n    }\n};\n\nlli modpow(lli n, lli p, lli mod){\n    lli res = 1;\n    for(int i=63; i>=0; i--){\n        res = res*res %mod;\n        if((p & 1LL<<i) != 0) res = res*n %mod;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n==0) break;\n        \n        UnionFindTree uft(n);\n        for(int i=0; i<m; i++){\n            int a,b;\n            cin >> a >> b;\n            a--; b--;\n            uft.Union(a, b);\n        }\n        if(m == 0){\n            cout << modpow(2, n, mod) << endl;\n        }else{\n            cout << (modpow(2, uft.numgroup, mod) +1)%mod << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nll pow(ll x, ll n, ll mod)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x*x%mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tadd_edge(g, a, b, 0);\n\t\t\tadd_edge(g, b, a, 0);\n\t\t}\n\t\tvector<bool> vis(n);\n\t\tll cnt = 0;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (vis[i]) continue;\n\t\t\tvis[i] = true;\n\t\t\tcnt++;\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint t = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (auto j : g[t])\n\t\t\t\t{\n\t\t\t\t\tint u = j.to;\n\t\t\t\t\tif (vis[u]) continue;\n\t\t\t\t\tvis[u] = true;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = pow(2, cnt, MOD);\n\t\tif (cnt != n) ans++;\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst ll mod = 1e9+7;\n\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nll power(ll x, ll n) {\n\tll res = 1;\n\tfor (ll i = 1; i <= n; i <<= 1) {\n\t\tif (i & n) {\n\t\t\tres = mul(res, x);\n\t\t}\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tset<int> s;\n\t\tREP(i, M) {\n\t\t\tint a, b; cin >> a >> b; --a, --b;\n\t\t\ts.insert(a);\n\t\t\ts.insert(b);\n\t\t}\n\t\tint scnt = (int)s.size();\n\t\tll ans = 0;\n\t\tif (scnt > 0) {\n\t\t\tans = add(ans, 1);\n\t\t\tans = power(2, N-scnt+1);\n\t\t}\n\t\telse {\n\t\t\tans = power(2, N);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nint N,M;\n\nint main(){\n  while(1){\n    cin>>N>>M;\n    if(N==0)break;\n    UnionFind uf(N);\n    rep(i,M){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      uf.unite(a,b);\n    }\n    vector<bool> used(N,false);\n    int sum=0;\n    rep(i,N){\n      if(used[uf.find(i)])continue;\n      used[uf.find(i)]=true;\n      if(uf.size(i)>1)sum+=uf.size(i);\n    }\n    ll res=mod_pow(2,N-sum);\n    if(sum>0){\n      (res*=2)%=mod;\n      (res+=1)%=mod;\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\n\nint parent[100005];\nvoid init()\n{\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t}\n}\n\nint root(int i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2) return ((a % mod) * (pow(a, n-1) % mod)) % mod;\n\tllint t = pow(a, n/2);\n\treturn ( (t%mod) * (t%mod) ) % mod;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tinit();\n\t\t\n\t\tint a, b;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> a >> b;\n\t\t\tunite(a, b);\n\t\t}\n\t\t\n\t\tllint X = 0;\n\t\tfor(int i = 1; i <= N; i++) if(parent[i] == i) X++;\n\t\t\n\t\tllint ans = pow(2, X);\n\t\tif(M) ans++;\n\t\tcout << ans % mod << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\nconst long long mod = (1e9) + 7;\n\nstruct UnionFind{\n  vector<int> data;\n  UnionFind(int n) : data(n, -1) {}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x,y);\n      data[x] += data[y];//高さを更新\n      data[y] = x;//親を更新\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N){\n    UnionFind uf(N);\n    for(int i = 0; i < M; ++i){\n      int a, b;\n      cin >> a >> b;\n      --a,--b;\n      uf.unite(a,b);\n    }\n    long long ans = 1;\n    set<int> S;\n    for(int i = 0; i < N; ++i) S.insert(uf.find(i));\n    for(size_t i = 0; i < S.size(); ++i) ans *= 2, ans %= mod;\n    ans += (N != (int)S.size());\n    ans %= mod;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    const int n;\n    UnionFind(int n) : n(n), par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    friend ostream& operator<<(ostream& os, UnionFind& uf) {\n        os << \"[\";\n        for (int i = 0; i < uf.n; ++i) {\n            if (i > 0) os << \" \";\n            os << uf.root(i);\n        }\n        return os << \"]\" << endl;\n    }\n};\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    using Int = modint<MOD>;\n\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0) break;\n        UnionFind uf(n);\n        for (int i = 0; i < m; ++i) {\n            int s, t; cin >> s >> t; --s, --t;\n            uf.merge(s, t);\n        }\n\n        int a = 0, b = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != uf.root(i)) continue;\n            (uf.size(i) > 1 ? a : b) += 1;\n        }\n\n        Int ans = Int(2).pow(a + b) + (a > 0);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll mypow(ll a, ll n) {\n\tif (n == 0)return 1;\n\tif (n % 2 == 0)return mypow(a, n / 2)*mypow(a, n / 2) % MOD;\n\treturn (a*mypow(a, n / 2) % MOD)*mypow(a, n / 2) % MOD;\n}\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> ran;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n};\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (!n)break;\n\t\tUnionFind u(n);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tu.unite(a, b);\n\t\t}\n\t\tvi cnt(n, 0);\n\t\tset<int> s;\n\t\tREP(i, n) {\n\t\t\ts.insert(u.par[i]);\n\t\t}\n\t\tll res = mypow(2, s.size());\n\t\tif (m != 0)res++;\n\t\tcout << res%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nint n,m;\nint a[100001],b[100001];\nvector<int> G[100001];\nint group[100001];\nint gcnt[100001];\n\nvoid dfs(int v,int cnt){\n\tgroup[v]=cnt;\n\tgcnt[cnt]++;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(group[G[v][i]]==-1)dfs(G[v][i],cnt);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tG[a[i]].push_back(b[i]);\n\t\t\tG[b[i]].push_back(a[i]);\n\t\t}\n\t\tmemset(gcnt,0,sizeof(gcnt));\n\t\tmemset(group,-1,sizeof(group));\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(group[i]==-1){\n\t\t\t\tdfs(i,cnt++);\n\t\t\t}\n\t\t}\n\t\tll res=1;\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tif(gcnt[i]>1){\n\t\t\t\tres=(ll)res*3%mod;\n\t\t\t}else res=(ll)res*2%mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint mod = 1000000007;\nint n,m,a[100001],b[100001],n1,n2;\nint used[100001];\nint main(){\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    cin>>m;\n    r(i,m)cin>>a[i]>>b[i],a[i]--,b[i]--;\n    n1=n2=1;\n    r(i,n)n1=n1*2,n1=n1%mod;\n    r(i,n-2)n2=n2*2,n2=n2%mod;\n    if(m==0)cout<<n1<<endl;\n    else if(n==1)cout<<2<<endl;\n    else{\n      set<int>s[100001];\n      int ans=0;\n      r(i,m){\n\tif(!i) ans+=n2;\n\telse{\n\t  int x=n2-1;\n\t  set<int>st;\n\t  set_union(s[a[i]].begin(),s[a[i]].end(),s[b[i]].begin(),s[b[i]].end(),inserter(st,end(st)));\n\t  x-=st.size();\n\t  if(!x)x++;\n\t  ans+=x;\n\t  //cout<<x<<endl;\n\t}\n\ts[a[i]].insert(b[i]);\n\ts[b[i]].insert(a[i]);\n\tans=ans%mod;\n      }\n      cout<<ans<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n    int n, m, sp[100000][2], i, j, count = 0, a, b, p[100000][2], k, l=0, ans[50], c[100000][2], flag; \n    scanf(\"%d %d\", &n, &m);\n    while(m || n)\n    {\n        /*if(m == 0)\n        {\n            i = 1;\n            for(j=0; j<n; j++)\n            {\n               i = i%1000000007;\n               i *= 2;\n            }\n            printf(\"%d\", i);\n            break;\n        }*/ \n        for(i=0; i<m; i++)\n            scanf(\"%d %d\", &sp[i][0], &sp[i][1]); \n        for(i=0; i<n; i++)\n          for(j=i+1; j<n; j++)\n           {\n            p[count][0] = i+1;\n            p[count][1] = j+1;\n            count++;\n           }\n        //for(i = 0; i<count; i++)\n        //    printf(\"%d %d\\n\", p[i][0], p[i][1]);\n        count = 0;\n        for(i = 0; i<n*(n-1)/2; i++)\n        {\n            a = p[i][0];\n            b = p[i][1];\n            for(j=a; j<b; j++)\n            {      \n                for(k=0; k<m; k++)\n                { \n                   if((j==sp[k][0]&&(j+1)==sp[k][1])||((j+1)==sp[k][0]&&j==sp[k][1]))\n                   {\n                       flag = 1;\n                       break;\n                   }\n               \n                   else   \n                       flag = 0;       \n                }   \n            }\n            if(flag)\n                {\n                    c[count][0] = a;\n                    c[count][1] = b;\n                    count++;\n                }\n        }\n        i = 1;\n        for(j=0; j<n; j++)\n        {\n            i = i%1000000007;\n            i *= 2;\n        }\n        if(m==0)\n            ans[l] = i;\n        else \n            ans[l] = (i - (2*count)%1000000007 + 1)%1000000007;\n        l++;\n        scanf(\"%d %d\", &n, &m);\n    }\n    for(i = 0; i<l; i++)\n        printf(\"%d\\n\", ans[i]);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.function.BiFunction;\n\npublic class Main{\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter ot = new PrintWriter(System.out);\n\tstatic Random rand = new Random();\n\tstatic int mod = 1000000007;\n\tstatic long modmod = (long)mod * mod;\n\tstatic long inf = (long)1e17;\n\tstatic int[] dx = {0,1,0,-1};\n\tstatic int[] dy = {1,0,-1,0};\n\tstatic int[] dx8 = {-1,-1,-1,0,0,1,1,1};\n\tstatic int[] dy8 = {-1,0,1,-1,1,-1,0,1};\n\tstatic char[] dc = {'R','D','L','U'};\n\tstatic BiFunction<Integer,Integer,Integer> fmax = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fmin = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fsum = (a,b)-> {return a+b;};\n\tstatic BiFunction<Long,Long,Long> fmaxl = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Long,Long,Long> fminl = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Long,Long,Long> fsuml = (a,b)-> {return a+b;};\n\tstatic BiFunction<Integer,Integer,Integer> fadd = fsum;\n\tstatic BiFunction<Integer,Integer,Integer> fupd = (a,b)-> {return b;};\n\tstatic BiFunction<Long,Long,Long> faddl = fsuml;\n\tstatic BiFunction<Long,Long,Long> fupdl = (a,b)-> {return b;};\n\tstatic String sp = \" \";\n\t\n\tpublic static void main(String[] args) {\n\t\t//AOJ2568 Everlasting -One-\n\t\t//author:Suunn\n\t\t//何もわからない、助けて\n\t\t//なんか条件を綺麗に言い換えるのかな...\n\t\t//2つの転職できる条件を言い換えると\n\t\t//同じ連結成分から白と黒の頂点を1つずつ選んで、塗り替える\n\t\t//白の頂点は必ず黒に塗り替える\n\t\t//黒の頂点はどちらにしてもよい\n\t\t//もう少し考える\n\t\t//白の頂点は黒に塗り替える\n\t\t//黒の頂点はだいたい白にしても黒にしてもよいが、最低1つ白の頂点と同じ連結成分にある\n\t\t//黒の頂点を選んで白にしなければならない\n\t\t\n\t\t//白と黒が両方ある連結成分を1つ選んで、そこは白と黒が両方あるまま、それ以外は自由に塗り替えみたいなことができる\n\t\t//（一旦連結成分の白黒以外全部黒にするみたいな感じでできる）\n\t\t//これを使ってどんな操作が可能か？\n\t\t//（大きさ3以上の連結成分があるとき、その中で選ぶ「白黒」の組は自由に変更できる）\n\t\t//（大きさ2以上の連結成分が2個以上あるとき、「白黒」を選ぶ連結成分は自由に変更できる）\n\t\t\n\t\t//ここまで分かれば後は算数するだけ？\n\t\t\n\t\t//「白黒」がないようなものは互いに行き来できない\n\t\t//「白黒」があるようなもの同士では必ず行き来が可能\n\t\t\n\t\twhile(true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint M = sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tUnionFindTree UF = new UnionFindTree(N);\n\t\t\tfor(int i=0;i<M;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tUF.unite(a,b);\n\t\t\t}\n\t\t\tlong ans = 1;\n\t\t\tfor(int i=0;i<N;i++) {\n\t\t\t\tif(UF.isRoot(i))ans *= 2;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t\tif(M!=0)ans++;\n\t\t\tSystem.out.println(ans%mod);\n\t\t}\n\t}\n\t\n\t\n\t\n\n\n}\n\nclass UnionFindTree {\n\tint[] root;\n\tint[] rank;\n\tlong[] size;\n\tint[] edge;\n\tint num;\n\tUnionFindTree(int N){\n\t\troot = new int[N];\n\t\trank = new int[N];\n\t\tsize = new long[N];\n\t\tedge = new int[N];\n\t\tnum = N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\troot[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t}\n\t\n\tpublic long size(int x) {\n\t\treturn size[find(x)];\n\t}\n\tpublic boolean isRoot(int x) {\n\t\treturn x==find(x);\n\t}\n\tpublic long extraEdge(int x) {\n\t\tint r = find(x);\n\t\treturn edge[r] - size[r] + 1;\n\t}\n\tpublic int find(int x){\n\t\tif(root[x]==x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn find(root[x]);\n\t\t}\n\t}\n\n\tpublic boolean unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y){\n\t\t\tedge[x]++;\n\t\t\treturn false;\n\t\t}else{\n\t\t\tnum--;\n\t\t\tif(rank[x]<rank[y]){\n\t\t\t\troot[x] = y;\n\t\t\t\tsize[y] += size[x];\n\t\t\t\tedge[y] += edge[x]+1;\n\t\t\t}else{\n\t\t\t\troot[y] = x;\n\t\t\t\tsize[x] += size[y];\n\t\t\t\tedge[x] += edge[y]+1;\n\t\t\t\tif(rank[x]==rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic boolean same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\n}\n\n\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] b = new byte[1024];\n    private int p = 0;\n    private int bl = 0;\n    private boolean hNB() {\n        if (p<bl) {\n            return true;\n        }else{\n            p = 0;\n            try {\n                bl = in.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (bl<=0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\tprivate int rB() { if (hNB()) return b[p++]; else return -1;}\n    private static boolean iPC(int c) { return 33 <= c && c <= 126;}\n    private void sU() { while(hNB() && !iPC(b[p])) p++;}\n    public boolean hN() { sU(); return hNB();}\n    public String next() {\n        if (!hN()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = rB();\n        while(iPC(b)) {\n            sb.appendCodePoint(b);\n            b = rB();\n        }\n        return sb.toString();\n    }\n    public char nextChar() {\n    \treturn next().charAt(0);\n    }\n    public long nextLong() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b=='-') {\n            m=true;\n            b=rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1||!iPC(b)){\n                return (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int nextInt() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b == '-') {\n            m = true;\n            b = rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b-'0';\n            }else if(b==-1||!iPC(b)){\n                return (int) (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int[] nextInts(int n) {\n    \tint[] a = new int[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public int[] nextInts(int n,int s) {\n    \tint[] a = new int[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public long[] nextLongs(int n, int s) {\n    \tlong[] a = new long[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n\t}\n    public long[] nextLongs(int n) {\n    \tlong[] a = new long[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n    }\n    public int[][] nextIntses(int n,int m){\n    \tint[][] a = new int[n][m];\n    \tfor(int i=0;i<n;i++) {\n    \t\tfor(int j=0;j<m;j++) {\n    \t\t\ta[i][j] = nextInt();\n    \t\t}\n    \t}\n    \treturn a;\n    }\n\n    public String[] nexts(int n) {\n    \tString[] a = new String[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = next();\n    \t}\n    \treturn a;\n    }\n    void nextIntses(int n,int[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextInt();\n    \t\t}\n    \t}\n    }\n    void nextLongses(int n,long[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextLong();\n    \t\t}\n    \t}\n    }\n\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "module SimpleUndirectedGraphic\n    require 'set'\n\n    def each_connected_component(&block)\n        return enum_for(__method__) unless block_given?\n        reached = Set.new\n        each_node do |s|\n            next if reached.include?(s)\n            cc = Set[s]\n            queue = [s]\n            until queue.empty?\n                u = queue.shift\n                each_neighbour(u) do |v|\n                    next if cc.include?(v)\n                    cc << v\n                    queue << v\n                    reached << v\n                end\n            end\n            block.call(cc)\n        end\n    end\nend\n\nclass Hash\n    include SimpleUndirectedGraphic\n    alias each_node each_key\n    def each_neighbour(u)\n        self[u].each do |v|\n            yield(v)\n        end\n    end\nend\n\nloop do\n    n, m = gets.split.map(&:to_i)\n    break if n == 0\n    g = {}\n    (1..n).map {|i| g[i] = Set.new}\n    m.times do\n        u, v = gets.split.map(&:to_i)\n        g[u] << v\n        g[v] << u\n    end\n\n    isolated = 0\n    cc = 0\n\n    g.each_connected_component do |a|\n        if a.size == 1\n            isolated += 1\n        else\n            cc += 1\n        end\n    end\n\n    if cc > 0\n        p (1 + 2 ** (cc + isolated)) % 1_000_000_007\n    else\n        p 2 ** isolated % 1_000_000_007\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "module SimpleUndirectedGraphic\n    require 'set'\n\n    def each_connected_component(&block)\n        return enum_for(__method__) unless block_given?\n        reached = Set.new\n        each_node do |s|\n            next if reached.include?(s)\n            cc = Set[s]\n            queue = [s]\n            until queue.empty?\n                u = queue.shift\n                each_neighbour(u) do |v|\n                    next if cc.include?(v)\n                    cc << v\n                    queue << v\n                    reached << v\n                end\n            end\n            block.call(cc)\n        end\n    end\nend\n\nclass Hash\n    include SimpleUndirectedGraphic\n    alias each_node each_key\n    def each_neighbour(u)\n        self[u].each do |v|\n            yield(v)\n        end\n    end\nend\n\nloop do\n    n, m = gets.split.map(&:to_i)\n    break if n == 0\n    g = {}\n    (1..n).map {|i| g[i] = Set.new}\n    m.times do\n        u, v = gets.split.map(&:to_i)\n        g[u] << v\n        g[v] << u\n    end\n\n    isolated = 0\n    cc = false\n\n    g.each_connected_component do |a|\n        if a.size == 1\n            isolated += 1\n        else\n            cc = true\n        end\n    end\n\n    if cc\n        p (1 + 2 ** (isolated+1)) % 1_000_000_007\n    else\n        p 2 ** isolated % 1_000_000_007\n    end\nend"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nMOD = 10**9 + 7\nwhile 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b = map(int, input().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n    que = deque()\n    used = [0]*N\n    r = 0; k = 0\n    for i in range(N):\n        if used[i]:\n            continue\n        k += 1\n        used[i] = 1\n        c = 1\n        que.append(i)\n        while que:\n            v = que.popleft()\n            for w in G[v]:\n                if used[w]:\n                    continue\n                que.append(w)\n                used[w] = 1\n                c += 1\n        if c > 1:\n            r += 1\n    if r > 0:\n        print((pow(2, k, MOD) + 1) % MOD)\n    else:\n        print(pow(2, N, MOD))\n"
  }
]