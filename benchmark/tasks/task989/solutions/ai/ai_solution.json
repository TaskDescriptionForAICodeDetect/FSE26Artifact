[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int to;\n    int company;\n    int next;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N + 1];\nint edgeCount = 0;\n\nvoid addEdge(int from, int to, int company) {\n    edges[edgeCount].to = to;\n    edges[edgeCount].company = company;\n    edges[edgeCount].next = head[from];\n    head[from] = edgeCount++;\n    \n    edges[edgeCount].to = from;\n    edges[edgeCount].company = company;\n    edges[edgeCount].next = head[to];\n    head[to] = edgeCount++;\n}\n\nint dijkstra(int N) {\n    int dist[MAX_N + 1][MAX_N + 1];\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    dist[1][0] = 0;\n    \n    int minCost = INT_MAX;\n    int visited[MAX_N + 1][MAX_N + 1] = {0};\n    \n    for (int _ = 0; _ < N * N; _++) {\n        int minDist = INT_MAX;\n        int minStation = -1;\n        int minCompany = -1;\n        \n        for (int station = 1; station <= N; station++) {\n            for (int company = 0; company < N; company++) {\n                if (!visited[station][company] && dist[station][company] < minDist) {\n                    minDist = dist[station][company];\n                    minStation = station;\n                    minCompany = company;\n                }\n            }\n        }\n        \n        if (minStation == -1) break;\n        \n        visited[minStation][minCompany] = 1;\n        \n        if (minStation == N) {\n            minCost = minDist;\n            break;\n        }\n        \n        for (int e = head[minStation]; e != -1; e = edges[e].next) {\n            int nextStation = edges[e].to;\n            int nextCompany = edges[e].company;\n            \n            int newDist = minDist;\n            if (minCompany != nextCompany) newDist++;\n            \n            if (newDist < dist[nextStation][nextCompany]) {\n                dist[nextStation][nextCompany] = newDist;\n            }\n        }\n    }\n    \n    return minCost == INT_MAX ? -1 : minCost;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    memset(head, -1, sizeof(head));\n    \n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        addEdge(a, b, c);\n    }\n    \n    printf(\"%d\\n\", dijkstra(N));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int station;\n    int company;\n    int cost;\n} Node;\n\ntypedef struct {\n    int *data;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nvoid initPriorityQueue(PriorityQueue *pq, int capacity) {\n    pq->data = (int *)malloc(capacity * sizeof(int));\n    pq->size = 0;\n    pq->capacity = capacity;\n}\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid push(PriorityQueue *pq, int value) {\n    if (pq->size == pq->capacity) return;\n    pq->data[pq->size++] = value;\n    int current = pq->size - 1;\n    while (current > 0) {\n        int parent = (current - 1) / 2;\n        if (pq->data[current] < pq->data[parent]) {\n            swap(&pq->data[current], &pq->data[parent]);\n            current = parent;\n        } else {\n            break;\n        }\n    }\n}\n\nint pop(PriorityQueue *pq) {\n    if (pq->size == 0) return -1;\n    int result = pq->data[0];\n    pq->data[0] = pq->data[--pq->size];\n    int current = 0;\n    while (1) {\n        int left = 2 * current + 1;\n        int right = 2 * current + 2;\n        int smallest = current;\n        if (left < pq->size && pq->data[left] < pq->data[smallest]) {\n            smallest = left;\n        }\n        if (right < pq->size && pq->data[right] < pq->data[smallest]) {\n            smallest = right;\n        }\n        if (smallest != current) {\n            swap(&pq->data[current], &pq->data[smallest]);\n            current = smallest;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    Node **adj = (Node **)malloc((N + 1) * sizeof(Node *));\n    int *adjSize = (int *)calloc(N + 1, sizeof(int));\n    int *adjCapacity = (int *)calloc(N + 1, sizeof(int));\n    \n    for (int i = 0; i < M; i++) {\n        int p, q, c;\n        scanf(\"%d %d %d\", &p, &q, &c);\n        \n        if (adjCapacity[p] == adjSize[p]) {\n            adjCapacity[p] = adjCapacity[p] == 0 ? 1 : adjCapacity[p] * 2;\n            adj[p] = (Node *)realloc(adj[p], adjCapacity[p] * sizeof(Node));\n        }\n        adj[p][adjSize[p]++] = (Node){q, c, 0};\n        \n        if (adjCapacity[q] == adjSize[q]) {\n            adjCapacity[q] = adjCapacity[q] == 0 ? 1 : adjCapacity[q] * 2;\n            adj[q] = (Node *)realloc(adj[q], adjCapacity[q] * sizeof(Node));\n        }\n        adj[q][adjSize[q]++] = (Node){p, c, 0};\n    }\n    \n    int **dist = (int **)malloc((N + 1) * sizeof(int *));\n    for (int i = 1; i <= N; i++) {\n        dist[i] = (int *)malloc(1000001 * sizeof(int));\n        for (int j = 0; j <= 1000000; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    \n    PriorityQueue pq;\n    initPriorityQueue(&pq, M * 2);\n    \n    dist[1][0] = 0;\n    push(&pq, 1);\n    push(&pq, 0);\n    push(&pq, 0);\n    \n    int result = -1;\n    \n    while (pq.size > 0) {\n        int currentStation = pop(&pq);\n        int currentCompany = pop(&pq);\n        int currentCost = pop(&pq);\n        \n        if (currentStation == N) {\n            result = currentCost;\n            break;\n        }\n        \n        if (currentCost > dist[currentStation][currentCompany]) continue;\n        \n        for (int i = 0; i < adjSize[currentStation]; i++) {\n            Node neighbor = adj[currentStation][i];\n            int newCost = currentCost + (neighbor.company != currentCompany ? 1 : 0);\n            if (newCost < dist[neighbor.station][neighbor.company]) {\n                dist[neighbor.station][neighbor.company] = newCost;\n                push(&pq, neighbor.station);\n                push(&pq, neighbor.company);\n                push(&pq, newCost);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", result);\n    \n    for (int i = 1; i <= N; i++) {\n        free(adj[i]);\n        free(dist[i]);\n    }\n    free(adj);\n    free(adjSize);\n    free(adjCapacity);\n    free(dist);\n    free(pq.data);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int company;\n};\n\nstruct State {\n    int station;\n    int company;\n    int cost;\n    bool operator>(const State& other) const {\n        return cost > other.cost;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<Edge>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int p, q, c;\n        cin >> p >> q >> c;\n        adj[p].push_back({q, c});\n        adj[q].push_back({p, c});\n    }\n\n    priority_queue<State, vector<State>, greater<State>> pq;\n    unordered_map<int, unordered_map<int, int>> dist;\n\n    pq.push({1, -1, 0});\n    dist[1][-1] = 0;\n\n    int ans = -1;\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.station == N) {\n            ans = current.cost;\n            break;\n        }\n\n        if (current.cost > dist[current.station][current.company]) {\n            continue;\n        }\n\n        for (const Edge& edge : adj[current.station]) {\n            int new_cost = current.cost;\n            if (edge.company != current.company) {\n                new_cost += 1;\n            }\n            if (dist.find(edge.to) == dist.end() || dist[edge.to].find(edge.company) == dist[edge.to].end() || new_cost < dist[edge.to][edge.company]) {\n                dist[edge.to][edge.company] = new_cost;\n                pq.push({edge.to, edge.company, new_cost});\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        int to, company;\n        Edge(int to, int company) {\n            this.to = to;\n            this.company = company;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            int c = sc.nextInt();\n            adj.get(p).add(new Edge(q, c));\n            adj.get(q).add(new Edge(p, c));\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        Map<String, Integer> dist = new HashMap<>();\n        pq.offer(new int[]{1, -1, 0});\n        dist.put(\"1,-1\", 0);\n\n        int res = -1;\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int u = curr[0];\n            int prevCompany = curr[1];\n            int fare = curr[2];\n\n            if (u == N) {\n                res = fare;\n                break;\n            }\n\n            for (Edge e : adj.get(u)) {\n                int v = e.to;\n                int c = e.company;\n                int newFare = fare + (c == prevCompany ? 0 : 1);\n                String key = v + \",\" + c;\n                if (!dist.containsKey(key) || newFare < dist.get(key)) {\n                    dist.put(key, newFare);\n                    pq.offer(new int[]{v, c, newFare});\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:36:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnukeSubway {\n    public static int minimumFare(int N, int M, int[][] lines) {\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int i = 1; i <= N; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n        \n        for (int[] line : lines) {\n            int u = line[0], v = line[1], company = line[2];\n            graph.get(u).add(new int[]{v, company});\n            graph.get(v).add(new int[]{u, company});\n        }\n        \n        int[][] dist = new int[N+1][M+1];\n        for (int[] row : dist) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        for (int company = 1; company <= M; company++) {\n            dist[1][company] = 0;\n            pq.offer(new int[]{1, company, 0});\n        }\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int station = curr[0], currCompany = curr[1], fare = curr[2];\n            \n            if (station == N) return fare;\n            \n            if (fare > dist[station][currCompany]) continue;\n            \n            for (int[] next : graph.get(station)) {\n                int nextStation = next[0], nextCompany = next[1];\n                \n                int newFare = fare + (currCompany == nextCompany ? 0 : 1);\n                \n                if (newFare < dist[nextStation][nextCompany]) {\n                    dist[nextStation][nextCompany] = newFare;\n                    pq.offer(new int[]{nextStation, nextCompany, newFare});\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int[][] lines = new int[M][3];\n        \n        for (int i = 0; i < M; i++) {\n            lines[i][0] = sc.nextInt();\n            lines[i][1] = sc.nextInt();\n            lines[i][2] = sc.nextInt();\n        }\n        \n        System.out.println(minimumFare(N, M, lines));\n    }\n}",
    "timestamp": "2025-08-05 23:37:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nconst int INF = 1e9;\n\nvector<pair<int, int>> graph[MAX_N];\nint dist[MAX_N];\n\nint dijkstra(int N, int M) {\n    for (int i = 1; i <= N; i++) dist[i] = INF;\n    dist[1] = 0;\n    \n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\n    pq.push({0, {1, -1}});\n    \n    while (!pq.empty()) {\n        int cost = pq.top().first;\n        int curr = pq.top().second.first;\n        int prev_company = pq.top().second.second;\n        pq.pop();\n        \n        if (cost > dist[curr]) continue;\n        \n        if (curr == N) return cost;\n        \n        for (auto& edge : graph[curr]) {\n            int next = edge.first;\n            int company = edge.second;\n            \n            int new_cost = cost;\n            if (prev_company != -1 && prev_company != company) {\n                new_cost++;\n            }\n            \n            if (new_cost < dist[next]) {\n                dist[next] = new_cost;\n                pq.push({new_cost, {next, company}});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n    \n    cout << dijkstra(N, M) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef min_fare(N, M, edges):\n    # Create graph with structure: station -> [(adjacent_station, company)]\n    graph = defaultdict(list)\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    \n    # Initialize distances and queue\n    INF = float('inf')\n    dist = [[INF] * (M + 1) for _ in range(N + 1)]\n    queue = deque()\n    \n    # Starting point\n    dist[1][0] = 0\n    queue.append((1, 0, 0))  # (station, cost, last_company_used)\n    \n    while queue:\n        u, cost, last_company = queue.popleft()\n        \n        for v, company in graph[u]:\n            # Calculate new cost\n            new_cost = cost + (1 if company != last_company and last_company != 0 else 0) + 1\n            \n            if new_cost < dist[v][company]:\n                dist[v][company] = new_cost\n                queue.append((v, new_cost, company))\n    \n    # Find minimum fare to reach station N\n    min_fare = min(dist[N])\n    return min_fare if min_fare != INF else -1\n\n# Example usage, assuming edges are specified as (station1, station2, company)\nN, M = 5, 5\nedges = [\n    (1, 2, 1), \n    (2, 3, 2), \n    (3, 4, 1),\n    (4, 5, 2),\n    (1, 5, 3)\n]\n\nprint(min_fare(N, M, edges))",
    "timestamp": "2025-08-13 16:20:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnukeSubway {\n    static class Edge {\n        int to, company;\n        Edge(int to, int company) {\n            this.to = to;\n            this.company = company;\n        }\n    }\n\n    static class State {\n        int station, fare, company;\n        State(int station, int fare, int company) {\n            this.station = station;\n            this.fare = fare;\n            this.company = company;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        List<Edge>[] graph = new ArrayList[n + 1];\n        for (int i = 1; i <= n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int c = sc.nextInt();\n            graph[u].add(new Edge(v, c));\n            graph[v].add(new Edge(u, c));\n        }\n        \n        int[] minFare = new int[n + 1];\n        Arrays.fill(minFare, Integer.MAX_VALUE);\n        minFare[1] = 0;\n        \n        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.fare));\n        pq.offer(new State(1, 0, -1));\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.station == n) {\n                System.out.println(current.fare);\n                return;\n            }\n            \n            if (current.fare > minFare[current.station]) continue;\n            \n            for (Edge edge: graph[current.station]) {\n                int addedFare = current.company == edge.company ? 1 : 2;\n                int newFare = current.fare + addedFare;\n                \n                if (newFare < minFare[edge.to]) {\n                    minFare[edge.to] = newFare;\n                    pq.offer(new State(edge.to, newFare, edge.company));\n                }\n            }\n        }\n        \n        System.out.println(-1);\n    }\n}",
    "timestamp": "2025-08-13 16:20:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_STATIONS 100001\n#define MAX_COMPANIES 100\n\ntypedef struct {\n    int to, comp;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_COMPANIES];\n    int size;\n} AdjList;\n\ntypedef struct {\n    int station, cost, company;\n} Node;\n\ntypedef struct {\n    Node nodes[MAX_STATIONS * MAX_COMPANIES];\n    int size;\n} PriorityQueue;\n\nvoid push(PriorityQueue* pq, Node item) {\n    int i = pq->size++;\n    while (i > 0) {\n        int p = (i - 1) / 2;\n        if (pq->nodes[p].cost <= item.cost) break;\n        pq->nodes[i] = pq->nodes[p];\n        i = p;\n    }\n    pq->nodes[i] = item;\n}\n\nNode pop(PriorityQueue* pq) {\n    Node res = pq->nodes[0];\n    Node temp = pq->nodes[--pq->size];\n    int i = 0;\n    while (i * 2 + 1 < pq->size) {\n        int left = i * 2 + 1, right = i * 2 + 2;\n        int min = (right < pq->size && pq->nodes[right].cost < pq->nodes[left].cost) ?\n                   right : left;\n        if (pq->nodes[min].cost >= temp.cost) break;\n        pq->nodes[i] = pq->nodes[min];\n        i = min;\n    }\n    pq->nodes[i] = temp;\n    return res;\n}\n\nint dijkstra(AdjList* graph, int N, int M) {\n    PriorityQueue pq = { .size = 0 };\n    bool visited[MAX_STATIONS][MAX_COMPANIES] = { {false} };\n    int dist[MAX_STATIONS][MAX_COMPANIES];\n\n    for (int i = 0; i <= N; i++)\n        for (int j = 0; j < MAX_COMPANIES; j++)\n            dist[i][j] = INT_MAX;\n\n    for (int i = 0; i < graph[1].size; i++) {\n        int comp = graph[1].edges[i].comp;\n        dist[1][comp] = 0;\n        push(&pq, (Node){1, 0, comp});\n    }\n\n    while (pq.size > 0) {\n        Node cur = pop(&pq);\n        if (cur.station == N) return cur.cost;\n        if (visited[cur.station][cur.company]) continue;\n        visited[cur.station][cur.company] = true;\n\n        for (int i = 0; i < graph[cur.station].size; i++) {\n            Edge edge = graph[cur.station].edges[i];\n            int nextCost = cur.cost + (cur.company == edge.comp ? 0 : 1);\n            if (nextCost < dist[edge.to][edge.comp]) {\n                dist[edge.to][edge.comp] = nextCost;\n                push(&pq, (Node){edge.to, nextCost, edge.comp});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n    AdjList graph[MAX_STATIONS] = {0};\n\n    for (int i = 0; i < M; i++) {\n        int u, v, c;\n        scanf(\"%d%d%d\", &u, &v, &c);\n        graph[u].edges[graph[u].size++] = (Edge){v, c};\n        graph[v].edges[graph[v].size++] = (Edge){u, c};\n    }\n\n    printf(\"%d\\n\", dijkstra(graph, N, M));\n    return 0;\n}",
    "timestamp": "2025-08-13 16:21:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to, company;\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<Edge>> graph(N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        graph[u].push_back({v, c});\n        graph[v].push_back({u, c});\n    }\n    \n    vector<vector<int>> dist(N + 1, vector<int>(M + 1, INT_MAX));\n    priority_queue<tuple<int, int, int>,\n        vector<tuple<int, int, int>>,\n        greater<tuple<int, int, int>>> pq;\n    \n    dist[1][0] = 0;\n    pq.emplace(0, 1, 0);\n    \n    while (!pq.empty()) {\n        auto [cost, u, company] = pq.top();\n        pq.pop();\n        \n        if (dist[u][company] < cost) continue;\n        \n        for (auto & edge : graph[u]) {\n            int v = edge.to;\n            int c = edge.company;\n            int new_cost = (company == 0 || c == company) ? cost : cost + 1;\n            \n            if (new_cost < dist[v][c]) {\n                dist[v][c] = new_cost;\n                pq.emplace(new_cost, v, c);\n            }\n        }\n    }\n    \n    int result = INT_MAX;\n    for (int i = 1; i <= M; ++i) {\n        result = min(result, dist[N][i]);\n    }\n    \n    cout << (result == INT_MAX ? -1 : result) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:21:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, M, lines):\n    graph = defaultdict(list)\n    company_lines = defaultdict(list)\n    \n    for u, v, c in lines:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n        company_lines[c].append((u, v))\n    \n    dist = [[float('inf')] * (len(company_lines) + 1) for _ in range(N + 1)]\n    dist[1][0] = 0\n    \n    queue = deque([(1, 0, 0)])\n    \n    while queue:\n        curr, curr_fare, last_company = queue.popleft()\n        \n        if curr == N:\n            return curr_fare\n        \n        for next_station, company in graph[curr]:\n            # Using same company\n            if company == last_company or last_company == 0:\n                if curr_fare < dist[next_station][company]:\n                    dist[next_station][company] = curr_fare\n                    queue.appendleft((next_station, curr_fare, company))\n            \n            # Changing company\n            else:\n                new_fare = curr_fare + 1\n                if new_fare < dist[next_station][company]:\n                    dist[next_station][company] = new_fare\n                    queue.append((next_station, new_fare, company))\n    \n    return -1\n\ndef main():\n    N, M = map(int, input().split())\n    lines = []\n    for _ in range(M):\n        u, v, c = map(int, input().split())\n        lines.append((u, v, c))\n    \n    result = solve(N, M, lines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:21:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        p = int(data[idx])\n        q = int(data[idx+1])\n        c = int(data[idx+2])\n        idx += 3\n        adj[p].append((q, c))\n        adj[q].append((p, c))\n    \n    INF = float('inf')\n    # dist is a dictionary: key is (station, company), value is min cost\n    dist = {}\n    heap = []\n    \n    # Initialize for station 1\n    for q, c in adj[1]:\n        heapq.heappush(heap, (1, q, c))\n        dist[(q, c)] = 1\n    \n    heapq.heappush(heap, (1, 1, -1))  # company -1 represents no line used yet\n    dist[(1, -1)] = 1\n    \n    found = False\n    answer = INF\n    \n    while heap:\n        current_cost, u, current_company = heapq.heappop(heap)\n        if u == N:\n            answer = current_cost\n            found = True\n            break\n        if current_cost > dist.get((u, current_company), INF):\n            continue\n        for v, next_company in adj[u]:\n            new_cost = current_cost\n            if next_company != current_company:\n                new_cost += 1\n            if (v, next_company) not in dist or new_cost < dist.get((v, next_company), INF):\n                dist[(v, next_company)] = new_cost\n                heapq.heappush(heap, (new_cost, v, next_company))\n    \n    if found:\n        print(answer)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 16:21:30"
  }
]