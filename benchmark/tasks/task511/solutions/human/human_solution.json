[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nobject Main extends App {\n  import scala.io.StdIn._\n  val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.tabulate(h){_ ⇒ readLine.trim.toCharArray}\n  val hatch = (0 until w).flatMap(x ⇒ (0 until h).filter(y ⇒ state(y)(x) == '%').map(y ⇒ Coordinate(x, y))).head\n  val princess = (0 until w).flatMap(x ⇒ (0 until h).filter(y ⇒ state(y)(x) == '@').map(y ⇒ Coordinate(x, y))).head\n  val minCost = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ -1}}\n  minCost(hatch.y)(hatch.x) == 0\n  val queue = mutable.Queue[Coordinate](hatch)\n\n  while(queue.nonEmpty){\n    val top = queue.dequeue()\n    for (next ← top.neighbors if (0 until w).contains(next.x) && (0 until h).contains(next.y) && minCost(next.y)(next.x) == -1){\n      minCost(next.y)(next.x) = minCost(top.y)(top.x) + 1\n      queue.enqueue(next)\n    }\n  }\n\n  println(\n    if ((0 until w).exists(x ⇒ (0 until h).exists(y ⇒ state(y)(x) == '$' && minCost(y)(x) <= minCost(princess.y)(princess.x)))) \"No\" else \"Yes\"\n  )\n\n  case class Coordinate(x: Int, y: Int) {\n    def neighbors: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nobject Main extends App {\n  import scala.io.StdIn._\n  val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.tabulate(h){_ ⇒ readLine.trim.toCharArray}\n  val hatch = (0 until w).flatMap(x ⇒ (0 until h).filter(y ⇒ state(y)(x) == '%').map(y ⇒ Coordinate(x, y))).head\n  val princess = (0 until w).flatMap(x ⇒ (0 until h).filter(y ⇒ state(y)(x) == '@').map(y ⇒ Coordinate(x, y))).head\n  val minCost = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ -1}}\n  minCost(hatch.y)(hatch.x) == 0\n  val queue = mutable.Queue[Coordinate](hatch)\n\n  while(queue.nonEmpty){\n    val top = queue.dequeue()\n    for (next ← top.neighbors if (0 until w).contains(next.x) && (0 until h).contains(next.y) && minCost(next.y)(next.x) == -1 && state(next.y)(next.x) != '#'){\n      minCost(next.y)(next.x) = minCost(top.y)(top.x) + 1\n      queue.enqueue(next)\n    }\n  }\n\n  println(\n    if ((0 until w).exists(x ⇒ (0 until h).exists(y ⇒ state(y)(x) == '$' && minCost(y)(x) <= minCost(princess.y)(princess.x)))) \"No\" else \"Yes\"\n  )\n\n  case class Coordinate(x: Int, y: Int) {\n    def neighbors: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t//\tint cnt = 0;\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\tms[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (ms[p.second][p.first] <= tmp[p.second][p.first])continue;\n\t\t\tms[p.second][p.first] = min(ms[p.second][p.first], tmp[p.second][p.first]);\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\t//cout << cnt <<\" \"<<nx<<\" \"<<ny<< endl;\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint h, w;\nchar b[200][200];\nint pri[200][200];\nint sol[200][200];\nqueue<int> que;\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        pri[i][j] = INF;\n        sol[i][j] = INF;\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '$'){\n            que.push(i*200+j);\n            sol[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int hh = q/200, ww = q%200;\n        rep(i,4){\n            int y = q/200+dh[i], x = q%200+dw[i];\n            if(0>y||y>=h||0>x||x>=w) continue;\n            if(sol[y][x] <= sol[hh][ww]+1) continue;\n            if(b[y][x] == '#') continue;\n            sol[y][x] = sol[hh][ww]+1;\n            que.push(y*200+x);\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '@'){\n            que.push(i*200+j);\n            pri[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int hh = q/200, ww = q%200;\n        rep(i,4){\n            int y = hh+dh[i], x = ww+dw[i];\n            if(0>y||y>=h||0>x||x>=w) continue;\n            if(pri[y][x] <= pri[hh][ww]+1) continue;\n            if(sol[y][x] <= pri[hh][ww]+1) continue;\n            if(b[y][x] == '#') continue;\n            pri[y][x] = pri[hh][ww]+1;\n            que.push(y*200+x);\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '%'){\n            if(pri[i][j] != INF){\n                cout << \"Yes\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nstring maze[210];\nint d[210][210], dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, h, w, gx, gy;\nint bfs(int sx, int sy) {\n\tqueue<PII> que;\n\tREP(i, h) REP(j, w) d[i][j] = INF;\n\tque.push(PII(sx, sy));\n\td[sy][sx] = 0;\n\twhile(que.size()) {\n\t\tPII p = que.front(); que.pop();\n\t\t//cout << p.first << \" \" << p.second << endl;\n\t\t//if(p.first == gx && p.second == gy) break;\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && maze[ny][nx] != '#' && d[ny][nx] == INF) {\n\t\t\t\tque.push(PII(nx, ny));\n\t\t\t\td[ny][nx] = d[p.second][p.first] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*REP(i, h) {\n\t\tREP(j, w) {\n\t\t\tcout << d[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn d[gy][gx];\n}\n\nsigned main(void)\n{\n\tcin >> h >> w;\n\tREP(i, h) cin >> maze[i];\n\n\tint py, px;\n\tVI sy, sx;\n\tREP(i, h) REP(j, w) {\n\t\tif(maze[i][j] == '@') {py = i; px = j;}\n\t\telse if(maze[i][j] == '$') {sy.PB(i); sx.PB(j);}\n\t\telse if(maze[i][j] == '%') {gy = i; gx = j;}\n\t}\n\n\tbfs(gx, gy);\n\n\tint p = d[py][px];\n\tint s = INF;\n\tREP(i, sx.size()) s = min(s, d[sy[i]][sx[i]]);\n\n\t//cout << p << \" \" << s << endl;\n\t/*REP(i, h) {\n\t\tREP(j, w) {\n\t\t\tcout << d[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(s <= p) cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m;\n  cin >> n >> m;\n  string s[n];\n  rep(i,n) R s[i];\n  vector<P> v;\n  int d[n][m];\n  rep(i,n)rep(j,m)d[i][j]=MAX;\n  queue<P> que;\n  rep(i,n)rep(j,m) {\n    if(s[i][j]=='%') {\n      d[i][j]=0;\n      que.push(P(i,j));\n    }\n    if(s[i][j]=='@') v.pb(P(i,j));\n  }\n  rep(i,n)rep(j,m)if(s[i][j]=='$') v.pb(P(i,j));\n  while(!que.empty()) {\n    P p=que.front();que.pop();\n    rep(i,4) {\n      int x=p.F+dx[i],y=p.S+dy[i];\n      if(!check(n,m,x,y)||d[x][y]<=d[p.F][p.S]+1||s[x][y]=='#') continue;\n      d[x][y]=d[p.F][p.S]+1;\n      que.push(P(x,y));\n    }\n  }\n  bool f=1;\n  REP(i,1,v.size()) {\n    if(d[v[0].F][v[0].S]>=d[v[i].F][v[i].S]) f=0;\n  }\n  if(f) pr(\"Yes\");\n  else pr(\"No\");\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nusing T3=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    char M[H][W];\n    int dist[H][W];\n    queue<T3> Q;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>M[i][j];\n            if(M[i][j]=='%'){\n                dist[i][j]=0;\n                Q.push(T3(i,j,0));\n            }else{\n                dist[i][j]=1000000;\n            }\n        }\n    }\n    int dist_p = 1000000, dist_s=1000000;\n    while(!Q.empty()){\n        int i,j,d;\n        tie(i,j,d)=Q.front();\n        Q.pop();\n        if(dist[i][j]<d) continue;\n        else dist[i][j]=d;\n        if(M[i][j]=='@') dist_p=d;\n        if(M[i][j]=='$') dist_s=min(dist_s,d);\n        int diff[5]={0,-1,0,1,0};\n        for(int k=0;k<4;k++){\n            if(i+diff[k]<0||i+diff[k]>=H||j+diff[k+1]<0||j+diff[k+1]>=W) continue;\n            if(M[i+diff[k]][j+diff[k+1]]!='#'&&dist[i+diff[k]][j+diff[k+1]]==1000000){\n                Q.push(T3(i+diff[k],j+diff[k+1],d+1));\n            }\n        }\n    }\n    if(dist_p<dist_s){\n        cout<<\"Yes\"<<endl;\n    }else{\n        cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 210;\nint h, w;\nchar field[MAX_N][MAX_N];\nint table[MAX_N][MAX_N];\nint princess;\nint soldier = INF;\nvoid bfs(int y, int x)\n{\n    table[y][x] = 0;\n    queue<P> que;\n    que.push(P(y, x));\n    while(!que.empty())\n    {\n        P p = que.front(); que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n            if(table[ny][nx] >= 0 || field[ny][nx] == '#') continue;\n            table[ny][nx] = table[p.first][p.second] + 1;\n            if(field[ny][nx] == '@') princess = table[ny][nx];\n            if(field[ny][nx] == '$') soldier = min(table[ny][nx], soldier);\n            que.push(P(ny, nx));\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    int sy, sx;\n    memset(table, - 1, sizeof(table));\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++) \n        {\n            cin >> field[i][j];\n            if(field[i][j] == '%') sy = i, sx = j;\n        }\n    }\n    bfs(sy, sx);\n    cout << (princess < soldier ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define sf scanf\n#define pf printf\n#define ll long long\n#define fr(I,M,N) for(I=M;I<=N;I++)\n#define fr_(I,M,N) for(I=M;I>=N;I--)\n#define re return\n#define sfn cin>>n\n#define bal pf(\"bal\\n\")\n#define pb push_back\n#define ins insert\n#define sz(X) X.size()\n#define xx first\n#define yy second\n#define skip continue\n#define memo(X,N) memset(X,N,sizeof(X))\n#define all(X) X.begin(),X.end()\n#define mp make_pair\n#define pi acos(-1)\n\n\n/*\n#define nMX 5000000\n#define pMX 500000\nint pr[pMX+1],prnum[nMX+1];\n\nint sieve()\n{\n    int i,j;\n    for(i=1;i<=nMX;i++)\n        prnum[i]=i+1;\n    for(i=1;i<=nMX;i++)\n        if(prnum[i]!=-1)\n            for(j=2*prnum[i]-1;j<=nMX;j+=prnum[i])\n                    prnum[j]=-1;\n    j=0;\n    for(i=1;i<=nMX;i++)\n        if(prnum[i]!=-1)\n            pr[++j]=prnum[i];\n    re j;\n}*/\n\n/*ll m_ncr[10001][10001];\nll ncr(ll i,ll j)\n{\n    if(j==1) re i;\n    if(i==j) re 1;\n    if(m_ncr[i][j]!=-1) re m_ncr[i][j];\n    re m_ncr[i][j]=ncr(i-1,j) + ncr(i-1,j-1);\n}*/\n\n/*ll m_fact[21];\nll fact(ll i)\n{\n    if(i==1 || i==0) re 1;\n    if(m_fact[i]!=-1) re m_fact[i];\n    re m_fact[i]=i*fact(i-1);\n}*/\n\n//cout<<\"Case \"<<++cas<<\": \"<<<<endl;\n\n\nint cas;\nint n,m,tt[202][202];\nstring s[202];\n\nvoid upd(int i,int j,int x)\n{\n    if(i>n || j>m || i<0 || j<0) re;\n    if(s[i][j]=='#') re;\n    if(tt[i][j]<=x) re;\n    tt[i][j]=x;\n    upd(i+1,j,x+1);\n    upd(i,j+1,x+1);\n    upd(i-1,j,x+1);\n    upd(i,j-1,x+1);\n}\n\nint doit(int i,int j,int x)\n{\n    if(i>n || j>m || i<0 || j<0) re 0;\n    if(s[i][j]=='#') re 0;\n    if(tt[i][j]<=x) re 0;\n    tt[i][j]=x;\n    if(s[i][j]=='%') re 1;\n    int r=0;\n    r+=doit(i+1,j,x+1);\n    r+=doit(i,j+1,x+1);\n    r+=doit(i-1,j,x+1);\n    r+=doit(i,j-1,x+1);\n    re r;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    int i,j,x,cnt=0,y,k,g,flg,t;\n    cin>>n>>m;\n    n--;\n    m--;\n    fr(i,0,n)\n    {\n        cin>>s[i];\n    }\n    fr(i,0,n+1) fr(j,0,m+1) tt[i][j]=1e9;\n    fr(i,0,n)\n    {\n        fr(j,0,m)\n        {\n            if(s[i][j]=='$')\n                upd(i,j,0);\n        }\n    }\n    x=-1;\n    fr(i,0,n)\n    {\n        fr(j,0,m)\n        {\n            if(s[i][j]=='@')\n            {\n                x=doit(i,j,0);\n                break;\n            }\n        }\n        if(x!=-1) break;\n    }\n    if(x) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nusing T3=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    char M[H][W];\n    int dist[H][W];\n    queue<T3> Q;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>M[i][j];\n            if(M[i][j]=='%'){\n                dist[i][j]=0;\n                Q.push(T3(i,j,0));\n            }else{\n                dist[i][j]=1000000;\n            }\n        }\n    }\n    int dist_p = 1000000, dist_s=1000000;\n    while(!Q.empty()){\n        int i,j,d;\n        tie(i,j,d)=Q.front();\n        Q.pop();\n        if(dist[i][j]<d) continue;\n        else dist[i][j]=d;\n        if(M[i][j]=='@') dist_p=d;\n        if(M[i][j]=='$') dist_s=min(dist_s,d);\n        int diff[5]={0,-1,0,1,0};\n        for(int k=0;k<4;k++){\n            if(M[i+diff[k]][j+diff[k+1]]!='#'&&dist[i+diff[k]][j+diff[k+1]]==1000000){\n                Q.push(T3(i+diff[k],j+diff[k+1],d+1));\n            }\n        }\n    }\n    if(dist_p<dist_s){\n        cout<<\"Yes\"<<endl;\n    }else{\n        cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol,pri;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='$'){sol=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<w)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q1;\n  Q1.push(mk(mk(y,x),0));\n  while(!Q1.empty()){\n    pair<pair<int,int > ,int >a=Q1.front();Q1.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='@'){pri=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<w)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q1.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  if(pri<sol)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nint H, W;\nchar f[200][200];\n \nint bfs(queue<int>& px, queue<int>& py, int gx, int gy)\n{\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    auto qx = px, qy = py;\n    while (!px.empty()) {\n        int x = px.front(), y = py.front();\n        px.pop(); py.pop();\n        d[y][x] = 0;\n    }\n    const int dx[] = {-1, +1, +0, +0}, dy[] = {+0, +0, -1, +1};\n    while (!qx.empty()) {\n        int x = qx.front(), y = qy.front();\n        qx.pop(); qy.pop();\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (0 <= nx && nx < W && 0 <= ny && ny < H &&\n                f[ny][nx]=='.') {                \n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    qx.push(nx); qy.push(ny);\n                }\n            }\n        }\n    }\n    return d[gy][gx];\n}\n \nint main()\n{\n    int gx, gy;\n    cin >> H >> W;\n    queue<int> ax, ay, bx, by;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0 ; j < W; j++) {\n            cin >> f[i][j];\n            if (f[i][j] == '@') {\n                f[i][j] = '.';\n                ax.push(j); ay.push(i);\n            } else if (f[i][j] == '$') {\n                f[i][j] = '.';\n                bx.push(j); by.push(i);\n            } else if (f[i][j] == '%') {\n                f[i][j] = '.';\n                gx = j; gy = i;\n            }\n        }\n    }\n    cout << (bfs(ax, ay, gx, gy) < bfs(bx, by, gx, gy) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint n, m;\nchar b[200][200];\nint sol[200][200];\nint pre[200][200];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nqueue<int> que;\n\nint main(){\n    cin >> n >> m;\n    rep(i,n) rep(j,m) cin >> b[i][j];\n    rep(i,n) rep(j,m){\n        sol[i][j] = INF;\n        pre[i][j] = INF;\n    }\n    rep(i,n) rep(j,m){\n        if(b[i][j] == '$'){\n            que.push(i*200+j);\n            sol[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int y = q/200, x = q%200;\n        rep(i,4){\n            int yy = y+dy[i], xx = x+dx[i];\n            if(0>yy||yy>=n||0>xx||xx>=m) continue;\n            if(sol[yy][xx] <= sol[y][x]+1) continue;\n            sol[yy][xx] = sol[y][x]+1;\n            que.push(yy*200+xx);\n        }\n    }\n    rep(i,n) rep(j,m){\n        if(b[i][j] == '@'){\n            que.push(i*200+j);\n            pre[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int y = q/200, x = q%200;\n        rep(i,4){\n            int yy = y+dy[i], xx = x+dx[i];\n            if(0>yy||yy>=n||0>xx||xx>=m) continue;\n            if(pre[yy][xx] <= pre[y][x]+1) continue;\n            if(sol[yy][xx] <= pre[y][x]+1) continue;\n            pre[yy][xx] = pre[y][x]+1;\n            que.push(yy*200+xx);\n        }\n    }\n    rep(i,n) rep(j,m){\n        if(b[i][j] == '%'){\n            if(pre[i][j] != INF){\n                cout << \"Yes\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    //memset(dis, -1, sizeof(dis));\n    rep(i,h) rep(j,w) dis[i][j] = INF;\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == INF && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string M[H];\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n  }\n  int s_x, s_y, g_x, g_y;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == '%'){\n        s_x = i;\n        s_y = j;\n      }\n      if(M[i][j] == '@'){\n        g_x = i;\n        g_y = j;\n      }\n    }\n  }\n  int d[H][W];\n  for(int i = 0; i < H; ++i) fill(d[i],d[i]+W,-1);\n  d[s_x][s_y] = 0;\n  queue< pair<int,int> > que;\n  que.push(make_pair(s_x, s_y));\n  int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int i = 0; i < 4; ++i){\n      int next_x = x + dx[i], next_y = y + dy[i];\n      if(next_x >= 0 && next_x < H && next_y >= 0 && next_y < W && d[next_x][next_y] < 0 && M[next_x][next_y] != '#'){\n        d[next_x][next_y] = d[x][y] + 1;\n        que.push(make_pair(next_x, next_y));\n      }\n    }\n  }\n  int princess = 100000000, soldier = princess;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == '@') princess = min(princess, d[i][j]);\n      if(M[i][j] == '$') soldier = min(soldier, d[i][j]);\n      \n    }\n  }\n  if(princess < soldier) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nstruct Data {\n    int x, y, c;\n    Data(int x, int y, int c) : x(x), y(y), c(c) {}\n};\n\nint main () {\n    int H, W;\n    cin >> H >> W;\n    queue<Data> q;\n    queue<Data> s;\n    int gx, gy;\n    vector<vector<char>> ml(H + 2, vector<char>(W + 2, '#'));\n    REP (i, 1, H + 1) REP (j, 1, W + 1) {\n        cin >> ml[i][j];\n        if (ml[i][j] == '@') {\n            q.emplace(j, i, 0);\n        }\n        else if (ml[i][j] == '%') {\n            gy = i;\n            gx = j;\n        }\n        else if (ml[i][j] == '$') {\n            s.emplace(j, i, 0);\n        }\n    }\n    const int inf = 1 << 30;\n    const int dx[4] = {0, 1, 0, -1};\n    const int dy[4] = {1, 0, -1, 0};\n    vector<vector<int>> pml(H + 2, vector<int>(W + 2, inf / 2));\n    vector<vector<int>> sml(H + 2, vector<int>(W + 2, inf));\n\n    auto func = [&ml, &dx, &dy](vector<vector<int>> &ps, queue<Data> &q) -> void {\n        while (q.size()) {\n            auto d = q.front();\n            q.pop();\n            if (ps[d.y][d.x] <= d.c) continue;\n            ps[d.y][d.x] = d.c;\n            REP (k, 0, 4) {\n                int nx = d.x + dx[k];\n                int ny = d.y + dy[k];\n                if (ml[ny][nx] == '#') continue;\n                q.emplace(nx, ny, d.c + 1);\n            }\n        }\n    };\n    func(pml, q);\n    func(sml, s);\n    cout << (pml[gy][gx] < sml[gy][gx] ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<time.h>\n#include<stack>\n#include<map>\n#include<queue>\n#include<set>\n#include<bitset>\n#include<vector>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int>V;\ntypedef pair<int , int > P;\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 2e18;\nconst double PI = acos(-1.0);\nconst double eps = 1e-9;\nconst int N = 5+2e2;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint dp[N][N];\nchar s[N][N];\nbool vis[N][N];\nint ans1, ans2, n, m;\n\nvoid bfs(int i, int j)\n{\n    dp[i][j] = 0;\n    ans1 = ans2 = 0;\n    queue<P>q;\n    while(!q.empty())   q.pop();\n    q.push(P(i, j));\n    while(!q.empty())\n    {\n        P p = q.front();    q.pop();\n        vis[p.x][p.y] = 1;\n        if(ans1&&ans2)  break;\n        if(s[p.x][p.y]=='@')    ans1 = dp[p.x][p.y];\n        if(s[p.x][p.y]=='$')    ans2 = dp[p.x][p.y];\n        for(int k = 0; k < 4; k ++)\n        {\n            int xx = dx[k]+p.x, yy = dy[k]+p.y;\n            if(xx==0||yy==0||xx>n||yy>m)    continue;\n            if(vis[xx][yy]) continue;\n            if(s[xx][yy] == '#')    continue;\n            dp[xx][yy] = dp[p.x][p.y] + 1;\n            q.push(P(xx, yy));\n        }\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m))\n    {\n        memset(dp, 0x3f, sizeof dp);\n        memset(vis, 0, sizeof vis);\n        for(int i = 1; i <= n; i ++)\n            scanf(\"%s\", s[i]+1);\n        for(int i = 1; i <= n; i ++)\n            for(int j = 1; j <= m; j ++)\n        {\n            if(s[i][j] == '%')\n                bfs(i, j);\n        }\n        if(ans1<ans2||ans2==0)   puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 210;\nint h, w;\nchar field[MAX_N][MAX_N];\nint table[MAX_N][MAX_N];\nint princess;\nint soldier = INF;\nvoid bfs(int y, int x)\n{\n    table[y][x] = 0;\n    queue<P> que;\n    que.push(P(y, x));\n    while(!que.empty())\n    {\n        P p = que.front(); que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n            if(table[ny][nx] >= 0 || field[ny][nx] == '#') continue;\n            table[ny][nx] = table[p.first][p.second] + 1;\n            if(field[ny][nx] == '@') princess = table[ny][nx];\n            if(field[ny][nx] == '$') soldier = min(table[ny][nx], soldier);\n            que.push(P(ny, nx));\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    int sy, sx;\n    memset(table, - 1, sizeof(table));\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++) \n        {\n            cin >> field[i][j];\n            if(field[i][j] == '%') sy = i, sx = j;\n        }\n    }\n    bfs(sy, sx);\n    cout << (princess < soldier ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define SF scanf\n#define PF printf\n#define PB push_back\n#define MP make_pair\n#define mx 5000001\n#define MOD 1000000007\n#define INP          freopen(\"in.txt\", \"r\", stdin);\n#define OUT          freopen(\"out.txt\", \"w\", stdout);\n#define BOOST        std::ios_base::sync_with_stdio(false);\n\nchar st[210][210];\nint vis[210][210];\nint sz1,sz2,ns,mm;\nqueue<pair<int,int> >pq;\nqueue<pair<int,int> >pq2;\nint fx[]={1,-1,0,0};\nint fy[]={0,0,1,-1};\nint level[210][210];\nint lev[210][210];\nvoid bfs2()\n{\n\n    pair<int,int>pp;\n\n    pp=pq2.front();\n    int x=pp.first;\n    int y=pp.second;\n    lev[x][y]=0;\n    vis[x][y]=1;\n    while(!pq2.empty())\n    {\n        pp=pq2.front();\n        pq2.pop();\n        int p1=pp.first;\n        int p2=pp.second;\n        for(int p=0;p<4;p++)\n        {\n            int x=p1+fx[p];\n            int y=p2+fy[p];\n            if(x>0&&x<=sz1&&y>0&&y<=sz2&&vis[x][y]==0&&(st[x][y]=='.'||st[x][y]=='%'))\n            {\n\n                pq2.push(MP(x,y));\n                lev[x][y]=lev[p1][p2]+1;\n                vis[x][y]=1;\n            }\n\n\n        }\n    }\n}\n\nvoid bfs3(int i,int j)\n{\n    level[i][j]=0;\n    pair<int,int>pp;\n    vis[i][j]=1;\n    pq.push(MP(i,j));\n    while(!pq.empty())\n    {\n        pp=pq.front();\n        pq.pop();\n        int p1=pp.first;\n        int p2=pp.second;\n        for(int p=0;p<4;p++)\n        {\n            int x=p1+fx[p];\n            int y=p2+fy[p];\n            if(x>0&&x<=sz1&&y>0&&y<=sz2&&vis[x][y]==0&&(st[x][y]=='.'||st[x][y]=='%'))\n            {\n\n\n                level[x][y]=level[p1][p2]+1;\n                if(level[x][y]<lev[x][y]||lev[x][y]==0)\n                {\n                    pq.push(MP(x,y));\n                    vis[x][y]=1;\n                }\n\n            }\n\n\n        }\n    }\n}\nint main()\n{\n\n\n    ll n,t,i,j,n1,k,m,f=0,s=0,c=0,p=1,c1=0,p1=0,p2=0,res=0,c2,s1,s2,ss,pp,x,y,q;\n    string st1,st2;\n   // SF(\"%lld\",&n);\n\n\n    cin>>sz1>>sz2;\n    ns=1000000;\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            cin>>st[i][j];\n            if(st[i][j]=='%')\n            {\n                x=i,y=j;\n            }\n        }\n    }\n    memset(vis,0,sizeof(vis));\n    memset(lev,0,sizeof(lev));\n    memset(level,0,sizeof(level));\n\n\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            if(st[i][j]=='$')\n            {\n                pq2.push(MP(i,j));\n            }\n\n        }\n    }\n    if(!pq2.empty())\n    bfs2();\n    memset(vis,0,sizeof(vis));\n    memset(level,0,sizeof(level));\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            if(st[i][j]=='@')\n            {\n                bfs3(i,j);\n            }\n\n        }\n    }\n    if(level[x][y]==0||(lev[x][y]!=0&&lev[x][y]<=level[x][y]))\n    {\n        //cout<<level[x][y]<<\" \"<<lev[x][y]<<endl;\n        cout<<\"No\"<<endl;\n\n    }\n    else\n    {\n        //cout<<level[x][y]<<\" \"<<lev[x][y]<<endl;\n        cout<<\"Yes\"<<endl;\n    }\n\n\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//幅優先探索\n//迷路の最短距離を求める\n//まず、盤面のサイズと、迷路のスタート地点とゴール地点の座標が与えられる。\n//次に、それぞれのマスが通行可能な空きマス(.)か通行不可能な壁マス(#)かという情報を持った盤面が与えられる。\n//スタート地点とゴール地点は必ず空きマスであり、スタート地点からゴール地点へは、空きマスを辿って必ずたどり着ける。\n\n// queue (FIFO) を使うのがスマート(atcoder調べ)\n// pop() := キューの先頭要素を削除\n// front() 先頭要素の参照\n// push() := キューの末尾にデータを追加\n// 出し入れするデータは座標\n\n// 入力例\n// 7 8\n// 2 2\n// 4 5\n// ########\n// #......#\n// #.######\n// #..#...#\n// #..##..#\n// ##.....#\n// ########\n\n// 出力例\n// 11\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint main(){\n\n    //入力\n    int r, c, si, sj, gi, gj;\n    cin >> r >> c;\n    \n    queue<pair<int, int> > p[2];\n    queue<pair<int, int> > s[2];\n    \n    // canGo[i][j] := (i, j) が壁ならばfalse, 通路ならばtrue\n    vector<vector<bool> > canGo(r + 2, vector<bool> (c + 2, false));\n    for(int i = 1; i <= r; i++){\n        for(int j = 1; j <= c; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else if(input == '$'){\n                s[0].push({i, j});\n            }else{\n                canGo[i][j] = true;\n\n                if(input == '@'){\n                    //canGo[i][j] = false;\n                    p[0].push({i, j});\n                }else if(input == '%'){\n                    gi = i;\n                    gj = j;\n                }\n\n            }\n        }\n    }\n\n    //cout << gi << \" \" << gj << endl;\n\n    int now = 0;\n\n    while(!p[now].empty()){\n\n        //兵士動いてください\n        //cout << \"soldier\" << endl;\n        while(!s[now].empty()){\n\n            int nowi = s[now].front().first;\n            int nowj = s[now].front().second;\n            \n            //cout << nowi << \" \" << nowj << endl;\n\n            s[now].pop();\n            if(nowi == gi && nowj == gj){\n                cout << \"No1\" << endl;\n                return 0;\n            }\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //その方向に進めるなら\n                if(canGo[nexti][nextj]){\n                    //そのマスにキューを追加し\n                    //再度検索することのないように壁で埋める\n                    s[(now + 1) % 2].push({nexti, nextj});\n                    canGo[nexti][nextj] = false;\n                }\n            }\n        }\n\n        //cout << endl;\n\n        //姫さんどうぞ\n        //cout << \"princess\" << endl;\n        while(!p[now].empty()){    //キュー画空になるまで\n            //キューの先頭要素を取り出す\n            //int nowcost = wait.front().first;\n            int nowi = p[now].front().first;\n            int nowj = p[now].front().second;\n\n            //cout << nowi << \" \" << nowj << endl;\n\n            p[now].pop();\n\n            //ゴールにたどり着いたらそのコストが答え\n            if(nowi == gi && nowj == gj){\n                cout << \"Yes\" << endl;\n                return 0;\n            }\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //その方向に進めるなら\n                if(canGo[nexti][nextj]){\n                    //そのマスにキューを追加し\n                    //再度検索することのないように壁で埋める\n                    p[(now + 1) % 2].push({nexti, nextj});                    \n                    canGo[nexti][nextj] = false;\n                }\n            }\n        }\n\n        now = (now + 1) % 2;\n\n    }\n    \n    cout << \"No2\" << endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nstring mp[N];\n\nint bfs(char s){\n  queue<P> Q;\n  int D[N][N]={};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) \n      if(mp[i][j]==s)Q.push(P(i,j)),D[i][j]=1;\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int y=t.first,x=t.second;\n    if(mp[y][x]=='\\%') return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||D[ny][nx]||mp[ny][nx]=='#')continue;\n      Q.push(P(ny,nx));\n      D[ny][nx]=D[y][x]+1;\n    }\n  }\n  return 1e9;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<((bfs('@')<bfs('$'))? \"Yes\":\"No\")<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y,z;\n};\nPoint operator-(const Point& a,const Point& b)\n{\n  Point ret={a.x-b.x,a.y-b.y,a.z-b.z};\n  return ret;\n}\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nPoint cross(Point a,Point b)\n{\n  Point ret={a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};\n  return ret;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\nstring board[210];\nint H,W;\nint sx,sy;\nint gx,gy;\nint primin=inf;\nint solmin=inf;\nint d[210][210];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\ntypedef pair<int,int> P;\nvoid solve(int sy,int sx,char decide)\n{\n  queue<P> que;\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  que.push(P(sy,sx));\n  while(!que.empty())\n    {\n      P p=que.front();que.pop();\n      gy=p.first;\n      gx=p.second;\n      if(board[p.first][p.second]==decide) break;\n      for(int i=0;i<4;i++)\n\t{\n\t  int ny=p.first+dy[i];\n\t  int nx=p.second+dx[i];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#' || d[ny][nx]!=inf) continue;\n\t  que.push(P(ny,nx));\n\t  d[ny][nx]=d[p.first][p.second]+1;\n\t}\n    }\n  if(decide=='@') primin=min(primin,d[gy][gx]);\n  else if(decide=='$') solmin=min(solmin,d[gy][gx]);\n}\n\nint main(int argc,char const* argv[])\n{\n  cin >> H >> W;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n   \n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='%')\n\t    {\n\t      sy=i,sx=j;\n\t    }\n\t}\n    }\n  solve(sy,sx,'@');\n  solve(sy,sx,'$');\n  if(primin>=solmin){cout << \"No\" << endl;}\n  else{cout << \"Yes\" << endl;}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t//\tint cnt = 0;\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\tms[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (ms[p.second][p.first] < tmp[p.second][p.first])continue;\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tms[ny][nx] = min(ms[ny][nx],tmp[ny][nx]);\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\t//cout << cnt <<\" \"<<nx<<\" \"<<ny<< endl;\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\nint n,m;\nchar mp[205][205];\nbool In(int x,int y){\n\tif (x<=0 || y<=0 || x>n || y>m){\n\t\treturn false;\n\t}\n\treturn true;\n}\nint Ex,Ey;\nint dist1[205][205];\nint dist2[205][205];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nbool vis[205][205];\nint bfs1(int x,int y){\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(x,y));\n\tdist1[x][y]=0;\n\tvis[x][y]=true;\n\twhile (!q.empty()){\n\t\tpair<int,int> t=q.front();\n\t\tq.pop();\n\t\tint x=t.first;\n\t\tint y=t.second;\n\t\tfor (int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i];\n\t\t\tint ny=y+dy[i];\n\t\t\t//cout<<nx<<\" \"<<ny<<endl;\n\t\t\tif (!In(nx,ny)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mp[nx][ny]=='#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vis[nx][ny]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mp[nx][ny]=='@'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist1[nx][ny]=dist1[x][y]+1;\n\t\t\tvis[nx][ny]=true;\n\t\t\tq.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\nint bfs2(int x,int y){\n\tqueue<pair<int,int> > q;\n\twhile (!q.empty()){\n\t\tq.pop();\n\t}\n\tq.push(make_pair(x,y));\n\tdist2[x][y]=0;\n\tvis[x][y]=true;\n\twhile (!q.empty()){\n\t\tpair<int,int> t=q.front();\n\t\tq.pop();\n\t\tint x=t.first;\n\t\tint y=t.second;\n\t\tfor (int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i];\n\t\t\tint ny=y+dy[i];\n\t\t\t//cout<<nx<<\" \"<<ny<<endl;\n\t\t\tif (!In(nx,ny)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mp[nx][ny]=='#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vis[nx][ny]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mp[nx][ny]=='$'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist2[nx][ny]=dist2[x][y]+1;\n\t\t\tvis[nx][ny]=true;\n\t\t\tq.push(make_pair(nx,ny));\n\t\t}\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tcin>>mp[i][j];\n\t\t\tif (mp[i][j]=='%'){\n\t\t\t\tEx=i;\n\t\t\t\tEy=j;\n\t\t\t}\n\t\t}\n\t}\n\tbfs1(Ex,Ey);\n\tmemset(vis,0,sizeof(vis));\n\tbfs2(Ex,Ey);\n\tint mn=1e9;\n\tint Plen=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (mp[i][j]=='$'){\n\t\t\t\tif (dist1[i][j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmn=min(mn,dist1[i][j]);\n\t\t\t}\n\t\t\tif (mp[i][j]=='@'){\n\t\t\t\tPlen=dist2[i][j];\n\t\t\t}\n\t\t}\n\t}\n/*\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tcout<<dist1[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tcout<<dist2[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tif (Plen==0){\n\t\tcout<<\"No\";\n\t}\n\telse if (mn<=Plen){\n\t\tcout<<\"No\";\n\t}\n\telse{\n\t\tcout<<\"Yes\";\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdist = arg_dist;\n\t}\n\tInfo(){\n\t\trow = 0,col = 0,dist = 0;\n\t}\n\n\tint row,col,dist;\n};\n\nint H,W,div_row[4] = {-1,0,0,1},div_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint escape_row,escape_col;\n\tscanf(\"%d %d\",&H,&W);\n\tchar map[200][201];\n\n\tint distance[200][200];\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W;k++){\n\t\t\tdistance[i][k] = -1;\n\t\t\tif(map[i][k] == '%'){\n\t\t\t\tescape_row = i;\n\t\t\t\tescape_col = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tdistance[escape_row][escape_col] = 0;\n\n\tint prin = -1,enemy = 50000;\n\n\tqueue<Info> Q;\n\n\tQ.push(Info(escape_row,escape_col,0));\n\tInfo current;\n\n\twhile(!Q.empty()){\n\t\tcurrent = Q.front();\n\t\tQ.pop();\n\n\t\tif(map[current.row][current.col] == '@'){\n\t\t\tif(prin == -1){\n\t\t\t\tprin = current.dist;\n\t\t\t}else{\n\t\t\t\tprin = min(prin,current.dist);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}else if(map[current.row][current.col] == '$'){\n\t\t\tenemy = min(enemy,current.dist);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif((prin != -1 && current.dist >= prin) || (current.dist >= enemy))continue;\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(rangeCheck(current.row+div_row[i],current.col+div_col[i]) == true && map[current.row+div_row[i]][current.col+div_col[i]] != '#' &&\n\t\t\t\t\t(distance[current.row+div_row[i]][current.col+div_col[i]] == -1 || distance[current.row+div_row[i]][current.col+div_col[i]] > current.dist+1)){\n\t\t\t\tdistance[current.row+div_row[i]][current.col+div_col[i]] = current.dist+1;\n\t\t\t\tQ.push(Info(current.row+div_row[i],current.col+div_col[i],current.dist+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(prin == -1 || prin >= enemy){\n\t\tprintf(\"No\\n\");\n\t}else{\n\t\tprintf(\"Yes\\n\");\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nusing P = std::pair<int, int>;\n\n\nvector<vector<int>> bfs(vector<string> const& v, int y, int x) {\n    vector<vector<int>> d(v.size(), vector<int>(v[0].size(), 1e9));\n    d[y][x] = 0;\n    queue<P> que;\n    que.push(P{y, x});\n    while(!que.empty()) {\n        P p = que.front(); que.pop();\n        int dx[4] = {0, 1, 0, -1},\n            dy[4] = {1, 0, -1, 0};\n        for(int i=0; i<4; ++i) {\n            int ny = p.first + dy[i], nx = p.second + dx[i];\n            if(0 <= ny && ny < v.size() && 0 <= nx && nx < v[0].size() && v[ny][nx] != '#' && d[ny][nx] == 1e9) {\n                que.push(P{ny, nx});\n                d[ny][nx] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> v(H);\n    for(int i=0; i<H; ++i) {\n        cin >> v[i];\n    }\n    vector<vector<int>> d;\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if(v[i][j] == '%') {\n                d = bfs(v, i, j);\n            }\n        }\n    }\n    int p=0, s=1e9;\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            if(v[i][j] == '@') {\n                p = d[i][j];\n            }\n            if(v[i][j] == '$') {\n                s = min(s, d[i][j]);\n            }\n        }\n    }\n    if(s <= p) {\n        cout << \"No\" << endl;\n    } else {\n        cout << \"Yes\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define MAXN 210\n#define INF 0x3f3f3f3f\nusing namespace std;\n\nint R,C;\nchar a[MAXN][MAXN];\n\nstruct Cell {\n  int r, c;\n  Cell(int r, int c):r(r),c(c) {}\n};\n\nconst int dr[] = {-1,1,0,0};\nconst int dc[] = {0,0,-1,1};\nint d[MAXN][MAXN][2], vis[MAXN][MAXN][2];\n\nqueue<Cell> Q;\nvoid bfs(int kind) {\n  while(!Q.empty()) {\n    Cell cell = Q.front(); Q.pop();\n    int r = cell.r, c = cell.c;\n    for(int dir = 0; dir < 4; dir++) {\n      int nr = r + dr[dir], nc = c + dc[dir];\n      if(nr >= 0 && nr < R && nc >= 0 && nc < C && a[nr][nc] == '.' && !vis[nr][nc][kind]) {\n        Q.push(Cell(nr, nc));\n        vis[nr][nc][kind] = 1;\n        d[nr][nc][kind] = d[r][c][kind] + 1;\n      }\n    }\n  }\n}\n\nint ans;\nvoid check(int r, int c) {\n  if(a[r][c] != '.' || !vis[r][c][0]) return;\n  if(!vis[r][c][1] || d[r][c][0] < d[r][c][1]) ans = min(ans, d[r][c][0] + 1);\n}\n\nint main() {\n\n    scanf(\"%d%d\", &R, &C);\n    int jr, jc;\n    int tr,tc;\n    vector<Cell> fires;\n    for(int i = 0; i < R; i++) {\n      scanf(\"%s\", a[i]);\n      for(int j = 0; j < C; j++)\n\n      if(a[i][j]=='%')\n      {\n      \ttr=i; tc=j; a[i][j]='.';\n\t  }\n        else if(a[i][j] == '@') { jr = i; jc = j; a[i][j] = '.'; }\n        else if(a[i][j] == '$') { fires.push_back(Cell(i,j)); a[i][j] = '.'; }\n    }\n    memset(vis, 0, sizeof(vis));\n    vis[jr][jc][0] = 1; d[jr][jc][0] = 0;\n    Q.push(Cell(jr, jc));\n    bfs(0);\n    for(int i = 0; i < fires.size(); i++) {\n      vis[fires[i].r][fires[i].c][1] = 1;\n      d[fires[i].r][fires[i].c][1] = 0;\n      Q.push(fires[i]);\n    }\n    bfs(1);\n    ans = INF;\n    check(tr,tc);\n    if(ans == INF) printf(\"No\\n\"); else printf(\"Yes\\n\");\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=1000000,pri;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='$'){sol=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<h)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q1;\n  Q1.push(mk(mk(y,x),0));\n  while(!Q1.empty()){\n    pair<pair<int,int > ,int >a=Q1.front();Q1.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='@'){pri=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<h)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q1.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  if(pri<sol)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\n\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n  vector<string> f(h);\n  queue<pair<pair<int,int>,int>> q;\n  vector<vector<bool>> visited(h,vector<bool>(w,false));\n  int sx,sy,gx,gy;\n  rep(i,h){\n    cin >> f[i];\n    rep(j,w){\n      if(f[i][j]=='@'){\n        sx=i,sy=j;\n        f[i][j]='.';\n      }else if(f[i][j]=='$'){\n        q.push({{i,j},0});\n        visited[i][j]=true;\n        f[i][j]='.';\n      }else if(f[i][j]=='%'){\n        gx=i,gy=j;\n        f[i][j]='.';\n      }\n    }\n  }\n  vector<int> v={0,1,0,-1,0};\n  int gd=IINF;\n  while(!q.empty()){\n    auto now = q.front();\n    q.pop();\n    rep(i,4){\n      int nx = now.first.first+v[i];\n      int ny = now.first.second+v[i+1];\n      if(0<=nx&&nx<h&&0<=ny&&ny<w){\n        if(f[nx][ny]=='.'&&!visited[nx][ny]){\n          visited[nx][ny]=true;\n          if(nx==gx&&ny==gy){\n            gd=now.second+1;\n            goto next;\n          }\n          q.push({{nx,ny},now.second+1});\n        }\n      }\n    }\n  }\n  next:;\n  while(!q.empty()) q.pop();\n  visited=vector<vector<bool>>(h,vector<bool>(w,false));\n  q.push({{sx,sy},0});\n  while(!q.empty()){\n    auto now = q.front();\n    q.pop();\n    rep(i,4){\n      int nx = now.first.first+v[i];\n      int ny = now.first.second+v[i+1];\n      if(0<=nx&&nx<h&&0<=ny&&ny<w){\n        if(f[nx][ny]=='.'&&!visited[nx][ny]){\n          visited[nx][ny]=true;\n          if(nx==gx&&ny==gy){\n            if(now.second+1<gd){\n              CYES;\n            }else{\n              CNO;\n            }\n            return 0;\n          }\n          q.push({{nx,ny},now.second+1});\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n/*\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2781\n\n????\\??????????????????????\n????????????????????????????\\???????????????§?????????????????????????????£???????????????????\\?????????????????????????????????????\n????????????????£???????????\\??????????????????????????????????????????????????????¢???????????????????????????????\\???????????????????\n?????????????????¨?????§??????????????????????±??????????????????°????????????????????¨??????\n\n ????´????????????????????????°???????????????????????¢????????£??????????????°?????????????????????????¨??????????????????????\n ???1??????????£?????\\????????????\\??§???????????????2?????????????£?????\\?????????\\????????¨?????§?????????????????????\n ???????????????????????????????????????????£???¨?????¶?????¨?????????????\\??????¨????£??????°?????£????????????????????????????????¨?????????\n ??°??????????????????????????????????????????????????????????????¨????????????????\\?????????????????????°???????????°???\n ????????¨????\\?????????????????????????????????¨?????§????????????????????????0?????\\??????????£?????????????\n\n ?\\??????¨??¨??????????£???????????????????????????????????????????????????????????????????????????°????\\??????¨????£????\n ??????????¬????????????????????????¨?????§???????????????????????????????\\??????¨????£?????°´?????\\??????????????´?????£??\\???????????????\n ?§?????????????????????????????????¨??????????????¨?????§??????????????????????\\??????¨????£??????????????????????????????¨?????§????????????\n ???????\\???????????????\\??????????????°???????£???????????????????????????£????????????????????¨?????£??????????\\?????????????????????????\n ?\\???????????????¨??????????£?????????????????????????????????????????????¨?????£???????????°??????????????°?????§???????????¨???????????§?????????\n\n ??????????£??????????????????????????????????????????£?????¨??????????\\????????????????????????¨?????§??????????????????????????¨????????°???\n ????????¨????\\???????????£?????????????????????¨?????§????????????????\\???????????£???????????????????????????°???????????¨????????°???\n ?\\?????????????????????¨?????§??????????\\?????????????????????????????????¨?????§????????????\n\n*/\ntypedef long long ll;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> masu(H + 2, vector<int>(W + 2, -1));\n\tint px, py;\n\tint hx, hy;\n\tvector<int> sx, sy;\n\t//initialize\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W;j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '%') {\n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\thx = i; hy = j;\n\t\t\t}\n\t\t\telse if (c == '.')masu[i][j] = 0;\n\t\t\telse if (c == '@') { \n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\tpx = i; py = j;\n\t\t\t}\n\t\t\telse if (c == '$') sx.push_back(i), sy.push_back(j);\n\t\t}\n\t}\n\tvector<vector<int>> dist(H + 2, vector<int>(W + 2, (1 << 30)));\n\tqueue<pair<int, int>> q;\n\tq.push({ px,py });\n\tdist[px][py] = 0;\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second]+1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tint key = dist[hx][hy];\n\tdist = vector<vector<int>>(H + 2, vector<int>(W + 2, (1 << 30)));\n\tfor (int i = 0; i < sx.size();i++) {\n\t\tq.push({ sx[i],sy[i] });\n\t\tdist[sx[i]][sy[i]] = 0;\n\t}\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second] + 1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tif (key > dist[hx][hy]) {\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pii pair<int,int>\n#define ss second\n#define ff first\nusing namespace std ;\nint mn_dist = 100000000 ;\n\nint row , col , hx , hy , px,  py;\n\nchar g[405][405] ;\nint vis[405][405] , d[405][405] ;\n\nint dx[] = {0,0,1,-1} ;\nint dy[] = {1,-1,0,0} ;\n\n\nbool valid (int x,int y) {\n\n    if (x >= 0 and x < row and y >= 0  and y < col and vis[x][y] == 0 and g[x][y] != '#' ) return 1 ;\n    return  0 ;\n\n\n}\n\nvoid bfs (int sx, int sy) {\n\n    memset (vis, 0 , sizeof vis) ;\n\n\n    vis[sx][sy] = 1 ;\n\n    d[sx][sy] = 0 ;\n\n\n    queue <pair<int,int > > q ;\n    q.push(mp(sx,sy)) ;\n\n    while(!q.empty()) {\n        pii u = q.front() ;\n        int x = u.ff , y = u.ss ;\n        q.pop() ;\n\n        for(int i = 0 ; i < 4 ; i++) {\n            int x_ = x+dx[i] , y_ = y+ dy[i] ;\n\n            if (valid(x_,y_)) {\n                vis[x_][y_] = 1 ;\n                d[x_][y_] = d[x][y] + 1 ;\n                q.push(mp(x_,y_)) ;\n            }\n        }\n    }\n}\n\n\n\n\n\n\nint main () {\n\n    cin >> row >> col ;\n    for(int i = 0 ; i < row ; i++) scanf (\"%s\" , g[i]) ;\n\n    for(int i = 0 ; i < row ; i++) {\n        for(int j = 0 ; j < col ; j++) {\n            if (g[i][j] == '@') px = i , py = j ;\n            if (g[i][j] == '%') hx = i , hy = j ;\n        }\n    }\n\n    bfs(hx,hy) ;\n    int p_dist = d[px][py] ;\n    for(int i = 0 ; i < row ; i++) {\n        for(int j = 0 ; j < col ; j++) {\n            if (g[i][j] == '$' and vis[i][j] == 1) {\n                mn_dist = min(d[i][j],mn_dist) ;\n            }\n        }\n    }\n\n    if (mn_dist <= p_dist) {\n        printf (\"No\\n\") ;\n    } else {\n        printf (\"Yes\\n\" ) ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    int si, sj, gi, gj;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> mat[i][j];\n            if(mat[i][j] == '@')    gi = i, gj = j;\n            if(mat[i][j] == '%')    si = i, sj = j;\n        }\n    }\n    vector<vector<int>> v(h, vector<int>(w, 1<<30));\n    v[si][sj] = 0;\n    queue<pair<int,int>> q;\n    q.push({si,sj});\n    int ans = 1<<30;\n    while(!q.empty()){\n        pair<int,int> p = q.front();    q.pop();\n        int i = p.first, j = p.second;\n        for(int k = 0; k < 4; k++){\n            int ni = i+di[k], nj = j+dj[k];\n            if(inRange(ni,0,h)&&inRange(nj,0,w)&&mat[ni][nj]!='#'&&v[ni][nj]==1<<30){\n                v[ni][nj] = v[i][j]+1;\n                if(mat[ni][nj] == '$')  ans = min(ans, v[ni][nj]);\n                q.push({ni,nj});\n            }\n        }\n    }\n    cout << (v[gi][gj] < ans ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//幅優先探索\n//迷路の最短距離を求める\n//まず、盤面のサイズと、迷路のスタート地点とゴール地点の座標が与えられる。\n//次に、それぞれのマスが通行可能な空きマス(.)か通行不可能な壁マス(#)かという情報を持った盤面が与えられる。\n//スタート地点とゴール地点は必ず空きマスであり、スタート地点からゴール地点へは、空きマスを辿って必ずたどり着ける。\n\n// queue (FIFO) を使うのがスマート(atcoder調べ)\n// pop() := キューの先頭要素を削除\n// front() 先頭要素の参照\n// push() := キューの末尾にデータを追加\n// 出し入れするデータは座標\n\n// 入力例\n// 7 8\n// 2 2\n// 4 5\n// ########\n// #......#\n// #.######\n// #..#...#\n// #..##..#\n// ##.....#\n// ########\n\n// 出力例\n// 11\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint main(){\n\n    //入力\n    int r, c, si, sj, gi, gj;\n    cin >> r >> c;\n    \n    queue<pair<int, int> > p[2];\n    queue<pair<int, int> > s[2];\n    \n    // canGo[i][j] := (i, j) が壁ならばfalse, 通路ならばtrue\n    vector<vector<bool> > canGo(r + 2, vector<bool> (c + 2, false));\n    for(int i = 1; i <= r; i++){\n        for(int j = 1; j <= c; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else if(input == '$'){\n                s[0].push({i, j});\n            }else{\n                canGo[i][j] = true;\n\n                if(input == '@'){\n                    //canGo[i][j] = false;\n                    p[0].push({i, j});\n                }else if(input == '%'){\n                    gi = i;\n                    gj = j;\n                }\n\n            }\n        }\n    }\n\n    //cout << gi << \" \" << gj << endl;\n\n    int now = 0;\n\n    while(!p[now].empty()){\n\n        //兵士動いてください\n        //cout << \"soldier\" << endl;\n        while(!s[now].empty()){\n\n            int nowi = s[now].front().first;\n            int nowj = s[now].front().second;\n            \n            //cout << nowi << \" \" << nowj << endl;\n\n            s[now].pop();\n            if(nowi == gi && nowj == gj){\n                cout << \"No\" << endl;\n                return 0;\n            }\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //その方向に進めるなら\n                if(canGo[nexti][nextj]){\n                    //そのマスにキューを追加し\n                    //再度検索することのないように壁で埋める\n                    s[(now + 1) % 2].push({nexti, nextj});\n                    canGo[nexti][nextj] = false;\n                }\n            }\n        }\n\n        //cout << endl;\n\n        //姫さんどうぞ\n        //cout << \"princess\" << endl;\n        while(!p[now].empty()){    //キュー画空になるまで\n            //キューの先頭要素を取り出す\n            //int nowcost = wait.front().first;\n            int nowi = p[now].front().first;\n            int nowj = p[now].front().second;\n\n            //cout << nowi << \" \" << nowj << endl;\n\n            p[now].pop();\n\n            //ゴールにたどり着いたらそのコストが答え\n            if(nowi == gi && nowj == gj){\n                cout << \"Yes\" << endl;\n                return 0;\n            }\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n\n                //その方向に進めるなら\n                if(canGo[nexti][nextj]){\n                    //そのマスにキューを追加し\n                    //再度検索することのないように壁で埋める\n                    p[(now + 1) % 2].push({nexti, nextj});                    \n                    canGo[nexti][nextj] = false;\n                }\n            }\n        }\n\n        now = (now + 1) % 2;\n\n    }\n    \n    cout << \"No\" << endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\nint n,m;\nstruct Node\n{\n    int x,y;\n    int step=0;\n};\nchar a[205][205];\nint vis[205][205],dr[4][2]= {{1,0},{-1,0},{0,1},{0,-1}};\nNode s,t;\nint bfs(Node u,Node v)\n{\n    memset(vis,0,sizeof(vis));\n    vis[u.x][u.y]=1;\n    u.step=0;\n    queue <Node> Q;\n    Q.push(u);\n    while(!Q.empty())\n    {\n        Node c=Q.front();\n        Q.pop();\n        if (c.x==v.x&&c.y==v.y) return c.step;\n        for (int i=0; i<4; i++)\n        {\n            Node ne;\n            ne.x=c.x+dr[i][0];\n            ne.y=c.y+dr[i][1];\n            if (!vis[ne.x][ne.y]&&a[ne.x][ne.y]!='#'&&ne.x>=1&&ne.x<=n&&ne.y>=1&&ne.y<=m)\n            {\n                vis[ne.x][ne.y]=1;\n                ne.step=c.step+1;\n                Q.push(ne);\n            }\n        }\n    }\n}\nint bfs2(Node u,int ma)\n{\n    memset(vis,0,sizeof(vis));\n    vis[u.x][u.y]=1;\n    u.step=0;\n    queue <Node> Q;\n    Q.push(u);\n    while(!Q.empty())\n    {\n        Node c=Q.front();\n        Q.pop();\n        for (int i=0; i<4; i++)\n        {\n            Node ne;\n            ne.x=c.x+dr[i][0];\n            ne.y=c.y+dr[i][1];\n            if (!vis[ne.x][ne.y]&&a[ne.x][ne.y]!='#'&&ne.x>=1&&ne.x<=n&&ne.y>=1&&ne.y<=m)\n            {\n                vis[ne.x][ne.y]=1;\n                ne.step=c.step+1;\n                // printf(\"%d %d %d\\n\",ne.x,ne.y,ne.step);\n                if (ne.step>ma) return 1;\n                if (a[ne.x][ne.y]=='$')\n                    return 0;\n                Q.push(ne);\n            }\n        }\n    }\n}\nint main()\n{\n    //freopen(\"input(1).in\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n    {\n        memset(a,0,sizeof(a));\n        int f=1;\n        for (int i=1; i<=n; i++)\n        {\n            for (int j=1; j<=m; j++)\n            {\n                cin>>a[i][j];\n                if (a[i][j]=='@')\n                {\n                    s.x=i,s.y=j;\n                }\n                else if (a[i][j]=='%')\n                {\n                    t.x=i,t.y=j;\n                }\n            }\n        }\n        int dis=bfs(s,t);\n        //cout<<dis<<endl;\n        f=bfs2(t,dis);\n        f ? printf(\"Yes\\n\") :printf(\"No\\n\");\n    }\n\n    return 0;\n}\n/*\n4 4\n%...\n...$\n..@$\n$$$$\n4 4\n%..@\n.#..\n....\n$...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    using P = pair<int, int>;\n    P a, b;\n    vector<vector<int>> v(h+2, vector<int> (w+2, 0));\n    queue<P> Q, QQ;\n    vector<vector<int>> dist1(h+2, vector<int> (w+2, INF<int>));\n\n    auto dist2 = dist1;\n\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            v[i+1][j+1] = (s[j] != '#');\n            if(s[j] == '@') {\n                a = {i + 1, j + 1};\n                dist1[i+1][j+1] = 0;\n            }\n            else if(s[j] == '%') b = {i+1, j+1};\n            else if(s[j] == '$') {\n                Q.emplace(i+1, j+1);\n                dist2[i+1][j+1] = 0;\n            }\n        }\n    }\n    array<int, 4> di{0, 0, -1, 1}, dj{1, -1, 0, 0};\n\n    QQ.emplace(a);\n    while(!QQ.empty()){\n        int i, j;\n        tie(i, j) = QQ.front(); QQ.pop();\n        for (int k = 0; k < 4; ++k) {\n            if(v[i+di[k]][j+dj[k]] && dist1[i+di[k]][j+dj[k]] > dist1[i][j]+1){\n                dist1[i+di[k]][j+dj[k]] = dist1[i][j]+1;\n                QQ.emplace(i+di[k], j+dj[k]);\n            }\n        }\n    }\n    while(!Q.empty()){\n        int i, j;\n        tie(i, j) = Q.front(); Q.pop();\n        for (int k = 0; k < 4; ++k) {\n            if(v[i+di[k]][j+dj[k]] && dist2[i+di[k]][j+dj[k]] > dist2[i][j]+1){\n                dist2[i+di[k]][j+dj[k]] = dist2[i][j]+1;\n                Q.emplace(i+di[k], j+dj[k]);\n            }\n        }\n    }\n    puts((dist2[b.first][b.second] > dist1[b.first][b.second]) ? \"Yes\" : \"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 1e3;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n\tint x,y;\n} soldier[1e5],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n\tint temp;\n\t//printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n\t//labyrinth[y][x] = 3;\n\tvis[y][x] = true;\n\tif(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n\t{\n\t\tif(labyrinth[y][x-1] == goal)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x-1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n\t{\n\t\tif(labyrinth[y][x+1] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x+1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n\t{\n\t\tif(labyrinth[y-1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y-1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n\t{\n\t\tif(labyrinth[y+1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y+1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\treturn shortest;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t//freopen(\"1002.txt\",\"r\",stdin);\n\t//freopen(\"ans.txt\",\"w+\",stdout);\n\twhile(~scanf(\"%d%d\",&H,&W))\n\t{\n\t\ttf = true;\n\t\tscnt = 0;\n\t\tshortest = INF;\n\t\tmemset(labyrinth,-1,sizeof(labyrinth));\n\t\tgetchar();\n\t\tfor(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\twhile((ch = getchar())=='\\n');\n\t\t\t\tswitch(ch)\n\t\t\t\t{\n\t\t\t\tcase '@':\n\t\t\t\t\tprincess.x = j;\n\t\t\t\t\tprincess.y = i,labyrinth[i][j] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\tsoldier[scnt].x = j;\n\t\t\t\t\tsoldier[scnt++].y = i;\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tlabyrinth[i][j] = 2;\n\t\t\t\t\tescape.x = j;\n\t\t\t\t\tescape.y = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tgoal = 2;\n\t\tpshort = dfs(princess.x,princess.y,0);\n\t\t//printf(\"pshort:%d\\n\",pshort);\n\n\t\tgoal = 5;\n\t\tshortest = INF;\n\t\tmemset(vis,false,sizeof(vis));\n\t\teshort = dfs(escape.x,escape.y,0);\n\t\t//printf(\"eshort:%d\\n\",eshort);\n\t\tif(eshort<pshort)\n\t\t\tpshort = eshort;\n\t\t/*for(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\tif(i == princess.y&&j == princess.x)\n\t\t\t\t\tprintf(\"X\");\n\t\t\t\telse\n\t\t\t\tprintf(\"%d\",labyrinth[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(!scnt&&pshort!=INF)\n\t\t{\n\t\t\ttf = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pshort != INF)\n\t\t\t{\n\t\t\t\tgoal = 2;\n\t\t\t\tfor(int i = 0; i < scnt; ++i)\n\t\t\t\t{\n\t\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\t\tshortest = INF;\n\t\t\t\t\tsshort = dfs(soldier[i].x,soldier[i].y,0);\n\t\t\t\t\t//printf(\"sshort:%d\\n\",sshort);\n\t\t\t\t\tif(sshort <= pshort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\ttf = false;\n\n\t\t}\n\t\tif(tf)\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define LL long long int\n#define uLL unsigned long long int\n\n#define S(a) scanf(\"%d\",&a)\n#define S2(a,b) scanf(\"%d%d\",&a,&b)\n#define S3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define SLL(a) scanf(\"%lld\",&a)\n#define SLL2(a,b) scanf(\"%lld%lld\",&a,&b)\n#define SLL3(a,b,c) scanf(\"%lld%lld%lld\",&a,&b,&c)\n#define SC(a) scanf(\"%c\",&a)\n#define P(a) printf(\"%d\",a)\n#define PS(a) printf(\"%s\",a)\n#define PLL(a) printf(\"%lld\",a)\n#define PCASE(kk) printf(\"Case %d: \",kk++)\n#define PCASENL printf(\"Case %d:\\n\",kk++)\n#define NL puts(\"\")\n\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pi (2.0*acos(0.0))\n#define pii pair<int,int>\n\nlong long int gcd(long long int c,long long int d)\n{\n    if(d==0) return c;\n    else return gcd(d,c%d);\n}\n\n//knight and king move....\n\n//int Dx[]={-2,-1,1,2,1,2,-2,-1};\n//int Dy[]={-1,-2,2,1,-2,-1,1,2};\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n//////////////////////////////////////////////////\n\nint n,m,cell_tim[210][210],sx,sy,ex,ey;\nchar ch[210][210];\n\nint chk(int x,int y)\n{\n    if(x<1 || x>n)return 0;\n    if(y<1 || y>m)return 0;\n    if(ch[x][y]=='#')return 0;\n    return 1;\n}\nvoid bfs(int xx,int yy)\n{\n    queue< int >q;\n    q.push( xx );\n    q.push( yy );\n    q.push(  0 );\n    cell_tim[xx][yy]=0;\n    while(!q.empty())\n    {\n        int x=q.front();    q.pop();\n        int y=q.front();    q.pop();\n        int ti=q.front();   q.pop();\n        for(int i=0;i<4;i++)\n        {\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            if(chk(nx,ny)==1 && cell_tim[nx][ny]>ti+1)\n            {\n                cell_tim[nx][ny]=ti+1;\n                q.push( nx );\n                q.push( ny );\n                q.push( ti+1 );\n            }\n        }\n    }\n    return ;\n}\n\nint dfs1(int xx,int yy)\n{\n    queue< int >q;\n    q.push( xx );\n    q.push( yy );\n    q.push(  0 );\n    cell_tim[xx][yy]=0;\n    while(!q.empty())\n    {\n        int x=q.front();    q.pop();\n        int y=q.front();    q.pop();\n        int ti=q.front();   q.pop();\n        if(x==ex && y==ey) return 1;\n        for(int i=0;i<4;i++)\n        {\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            if(chk(nx,ny)==1 && cell_tim[nx][ny]>ti+1)\n            {\n                cell_tim[nx][ny]=ti+1;\n                q.push( nx );\n                q.push( ny );\n                q.push( ti+1 );\n            }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    S2(n,m);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            scanf(\" %c\",&ch[i][j]);\n            if(ch[i][j]=='@'){sx=i;sy=j;}\n            if(ch[i][j]=='%'){ex=i;ey=j;}\n        }\n    }\n\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=m;j++)cell_tim[i][j]=1000000000;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(ch[i][j]=='$')\n            {\n                bfs(i,j);\n            }\n        }\n    }\n    int ans=dfs1(sx,sy);\n    if(ans==1)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[200][201];\nint d1[200][200], d2[200][200];\nbool b[200][200];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint h, w;\n\nvoid dfs(int x, int y) {\n\tb[x][y] = true;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w && !b[nx][ny] && d2[nx][ny] < d1[nx][ny])\n\t\t\tdfs(nx, ny);\n\t}\n}\nint main() { \n\tscanf(\"%d%d\", &h, &w);\n\tmemset(d1, 0x3f, sizeof(d1));\n\tmemset(d2, 0x3f, sizeof(d2));\n\tqueue<P>que;\n\tint sx, sy, gx, gy;\n\trep(i, h) {\n\t\tscanf(\"%s\", s[i]);\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == '$') {\n\t\t\t\td1[i][j] = 0; que.push(P(i, j));\n\t\t\t}\n\t\t\tif (s[i][j] == '@')sx = i, sy = j;\n\t\t\tif (s[i][j] == '%')gx = i, gy = j;\n\t\t}\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d1[nx][ny] == INF) {\n\t\t\t\td1[nx][ny] = d1[p.first][p.second] + 1;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\tque.push(P(sx, sy));\n\td2[sx][sy] = 0;\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d2[nx][ny] == INF) {\n\t\t\t\td2[nx][ny] = d2[p.first][p.second] + 1;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sx, sy);\n\tputs(b[gx][gy] ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<math.h>\n#include<queue>\nusing namespace std;\nchar map[210][210];\nint step[210][210];\nint px,py,ex,ey;\nint pstep=500,sstep=500;\nstruct node\n{\n\tint x,y,step;\n}a[410];\nvoid bfs(int h,int w)\n{\n\tqueue<node>Q;\n\twhile(!Q.empty()) Q.pop();\n\tnode tem;\n\ttem.x=ex,tem.y=ey;\n\ttem.step=0;\n\tstep[tem.x][tem.y]=0;\n\tQ.push(tem);\n\twhile(!Q.empty())\n\t{\n\t\ttem=Q.front();\n\t\tQ.pop();\n\t\tif(map[tem.x][tem.y]=='@' && tem.step<pstep)\n\t\t\tpstep=tem.step;\n\t\telse if(map[tem.x][tem.y]=='$' && tem.step<sstep)\n\t\t\tsstep=tem.step;\n\t\tnode t;\n\t\tif(tem.x-1>=0 && map[tem.x-1][tem.y]!='#' && tem.step+1<step[tem.x-1][tem.y])\n\t\t{\n\t\t\tt.x=tem.x-1;\n\t\t\tt.y=tem.y;\n\t\t\tt.step=tem.step+1;\n\t\t\tstep[t.x][t.y]=t.step;\n\t\t/*\tif(map[tem.x-1][tem.y]=='@' && t.step<pstep)\n\t\t\t\tpstep=t.step;\n\t\t\telse if(map[tem.x-1][tem.y]=='$' && t.step<sstep)\n\t\t\t\tsstep=t.step;\n\t\t\t\t*/\n\t\t\tQ.push(t);\n\t\t}\n\t\tif(tem.x+1<h && map[tem.x+1][tem.y]!='#' && tem.step+1<step[tem.x+1][tem.y] )\n\t\t{\n\t\t\tt.x=tem.x+1;\n\t\t\tt.y=tem.y;\n\t\t\tt.step=tem.step+1;\n\t\t\tstep[t.x][t.y]=t.step;\n\t\t\t/*\n\t\t   if(map[tem.x+1][tem.y]=='@' && t.step<pstep)\n\t\t\t\tpstep=t.step;\n\t\t\telse if(map[tem.x+1][tem.y]=='$' && t.step<sstep)\n\t\t\t\tsstep=t.step;\n\t\t\t\t*/\n\t\t\tQ.push(t);\n\t\t}\n\t\tif(tem.y-1>=0 && map[tem.x][tem.y-1]!='#' && tem.step+1<step[tem.x][tem.y-1])\n\t\t{\n\t\t\tt.x=tem.x;\n\t\t\tt.y=tem.y-1;\n\t\t\tt.step=tem.step+1;\n\t\t\tstep[t.x][t.y]=t.step;\n\t\t\t/*\n\t\t   if(map[tem.x][tem.y-1]=='@' && t.step<pstep)\n\t\t\t\tpstep=t.step;\n\t\t\telse if(map[tem.x][tem.y-1]=='$' && t.step<sstep)\n\t\t\t\tsstep=t.step;\n\t\t\t\t*/\n\t\t\tQ.push(t);\n\t\t}\n\t\tif(tem.y+1<w && map[tem.x][tem.y+1]!='#' && tem.step+1<step[tem.x][tem.y+1])\n\t\t{\n\t\t\tt.x=tem.x;\n\t\t\tt.y=tem.y+1;\n\t\t\tt.step=tem.step+1;\n\t\t\tstep[t.x][t.y]=t.step;\n\t\t\t/*\n\t\t\tif(map[tem.x][tem.y+1]=='@' && t.step<sstep)\n\t\t\t\tsstep=t.step;\n\t\t\telse if(map[tem.x][tem.y+1]=='$' && t.step<sstep)\n\t\t\t\tsstep=t.step;\n\t\t\t\t*/\n\t\t\tQ.push(t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint h,w;\n\twhile(scanf(\"%d%d\",&h,&w)!=EOF)\n\t{\n\t\tpstep=500,sstep=500;\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(step,0x3f,sizeof(step));\n\t\tint i,j;\n\t\tfor(i=0;i<h;i++)\n\t\t{\n\t\t\tscanf(\"%s\",&map[i]);\n\t\t\tfor(j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(map[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tpx=i;py=j;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]=='%')\n\t\t\t\t\tex=i,ey=j;\n\t\t\t}\n\t\t}\n\t\tbfs(h,w);\n\t\tif(pstep<sstep)\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int inf = 1 << 28;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nint n, m;\nvector<vector<int> > d;\nvector<string> vs;\n\nvoid bfs(int x, int y) {\n    queue<P> que;\n    que.push(P(x,y));\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        x = p.first;\n        y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && vs[nx][ny] != '#' && d[nx][ny] > d[x][y] + 1) {\n                d[nx][ny] = d[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    vector<int> sr, sc;\n    cin >> n >> m;\n    vs.resize(n);\n    for (auto& i : vs) cin >> i;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (vs[i][j] == '@') sx = i, sy = j;\n            if (vs[i][j] == '$') sr.push_back(i), sc.push_back(j);\n            if (vs[i][j] == '%') gx = i, gy = j;\n        }\n    }\n    d.resize(n);\n    for (auto& i : d) i.resize(m, inf);\n\n    for (int i = 0; i < sr.size(); i++) {\n        d[sr[i]][sc[i]] = 0;\n        bfs(sr[i], sc[i]);\n    }\n\n    queue<P> que;\n    que.push(P(sx,sy));\n    vector<vector<int> > dist(n, vector<int>(m,inf));\n    dist[sx][sy] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first;\n        int y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && vs[nx][ny] != '#' \n                && dist[nx][ny] > dist[x][y] + 1 && dist[x][y] + 1 < d[nx][ny]) {\n                dist[nx][ny] = dist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n\n    cout << (dist[gx][gy] != inf ? \"YES\" : \"NO\") << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* \" A computer would deserve to be called intelligent if it\ncould deceive a human into believing that it was human. \"\n                                            - Alan Turing */\n#include<bits/stdc++.h>\nusing namespace std;\n#define D               double\n#define LL              long long\n#define ULL             unsigned long long\n#define SF              scanf\n#define PF              printf\n#define FOR(i, a, b)    for(int i = a; i < b; i++)\n#define REV(i, a, b)    for(int i = a - 1; i >= b; i--)\n#define SET(a, v)       memset(a, v, sizeof a)\n#define VI              vector<int>\n#define PB              push_back\n#define ALL(v)          v.begin(), v.end()\n#define MII             map<int, int>\n#define MSI             map<string, int>\n#define PII             pair<int, int>\n#define MP              make_pair\n#define X               first\n#define Y               second\n// return the index     (match ? first match : immediate greater)\n#define lbA(a, n, x)    lower_bound(a, a + n, x) - a\n#define lbV(v, x)       lower_bound(ALL(v), x) - v.begin()\n// return the index     (match ? last match + 1 : immediate greater)\n#define ubA(a, n, x)    upper_bound(a, a + n, x) - a\n#define ubV(v, x)       upper_bound(ALL(v), x) - v.begin()\ntemplate <class T> inline T bigmod(T b, T p, T M) {\n    LL ret = 1;\n    for(; p > 0; p >>= 1) {\n        if(p & 1) ret = (ret * b) % M;\n        b = (b * b) % M;\n    }\n    return (T) ret;\n}\ntemplate <class T> inline T __lcm(T a, T b) {\n    return (a * b) / __gcd(a, b);\n}\nint dx4[] = {1, 0, -1, 0}; // 4 directions\nint dy4[] = {0, 1, 0, -1};\nint dx8[] = {0, 0, 1, 1, 1, -1, -1, -1}; // 8 directions\nint dy8[] = {1, -1, -1, 0, 1, -1, 0, 1};\nint kx8[] = {1, 1, 2, 2, -1, -1, -2, -2}; // Knight Moves\nint ky8[] = {2, -2, 1, -1, 2, -2, 1, -1};\n//freopen(\"in.txt\", \"r\", stdin);\n//freopen(\"out.txt\", \"w\", stdout);\n// int tc;SF(\"%d\",&tc);FOR(cs,1,tc+1){}\nconst LL                LINF = 1e18;\nconst int               INF = 1e9, NIL = -1;\nconst int               N = 200 + 5, M = 1e9 + 7;\n\nint n, m, vis[N][N];\nstring s[N];\n\nvoid bfs(int x, int y) {\n    vis[x][y] = 1;\n    queue<PII>q;\n    q.push(MP(x, y));\n    while(!q.empty()) {\n        PII p = q.front();\n        q.pop();\n        FOR(i, 0, 4) {\n            int u = p.X + dx4[i], v = p.Y + dy4[i];\n            if(u < 0 || u >= n || v < 0 || v >= m || s[u][v] == '#' || vis[u][v])\n                continue;\n            vis[u][v] = vis[p.X][p.Y] + 1;\n            q.push(MP(u, v));\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    FOR(i, 0, n) cin >> s[i];\n    FOR(i, 0, n) {\n        FOR(j, 0, m) {\n            if(s[i][j] == '%') bfs(i, j);\n        }\n    }\n    int pr = M, so = M;\n    FOR(i, 0, n) {\n        FOR(j, 0, m) {\n//            cout << i << \" \" << j << \" \" << vis[i][j] << endl;\n            if(s[i][j] == '@') pr = min(pr, vis[i][j]);\n            if(s[i][j] == '$') so = min(so, vis[i][j]);\n        }\n    }\n//    cout << pr << \" \" << so << endl;\n    if(pr < so) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxi 50\nint cost[maxi][maxi],color[maxi][maxi];\nint fx[4]= {1,-1,0,0};\nint fy[4]= {0,0,1,-1};\nchar grid[maxi][maxi];\nint xcell,ycell,dis=0;\nvoid bfs(int i,int j,int m, int l)\n{\n    memset(cost,0,sizeof(cost));\n    memset(color,0,sizeof(color));\n\n    queue<int>q;\n    int ui,uj,xi,yj,k;\n\n    q.push(m);\n    q.push(l);\n\n    cost[m][l] = 0;\n    color[m][l] = 1;\n\n    while(!q.empty())\n    {\n\n        ui = q.front();\n        q.pop();\n\n        uj = q.front();\n        q.pop();\n        for(k=0; k<4; k++)\n        {\n            xi = ui+fx[k];\n            yj = uj+fy[k];\n\n            if((xi>=1&&xi<=xcell) && (yj>=1&&yj<=ycell) && (grid[xi][yj]!='#'))\n            {\n                if(!color[xi][yj])\n                {\n                    q.push(xi);\n                    q.push(yj);\n                    cost[xi][yj] = cost[ui][uj]+1;\n                    color[xi][yj]=1;\n                }\n\n            }\n        }\n    }\n}\n\nint main()\n{\n    int i,j,k,m,n,flag,cas,x,y,l,no;\n    scanf(\"%d%d\",&xcell,&ycell);\n    flag=0,x=0,y=0,k=0,l=0,no=1;\n    for(i=1; i<=xcell; i++)\n    {\n        for(j=1; j<=ycell; j++)\n        {\n            scanf(\" %c\",&grid[i][j]);\n            if(grid[i][j]=='@')\n                x=i,y=j;\n            if(grid[i][j]=='%')\n                k=i,l=j;\n        }\n    }\n    bfs(x,y,k,l);\n    int princess=cost[x][y];\n    //cout << princess << endl;\n    for(i=1; i<=xcell; i++)\n    {\n        for(j=1; j<=ycell; j++)\n        {\n            if(grid[i][j]=='$')\n            {\n                //cout << cost [i][j] <<endl;\n                if(cost[i][j]<=princess)\n                {\n                    princess=0;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (princess)\n        printf(\"YES\\n\");\n    else\n        printf(\"NO\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct P {\n  int y, x;\n  P() {}\n  P(int y, int x) : y(y), x(x) {}\n};\n\nint h, w;\nvector<string> s;\nP start, goal;\nvector<P> demons;\nint dy[] = {-1, 0, 0, 1}, dx[] = {0, -1, 1, 0};\n\nvoid bfs(vector<vector<int>>& d, vector<P> v) {\n  queue<pair<P, int>> que;\n  for (int i = 0; i < v.size(); i++) {\n    d[v[i].y][v[i].x] = 0;\n    que.push({v[i], 0});\n  }\n  while (que.size()) {\n    auto p = que.front(); que.pop();\n    int py = p.first.y, px = p.first.x;\n    for (int i = 0; i < 4; i++) {\n      int ny = py + dy[i], nx = px + dx[i];\n      if (ny >= 0 && ny < h && nx >= 0 && nx < w && s[ny][nx] != '#' && d[ny][nx] > d[py][px] + 1) {\n        d[ny][nx] = d[py][px] + 1;\n        que.push({{ny, nx}, d[ny][nx]});\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  cin >> h >> w;\n  s.resize(h);\n  for (int i = 0; i < h; i++) {\n    cin >> s[i];\n    for (int j = 0; j < w; j++) {\n      if (s[i][j] == '@') start = {i, j};\n      else if (s[i][j] == '%') goal = {i, j};\n      else if (s[i][j] == '$') demons.emplace_back(i, j);\n    }\n  }\n\n  vector<vector<int>> d1(h, vector<int>(w, 1 << 30)), d2 = d1;\n  vector<P> tmp(1, start);\n  bfs(d1, tmp);\n  bfs(d2, demons);\n  cout << (d1[goal.y][goal.x] < d2[goal.y][goal.x] ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 2e2+2;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest,temp;\nint pshort,sshort;\nbool tf;\n\nstruct pt\n{\n    int x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n    //printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n    vis[y][x] = true;\n    if(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n    {\n        if((temp = dfs(x-1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y][x-1] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n    {\n        if((temp = dfs(x+1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y][x+1] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n    {\n        if((temp = dfs(x,y-1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y-1][x] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n    {\n        if((temp = dfs(x,y+1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y+1][x] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    return shortest;\n}\n\nint main()\n{\n    //freopen(\"1002.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&H,&W))\n    {\n        tf = true;\n        scnt = 0;\n        shortest = INF;\n        memset(labyrinth,-1,sizeof(labyrinth));\n        getchar();\n        for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                while((ch = getchar())=='\\n');\n                switch(ch)\n                {\n                case '@':\n                    princess.x = j;\n                    princess.y = i,labyrinth[i][j] = 1;\n                    break;\n                case '.':\n                    labyrinth[i][j] = 1;\n                    break;\n                case '\\$':\n                    soldier[scnt].x = j;\n                    soldier[scnt++].y = i;\n                    labyrinth[i][j] = 1;\n                    break;\n                case '%':\n                    labyrinth[i][j] = 2;\n                    escape.x = j;\n                    escape.y = i;\n                    break;\n                case '#':\n                    labyrinth[i][j] = 0;\n                    break;\n                }\n            }\n        }\n        /*for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                printf(\"%d\",labyrinth[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        memset(vis,false,sizeof(vis));\n        pshort = dfs(princess.x,princess.y,0);\n        //printf(\"pshort:%d\\n\",pshort);\n        if(pshort != INF)\n            for(int i = 0; i < scnt; ++i)\n            {\n                memset(vis,false,sizeof(vis));\n                shortest = INF;\n                sshort = dfs(soldier[i].x,soldier[i].y,0);\n                if(sshort <= pshort)\n                {\n                   // printf(\"sshort:%d\\n\",sshort);\n                    tf = false;\n                    break;\n                }\n            }\n        else\n            tf = false;\n        if(tf)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            printf(\"No\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  ac\n//\n//  Created by 胡天翼 on 2017/2/21.\n//  Copyright ? 2017年 胡天翼. All rights reserved.\n//\n\n#include <iostream>\n#include <set>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#define read freopen(\"in.txt\",\"r\",stdin)\n#define maxlongint 2147483647\ntypedef  long long LL;\ntypedef  unsigned long long ULL;\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n#define fori for(int i=1;i<=n;i++)\n#define forj for(int j=1;j<=m;j++)\n#define fork for(int k=1;k<=n;k++)\n#define FOR(i,n) for(int i=1;i<=n;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define DREP(i,a,b) for(int i=a;i>=b;i--)\n#define DOWN(i,n) for(int i=n;i>=1;i--)\n#define enter cout<<endl;\n#define in push_back\n#define out pop_back\n#define sqr(x) ((x)*(x))\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define offcin ios::sync_with_stdio(false)\n#define s(n) scanf(\"%d\",&n)\n#define sll(n) scanf(\"%lld\",&n)\n#define sd(x,y) scanf(\"%d%d\",&x,&y)\n#define sch(s) scanf(\"%s\",s)\n#define fillfalse(v) memset(v,false,sizeof(v))\n#define filltrue(v) memset(v,true,sizeof(v))\n#define f0(a)    memset(a,0,sizeof(a))\n#define Fillplus(a)    memset(a,-1,sizeof(a))\n#define lowbit(x) x&(-x)\nusing namespace std;\nconst int maxn = 1e5+5;\nconst int mod=1e9+7;\nint x,y,z,n,m;\nchar a[400][400];\nbool v[400][400];\nint xx,yy,x2,y2,ans,pp;\nstruct app\n{\n    int x,y,a;\n};\napp tmp;\nstring s;\nbool in(int x,int y)\n{\n    return x<=n&&x>=1&&y>=1&&y<=m;\n}\nint main() {\n    cin>>n>>m;\n    fori {cin>>s; REP(j,1,m) {a[i][j]=s[j-1]; if(a[i][j]=='@') {xx=i;yy=j;} if(a[i][j]=='%') {x2=i;y2=j;}}}\n    queue<app> Q;\n    tmp.x=xx;\n    tmp.y=yy;\n    tmp.a=0;\n    v[xx][yy]=1;\n    Q.push(tmp);\n    ans=0;\n    while(!Q.empty())\n    {\n        tmp=Q.front();\n        Q.pop();\n        x=tmp.x;\n        y=tmp.y;\n        z=tmp.a;\n//        cout<<x<<\" \"<<y<<\" \"<<z<<endl;\n        if(!v[x+1][y]&&in(x+1,y)&&a[x+1][y]!='#')\n        {\n            v[x+1][y]=1;\n            if(x+1==x2&&y==y2) {ans=z+1; break;}\n            tmp.x=x+1;\n            tmp.y=y;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x-1][y]&&in(x-1,y)&&a[x-1][y]!='#')\n        {\n            v[x-1][y]=1;\n            if(x-1==x2&&y==y2) {ans=z+1; break;}\n            tmp.x=x-1;\n            tmp.y=y;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x][y+1]&&in(x,y+1)&&a[x][y+1]!='#')\n        {\n            v[x][y+1]=1;\n            if(x==x2&&y+1==y2) {ans=z+1; break;}\n            tmp.x=x;\n            tmp.y=y+1;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x][y-1]&&in(x,y-1)&&a[x][y-1]!='#')\n        {\n            v[x][y-1]=1;\n            if(x==x2&&y-1==y2) {ans=z+1; break;}\n            tmp.x=x;\n            tmp.y=y-1;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n    }\n    if(ans==0) {cout<<\"No\"<<endl; return 0;}\n    pp=0;\n    while(!Q.empty()) Q.pop();\n    f0(v);\n    tmp.x=x2;\n    tmp.y=y2;\n    tmp.a=0;\n    v[x2][y2]=1;\n    Q.push(tmp);\n    while(!Q.empty())\n    {\n        tmp=Q.front();\n        Q.pop();\n        x=tmp.x;\n        y=tmp.y;\n        z=tmp.a;\n        if(z>=ans) break;\n        if(!v[x+1][y]&&in(x+1,y)&&a[x+1][y]!='#')\n        {\n            v[x+1][y]=1;\n            if(a[x+1][y]=='$') {pp=1; break;}\n            tmp.x=x+1;\n            tmp.y=y;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x-1][y]&&in(x-1,y)&&a[x-1][y]!='#')\n        {\n            v[x-1][y]=1;\n            if(a[x-1][y]=='$') {pp=1; break;}\n            tmp.x=x-1;\n            tmp.y=y;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x][y+1]&&in(x,y+1)&&a[x][y+1]!='#')\n        {\n           \n            v[x][y+1]=1;\n            if(a[x][y+1]=='$') {pp=1; break;}\n            tmp.x=x;\n            tmp.y=y+1;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n        if(!v[x][y-1]&&in(x,y-1)&&a[x][y-1]!='#')\n        {\n            v[x][y-1]=1;\n            if(a[x][y-1]=='$') {pp=1; break;}\n            tmp.x=x;\n            tmp.y=y-1;\n            tmp.a=z+1;\n            Q.push(tmp);\n        }\n    }\n    \n    if(pp) cout<<\"No\"<<endl; else cout<<\"Yes\"<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[ty][tx] = 0;\n\tqueue<pii> q;\n\tq.push({ tx,ty });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tint p=mp[sy][sx], s = INF;\n\tREP(i, n) {\n\t\ts = min(s, mp[y[i]][x[i]]);\n\t}\n\tif (p < s)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\n\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvs in;\nvvi d,dp;\nbool dfs(int a,int b,int c){\n\tif(dp[a][b]<c)return 0;\n\trep(i,4){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(x<0||y<0||x>=n||y>=m||in[x][y]=='#'||d[x][y]<=c+1||c+1>=dp[x][y])continue;\n\t\tif(in[x][y]=='%'){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 1;\n\t\t}\n\t\td[x][y]=c+1;\n\t\tif(dfs(x,y,c+1))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vs(n);\n\trep(i,n)cin>>in[i];\n\tdp=vvi(n,vi(m,inf));\n\tpriority_queue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='$'){\n\t\tque.push(tp(i,j,0));\n\t\tdp[i][j]=0;\n\t}\n\twhile(!que.empty()){\n\t\tint x,y,co;\n\t\ttie(x,y,co)=que.top();\n\t\tque.pop();\n\t\tif(dp[x][y]<co)continue;\n\t\trep(i,4){\n\t\t\tint nx=x+dx[i];\n\t\t\tint ny=y+dy[i];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#'||dp[nx][ny]<=co+1)continue;\n\t\t\tdp[nx][ny]=co+1;\n\t\t\tque.push(tp(nx,ny,co+1));\n\t\t}\n\t}\n\td=vvi(n,vi(m,inf));\n\trep(i,n)rep(j,m)if(in[i][j]=='@'){\n\t\td[i][j]=0;\n\t\tif(!dfs(i,j,0))cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ==========================================================================\n//\n//                Starting by the name of Almighty Allah\n//\n// ==========================================================================\n\n#include <bits/stdc++.h>\n\n#include <algorithm>\n#include <cstdio>\n#include <sstream>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iostream>\n#include <fstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <iterator>\n#include <deque>\n#include <climits>\n#include <complex>\n#include <bitset>\n#include <limits>\n\nusing namespace std;\n\n#define LL                          long long\n#define ULL                         unsigned long long\n// I/O\n#define SS(s)                       scanf(\"%s\",s)\n\n#define I(X)                        scanf(\"%d\",     &(X))\n#define II(X, Y)                    scanf(\"%d%d\",   &(X), &(Y))\n#define III(X, Y, Z)                scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n\n#define IL(X)                       scanf(\"%lld\", &X)\n#define IIL(X,Y )                   scanf(\"%lld%lld\", &X,&Y)\n#define IIIL(X,Y,Z)                 scanf(\"%lld%lld%lld\", &X,&Y,&Z)\n\n#define ID(x)                       scanf(\"%lf\",&x)\n#define IID(x,y)                    scanf(\"%lf%lf\",&x,&y)\n#define IIID(x,y,z)                 scanf(\"%lf%lf%lf\",&x,&y,&z)\n\n#define DI(X)         int X;        I(X);\n#define DII(X, Y)     int X, Y;     II(X,Y)\n#define DIII(X, Y, Z) int X, Y, Z;  III(X,Y,Z);\n\n#define DIL(X)        LL X;         IL(X)\n#define DIIL(X,Y)     LL X,Y;       IIL(X,Y)\n#define DIIIL(X,Y,Z)  LL X,Y,Z;     IIIL(X,Y,Z)\n\n#define DDI(x)        double x;     ID(x);\n#define DDII(x,y)     double x,y;   IID(x,y);\n#define DDDII(x,y,z)  double x,y,z; IIID(x,y,z);\n\n#define PI(x)                       printf(\"%d\\n\",      x)\n#define PII(x,y)                    printf(\"%d %d\\n\",   x,y)\n#define PIII(x,y,z)                 printf(\"%d %d %d\\n\",x,y,z)\n\n#define PIL(x)                      printf(\"%lld\\n\",          x)\n#define PIIL(x,y)                   printf(\"%lld %lld\\n\",     x,y)\n#define PIIIL(x,y,z)                printf(\"%lld %lld %lld\\n\",x,y,z)\n\n// LOOP\n#define rep(i,a,b)                  for(int i=a;i<=b;i++)\n#define rev(i,a,b)                  for(int i=a;i>=b;i--)\n#define repv(i,a)                   for(int i=0;i<(int)a.size();i++)\n#define revv(i,a)                   for(int i=((int)a.size())-1;i>=0;i--)\n\n#define FS(x)                       for(typeof (x.begin()) it = x.begin(); it != x.end (); it++)\n#define PR(x)                       for(typeof (x.begin()) it = x.begin(); it != x.end (); it++) {  cout << *it << \" \"; } cout << endl;\n#define PV(a)                       for(int i=0;i<(int)a.size();i++) printf(\"%d%c\",a[i],(i+1==(int)a.size() ? '\\n': ' '));\n// array initialization\n#define MEM(a,val)                  memset(a,val,sizeof(a));\n#define SET(a)                      memset(a,-1,sizeof a)\n#define CLR(a)                      memset(a,0,sizeof a)\n// min-max\n#define Max(a,b)                    (a>b?a:b)\n#define Min(a,b)                    (a<b?a:b)\n#define _Max(a,b,c)                 Max(a,Max(b,c))\n#define _Min(a,b,c)                 Min(a,Min(b,c))\n#define MAXV(a)                      (*max_element(all(a)))\n#define MINV(a)                      (*min_element(all(a)))\n\n#define FastMax(x,y)                ((((y-x)>>(32-1))&(x^y))^y)\n#define FastMin(x,y)                ((((y-x)>>(32-1))&(x^y))^x)\n\n#define SQR(n)          ((n)*(n))\n\n#define all(a)          a.begin(),a.end()\n#define PB              push_back\n#define NL              puts(\"\");\n#define pline           cout << \"_________________________\" << endl;\n// pair\n#define X               first\n#define Y               second\n// binary search\n#define LB(a,x)         (lower_bound(all(a),x)-a.begin()) // Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.\n#define UB(a,x)         (upper_bound(all(a),x)-a.begin()) // Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.\ntemplate<typename T> T  In()   {  char ch; T n = 0; bool ng = false; while (1) { ch = getchar(); if (ch == '-') { ng = true; ch = getchar(); break;} if (ch>='0' && ch<='9') break; }    while (1) { n = n*10 + (ch - '0'); ch = getchar(); if (ch<'0' || ch>'9')   break;    }  return (ng?-n:n);  }\n#define SI(X)           X=In<int>()\n#define SII(X,Y)        X=In<int>(),Y=In<int>()\n#define SIII(X,Y,Z)     X=In<int>(),Y=In<int>(),Z=In<int>()\n#define SL(X)           X=In<LL>()\n#define SLL(X,Y)        X=In<LL>(),Y=In<LL>()\n#define SLLL(X,Y,Z)     X=In<LL>(),Y=In<LL>(),Z=In<LL>()\n// segment_tree\n#define SEG             int mid=(s+e)>>1,l=(idx<<1),r=(l|1)\n#define lchild          l,s,mid\n#define rchild          r,mid+1,e\n\n#define T(a)            cerr << #a << \": \" << a << \" | \"<< endl;\n#define TT(a,b)         cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << endl;\n#define TTT(a,b,c)      cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << endl;\n#define TTTT(a,b,c,d)   cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" << #d << \": \" << d << endl;\n\n#define in(l,x,r)       ( l<=x && x<=r )\n#define in2(r,c,x,y)    ( in(1,x,r) && in(1,y,c) )\n// Bitwise-operation\n#define countbit(x)     __builtin_popcount(x)\ntemplate< class T, class X > inline bool checkbit(T a, X pos) { T t=1;return ((a&(t<<pos))>0);  }\ntemplate< class T, class X > inline T      setbit(T a, X pos) { T t=1;return (a|(t<<pos));      }\ntemplate< class T, class X > inline T    resetbit(T a, X pos) { T t=1;return (a&(~(t<<pos)));   }\ntemplate< class T, class X > inline T   togglebit(T a, X pos) { T t=1;return (a^(t<<pos));      }\n#define ctone(a) ( ( (~a)==0 )?32: __builtin_ctz( ~a ) )\n// mathematics\ntemplate<typename T> T POW(T base,T power)              { T ret=1; while(power)  { if(power & 1) ret=(ret*base); base=(base*base);  power>>=1; }return ret; }\ntemplate<typename T> T GCD(T a,T b)                     { if(a<0)return GCD(-a,b);if(b<0)return GCD(a,-b);return (b==0)?a:GCD(b,a%b);}\ntemplate<typename T> T LCM(T a,T b)                     { if(a<0)return LCM(-a,b);if(b<0)return LCM(a,-b);return a*(b/GCD(a,b));}\ntemplate<typename T> T EUCLIDE(T a,T b,T &x,T &y)       { if(a<0){T d=euclide(-a,b,x,y);x=-x;return d;}   if(b<0){T d=euclide(a,-b,x,y);y=-y;return d;}   if(b==0){x=1;y=0;return a;}else{T d=euclide(b,a%b,x,y);T t=x;x=y;y=t-(a/b)*y;return d;}}\ntemplate<typename T> T ABS(T a)                         { if(a<0)return -a;else return a;}\nLL Bigmod(LL base,LL power,LL _MOD)                      { LL ret=1;while(power){if(power & 1)ret=(ret*base)%_MOD;base=(base*base)%_MOD;power>>=1;}return ret;}\nLL ModInverse(LL number,LL _MOD)                         { return Bigmod(number,_MOD-2LL,_MOD); }\n// geometry\ntemplate<typename T> double DIS(T x1,T y1,T x2, T y2)   { return sqrt( (double)( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) ) );}\ntemplate<typename T> T ANGLE(T x1,T y1,T x2, T y2)      { return atan( double(y1-y2) / double(x1-x2));}\ntemplate<typename T> LL isLeft(T a,T b,T c)             { return (c.x-a.x)*(b.y-a.y)-(b.x-a.x)*(c.y-a.y); }\n// Degree and Radian\nconst double PI = 2 * acos(0);\ndouble DEG(double x) { return (180.0*x)/(PI*1.0);}\ndouble RAD(double x) { return (x*(PI*1.0))/(180.0);}\n// debug\nvoid BINARY(int n){  bitset<31>a=n;  cout << a << endl;}\nvoid P_ARR(int *ar,int a,int b) {  if(a>b) swap(a,b); if(a<=b) cout << ar[a]; for(int i=a+1;i<=b;i++) cout << \" \"<<ar[i];  cout << endl; }\ntemplate<class T> inline void make_unique_vec( vector<T> &vec ){ sort( vec.begin(), vec.end() ); vec.erase( unique( vec.begin(), vec.end() ), vec.end() ); }\ntemplate<class T> inline void make_unique_arr( T *ar,int &n)   { sort(ar + 1, ar + n + 1); n = unique(ar + 1, ar + n + 1) - ar - 1; }\n// for (map<int, int>::iterator it = mp.begin() , int cnt=0; it != mp.end(); it++) {  mp[it->first] = cnt++; }\n//int month[]={31,28,31,30,31,30,31,31,30,31,30,31};                                    /// month\nint dir[5][2] = { {0,0},{1,0},{0,1},{-1,0},{0,-1} };                                  /// 4 Direction\n//int dir[9][2] = { {0,0},{1,0},{0,1},{-1,0},{0,-1},{-1,1},{-1,-1},{1,-1},{1,1}};       /// 8 direction\n//int dir[9][2] = { {0,0},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1} };    /// Knight Direction\n//int dir[8][2] = { {0,0},{2,0},{1,1},{-1,1} ,{-2,0} , {-1,-1} ,{1,-1} };               /// Hexagonal Direction\n// dir[][0] = x value, dir[][1] = y value\n/// ======================================================================================================\n#define  debug  0\n#define  AA     if(debug)\n#define  eps     (1e-7)\n#define  pi      (2.0*acos(0.0)) //#define PI acos(-1.0)\n// IO\n#define  READ   freopen(\"C:\\\\Users\\\\PCNAME\\\\Desktop\\\\input.txt\",\"r\",stdin)\n#define  WRITE  freopen(\"C:\\\\Users\\\\PCNAME\\\\Desktop\\\\output.txt\",\"w\",stdout)\n#define  _cin   ios_base::sync_with_stdio(0); cin.tie(0);\n//#define  FF      fflush(stdout) // use after printf (for interactive problem)\n//#define  FFF     cout << flush  // use after cout (for interactive problem)\n//              0123456789\n#define  MX     207\n#define  MOD    1000000007LL\n#define  inf    2000000007\n\n#define PC printf(\"Case %d: \",cas)\n\n\nint ar[MX];\n\n// '@', '$', '%', '.', and '#' represent the princess, a soldier, the escape hatch, an empty cell, and a wall\n\nint dis[MX][MX];\nint vis[MX][MX];\nint n,m;\nchar ss[MX][MX];\n\nint main()\n{\n    II(n,m);\n\n    rep(i,1,n)\n    {\n        SS(ss[i]+1);\n    }\n\n    queue<int>q;\n\n    int a,b;\n    int s,e;\n\n    rep(i,1,n) rep(j,1,m)\n    {\n        dis[i][j] = inf;\n        vis[i][j] = inf;\n\n        if( ss[i][j]=='$' )\n        {\n            q.push(i);\n            q.push(j);\n            dis[i][j]=0;\n        }\n\n        if( ss[i][j]=='@' )\n        {\n            a=i;\n            b=j;\n            vis[a][b] = 0;\n        }\n\n        if( ss[i][j]=='%' )\n        {\n            s=i;\n            e=j;\n        }\n\n    }\n\n    while( !q.empty() )\n    {\n        int x = q.front(); q.pop();\n        int y = q.front(); q.pop();\n\n        int cst = dis[x][y]+1;\n\n        rep(i,1,4)\n        {\n            int xx = x+dir[i][0];\n            int yy = y+dir[i][1];\n\n            if( in2(n,m,xx,yy)  && ss[xx][yy]!='#' && dis[xx][yy]>cst )\n            {\n                dis[xx][yy] = cst;\n                q.push(xx);\n                q.push(yy);\n            }\n        }\n    }\n\n    q.push(a);\n    q.push(b);\n\n    while( !q.empty() )\n    {\n        int x = q.front(); q.pop();\n        int y = q.front(); q.pop();\n\n        int cst = vis[x][y]+1;\n\n        rep(i,1,4)\n        {\n            int xx = x+dir[i][0];\n            int yy = y+dir[i][1];\n\n            if( in2(n,m,xx,yy)  && ss[xx][yy]!='#' && vis[xx][yy]>cst && cst<dis[xx][yy] )\n            {\n                vis[xx][yy] = cst;\n                q.push(xx);\n                q.push(yy);\n            }\n        }\n    }\n\n    if( vis[s][e]!=inf ) puts(\"Yes\");\n    else puts(\"No\");\n\n\n\n\n\n\n\n\n\n//  main();\n\n\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 2e2+2;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest,temp;\nint pshort,sshort;\nbool tf;\n\nstruct pt\n{\n    int x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n    //printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n    vis[y][x] = true;\n    if(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n    {\n        if((temp = dfs(x-1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y][x-1] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n    {\n        if((temp = dfs(x+1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y][x+1] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n    {\n        if((temp = dfs(x,y-1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y-1][x] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    if(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n    {\n        if((temp = dfs(x,y+1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n        if(labyrinth[y+1][x] == 2)\n        {\n            return cur_length+1;\n        }\n    }\n    return shortest;\n}\n\nint main()\n{\n    //freopen(\"1002.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&H,&W))\n    {\n        tf = true;\n        scnt = 0;\n        shortest = INF;\n        memset(labyrinth,-1,sizeof(labyrinth));\n        getchar();\n        for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                while((ch = getchar())=='\\n');\n                switch(ch)\n                {\n                case '@':\n                    princess.x = j;\n                    princess.y = i,labyrinth[i][j] = 1;\n                    break;\n                case '.':\n                    labyrinth[i][j] = 1;\n                    break;\n                case '$':\n                    soldier[scnt].x = j;\n                    soldier[scnt++].y = i;\n                    labyrinth[i][j] = 1;\n                    break;\n                case '%':\n                    labyrinth[i][j] = 2;\n                    escape.x = j;\n                    escape.y = i;\n                    break;\n                case '#':\n                    labyrinth[i][j] = 0;\n                    break;\n                }\n            }\n        }\n       \n        memset(vis,false,sizeof(vis));\n        pshort = dfs(princess.x,princess.y,0);\n       // printf(\"pshort:%d\\n\",pshort);\n        if(!scnt&&pshort!=INF)\n        {\n            tf = true;\n        }\n        else\n        {\n            if(pshort != INF)\n                for(int i = 0; i < scnt; ++i)\n                {\n                    memset(vis,false,sizeof(vis));\n                    shortest = INF;\n                    sshort = dfs(soldier[i].x,soldier[i].y,0);\n                    //printf(\"sshort:%d\\n\",sshort);\n                    if(sshort <= pshort)\n                    {\n                        tf = false;\n                        break;\n                    }\n                }\n            else\n                tf = false;\n\n        }\n        if(tf)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            printf(\"No\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nint W,H,div_row[4] = {-1,0,0,1},div_col[4] = {0,-1,1,0};\nchar map[200][201];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid calcDist(int distance[200][200],int row,int col,int dist){\n\n\tfor(int i = 0; i < 4; i++){\n\t\tif(rangeCheck(row+div_row[i],col+div_col[i]) == true && map[row+div_row[i]][col+div_col[i]] != '#' &&  //???????????????????§???????????£???§?????????\n\t\t\t\t(distance[row+div_row[i]][col+div_col[i]] == -1 || distance[row+div_row[i]][col+div_col[i]] > dist+1)){ //??????(?§???????????????¢??????????¨????????????????????????????????????????????????????)\n\t\t\tdistance[row+div_row[i]][col+div_col[i]] = dist+1;\n\t\t\tcalcDist(distance,row+div_row[i],col+div_col[i],dist+1);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint escape_row,escape_col;\n\tscanf(\"%d %d\",&H,&W);\n\n\tint distance[200][200];\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W;k++){\n\t\t\tdistance[i][k] = -1;\n\t\t\tif(map[i][k] == '%'){\n\t\t\t\tescape_row = i;\n\t\t\t\tescape_col = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tdistance[escape_row][escape_col] = 0;\n\n\tcalcDist(distance,escape_row,escape_col,0);\n\n\tint princess,enemy = 50000;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(map[i][k] == '@'){\n\t\t\t\tprincess = distance[i][k];\n\t\t\t}else if(map[i][k] == '$'){\n\t\t\t\tif(distance[i][k] != -1){\n\t\t\t\t\tenemy = min(enemy,distance[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(princess == -1 || princess >= enemy){\n\t\tprintf(\"No\\n\");\n\t}else{\n\t\tprintf(\"Yes\\n\");\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//file stream\n#define output freopen(\"output.txt\",\"w\",stdout)\n#define input freopen(\"input.txt\",\"r\",stdin)\n//functions\n#define pb(x)  push_back(x)\n// if needed pair\n#define f first\n#define s second\n#define mp(x,y) make_pair(x,y)\n\n\n//inputs 1 var\n#define s1i(n) scanf(\"%d\",&n)\n#define s1u(n) scanf(\"%u\",&n)\n#define s1l(n) scanf(\"%lld\",&n)\n#define s1lu(n) scanf(\"%llu\",&n)\n#define s1d(n) scanf(\"%lf\",&n)\n#define s1s(n) scanf(\"%s\",n)\n//inputs 2 var\n#define s2i(n,m) scanf(\"%d %d\",&n,&m)\n#define s2u(n,m) scanf(\"%u %u\",&n,&m)\n#define s2l(n,m) scanf(\"%lld %lld\",&n,&m)\n#define s2lu(n,m) scanf(\"%llu %llu\",&n,&m)\n#define s2d(n,m) scanf(\"%lf %lf\",&n,&m)\n//inputs 3 var\n#define s3i(n,m,l) scanf(\"%d %d %d\",&n,&m,&l)\n#define s3u(n,m,l) scanf(\"%u %u %u\",&n,&m,&l)\n#define s3l(n,m,l) scanf(\"%lld %lld %lld\",&n,&m,&l)\n#define s3lu(n,m,l) scanf(\"%llu %llu %llu\",&n,&m,&l)\n#define s3d(n,m,l) scanf(\"%lf %lf %lf\",&n,&m,&l)\n\n//output 1 var\n#define p1i(n) printf(\"%d\",n)\n#define p1u(n) printf(\"%u\",n)\n#define p1l(n) printf(\"%lld\",n)\n#define p1lu(n) printf(\"%llu\",n)\n#define p1d(n,pre) printf(\"%.*f\",pre,n)\n#define p1s(n) printf(\"%s\",n)\n//output 2 var\n#define p2i(n,m) printf(\"%d %d\",n,m)\n#define p2u(n,m) printf(\"%u %u\",n,m)\n#define p2l(n,m) printf(\"%lld %lld\",n,m)\n#define p2lu(n,m) printf(\"%llu %llu\",n,m)\n#define p2d(n,m,pre) printf(\"%.*f %.*f\",pre,n,pre,m)\n//inputs 3 var less important\n#define p3i(n,m,l) printf(\"%d %d %d\",n,m,l)\n#define p3u(n,m,l) printf(\"%u %u %u\",n,m,l)\n#define p3l(n,m,l) printf(\"%lld %lld %lld\",n,m,l)\n#define p3lu(n,m,l) printf(\"%llu %llu %llu\",n,m,l)\n//output misc\n#define nline() putchar(10)\n#define space() putchar(' ')\n#define pch(c) putchar(c)\n#define tcase(i) printf(\"Case %d:\",i)\n//loop\n#define fr0(i,n) for(i=0;i<n;i++)\n#define fr1(i,n) for(i=1;i<=n;i++)\n//memory reset\n#define set0(x) memset(x,0,sizeof x)\n#define setn1(x) memset(x,-1,sizeof x)\n#define setinf(x) memset(x,125,sizeof x)\n//bit operation single variable\n#define On(x,i)  (x|=(1<<(i)))\n#define Off(x,i) (x&= ~(1<<(i)))\n#define isOn(x,i) (x&(1<<(i)))\n#define Toggle(x,i) (x^=(1<<(i)))\n#define tmod(x,i)  (x&(~(-1<<i)))\n\n//data type\ntypedef long long ll;\ntypedef unsigned long long ull;\n//bit operation array\n//constant\nconst double EPS = 1e-9;\nusing namespace std;\nint tc,o,prc,sld,i,j,r,c,x,y;\n\nchar B[250][250];\nqueue<pair<int,int> > q;\nmap<pair<int,int> ,int> level,visited;\npair<int,int>u;\nmain()\n{\n    {\n        s2i(r,c);\n        fr0(i,r)\n        {\n            scanf(\"%s\",B[i]);\n            fr0(j,c)\n            {\n                if(B[i][j]=='%')\n                {\n                    x=i,y=j;continue;\n                }\n            }\n        }\n        q.push(mp(x,y));\n        level[mp(x,y)]=0;\n        visited[mp(x,y)]=1;\n        sld=5000;prc=50000;\n        while(!q.empty())\n        {\n            u=q.front();q.pop();\n            if(B[u.f][u.s]=='@')prc=level[u];\n            if(B[u.f][u.s]=='$')sld=min(sld,level[u]);\n\n            if(u.f+1<r && B[u.f+1][u.s]!='#' && !visited[mp(u.f+1,u.s)])\n            {\n                level[mp(u.f+1,u.s)]=level[u]+1;\n                visited[mp(u.f+1,u.s)]=1;\n                q.push(mp(u.f+1,u.s));\n            }\n\n            if(u.s+1<c && B[u.f][u.s+1]!='#' && !visited[mp(u.f,u.s+1)])\n            {\n                level[mp(u.f,u.s+1)]=level[u]+1;\n                visited[mp(u.f,u.s+1)]=1;\n                q.push(mp(u.f,u.s+1));\n            }\n\n\n            if(u.f-1>=0 && B[u.f-1][u.s]!='#' && !visited[mp(u.f-1,u.s)])\n            {\n                level[mp(u.f-1,u.s)]=level[u]+1;\n                visited[mp(u.f-1,u.s)]=1;\n                q.push(mp(u.f-1,u.s));\n            }\n\n            if(u.s+1>=0 && B[u.f][u.s-1]!='#' && !visited[mp(u.f,u.s-1)])\n            {\n                level[mp(u.f,u.s-1)]=level[u]+1;\n                visited[mp(u.f,u.s-1)]=1;\n                q.push(mp(u.f,u.s-1));\n            }\n        }\n        if(prc<sld)printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nint main()\n{\n  int H, W;\n  cin >> H >> W;\n  char mas[202][202];\n  queue<Pi> que;\n  rep(i, H) rep(j, W) {\n    cin >> mas[i][j];\n    if(mas[i][j] == '%') que.push(Pi(i, j));\n  }\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {1, 0, -1, 0};\n  int d[202][202]; memset(d, -1, sizeof(d));\n  d[que.front().F][que.front().S] = 0;\n  int pri = -1; vector<int> sol;\n  while(!que.empty()) {\n    Pi p = que.front(); que.pop();\n    if(mas[p.F][p.S] == '@') {\n      pri = d[p.F][p.S];\n    } else if(mas[p.F][p.S] == '$') {\n      sol.push_back(d[p.F][p.S]);\n    }\n    rep(i, 4) {\n      if(0 <= p.F+dy[i] && p.F+dy[i] < H &&\n\t 0 <= p.S+dx[i] && p.S+dx[i] < W &&\n\t mas[p.F+dy[i]][p.S+dx[i]] != '#' &&\n\t d[p.F+dy[i]][p.S+dx[i]] == -1) {\n\tque.push(Pi(p.F+dy[i], p.S+dx[i]));\n\td[p.F+dy[i]][p.S+dx[i]] = d[p.F][p.S] + 1;\n      }\n    }\n  }\n  cout << (pri != -1 && (sol.empty() || *min_element(all(sol)) > pri) ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=0,pri=0;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<int,int> >Q;\n  queue<int>q1;\n  q1.push(0);\n  Q.push(mk(y,x));\n  while(!Q.empty()){\n    pair<int,int >a=Q.front();Q.pop();\n    int xx=a.second,yy=a.first,cc=q1.front();q1.pop();\n    b[yy][xx]=1;\n    if(pri&&pri<cc)break;\n    if(s[yy][xx]=='$'){sol=cc;}\n    if(s[yy][xx]=='@'){pri=cc;}\n    if(sol)break;\n    r(i,4){\n      int x1=xx+dx[i],y1=yy+dy[i];\n      if(x1<0||x1>=w||y1<0||y1>=h||b[y1][x1]||s[y1][x1]=='#')continue;\n          Q.push(mk(y1,x1));\n          q1.push(cc+1);\n    }\n  }\n  if(sol==0)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) cin >> v[i];\n\tint N = H * W;\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < H - 1; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == '#' || v[i + 1][j] == '#') continue;\n\t\t\tG[i * W + j].push_back(i * W + j + W);\n\t\t\tG[i * W + j + W].push_back(i * W + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W - 1; j++) {\n\t\t\tif (v[i][j] == '#' || v[i][j + 1] == '#') continue;\n\t\t\tG[i * W + j].push_back(i * W + j + 1);\n\t\t\tG[i * W + j + 1].push_back(i * W + j);\n\t\t}\n\t}\n\tint s = -1, g = -1; vector<int> sol;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == '$') sol.push_back(i * W + j);\n\t\t\tif (v[i][j] == '@') s = i * W + j;\n\t\t\tif (v[i][j] == '%') g = i * W + j;\n\t\t}\n\t}\n\tvector<int> solt(N, 999999999);\n\tqueue<int> que1;\n\tfor (int i : sol) que1.push(i), solt[i] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (solt[i] == 999999999) {\n\t\t\t\tsolt[i] = solt[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dist(N, 999999999); dist[s] = 0;\n\tqueue<int> que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == 999999999 && solt[i] > dist[u] + 1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dist[g] != 999999999 ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll h, w;\nstring s[210];\nll d[210][210];\nll dd[210][210];\nll sx, sy;\nll dx[] = { 0,1,0,-1 };\nll dy[] = { 1,0,-1,0 };\n\nvoid solve() {\n\trep(i, 210)rep(j, 210)d[i][j] = INF;\n\td[sy][sx] = 0;\n\n\ttypedef pair<P, ll> ppi;\n\tqueue<ppi> que;\n\tque.push(ppi({ sy,sx }, 0));\n\twhile (que.size()) {\n\t\tppi p = que.front();\n\t\tque.pop();\n\t\tint y = p.first.first;\n\t\tint x = p.first.second;\n\t\t//cout << \"!\" << y << \" \" << x << endl;\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\t//cout << ny << \" \" << nx << endl;\n\t\t\tif (ny >= h || ny < 0 || nx >= w || nx < 0)continue;\n\t\t\tif (s[ny][nx] == '#')continue;\n\t\t\tif (d[ny][nx] > p.second + 1) {\n\t\t\t\td[ny][nx] = p.second + 1;\n\t\t\t\tif (s[ny][nx] == '.')que.push(ppi(P(ny, nx), d[ny][nx]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> h >> w;\n\trep(i, h) {\n\t\tcin >> s[i];\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == '%') {\n\t\t\t\tsx = j, sy = i;\n\t\t\t}\n\t\t}\n\t}\n\tsolve();\n\tll dd = INF;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == '@')dd = d[i][j];\n\t\t}\n\t}\n\tbool f = 1;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (s[i][j] == '$') {\n\t\t\t\tif (dd >= d[i][j])f = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (f)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n#define MAX 210\nchar c[MAX][MAX];\n\nint p[MAX][MAX] = {};\nint s[MAX][MAX] = {};\n\nint H, W;\nbool inrange(int i, int j) {\n\treturn 0 <= i&&i < H && 0 <= j&&j < W;\n}\nint di[] = { 1,0,-1,0 };\nint dj[] = { 0,1,0,-1 };\nvoid bfsp(int si, int sj) {\n\tqueue<pair<int, int>> Q, NQ;\n\tNQ.emplace(si, sj);\n\tint cnt = 0;\n\twhile (NQ.size()) {\n\t\tswap(Q, NQ);\n\t\twhile (Q.size()) {\n\t\t\tauto a = Q.front(); Q.pop();\n\t\t\tint i = a.first, j = a.second;\n\t\t\tif (!inrange(i, j))continue;\n\t\t\tif (c[i][j] == '#')continue;\n\t\t\tif (p[i][j] <= cnt)continue;\n\t\t\tp[i][j] = cnt;\n\t\t\trep(h, 0, 4) {\n\t\t\t\tNQ.emplace(i + di[h], j + dj[h]);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n}\nvoid bfss(int si, int sj) {\n\tqueue<pair<int, int>> Q, NQ;\n\tNQ.emplace(si, sj);\n\tint cnt = 0;\n\twhile (NQ.size()) {\n\t\tswap(Q, NQ);\n\t\twhile (Q.size()) {\n\t\t\tauto a = Q.front(); Q.pop();\n\t\t\tint i = a.first, j = a.second;\n\t\t\tif (!inrange(i, j))continue;\n\t\t\tif (c[i][j] == '#')continue;\n\t\t\tif (s[i][j] <= cnt)continue;\n\t\t\ts[i][j] = cnt;\n\t\t\trep(h, 0, 4) {\n\t\t\t\tNQ.emplace(i + di[h], j + dj[h]);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n}\n\n\nsigned main() {\n\tcin >> H >> W;\n\tint pi, pj;\n\tint si = -1, sj;\n\tint ei, ej;\n\tmemset(p, 0x3f, sizeof(p));\n\tmemset(s, 0x3f, sizeof(s));\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tcin >> c[i][j];\n\n\t\tif (c[i][j] == '@')pi = i, pj = j;\n\t\tif (c[i][j] == '$')si = i, sj = j;\n\t\tif (c[i][j] == '%')ei = i, ej = j;\n\t}\n\tbfsp(pi, pj);\n\tif (si != -1)bfss(si, sj);\n\n\tif (p[ei][ej] == INF || p[ei][ej] >= s[ei][ej])cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> aa;\n\nchar s[210][210]; //地? \nint p[210][210];  //距? \nint k[210][210];  //到aa的映射 \nint t, x, y, x2, y2;      //士兵个数 公主坐? ?的坐? \nint h, w;\n\nvoid try1(int x, int y, int l)\n{\n\t//cout << x << \" \" << y << \" \" << l << endl;\n\tif (l >= 8) return;\n\tif (s[x][y] == '$' && aa[k[x][y]] > l)\n\t{\n\t\taa[k[x][y]] = l;\n\t}\n\tif (x - 1 >= 0 && s[x - 1][y] != '#' && l + 1 < p[x - 1][y])\n\t{\n\t\tp[x - 1][y] = l + 1;\n\t\ttry1(x - 1, y, l + 1);\n\t}\n\tif (x + 1 < h && s[x + 1][y] != '#' && l + 1 < p[x + 1][y])\n\t{\n\t\tp[x + 1][y] = l + 1;\n\t\ttry1(x + 1, y, l + 1);\n\t}\n\tif (y - 1 >= 0 && s[x][y - 1] != '#' && l + 1 < p[x][y - 1])\n\t{\n\t\tp[x][y - 1] = l + 1;\n\t\ttry1(x, y - 1, l + 1);\n\t}\n\tif (y + 1 < w && s[x][y + 1] != '#' && l + 1 < p[x][y + 1])\n\t{\n\t\tp[x][y + 1] = l + 1;\n\t\ttry1(x, y + 1, l + 1);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tint m = 80000,q;\n\twhile (cin >> h >> w)\n\t{\n\tt = 0;\n\taa.clear();\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tcin >> s[i][j];\n\t\t\tif (s[i][j] == '@')\n\t\t\t{\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t\tif (s[i][j] == '$')\n\t\t    {\n\t\t    \taa.push_back(m);\n\t\t    \tk[i][j] = t;\n\t\t    \tt++;\n\t\t\t}\n\t\t\tif (s[i][j] == '%')\n\t\t\t{\n\t\t\t\tx2 = i;\n\t\t\t\ty2 = j;\n\t\t\t}\n\t\t\tp[i][j] = 80000;\n\t\t}\n\t\tgetchar();\n\t}\n\tif (t == 0)\n\t{\n\t\tcout << \"Yes\" << endl;\n\t\tcontinue;\n\t}\n\tp[x2][y2] = 0;\n\ttry1(x2, y2, 0);\n\tq = 1;\n\tfor (auto i = aa.begin(); i != aa.end(); i++)\n\t{\n\t\tif ((*i) <= p[x][y])\n\t\t{\n\t\t\tq = 0;\n\t\t    break;\n\t\t}\n\t } \n\tif (q)\n\t{\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"No\" << endl;\n\t}\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n*\n*\t\t\tArif Hosan\n*American International University Bangladesh\n*\n**/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<set>\n#define PI 2*acos(0.0)\n#define SIZE 1000000\n#define endl '\\n'\nint caseno = 1;\n#define CP() printf(\"Case %d: \",caseno++)\n#define R() freopen(\"in.txt\",\"r\",stdin)\n#define W() freopen(\"out.txt\",\"w\",stdout)\n#define RW R(); W()\n#define SFI(_i) scanf(\"%d\",&_i)\n#define SFII(_i,_ii) scanf(\"%d%d\",&_i,&_ii)\n#define SFD(_i) scanf(\"%lf\",&_i)\n#define SFC(_c) scanf(\"%c\",&_c)\n#define PFIL(_i) printf(\"%d\\n\",_i)\n#define PFI(_i) printf(\"%d\",_i)\n#define PFSL(_i) printf(\"%s\\n\",_i)\n#define PFS(_i) printf(\"%s\",_i)\n#define NL printf(\"\\n\")\n#define SPC printf(\" \")\n#define ALL(_c) _c.begin(),_c.end()\n#define ITE(_a,_b) map<_a,_b>::iterator\n#define MEM(_c,_v) memset(_c,_v,sizeof(_c))\n#define FOR(i,a,b) for(i=(a);i<(b);i++)\n#define REV(i,a,b) for(i=(a);i>=(b);i--)\n#define valid(nx,ny) nx>=0 && nx<H && ny>=0 && ny<w\nusing namespace std;\nint dirx[] = { 0,0,1,-1 }, diry[] = { 1,-1,0,0 };\nint H, w;\nint levP[205][205], levG[205][205];\nstring G[205];\n\nbool BFSP(int i, int j) {\n\tqueue<pair<int, int> >Q;\n\tQ.push(make_pair(i, j));\n\twhile(!Q.empty()) {\n\t\tpair<int, int> P = Q.front(); Q.pop();\n\t\tif(G[P.first][P.second]=='%') return false;\n\t\tint x,y;\n\t\tFOR(x,0,4) {\n\t\t\tint ti = P.first + dirx[x];\n\t\t\tint tj = P.second + diry[x];\n\t\t\tif(valid(ti,tj) && (G[ti][tj] != '#' && G[ti][tj] != '$') && levP[ti][tj]==-1) {\n\t\t\t\tlevP[ti][tj] = levP[P.first][P.second] + 1;\n\t\t\t\tQ.push(make_pair(ti, tj));\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool BFSG(int i, int j) {\n\tqueue<pair<int, int> >Q;\n\tQ.push(make_pair(i, j));\n\twhile (!Q.empty()) {\n\t\tpair<int, int> P = Q.front(); Q.pop();\n\t\t//if (levP[P.first][P.second]!=-1 && levG[P.first][P.second] <= levP[P.first][P.second]) \n\t\tif (G[P.first][P.second]=='%' && levP[P.first][P.second] != -1 && levG[P.first][P.second] <= levP[P.first][P.second])\n\t\t\treturn true;\n\t\tif (G[P.first][P.second] == '%') return false;\n\t\tint x, y;\n\t\tFOR(x, 0, 4) {\n\t\t\tint ti = P.first + dirx[x];\n\t\t\tint tj = P.second + diry[x];\n\t\t\tif (valid(ti, tj) && G[ti][tj] != '#' && levG[ti][tj] == -1) {\n\t\t\t\tlevG[ti][tj] = levG[P.first][P.second] + 1;\n\t\t\t\tQ.push(make_pair(ti, tj));\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\t\tMEM(levP, -1);\n\t\tint i, j;\n\t\tbool status = false;\n\t\tFOR(i, 0, H) cin >> G[i];\n\t\tFOR(i,0,H) {\n\t\t\tFOR(j,0,w) {\n\t\t\t\tif(G[i][j]=='@') {\n\t\t\t\t\tlevP[i][j] = 0;\n\t\t\t\t\tstatus=BFSP(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!status) {\n\t\t\tFOR(i, 0, H) {\n\t\t\t\tFOR(j, 0, w) {\n\t\t\t\t\tif (G[i][j] == '$') {\n\t\t\t\t\t\tMEM(levG, -1);\n\t\t\t\t\t\tlevG[i][j] = 0;\n\t\t\t\t\t\tstatus = BFSG(i, j);\n\t\t\t\t\t\tif (status) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (status) break;\n\t\t\t}\n\t\t}\n\t\tif (status) PFSL(\"No\");\n\t\telse PFSL(\"Yes\");\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define ff first\n#define ss second\n\ntypedef vector<int> vi;\nint ara[205][205];\npii d, p;\n\nvector<string> grid;\nint xx[] = {0, 0, 1, -1};\nint yy[] = {1, -1, 0, 0};\nint n, m;\n\nbool isValid(int x, int y){\n\treturn (x>=0 && y>=0 && x<n && y<m);\t\n}\n\nvoid cost(int x, int y){\n\tqueue<int> qx, qy;\n\tqx.push(x);\n\tqy.push(y);\n\tmemset(ara, 0, sizeof(ara));\n\tara[x][y] = 1;\n\twhile(!qx.empty()){\n\t\tx = qx.front();\n\t\ty = qy.front();\n\t\tqx.pop();\n\t\tqy.pop();\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint tx = x+xx[i], ty = y+yy[i];\n\t\t\tif(isValid(tx, ty) && !ara[tx][ty] && grid[tx][ty] != '#'){\n\t\t\t\tqx.push(tx);\n\t\t\t\tqy.push(ty);\n\t\t\t\tara[tx][ty] = ara[x][y]+1;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&n, &m);\n\n    grid = vector<string>(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> grid[i];\n\t}\n\t\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(grid[i][j] == '%') d = mp(i, j);\n\t\t\telse if(grid[i][j] == '@') p = mp(i, j);\t\t\n\t\t}\n\t}\n\n\tcost(d.ff, d.ss);\n\t\n\tbool flag = true;\n\tint mn = ara[p.ff][p.ss], t;\n\tfor(int i=0; i<n && flag; i++){\n\t\tfor(int j=0; j<m && flag; j++){\n\t\t\tif(grid[i][j] == '$'){\n\t\t\t\tflag = (mn < ara[i][j]);\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\tif(flag) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    int sx, sy;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (S[x][y] == '%') {\n                sx = x;\n                sy = y;\n            }\n        }\n    }\n\n    queue<pair<int, int>> que;\n    que.emplace(sx, sy);\n    vector<vector<int>> dist(H, vector<int>(W, INF));\n    dist[sx][sy] = 0;\n\n    while (!que.empty()) {\n        int x, y;\n        tie(x, y) = que.front();\n        que.pop();\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n                S[nx][ny] == '#' || dist[nx][ny] < INF) continue;\n\n            dist[nx][ny] = dist[x][y] + 1;\n            que.emplace(nx, ny);\n        }\n    }\n\n    int pri, sol = INF;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (S[x][y] == '@') {\n                pri = dist[x][y];\n            } else if (S[x][y] == '$') {\n                sol = min(sol, dist[x][y]);\n            }\n        }\n    }\n\n    cout << (pri < sol ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nstring mp[N];\n\nint bfs(char s){\n  queue<P> Q;\n  int D[N][N]={};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) \n      if(mp[i][j]==s)Q.push(P(i,j)),D[i][j]=1;\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int y=t.first,x=t.second;\n    if(mp[y][x]=='\\%') return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||D[ny][nx]!=-1||mp[ny][nx]=='#')continue;\n      Q.push(P(ny,nx));\n      D[ny][nx]=D[y][x]+1;\n    }\n  }\n  return 1e9;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<((bfs('@')<bfs('$'))? \"Yes\":\"No\")<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    using P = pair<int, int>;\n    P a, b;\n    vector<vector<int>> v(h+2, vector<int> (w+2, 0));\n    queue<P> Q, QQ;\n    vector<vector<int>> dist1(h+2, vector<int> (w+2, MOD));\n\n    auto dist2 = dist1;\n\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            v[i+1][j+1] = (s[j] != '#');\n            if(s[j] == '@') {\n                a = {i + 1, j + 1};\n                dist1[i+1][j+1] = 0;\n            }\n            else if(s[j] == '%') b = {i+1, j+1};\n            else if(s[j] == '$') {\n                Q.emplace(i+1, j+1);\n                dist2[i+1][j+1] = 0;\n            }\n        }\n    }\n    array<int, 4> di{0, 0, -1, 1}, dj{1, -1, 0, 0};\n\n    QQ.emplace(a);\n    while(!QQ.empty()){\n        int i, j;\n        tie(i, j) = QQ.front(); QQ.pop();\n        for (int k = 0; k < 4; ++k) {\n            if(v[i+di[k]][j+dj[k]] && dist1[i+di[k]][j+dj[k]] > dist1[i][j]+1){\n                dist1[i+di[k]][j+dj[k]] = dist1[i][j]+1;\n                QQ.emplace(i+di[k], j+dj[k]);\n            }\n        }\n    }\n    while(!Q.empty()){\n        int i, j;\n        tie(i, j) = Q.front(); Q.pop();\n        for (int k = 0; k < 4; ++k) {\n            if(v[i+di[k]][j+dj[k]] && dist2[i+di[k]][j+dj[k]] > dist2[i][j]+1){\n                dist2[i+di[k]][j+dj[k]] = dist2[i][j]+1;\n                Q.emplace(i+di[k], j+dj[k]);\n            }\n        }\n    }\n    puts((dist2[b.first][b.second] > dist1[b.first][b.second]) ? \"Yes\" : \"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4]={1, 0, 0, -1};\nint dy[4]={0, 1, -1, 0};\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  int sx,sy;\n  vector<vector<char> > map(h+2, vector<char>(w+2, '#'));\n  for(int i=1; i<=h; i++){\n    for(int j=1; j<=w; j++){\n      cin >> map[i][j];\n      if(map[i][j]=='%'){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n\n  queue<pair<int,pair<int,int> > > q;\n  q.push(make_pair(0, make_pair(sy,sx)));\n  int princess=1e9;\n  int soldier=1e9;\n  while(!q.empty()){\n    int step=q.front().first;\n    int y=q.front().second.first;\n    int x=q.front().second.second;\n    q.pop();\n    if(map[y][x]=='@'){\n      princess = step;\n    }\n    if(map[y][x]=='$'){\n      soldier = step;\n    }\n    map[y][x]='#';\n\n    for(int i=0; i<4; i++){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(map[ny][nx]!='#'){\n        q.push(make_pair(step+1, make_pair(ny,nx)));\n      }\n    }\n  }\n\n  if(princess<soldier){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring solve()\n{\n    int h,w;\n    cin >>h >>w;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n    #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n\n    int px,py;\n    rep(i,h)rep(j,w)if(s[i][j]=='%')\n    {\n        py = i;\n        px = j;\n    }\n\n    while(1)\n    {\n        vector<string> ns(s);\n        rep(i,h)rep(j,w)if(s[i][j]=='@')\n        {\n            rep(k,4)\n            {\n                int nx = j+dx[k], ny = i+dy[k];\n                if(IN(nx,ny) && (s[ny][nx]=='.'||s[ny][nx]=='%')) ns[ny][nx]='@';\n            }\n        }\n\n        rep(i,h)rep(j,w)if(s[i][j]=='$')\n        {\n            rep(k,4)\n            {\n                int nx = j+dx[k], ny = i+dy[k];\n                if(IN(nx,ny) && s[ny][nx]!='#') ns[ny][nx]='$';\n            }\n        }\n\n        s = ns;\n        if(s[py][px]=='@') return \"Yes\";\n        if(s[py][px]=='$') return \"No\";\n    }\n}\n\nint main()\n{\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<string>s(H);\n\tfor (auto &i : s)cin >> i;\n\tvector<vector<int>>adis(H, vector<int>(W, MOD));\n\tvector<vector<int>>bdis(H, vector<int>(W, MOD));\n\tvector<vector<int>>cdis(H, vector<int>(W, MOD));\n\tqueue<pair<int, int>>Q;\n\tint dir[] = { 1,0,-1,0,1 };\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '@') {\n\t\t\t\tQ.emplace(i, j);\n\t\t\t\tadis[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint cy, cx;\n\t\ttie(cy, cx) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ny = cy + dir[i];\n\t\t\tint nx = cx + dir[i + 1];\n\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\tif (s[ny][nx] == '#')continue;\n\t\t\tif (adis[ny][nx] > adis[cy][cx] + 1) {\n\t\t\t\tadis[ny][nx] = adis[cy][cx] + 1;\n\t\t\t\tQ.emplace(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '$') {\n\t\t\t\tQ.emplace(i, j);\n\t\t\t\tbdis[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint cy, cx;\n\t\ttie(cy, cx) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ny = cy + dir[i];\n\t\t\tint nx = cx + dir[i + 1];\n\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\tif (s[ny][nx] == '#')continue;\n\t\t\tif (bdis[ny][nx] > bdis[cy][cx] + 1) {\n\t\t\t\tbdis[ny][nx] = bdis[cy][cx] + 1;\n\t\t\t\tQ.emplace(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '@') {\n\t\t\t\tQ.emplace(i, j);\n\t\t\t\tcdis[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint cy, cx;\n\t\ttie(cy, cx) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ny = cy + dir[i];\n\t\t\tint nx = cx + dir[i + 1];\n\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W)continue;\n\t\t\tif (s[ny][nx] == '#')continue;\n\t\t\tif (adis[ny][nx] >= bdis[ny][nx])continue;\n\t\t\tif (cdis[ny][nx] > cdis[cy][cx] + 1) {\n\t\t\t\tcdis[ny][nx] = cdis[cy][cx] + 1;\n\t\t\t\tQ.emplace(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = MOD;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == '%') {\n\t\t\t\tans = cdis[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == MOD)cout << \"No\\n\";\n\telse cout << \"Yes\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2781\n\nsigned main(){\n\t// cin.tie(nullptr);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\tint H, W;\n\tint pd = INF;\n\tvector<string> mp;\n\tqueue<pair<int,pair<int,int>>> Q;\n\tvector<vector<int>> dis;\n\t\n\tcin>>H>>W;\n\t\n\tmp.resize(H);\n\tdis.resize(H,vector<int>(W, INF));\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tcin>>mp[i];\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(mp[i][j] == '%'){\n\t\t\t\tdis[i][j] = 0;\n\t\t\t\tQ.push(make_pair(0,make_pair(i, j)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile(!Q.empty()){\n\t\tpair<int,pair<int,int>> p = Q.front(); Q.pop();\n\t\tint d = p.first, x = p.second.second, y = p.second.first;\n\t\t\n\t\tif(dis[y][x] < d) continue;\n\t\t\n\t\tif(mp[y][x] == '@') pd = d;\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint ny = y + (2 - i)%2, nx = x + (i - 1)%2;\n\t\t\t\n\t\t\tif(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n\t\t\t\n\t\t\tif(mp[ny][nx] == '#') continue;\n\t\t\t\n\t\t\tif(dis[ny][nx] > d + 1){\n\t\t\t\tdis[ny][nx] = d + 1;\n\t\t\t\tQ.push(make_pair(d+1,make_pair(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(pd == INF){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(mp[i][j] == '$'){\n\t\t\t\tif(pd >= dis[i][j]){\n\t\t\t\t\tcout<<\"No\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<\"Yes\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<cctype>\n#include<string.h>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#include<fstream>\n#include<cstdlib>\n#include<vector>\n#include<map>\n#include<set>\n#include<utility>\n#include<iomanip>\n#include<queue>\nusing namespace std;\n\n#define LL long long int\n#define uLL unsigned long long int\n\n#define S(a) scanf(\"%d\",&a)\n#define S2(a,b) scanf(\"%d%d\",&a,&b)\n#define S3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define SLL(a) scanf(\"%lld\",&a)\n#define SLL2(a,b) scanf(\"%lld%lld\",&a,&b)\n#define SLL3(a,b,c) scanf(\"%lld%lld%lld\",&a,&b,&c)\n#define SC(a) scanf(\"%c\",&a)\n#define P(a) printf(\"%d\",a)\n#define PS(a) printf(\"%s\",a)\n#define PLL(a) printf(\"%lld\",a)\n#define PCASE(kk) printf(\"Case %d: \",kk++)\n#define PCASENL printf(\"Case %d:\\n\",kk++)\n#define NL puts(\"\")\n\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pi (2.0*acos(0.0))\n#define pii pair<int,int>\n\nlong long int gcd(long long int c,long long int d)\n{\n    if(d==0) return c;\n    else return gcd(d,c%d);\n}\n\n//knight and king move....\n\n//int Dx[]={-2,-1,1,2,1,2,-2,-1};\n//int Dy[]={-1,-2,2,1,-2,-1,1,2};\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n//////////////////////////////////////////////////\n\nint n,m,cell_tim[210][210],sx,sy,ex,ey;\nchar ch[210][210];\n\nint chk(int x,int y)\n{\n    if(x<1 || x>n)return 0;\n    if(y<1 || y>m)return 0;\n    if(ch[x][y]=='#')return 0;\n    return 1;\n}\n\nvoid bfs(int x,int y,int ti)\n{\n    queue<pair<int,pair<int,int> > >q;\n\n    q.push( mp(x,mp(y,0) ) );\n//    vis[x][y]=0;\n    while(!q.empty())\n    {\n        pair<int,pair<int,int> > fr = q.front();\n        q.pop();\n        x=fr.first;\n        y=fr.second.first;\n        ti=fr.second.second;\n        cell_tim[x][y]=ti;\n//        cout<<x<<\" \"<<y<<\" \"<<ti<<endl;\n        for(int i=0;i<4;i++)\n        {\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n            //ti=fr.second.second+1;\n            if(chk(nx,ny)==1 && cell_tim[nx][ny]>ti+1)\n            {\n//                cell_time[nx][ny]=ti+1;\n                q.push( mp(nx,mp(ny,ti+1)) );\n            }\n        }\n    }\n    return ;\n}\n\nint dfs1(int x,int y,int ti)\n{\n    if(chk(x,y)==0)return 0;\n    if(cell_tim[x][y]<=ti)return 0;\n    //cout<<x<<\" \"<<y<<\" \"<<ti<<endl;\n    if(x==ex && y==ey)return 1;\n    cell_tim[x][y]=ti;\n    int ret=0;\n    for(int i=0;i<4;i++)\n    {\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        ret|=dfs1(nx,ny,ti+1);\n        if(ret)break;\n    }\n    return ret;\n}\n\nint main()\n{\n    S2(n,m);\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            scanf(\" %c\",&ch[i][j]);\n            if(ch[i][j]=='@')sx=i,sy=j;\n            if(ch[i][j]=='%')ex=i,ey=j;\n        }\n    }\n\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=m;j++)cell_tim[i][j]=1000000000;\n    }\n//    cout<<\"asdf\"<<endl;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(ch[i][j]=='$')\n            {\n                bfs(i,j,0);\n            }\n        }\n    }\n\n//    for(int i=1;i<=n;i++)\n//    {\n//        for(int j=1;j<=m;j++)\n//        {\n//            cout<<cell_time[i][j]<<\" \";\n//        }\n//        NL;\n//    }\n\n    int ans=dfs1(sx,sy,0);\n    if(ans==1)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n//const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint h, w;\n\tcin >> h >> w;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tint sx, sy;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == '%')\n\t\t{\n\t\t\tsx = i; sy = j;\n\t\t}\n\t}\n\tint pr = INF, so = INF;\n\tqueue<pii> que;\n\tque.emplace(sx, sy);\n\tvector<vi> dist(h, vi(w, INF));\n\tdist[sx][sy] = 0;\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front().first;\n\t\tint y = que.front().second;\n\t\tque.pop();\n\t\tif (fld[x][y] == '@') chmin(pr, dist[x][y]);\n\t\tif (fld[x][y] == '$') chmin(so, dist[x][y]);\n\t\tREP(i, 4)\n\t\t{\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#' || dist[nx][ny] < INF) continue;\n\t\t\tdist[nx][ny] = dist[x][y] + 1;\n\t\t\tque.emplace(nx, ny);\n\t\t}\n\t}\n\tcout << (pr < so ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n#define MAX 210\nchar c[MAX][MAX];\n\nint p[MAX][MAX] = {};\nint s[MAX][MAX] = {};\n\nint H, W;\nbool inrange(int i, int j) {\n\treturn 0 <= i&&i < H && 0 <= j&&j < W;\n}\nint di[] = { 1,0,-1,0 };\nint dj[] = { 0,1,0,-1 };\nvoid dfsp(int i, int j, int cnt) {\n\tif (!inrange(i, j))return;\n\tif (c[i][j] == '#')return;\n\tif (p[i][j] < cnt)return;\n\tp[i][j] = cnt;\n\trep(h, 0, 4) {\n\t\tdfsp(i + di[h], j + dj[h], cnt + 1);\n\t}\n}\nvoid dfss(int i, int j, int cnt) {\n\tif (!inrange(i, j))return;\n\tif (c[i][j] == '#')return;\n\tif (s[i][j] < cnt)return;\n\ts[i][j] = cnt;\n\trep(h, 0, 4) {\n\t\tdfss(i + di[h], j + dj[h], cnt + 1);\n\t}\n}\n\n\nsigned main() {\n\tcin >> H >> W;\n\tint pi, pj;\n\tint si = -1, sj;\n\tint ei, ej;\n\tmemset(p, 0x3f, sizeof(p));\n\tmemset(s, 0x3f, sizeof(s));\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tcin >> c[i][j];\n\n\t\tif (c[i][j] == '@')pi = i, pj = j;\n\t\tif (c[i][j] == '$')si = i, sj = j;\n\t\tif (c[i][j] == '%')ei = i, ej = j;\n\t}\n\tdfsp(pi, pj, 0);\n\tif (si != -1)dfss(si, sj, 0);\n\n\tif (p[ei][ej] == INF || p[ei][ej] >= s[ei][ej])cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nchar mp[209][209];\nint mark[209][209];\nint px[4]= {0,1,0,-1};\nint py[4]= {1,0,-1,0};\nconst int inf=99999;\nint ans[209][209];\nint bfs(int x,int y )\n{\n    if (ans[x][y]!=-1)return ans[x][y];\n    if (mark[x][y]==1||mp[x][y]=='#')return inf;\n    if (mp[x][y]=='%')return 1;\n    int anss=inf;\n    mark[x][y]=1;\n    for (int i =0; i<4; i++)\n    {\n        if (x+px[i]>=0&&x+px[i]<n&&y+py[i]>=0&&y+py[i]<m)\n            anss=min(anss,bfs(x+px[i],y+py[i])+1);\n    }\n    mark[x][y]=0;\n    if (anss>=inf)\n    {\n        ans[x][y]=inf;\n        return inf;\n    }\n    else return ans[x][y]=anss;\n}\nint main ()\n{\n    while (~scanf(\"%d%d\",&n,&m))\n    {\n        memset(mark,0,sizeof(mark));\n        for (int i =0; i<n; i++)\n        {\n            scanf(\"%s\",&mp[i]);\n        }\n        memset(ans,-1,sizeof(ans));\n        int sd=inf;\n        int pr=inf;\n        for (int i =0; i<n; i++)\n            for (int j =0; j<m; j++)\n                if (mp[i][j]=='@')\n                    pr=bfs(i,j);\n        for (int i =0; i<n; i++)\n        {\n            for (int j =0; j<m; j++)\n            {\n                if (mp[i][j]=='$')\n                {\n                    if (ans[i][j]!=-1)\n                    sd=min(sd,ans[i][j]);\n                }\n            }\n        }\n        if (pr>=sd)printf (\"No\\n\");\n        else printf (\"Yes\\n\");\n    }\n}\n\n/*\n3 4\n.%..\n.##$\n.@$.\n3 4\n.%..\n.##.\n.@$$\n3 4\n.%..\n.##.\n$@$.\n10 10\n$.........\n..........\n..........\n#########%\n..........\n..........\n..........\n..........\n..........\n.........@\n10 10\n%.........\n..........\n..........\n#########$\n..........\n..........\n..........\n..........\n..........\n.........@\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<cstdio>  \n#include<cstring>  \n#include<algorithm>  \n#include<queue>  \n  \nusing namespace std;  \nconst int MAXN = 210;  \nconst int  INF = 0x3f3f3f;  \n  \nint dirt[4][2]={{1,0},{-1,0},{0,-1},{0,1}};  \nchar map[MAXN][MAXN];  \nint vis[MAXN][MAXN];  \nint n,m;//,flag;  \nint sx,sy;  \nint num1 = INF,num2 = INF;  \n  \n  \nstruct node{  \n    int x,y,num;  \n};  \nvoid BFS(){  \n    vis[sx][sy]=1;  \n    queue<node>q;  \n    node a,b;  \n    a.x=sx,a.y=sy,a.num = 0;  \n    q.push(a);  \n    while(!q.empty()){  \n        a = q.front();  \n        q.pop();  \n        for(int i=0;i<4;i++){  \n            b.x = a.x+dirt[i][0];  \n            b.y = a.y+dirt[i][1];  \n            b.num = a.num+1;  \n            if(b.x<0||b.x>=n||b.y<0||b.y>=m){  \n                continue;  \n            }  \n            if(map[b.x][b.y] == '#'){  \n                continue;  \n            }  \n            if(map[b.x][b.y]=='@'){  \n                //flag=1;  \n                num1 = min(num1,b.num);  \n                //continue;  \n                continue;  \n            }  \n            if(map[b.x][b.y] == '$'){  \n                //flag=0;  \n                num2 = min(num2,b.num);  \n                continue;  \n                //continue;  \n            }  \n            if(map[b.x][b.y] == '.' && !vis[b.x][b.y]){  \n                vis[b.x][b.y] = 1;  \n                q.push(b);  \n            }  \n  \n        }  \n        //if(flag){  \n            //return;  \n        //}  \n  \n  \n  \n    }  \n}  \nint main(){  \n  \n    char s[210];  \n    scanf(\"%d%d\",&n,&m);  \n    for(int i=0;i<n;i++){  \n        scanf(\"%s\",s);  \n        //int l = strlen(s);  \n        for(int j=0;s[j] != '\\0';j++){  \n            map[i][j] = s[j];  \n            if(map[i][j]=='%'){  \n                sx = i,sy=j;  \n            }  \n        }  \n    }  \n    BFS();  \n    if(num1 < num2)  \n        printf(\"Yes\\n\");  \n    else  \n        printf(\"No\\n\");  \n    return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n#define MAX 210\nchar c[MAX][MAX];\nint p[MAX][MAX], s[MAX][MAX];\nint H, W;\nbool inrange(int i, int j) {\n\treturn 0 <= i&&i < H && 0 <= j&&j < W;\n}\nint di[] = { 1,0,-1,0 };\nint dj[] = { 0,1,0,-1 };\nint bfsp(int si, int sj) {\n\tqueue<pair<int, int>> Q, NQ;\n\tNQ.emplace(si, sj);\n\tint cnt = 0;\n\twhile (NQ.size()) {\n\t\tswap(Q, NQ);\n\t\twhile (Q.size()) {\n\t\t\tauto a = Q.front(); Q.pop();\n\t\t\tint i = a.first, j = a.second;\n\t\t\tif (!inrange(i, j))continue;\n\t\t\tif (c[i][j] == '#')continue;\n\t\t\tif (p[i][j] <= cnt)continue;\n\t\t\tp[i][j] = cnt;\n\t\t\tif (c[i][j] == '%')return cnt;\n\t\t\trep(h, 0, 4) {\n\t\t\t\tNQ.emplace(i + di[h], j + dj[h]);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\treturn INF;\n}\nint bfss(int si, int sj) {\n\tqueue<pair<int, int>> Q, NQ;\n\tNQ.emplace(si, sj);\n\tint cnt = 0;\n\twhile (NQ.size()) {\n\t\tswap(Q, NQ);\n\t\twhile (Q.size()) {\n\t\t\tauto a = Q.front(); Q.pop();\n\t\t\tint i = a.first, j = a.second;\n\t\t\tif (!inrange(i, j))continue;\n\t\t\tif (c[i][j] == '#')continue;\n\t\t\tif (s[i][j] <= cnt)continue;\n\t\t\ts[i][j] = cnt;\n\t\t\tif (c[i][j] == '$')return cnt;\n\t\t\trep(h, 0, 4) {\n\t\t\t\tNQ.emplace(i + di[h], j + dj[h]);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\treturn INF;\n}\n\nsigned main() {\n\tcin >> H >> W;\n\tint si = -1, sj;\n\tmemset(p, 0x3f, sizeof(p));\n\tmemset(s, 0x3f, sizeof(s));\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tcin >> c[i][j];\n\t}\n\tint a = INF;\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tif (c[i][j] == '@')a = bfsp(i, j);\n\t}\n\tint b = INF;\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tif (c[i][j] == '%')chmin(b, bfss(i, j));\n\t}\n\n\tif (a >= b)cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n/*\n * @ princess\n * $ soldier\n * % hatch\n * . empty\n * # wall\n */\n\nstruct S {\n    int x, y, dist;\n    S() {}\n    S(int a, int b, int c): x(a), y(b), dist(c) {}\n};\n\nint H, W;\nstring arr[222];\n\nint visited[222][222];\n\nint p_dist = INF;\nint s_dist = INF;\n\nvoid dfs(int x, int y, int dist = 0) {\n    visited[x][y] = true;\n    if (arr[x][y] == '@') {\n        s_dist = dist;\n    } else if (arr[x][y] == '$') {\n        p_dist = min(p_dist, dist);\n    }\n    for (int j = 0; j < 4; ++j) {\n        int nx = x + dx[j], ny = y + dy[j];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n        if (arr[nx][ny] != '#' && !visited[nx][ny]) {\n            dfs(nx, ny, dist+1);\n        }\n    }\n}\n\nint main() {\n    cin >> H >> W;\n    for (int j = 0; j < H; ++j) {\n        cin >> arr[j];\n    }\n    for (int j = 0; j < H; ++j) { fill(visited[j], visited[j]+W, 0); }\n\n\n    int sx, sy;\n    \n    for (int j = 0; j < H; ++j) {\n        int val = arr[j].find('%');\n        if (val != -1) {\n            sx = j; sy = val;\n            break;\n        }\n    }\n\n\n    const string result = [&]() {\n        int p_dist = INF;\n        int s_dist = INF;\n        queue<S> que;\n        que.emplace(sx, sy, 0);\n        visited[sx][sy] = true;\n        while (!que.empty()) {\n            S p = que.front(); que.pop();\n            int x = p.x, y = p.y;\n            if (arr[x][y] == '@') {\n                p_dist = p.dist;\n            } else if (arr[x][y] == '$') {\n                s_dist = min(s_dist, p.dist);\n            }\n            if (p_dist < p.dist) {\n                break;\n            }\n            for (int j = 0; j < 4; ++j) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n                if (arr[nx][ny] != '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    que.emplace(nx, ny, p.dist+1);\n                }\n            }\n        }\n        return p_dist < s_dist ? \"Yes\" : \"No\";\n    }();\n\n    cout << result << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\nstruct node\n{\n    int x, y;\n}q[80000];\nint n, m, dis[206][206];\nchar s[206][206];\nint sol, girl;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvoid bfs(int ex, int ey)\n{\n    int l=0, r=0;\n    q[r++] = node{ex, ey};\n    dis[ex][ey] = 0;\n    while(l < r)\n    {\n        node u = q[l++];\n        for(int i=0; i<4; ++i)\n        {\n            int mx = u.x + dx[i];\n            int my = u.y + dy[i];\n            if(mx < 0 || mx >= n || my < 0 || my >= m || s[mx][my] == '#' || dis[mx][my] != -1) continue;\n            dis[mx][my] = dis[u.x][u.y] + 1;\n            q[r++] = node{mx, my};\n            if(s[mx][my]=='$')\n                sol = min(sol, dis[mx][my]);\n            else if(s[mx][my] == '@')\n                girl = dis[mx][my];\n        }\n    }\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        sol = girl = 1e9;\n        memset(dis, -1, sizeof(dis));\n        for(int i=0; i<n; ++i)\n            scanf(\"%s\",s[i]);\n        for(int i=0; i<n; ++i)\n        {\n            for(int j=0; j<m; ++j)\n            {\n                if(s[i][j] == '%')\n                {\n                    bfs(i,j);\n                    break;\n                }\n            }\n        }\n        //printf(\"%d %d\\n\",sol,girl);\n        if(sol > girl || (sol == 1e9&&girl!=1e9))\n           puts(\"Yes\");\n        else\n            puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n#include <list>\nusing namespace std;\ntypedef long long ll;\nchar s[205][205];\nbool vis[205][205];\nbool visq[205][205];\nstruct aa\n{\n    int deep;\n    int x;\n    int y;\n};\nqueue<aa>p;\nqueue<aa>so;\nint dr[4] = {0,0,1,-1};\nint dc[4] = {-1,1,0,0};\nint n,m;\nbool judge(int x,int y)\n{\n    if(x < 0 || x >= n)return false;\n    if(y < 0 || y >= m)return false;\n    return true;\n}\nbool bfs()\n{\n    int deep = 0;\n    aa temp;\n    int tx,ty;\n    while(1)\n    {\n        while(!so.empty())\n        {\n            temp = so.front();\n            if(temp.deep != deep)\n            {\n                break;\n            }\n            so.pop();\n            for(int i = 0; i < 4; i ++)\n            {\n                tx = temp.x + dr[i];\n                ty = temp.y + dc[i];\n                if(judge(tx,ty) == true &&s[tx][ty] != '#'&& vis[tx][ty] == false)\n                {\n                    vis[tx][ty] = true;\n                    temp.x = tx,temp.y = ty,temp.deep += 1;\n                    so.push(temp);\n                }\n            }\n        }\n        while(!p.empty())\n        {\n            temp = p.front();\n            if(temp.deep != deep)break;\n            p.pop();\n            for(int i = 0; i <4; i ++)\n            {\n                tx = temp.x + dr[i];\n                ty = temp.y + dc[i];\n                if(judge(tx,ty) == true &&s[tx][ty] != '#'&&visq[tx][ty] == false&& vis[tx][ty] == false)\n                {\n                    visq[tx][ty] = true;\n                    temp.x = tx,temp.y = ty,temp.deep += 1;\n                    if(s[temp.x][temp.y] == '%')return true;\n                    p.push(temp);\n                }\n            }\n        }\n        if(p.empty())return false;\n        deep ++;\n    }\n    return false;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0; i < n; i ++)\n    {\n        scanf(\"%s\",&s[i]);\n    }\n    aa temp;\n    for(int i = 0; i < n; i ++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(s[i][j] == '@')\n            {\n                temp.x = i,temp.y =j,temp.deep = 0;\n                p.push(temp);\n                vis[i][j] = true;\n            }\n            else if(s[i][j] == '$')\n            {\n                temp.x = i,temp.y =j,temp.deep = 0;\n                so.push(temp);\n                visq[i][j] = true;\n            }\n        }\n    }\n    bool flag = bfs();\n    if(flag == true)\n    {\n        printf(\"Yes\\n\");\n    }\n    else\n    {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2781.cc: Help the Princess!\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 200;\nconst int MAX_W = 200;\nconst int INF = 1 << 30;\n\nconst int dxs[] = { 1, 0, -1, 0 }, dys[] = { 0, -1, 0, 1 };\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef queue<pii> qpii;\n\n/* global variables */\n\nchar flds[MAX_H][MAX_W + 4];\nint dists[MAX_H][MAX_W];\n\n/* subroutines */\n\nbool bfs(qpii &q, int gx, int gy, int h, int w) {\n  while (! q.empty()) {\n    pii u = q.front(); q.pop();\n    int &ux = u.first, &uy = u.second;\n    if (ux == gx && uy == gy) return true;\n\n    int vd = dists[uy][ux] + 1;\n    \n    for (int di = 0; di < 4; di++) {\n      int vx = ux + dxs[di], vy = uy + dys[di];\n      if (vx >= 0 && vx < w && vy >= 0 && vy < h &&\n\t  flds[vy][vx] == '.' && dists[vy][vx] > vd) {\n\tdists[vy][vx] = vd;\n\tq.push(pii(vx, vy));\n      }\n    }\n  }\n\n  return false;\n}\n\n/* main */\n\nint main() {\n  int h, w;\n  scanf(\"%d%d\", &h, &w);\n\n  int px, py, gx, gy;\n  qpii q;\n\n  for (int y = 0; y < h; y++) {\n    scanf(\"%s\", flds[y]);\n    fill(dists[y], dists[y] + w, INF);\n    for (int x = 0; x < w; x++)\n      switch (flds[y][x]) {\n      case '@': px = x, py = y, flds[y][x] = '.'; break;\n      case '%': gx = x, gy = y, flds[y][x] = '.'; break;\n      case '$': q.push(pii(x, y)), dists[y][x] = 0, flds[y][x] = '.'; break;\n      }\n  }\n\n  bfs(q, -1, -1, h, w);\n  //for (int y = 0; y < h; y++) {\n  //for (int x = 0; x < w; x++) printf(\"%d \", dists[y][x]);\n  //putchar('\\n');\n  //}\n\n  dists[py][px] = 0;\n  q.push(pii(px, py));\n  bool ok = bfs(q, gx, gy, h, w);\n  if (ok) puts(\"Yes\");\n  else puts(\"No\");\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string M[H];\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n  }\n  int s_x, s_y;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == '%'){\n\ts_x = i;\n\ts_y = j;\n      }\n    }\n  }\n  queue< pair<int,int> > que;\n  que.push(make_pair(s_x, s_y));\n  vector< vector<int> > D(H, vector<int>(W,-1));\n  D[s_x][s_y] = 0;\n  int d[] = {1,0,-1,0,1};\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int i = 0; i < 4; ++i){\n      int x_next = x + d[i], y_next = y + d[i+1];\n      if(x_next >= 0 && x_next < H && y_next >= 0 && y_next < W && M[x_next][y_next] != '#' && D[x_next][y_next] < 0){\n\t  D[x_next][y_next] = D[x][y] + 1;\n\t  que.push(make_pair(x_next, y_next));\n\t}\n\t}\n    }\n    int p = 1000000000, s = 1000000000;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '@')\n\t  p = D[i][j];\n\tif(M[i][j] == '$')\n\t  s = min(D[i][j],s);\n      }\n    }\n    cout << ((p < s) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#define INF 999999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s,\n    vector<Weight> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    for(auto &f:g[e.dst]) {\n      if (dist[f.dst] > e.weight+f.weight) {\n        dist[f.dst] = e.weight+f.weight;\n        Q.push(Edge(f.src, f.dst, e.weight+f.weight));\n      }\n    }\n  }\n}\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string>v(H);\n\tfor(int i=0;i<H;i++)cin>>v[i];\n\tvector<int>soldiers;\n\tint start,princess=-1;\n\tGraph g(H*W);\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++){\n\t\tif(v[i][j]=='#')continue;\n\t\tint x=i*W+j,y,f;\n\t\tif(v[i][j]=='%')start=x;\n\t\tif(v[i][j]=='@')princess=x;\n\t\tif(v[i][j]=='$')soldiers.push_back(x);\n\t\tif(i<H-1){\n\t\t\ty=(i+1)*W+j;\n\t\t\tif(v[i+1][j]!='#')g[x].push_back(Edge(x,y,1)),g[y].push_back(Edge(y,x,1));\n\t\t}\n\t\tif(j<W-1){\n\t\t\ty=i*W+j+1;\n\t\t\tif(v[i][j+1]!='#')g[x].push_back(Edge(x,y,1)),g[y].push_back(Edge(y,x,1));\n\t\t}\n\t}\n\tvector<Weight> dist;\n\tvector<int> prev;\n\tshortestPath(g,start,dist,prev);\n\tWeight sol=INF;\n\tfor(int e:soldiers)sol=min(sol,dist[e]);\n\tputs(dist[princess]<sol ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    memset(dis, -1, sizeof(dis));\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                if(next.y == goal.y && next.x == goal.x) return dis[goal.y][goal.x];\n                q.push(next);\n            }\n        }\n    }\n    return INF;\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n\n    scanf(\"%d%d\", &h,&w);\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n            //cout << p << ' ' << s << endl;;\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\nusing P = pair<int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    int map[H][W];\n    P princess;\n    vector<P> soldier;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;\n            cin>>c;\n            map[i][j]=1;\n            if(c=='#') map[i][j]=0;\n            if(c=='%') map[i][j]=2;\n            if(c=='@') princess=P(j,i);\n            if(c=='$') soldier.emplace_back(j,i);\n        }\n    }\n    if(!soldier.size()){\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n    int dist[H][W];\n    queue<P> Q;\n    Q.push(princess);\n    fill(dist[0],dist[H],100000000);\n    int dist_princess=-1;\n    dist[get<1>(princess)][get<0>(princess)]=0;\n    while(!Q.empty()){\n        int x,y;\n        tie(x,y)=Q.front(); Q.pop();\n        if(map[y][x]==2){\n            dist_princess=dist[y][x];\n            while(!Q.empty()) Q.pop();\n            break;\n        }\n        int d[5]={0,1,0,-1,0};\n        for(int k=0;k<4;k++){\n            int dx=d[k],dy=d[k+1];\n            if(x+dx<0||W<=x+dx||y+dy<0||H<=y+dy) continue;\n            if(map[y+dy][x+dx]){\n                if(dist[y+dy][x+dx]>dist[y][x]+1){\n                    Q.push(P(x+dx,y+dy));\n                    dist[y+dy][x+dx]=dist[y][x]+1;\n                }\n            }\n        }\n    }\n    int dist_soldier=100000000;\n    fill(dist[0],dist[H],100000000);\n    for(auto s:soldier){\n        Q.push(s);\n        dist[get<1>(s)][get<0>(s)]=0;\n    }\n    while(!Q.empty()){\n        int x,y;\n        tie(x,y)=Q.front(); Q.pop();\n        if(map[y][x]==2){\n            dist_soldier=dist[y][x];\n            break;\n        }\n        int d[5]={0,1,0,-1,0};\n        for(int k=0;k<4;k++){\n            int dx=d[k],dy=d[k+1];\n            if(x+dx<0||W<=x+dx||y+dy<0||H<=y+dy) continue;\n            if(map[y+dy][x+dx]){\n                if(dist[y+dy][x+dx]>dist[y][x]+1){\n                    Q.push(P(x+dx,y+dy));\n                    dist[y+dy][x+dx]=dist[y][x]+1;\n                }\n            }\n        }\n    }\n    // cout<<dist_princess<<' '<<dist_soldier<<endl;\n    if(dist_soldier<=dist_princess){\n        cout<<\"No\"<<endl;\n    }else{\n        cout<<\"Yes\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long\n#define pii pair<int, int>\n#define MP make_pair\n#define ls i << 1\n#define rs ls | 1\n#define md (ll + rr >> 1)\n#define lson ll, md, ls\n#define rson md + 1, rr, rs\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define Pi acos(-1.0)\n#define eps 1e-12\n#define N 220\n#define M 400020\n\nchar s[N][N];\nint sx, sy;\nint n, m;\nint d[N][N];\n\nint dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};\n\nbool in(int x, int y) {\n\treturn x >= 1 && y >= 1 && x <= n && y <= m && s[x][y] != '#';\n}\n\nvoid bfs() {\n\tqueue<int> q;\n\tq.push(sx); q.push(sy);\n\tmemset(d, -1, sizeof d);\n\td[sx][sy] = 0;\n\twhile(!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tint y = q.front(); q.pop();\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tint dx = x + dir[i][0];\n\t\t\tint dy = y + dir[i][1];\n\t\t\tif(!in(dx, dy)) continue;\n\t\t\tif(d[dx][dy] == -1) {\n\t\t\t\td[dx][dy] = d[x][y] + 1;\n\t\t\t\tq.push(dx); q.push(dy);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i) {\n\t\tscanf(\"%s\", s[i] + 1);\n\t\tfor(int j = 1; j <= m; ++j) {\n\t\t\tif(s[i][j] == '%') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t}\n\t\t}\n\t}\n\tbfs();\n\tint d1 = inf, d2 = inf;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= m; ++j) {\n\t\t\tif(s[i][j] == '@') d1 = d[i][j];\n\t\t\tif(s[i][j] == '$' && d[i][j] != -1) {\n\t\t\t\td2 = min(d2, d[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(d1 < d2) puts(\"Yes\");\n\telse puts(\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2781.cpp\n// Author: ymiyamoto\n//\n// Created on Fri Dec 29 19:30:51 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nuint32_t wfs(vector<string> map, int32_t y, int32_t x)\n{\n  vector<vector<int32_t>> visited(map.size(), vector<int32_t>(map[0].size(), -1));\n  visited[y][x] = 0;\n  queue<pair<int32_t, int32_t>> q;\n  q.push({y, x});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> p = q.front();\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> ds = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    for (auto d : ds) {\n      int32_t y2 = p.first + d.first;\n      int32_t x2 = p.second + d.second;\n      if (0 <= y2 && y2 < (int32_t)map.size() && 0 <= x2 && x2 < (int32_t)map[0].size() && (visited[y2][x2] == -1)) {\n        if (map[y2][x2] == '#') continue;\n        visited[y2][x2] = visited[p.first][p.second] + 1;\n        q.push({y2, x2});\n      }\n    }\n  }\n\n  for (uint32_t i = 0; i < map.size(); i++) {\n    for (uint32_t j = 0; j < map[0].size(); j++) {\n      if (map[i][j] == '%') {\n        return visited[i][j];\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  uint32_t H, W;\n  cin >> H >> W;\n  vector<string> map;\n  for (uint32_t i = 0; i < H; i++) {\n    string line;\n    cin >> line;\n    map.push_back(line);\n  }\n\n  uint32_t princess;\n  uint32_t soldier = UINT32_MAX;\n  for (uint32_t y = 0; y < H; y++) {\n    for (uint32_t x = 0; x < W; x++) {\n      if (map[y][x] == '@') {\n        princess = wfs(map, y, x);\n      } else if (map[y][x] == '$') {\n        soldier = min(soldier, wfs(map, y, x));\n      }\n    }\n  }\n\n  if (princess < soldier) {\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n#define pii pair<int, int>\n#define tii tuple<int, int, int>\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nqueue<pii> que;\n\nint main(void){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = 0; i < h; i++) cin >> s[i];\n    vector<vector<int> > g(h, vector<int>(w, 99999));\n    \n    int py, px, hy, hx;\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) \n        if (s[i][j] == '$') que.push(make_pair(i,j)), g[i][j] = 0;\n        else if (s[i][j] == '@') py = i, px = j;\n        else if (s[i][j] == '%') hy = i, hx = j;\n        else if (s[i][j] == '#') g[i][j] = -1;\n        \n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int ty = p.first, tx = p.second, node = g[ty][tx];\n        for (int i = 0; i < 4; i++) {\n            int ny = ty + dy[i];\n            int nx = tx + dx[i];\n            if (ny < 0 || ny >= h || nx < 0 || nx >= w || g[ny][nx] == -1) continue;\n            if (g[ny][nx] > node+1) {\n                g[ny][nx] = node+1;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    int sol = g[hy][hx];\n    \n    g[py][px] = 0;\n    que.push(make_pair(py,px));\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int ty = p.first, tx = p.second, node = g[ty][tx];\n        for (int i = 0; i < 4; i++) {\n            int ny = ty + dy[i];\n            int nx = tx + dx[i];\n            if (ny < 0 || ny >= h || nx < 0 || nx >= w || g[ny][nx] == -1) continue;\n            if (g[ny][nx] > node+1) {\n                g[ny][nx] = node+1;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    if (sol == g[hy][hx]) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nusing T3=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    char M[H][W];\n    int dist[H][W];\n    queue<T3> Q;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>M[i][j];\n            if(M[i][j]=='%'){\n                dist[i][j]=0;\n                Q.push(T3(i,j,0));\n            }else{\n                dist[i][j]=1000000;\n            }\n        }\n    }\n    int dist_p = 1000000, dist_s=1000000;\n    while(!Q.empty()){\n        int i,j,d;\n        tie(i,j,d)=Q.front();\n        Q.pop();\n        if(M[i][j]=='@') dist_p=d;\n        if(M[i][j]=='$') dist_s=min(dist_s,d);\n        int diff[5]={0,-1,0,1,0};\n        for(int k=0;k<4;k++){\n            if(i+diff[k]<0||i+diff[k]>=H||j+diff[k+1]<0||j+diff[k+1]>=W) continue;\n            if(M[i+diff[k]][j+diff[k+1]]!='#'&&dist[i+diff[k]][j+diff[k+1]]==1000000){\n                dist[i+diff[k]][j+diff[k+1]]=d+1;\n                Q.push(T3(i+diff[k],j+diff[k+1],d+1));\n            }\n        }\n    }\n    if(dist_p<dist_s){\n        cout<<\"Yes\"<<endl;\n    }else{\n        cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar pal[207][207];\nint sol[207][207];\nint pri[207][207];\nint h, w;\nbool flag;\n\nvoid rec_sol(int i, int j)\n{\n\tif (j+1 < w) if (sol[i][j+1] > sol[i][j]+1 && (pal[i][j+1]=='.'||pal[i][j+1]=='%'||pal[i][j+1]=='@')) {\n\t\tsol[i][j+1] = sol[i][j]+1;\n\t\trec_sol(i, j+1);\n\t}\n\tif (j-1 > -1) if (sol[i][j-1] > sol[i][j]+1 && (pal[i][j-1]=='.'||pal[i][j-1]=='%'||pal[i][j-1]=='@')) {\n\t\tsol[i][j-1] = sol[i][j]+1;\n\t\trec_sol(i, j-1);\n\t}\n\tif (i+1 < h) if (sol[i+1][j] > sol[i][j]+1 && (pal[i+1][j]=='.'||pal[i+1][j]=='%'||pal[i+1][j]=='@')) {\n\t\tsol[i+1][j] = sol[i][j]+1;\n\t\trec_sol(i+1, j);\n\t}\n\tif (i-1 > -1) if (sol[i-1][j] > sol[i][j]+1 && (pal[i-1][j]=='.'||pal[i-1][j]=='%'||pal[i-1][j]=='@')) {\n\t\tsol[i-1][j] = sol[i][j]+1;\n\t\trec_sol(i-1, j);\n\t}\n}\n\nvoid rec_pri(int i, int j)\n{\n\tif (pal[i][j]=='%'&&pri[i][j] < sol[i][j]) flag = 1;\n\tif (j+1 < w) if (pri[i][j+1] > pri[i][j]+1 && (pal[i][j+1]=='.'|| pal[i][j+1]=='%')) {\n\t\tpri[i][j+1] = pri[i][j]+1;\n\t\trec_pri(i, j+1);\n\t}\n\tif (j-1 > -1) if (pri[i][j-1] > pri[i][j]+1 && (pal[i][j-1]=='.'|| pal[i][j-1]=='%')) {\n\t\tpri[i][j-1] = pri[i][j]+1;\n\t\trec_pri(i, j-1);\n\t}\n\tif (i+1 < h) if (pri[i+1][j] > pri[i][j]+1 && (pal[i+1][j]=='.'|| pal[i+1][j]=='%')) {\n\t\tpri[i+1][j] = pri[i][j]+1;\n\t\trec_pri(i+1, j);\n\t}\n\tif (i-1 > -1) if (pri[i-1][j] > pri[i][j]+1 && (pal[i-1][j]=='.'|| pal[i-1][j]=='%')) {\n\t\tpri[i-1][j] = pri[i][j]+1;\n\t\trec_pri(i-1, j);\n\t}\n\t\n}\n\nint main(void)\n{\n\tint i, j, p, q;\n\tscanf(\"%d %d\", &h, &w);\n\tfor (i = 0; i < h; i++) scanf(\"%s\", pal[i]);\n\tfor (i = 0; i < h; i++) \n\t\tfor (j = 0; j < w; j++) {\n\t\t\tsol[i][j] = 1000;\n\t\t\tpri[i][j] = 1000;\n\t\t}\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (pal[i][j]=='$') {\n\t\t\t\tsol[i][j] = 0;\n\t\t\t\trec_sol(i, j);\n\t\t\t}\n\t\t\tif (pal[i][j]=='@') {\n\t\t\t\tp = i; q = j;\n\t\t\t}\n\t\t}\n\t}\n\tflag = 0;\n\tpri[p][q] = 0;\n\trec_pri(p, q);\n\t/* for (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) printf(\" %d\", sol[i][j]);\n\t\tprintf(\"\\n\"); \n\t}\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) printf(\" %d\", pri[i][j]);\n\t\tprintf(\"\\n\"); \n\t} */\n\tif (flag) printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\nusing P = pair<int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    int map[H][W];\n    P princess;\n    vector<P> soldier;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;\n            cin>>c;\n            map[i][j]=1;\n            if(c=='#') map[i][j]=0;\n            if(c=='%') map[i][j]=2;\n            if(c=='@') princess=P(j,i);\n            if(c=='$') soldier.emplace_back(j,i);\n        }\n    }\n    if(!soldier.size()){\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n    int dist[H][W];\n    queue<P> Q;\n    Q.push(princess);\n    fill(dist[0],dist[H],100000000);\n    int dist_princess=-1;\n    dist[get<1>(princess)][get<0>(princess)]=0;\n    while(!Q.empty()){\n        int x,y;\n        tie(x,y)=Q.front(); Q.pop();\n        if(map[y][x]==2){\n            dist_princess=dist[y][x];\n            while(!Q.empty()) Q.pop();\n            break;\n        }\n        int d[5]={0,1,0,-1,0};\n        for(int k=0;k<4;k++){\n            int dx=d[k],dy=d[k+1];\n            if(x+dx<0||W<=x+dx||y+dy<0||H<=y+dy) continue;\n            if(map[y+dy][x+dx]){\n                if(dist[y+dy][x+dx]>dist[y][x]+1){\n                    Q.push(P(x+dx,y+dy));\n                    dist[y+dy][x+dx]=dist[y][x]+1;\n                }\n            }\n        }\n    }\n    int dist_soldier=100000000;\n    for(auto s:soldier){\n        Q.push(s);\n        fill(dist[0],dist[H],100000000);\n        dist[get<1>(s)][get<0>(s)]=0;\n        while(!Q.empty()){\n            int x,y;\n            tie(x,y)=Q.front(); Q.pop();\n            if(map[y][x]==2){\n                dist_soldier=min(dist_soldier,dist[y][x]);\n                while(!Q.empty()) Q.pop();\n                break;\n            }\n            int d[5]={0,1,0,-1,0};\n            for(int k=0;k<4;k++){\n                int dx=d[k],dy=d[k+1];\n                if(x+dx<0||W<=x+dx||y+dy<0||H<=y+dy) continue;\n                if(map[y+dy][x+dx]){\n                    if(dist[y+dy][x+dx]>dist[y][x]+1){\n                        Q.push(P(x+dx,y+dy));\n                        dist[y+dy][x+dx]=dist[y][x]+1;\n                    }\n                }\n            }\n        }\n    }\n    // cout<<dist_princess<<' '<<dist_soldier<<endl;\n    if(dist_soldier<=dist_princess){\n        cout<<\"No\"<<endl;\n    }else{\n        cout<<\"Yes\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint d[210][210];\n\nbool isOutOfRange(int y, int x, int h, int w){\n\treturn y < 0 || y >= h || x < 0 || x >= w;\n}\n\nint main(){\n\tint h, w;\n\tcin>>h>>w;\n\tvector<string> vs(h);\n\trep(i, h) cin>>vs[i];\n\n\tvector<pii> v;\n\tpii s, g;\n\trep(i, h) rep(j, w) if(vs[i][j] == '$') v.pb({i, j});\n\trep(i, h) rep(j, w) if(vs[i][j] == '@') s = {i, j};\n\trep(i, h) rep(j, w) if(vs[i][j] == '%') g = {i, j};\n\n\trep(i, 210) rep(j, 210) d[i][j] = INF;\n\trep(i, v.size()){\n\t\tqueue<pii> q;\n\t\tq.push(v[i]);\n\t\td[v[i].fi][v[i].se] = 0;\n\t\twhile(!q.empty()){\n\t\t\tpii p = q.front();\tq.pop();\n\t\t\tint c = d[p.fi][p.se];\n\t\t\trep(j, 4){\n\t\t\t\tint nx = p.se + dx[j], ny = p.fi + dy[j];\n\t\t\t\tif(isOutOfRange(ny, nx, h, w) || vs[ny][nx] == '#') continue;\n\t\t\t\tint nc = d[ny][nx];\n\t\t\t\tif(c+1 < nc){\n\t\t\t\t\td[ny][nx] = c + 1;\n\t\t\t\t\tq.push({ny, nx});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<int, pii>, vector<pair<int, pii> > , greater<pair<int, pii> > > q;\n\tpair<int, pii> p;\n\tset<pii> used;\n\tq.push({0, s});\n\tused.insert(s);\n\twhile(!q.empty()){\n\t\tp = q.top(); q.pop();\n\t\tint c = p.fi;\n\t\t//cout<<\" \"<<p.se.fi<<\" \"<<p.se.se<<\" \"<<p.fi<<endl;\n\t\trep(i, 4){\n\t\t\tint nx = p.se.se + dx[i], ny = p.se.fi + dy[i];\n\t\t\tif(isOutOfRange(ny, nx, h, w) || vs[ny][nx] == '#') continue;\n\t\t\tint nc = d[ny][nx];\n\t\t\tif(nc <= c+1 || used.count({ny, nx})) continue;\n\t\t\tif(g == (pii){ny, nx}){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq.push({c+1, {ny, nx}});\n\t\t\tused.insert({ny, nx});\n\t\t}\n\t}\n\tcout<<\"No\"<<endl;\n\n\t// for(int i = 0; i < h; i++){\n\t// \tfor(int j = 0; j < w; j++){\n\t// \t\tprintf(\"%3d\", (d[i][j]==INF?-1:d[i][j]));\n\t// \t}\n\t// \tprintf(\"\\n\");\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P {\n\tint x, y;\n\tP() : x(0), y(0) {}\n\tP(int x, int y)\n\t\t: x(x), y(y) {}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tP s, g;\n\tvector<P> q, sol;\n\tchar c;\n\tcin >> H >> W;\n\tvector<vector<int>> a(H, vector<int>(W, 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '%') {\n\t\t\t\tg.x = i, g.y = j;\n\t\t\t}\n\t\t\telse if (c == '@') {\n\t\t\t\ts.x = i, s.y = j;\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tq.push_back(s);\n\t\t\t}\n\t\t\telse if (c == '$') {\n\t\t\t\tsol.push_back(P(i, j));\n\t\t\t\ta[i][j] = -1;\n\t\t\t}\n\t\t\telse if (c == '#') {\n\t\t\t\ta[i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tbool res = false;\n\twhile (!q.empty()) {\n\t\tvector<P> tq, tsol;\n\t\tfor (auto p : sol) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = p.x + dx[i], ty = p.y + dy[i];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W && a[tx][ty] != -1) {\n\t\t\t\t\ta[tx][ty] = -1;\n\t\t\t\t\ttsol.push_back(P(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto p : q) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = p.x + dx[i], ty = p.y + dy[i];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W && a[tx][ty] == 1) {\n\t\t\t\t\tif (tx == g.x && ty == g.y) {\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\ttq.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta[tx][ty] = 0;\n\t\t\t\t\ttq.push_back(P(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = tq, sol = tsol;\n\t}\n\tcout << (res ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//==========================================================================\n//\n//                   Bismillahir-Rahmanir-Rahim\n//\n// ==========================================================================\n#include <bits/stdc++.h>\n#define        ll                              long long int\n#define        f(x,y,z)                        for(int x=y;x<z;x++)\n#define        pii                             pair<int,int>\n#define        pll                             pair<ll,ll>\n#define        CLR(a)                          memset(a,0,sizeof(a))\n#define        SET(a)                          memset(a,-1,sizeof(a))\n#define        N                               100010\n#define        M                               1000000007\n#define        pi                              acos(-1.0)\n#define        ff                              first\n#define        ss                              second\n#define        pb                              push_back\n#define        inf                             (int)1e9\n#define        eps                              1e-9\nusing namespace std;\nint dx[]={0,0,1,-1,-1,-1,1,1};\nint dy[]={1,-1,0,0,-1,1,1,-1};\ntemplate < class T> inline T biton(T n,T pos){return n |((T)1<<pos);}\ntemplate < class T> inline T bitoff(T n,T pos){return n & ~((T)1<<pos);}\ntemplate < class T> inline T ison(T n,T pos){return (bool)(n & ((T)1<<pos));}\ntemplate < class T> inline T gcd(T a, T b){while(b){a%=b;swap(a,b);}return a;}\ntemplate <typename T> string NumberToString ( T Number ) { ostringstream ss; ss << Number; return ss.str(); }\ninline int nxt(){int aaa;scanf(\"%d\",&aaa);return aaa;}\ninline ll lxt(){ll aaa;scanf(\"%I64d\",&aaa);return aaa;}\ninline double dxt(){double aaa;scanf(\"%lf\",&aaa);return aaa;}\ntemplate <class T> inline T bigmod(T p,T e,T m){T ret = 1;\nfor(; e > 0; e >>= 1){\n    if(e & 1) ret = (ret * p) % m;p = (p * p) % m;\n} return (T)ret;}\n#define sayed\n#ifdef sayed\n     #define debug(args...) {cerr<<\"Debug: \"; dbg,args; cerr<<endl;}\n#else\n    #define debug(args...)  // Just strip off all debug tokens\n#endif\nstruct debugger{\n    template<typename T> debugger& operator , (const T& v){\n        cerr<<v<<\" \";\n        return *this;\n    }\n}dbg;\n///******************************************START******************************************\nint n,m;\nint color[205][205];\nint level[205][205];\nchar grid[205][205];\nbool mark[205][205];\nvoid bfs(int i,int j){\n      color[i][j]=1;pii top;\n\n      queue<pii> q;\n      q.push({i,j});\n      while(!q.empty()){\n\n          top=q.front();q.pop();\n         for(int k=0;k<4;k++){\n\n            int nx=top.ff+dx[k];\n            int ny=top.ss+dy[k];\n            if(nx<0||nx>=n||ny<0||ny>=m||color[nx][ny]) continue;\n            if(grid[nx][ny]=='.'||grid[nx][ny]=='%'||grid[nx][ny]=='$'){\n                color[nx][ny]=1;\n                level[nx][ny]=level[top.ff][top.ss]+1;\n                q.push({nx,ny});\n            }\n\n         }\n\n      }\n}\nint dist[205][205];\nbool bfs1(){\n    CLR(color);\n    CLR(dist);\n    queue<pii> q; pii dest;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(grid[i][j]=='$')\n            {\n                q.push({i,j});\n                dist[i][j]=0;\n\n            }  else {\n             dist[i][j]=inf;\n\n            }\n            if(grid[i][j]=='%') dest={i,j};\n        }\n    }\n     if(q.empty()) return false;\n      while(!q.empty()){\n\n         pii top=q.front();q.pop();\n\n         for(int k=0;k<4;k++){\n\n            int nx=top.ff+dx[k];\n            int ny=top.ss+dy[k];\n            if(nx<0||nx>=n||ny<0||ny>=m||color[nx][ny]) continue;\n            if(grid[nx][ny]=='.'||grid[nx][ny]=='%'||grid[nx][ny]=='@'||grid[nx][ny]=='$'){\n                color[nx][ny]=1;\n                dist[nx][ny]=min(dist[nx][ny],dist[top.ff][top.ss]+1);\n                q.push({nx,ny});\n            }\n\n         }\n\n      }\n      if(dist[dest.ff][dest.ss]<=level[dest.ff][dest.ss]) return true;\n      return false;\n}\n\nint main(){\n     //freopen(\"out.txt\",\"w\",stdout);\n    //ios_base::sync_with_stdio(false);\n   //cin.tie(0);\n   n=nxt(),m=nxt();\n   for(int i=0;i<n;i++) scanf(\"%s\",grid[i]);\n   for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n        if(grid[i][j]=='@'){\n            bfs(i,j);\n            break;\n        }\n    }\n   }\n\n    int ans;\n        ans= bfs1();\n   if(!ans){\n    puts(\"Yes\");\n    return 0;\n   }\n   puts(\"No\");\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define REP(i, n) FOR(i, 0, (n))\n#define ALL(a) (a.begin(), a.end())\ntypedef vector<int> vi;\n\nconstexpr int INF = 1000000000;\n\nint main() {\n    int h,w;\n    cin>>h>>w;\n    vector<string> t(h);\n    int pi, pj, hi, hj;\n    vi si, sj;\n    REP(i,h) {\n        cin>>t[i];\n        REP(j,w) {\n            switch (t[i][j]) {\n                case '@':\n                pi = i;\n                pj = j;\n                break;\n                case '%':\n                hi = i;\n                hj = j;\n                break;\n                case '$':\n                si.push_back(i);\n                sj.push_back(j);\n            }\n        }\n    }\n    vector<vi> dist(h, vi(w, INF));\n    dist[hi][hj] = 0;\n    queue<pair<int,int>> que;\n    que.push(make_pair(hi, hj));\n    while(!que.empty()) {\n        int i, j;\n        tie(i,j) = que.front();\n        que.pop();\n        int di[] = {1, 0, -1, 0};\n        int dj[] = {0, 1, 0, -1};\n        REP(k,4) {\n            int ni = i + di[k];\n            int nj = j + dj[k];\n            if (ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n            if (t[ni][nj] == '#') continue;\n            if (dist[ni][nj] <= dist[i][j]) continue;\n            dist[ni][nj] = dist[i][j] + 1;\n            que.push(make_pair(ni, nj));\n        }\n    }\n    int pd = dist[pi][pj];\n    bool valid = true;\n    REP(i, si.size()) {\n        if (dist[si[i]][sj[i]] <= pd) {\n            valid = false;\n        }\n    }\n    if (valid) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint d[210][210];\n\nbool isOutOfRange(int y, int x, int h, int w){\n\treturn y < 0 || y >= h || x < 0 || x >= w;\n}\n\nint main(){\n\tint h, w;\n\tcin>>h>>w;\n\tvector<string> vs(h);\n\trep(i, h) cin>>vs[i];\n\n\tvector<pii> v;\n\tpii s, g;\n\trep(i, h) rep(j, w) if(vs[i][j] == '$') v.pb({i, j});\n\trep(i, h) rep(j, w) if(vs[i][j] == '@') s = {i, j};\n\trep(i, h) rep(j, w) if(vs[i][j] == '%') g = {i, j};\n\n\trep(i, 210) rep(j, 210) d[i][j] = INF;\n\trep(i, v.size()){\n\t\tqueue<pii> q;\n\t\tq.push(v[i]);\n\t\td[v[i].fi][v[i].se] = 0;\n\t\twhile(!q.empty()){\n\t\t\tpii p = q.front();\tq.pop();\n\t\t\tint c = d[p.fi][p.se];\n\t\t\trep(j, 4){\n\t\t\t\tint nx = p.se + dx[j], ny = p.fi + dy[j];\n\t\t\t\tif(isOutOfRange(ny, nx, h, w) || vs[ny][nx] == '#') continue;\n\t\t\t\tint nc = d[ny][nx];\n\t\t\t\tif(c+1 < nc){\n\t\t\t\t\td[ny][nx] = c + 1;\n\t\t\t\t\tq.push({ny, nx});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<int, pii> > q;\n\tpair<int, pii> p;\n\tset<pii> used;\n\tq.push({0, s});\n\tused.insert(s);\n\twhile(!q.empty()){\n\t\tp = q.top(); q.pop();\n\t\tint c = p.fi;\n\t\trep(i, 4){\n\t\t\tint nx = p.se.se + dx[i], ny = p.se.fi + dy[i];\n\t\t\tif(isOutOfRange(ny, nx, h, w) || vs[ny][nx] == '#') continue;\n\t\t\tint nc = d[ny][nx];\n\t\t\tif(nc <= c+1 || used.count({ny, nx})) continue;\n\t\t\tif(g == (pii){ny, nx}){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tq.push({c+1, {ny, nx}});\n\t\t\tused.insert({ny, nx});\n\t\t}\n\t}\n\tcout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include <queue>\n\nusing namespace std;\n\nconst int maxx=205;\nint n,m,k;\nchar a[maxx][maxx];\nint ans = 0,cnt = 0,pos = 0;\nint l = 0,r = 0;\n\n\nconst int INF = 100000000;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\ntypedef pair <int,int> P;\nqueue<P> que;\nint d[maxx][maxx];\nint sx,sy;\nint ex,ey;\nint ans1 = INF,ans2 = INF;\nbool judge(int x,int y){\n    if(a[x][y] != '#'){\n        if(x >= 0 && x < n)\n        {\n            if(y >= 0 && y < m)\n            {\n                if(d[x][y] == INF){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvoid bfs()\n{\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            d[i][j] = INF;//初始化\n        }\n    }\n    que.push(P(sx,sy));\n    d[sx][sy] = 0;//并把距???0；\n    while(que.size()){//直到?列?空\n        P p = que.front();que.pop();\n        if(a[p.first][p.second] == '$'){\n            ans2 = min(ans2,d[p.first][p.second]);\n        }\n        if(a[p.first][p.second] == '@')\n        {\n            ans1 = min(ans1,d[p.first][p.second]);\n        }\n        for(int i = 0; i < 4; i++)\n        {\n            int nx = p.first + dx[i],ny = p.second + dy[i];\n            if(judge(nx,ny))\n            {\n                que.push(P(nx,ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n//    return d[ex][ey];\n}\n\n\nint main()\n{\n#ifdef LOCAL\n//    freopen(\"/Users/ecooodt/Desktop/c++ and acm/_集?/tp1/2.txt\",\"r\",stdin);\n#endif\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0; i < n; i++)\n    {\n        getchar();\n        for(int j = 0; j < m; j++)\n        {\n            scanf(\"%c\",&a[i][j]);\n            if(a[i][j] == '%')\n            {\n                sx = i,sy = j;\n            }\n        }\n    }\n    bfs();\n    if(ans1 < ans2)\n    printf(\"Yes\\n\");\n    else\n    printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int h,w;\n    vector<string> v(h);\n    int sx,sy,px,py;\n    for(int i=0;i<h;i++){\n        cin>>v[i];\n        for(int j=0;j<w;j++){\n            if(v[i][j]=='%'){\n                sx=i;sy=j;\n            }\n            else if(v[i][j]=='@'){\n                px=i;py=j;\n            }\n        }\n    }\n    vector<vector<int> > dis(300,vector<int>(300,INF));\n    dis[sx][sy]=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n    queue<P> q;\n    q.push(P(sx,sy));\n    while(!q.empty()){\n        P p=q.front();q.pop();\n        int x=p.first,y=p.second;\n        for(int i=0;i<4;i++){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n            if(v[nx][ny]=='#') continue;\n            if(dis[nx][ny]!=INF) continue;\n            dis[nx][ny]=dis[x][y]+1;\n            q.push(P(nx,ny));\n        }\n    }\n    int pdis=dis[px][py];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(v[i][j]!='$') continue;\n            if(dis[i][j]<=pdis){\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int f[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n\nchar A[205][205];\nint n,m;\nstruct arcnode\n{\n    int x;\n    int y;\n    int num;\n};\n\n\nint BFS (int x0,int y0)\n{\n    int h[205][205];\n    queue<arcnode>q;\n    int sum=0;\n    arcnode p;\n    p.num=0;\n    p.x=x0;\n    p.y=y0;\n    q.push(p);\n    h[x0][y0]=1;\n\twhile(!q.empty())\n    {\n\t\tarcnode a=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n        {\n\t\t\tint x1=a.x+f[i][0];\n\t\t\tint y1=a.y+f[i][1];\n\t\t\tif(x1>=0&&y1>=0&&x1<n&&y1<m&&!h[x1][y1])\n\t\t\t{\n\t\t\t\tif(A[x1][y1]=='.'||A[x1][y1]=='@'||A[x1][y1]=='$')\n\t\t\t\t{\n\t\t\t\t\th[x1][y1]=1;\n\t\t\t\t\tarcnode b;\n\t\t\t\t\tb.x=x1;\n\t\t\t\t\tb.y=y1;\n\t\t\t\t\tb.num=a.num+1;\n\t\t\t\t\tq.push(b);\n\t\t\t\t}\n                else if(A[x1][y1]=='%')\n                {\n\t\t\t\t\tsum=a.num;\n\t\t\t\t\treturn sum;\n                }\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n    int x0,y0;\n    int sum1=0,sum2=100000000;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n    {\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tcin>>A[i][j];\n\t\t\tif(A[i][j]=='@')\n\t\t\t{\n\t\t\t\tx0=i;\n\t\t\t\ty0=j;\n\t\t\t}\n\t\t}\n\t}\n\tsum1=BFS(x0,y0);\n\tfor(int i=0;i<n;i++)\n    {\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(A[i][j]=='$')\n\t\t\t{\n\t\t\t\tx0=i;\n\t\t\t\ty0=j;\n\t\t\t\tsum2=min(BFS(x0,y0),sum2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sum1==-1)\n        cout<<\"No\"<<endl;\n    else if(sum2==-1)\n        cout<<\"Yes\"<<endl;\n\telse if(sum1<sum2)\n        cout<<\"Yes\"<<endl;\n\telse\n        cout<<\"No\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int h,w;\n  cin>>h>>w;\n  vector<string> vec(h+2);\n  rep(i,h) cin>>vec[i+1];\n  vec[0] = string(w+2,'#');\n  vec[h+1] =  string(w+2, '#');\n  rep(i,h) vec[i+1] = \"#\" + vec[i+1] + \"#\";\n\n  h+=2; w+=2;\n  int sx,sy;\n  rep(i,h)rep(j,w)if(vec[i][j]=='%') sx=i,sy=j;\n\n  vector<vector<int>> d(h, vector<int>(w, -1));\n\n  queue<int> x,y;\n  x.push(sx); y.push(sy);\n  while(!x.empty()){\n    int i = x.front(); x.pop();\n    int j = y.front(); y.pop();\n    const int dx[] = {0,0,1,-1}, dy[]={1,-1,0,0};\n    rep(k,4){\n      int nx = i+dx[k], ny=j+dy[k];\n      if(vec[nx][ny]=='#' || d[nx][ny]!=-1) continue;\n      d[nx][ny] = d[i][j]+1;\n      x.push(nx); y.push(ny);\n    }\n  }\n\n  int p=0, s=INF;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='@') p = d[i][j];\n    if(vec[i][j]=='$') s = min(s,d[i][j]);\n  }\n\n  if(p < s) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 1e4;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n\tint x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n\tint temp;\n\t//printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n\t//labyrinth[y][x] = 3;\n\tvis[y][x] = true;\n\tif(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n\t{\n\t\tif(labyrinth[y][x-1] == goal)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x-1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n\t{\n\t\tif(labyrinth[y][x+1] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x+1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n\t{\n\t\tif(labyrinth[y-1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y-1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n\t{\n\t\tif(labyrinth[y+1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y+1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\treturn shortest;\n}\n\nint main()\n{\n\t//freopen(\"1002.txt\",\"r\",stdin);\n\t//freopen(\"ans.txt\",\"w+\",stdout);\n\twhile(~scanf(\"%d%d\",&H,&W))\n\t{\n\t\ttf = true;\n\t\tscnt = 0;\n\t\tshortest = INF;\n\t\tmemset(labyrinth,-1,sizeof(labyrinth));\n\t\tgetchar();\n\t\tfor(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\twhile((ch = getchar())=='\\n');\n\t\t\t\tswitch(ch)\n\t\t\t\t{\n\t\t\t\tcase '@':\n\t\t\t\t\tprincess.x = j;\n\t\t\t\t\tprincess.y = i,labyrinth[i][j] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\tsoldier[scnt].x = j;\n\t\t\t\t\tsoldier[scnt++].y = i;\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tlabyrinth[i][j] = 2;\n\t\t\t\t\tescape.x = j;\n\t\t\t\t\tescape.y = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tgoal = 2;\n\t\tpshort = dfs(princess.x,princess.y,0);\n\t\t//printf(\"pshort:%d\\n\",pshort);\n\n\t\tgoal = 5;\n\t\tshortest = INF;\n\t\tmemset(vis,false,sizeof(vis));\n\t\teshort = dfs(escape.x,escape.y,0);\n\t\t//printf(\"eshort:%d\\n\",eshort);\n\t\tif(eshort<pshort)\n\t\t\tpshort = eshort;\n\t\t/*for(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\tif(i == princess.y&&j == princess.x)\n\t\t\t\t\tprintf(\"X\");\n\t\t\t\telse\n\t\t\t\tprintf(\"%d\",labyrinth[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(!scnt&&pshort!=INF)\n\t\t{\n\t\t\ttf = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pshort != INF)\n\t\t\t{\n\t\t\t\tgoal = 2;\n\t\t\t\tfor(int i = 0; i < scnt; ++i)\n\t\t\t\t{\n\t\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\t\tshortest = INF;\n\t\t\t\t\tsshort = dfs(soldier[i].x,soldier[i].y,0);\n\t\t\t\t\t//printf(\"sshort:%d\\n\",sshort);\n\t\t\t\t\tif(sshort <= pshort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\ttf = false;\n\n\t\t}\n\t\tif(tf)\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n/*\n * @ princess\n * $ soldier\n * % hatch\n * . empty\n * # wall\n */\n\nint H, W;\nstring arr[222];\n\nint visited[222][222];\n\nint p_dist = INF;\nint s_dist = INF;\n\nvoid dfs(int x, int y, int dist = 0) {\n    visited[x][y] = true;\n    if (arr[x][y] == '@') {\n        s_dist = dist;\n    } else if (arr[x][y] == '$') {\n        p_dist = min(p_dist, dist);\n    }\n    for (int j = 0; j < 4; ++j) {\n        int nx = x + dx[j], ny = y + dy[j];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n        if (arr[nx][ny] != '#' && !visited[nx][ny]) {\n            dfs(nx, ny, dist+1);\n        }\n    }\n}\n\nint main() {\n    cin >> H >> W;\n    for (int j = 0; j < H; ++j) {\n        cin >> arr[j];\n    }\n    for (int j = 0; j < H; ++j) { fill(visited[j], visited[j]+W, 0); }\n\n\n    int sx, sy;\n    \n    for (int j = 0; j < H; ++j) {\n        int val = arr[j].find('%');\n        if (val != -1) {\n            sx = j; sy = val;\n            break;\n        }\n    }\n\n    const string result = [&]() {\n        using P = pair<int, int>;\n        queue<P> que;\n        que.emplace(sx, sy);\n        visited[sx][sy] = true;\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            if (arr[x][y] == '@') {\n                return \"Yes\";\n            } else if (arr[x][y] == '$') {\n                return \"No\";\n            }\n            for (int j = 0; j < 4; ++j) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (nx < 0 || H <= nx || ny < 0 || W <= ny) { continue; }\n                if (arr[nx][ny] != '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    que.emplace(nx, ny);\n                }\n            }\n        }\n        return \"No\";\n    }();\n\n    cout << result << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9+7;\nint h, w, sx, sy, gx, gy;\nchar ch[205][205];\nint d[205][205];\ntypedef pair <int, int> p;\nint bfs( )\n{\n    memset(d, -1, sizeof(d));\n    queue <p> que;\n    que.push(p(sx, sy));\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    while(que.size( ))\n    {\n        p s = que.front( );\n        que.pop( );\n        if(s.first == gx && s.second == gy) break;\n        for(int i = 0; i < 4; i++)\n        {\n            int nx = s.first + dx[i];\n            int ny = s.second + dy[i];\n            if(nx >= 0 && nx < h && ny >= 0 && ny < w\n               && ch[nx][ny] != '#' && d[nx][ny] == -1)\n            {\n                que.push(p(nx, ny));\n                d[nx][ny] = d[s.first][s.second] + 1;\n            }\n        }\n    }\n    return d[gx][gy];\n}\nint main( )\n{\n    while(scanf(\"%d%d\", &h, &w) != EOF)\n    {\n        for(int i = 0; i < h; i++)\n        {\n            scanf(\"%s\", &ch[i]);\n            for(int j = 0; j < w; j++)\n            {\n                if(ch[i][j] == '%')\n                {\n                    gx = i;\n                    gy = j;\n                }\n                if(ch[i][j] == '@')\n                {\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n        d[sx][sy] = 0;\n        int ans1 = bfs( );\n        int ans2 = INF;\n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                if(ch[i][j] == '$')\n                {\n                    sx = i;\n                    sy = j;\n                    d[sx][sy] = 0;\n                    ans2= min(ans2, bfs( ));\n                }\n            }\n        }\n        //printf(\"%d--%d\\n\", ans1, ans2);\n        if(ans1 < ans2) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2001;\nconst int dx[] = {1,0,0,-1};\nconst int dy[] = {0,1,-1,0};\n\nint d[MAX_N][MAX_N];\nint e[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w;\n    cin >> h >> w;\n    vs fd(h);\n    int si,sj;\n    vp vec;\n    rep(i,h){\n        cin >> fd[i];\n        rep(j,w){\n            if(fd[i][j] == '@'){\n                si = i,sj = j;\n            }else if(fd[i][j] == '$'){\n                vec.pb(P(i,j));\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,w){\n            d[i][j] = INF;\n        }\n    }\n    queue<P> que;\n    rep(i,len(vec)){\n        que.push(P(vec[i]));\n        d[vec[i].fi][vec[i].se] = 0;\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nx = p.fi+dx[i],ny = p.se+dy[i];\n            if(0 <= nx && nx < h && 0 <= ny && ny < w && fd[nx][ny] != '#'){\n                if(d[nx][ny] > d[p.fi][p.se]+1){\n                    d[nx][ny] = d[p.fi][p.se]+1;\n                    que.push(P(nx,ny));\n                }\n            }\n        }\n    }\n    queue<P> q;\n    q.push(P(si,sj));\n    rep(i,h){\n        rep(j,w){\n            e[i][j] = INF;\n        }\n    }\n    e[si][sj] = 0;\n    while(!q.empty()){\n        P p = q.front();\n        q.pop();\n        rep(i,4){\n            int nx = p.fi+dx[i],ny = p.se+dy[i];\n            if(0 <= nx && nx < h && 0 <= ny && ny < w && fd[nx][ny] != '#' && d[nx][ny] > e[p.fi][p.se]+1){\n                if(e[nx][ny] > e[p.fi][p.se]+1){\n                    if(fd[nx][ny] == '%'){\n                        cout << \"YES\\n\";\n                        return 0;\n                    }\n                    e[nx][ny] = e[p.fi][p.se]+1;\n                    q.push(P(nx,ny));\n                }\n            }\n        }\n    }\n    cout << \"NO\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nint main()\n{\n  int H, W;\n  cin >> H >> W;\n  char mas[202][202];\n  queue<Pi> que;\n  rep(i, H) rep(j, W) {\n    cin >> mas[i][j];\n    if(mas[i][j] == '%') que.push(Pi(i, j));\n  }\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {1, 0, -1, 0};\n  int d[202][202]; memset(d, -1, sizeof(d));\n  d[que.front().F][que.front().S] = 0;\n  int pri = -1; vector<int> sol;\n  while(!que.empty()) {\n    Pi p = que.front(); que.pop();\n    if(mas[p.F][p.S] == '@') {\n      pri = d[p.F][p.S];\n    } else if(mas[p.F][p.S] == '$') {\n      sol.push_back(d[p.F][p.S]);\n    }\n    rep(i, 4) {\n      if(0 <= p.F+dy[i] && p.F+dy[i] < H &&\n\t 0 <= p.S+dx[i] && p.S+dx[i] < W &&\n\t mas[p.F+dy[i]][p.S+dx[i]] != '#' &&\n\t d[p.F+dy[i]][p.S+dx[i]] == -1) {\n\tque.push(Pi(p.F+dy[i], p.S+dx[i]));\n\td[p.F+dy[i]][p.S+dx[i]] = d[p.F][p.S] + 1;\n      }\n    }\n  }\n  cout << (pri != -1 && (sol.empty() || *min_element(all(sol)) > pri) ? \"Yes\" : \"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    memset(dis, 1, sizeof(dis));\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<cmath>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\nconst int maxn = 205;\nchar maze[maxn][maxn];\nbool vis[maxn][maxn];\nint n,m,dp,ds,cur;\n\nconst pair<int,int> step = make_pair(-1,-1);\nqueue<pair<int,int> > que;\nvoid bfs(int x,int y)\n{\n    while(!que.empty()) que.pop();\n    cur = 0,dp = INF,ds = INF;\n    memset(vis,false,sizeof vis);\n\n    vis[y][x] = true;\n    que.push(make_pair(x,y));\n    que.push(step);\n\n    while(cur <= n+m && (dp==INF||ds==INF)){\n        pair<int,int> u = que.front();\n        que.pop();\n\n        if(maze[u.second][u.first] == '@') dp = min(dp,cur);\n        if(maze[u.second][u.first] == '$') ds = min(ds,cur);\n\n        if(u == step){\n            ++cur;\n            que.push(step);\n            continue;\n        }\n        for(int i=0;i<4;++i){\n            int nx = u.first+dx[i],ny = u.second+dy[i];\n            if(!vis[ny][nx] && 0<=nx && 0<=ny && nx<m && ny<n && maze[ny][nx] != '#'){\n                vis[ny][nx] = true;\n                que.push(make_pair(nx,ny));\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m)){\n        for(int i=0;i<n;++i){\n            scanf(\"%s\",maze[i]);\n        }\n        for(int i=0;i<n;++i){\n            for(int j=0;j<m;++j){\n                if(maze[i][j] == '%'){\n                    bfs(j,i);\n                }\n            }\n        }\n        if(dp < ds) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nvector<vector<int>> GridBFS(int sh, int sw, vector<string>& vs) {\n\tint dh[] = { 1,-1,0,0 };\n\tint dw[] = { 0,0,1,-1 };\n\tint H = vs.size();\n\tint W = vs[0].size();\n\tqueue<pair<int, int>> q;\n\tvector<vector<int>> d(H, vector<int>(W, inf));\n\tq.emplace(sh, sw);\n\td[sh][sw] = 0;\n\twhile (!q.empty()) {\n\t\tint h, w; tie(h, w) = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dh[i];\n\t\t\tint nw = w + dw[i];\n\t\t\tif (nh < 0 or nh >= H or nw < 0 or nw >= W) continue;\n\t\t\tif (vs[nh][nw] == '#') continue;\n\t\t\tif (chmin(d[nh][nw], d[h][w] + 1)) q.emplace(nh, nw);\n\t\t}\n\t}\n\treturn d;\n}\n\nvector<vector<int>> MultiGridBFS(vector<int> &sh, vector<int> &sw, vector<string>& vs) {\n\tint dh[] = { 1,-1,0,0 };\n\tint dw[] = { 0,0,1,-1 };\n\tint H = vs.size();\n\tint W = vs[0].size();\n\tqueue<pair<int, int>> q;\n\tvector<vector<int>> d(H, vector<int>(W, inf));\n\tfor (int i = 0; i < sh.size(); i++) {\n\t\td[sh[i]][sw[i]] = 0;\n\t\tq.emplace(sh[i], sw[i]);\n\t}\n\twhile (!q.empty()) {\n\t\tint h, w; tie(h, w) = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nh = h + dh[i];\n\t\t\tint nw = w + dw[i];\n\t\t\tif (nh < 0 or nh >= H or nw < 0 or nw >= W) continue;\n\t\t\tif (vs[nh][nw] == '#') continue;\n\t\t\tif (chmin(d[nh][nw], d[h][w] + 1)) q.emplace(nh, nw);\n\t\t}\n\t}\n\treturn d;\n}\n\n\nint main()\n{\n\t\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t\n\tint H, W; cin >> H >> W;\n\tvector<string> vs(H); for (int i = 0; i < H; i++) cin >> vs[i];\n\tint ph = -1, pw = -1, eh = -1, ew = -1;;\n\tvector<int> sh, sw;\n\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\tif (vs[i][j] == '$') sh.emplace_back(i), sw.emplace_back(j);\n\t\tif (vs[i][j] == '@') ph = i, pw = j;\n\t\tif (vs[i][j] == '%') eh = i, ew = j;\n\t}\n\tauto d1 = GridBFS(ph, pw, vs);\n\tauto d2 = MultiGridBFS(sh, sw, vs);\n\tif (d1[eh][ew] < d2[eh][ew]) cout << \"Yes\" << \"\\n\";\n\telse cout << \"No\" << \"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> cells(h);\n\tvvb able(h,vb(w,false));\n\tREP(i, h)\n\t\tcin >> cells[i];\n\tint sx, sy,gx,gy;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cells[i][j] == '@') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\tif (cells[i][j] == '%') {\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t}\n\t\t\tif (cells[i][j] == '#')\n\t\t\t\tcontinue;\n\t\t\tvvb visited(h, vb(w,false));\n\t\t\tvisited[i][j] = true;\n\t\t\tqueue<pair<pii,int>> Q;\n\t\t\tQ.push({ { i,j },0 });\n\t\t\tbool pfast = false;\n\t\t\tbool sfast = false;\n\t\t\tint dis = 9999;\n\t\t\twhile (!Q.empty())\n\t\t\t{\n\t\t\t\tpair<pii, int> q = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tif (q.second > dis)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cells[q.first.first][q.first.second] == '$') {\n\t\t\t\t\tsfast = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(pfast)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cells[q.first.first][q.first.second] == '@') {\n\t\t\t\t\tpfast = true;\n\t\t\t\t\tdis = q.second;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tint nx = q.first.second + dx[k];\n\t\t\t\t\tint ny = q.first.first + dy[k];\n\t\t\t\t\tif(0<=ny&& ny<h&& 0 <= nx && nx<w)\n\t\t\t\t\t\tif(cells[ny][nx]!='#')\n\t\t\t\t\t\t\tif (visited[ny][nx] == false) {\n\t\t\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\t\t\tQ.push({ {ny,nx},q.second+1 });\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!sfast&&pfast) {\n\t\t\t\table[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvvb visited(h, vb(w, false));\n\tvisited[sy][sx] = true;\n\tqueue<pii> Q;\n\tQ.push({ sy,sx });\n\tbool ans = false;\n\twhile (!Q.empty())\n\t{\n\t\tpii q = Q.front();\n\t\tQ.pop();\n\t\tif (q.first == gy&&q.second == gx) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t\tREP(k, 4) {\n\t\t\tint nx = q.second + dx[k];\n\t\t\tint ny = q.first + dy[k];\n\t\t\tif (0 <= ny&& ny<h && 0 <= nx && nx<w)\n\t\t\t\tif (cells[ny][nx] != '#'&&able[ny][nx])\n\t\t\t\t\tif (visited[ny][nx] == false) {\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t}\n\t\t}\n\t}\n\tif (ans) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 210\n#define INF 0x3f3f3f3f\nusing namespace std;\n\nint n, m;\nchar mp[N][N];\n\nvector< pair<int, int> > sol;\npair<int, int> s, t;\n\nint solDist[N][N];\nint sDist[N][N];\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nqueue< pair<int, int> > q;\n\nvoid bfs(const vector< pair<int, int> > from, int d[N][N]) {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tfor (auto x: from) {\n\t\td[x.first][x.second] = 0;\n\t\tq.push(x);\n\t}\n\t\n\twhile (!q.empty()) {\n\t\tint ux = q.front().first;\n\t\tint uy = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint vx = ux + dx[i];\n\t\t\tint vy = uy + dy[i];\n\t\t\tif (1 <= vx && vx <= n && 1 <= vy && vy <= m && mp[vx][vy] != '#') {\n\t\t\t\tif (d[vx][vy] > d[ux][uy]) {\n\t\t\t\t\td[vx][vy] = d[ux][uy] + 1;\n\t\t\t\t\tq.push(make_pair(vx, vy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool vis[N][N];\nbool dfs(int ux, int uy) {\n\tif (vis[ux][uy]) return false;\n\tvis[ux][uy] = 1;\n\tif (sDist[ux][uy] == INF || sDist[ux][uy] > solDist[ux][uy]) return false;\n\tif (make_pair(ux, uy) == t) return true;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint vx = ux + dx[i];\n\t\tint vy = uy + dy[i];\n\t\tif (1 <= vx && vx <= n && 1 <= vy && vy <= m && mp[vx][vy] != '#' && dfs(vx, vy)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%s\", mp[i] + 1);\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tif (mp[i][j] == '@') s = make_pair(i, j);\n\t\t\tif (mp[i][j] == '%') t = make_pair(i, j);\n\t\t\tif (mp[i][j] == '$') sol.push_back(make_pair(i, j));\n\t\t}\n\t}\n\t\n\tvector< pair<int, int> > tmp_s;\n\ttmp_s.clear();\n\ttmp_s.push_back(s);\n\tbfs(tmp_s, sDist);\n\ttmp_s.clear();\n\ttmp_s = sol;\n\tbfs(tmp_s, solDist);\n\tputs(dfs(s.first, s.second) ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=0,pri=0;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<int,int> >Q;\n  queue<int>q1;\n  q1.push(0);\n  Q.push(mk(y,x));\n  b[y][x]=1;\n  while(!Q.empty()){\n    pair<int,int >a=Q.front();Q.pop();\n    int xx=a.second,yy=a.first,cc=q1.front();q1.pop();\n    if(pri&&pri<cc)break;\n    if(s[yy][xx]=='$'){sol=cc;break;}\n    if(s[yy][xx]=='@'){pri=cc;}\n    r(i,4){\n      int x1=xx+dx[i],y1=yy+dy[i];\n      if(x1<0||x1>=w||y1<0||y1>=h||b[y1][x1]||s[y1][x1]=='#')continue;\n      Q.push(mk(y1,x1));b[y1][x1]=1;\n      q1.push(cc+1);\n    }\n  }\n  if(sol==0)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tvvi tmp(h, vi(w, INF));\n\tREP(i, n) {\n\t//\tint cnt = 0;\n\t\t\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (ms[p.second][p.first] <= tmp[p.second][p.first])continue;\n\t\t\tms[p.second][p.first] = min(ms[p.second][p.first], tmp[p.second][p.first]);\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\t//cout << cnt <<\" \"<<nx<<\" \"<<ny<< endl;\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\ttmp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar t[200][200];\nint si,sj,ti,tj;\nint d[200][200];\nint di[]={-1,0,1,0};\nint dj[]={0,1,0,-1};\n\nint main(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='@'){\n        si=i;\n        sj=j;\n      }\n      if(t[i][j]=='%'){\n        ti=i;\n        tj=j;\n      }\n    }\n  }\n  memset(d,1,sizeof(d));\n  d[ti][tj]=0;\n  queue<int> qi,qj;\n  qi.push(ti);\n  qj.push(tj);\n  while(!qi.empty()){\n    int pi=qi.front();qi.pop();\n    int pj=qj.front();qj.pop();\n    for(int dir=0;dir<4;dir++){\n      int ni=pi+di[dir];\n      int nj=pj+dj[dir];\n      if(ni<0||nj<0||ni>=H||nj>=W)continue;\n      if(t[ni][nj]=='#')continue;\n      if(d[ni][nj]>d[pi][pj]+1){\n        d[ni][nj]=d[pi][pj]+1;\n        qi.push(ni);\n        qj.push(nj);\n      }\n    }\n  }\n  int dist=d[si][sj];\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(t[i][j]=='$')\n        if(d[i][j]<=dist)\n          dist=0;\n  if(dist)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint64 dx[4] = {-1, 1, 0, 0};\nint64 dy[4] = {0, 0, -1, 1};\n\nint main(void) {\n  vector<PLL> sol;\n  PLL prin;\n  PLL st;\n  int64 H, W;\n  cin >> H >> W;\n  vector<string> f(H);\n  REP(i, H) {\n    cin >> f[i];\n    REP(j, W) {\n      if (f[i][j] == '@') prin = PLL(i, j);\n      if (f[i][j] == '%') st = PLL(i, j);\n      if (f[i][j] == '$') sol.push_back(PLL(i, j));\n    }\n  }\n  using T = pair<int64, PLL>;\n  priority_queue<T, vector<T>, greater<T>> pq;\n  auto d = make_v<int64>(H, W);\n  fill_v<int64>(d, INF_LL);\n  d[st.fs][st.sc] = 0;\n  pq.push(T(0, st));\n  auto in = [&](int64 y, int64 x) { return 0<=y&&y<H&&0<=x&&x<W&&f[y][x]!='#'; };\n\n  while (pq.size()) {\n    int64 dd, x, y;\n    PLL a;\n    tie(dd, a) = pq.top(); pq.pop();\n    tie(y, x) = a;\n    if (d[y][x] < dd) continue;\n    REP(i, 4) {\n      int64 yy = y + dy[i], xx = x + dx[i];\n      if (!in(yy, xx)) continue;\n      if (d[yy][xx] > dd+1) {\n        d[yy][xx] = dd+1;\n        pq.push(T(dd+1, PLL(yy, xx)));\n      }\n    }\n  }\n  int64 res = d[prin.fs][prin.sc];\n  bool ok = 1;\n  REP(i, sol.size()) {\n    if (d[sol[i].fs][sol[i].sc] <= res) ok = 0;\n  }\n  cout << (ok ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> cells(h);\n\tvvi able(h, vi(w, 9999));\n\tREP(i, h)\n\t\tcin >> cells[i];\n\tint sx, sy, gx, gy;\n\tqueue<pair<pii, int>> Qs;\n\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cells[i][j] == '@') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\tif (cells[i][j] == '%') {\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t}\n\t\t\tif (cells[i][j] == '$') {\n\t\t\t\tQs.push({ {i,j},0 });\n\t\t\t\table[i][j] = 0;\n\t\t\t}\n\t\t\tif (cells[i][j] == '#')\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\twhile (!Qs.empty())\n\t{\n\t\tpair<pii, int> q = Qs.front();\n\t\tQs.pop();\n\t\tREP(k, 4) {\n\t\t\tint nx = q.first.second + dx[k];\n\t\t\tint ny = q.first.first + dy[k];\n\t\t\tif (0 <= ny&& ny < h && 0 <= nx && nx < w)\n\t\t\t\tif (cells[ny][nx] != '#')\n\t\t\t\t\tif (able[ny][nx] > q.second + 1) {\n\t\t\t\t\t\table[ny][nx] = q.second + 1;\n\t\t\t\t\t\tQs.push({ { ny,nx },q.second + 1 });\n\t\t\t\t\t}\n\t\t}\n\t}\n\tvvb visited(h, vb(w, false));\n\tvisited[sy][sx] = true;\n\tqueue<pair<pii, int>> Q;\n\tQ.push({{ sy,sx },0});\n\tbool ans = false;\n\twhile (!Q.empty())\n\t{\n\t\tpair<pii, int> q = Q.front();\n\t\tQ.pop();\n\t\tif (q.first.first == gy&&q.first.second == gx) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t\tREP(k, 4) {\n\t\t\tint nx = q.first.second + dx[k];\n\t\t\tint ny = q.first.first + dy[k];\n\t\t\tif (0 <= ny&& ny < h && 0 <= nx && nx < w)\n\t\t\t\tif (cells[ny][nx] != '#'&&able[ny][nx]>q.second+1)\n\t\t\t\t\tif (visited[ny][nx] == false) {\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\tQ.push({ { ny,nx },q.second+1 });\n\t\t\t\t\t}\n\t\t}\n\t}\n\tif (ans) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 210;\nint h, w;\nchar field[MAX_N][MAX_N];\nint table[MAX_N][MAX_N];\nint princess;\npriority_queue<int> soldier;\nvoid bfs(int y, int x)\n{\n    table[y][x] = 0;\n    queue<P> que;\n    que.push(P(y, x));\n    while(!que.empty())\n    {\n        P p = que.front(); que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n            if(table[ny][nx] >= 0 || field[ny][nx] == '#') continue;\n            table[ny][nx] = table[p.first][p.second] + 1;\n            if(field[ny][nx] == '@') princess = table[ny][nx];\n            if(field[ny][nx] == '$') soldier.push(table[ny][nx]);\n            que.push(P(ny, nx));\n        }\n    }\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    int sy, sx;\n    memset(table, - 1, sizeof(table));\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j < w; j++) \n        {\n            cin >> field[i][j];\n            if(field[i][j] == '%') sy = i, sx = j;\n        }\n    }\n    bfs(sy, sx);\n    int num;\n    if(soldier.size() == 0) num = INF;\n    else num = soldier.top();\n    cout << (princess < num ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\n\nint bfs(int h, int w, point start, point goal, int dis[N][N]){\n    queue<point> q;\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\nbool check(int dis[N][N], vector<point> v, int p){\n    rep(i,v.size()){\n        if(dis[v[i].y][v[i].x] <= p) return 1;\n    }\n    return 0;\n}\n\nint main(){\n    int h, w;\n    int dis[N][N];\n    point princess, patch;\n    vector<point> soldiers;\n\n    scanf(\"%d%d\", &h,&w);\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') patch = {j, i};\n            else if(m[i][j] == '@') princess = {j, i};\n            else if(m[i][j] == '$'){\n                point temp = {j, i};\n                soldiers.emplace_back(temp);\n            }\n        }\n    }\n\n    memset(dis, -1, sizeof(dis));\n    int p = bfs(h, w, princess, patch, dis);\n\n    memset(dis, -1, sizeof(dis));\n    bfs(h, w, patch, patch, dis); //dis???patch??????????????¢???????????????\n\n    if(check(dis, soldiers, p)) printf(\"No\\n\");\n    else printf(\"Yes\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>T find_if(const F& f)const {\n\t\tfor (T i : *this)if (f(i))return i; return 0;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max_by(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min_by(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Point {\n\tstatic int H, W;\n\tstatic const vector<Point> d;\n\tstatic void set_range(int _H, int _W) { H = _H; W = _W; }\n\tstatic constexpr Point zero() { return { 0,0 }; }\n\tstatic constexpr Point one() { return { 1,1 }; }\n\tint x, y;\n\tconstexpr Point() :x(0), y(0) {}\n\tconstexpr Point(int _x, int _y) : x(_x), y(_y) {}\n\tconstexpr Point(const pair<int, int>& xy) : x(xy.first), y(xy.second) {}\n\tPoint(int n) :x(n% W), y(n / W) {}\n\tconstexpr Point operator+()const { return *this; }\n\tconstexpr Point operator-()const { return { -x,-y }; }\n\tconstexpr Point operator+(const Point& p)const { return Point(*this) += p; }\n\tconstexpr Point operator-(const Point& p)const { return Point(*this) -= p; }\n\tconstexpr Point operator*(const Point& p)const { return Point(*this) *= p; }\n\tconstexpr Point operator/(const Point& p)const { return Point(*this) /= p; }\n\tconstexpr Point operator%(const Point& p)const { return Point(*this) %= p; }\n\tconstexpr Point operator+(int n)const { return Point(*this) += n; }\n\tconstexpr Point operator-(int n)const { return Point(*this) -= n; }\n\tconstexpr Point operator*(int n)const { return Point(*this) *= n; }\n\tconstexpr Point operator/(int n)const { return Point(*this) /= n; }\n\tconstexpr Point operator%(int n)const { return Point(*this) %= n; }\n\tconstexpr Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tconstexpr Point& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tconstexpr Point& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tconstexpr Point& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tconstexpr Point& operator%=(const Point& p) { x %= p.x; y %= p.y; return *this; }\n\tconstexpr Point& operator+=(int n) { x += n; y += n; return *this; }\n\tconstexpr Point& operator-=(int n) { x -= n; y -= n; return *this; }\n\tconstexpr Point& operator*=(int n) { x *= n; y *= n; return *this; }\n\tconstexpr Point& operator/=(int n) { x /= n; y /= n; return *this; }\n\tconstexpr Point& operator%=(int n) { x %= n; y %= n; return *this; }\n\tconstexpr bool operator==(const Point& p)const { return x == p.x && y == p.y; }\n\tconstexpr bool operator!=(const Point& p)const { return x != p.x || y != p.y; }\n\tbool operator<(const Point& p)const { return to_i() < p.to_i(); }\n\tbool operator<=(const Point& p)const { return to_i() <= p.to_i(); }\n\tbool operator>(const Point& p)const { return to_i() > p.to_i(); }\n\tbool operator>=(const Point& p)const { return to_i() >= p.to_i(); }\n\tconstexpr int operator[](int i)const { return i == 0 ? x : i == 1 ? y : 0; }\n\tbool in_range()const { return 0 <= x && x < W && 0 <= y && y < H; }\n\tint to_i()const { return x + y * W; }\n\tconstexpr pair<int, int> to_pair()const { return { x,y }; }\n\tint dist(const Point& p)const { return std::abs(x - p.x) + std::abs(y - p.y); }\n\tPoint abs(const Point& p)const { return { std::abs(x - p.x),std::abs(y - p.y) }; }\n\tPoint abs()const { return { std::abs(x), std::abs(y) }; }\n\tPoint& swap() { std::swap(x, y); return *this; }\n\tvector<Point> adjacent4()const {\n\t\tvector<Point> v(4); for (int i = 0; i < 4; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent8()const {\n\t\tvector<Point> v(8); for (int i = 0; i < 8; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent6()const {\n\t\tvector<Point> v(6); for (int i = 0; i < 6; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adj4_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent4())if (P.in_range())v.push_back(P); return v;\n\t}\n\tvector<Point> adj8_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent8())if (P.in_range())v.push_back(P); return v;\n\t}\n\tconstexpr Point left()const { return { x - 1,y }; }\n\tconstexpr Point right()const { return { x + 1,y }; }\n\tconstexpr Point up()const { return { x,y - 1 }; }\n\tconstexpr Point down()const { return { x,y + 1 }; }\n\tconstexpr Point moved(char c)const { return Point(*this).move(c); }\n\tconstexpr Point& move(char c) {\n\t\tswitch (c) {\n\t\tcase 'L':case 'l':case'>':x--; break;\n\t\tcase 'R':case 'r':case'<':x++; break;\n\t\tcase 'U':case 'u':case'^':y--; break;\n\t\tcase 'D':case 'd':case'v':y++; break;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr Point rotate90() { return { y,-x }; }\n\tconstexpr Point rotate180() { return { -x,-y }; }\n\tconstexpr Point rotate270() { return { -y,x }; }\n};\nint Point::H, Point::W;\nconst vector<Point> Point::d{ {0,1},{1,0},{0,-1},{-1,0},{1,1},{-1,-1},{1,-1},{-1,1} };\ninline ostream& operator<<(ostream& os, const Point& p) { return  os << '(' << p.x << \", \" << p.y << ')'; }\ninline istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nvector<vector<int>> GridBFS(const vector<string>& grid, Point s, char wall = '#') {\n\tint h = grid.size(), w = grid.front().size();\n\tPoint::set_range(h, w);\n\tvector<vector<int>> res(h, vector<int>(w, INT_MAX));\n\tres[s.y][s.x] = 0;\n\tqueue<Point> q;\n\tq.push(s);\n\twhile (!q.empty()) {\n\t\tauto f = q.front(); q.pop();\n\t\tfor (auto p : f.adj4_in_range()) {\n\t\t\tif (grid[p.y][p.x] != wall && res[p.y][p.x] == INT_MAX) {\n\t\t\t\tq.push(p);\n\t\t\t\tres[p.y][p.x] = res[f.y][f.x] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nvector<vector<int>> GridBFS(const vector<string>& grid, char start, char wall = '#') {\n\tint h = grid.size(), w = grid.front().size();\n\tPoint s;\n\tfor (int i = 0; i < h; ++i)for (int j = 0; j < w; ++j) {\n\t\tif (grid[i][j] == start) {\n\t\t\ts = Point(j, i);\n\t\t}\n\t}\n\treturn GridBFS(grid, s, wall);\n}\n\nint main() {\n\tINT(h, w);\n\tVS s = in[h];\n\tauto dist = GridBFS(s, '%');\n\n\tint time = 0, mi = inf;\n\trep(i, h)rep(j, w) {\n\t\tif (s[i][j] == '@') {\n\t\t\ttime = dist[i][j];\n\t\t} else if (s[i][j] == '$') {\n\t\t\tchmin(mi, dist[i][j]);\n\t\t}\n\t}\n\tout(time < mi);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define REP(i, n) FOR(i, 0, (n))\n#define ALL(a) (a.begin(), a.end())\ntypedef vector<int> vi;\n\nconstexpr int INF = 1000000000;\n\nint main() {\n    int h,w;\n    cin>>h>>w;\n    vector<string> t(h);\n    int pi, pj, hi, hj;\n    vi si, sj;\n    REP(i,h) {\n        cin>>t[i];\n        REP(j,w) {\n            switch (t[i][j]) {\n                case '@':\n                pi = i;\n                pj = j;\n                break;\n                case '%':\n                hi = i;\n                hj = j;\n                break;\n                case '$':\n                si.push_back(i);\n                sj.push_back(j);\n            }\n        }\n    }\n    vector<vi> dist(h, vi(w, INF));\n    dist[hi][hj] = 0;\n    queue<pair<int,int>> que;\n    que.push(make_pair(hi, hj));\n    while(!que.empty()) {\n        int i, j;\n        tie(i,j) = que.front();\n        que.pop();\n        int di[] = {1, 0, -1, 0};\n        int dj[] = {0, 1, 0, -1};\n        REP(k,4) {\n            int ni = i + di[k];\n            int nj = j + dj[k];\n            if (ni < 0 || nj < 0 || ni >= h || nj >= w) continue;\n            if (t[ni][nj] == '#') continue;\n            if (dist[ni][nj] <= dist[i][j] + 1) continue;\n            dist[ni][nj] = dist[i][j] + 1;\n            que.push(make_pair(ni, nj));\n        }\n    }\n    int pd = dist[pi][pj];\n    bool valid = true;\n    REP(i, si.size()) {\n        if (dist[si[i]][sj[i]] <= pd) {\n            valid = false;\n        }\n    }\n    if (valid) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\n\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvs in;\nvvi d,dp;\nbool dfs(int a,int b,int c){\n\tif(dp[a][b]<c)return 0;\n\trep(i,4){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(x<0||y<0||x>=n||y>=m||in[x][y]=='#'||d[x][y]<=c+1||c+1>=dp[x][y])continue;\n\t\tif(in[x][y]=='%'){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 1;\n\t\t}\n\t\tif(dfs(x,y,c+1))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vs(n);\n\trep(i,n)cin>>in[i];\n\tdp=vvi(n,vi(m,inf));\n\tpriority_queue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='$'){\n\t\tque.push(tp(i,j,0));\n\t\tdp[i][j]=0;\n\t}\n\twhile(!que.empty()){\n\t\tint x,y,co;\n\t\ttie(x,y,co)=que.top();\n\t\tque.pop();\n\t\tif(dp[x][y]<co)continue;\n\t\trep(i,4){\n\t\t\tint nx=x+dx[i];\n\t\t\tint ny=y+dy[i];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#'||dp[nx][ny]<=co+1)continue;\n\t\t\tdp[nx][ny]=co+1;\n\t\t\tque.push(tp(nx,ny,co+1));\n\t\t}\n\t}\n\td=vvi(n,vi(m,inf));\n\trep(i,n)rep(j,m)if(in[i][j]=='@'){\n\t\td[i][j]=0;\n\t\tif(!dfs(i,j,0))cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nusing T3=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    cin>>H>>W;\n    char M[H][W];\n    int dist[H][W];\n    queue<T3> Q;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>M[i][j];\n            if(M[i][j]=='%'){\n                dist[i][j]=0;\n                Q.push(T3(i,j,0));\n            }else{\n                dist[i][j]=1000000;\n            }\n        }\n    }\n    int dist_p = 1000000, dist_s=1000000;\n    while(!Q.empty()){\n        int i,j,d;\n        tie(i,j,d)=Q.front();\n        Q.pop();\n        if(M[i][j]=='@') dist_p=d;\n        if(M[i][j]=='$') dist_s=min(dist_s,d);\n        int diff[5]={0,-1,0,1,0};\n        for(int k=0;k<4;k++){\n            if(i+diff[k]<0||i+diff[k]>=H||j+diff[k+1]<0||j+diff[k+1]>=W) continue;\n            if(M[i+diff[k]][j+diff[k+1]]!='#'&&dist[i+diff[k]][j+diff[k+1]]==1000000){\n                dist[i+diff[k]][j+diff[k+1]]=d+1;\n                Q.push(T3(i+diff[k],j+diff[k+1],d+1));\n            }\n        }\n    }\n    if(dist_p<dist_s){\n        cout<<\"Yes\"<<endl;\n    }else{\n        cout<<\"No\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nchar mp[209][209];\nint mark[209][209];\nint px[4]= {0,1,0,-1};\nint py[4]= {1,0,-1,0};\nconst int inf=99999;\nint ans[209][209];\nint bfs(int x,int y )\n{\n    if (ans[x][y]!=-1)return ans[x][y];\n    if (mark[x][y]==1||mp[x][y]=='#')return inf;\n    if (mp[x][y]=='%')return 1;\n    int anss=inf;\n    mark[x][y]=1;\n    for (int i =0; i<4; i++)\n    {\n        if (x+px[i]>=0&&x+px[i]<n&&y+py[i]>=0&&y+py[i]<m)\n            anss=min(anss,bfs(x+px[i],y+py[i])+1);\n    }\n    mark[x][y]=0;\n    if (anss>=inf)\n    {\n        ans[x][y]=inf;\n        return inf;\n    }\n    else return ans[x][y]=anss;\n}\nint main ()\n{\n    while (~scanf(\"%d%d\",&n,&m))\n    {\n        memset(mark,0,sizeof(mark));\n        for (int i =0; i<n; i++)\n        {\n            scanf(\"%s\",&mp[i]);\n        }\n        memset(ans,-1,sizeof(ans));\n        int sd=inf;\n        int pr=inf;\n        for (int i =0; i<n; i++)\n            for (int j =0; j<m; j++)\n                if (mp[i][j]=='@')\n                    pr=bfs(i,j);\n        for (int i =0; i<n; i++)\n        {\n            for (int j =0; j<m; j++)\n            {\n                if (mp[i][j]=='$')\n                {\n                    memset(mark,0,sizeof(mark));\n                    sd=min(sd,bfs(i,j));\n                }\n            }\n        }\n//        for (int i =0; i<n; i++)\n//        {\n//            for (int j =0; j<m; j++)\n//            {\n//                printf (\"%5d \",ans[i][j]);\n//            }\n//            printf (\"\\n\");\n//        }\n        if (pr>=sd)printf (\"No\\n\");\n        else printf (\"Yes\\n\");\n    }\n}\n\n/*\n3 4\n.%..\n.##$\n.@$.\n3 4\n.%..\n.##.\n.@$$\n3 4\n.%..\n.##.\n$@$.\n10 10\n$.........\n..........\n..........\n#########%\n..........\n..........\n..........\n..........\n..........\n.........@\n10 10\n%.........\n..........\n..........\n#########$\n..........\n..........\n..........\n..........\n..........\n.........@\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nstring mp[N];\n\nint bfs(char s){\n  queue<P> Q;\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) \n      if(mp[i][j]==s)Q.push(P(i,j)),D[i][j]=0;\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int y=t.first,x=t.second;\n    if(mp[y][x]=='\\%') return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||D[ny][nx]!=-1||mp[ny][nx]=='#')continue;\n      \n      Q.push(P(ny,nx));\n      D[ny][nx]=D[y][x]+1;\n    }\n  }\n  return 1e9;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<((bfs('@')<bfs('$'))? \"Yes\":\"No\")<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <set>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#define rep(i,m,n) for(i=m;i<=n;i++)\n#define mod 1000000007\n#define inf 0x3f3f3f3f\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ll long long\n#define pi acos(-1.0)\n#define pii pair<int,int>\n#define sys system(\"pause\")\nconst int maxn=1e3+10;\nconst int N=1e3+10;\nusing namespace std;\nll gcd(ll p,ll q){return q==0?p:gcd(q,p%q);}\nll qpow(ll p,ll q){ll f=1;while(q){if(q&1)f=f*p;p=p*p;q>>=1;}return f;}\nint n,m,k,t,vis[maxn][maxn],ret,dis[][2]={-1,0,0,-1,0,1,1,0};\nchar a[maxn][maxn];\nvi x;\nbool ok(int x,int y){return x>=1&&x<=n&&y>=1&&y<=m;}\nvoid bfs(int x,int y)\n{\n    queue<pii>pq;\n    pq.push(mp(x,y));\n    vis[x][y]=0;\n    while(!pq.empty())\n    {\n        pii x=pq.front();\n        pq.pop();\n        for(int i=0;i<4;i++)\n        {\n            int nx=x.fi+dis[i][0],ny=x.se+dis[i][1];\n            if(ok(nx,ny)&&vis[nx][ny]==inf)\n            {\n                vis[nx][ny]=vis[x.fi][x.se]+1;\n                pq.push(mp(nx,ny));\n            }\n        }\n    }\n}\nint main()\n{\n    int i,j;\n    memset(vis,inf,sizeof(vis));\n    scanf(\"%d%d\",&n,&m);\n    rep(i,1,n)scanf(\"%s\",a[i]+1);\n    rep(i,1,n)rep(j,1,m)if(a[i][j]=='%')bfs(i,j);\n    rep(i,1,n)rep(j,1,m)\n    {\n        if(a[i][j]=='@')ret=vis[i][j];\n        else if(a[i][j]=='$')x.pb(vis[i][j]);\n    }\n    sort(x.begin(),x.end());\n    if(ret!=inf&&(x.empty()||x[0]>ret))puts(\"YES\");\n    else puts(\"NO\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#include <queue>\n\nusing namespace std;\n\nstruct Info {\n    int x, y, dis;\n};\n\nconst int MAXN = 205;\nconst int DIFF[2][4] = {{0, 0, 1, -1}, {1, -1, 0, 0}};\n\nint n, m;\nchar mp[MAXN][MAXN];\nbool vis[MAXN][MAXN];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%s\", mp[i] + 1);\n    }\n\n    queue<Info> q;\n    int dis1 = 1e9;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (mp[i][j] == '@') {\n                q.push((Info) {i, j, 0});\n                break;\n            }\n        }\n        if (!q.empty()) break;\n    }\n    while (!q.empty()) {\n        Info info = q.front(); q.pop();\n        if (mp[info.x][info.y] == '%') {\n            dis1 = info.dis;\n            break;\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = info.x + DIFF[0][i], ny = info.y + DIFF[1][i];\n            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n            if (mp[nx][ny] == '#') continue;\n            if (vis[nx][ny]) continue;\n            q.push((Info) {nx, ny, info.dis + 1});\n            vis[nx][ny] = true;\n        }\n    }\n    while (!q.empty()) q.pop();\n\n    memset(vis, 0, sizeof(vis));\n    int dis2 = 1e9;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (mp[i][j] == '$') {\n                q.push((Info) {i, j, 0});\n            }\n        }\n    }\n    while (!q.empty()) {\n        Info info = q.front(); q.pop();\n        if (mp[info.x][info.y] == '%') {\n            dis2 = info.dis;\n            break;\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = info.x + DIFF[0][i], ny = info.y + DIFF[1][i];\n            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;\n            if (mp[nx][ny] == '#') continue;\n            if (vis[nx][ny]) continue;\n            q.push((Info) {nx, ny, info.dis + 1});\n            vis[nx][ny] = true;\n        }\n    }\n\n    puts(dis1 < dis2 ? \"Yes\" : \"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint h,w;\nchar a[205][205];\nint visit[205][205];\nstruct Node {\n\tint x,y;\n}b[40005],s,e,temp,temp2;\nint xx[4]={1,0,-1,0};\nint yy[4]={0,1,0,-1};\nint bfs1(Node s)\n{\n\tmemset(visit,0,sizeof(visit));\n\tqueue<Node>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ttemp=q.front();\n\t\tfor(int i=0;i<4;i++){\n\t\t\ttemp2.x=temp.x+xx[i];\n\t\t\ttemp2.y=temp.y+yy[i];\n\t\t\tif(temp2.x<0||temp.x>h||temp2.y<0||temp2.y>w||a[temp2.x][temp2.y]=='#'||visit[temp2.x][temp2.y]!=0) continue;\n\t\t\tq.push(temp2);\n\t\t\tvisit[temp2.x][temp2.y]=visit[temp.x][temp.y]+1;\n\t\t}\n\t\tq.pop();\n\t\tif(visit[e.x][e.y]!=0) break;\n\t}\n\treturn visit[e.x][e.y];\n}\nint bfs2(Node s)\n{\n\tmemset(visit,0,sizeof(visit));\n\tqueue<Node>q;\n\tq.push(s);\n\tint bx,by;\n\twhile(!q.empty()){\n\t\ttemp=q.front();\n\t\tint bb=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\ttemp2.x=temp.x+xx[i];\n\t\t\ttemp2.y=temp.y+yy[i];\n\t\t\tif(temp2.x<0||temp.x>h||temp2.y<0||temp2.y>w||a[temp2.x][temp2.y]=='#'||visit[temp2.x][temp2.y]!=0) continue;\n\t\t\tq.push(temp2);\n\t\t\tvisit[temp2.x][temp2.y]=visit[temp.x][temp.y]+1;\n\t\t\tif(a[temp2.x][temp2.y]=='$')  {\n\t\t\t\tbb=1;  bx=temp2.x; by=temp2.y; break;\n\t\t\t}\n\t\t}\n\t\tif(bb==1) break;\n\t\tq.pop();\t\n\t}\n\treturn visit[bx][by];\n}\nint main()\n{\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=0;i<h;i++)\n\t\tscanf(\"%s\",a[i]);\n\tint num=0;\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]=='@') {\n\t\t\t\ts.x=i; s.y=j;\n\t\t\t}\n\t\t\tif(a[i][j]=='%'){\n\t\t\t\te.x=i; e.y=j;\n\t\t\t}\n\t\t\tif(a[i][j]=='$'){\n\t\t\t\tnum++; b[num].x=i; b[num].y=j;\n\t\t\t}\n\t\t}\n\tif(num==0){\n\t\tprintf(\"Yes\\n\");\n\t}\n\telse{\n\t\tint ans=bfs1(s);\n\t\tint flag=1;\n\t\tint ans2=bfs2(e);\n\t\tif(ans2<=ans) flag=0;\n\t\tif(flag==1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\t\n\t\n\t\n\t\n } "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    rep(i,N) rep(j,N) dis[i][j] = INF;\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == INF && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        rep(j,w){\n            cin >> m[i][j];\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    int p = INF, s = INF;\n    rep(i,h){\n        rep(j,w){\n            start = {j, i};\n            if(m[i][j] == '@') p = bfs(h, w, start, goal);\n            else if(m[i][j] == '$') s = min(bfs(h, w, start, goal), s);\n        }\n    }\n    if(p < s) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t//\tint cnt = 0;\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\tms[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tms[ny][nx] = min(ms[ny][nx],tmp[ny][nx]);\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\t//cout << cnt <<\" \"<<nx<<\" \"<<ny<< endl;\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n\nusing namespace std;\nint n,m;\nchar ara[500][500];\nint vis[500][500];\n\ntypedef pair<int,int> pp;\n\nint fx[]={1,-1,0,0};\nint fy[]={0,0,1,-1};\n\nbool issafe(int x,int y){\n    return ( x>0 && x<=n && y>0 && y<=m   );\n}\n\nvoid bfs(int s1,int s2){\n    queue<pair<pp,int> >myq;\n    myq.push(mp(mp(s1,s2),1));\n    vis[s1][s2]=1;\n    while(!myq.empty()){\n        int x=myq.front().xx.xx;\n        int y=myq.front().xx.yy;\n        int d=myq.front().yy;\n        myq.pop();\n        for(int i=0;i<4;i++){\n            int p=x+fx[i];\n            int q=y+fy[i];\n            if(issafe(p,q)){\n                if(ara[p][q]!='#' && vis[p][q]==0){\n                    vis[p][q]=vis[x][y]+1;\n                    myq.push(mp(mp(p,q),vis[p][q]));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin>>n>>m;\n    int pr1,pr2,s3,s4;\n\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            cin>>ara[i][j];\n            if(ara[i][j]=='%'){\n                pr1=i,pr2=j;\n            }\n            if(ara[i][j]=='@'){\n                s3=i;\n                s4=j;\n            }\n        }\n    }\n\n    bfs(pr1,pr2);\n    int val=vis[s3][s4];\n    bool flag=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            if(ara[i][j]=='$'){\n                if(vis[i][j]<=val){\n                    flag=1;\n                }\n            }\n        }\n    }\n    if(flag)cout<<\"No\"<<endl;\n    else cout<<\"Yes\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include <queue>\n\nusing namespace std;\n\nconst int maxx=205;\nint n,m,k;\nchar a[maxx][maxx];\nint ans = 0,cnt = 0,pos = 0;\nint l = 0,r = 0;\n\n\nconst int INF = 100000000;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\ntypedef pair <int,int> P;\nqueue<P> que;\nint d[maxx][maxx];\nint sx,sy;\nint ex,ey;\n\nbool judge(int x,int y){\n    if(a[x][y] == '.' || a[x][y] == '%'){\n        if(x >= 0 && x < n)\n        {\n            if(y >= 0 && y < m)\n            {\n                if(d[x][y] == INF){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint bfs()\n{\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            d[i][j] = INF;//初始化\n        }\n    }\n    que.push(P(sx,sy));\n    d[sx][sy] = 0;//并把距???0；\n    while(que.size()){//直到?列?空\n        P p = que.front();que.pop();\n        if(p.first == ex && p.second == ey){\n            break;//如果已?是?点，??束搜索。\n        }\n        for(int i = 0; i < 4; i++)\n        {\n            int nx = p.first + dx[i],ny = p.second + dy[i];\n            if(judge(nx,ny))\n            {\n                que.push(P(nx,ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return d[ex][ey];\n}\n\n\nint main()\n{\n#ifdef LOCAL\n//    freopen(\"/Users/ecooodt/Desktop/c++ and acm/_集?/tp1/2.txt\",\"r\",stdin);\n#endif\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0; i < n; i++)\n    {\n        getchar();\n        for(int j = 0; j < m; j++)\n        {\n            scanf(\"%c\",&a[i][j]);\n            if(a[i][j] == '%')\n            {\n                ex = i,ey = j;\n            }\n            if(a[i][j] == '@') sx = i,sy = j;\n        }\n    }\n    pos = bfs();\n//    printf(\"%d \",pos);\n    for(int i = 0; i < n; i ++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(a[i][j] == '$')\n            {\n                sx = i,sy = j;\n                int t = bfs();\n                if(t <= pos) {\n//                    printf(\"%d\\n\",t);\n                    printf(\"No\\n\");\n                    return 0;\n                }\n            }\n        }\n    }\n    printf(\"Yes\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 1e3;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n\tint x,y;\n} soldier[100000],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n\tint temp;\n\t//printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n\t//labyrinth[y][x] = 3;\n\tvis[y][x] = true;\n\tif(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n\t{\n\t\tif(labyrinth[y][x-1] == goal)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x-1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n\t{\n\t\tif(labyrinth[y][x+1] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x+1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n\t{\n\t\tif(labyrinth[y-1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y-1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n\t{\n\t\tif(labyrinth[y+1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y+1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\treturn shortest;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t//freopen(\"1002.txt\",\"r\",stdin);\n\t//freopen(\"ans.txt\",\"w+\",stdout);\n\twhile(~scanf(\"%d%d\",&H,&W))\n\t{\n\t\ttf = true;\n\t\tscnt = 0;\n\t\tshortest = INF;\n\t\tmemset(labyrinth,-1,sizeof(labyrinth));\n\t\tgetchar();\n\t\tfor(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\twhile((ch = getchar())=='\\n');\n\t\t\t\tswitch(ch)\n\t\t\t\t{\n\t\t\t\tcase '@':\n\t\t\t\t\tprincess.x = j;\n\t\t\t\t\tprincess.y = i,labyrinth[i][j] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\tsoldier[scnt].x = j;\n\t\t\t\t\tsoldier[scnt++].y = i;\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tlabyrinth[i][j] = 2;\n\t\t\t\t\tescape.x = j;\n\t\t\t\t\tescape.y = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tgoal = 2;\n\t\tpshort = dfs(princess.x,princess.y,0);\n\t\t//printf(\"pshort:%d\\n\",pshort);\n\n\t\tgoal = 5;\n\t\tshortest = INF;\n\t\tmemset(vis,false,sizeof(vis));\n\t\teshort = dfs(escape.x,escape.y,0);\n\t\t//printf(\"eshort:%d\\n\",eshort);\n\t\tif(eshort<pshort)\n\t\t\tpshort = eshort;\n\t\t/*for(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\tif(i == princess.y&&j == princess.x)\n\t\t\t\t\tprintf(\"X\");\n\t\t\t\telse\n\t\t\t\tprintf(\"%d\",labyrinth[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(!scnt&&pshort!=INF)\n\t\t{\n\t\t\ttf = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pshort != INF)\n\t\t\t{\n\t\t\t\tgoal = 2;\n\t\t\t\tfor(int i = 0; i < scnt; ++i)\n\t\t\t\t{\n\t\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\t\tshortest = INF;\n\t\t\t\t\tsshort = dfs(soldier[i].x,soldier[i].y,0);\n\t\t\t\t\t//printf(\"sshort:%d\\n\",sshort);\n\t\t\t\t\tif(sshort <= pshort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\ttf = false;\n\n\t\t}\n\t\tif(tf)\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstruct edge\n{\n\tint to;\n\tlong long cost;\n\tedge(int to_, long long cost_) :\n\t\tto(to_), cost(cost_) {}\n};\nconst long long INF = 123456789012345;\nusing P = pair<long long, int>;//first:cost,second:vertice\nvoid dijkstra(vector<edge>graph_[], long long dist[], int n_, int s_)\n{\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tque.push({ 0,s_ });\n\tfill(dist, dist + n_, INF);\n\tdist[s_] = 0ll;\n\twhile (!que.empty())\n\t{\n\t\tauto q = que.top();\n\t\tque.pop();\n\t\tlong long thd = q.first;\n\t\tint thv = q.second;\n\t\tif (thd > dist[thv])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto ed : graph_[thv])\n\t\t{\n\t\t\tif (dist[ed.to] > ed.cost + thd)\n\t\t\t{\n\t\t\t\tdist[ed.to] = ed.cost + thd;\n\t\t\t\tque.push({ dist[ed.to],ed.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint h, w;\nint g, p;\nvector<int>sol;\nvector<edge>graph[200 * 200];\nLL dist[200 * 200];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nint main()\n{\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tif (s[j] == '#')continue;\n\t\t\tfor (int d = 0; d < 4; ++d)\n\t\t\t{\n\t\t\t\tint ii = i + dx[d];\n\t\t\t\tint jj = j + dy[d];\n\t\t\t\tif (ii < 0 || jj < 0 || ii >= h || jj >= w)continue;\n\t\t\t\tgraph[i * w + j].push_back(edge(ii * w + jj, 1));\n\t\t\t}\n\t\t\tif (s[j] == '@')p = i * w + j;\n\t\t\tif (s[j] == '$')sol.push_back(i * w + j);\n\t\t\tif (s[j] == '%')g = i * w + j;\n\t\t}\n\t}\n\tdijkstra(graph, dist, h*w, g);\n\tLL shut = INT_MAX;\n\tfor (int s : sol)\n\t{\n\t\tshut = min(shut, dist[s]);\n\t}\n\tif (shut > dist[p])\n\t{\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t{\n\t\tcout << \"No\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint h, w;\nchar b[200][200];\nint pri[200][200];\nint sol[200][200];\nqueue<int> que;\nint dh[4] = {0,1,0,-1};\nint dw[4] = {1,0,-1,0};\n\nint main(){\n    cin >> h >> w;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        pri[i][j] = INF;\n        sol[i][j] = INF;\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '$'){\n            que.push(i*200+j);\n            sol[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int hh = q/200, ww = q%200;\n        rep(i,4){\n            int y = q/200+dh[i], x = q%200+dw[i];\n            if(0>y||y>=h||0>x||x>=w) continue;\n            if(sol[y][x] <= sol[hh][ww]+1) continue;\n            sol[y][x] = sol[hh][ww]+1;\n            que.push(y*200+x);\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '@'){\n            que.push(i*200+j);\n            pri[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        int q = que.front();\n        que.pop();\n        int hh = q/200, ww = q%200;\n        rep(i,4){\n            int y = hh+dh[i], x = ww+dw[i];\n            if(0>y||y>=h||0>x||x>=w) continue;\n            if(pri[y][x] <= pri[hh][ww]+1) continue;\n            if(sol[y][x] <= pri[hh][ww]+1) continue;\n            pri[y][x] = pri[hh][ww]+1;\n            que.push(y*200+x);\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '%'){\n            if(pri[i][j] != INF){\n                cout << \"Yes\" << endl;\n                return 0;\n            }\n        }\n    }\n    cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????? ??????? ??????????? ????????? //\n//________________//\n#include <bits/stdc++.h>\n\n//  http://ideone.com/kxcEk8\nusing namespace std;\n#define NN 205\n#define inf                  1e7\n#define white                0\n#define grey                 1\n#define black                2\n#define ll                   long long\n#define ull                  unsigned long long\n#define PI                   2.0*acos(0.0)   // acos(-1)\n#define pii                  pair <int,int>\n#define pll                  pair <ll,ll>\n#define rep(i,x,y)           for(int i = x ; i < y ; i++)\n#define ff                   first\n#define ss                   second\n#define X(i)                 x+fx[i]\n#define Y(i)                 y+fy[i]\n#define BOUNDRY(i,j)         ((i>=0 && i < r) && (j>= 0 && j< c))\n#define WRITE                freopen(\"a.txt\",\"w\",stdout);\n//***********************************************\n#define MOD\n#define ashraf\n#ifdef ashraf\n     #define so(args...) {cerr<<\"so: \"; dbg,args; cerr<<endl;}\n#else\n    #define so(args...)  // Just strip off all debug tokens\n#endif\nstruct debugger{\n    template<typename T> debugger& operator , (const T& v){\n        cerr<<v<<\" \";\n        return *this;\n    }\n}dbg;\n\n\n//******************************************************\ninline void take(int &x) {scanf(\"%d\",&x);}\ninline void take(int &x ,int &y)  {scanf(\"%d %d\",&x, &y);}\ntemplate < class T> inline T Set(T N, T pos){ return N = N | (1<< pos);}\ntemplate < class T> inline bool Check(T N , T pos){ return (bool) (N & (1<<pos));}\ntemplate < class T> inline T Reset(T N , T pos) { return N = N & ~(1 << pos); }\ndouble grad(double n){ return (PI*n)/180; }\ndouble agrad(double n){ return (180*n)/PI; }\ntemplate < class T> inline T gcd(T a, T b) {\n  while (a > 0 && b > 0)\n    a > b ? a%=b : b%=a;\n  return a + b;\n}\ntemplate <class T > inline T  modInv(T n, T m) {\n      T x, y, gcd;\n      extEuclid(n, m, x, y, gcd);\n      if (gcd == 1) return x % m;\n      return 0;\n}\ntemplate < class T> inline T lcm(T a, T b) {return (a*b)/gcd(a,b);}\ntemplate < class T> T big(T b , T p , T mod){\n    if(p == 0) return 1;\n    if(!(p&1)){\n        T x = big(b,p/2,mod);\n        return (x*x)%mod;\n    }\n    else return (b*big(b,p-1,mod))%mod;\n}\n\ntemplate < class T> T POW(T b , T p){\n    if(p == 0) return 1;\n    if(!(p&1)){\n        T x = POW(b,p/2);\n        return (x*x);\n    }\n    else return (b*POW(b,p-1));\n}\n\nint fx[] = {0,1,0,-1};\nint fy[] = {1,0,-1,0};\n    int r , c;\nstring ch[NN];\nint vis[NN][NN];\nint level[NN][NN];\nvoid dfs(int m , int n){\n     vis[m][n] = 1;\n     queue < pii > q;\n     q.push(make_pair(m,n));\n     while(!q.empty()){\n         int x = q.front().ff;\n         int y = q.front().ss;\n         q.pop();\n         for(int i = 0 ; i< 4 ; i++){\n             int X = fx[i]+x;\n             int Y = fy[i]+y;\n             if(  BOUNDRY(X,Y) && !vis[X][Y] &&  ch[X][Y] != '#'){\n                  level[X][Y] = 1+level[x][y];\n                  q.push(make_pair(X,Y));\n                  vis[X][Y] = 1;\n             }\n        }\n\n     }\n}\nint main()\n{\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> r >> c;\n    int savex , savey, psavex , psavey;\n    for(int i = 0 ; i< r ; i++){\n        cin >> ch[i];\n        for(int j = 0 ; j< ch[i].size() ; j++){\n             if(ch[i][j] == '%'){\n                savex = i;\n                savey = j;\n             }\n             if(ch[i][j] == '@'){\n               psavex = i;\n               psavey = j;\n             }\n        }\n    }\n    memset(vis,0,sizeof vis);\n    memset(level,0,sizeof level);\n    dfs(savex,savey);\n    bool flag = 0;\n    for(int i = 0 ; i< r ; i++){\n        for(int j = 0 ; j< ch[i].size() ; j++){\n             if(ch[i][j] == '$'){\n                if(level[i][j] <= level[psavex][psavey]){\n                    flag = 1;\n                }\n             }\n//             cout << level[i][j] << ' ';\n        }\n//        cout << endl;\n    }\n\n    if(flag == 1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// @Team    : nupt2017team12\n// @Author  : Zst\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define MOD 1000000007\n#define CLR(a,x) memset(a,x,sizeof(a))\n#define INF 0x3f3f3f3f\n#define pb push_back\n#define FOR(i,a,b) for( int i = ( a ); i <= ( b ); ++i )\n\nconst int N = 200+7;\nchar maps[N][N];\nbool vis[N][N];\n\nint r, c;\nint posX, posY;\n\nint princess;\nint soldier;\n\nvoid solve( int x, int y, int times )\n{\n\tvis[x][y] = true;\n\tif( maps[x][y] == '@' ) {\n\t\tprincess = min( princess, times );\n\t} else if( maps[x][y] == '$' ) {\n\t\tsoldier = min( soldier, times );\n\t}\n\tif( x-1 >= 0 ) {\n\t\tif( vis[x-1][y] != true ) {\n\t\t\tsolve( x-1, y, times+1 );\n\t\t}\n\t}\n\tif( y-1 >= 0 ) {\n\t\tif( vis[x][y-1] != true ) {\n\t\t\tsolve( x, y-1, times+1 );\n\t\t}\n\t}\n\tif( x+1 < r ) {\n\t\tif( vis[x+1][y] != true ) {\n\t\t\tsolve( x+1, y, times+1 );\n\t\t}\n\t}\n\tif( y+1 < c ) {\n\t\tif( vis[x][y+1] != true ) {\n\t\t\tsolve( x, y+1, times+1 );\n\t\t}\n\t}\n\treturn;\n\n}\n\n\nint main()\n{\n\tprincess = soldier = INF;\n\tCLR( vis, false );\n    // freopen( \"B.txt\", \"r\", stdin );\n    scanf( \"%d%d\", &r, &c );\n    FOR( i, 0, r-1 ) {\n    \tscanf( \"%s\", maps[i] );\n\t\tFOR( j, 0, c-1 ) {\n\t\t\tif( maps[i][j] == '%' ) {\n\t\t\t\tposX = i;\n\t\t\t\tposY = j;\n\t\t\t} else if( maps[i][j] == '#' ) {\n\t\t\t\tvis[i][j] = true;\n\t\t\t}\n\t\t}\n    }\n    solve( posX, posY, 0 );\n    if( princess < soldier ) {\n    \tprintf( \"Yes\\n\");\n    } else {\n    \tprintf( \"No\\n\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nchar t[100][100];\nint si,sj,ti,tj;\nint d[100][100];\nint di[]={-1,0,1,0};\nint dj[]={0,1,0,-1};\n\nint main(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='@'){\n        si=i;\n        sj=j;\n      }\n      if(t[i][j]=='%'){\n        ti=i;\n        tj=j;\n      }\n    }\n  }\n  memset(d,1,sizeof(d));\n  d[ti][tj]=0;\n  queue<int> qi,qj;\n  qi.push(ti);\n  qj.push(tj);\n  while(!qi.empty()){\n    int pi=qi.front();qi.pop();\n    int pj=qj.front();qj.pop();\n    for(int dir=0;dir<4;dir++){\n      int ni=pi+di[dir];\n      int nj=pj+dj[dir];\n      if(ni<0||nj<0||ni>=H||nj>=W)continue;\n      if(t[ni][nj]=='#')continue;\n      if(d[ni][nj]>d[pi][pj]+1){\n        d[ni][nj]=d[pi][pj]+1;\n        qi.push(ni);\n        qj.push(nj);\n      }\n    }\n  }\n  int dist=d[si][sj];\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(t[i][j]=='$')\n        if(d[i][j]<=dist)\n          dist=0;\n  if(dist)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 210\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint h,w;\nstring grid[MAX];\nint mem1[MAX][MAX],mem2[MAX][MAX];\n\nvoid init(){\n  FOR(i,0,MAX){\n    FOR(j,0,MAX){\n      mem1[i][j]=inf;\n      mem2[i][j]=inf;\n    }\n  }\n}\n\nbool in(int a,int b){\n  if(a<0 || b<0 || h<=a || w<=b)return false;\n  return true;\n}\n\nstring solve(){\n  queue<pii> q;\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(grid[i][j]=='$'){\n        q.push(mp(i,j));\n        mem1[i][j]=0;\n      }\n    }\n  }\n  while(q.size()){\n    pii u=q.front();\n    q.pop();\n    FOR(k,0,4){\n      int ni=u.f+dy[k],nj=u.s+dx[k];\n      if(!in(ni,nj))continue;\n      if(grid[ni][nj]=='#')continue;\n      if(mem1[u.f][u.s]+1<mem1[ni][nj]){\n        mem1[ni][nj]=mem1[u.f][u.s]+1;\n        q.push(mp(ni,nj));\n      }\n    }\n  }\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(grid[i][j]=='@'){\n        q.push(mp(i,j));\n        mem2[i][j]=0;\n      }\n    }\n  }\n  while(q.size()){\n    pii u=q.front();\n    q.pop();\n\n    if(grid[u.f][u.s]=='%')return \"Yes\";\n\n    FOR(k,0,4){\n      int ni=u.f+dy[k],nj=u.s+dx[k];\n      if(!in(ni,nj))continue;\n      if(grid[ni][nj]=='#')continue;\n      if(mem2[u.f][u.s]+1<mem2[ni][nj] && mem2[u.f][u.s]+1<mem1[ni][nj]){\n        mem2[ni][nj]=mem2[u.f][u.s]+1;\n        q.push(mp(ni,nj));\n      }\n    }\n  }\n  return \"No\";\n}\n\nint main()\n{\n  init();\n\n  cin>>h>>w;\n  FOR(i,0,h)cin>>grid[i];\n\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main(){\n  int H, W;\n  cin >> H >> W;\n  string M[H];\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n  }\n  int s_x, s_y;\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == '%'){\n\ts_x = i;\n\ts_y = j;\n      }\n    }\n  }\n  queue< pair<int,int> > que;\n  que.push(make_pair(s_x, s_y));\n  vector< vector<int> > D(H, vector<int>(W,-1));\n  D[s_x][s_y] = 0;\n  int d[] = {1,0,-1,0,1};\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int i = 0; i < 4; ++i){\n      int x_next = x + d[i], y_next = y + d[i+1];\n      if(x_next >= 0 && x_next < H && y_next >= 0 && y_next < W && M[x_next][y_next] != '#' && D[x_next][y_next] < 0){\n\t  D[x_next][y_next] = D[x][y] + 1;\n\t  que.push(make_pair(x_next, y_next));\n\t}\n\t}\n    }\n    int p = 1000000000, s = 1000000000;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '@')\n\t  p = D[i][j];\n\tif(M[i][j] == '$')\n\t  s = D[i][j];\n      }\n    }\n    cout << ((p < s) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct node{\n\tint r,c,cen;\n};\nint h,w;\nint p=-1;\nint s=-1;\nchar map[250][250];\n//int cen[250][250]={0};\nint vis[250][250]={0};\nint d[2][4]={1,-1,0,0,0,0,1,-1};\nint ok(int r,int c){\n\tif(r<0||r>=h) return false;\n\tif(c<0||c>=w) return false;\n\tif(map[r][c]=='#') return false;\n\tif(vis[r][c]) return false;\n\treturn true;\n}\nvoid bfs(int r,int c){\n\tvis[r][c] = 1;\n\tnode st;st.r=r;st.c=c;st.cen=0;\n\tqueue<node> q;q.push(st);\n\twhile(!q.empty()){\n\t\tnode t = q.front();\n\t\tq.pop();\n\t\tif(map[t.r][t.c]=='$'){\n\t\t\tif(s==-1) s = t.cen;\n\t\t\telse s = min(s,t.cen);\n\t\t}\n\t\telse if(map[t.r][t.c]=='@'){\n\t\t\tif(p==-1) p = t.cen;\n\t\t\telse p = min(p,t.cen);\n\t\t}\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(ok(t.r+d[0][i],t.c+d[1][i])){\n\t\t\t\tvis[t.r+d[0][i]][t.c+d[1][i]] = 1;\n\t\t\t\tq.push((node){t.r+d[0][i],t.c+d[1][i],t.cen+1});\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tcin>>h>>w;\n\tfor(i=0;i<h;++i){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\tfor(i=0;i<h;++i){\n\t\tfor(j=0;j<w;++j){\n\t\t\tif(map[i][j]=='%') {\n\t\t\t\t bfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tif(p==-1){\n\t\tprintf(\"No\\n\");\n\t}\n\telse if(s==-1){\n\t\tprintf(\"Yes\\n\");\n\t}\n\telse if(p>=s) printf(\"No\\n\");\n\telse printf(\"Yes\\n\");\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n#define MAX 210\nchar c[MAX][MAX];\n\nint p[MAX][MAX] = {};\nint s[MAX][MAX] = {};\n\nint H, W;\nbool inrange(int i, int j) {\n\treturn 0 <= i&&i < H && 0 <= j&&j < W;\n}\nint di[] = { 1,0,-1,0 };\nint dj[] = { 0,1,0,-1 };\nvoid dfsp(int i, int j, int cnt) {\n\tif (!inrange(i, j))return;\n\tif (c[i][j] == '#')return;\n\tif (p[i][j] < cnt)return;\n\tp[i][j] = cnt;\n\trep(h, 0, 4) {\n\t\tdfsp(i + di[h], j + dj[h], cnt + 1);\n\t}\n}\nvoid dfss(int i, int j, int cnt) {\n\tif (!inrange(i, j))return;\n\tif (c[i][j] == '#')return;\n\tif (s[i][j] < cnt)return;\n\ts[i][j] = cnt;\n\trep(h, 0, 4) {\n\t\tdfss(i + di[h], j + dj[h], cnt + 1);\n\t}\n}\n\n\nsigned main() {\n\tcin >> H >> W;\n\tint pi, pj;\n\tint si = -1, sj;\n\tint ei, ej;\n\tmemset(p, 0x3f, sizeof(p));\n\tmemset(s, 0x3f, sizeof(s));\n\trep(i, 0, H)rep(j, 0, W) {\n\t\tcin >> c[i][j];\n\n\t\tif (c[i][j] == '@')pi = i, pj = j;\n\t\tif (c[i][j] == '$')si = i, sj = j;\n\t\tif (c[i][j] == '%')ei = i, ej = j;\n\t}\n\tdfsp(pi, pj, 0);\n\tif (si != -1)dfss(si, sj, 0);\n\n\tif (p[ei][ej] == INF || p[ei][ej] >= s[ei][ej])cout << \"NO\" << endl;\n\telse cout << \"YES\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (tmp[p.second][p.first] > ms[p.second][p.first])continue;\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tms[ny][nx] = tmp[ny][nx];\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tms[i][j] = min(ms[i][j], tmp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tq.push({ sx,sy });\n\tvvi visited(h, vi(w, 0));\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tvisited[p.second][p.first] = 1;\n\t\tif (p.first == tx&&p.second == ty) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&mp[ny][nx]<ms[ny][nx]&&!visited[ny][nx]) {\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define H 205\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\npriority_queue<P1,vector<P1>,greater<P1> > q;\nint h,w,sy,sx;\nstring s[H];\nint d[H][H];\n\nint dijkstra(){\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  while(!q.empty()){\n    P1 t=q.top(); q.pop();\n    int y=t.second.first;\n    int x=t.second.second;\n    int cost=t.first;\n    if(d[y][x]<cost)continue;\n    if(s[y][x]=='%')return cost;\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(ny<0||nx<0||h<=ny||w<=nx)continue;\n      if(s[ny][nx]=='#')continue;\n      if(d[ny][nx]>cost+1){\n\td[ny][nx]=cost+1;\n\tq.push(P1(cost+1,P(ny,nx)));\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++){\n    cin>>s[i];\n    for(int j=0;j<w;j++){\n      d[i][j]=INF;\n      if(s[i][j]=='@')sy=i,sx=j;\n      if(s[i][j]=='$'){\n\tq.push(P1(0,P(i,j)));\n\td[i][j]=0;\n      }\n    }\n  }\n  int comp=dijkstra();\n  while(!q.empty())q.pop();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      d[i][j]=INF;\n  q.push(P1(0,P(sy,sx)));\n  d[sy][sx]=0;\n  int r=dijkstra();\n  if(r<comp)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol,pri;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='$'){sol=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<w)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q1;\n  Q1.push(mk(mk(y,x),0));\n  while(!Q1.empty()){\n    pair<pair<int,int > ,int >a=Q1.front();Q1.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='@'){pri=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<w)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q1.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  if(pri<sol)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nconst ll dx[] = {0, 1, 0, -1};\nconst ll dy[] = {-1, 0, 1, 0};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int H, W; cin >> H >> W;\n    auto inRange = [&](int x, int y) {\n        return 0 <= x && x < W && 0 <= y && y < H;\n    };\n    vector<string> m(H); cin >> m;\n    int gx = -1, gy = -1;\n    REP(y, H) REP(x, W) if (m[y][x] == '%') {\n        gx = x, gy = y;\n    }\n    vector<vector<ll>> dist(H, vector<ll>(W, -1));\n    queue<P> Q; Q.push({gx, gy});\n    while ( !Q.empty() ) {\n        P p = Q.front(); Q.pop();\n        ll x, y; tie(x, y) = p;\n        REP(d, 4) {\n            ll nx = x + dx[d];\n            ll ny = y + dy[d];\n            if ( inRange(nx, ny) && m[ny][nx] != '#' && dist[ny][nx] < 0 ) {\n                dist[ny][nx] = dist[y][x]+1;\n                Q.push({nx, ny});\n            }\n        }\n    }\n    ll sdist = linf, pdist = linf;\n    REP(y, H) REP(x, W) {\n        if (m[y][x] == '$') {\n            sdist = min(sdist, dist[y][x]);\n        }\n        if (m[y][x] == '@') {\n            pdist = min(pdist, dist[y][x]);\n        }\n    }\n    if (pdist == linf || pdist >= sdist) {\n        cout << \"No\" << endl;\n    }\n    else {\n        cout << \"Yes\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define D double\n#define pb push_back\n#define mp make_pair\n#define sf scanf\n#define pf printf\n#define ff first\n#define ss second\n#define SZ 100005\n#define eps 1e-8\n#define PI (2*acos(0.0))\n#define mem(a, b) memset(a, b, sizeof a)\n#define FastIO ios_base::sync_with_stdio(0)\nconst int inf = 0x7f7f7f7f;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n//int dx[]={2,1,-1,-2,-2,-1,1,2};\n//int dy[]={1,2,2,1,-1,-2,-2,-1};\n//int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};\n\nint n, m;\nchar grid[205][205];\nint seen[205][205], dist[205][205];\n\nbool valid(int x, int y)\n{\n    if(x>=0 && x<n && y>=0 && y<m && seen[x][y]==0 && grid[x][y]!='#') return 1;\n    return 0;\n}\n\nvoid bfs(int x, int y)\n{\n    mem(seen, 0);\n    mem(dist, inf);\n    seen[x][y] = 1;\n    dist[x][y] = 0;\n\n    queue<int>q;\n    q.push(x); q.push(y);\n\n    while(!q.empty())\n    {\n        x = q.front(); q.pop();\n        y = q.front(); q.pop();\n\n        for(int i=0; i<4; i++) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n\n            if(valid(xx, yy)) {\n                seen[xx][yy] = 1;\n                dist[xx][yy] = dist[x][y] + 1;\n                q.push(xx); q.push(yy);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(sf(\"%d %d\", &n, &m)==2)\n    {\n        for(int i=0; i<n; i++) {\n            sf(\"%s\", grid[i]);\n        }\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if(grid[i][j]=='%') {\n                    bfs(i, j);\n                    break;\n                }\n            }\n        }\n\n        int princes = 0, solder = inf;\n\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if(grid[i][j]=='@') {\n                    princes = dist[i][j];\n                }\n\n                else if(grid[i][j]=='$') {\n                    solder = min(solder, dist[i][j]);\n                }\n            }\n        }\n\n        //cout<<princes<<\" \"<<solder<<endl;\n        if(solder<=princes) pf(\"No\\n\");\n        else pf(\"Yes\\n\");\n    }\n    //main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  L\n//\n//  Created by LucienShui on 2017/4/19.\n//  Copyright ? 2017年 LucienShui. All rights reserved.\n//\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <cstring>\n#include <vector>\n#include <queue>\n#define mfor(i,n) for(int i=0 ; i<n ; ++i)\n\nusing namespace std;\n\nstruct node {\n    int h,l,step;\n};\n\nchar mp[1005][1005];\nbool vis[1005][1005];\nint nex[5][3]={{0,1},{1,0},{0,-1},{-1,0}},w,h;\nvector<node> soldier;\nint bfs(int sh, int sl, int eh, int el) {\n    queue<node> q;\n    memset(vis,false,sizeof(vis));\n    vis[sh][sl]=true;\n    node it,next;\n    int nh,nl;\n    it.h=sh,it.l=sl,it.step=0;\n    q.push(it);\n    while(!q.empty()) {q.pop();}\n    while(!q.empty()) {\n        it=q.front();\n        q.pop();\n        if(it.h==eh && it.l==el) {\n            return it.step;\n        }\n        for(int k=0 ; k<4 ; k++) {\n            nh=it.h+nex[k][0];\n            nl=it.l+nex[k][1];\n            if(nh<1||nl<1||nh>h||nl>w||vis[nh][nl]) continue;\n            if(mp[nh][nl]!='#'&&mp[nh][nl]!='$') {\n                next.h=nh,next.l=nl,next.step=it.step+1;\n                q.push(next);\n                vis[nh][nl]=true;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int sh,sl,eh,el;\n    node t;\n    scanf(\"%d%d\",&h,&w);\n    for(int i=1 ; i<=h ; i++) {\n        scanf(\"%s\",mp[i]+1);\n        for(int j=1 ; j<=w ; j++) {\n            if(mp[i][j]=='$') {\n                t.h=i,t.l=j;\n                soldier.push_back(t);\n            }\n            else if(mp[i][j]=='@') sh=i,sl=j;\n            else if(mp[i][j]=='%') eh=i,el=j;\n        }\n    }\n    int a=bfs(sh,sl,eh,el),minn=1008611,ss;\n    vector<node>::iterator it;\n    for(it=soldier.begin() ; it!=soldier.end(); it++) {\n        ss = bfs((*it).h,(*it).l,eh,el);\n        if(~ss) minn = min(ss,minn);\n    }\n    if(a<minn) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI 3.14159265358979323846\n\nusing namespace std;\n\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\n#define M_PI 3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\ninline int readInt()\n{\n    int x;\n    scanf(\"%d\", &x);\n    return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n//#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\nconst int INF = 2147483647;\n\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n    if (n < k)\n        return 0;\n    if (n < 0 || k < 0)\n        return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint dxy[5] = {-1, 0, 1, 0, -1};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    int H, W;\n    cin >> H >> W;\n\n    vector<string> s;\n    for (int i = 0; i < H; i++)\n    {\n        string t;\n        cin >> t;\n        s.push_back(t);\n    }\n\n    int sy, sx;\n    int py, px;\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            if (s[i][j] == '%')\n            {\n                sy = i, sx = j;\n            }\n\n            if (s[i][j] == '@')\n            {\n                py = i, px = j;\n            }\n        }\n    }\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    dist[sy][sx] = 0;\n    queue<pair<int, int>> q;\n    q.push({sy, sx});\n    while (q.size())\n    {\n        auto p = q.front();\n        q.pop();\n\n        int y = p.first, x = p.second;\n        for (int i = 0; i < 4; i++)\n        {\n            int ny = y + dxy[i], nx = x + dxy[i + 1];\n            if (ny >= 0 && ny < H && nx >= 0 && nx < W && dist[ny][nx] == INT_MAX && s[ny][nx] != '#')\n            {\n                dist[ny][nx] = dist[y][x] + 1;\n                q.push({ny, nx});\n            }\n        }\n    }\n\n    int mi = dist[py][px];\n    if (mi == INT_MAX)\n    {\n        cout << \"No\" << endl;\n    }\n    else\n    {\n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if (s[i][j] == '$')\n                {\n                    if (mi >= dist[i][j])\n                    {\n                        cout << \"No\" << endl;\n                        return 0;\n                    }\n                }\n            }\n        }\n        cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n \nconst int INF=1001001001;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n \nint H,W;\nchar fld[222][222];\nint lim[222][222];\nint dist[222][222];\n \nsigned main(){\n    int sy,sx,gy,gx;\n \n    cin>>H>>W;\n \n    queue<pint>que;\n    fill_n(*lim,222*222,INF);\n \n    rep(i,H)rep(j,W){\n        cin>>fld[i][j];\n        if(fld[i][j]=='@'){\n            sy=i;sx=j;\n        }\n        if(fld[i][j]=='%'){\n            gy=i;gx=j;\n        }\n        if(fld[i][j]=='$'){\n            lim[i][j]=0;\n            que.push(pint(i,j));\n        }\n    }\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n \n        rep(i,4){\n            int ny=y+dy[i],nx=x+dx[i];\n            if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]=='#'||lim[ny][nx]!=INF)continue;\n            lim[ny][nx]=lim[y][x]+1;\n            que.push(pint(ny,nx));\n        }\n    }\n \n    fill_n(*dist,222*222,INF);\n    dist[sy][sx]=0;\n    que.push(pint(sy,sx));\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n \n        rep(i,4){\n            int ny=y+dy[i],nx=x+dx[i];\n            if(ny<0||ny>=H||nx<0||nx>=W||dist[ny][nx]!=INF||fld[ny][nx]=='#'||lim[ny][nx]<=dist[y][x]+1)continue;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push(pint(ny,nx));\n        }\n    }\n \n    if(dist[gy][gx]!=INF){\n        cout<<\"Yes\"<<endl;\n    }\n    else{\n        cout<<\"No\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nstring mp[201];\n\nint bfs(char s){\n  queue<P> Q;\n  int D[N][N];\n  memset(D,-1,sizeof(D));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) \n      if(mp[i][j]==s)Q.push(P(i,j)),D[i][j]=0;\n\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    int y=t.first,x=t.second;\n    if(mp[y][x]=='\\%') return D[y][x];\n    for(int i=0;i<4;i++){\n      int ny=y+dy[i],nx=x+dx[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||D[ny][nx]!=-1)continue;\n  \n      Q.push(P(ny,nx));\n      D[ny][nx]=D[y][x]+1;\n    }\n  }\n  return 1e9;\n}\n\nint main(){\n  cin>>h>>w;\n  for(int i=0;i<h;i++)cin>>mp[i];\n  cout <<((bfs('@')<bfs('$'))? \"Yes\":\"No\")<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <string>\n#include <cmath>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long LL;\nconst int inf=0x3f3f3f3f;\nconst int mod=1e9+7;\nconst int N=2e2+10;\nint n,m,x,y,t1,t2;\nchar s[N][N];\nbool vis[N][N];\nint fx[]={-1,0,0,1},fy[]={0,-1,1,0};\nstruct wq\n{\n    int x,y,p;\n    wq(int a=0,int b=0,int c=0){x=a;y=b;p=c;}\n};\nqueue<wq>q;\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",s[i]+1);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(s[i][j]=='%')\n            {\n                x=i;y=j;i=n+1;break;\n            }\n        }\n    }\n    q.push(wq(x,y,0));\n    while(!q.empty())\n    {\n        wq tmp=q.front();\n        q.pop();\n        if(s[tmp.x][tmp.y]=='@') t1=tmp.p;\n        else if(s[tmp.x][tmp.y]=='$') t2=tmp.p;\n        if(t1&&t2) break;\n        vis[tmp.x][tmp.y]=1;\n        for(int i=0;i<4;i++)\n        {\n            int vx=tmp.x+fx[i],vy=tmp.y+fy[i];\n            if(vx>0&&vx<=n&&vy>0&&vy<=m&&!vis[vx][vy]&&s[vx][vy]!='#') q.push(wq(vx,vy,tmp.p+1));\n        }\n    }\n    if(!t2) t2=inf;\n    printf(\"%s\\n\",t1<t2?\"Yes\":\"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state {\n  int y, x, d;\n  bool operator<(const state &s) const {\n    return d > s.d;\n  }\n};\n\nint H, W, SY, SX;\nchar S[300][300];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool visited[300][300];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  cin >> H >> W;\n  REP(i, 0, H) REP(j, 0, W) {\n    cin >> S[i][j];\n    if(S[i][j] == '%') {\n      SY = i;\n      SX = j;\n    }\n  }\n\n  REP(i, 0, H) REP(j, 0, W) visited[i][j] = false;\n  queue<state> q;\n  q.push((state) { SY, SX, 0 });\n\n  while(q.size()) {\n    state c = q.front();\n    q.pop();\n    if(visited[c.y][c.x]) continue;\n    visited[c.y][c.x] = true;\n    if(S[c.y][c.x] == '@') {\n      cout << \"Yes\" << endl;\n      break;\n    }\n    if(S[c.y][c.x] == '$') {\n      cout << \"No\" << endl;\n      break;\n    }\n    REP(i, 0, 4) {\n      if(isin(c.y + dd[i], c.x + dd[i + 1]) && !visited[c.y + dd[i]][c.x + dd[i + 1]]) {\n        q.push((state) { c.y + dd[i], c.x + dd[i + 1], c.d + 1 });\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <queue>\n\nusing namespace std;\n\nchar a[205][205];\nint b[205][205];\nqueue <int> ii;\nqueue <int> jj;\n\n\nint main ()\n\n{\n    int w,h,i,j,k,s,p,ei,ej,fp,fs;\n    cin>>h>>w;\n    p=s=fp=fs=0;\n\n    memset(b,0,sizeof(b));\n\n    for(i=0;i<w+2;i++)\n    {\n        a[0][i]='#';\n        a[h+1][i]='#';\n    }\n\n    for(i=0;i<h+2;i++)\n    {\n        a[i][0]='#';\n        a[i][w+1]='#';\n    }\n\n    for(i=1;i<=h;i++)\n    {\n        for(j=1;j<=w;j++)\n        {\n            cin>>a[i][j];\n            if(a[i][j]=='%') {ii.push(i);\n            jj.push(j);\n            b[i][j]=1;}\n        }\n    }\n\n    int ti,tj;\n\n    while(!ii.empty())\n    {\n        ti= ii.front();\n        tj= jj.front();\n        ii.pop();\n        jj.pop();\n\n        //cout<<fp<<\" \"<<b[ti][tj]<<endl;\n\n        if(p==1 && fp == b[ti][tj] && s==0) {cout<<\"Yes\"<<endl;\n        return 0;}\n\n        if(s==1 && fs == b[ti][tj] && p==0)\n        {\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n\n        if(s==1 && p==1 && fs == b[ti][tj])\n        {\n            cout<<\"No\"<<endl;\n        return 0;\n        }\n\n        if(a[ti-1][tj]=='.' && b[ti-1][tj]==0)\n        {\n            ii.push(ti-1);\n            jj.push(tj);\n            b[ti-1][tj]=(b[ti][tj])+1;\n        }\n\n        if(a[ti+1][tj]=='.' && b[ti+1][tj]==0)\n        {\n            ii.push(ti+1);\n            jj.push(tj);\n            b[ti+1][tj]=(b[ti][tj])+1;\n        }\n\n        if(a[ti][tj-1]=='.' && b[ti][tj-1]==0)\n        {\n            ii.push(ti);\n            jj.push(tj-1);\n            b[ti][tj-1]=(b[ti][tj])+1;\n        }\n\n        if(a[ti][tj+1]=='.' && b[ti][tj+1]==0)\n        {\n            ii.push(ti);\n            jj.push(tj+1);\n            b[ti][tj+1]=(b[ti][tj])+1;\n        }\n\n        //rasta dekha shesh\n\n        if(a[ti-1][tj]=='$')\n        {\n            ii.push(ti-1);\n            jj.push(tj);\n            b[ti-1][tj]=(b[ti][tj])+1;\n            s=1;\n            if(fs==0) fs = b[ti-1][tj];\n        }\n\n        if(a[ti+1][tj]=='$')\n        {\n            ii.push(ti+1);\n            jj.push(tj);\n            b[ti+1][tj]=(b[ti][tj])+1;\n            s=1;\n            if(fs==0) fs = b[ti+1][tj];\n        }\n\n        if(a[ti][tj-1]=='$')\n        {\n            ii.push(ti);\n            jj.push(tj-1);\n            b[ti][tj-1]=(b[ti][tj])+1;\n            s=1;\n            if(fs==0) fs = b[ti][tj-1];\n        }\n\n        if(a[ti][tj+1]=='$')\n        {\n            ii.push(ti);\n            jj.push(tj+1);\n            b[ti][tj+1]=(b[ti][tj])+1;\n            s=1;\n            if(fs==0) fs = b[ti][tj+1];\n        }\n\n        //soldier dekha shesh\n\n        if(a[ti-1][tj]=='@')\n        {\n           ii.push(ti-1);\n           jj.push(tj);\n           b[ti-1][tj]=(b[ti][tj])+1;\n           fp = b[ti-1][tj];\n           p=1;\n        }\n\n        if(a[ti+1][tj]=='@')\n        {\n            ii.push(ti+1);\n            jj.push(tj);\n            b[ti+1][tj]=(b[ti][tj])+1;\n            fp = b[ti+1][tj];\n            p=1;\n        }\n\n        if(a[ti][tj-1]=='@')\n        {\n            ii.push(ti);\n            jj.push(tj-1);\n            b[ti][tj-1]=(b[ti][tj])+1;\n            fp = b[ti][tj-1];\n            p=1;\n        }\n\n        if(a[ti][tj+1]=='@')\n        {\n            ii.push(ti);\n            jj.push(tj+1);\n            b[ti][tj+1]=(b[ti][tj])+1;\n            fp = b[ti][tj+1];\n            p=1;\n        }\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nchar mp[209][209];\nint mark[209][209];\nint px[4]= {0,1,0,-1};\nint py[4]= {1,0,-1,0};\nconst int inf=99999;\nint ans[209][209];\nint bfs(int x,int y )\n{\n    if (ans[x][y]!=-1)return ans[x][y];\n    if (mark[x][y]==1||mp[x][y]=='#')return inf;\n    if (mp[x][y]=='%')return 1;\n    int anss=inf;\n    mark[x][y]=1;\n    for (int i =0; i<4; i++)\n    {\n        if (x+px[i]>=0&&x+px[i]<n&&y+py[i]>=0&&y+py[i]<m)\n            anss=min(anss,bfs(x+px[i],y+py[i])+1);\n    }\n    mark[x][y]=0;\n    if (anss>=inf)\n    {\n        ans[x][y]=inf;\n        return inf;\n    }\n    else return ans[x][y]=anss;\n}\nint main ()\n{\n    while (~scanf(\"%d%d\",&n,&m))\n    {\n        memset(mark,0,sizeof(mark));\n        for (int i =0; i<n; i++)\n        {\n            scanf(\"%s\",&mp[i]);\n        }\n        memset(ans,-1,sizeof(ans));\n        int sd=inf;\n        int pr=inf;\n        for (int i =0; i<n; i++)\n            for (int j =0; j<m; j++)\n                if (mp[i][j]=='@')\n                    pr=bfs(i,j);\n        for (int i =0; i<n; i++)\n        {\n            for (int j =0; j<m; j++)\n            {\n                if (mp[i][j]=='$')\n                {\n                    memset(ans,-1,sizeof(ans));\n                    memset(mark,0,sizeof(mark));\n                    sd=min(sd,bfs(i,j));\n                }\n            }\n        }\n//        for (int i =0; i<n; i++)\n//        {\n//            for (int j =0; j<m; j++)\n//            {\n//                printf (\"%5d \",ans[i][j]);\n//            }\n//            printf (\"\\n\");\n//        }\n        if (pr>=sd)printf (\"No\\n\");\n        else printf (\"Yes\\n\");\n    }\n}\n\n/*\n3 4\n.%..\n.##$\n.@$.\n3 4\n.%..\n.##.\n.@$$\n3 4\n.%..\n.##.\n$@$.\n10 10\n$.........\n..........\n..........\n#########%\n..........\n..........\n..........\n..........\n..........\n.........@\n10 10\n%.........\n..........\n..........\n#########$\n..........\n..........\n..........\n..........\n..........\n.........@\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nchar maze[250][250];\nint fire[250][250];\nint vis[250][250];\nint a[4]={0,0,1,-1};\nint b[4]={1,-1,0,0};\nint n,m;\nstruct node{\n\tint x,y,z;\n};\nqueue <node> q;\nint flag ;\nvoid bfs(){\n\twhile(!q.empty()){\n\t\tnode k = q.front();\n\t\tq.pop();\n\t\tint x1=k.x,y1=k.y,z=k.z;\n\t\tif(-z>fire[x1][y1]||fire[x1][y1]==0){\n\t\t\tfire[x1][y1]=-z;\n\t\t}\n\t\tfor(int i =0 ; i<4;i++){\n\t\t\tint x2 = x1 + a[i];\n\t\t\tint y2 = y1 + b[i];\n\t\t\tif(x2>=n||y2>=m||x2<0||y2<0||maze[x2][y2]=='#'||vis[x2][y2]==1) continue;\n\t\t\tvis[x2][y2] =1;\n\t\t\tnode l ;\n\t\t\tl.x=x2,l.y=y2,l.z=z+1;\n\t\t\tq.push(l);\n\t\t}\n\t}\n}\nvoid dfs(int x,int y,int z){\n\tvis[x][y]=1;\n\tif(maze[x][y]=='%'){\n\t\tflag= true;\n\t}\n\tfor(int i  = 0;i< 4;i++){\n\t\tint x2 =x+a[i];\n\t\tint y2 =y+b[i];\n\t\tif(x2>=n||y2>=m||x2<0||y2<0||maze[x2][y2]=='#'||vis[x2][y2]==1)continue;\n\t\tif(fire[x2][y2]==0||(z+1)<-fire[x2][y2])\n\t\tdfs(x2,y2,z+1);\n\t\t\n\t}\n}\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m)){\n\t\tflag = false;\n\t\tfor(int i = 0 ; i< n; i ++){\n\t\t\tscanf(\"%s\",maze[i]);\n\t\t}\n\t\tmemset(fire,0,sizeof(fire));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j< m; j++){\n\t\t\t\tif(maze[i][j]=='$'){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\t\t\tvis[i][j] =1;\n\t\t\t\t\tnode k;\n\t\t\t\t\tk.x=i,k.y=j,k.z=1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tbfs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i =0 ;i<n;i++){\n\t\t\tfor(int j =0 ;j< m ;j++){\n\t\t\t\tif(maze[i][j]=='@'){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t\tdfs(i,j,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<time.h>\n#include<stack>\n#include<map>\n#include<queue>\n#include<set>\n#include<bitset>\n#include<vector>\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int>V;\ntypedef pair<int , int > P;\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 2e18;\nconst double PI = acos(-1.0);\nconst double eps = 1e-9;\nconst int N = 5+1e2;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nint dp[N][N];\nchar s[N][N];\nbool vis[N][N];\nint ans1, ans2, n, m;\n\nvoid bfs(int i, int j)\n{\n    dp[i][j] = 0;\n    ans1 = ans2 = 0;\n    queue<P>q;\n    while(!q.empty())   q.pop();\n    q.push(P(i, j));\n    while(!q.empty())\n    {\n        P p = q.front();    q.pop();\n        vis[p.x][p.y] = 1;\n        if(ans1&&ans2)  break;\n        if(s[p.x][p.y]=='@')    ans1 = dp[p.x][p.y];\n        if(s[p.x][p.y]=='$')    ans2 = dp[p.x][p.y];\n        for(int k = 0; k < 4; k ++)\n        {\n            int xx = dx[k]+p.x, yy = dy[k]+p.y;\n            if(xx==0||yy==0||xx>n||yy>m)    continue;\n            if(vis[xx][yy]) continue;\n            if(s[xx][yy] == '#')    continue;\n            dp[xx][yy] = dp[p.x][p.y] + 1;\n            q.push(P(xx, yy));\n        }\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m))\n    {\n        memset(dp, 0x3f, sizeof dp);\n        memset(vis, 0, sizeof vis);\n        for(int i = 1; i <= n; i ++)\n            scanf(\"%s\", s[i]+1);\n        for(int i = 1; i <= n; i ++)\n            for(int j = 1; j <= m; j ++)\n        {\n            if(s[i][j] == '%')\n                bfs(i, j);\n        }\n        if(ans1<ans2||ans2==0)   puts(\"Yes\");\n        else    puts(\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdist = arg_dist;\n\t}\n\tInfo(){\n\t\trow = 0,col = 0,dist = 0;\n\t}\n\n\tint row,col,dist;\n};\n\nint H,W,div_row[4] = {-1,0,0,1},div_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint escape_row,escape_col;\n\tscanf(\"%d %d\",&H,&W);\n\tchar map[200][201];\n\n\tint distance[200][200];\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W;k++){\n\t\t\tdistance[i][k] = -1;\n\t\t\tif(map[i][k] == '%'){\n\t\t\t\tescape_row = i;\n\t\t\t\tescape_col = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tdistance[escape_row][escape_col] = 0;\n\n\tint prin = -1,enemy = 50000;\n\n\tqueue<Info> Q;\n\n\tQ.push(Info(escape_row,escape_col,0));\n\tInfo current;\n\n\twhile(!Q.empty()){\n\t\tcurrent = Q.front();\n\t\tQ.pop();\n\n\t\tif(map[current.row][current.col] == '@'){ //?§????????????°??????????????¢?´¢???????????????\n\t\t\tif(prin == -1){\n\t\t\t\tprin = current.dist;\n\t\t\t}else{\n\t\t\t\tprin = min(prin,current.dist);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}else if(map[current.row][current.col] == '$'){\n\t\t\tenemy = min(enemy,current.dist);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif((prin != -1 && current.dist >= prin) || (current.dist >= enemy))continue; //??????????????????????§????????????????????????????????????¢?´¢???????????????\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(rangeCheck(current.row+div_row[i],current.col+div_col[i]) == true && map[current.row+div_row[i]][current.col+div_col[i]] != '#' &&  //???????????????????§???????????£???§?????????\n\t\t\t\t\t(distance[current.row+div_row[i]][current.col+div_col[i]] == -1 || distance[current.row+div_row[i]][current.col+div_col[i]] > current.dist+1)){ //??????(?§???????????????¢??????????¨????????????????????????????????????????????????????)\n\t\t\t\tdistance[current.row+div_row[i]][current.col+div_col[i]] = current.dist+1;\n\t\t\t\tQ.push(Info(current.row+div_row[i],current.col+div_col[i],current.dist+1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif(prin == -1 || prin >= enemy){\n\t\tprintf(\"No\\n\");\n\t}else{\n\t\tprintf(\"Yes\\n\");\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint INF = 100000;\nint main(){\n  int H, W;\n  cin >> H >> W;\n  vector<vector<char>> A(H + 2, vector<char>(W + 2, '#'));\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      cin >> A[i][j];\n    }\n  }\n  int ey, ex;\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      if (A[i][j] == '%'){\n        ey = i;\n        ex = j;\n      }\n    }\n  }\n  vector<vector<int>> d(H + 2, vector<int>(W + 2, INF));\n  d[ey][ex] = 0;\n  queue<pair<int, int>> Q;\n  Q.push(make_pair(ey, ex));\n  while (!Q.empty()){\n    int y = Q.front().first;\n    int x = Q.front().second;\n    Q.pop();\n    for (int i = 0; i < 4; i++){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if (d[y2][x2] == INF && A[y2][x2] != '#'){\n        d[y2][x2] = d[y][x] + 1;\n        Q.push(make_pair(y2, x2));\n      }\n    }\n  }\n  int p;\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      if (A[i][j] == '@'){\n        p = d[i][j];\n      }\n    }\n  }\n  bool ok = true;\n  for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      if (A[i][j] == '$' && d[i][j] <= p){\n        ok = false;\n      }\n    }\n  }\n  if (ok){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring solve()\n{\n    int h,w;\n    cin >>h >>w;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n    #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n\n    while(1)\n    {\n        bool p = false;\n        rep(i,h)rep(j,w)\n        {\n            if(s[i][j]=='@')\n            {\n                p = true;\n                rep(k,4)\n                {\n                    int nx = j+dx[k], ny = i+dy[k];\n                    if(IN(nx,ny))\n                    {\n                        if(s[ny][nx]=='%') return \"Yes\";\n                        if(s[ny][nx]=='.') s[ny][nx]='@';\n                    }\n                }\n            }\n        }\n        if(!p) break;\n\n        rep(i,h)rep(j,w)\n        {\n            if(s[i][j]=='$')\n            {\n                rep(k,4)\n                {\n                    int nx = j+dx[k], ny = i+dy[k];\n                    if(IN(nx,ny) && s[ny][nx]!='#')\n                    {\n                        s[ny][nx]='$';\n                    }\n                }\n            }\n        }\n\n    }\n\n    return \"No\";\n}\n\nint main()\n{\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P {\n\tint x, y;\n\tP() : x(0), y(0) {}\n\tP(int x, int y)\n\t\t: x(x), y(y) {}\n};\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint H, W;\n\tP s, g;\n\tvector<P> q, sol;\n\tchar c;\n\tcin >> H >> W;\n\tvector<vector<int>> a(H, vector<int>(W, 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c;\n\t\t\tif (c == '%') {\n\t\t\t\tg.x = i, g.y = j;\n\t\t\t}\n\t\t\telse if (c == '@') {\n\t\t\t\ts.x = i, s.y = j;\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tq.push_back(s);\n\t\t\t}\n\t\t\telse if (c == '$') {\n\t\t\t\tsol.push_back(P(i, j));\n\t\t\t\ta[i][j] = -1;\n\t\t\t}\n\t\t\telse if (c == '#') {\n\t\t\t\ta[i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tbool res = false;\n\twhile (!q.empty()) {\n\t\tvector<P> tq, tsol;\n\t\tfor (auto p : sol) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = p.x + dx[i], ty = p.y + dy[i];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W && a[tx][ty] != -1) {\n\t\t\t\t\ta[tx][ty] = -1;\n\t\t\t\t\ttsol.push_back(P(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto p : q) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = p.x + dx[i], ty = p.y + dy[i];\n\t\t\t\tif (tx >= 0 && tx < H && ty >= 0 && ty < W && a[tx][ty] == 1) {\n\t\t\t\t\tif (tx == g.x && ty == g.y) {\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\ttq.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta[tx][ty] = 0;\n\t\t\t\t\ttq.push_back(P(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = tq, sol = tsol;\n\t}\n\tcout << (res ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\nchar fi[220][220];\nint d[220][220];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint h,w; cin >> h >> w;\n\tpair<int,int> s,g;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t\tif(fi[i][j]=='@')g=make_pair(i,j);\n\t\t\tif(fi[i][j]=='%')s=make_pair(i,j);\n\t\t\td[i][j]=1e9;\n\t\t}\n\t}\n\tqueue<pair<int,int>> q;\n\tq.push(s);\n\td[s.first][s.second]=0;\n\twhile(q.size()){\n\t\tauto p=q.front(); q.pop();\n\t\tint x=p.first,y=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w&&fi[nx][ny]!='#'&&d[nx][ny]>d[x][y]+1){\n\t\t\t\td[nx][ny]=d[x][y]+1;\n\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n\tint mi=1e9;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fi[i][j]=='$')mi=min(mi,d[i][j]);\n\t\t}\n\t}\n\tif(mi>d[g.first][g.second])printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b)\tfor (int i(a); i <= (b); ++i)\n#define dec(i, a, b)\tfor (int i(a); i >= (b); --i)\n#define MP\t\tmake_pair\n#define fi\t\tfirst\n#define se\t\tsecond\n\n\ntypedef long long LL;\ntypedef pair <int, int> PII;\n\nconst int N    = 205;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n, m;\nint f[N][N];\nchar s[N][N];\nint x, y;\nqueue <PII> q;\nset <int> ss;\nint inf = 1 << 28;\n\nint main(){\n\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, 1, n) scanf(\"%s\", s[i] + 1);\n\n\trep(i, 1, n) rep(j, 1, m) f[i][j] = inf;\n\n\trep(i, 1, n) rep(j, 1, m) if ((int)s[i][j] == 37){\n\t\tq.push(MP(i, j));\n\t\tf[i][j] = 1;\n\t\tbreak;\n\t}\n\n\n\twhile (!q.empty()){\n\t\tauto now = q.front();\n\t\tq.pop();\n\t\tint x = now.fi, y = now.se;\n\t\trep(i, 0, 3){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (nx >= 1 && nx <= n && ny >= 1 && ny <= m && f[nx][ny] == inf && (s[nx][ny] == '$' || s[nx][ny] == '.' || s[nx][ny] == '@')){\n\t\t\t\tf[nx][ny] = f[x][y] + 1;\n\t\t\t\tq.push(MP(nx, ny));\n\t\t\t}\n\t\t}\t      \t\t\n\t}\n\n\trep(i, 1, n) rep(j, 1, m) if (s[i][j] == '$') ss.insert(f[i][j]);\n\tint cc = 0;\n\trep(i, 1, n) rep(j, 1, m) if (s[i][j] == '@') cc = f[i][j];\n\tputs(cc < (*ss.begin())  ? \"Yes\" : \"No\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (tmp[p.second][p.first] >= ms[p.second][p.first])continue;\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#') {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\t\t\tms[ny][nx] = tmp[ny][nx];\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=0,pri=0;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w){if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(pri&&pri<a.second)break;\n    if(s[yy][xx]=='$'){sol=a.second;}\n    if(s[yy][xx]=='@'){pri=a.second;}\n    if(sol)break;\n    r(i,4){\n      int x1=xx+dx[i],y1=yy+dy[i];\n      if(x1<0||x1>=w||y1<0||y1>=h||b[y1][x1]||s[y1][x1]=='#')continue;\n          Q.push(mk(mk(y1,x1),a.second+1));\n    }\n  }\n  if(sol==0)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2781.cpp\n// Author: ymiyamoto\n//\n// Created on Fri Dec 29 19:30:51 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nuint32_t wfs(vector<string> map, int32_t y, int32_t x)\n{\n  vector<vector<int32_t>> visited(map.size(), vector<int32_t>(map[0].size(), -1));\n  visited[y][x] = 0;\n  queue<pair<int32_t, int32_t>> q;\n  q.push({y, x});\n\n  while (!q.empty()) {\n    pair<int32_t, int32_t> p = q.front();\n    q.pop();\n\n    vector<pair<int32_t, int32_t>> ds = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    for (auto d : ds) {\n      int32_t y2 = p.first + d.first;\n      int32_t x2 = p.second + d.second;\n      if (0 <= y2 && y2 < (int32_t)map.size() && 0 <= x2 && x2 < (int32_t)map[0].size() && (visited[y2][x2] == -1)) {\n        if (map[y2][x2] == '#' || map[y2][x2] == '$') continue;\n        visited[y2][x2] = visited[p.first][p.second] + 1;\n        q.push({y2, x2});\n      }\n    }\n  }\n\n  for (uint32_t i = 0; i < map.size(); i++) {\n    for (uint32_t j = 0; j < map[0].size(); j++) {\n      if (map[i][j] == '%') {\n        return visited[i][j];\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  uint32_t H, W;\n  cin >> H >> W;\n  vector<string> map;\n  for (uint32_t i = 0; i < H; i++) {\n    string line;\n    cin >> line;\n    map.push_back(line);\n  }\n\n  uint32_t princess;\n  uint32_t soldier = UINT32_MAX;\n  for (uint32_t y = 0; y < H; y++) {\n    for (uint32_t x = 0; x < W; x++) {\n      if (map[y][x] == '@') {\n        princess = wfs(map, y, x);\n      } else if (map[y][x] == '$') {\n        soldier = min(soldier, wfs(map, y, x));\n      }\n    }\n  }\n\n  if (princess < soldier) {\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint H, W;\nint bo[210][210];\nll d[210][210];\n\nvoid BFS(int x, int y) {\n    for (int i = 0; i < H; i++) {\n        fill(d[i], d[i] + W + 10, llmax);\n    }\n    queue<pii> que;\n    d[x][y] = 0;\n    que.push(pii(x, y));\n    while (que.size() > 0) {\n        pii p = que.front();\n        int xx = p.first;\n        int yy = p.second;\n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            int xxx = xx + dx[i];\n            int yyy = yy + dy[i];\n            if (xxx >= 0 && xxx < H && yyy >= 0 && yyy < W) {\n                if (d[xxx][yyy] == llmax && bo[xxx][yyy] > 0) {\n                    d[xxx][yyy] = d[xx][yy] + 1;\n                    que.push(pii(xxx, yyy));\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> H >> W;\n    int st[2];\n    for (int i = 0; i < H; i++) {\n        string s;\n        cin >> s;\n        char mark[5] = {'#', '.', '@', '$', '%'};\n        for (int j = 0; j < W; j++) {\n            for (int k = 0; k < 5; k++) {\n                if (s[j] == mark[k]) {\n                    bo[i][j] = k;\n                    if (k == 4) {\n                        st[0] = i;\n                        st[1] = j;\n                    }\n                }\n            }\n        }\n    }\n    BFS(st[0], st[1]);\n    ll pri = llmax;\n    ll sol = llmax;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (bo[i][j] == 2) {\n                pri = d[i][j];\n                //cout << pri << \" aaa\" << endl;\n            } else if (bo[i][j] == 3) {\n                //cout << d[i][j] << endl;\n                if (d[i][j] < sol) {\n                    sol = d[i][j];\n                }\n            }\n        }\n    }\n    if (pri < sol) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// @Team    : nupt2017team12\n// @Author  : Zst\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define MOD 1000000007\n#define CLR(a,x) memset(a,x,sizeof(a))\n#define INF 0x3f3f3f3f\n#define pb push_back\n#define FOR(i,a,b) for( int i = ( a ); i <= ( b ); ++i )\n\nconst int N = 200+7;\nchar maps[N][N];\nint vis[N][N];\n\nint r, c;\nint posX, posY;\n\nint princess;\nint soldier;\n\nvoid solve( int x, int y, int times )\n{\n\tvis[x][y] = times;\n\tif( maps[x][y] == '@' ) {\n\t\tprincess = min( princess, times );\n\t} else if( maps[x][y] == '$' ) {\n\t\tsoldier = min( soldier, times );\n\t}\n\tif( x-1 >= 0 ) {\n\t\tif( vis[x-1][y] == -1 ) {\n\t\t\tsolve( x-1, y, times+1 );\n\t\t} else if( times+1 < vis[x-1][y] ) {\n\t\t\tsolve( x-1, y, times+1 );\n\t\t}\n\t}\n\tif( y-1 >= 0 ) {\n\t\tif( vis[x][y-1] == -1 ) {\n\t\t\tsolve( x, y-1, times+1 );\n\t\t} else if( times+1 < vis[x][y-1] ) {\n\t\t\tsolve( x, y-1, times+1 );\n\t\t}\n\t}\n\tif( x+1 < r ) {\n\t\tif( vis[x+1][y] == -1 ) {\n\t\t\tsolve( x+1, y, times+1 );\n\t\t} else if( times+1 < vis[x+1][y] ) {\n\t\t\tsolve( x+1, y, times+1 );\n\t\t}\n\t}\n\tif( y+1 < c ) {\n\t\tif( vis[x][y+1] == -1 ) {\n\t\t\tsolve( x, y+1, times+1 );\n\t\t} else if( times+1 < vis[x][y+1] ) {\n\t\t\tsolve( x, y+1, times+1 );\n\t\t}\n\t}\n\treturn;\n\n}\n\n\nint main()\n{\n    // freopen( \"B.txt\", \"r\", stdin );\n    while( scanf( \"%d%d\", &r, &c ) != EOF ) {\n    \tprincess = soldier = INF;\n\t\tCLR( vis, -1 );\n\t    FOR( i, 0, r-1 ) {\n\t    \tscanf( \"%s\", maps[i] );\n\t\t\tFOR( j, 0, c-1 ) {\n\t\t\t\tif( maps[i][j] == '%' ) {\n\t\t\t\t\tposX = i;\n\t\t\t\t\tposY = j;\n\t\t\t\t} else if( maps[i][j] == '#' ) {\n\t\t\t\t\tvis[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t    }\n\t    solve( posX, posY, 0 );\n\t    if( princess < soldier ) {\n\t    \tprintf( \"Yes\\n\");\n\t    } else {\n\t    \tprintf( \"No\\n\");\n\t    }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint H, W;\nint sx, sy;\nvector<string> s;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nvector<vector<int>> bfs() {\n    queue<pair<int, int>> que;\n    que.emplace(sx, sy);\n    vector<vector<int>> d(H, vector<int>(W, inf));\n    d[sx][sy] = 0;\n\n    while (!que.empty()) {\n        int x, y;\n        tie(x, y) = que.front(); que.pop();\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (inside(nx, ny) && s[nx][ny] != '#' && d[nx][ny] == inf) {\n                d[nx][ny] = d[x][y] + 1;\n                que.emplace(nx, ny);\n            }\n        }\n    }\n\n    return d;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '%') {\n                sx = i, sy = j;\n            }\n        }\n    }\n\n    auto d = bfs();\n    int princess;\n    int soldier = inf;\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '@') {\n                princess = d[i][j];\n            }\n            if (s[i][j] == '$') {\n                soldier = min(soldier, d[i][j]);\n            }\n        }\n    }\n\n    cout << (princess < soldier ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ?¨?????????? ?§???????????? ?§???±???????????????? ?§???±???????????? //\n//________________//\n#include <bits/stdc++.h>\n\n//  http://ideone.com/kxcEk8\nusing namespace std;\n#define NN 2005\n#define inf                  1e7\n#define white                0\n#define grey                 1\n#define black                2\n#define ll                   long long\n#define ull                  unsigned long long\n#define PI                   2.0*acos(0.0)   // acos(-1)\n#define pii                  pair <int,int>\n#define pll                  pair <ll,ll>\n#define rep(i,x,y)           for(int i = x ; i < y ; i++)\n#define ff                   first\n#define ss                   second\n#define X(i)                 x+fx[i]\n#define Y(i)                 y+fy[i]\n#define BOUNDRY(i,j)         ((i>=0 && i < r) && (j>= 0 && j< c))\n#define WRITE                freopen(\"a.txt\",\"w\",stdout);\n//***********************************************\n#define MOD\n#define ashraf\n#ifdef ashraf\n     #define so(args...) {cerr<<\"so: \"; dbg,args; cerr<<endl;}\n#else\n    #define so(args...)  // Just strip off all debug tokens\n#endif\nstruct debugger{\n    template<typename T> debugger& operator , (const T& v){\n        cerr<<v<<\" \";\n        return *this;\n    }\n}dbg;\n\n\n//******************************************************\ninline void take(int &x) {scanf(\"%d\",&x);}\ninline void take(int &x ,int &y)  {scanf(\"%d %d\",&x, &y);}\ntemplate < class T> inline T Set(T N, T pos){ return N = N | (1<< pos);}\ntemplate < class T> inline bool Check(T N , T pos){ return (bool) (N & (1<<pos));}\ntemplate < class T> inline T Reset(T N , T pos) { return N = N & ~(1 << pos); }\ndouble grad(double n){ return (PI*n)/180; }\ndouble agrad(double n){ return (180*n)/PI; }\ntemplate < class T> inline T gcd(T a, T b) {\n  while (a > 0 && b > 0)\n    a > b ? a%=b : b%=a;\n  return a + b;\n}\ntemplate <class T > inline T  modInv(T n, T m) {\n      T x, y, gcd;\n      extEuclid(n, m, x, y, gcd);\n      if (gcd == 1) return x % m;\n      return 0;\n}\ntemplate < class T> inline T lcm(T a, T b) {return (a*b)/gcd(a,b);}\ntemplate < class T> T big(T b , T p , T mod){\n    if(p == 0) return 1;\n    if(!(p&1)){\n        T x = big(b,p/2,mod);\n        return (x*x)%mod;\n    }\n    else return (b*big(b,p-1,mod))%mod;\n}\n\ntemplate < class T> T POW(T b , T p){\n    if(p == 0) return 1;\n    if(!(p&1)){\n        T x = POW(b,p/2);\n        return (x*x);\n    }\n    else return (b*POW(b,p-1));\n}\n\nint fx[] = {0,1,0,-1};\nint fy[] = {1,0,-1,0};\n    int r , c;\nstring ch[NN];\nint vis[NN][NN];\nint level[NN][NN];\nvoid dfs(int m , int n){\n     vis[m][n] = 1;\n     queue < pii > q;\n     q.push(make_pair(m,n));\n     while(!q.empty()){\n         int x = q.front().ff;\n         int y = q.front().ss;\n         q.pop();\n         for(int i = 0 ; i< 4 ; i++){\n             int X = fx[i]+x;\n             int Y = fy[i]+y;\n             if(!vis[X][Y] && ch[X][Y] != '#' && BOUNDRY(X,Y)){\n                  level[X][Y] = 1+level[x][y];\n                  q.push(make_pair(X,Y));\n                  vis[X][Y] = 1;\n             }\n        }\n\n     }\n}\nint main()\n{\n//    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> r >> c;\n    int savex , savey, psavex , psavey;\n    for(int i = 0 ; i< r ; i++){\n        cin >> ch[i];\n        for(int j = 0 ; j< ch[i].size() ; j++){\n             if(ch[i][j] == '%'){\n                savex = i;\n                savey = j;\n             }\n             if(ch[i][j] == '@'){\n               psavex = i;\n               psavey = j;\n             }\n        }\n    }\n    memset(vis,0,sizeof vis);\n    memset(level,0,sizeof level);\n    dfs(savex,savey);\n    bool flag = 0;\n    for(int i = 0 ; i< r ; i++){\n        for(int j = 0 ; j< ch[i].size() ; j++){\n             if(ch[i][j] == '$'){\n                if(level[i][j] <= level[psavex][psavey]){\n                    flag = 1;\n                }\n             }\n//             cout << level[i][j] << ' ';\n        }\n//        cout << endl;\n    }\n\n    if(flag == 1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// @Team    : nupt2017team12\n// @Author  : Zst\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define LL long long\n#define MOD 1000000007\n#define CLR(a,x) memset(a,x,sizeof(a))\n#define INF 0x3f3f3f3f\n#define pb push_back\n#define FOR(i,a,b) for( int i = ( a ); i <= ( b ); ++i )\n\nconst int N = 200+7;\nchar maps[N][N];\nbool vis[N][N];\n\nint r, c;\nint posX, posY;\n\nint princess;\nint soldier;\n\nvoid solve( int x, int y, int times )\n{\n\tvis[x][y] = true;\n\tif( maps[x][y] == '@' ) {\n\t\tprincess = min( princess, times );\n\t} else if( maps[x][y] == '$' ) {\n\t\tsoldier = min( soldier, times );\n\t}\n\tif( x-1 >= 0 ) {\n\t\tif( vis[x-1][y] != true ) {\n\t\t\tif( maps[x-1][y] != '#' ) {\n\t\t\t\tsolve( x-1, y, times+1 );\n\t\t\t}\n\t\t}\n\t}\n\tif( y-1 >= 0 ) {\n\t\tif( vis[x][y-1] != true ) {\n\t\t\tif( maps[x][y-1] != '#' ) {\n\t\t\t\tsolve( x, y-1, times+1 );\n\t\t\t}\n\t\t}\n\t}\n\tif( x+1 < r ) {\n\t\tif( vis[x+1][y] != true ) {\n\t\t\tif( maps[x+1][y] != '#' ) {\n\t\t\t\tsolve( x+1, y, times+1 );\n\t\t\t}\n\t\t}\n\t}\n\tif( y+1 < c ) {\n\t\tif( vis[x][y+1] != true ) {\n\t\t\tif( maps[x][y+1] != '#' ) {\n\t\t\t\tsolve( x, y+1, times+1 );\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n\n}\n\n\nint main()\n{\n\tposX = 0;\n\tprincess = soldier = INF;\n\tCLR( vis, false );\n    // freopen( \"B.txt\", \"r\", stdin );\n    scanf( \"%d%d\", &r, &c );\n    FOR( i, 0, r-1 ) {\n    \tscanf( \"%s\", maps[i] );\n    \tif( posX == 0 ) {\n    \t\tFOR( j, 0, c-1 ) {\n    \t\t\tif( maps[i][j] == '%' ) {\n    \t\t\t\tposX = i;\n    \t\t\t\tposY = j;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    solve( posX, posY, 0 );\n    if( princess < soldier ) {\n    \tprintf( \"Yes\\n\");\n    } else {\n    \tprintf( \"No\\n\");\n    }\n\n    \n\n\n\n\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y,z;\n};\nPoint operator-(const Point& a,const Point& b)\n{\n  Point ret={a.x-b.x,a.y-b.y,a.z-b.z};\n  return ret;\n}\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nPoint cross(Point a,Point b)\n{\n  Point ret={a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};\n  return ret;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\nstring board[210];\nint H,W;\nint sx,sy;\nint gx,gy;\nint primin=inf;\nint solmin=inf;\nint d[210][210];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\ntypedef pair<int,int> P;\nvoid solve(int sy,int sx,char movement)\n{\n  queue<P> que;\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  que.push(P(sy,sx));\n  while(!que.empty())\n    {\n      P p=que.front();que.pop();\n      if(p.first==gy && p.second==gx) break;\n      for(int i=0;i<4;i++)\n\t{\n\t  int ny=p.first+dy[i];\n\t  int nx=p.second+dx[i];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#' || d[ny][nx]!=inf) continue;\n\t  que.push(P(ny,nx));\n\t  d[ny][nx]=d[p.first][p.second]+1;\n\t}\n    }\n  if(movement=='@') primin=min(primin,d[gy][gx]);\n  else if(movement=='$') solmin=min(solmin,d[gy][gx]);\n}\n\nint main(int argc,char const* argv[])\n{\n  cin >> H >> W;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n   \n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='%')\n\t    {\n\t      gy=i,gx=j;\n\t    }\n\t}\n    }\n  \n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='@') solve(i,j,'@');\n\t  else if(board[i][j]=='$') solve(i,j,'$');\n\t}\n    }\n  if(primin>=solmin){cout << \"No\" << endl;}\n  else{cout << \"Yes\" << endl;}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \nint dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvector <string> board;\nvvb used;\nint x, y;\n\nbool solve(int a, int b);\n\nsigned main()\n{\n    cin >> x >> y;\n    board.assign(x, \"\");\n\n    rep(i, x) {\n        cin >> board[i];\n    }\n\n    bool ret;\n    rep(i, x) {\n        rep(j, y) {\n            if (board[i][j] == '%') {\n                ret = solve(i, j);\n            }\n        }\n    }\n\n    cout << ( (ret) ? \"Yes\" : \"No\" ) << endl;\n\n    return 0;\n}\n\nbool solve(int a, int b)\n{\n    queue< i_i > q;\n    q.push(i_i(a, b));\n    used.assign(x, vb(y, false));\n    used[a][b] = true;\n\n    while (!q.empty()) {\n        queue <i_i> nxt;\n        while (!q.empty()) {\n            int c = q.front().first, d = q.front().second;\n            q.pop();\n            rep(i, 4) {\n                int nx = c + dxy[i], ny = d + dxy[i+1];\n                if (nx < 0 || ny < 0 || x <= nx || y <= ny\n                        || used[nx][ny] ) {\n                    continue;\n                }\n                if (board[nx][ny] == '.') {\n                    nxt.push(i_i(nx, ny));\n                } else if (board[nx][ny] == '$') {\n                    return false;\n                } else if (board[nx][ny] == '@') {\n                    return true;\n                } \n                used[nx][ny] = true;\n            }\n        }\n        q = nxt;\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n/*\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2781\n\n????\\??????????????????????\n????????????????????????????\\???????????????§?????????????????????????????£???????????????????\\?????????????????????????????????????\n????????????????£???????????\\??????????????????????????????????????????????????????¢???????????????????????????????\\???????????????????\n?????????????????¨?????§??????????????????????±??????????????????°????????????????????¨??????\n\n ????´????????????????????????°???????????????????????¢????????£??????????????°?????????????????????????¨??????????????????????\n ???1??????????£?????\\????????????\\??§???????????????2?????????????£?????\\?????????\\????????¨?????§?????????????????????\n ???????????????????????????????????????????£???¨?????¶?????¨?????????????\\??????¨????£??????°?????£????????????????????????????????¨?????????\n ??°??????????????????????????????????????????????????????????????¨????????????????\\?????????????????????°???????????°???\n ????????¨????\\?????????????????????????????????¨?????§????????????????????????0?????\\??????????£?????????????\n\n ?\\??????¨??¨??????????£???????????????????????????????????????????????????????????????????????????°????\\??????¨????£????\n ??????????¬????????????????????????¨?????§???????????????????????????????\\??????¨????£?????°´?????\\??????????????´?????£??\\???????????????\n ?§?????????????????????????????????¨??????????????¨?????§??????????????????????\\??????¨????£??????????????????????????????¨?????§????????????\n ???????\\???????????????\\??????????????°???????£???????????????????????????£????????????????????¨?????£??????????\\?????????????????????????\n ?\\???????????????¨??????????£?????????????????????????????????????????????¨?????£???????????°??????????????°?????§???????????¨???????????§?????????\n\n ??????????£??????????????????????????????????????????£?????¨??????????\\????????????????????????¨?????§??????????????????????????¨????????°???\n ????????¨????\\???????????£?????????????????????¨?????§????????????????\\???????????£???????????????????????????°???????????¨????????°???\n ?\\?????????????????????¨?????§??????????\\?????????????????????????????????¨?????§????????????\n\n*/\ntypedef long long ll;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> masu(H + 2, vector<int>(W + 2, -1));\n\tint px, py;\n\tint hx, hy;\n\tvector<int> sx, sy;\n\t//initialize\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W;j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '%') {\n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\thx = i; hy = j;\n\t\t\t}\n\t\t\telse if (c == '.')masu[i][j] = 0;\n\t\t\telse if (c == '@') { \n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\tpx = i; py = j;\n\t\t\t}\n\t\t\telse if (c == '$') sx.push_back(i), sy.push_back(j);\n\t\t}\n\t}\n\tvector<vector<int>> dist(H + 2, vector<int>(W + 2, (1 << 30)));\n\tqueue<pair<int, int>> q;\n\tq.push({ px,py });\n\tdist[px][py] = 0;\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second]+1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tint key = dist[hx][hy];\n\tdist = vector<vector<int>>(H + 2, vector<int>(W + 2, (1 << 30)));\n\tfor (int i = 0; i < sx.size();i++) {\n\t\tq.push({ sx[i],sy[i] });\n\t\tdist[sx[i]][sy[i]] = 0;\n\t}\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second] + 1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tif (key >= dist[hx][hy]) {\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> cell;\n\n#define x first\n#define y second\n#define mp make_pair\n\nconst int N = 205;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nchar g[N][N];\nint h, w, sx, sy, d[N][N];\nint princess;\nvector <int> soldiers;\n\nbool valid (int x, int y) {\n\treturn x >= 1 and y >= 1 and x <= h and y <= w and g[x][y] != '#';\n}\n\nvoid bfs (void) {\n\tqueue <cell> q;\n\tq.push(mp(sx, sy));\n\tmemset(d, -1, sizeof d);\n\td[sx][sy] = 0;\n\n\twhile (not q.empty()) {\n\t\tcell u = q.front(); q.pop();\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tint nx = u.x + dx[k], ny = u.y + dy[k];\n\t\t\tif (!valid(nx, ny)) continue;\n\t\t\tif (d[nx][ny] != -1) continue;\n\n\t\t\td[nx][ny] = d[u.x][u.y] + 1;\n\t\t\tq.push(mp(nx, ny));\n\n\t\t\tif (g[nx][ny] == '@') princess = d[nx][ny];\n\t\t\telse if (g[nx][ny] == '$') soldiers.push_back(d[nx][ny]);\n\t\t}\n\t}\n}\n\nint main (int argc, char const *argv[]) {\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 1; i <= h; ++i) {\n\t\tscanf(\"%s\", g[i] + 1);\n\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\tif (g[i][j] == '%') sx = i, sy = j;  \n\t\t}\n\t}\n\n\tbfs();\n\n\tint flag = 1;\n\tfor (int i = 0; i < (int) soldiers.size(); ++i) {\n\t\tif (soldiers[i] <= princess) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(flag ? \"Yes\" : \"No\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint prx, pry;\nint hax, hay;\nint dfs(const vector<vector<int>>&field, vector<vector<int>>&memo) {\n\n\tqueue<aa>que;\n\tque.push(aa{ prx,pry,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tif (atop.y == hay&&atop.x == hax)return atop.time;\n\t\tque.pop();\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tconst int nextx = atop.x + dx[way];\n\t\t\tconst int nexty = atop.y + dy[way];\n\t\t\tconst int nexttime = atop.time + 1;\n\t\t\tif (field[nexty][nextx] > nexttime) {\n\n\t\t\t\tif (memo[nexty][nextx]>nexttime) {\n\t\t\t\t\tmemo[nexty][nextx] = nexttime;\n\t\t\t\t\tque.push(aa{ nextx,nexty,nexttime });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2, -1));\n\tvector<vector<int>>memo(H + 2, vector<int>(W + 2, 1000));\n\n\tqueue<aa>que;\n\tfor (int i = 0; i < H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tchar ch = st[j];\n\t\t\tif (ch == '@') {\n\t\t\t\tprx = j + 1, pry = i + 1;\n\t\t\t\tfield[i+1][j+1] = 1000;\n\t\t\t}\n\t\t\telse if (ch == '%') {\n\t\t\t\thax = j + 1, hay = i + 1;\n\t\t\t\tfield[i + 1][j + 1] = 1000;\n\t\t\t}\n\t\t\telse if (ch == '$') {\n\t\t\t\tque.push(aa{ j + 1,i + 1,0 });\n\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t}\n\t\t\telse if (ch == '.') {\n\t\t\t\tfield[i + 1][j + 1] = 1000;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i + 1][j + 1] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tmemo[pry][prx] = 0;\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tconst int nextx = atop.x + dx[way];\n\t\t\tconst int nexty = atop.y + dy[way];\n\t\t\tconst int nexttime = atop.time + 1;\n\t\t\tif (field[nexty][nextx] >= 0) {\n\n\t\t\t\tif (field[nexty][nextx]>nexttime) {\n\t\t\t\t\tfield[nexty][nextx] = nexttime;\n\t\t\t\t\tque.push(aa{ nextx,nexty,nexttime });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dfs(field, memo);\n\tif (ans >= 0)cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=203,INF=1<<30;\nint H,W;\nint dis[MAX][MAX];\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nvoid BFS(pair<int,int> s){\n    queue<pair<int,int>> Q;\n    dis[s.first][s.second]=0;\n    Q.push(s);\n    \n    while(!Q.empty()){\n        pair<int,int> a=Q.front();Q.pop();\n        \n        for(int i=0;i<4;i++){\n            int toh=a.first+dh[i],tow=a.second+dw[i];\n            \n            if(0<=toh&&toh<H&&0<=tow&&tow<W&&dis[toh][tow]==INF){\n                dis[toh][tow]=dis[a.first][a.second]+1;\n                \n                Q.push({toh,tow});\n            }\n        }\n    }\n    \n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W;\n    vector<string> S(H);\n    pair<int,int> s,g;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            dis[i][j]=INF;\n        }\n    }\n    for(int i=0;i<H;i++){\n        cin>>S[i];\n        for(int j=0;j<W;j++){\n            if(S[i][j]=='@') g={i,j};\n            else if(S[i][j]=='%') s={i,j};\n            else if(S[i][j]=='#') dis[i][j]=-1;\n        }\n    }\n    \n    BFS(s);\n    \n    \n    int mini=INF;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(S[i][j]=='$') mini=min(mini,dis[i][j]);\n        }\n    }\n    \n    if(mini>dis[g.first][g.second]) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint h, w, sx, sy, gx, gy;\nchar c[210][210];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nbool used[210][210];\n\nbool in(int x, int y){\n    return 0<=x && x<h && 0<=y && y<w && c[x][y] != '#';\n}\n\nvector<vector<int>> bfs(vector<pii> &init){\n    vector<vector<int>> d(h, vector<int>(w, MAX));\n    queue<pii> que;\n    for(auto &p: init){\n        d[p.fi][p.se] = 0;\n        que.push(p);\n    }\n    while(!que.empty()){\n        int x, y;\n        tie(x, y) = que.front(); que.pop();\n        rep(i, 4){\n            int nx = x+dx[i], ny = y+dy[i];\n            if(in(nx, ny) && d[nx][ny] == MAX){\n                d[nx][ny] = d[x][y] + 1;\n                que.emplace(nx, ny);\n            }\n        }\n    }\n    return d;\n}\n\nvoid dfs(int x, int y){\n    if(used[x][y]) return;\n    used[x][y] = true;\n    rep(i, 4){\n        int nx = x+dx[i], ny=y+dy[i];\n        if(in(nx, ny)) dfs(nx, ny);\n    }\n}\n\nint main(){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h)rep(j, w){\n        scanf(\" %c\", &c[i][j]);\n        if(c[i][j] == '@') sx = i, sy = j;\n        if(c[i][j] == '%') gx = i, gy = j;\n    }\n    vector<pii> init;\n    init.emplace_back(sx, sy);\n    auto d_pr = bfs(init);\n    init.clear();\n    rep(i, h)rep(j, w)if(c[i][j] == '$') init.emplace_back(i, j);\n    auto d_sl = bfs(init);\n\n    rep(i, h)rep(j, w)if(d_pr[i][j] >= d_sl[i][j]) c[i][j] = '#';\n    rep(i, h)rep(j, w) used[i][j] = false;\n    dfs(sx, sy);\n    puts(used[gx][gy] ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct P{\n  int x,y,d;\n  P(int y,int x,int d):y(y),x(x),d(d){}\n};\nint main(){\n  int h,w;cin>>h>>w;\n  int pr=1<<28,so=1<<28,i,j,k;\n  char m[h+2][w+2];\n  memset(m,'#',sizeof(m));\n  P p=P(0,0,0);\n  vector<P> ss;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      cin>>m[i][j];\n      if(m[i][j]=='@') p.y=i,p.x=j,p.d=0;\n      if(m[i][j]=='$') ss.push_back(P(i,j,0));\n    }\n  }\n  queue<P> q;\n  bool used[h+2][w+2];\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  memset(used,0,sizeof(used));\n  q.push(p);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(m[p.y][p.x]=='%') {\n      pr=p.d;\n      break;\n    }\n    if(used[p.y][p.x]) continue;\n    used[p.y][p.x]=true;\n    for(k=0;k<4;k++){\n      if(m[p.y+ay[k]][p.x+ax[k]]!='#'&&!used[p.y+ay[k]][p.x+ax[k]])\n\tq.push(P(p.y+ay[k],p.x+ax[k],p.d+1));\n    }\n  }\n  while(!q.empty()) q.pop();\n  memset(used,0,sizeof(used));\n  for(i=0;i<ss.size();i++) q.push(ss[i]);\n  while(!q.empty()){\n    p=q.front();q.pop();\n    if(m[p.y][p.x]=='%') {\n      so=p.d;\n      break;\n    }\n    if(used[p.y][p.x]) continue;\n    used[p.y][p.x]=true;\n    for(k=0;k<4;k++){\n      if(m[p.y+ay[k]][p.x+ax[k]]!='#'&&!used[p.y+ay[k]][p.x+ax[k]])\n\tq.push(P(p.y+ay[k],p.x+ax[k],p.d+1));\n    }\n  }\n  //cout << pr << \" \" << so << endl;\n  cout << ((pr<so)?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#define N 205\nusing namespace std;\nqueue<int> Q;\nconst int dx[5]={1,-1,0,0},dy[5]={0,0,1,-1};\nint h,w,a[N][N],vis[N][N],x,y,ans,flag,cnt;\nchar ch;\nstruct he{\n\tint x,y,s;\n}q[N*N];\nint main(){\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tch=getchar();\n\t\t\twhile(!(ch=='.'||ch=='@'||ch=='%'||ch=='#'||ch=='$')) ch=getchar();\n\t\t\tif(ch=='.') a[i][j]=1;\n\t\t\tif(ch=='@') a[i][j]=2;\n\t\t\tif(ch=='%') a[i][j]=3,x=i,y=j;\n\t\t\tif(ch=='#') a[i][j]=4;\n\t\t\tif(ch=='$') a[i][j]=5;\n\t\t}\n\t}\n\tq[1].x=x;q[1].y=y;cnt=1;\n\tvis[x][y]=1;\n\tQ.push(1);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tint x0=q[u].x,y0=q[u].y;\n\t\tif(flag==1&&ans<=q[u].s) break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint x1=x0+dx[i];\n\t\t\tint y1=y0+dy[i];\n\t\t\tif(x1<1||x1>h||y1<1||y1>w) continue;\n\t\t\tif(a[x1][y1]==4||vis[x1][y1]) continue;\n\t\t\tif(a[x1][y1]==5){flag=-1;break;}\n\t\t\tif(a[x1][y1]==2) {flag=1;ans=q[u].s+1;}\n\t\t\tq[++cnt].x=x1;q[cnt].y=y1;\n\t\t\tvis[x1][y1]=1;\n\t\t\tq[cnt].s=q[u].s+1;\n\t\t\tQ.push(cnt);\n\t\t}\n\t\tif(flag==-1) break;\n\t}\n\tif(flag==1) printf(\"Yes\\n\");else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define set(x,y) memset(x,y,sizeof(x))\n#define scan(x) scanf(\"%d\",&x)\n#define For(x,y,z)  for(int x=y;x<=z;x++)\nusing namespace std;\nconst int MAXN = 210;\nint maps[202][202];\nint fx,fy;\nint stx,sty;\nbool vis[MAXN][MAXN];\nbool visited[202][202];\nint index;\nint dis[MAXN][MAXN];\npair<int, int > a[4004];\n\ntypedef struct Node{\nint x,y,step;\nNode(int xx,int yy,int ss):x(xx),y(yy),step(ss){};\n}Node;\n int m,n;\nint dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint BFS(int Stx,int Sty)\n{\n    queue<Node>q;\n    set(vis,0);\n\n    q.push(Node(Stx,Sty,0));\n    vis[Stx][Sty]=1;\n    while(!q.empty())\n    {\n       Node s=q.front();\n\n        if(s.x==fx&&s.y==fy)\n            return s.step;\n        for(int i=0;i<4;i++)\n        {\n            int x=s.x+dir[i][0];\n            int y=s.y+dir[i][1];\n            if(x>=1&&x<=m&&y>=1&&y<=n&&(!maps[x][y]))\n            {\n                q.push(Node(x,y,s.step+1));\n                vis[x][y]=1;\n            }\n        }\n        q.pop();\n    }\n    return -1;\n}\nint main()\n{\n\n    cin>>m>>n;\n    char s[205];\n    for(int i=1;i<=m;i++)\n    {\n        cin>>s;\n        for(int j=0;j<n;j++)\n        {\n            if(s[j]=='.')\n                maps[i][j+1]=0;\n            else if(s[j]=='#')\n                maps[i][j+1]=1;\n            else if(s[j]=='%')\n            {\n                fx=i;\n                fy=j+1;\n            }\n            else if(s[j]=='@')\n            {\n                stx=i;\n                sty=j+1;\n\n            }\n            else if(s[j]=='$')\n            {\n                index++;\n                 maps[i][j+1]=1;\n                a[index].first=i;\n                a[index].second=j+1;\n\n            }\n        }\n    }\n    int maxn=BFS(stx,sty);\n   //cout<<\"公主的最短路\"<<maxn<<endl;\n    int ans=99999;\n    for(int i=1;i<=index;i++)\n    {\n        ans=min(ans,BFS(a[i].first,a[i].second));\n    }\n    if(ans>maxn&&maxn>=0)\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<string>\n#include<ctype.h>\n#include<math.h>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nvoid fre() { freopen(\"c://test//input.in\", \"r\", stdin); freopen(\"c://test//output.out\", \"w\", stdout); }\n#define MS(x, y) memset(x, y, sizeof(x))\n#define ls o<<1\n#define rs o<<1|1\ntypedef long long LL;\ntypedef unsigned long long UL;\ntypedef unsigned int UI;\ntemplate <class T1, class T2>inline void gmax(T1 &a, T2 b) { if (b > a)a = b; }\ntemplate <class T1, class T2>inline void gmin(T1 &a, T2 b) { if (b < a)a = b; }\nconst int N = 205, M = 0, Z = 1e9 + 7, inf = 0x3f3f3f3f;\ntemplate <class T1, class T2>inline void gadd(T1 &a, T2 b) { a = (a + b) % Z; }\nint casenum, casei;\nint n, m;\nchar s[N][N];\nstruct Q\n{\n\tint y, x;\n}q[N * N];\nint h, t;\nint f[N][N];\n\nvoid inq(int y, int x, int step)\n{\n\tif (y > n || y < 1 || x > m || x < 1)return;\n\tif (step >= f[y][x])return;\n\tf[y][x] = step;\n\tq[t++] = { y,x };\n}\nconst int dy[4] = { -1,0,0,1 };\nconst int dx[4] = { 0,-1,1,0 };\nint edy, edx;\nint bfs()\n{\n\twhile (h < t)\n\t{\n\t\tint y = q[h].y;\n\t\tint x = q[h++].x;\n\t\tfor (int k = 0; k < 4; ++k)\n\t\t{\n\t\t\tinq(y + dy[k], x + dx[k], f[y][x] + 1);\n\t\t}\n\t}\n\treturn f[edy][edx];\n}\n\nint main()\n{\n\twhile(~scanf(\"%d%d\", &n, &m))\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%s\", s[i] + 1);\n\t\t}\n\n\t\tMS(f, 63);\n\t\th = t = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t{\n\t\t\t\tif (s[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tinq(i, j, 0);\n\t\t\t\t}\n\t\t\t\telse if (s[i][j] == '%')\n\t\t\t\t{\n\t\t\t\t\tedy = i;\n\t\t\t\t\tedx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dis1 = bfs();\n\n\t\tMS(f, 63);\n\t\th = t = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t{\n\t\t\t\tif (s[i][j] == '$')\n\t\t\t\t{\n\t\t\t\t\tinq(i, j, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dis2 = bfs();\n\n\t\tif (dis1 < dis2)\n\t\t{\n\t\t\tputs(\"Yes\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"No\");\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n【trick&&吐槽】\n\n\n【?意】\n\n\n【分析】\n\n\n【????度&&?化】\n\n\n【数据】\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 205;\n\nchar mat[N][N];\nint endx, endy;\n\nstruct State\n{\n    int x;\n    int y;\n    int depth;\n    \n};\n\nint dirx[] = {0,0,1,-1};\nint diry[] = {1,-1,0,0};\nint vis[N][N];\n\nint search(int sx,int sy){\n    memset(vis,0,sizeof(vis));\n    queue<State> q;\n    State start;\n    start.x = sx;\n    start.y = sy;\n    start.depth = 0;\n    q.push(start);\n    while(!q.empty()){\n        State tmp = q.front();\n        q.pop();\n        //printf(\"%d %d \\n\",tmp.x,tmp.y );\n        if(vis[tmp.x][tmp.y]){\n            continue;\n        }else{\n            vis[tmp.x][tmp.y] = true;\n        }\n\n        if(tmp.x == endx && tmp.y == endy){\n            return tmp.depth;\n        }\n\n        for(int i=0;i<4;i++){\n            State next;\n            next.x = tmp.x+dirx[i];\n            next.y = tmp.y+diry[i];\n            next.depth = tmp.depth+1;\n            char now_char = mat[next.x][next.y];\n            if(now_char=='.' ||  now_char=='$' ||  now_char=='%'||  now_char=='@'){\n                q.push(next);\n            }\n        }\n    }\n    return INT_MAX;\n}\n\nint main() {\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    getchar();\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            scanf(\"%c\",&mat[i][j]);\n            if(mat[i][j]=='%'){\n                endx=i;\n                endy=j;\n            }\n        }\n        getchar();\n    }\n    int success_len;\n    int fail_len=INT_MAX;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            if(mat[i][j]=='@'){\n                success_len = search(i,j);\n                //printf(\"success:%d\\n\",success_len );\n            }else if(mat[i][j] == '$'){\n                fail_len = min(fail_len,search(i,j));\n                //printf(\"fail:%d\\n\",fail_len);\n            }\n        }\n    }\n    if(success_len<fail_len){\n        puts(\"Yes\");\n    }else{\n        puts(\"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> v(h);\n\tvi x, y;\n\tREP(i, h)cin >> v[i];\n\tint sx, sy, tx, ty;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (v[i][j] == '@') {\n\t\t\t\tsy = i; sx = j;\n\t\t\t}\n\t\t\telse if (v[i][j] == '$') {\n\t\t\t\ty.push_back(i); x.push_back(j);\n\t\t\t}\n\t\t\telse if (v[i][j] == '%') {\n\t\t\t\tty = i; tx = j;\n\t\t\t}\n\t\t}\n\t}\n\tint n = x.size();\n\tvvi mp(h, vi(w, INF));\n\tmp[sy][sx] = 0;\n\tqueue<pii> q;\n\tq.push({ sx,sy });\n\twhile (!q.empty()) {\n\t\tpii p = q.front(); q.pop();\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx]!='#'&&mp[ny][nx]==INF) {\n\t\t\t\tmp[ny][nx] = mp[p.second][p.first] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tvvi ms(h, vi(w, INF));\n\tREP(i, n) {\n\t//\tint cnt = 0;\n\t\tvvi tmp(h, vi(w, INF));\n\t\tq.push({ x[i],y[i] });\n\t\ttmp[y[i]][x[i]] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpii p = q.front(); q.pop();\n\t\t\tif (ms[p.second][p.first] <= tmp[p.second][p.first])continue;\n\t\t\tms[p.second][p.first] = min(ms[p.second][p.first], tmp[p.second][p.first]);\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = p.first + dx[i * 2], ny = p.second + dy[i * 2];\n\t\t\t\tif (nx >= 0 && ny >= 0 && ny < h&&nx < w&&v[ny][nx] != '#'&&tmp[ny][nx]==INF) {\n\t\t\t\t\ttmp[ny][nx] = tmp[p.second][p.first] + 1;\n\t\t\n\t\t\t\t\tq.push({ nx,ny });\n\t\t\t\t\t//cout << cnt <<\" \"<<nx<<\" \"<<ny<< endl;\n\t\t\t\t\t//cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tif (ms[ty][tx] > mp[ty][tx])cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint H, W;\nint ey, ex;\nchar maps[201][201];\n\nint bfs1() {\n  bool used[201][201] = {{0}};\n  queue<Pip> q;\n  q.push(Pip(0, Pii(ey, ex)));\n  while ( !q.empty() ) {\n    Pip p = q.front(); q.pop();\n    int c = p.fr,  y = p.sc.fr, x = p.sc.sc;    \n\n    if ( maps[y][x] == '@' ) {\n      return c;\n    }\n\n    if ( used[y][x] ) continue;\n    used[y][x] = true;\n\n    Rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if ( ny < 0 || nx < 0 || ny >= H || nx >= W || maps[ny][nx] == '#' || maps[ny][nx] == '$' ) continue;\n      q.push(Pip(c+1, Pii(ny, nx)));\n    }\n  }\n\n  return INF;\n}\n\nint bfs2() {\n  bool used[201][201] = {{0}};\n  queue<Pip> q;\n  q.push(Pip(0, Pii(ey, ex)));\n  while ( !q.empty() ) {\n    Pip p = q.front(); q.pop();\n    int c = p.fr,  y = p.sc.fr, x = p.sc.sc;    \n\n    if ( maps[y][x] == '$' ) {\n      return c;\n    }\n\n    if ( used[y][x] ) continue;\n    used[y][x] = true;\n\n    Rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if ( ny < 0 || nx < 0 || ny >= H || nx >= W || maps[ny][nx] == '#' ) continue;\n      q.push(Pip(c+1, Pii(ny, nx)));\n    }\n  }\n\n  return INF;\n}\n\nsigned main() {\n  cin >> H >> W;\n  Rep(i, H) Rep(j, W) {\n    cin >> maps[i][j];\n    if ( maps[i][j] == '%' ) ey = i, ex = j;\n  }\n\n  if ( bfs1() < bfs2() ) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nint main(void) {\n    int i,j;\n    int h,w;\n    cin >> h >> w;\n    vs s(h);\n    rep(i,h)cin >> s[i];\n    int dist[200][200];\n    rep(i,h)rep(j,w)dist[i][j] = INF;\n    rep(sx,h)rep(sy,w) if(s[sx][sy] =='%'){\n        dist[sx][sy] = 0;\n        queue<pii> q;\n        q.push(pii(sx,sy));\n        vi ans(2,INF);\n        while(q.size()){\n            int x = q.front().first;\n            int y = q.front().second;\n            if(s[x][y] == '@' || s[x][y] == '$'){\n                ans[s[x][y]=='@'] = min(ans[s[x][y]=='@'], dist[x][y]);\n            }\n            q.pop();\n            rep(i,4){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 > nx || 0 > ny || nx >= h || ny >= w)continue;\n                if(s[nx][ny] == '#')continue;\n                if(dist[nx][ny] > dist[x][y] + 1){\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push(pii(nx,ny));\n                }\n            }\n        }\n        if(ans[1] < ans[0]) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n        break;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint H,W;\nint exx=-1,exy=-1;\nstruct graph\n{\n    int E[230][230];\n};\ngraph ori;\nvoid graph_clr(graph &k)\n{\n    for(int i=0;i<H+2;i++)\n        for(int j=0;j<W+2;j++)\n        k.E[i][j]=0;\n}\nstruct S\n{\n    int x,y;\n    graph dfs;\n};\nvector<S> SV;\nS princess;\nvoid read()\n{\n    char t;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n    {\n        cin>>t;\n        ori.E[i][j]=t;\n        if(t=='$')\n        {\n            S st;\n        graph_clr(st.dfs);\n        st.x=i;st.y=j;\n        SV.push_back(st);\n        }\n        else if(t=='@')\n        {\n            graph_clr(princess.dfs);\n            princess.x=i;\n            princess.y=j;\n        }\n        else if(t=='%')\n        {\n            exx=i;exy=j;\n        }\n    }\n}\nvoid Sdfs(S &t,int step,int x,int y)\n{\n    if(ori.E[x][y]=='#')return;\n    if(x<0||y<0||x>H-1||y>W-1)return;\n    //if(t.dfs.E[x][y]!=0)return;\n    if(x==t.x&&y==t.y&&step!=0)return;\n\n    //if(t.dfs.E[exx][exy])return;\n\n    if(t.dfs.E[x][y]==0||t.dfs.E[x][y]>step)\n    t.dfs.E[x][y]=step;\n    else return;\n    Sdfs(t,step+1,x+1,y);\n    Sdfs(t,step+1,x-1,y);\n    Sdfs(t,step+1,x,y+1);\n    Sdfs(t,step+1,x,y-1);\n}\n/*void Pdfs(S &t,int step,int x,int y)\n{\n    if(ori.E[x][y]=='#')return;\n    if(x<0||y<0||x>H-1||y>W-1)return;\n    //if(t.dfs.E[x][y]!=0)return;\n    if(x==t.x&&y==t.y&&step!=0)return;\n    if(t.dfs.E[x][y]==0||t.dfs.E[x][y]>step)\n    t.dfs.E[x][y]=step;\n    else return;\n    Sdfs(t,step+1,x+1,y);\n    Sdfs(t,step+1,x-1,y);\n    Sdfs(t,step+1,x,y+1);\n    Sdfs(t,step+1,x,y-1);\n}*/\nvoid showG(graph &k)\n{\n        for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++)\n            {cout<<k.E[i][j]<<' ';}\n            cout<<endl;\n        }\n        cout<<endl;\n}\nbool pre1()\n{\n    Sdfs(princess,0,princess.x,princess.y);\n    for(int t=0;t<SV.size();t++)\n    {\n        Sdfs(SV[t],0,SV[t].x,SV[t].y);\n        if(SV[t].dfs.E[exx][exy]<=princess.dfs.E[exx][exy])\n        {\n            //showG(SV[t].dfs);\n            //showG(princess.dfs);\n            return 0;\n        }\n        //showG(SV[t].dfs);\n    }\n    return 1;\n    //showG(princess.dfs);\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    read();\n    cout<<(pre1()?\"Yes\":\"No\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    memset(dis, -1, sizeof(dis));\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\n\nstruct state {\n  int y, x, d;\n  bool operator<(const state &s) const {\n    return d > s.d;\n  }\n};\n\nint H, W, SY, SX;\nchar S[300][300];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool visited[300][300];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  cin >> H >> W;\n  REP(i, 0, H) REP(j, 0, W) {\n    cin >> S[i][j];\n    if(S[i][j] == '%') {\n      SY = i;\n      SX = j;\n    }\n  }\n\n  REP(i, 0, H) REP(j, 0, W) visited[i][j] = false;\n  queue<state> q;\n  q.push((state) { SY, SX, 0 });\n\n  int d1 = INF, d2 = INF;\n  while(q.size()) {\n    state c = q.front();\n    q.pop();\n    if(visited[c.y][c.x]) continue;\n    visited[c.y][c.x] = true;\n    if(S[c.y][c.x] == '@') {\n      d1 = c.d;\n    }\n    if(S[c.y][c.x] == '$') {\n      d2 = min(d2, c.d);\n    }\n    REP(i, 0, 4) {\n      int ny = c.y + dd[i], nx = c.x + dd[i + 1];\n      if(isin(ny, nx) && S[ny][nx] != '#' && !visited[ny][nx]) {\n        q.push((state) { ny, nx, c.d + 1 });\n      }\n    }\n  }\n  cout << (d1 < d2 ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF (1<<29)\n \nint H, W;\nchar f[200][200];\n  \nint bfs(queue<int>& px, queue<int>& py, int gx, int gy)\n{\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    auto qx = px, qy = py;\n    while (!px.empty()) {\n        int x = px.front(), y = py.front();\n        px.pop(); py.pop();\n        d[y][x] = 0;\n    }\n    const int dx[] = {-1, +1, +0, +0}, dy[] = {+0, +0, -1, +1};\n    while (!qx.empty()) {\n        int x = qx.front(), y = qy.front();\n        qx.pop(); qy.pop();\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (0 <= nx && nx < W && 0 <= ny && ny < H &&\n                f[ny][nx]=='.') {                \n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    qx.push(nx); qy.push(ny);\n                }\n            }\n        }\n    }\n    return d[gy][gx];\n}\n  \nint main()\n{\n    int gx, gy;\n    cin >> H >> W;\n    queue<int> ax, ay, bx, by;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0 ; j < W; j++) {\n            cin >> f[i][j];\n            if (f[i][j] == '@') {\n                f[i][j] = '.';\n                ax.push(j); ay.push(i);\n            } else if (f[i][j] == '$') {\n                f[i][j] = '.';\n                bx.push(j); by.push(i);\n            } else if (f[i][j] == '%') {\n                f[i][j] = '.';\n                gx = j; gy = i;\n            }\n        }\n    }\n    cout << (bfs(ax, ay, gx, gy) < bfs(bx, by, gx, gy) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    rep(i,N) rep(j,N) dis[i][j] = INF;\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == INF && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n        }\n    }\n    if(p < s) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint dist[205][205];\nint x[205][205];bool y[205][205];\nint main(){\n\tint h,w;cin>>h>>w;int gx=0,gy=0,sx=0,sy=0;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tchar B;cin>>B;\n\t\t\tif(B=='%'){gx=i;gy=j;x[i][j]=1;}\n\t\t\tif(B=='$'){x[i][j]=1;y[i][j]=true;}\n\t\t\tif(B=='@'){sx=i;sy=j;x[i][j]=1;}\n\t\t\tif(B=='.'){x[i][j]=1;}\n\t\t}\n\t}\n\tfor(int i=0;i<205*205;i++)dist[i/205][i%205]=114514;\n\tqueue<pair<int,int>>Q;Q.push(make_pair(gx,gy));dist[gx][gy]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front().first,a2=Q.front().second;Q.pop();\n\t\tint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=a1+dx[i],cy=a2+dy[i];\n\t\t\tif(x[cx][cy]==0)continue;\n\t\t\tif(dist[cx][cy]>dist[a1][a2]+1){\n\t\t\t\tdist[cx][cy]=dist[a1][a2]+1;\n\t\t\t\tQ.push(make_pair(cx,cy));\n\t\t\t}\n\t\t}\n\t}\n\tint minx=114514;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(y[i][j]==true)minx=min(minx,dist[i][j]);\n\t\t}\n\t}\n\tif(dist[sx][sy]<minx)cout<<\"Yes\"<<endl;\n\telse{cout<<\"No\"<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \nint dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvector <string> board;\nvvb used;\nint x, y;\n\nbool solve(int a, int b);\n\nsigned main()\n{\n    cin >> x >> y;\n    board.assign(x, \"\");\n\n    rep(i, x) {\n        cin >> board[i];\n    }\n\n    bool ret;\n    rep(i, x) {\n        rep(j, y) {\n            if (board[i][j] == '%') {\n                ret = solve(i, j);\n            }\n        }\n    }\n\n    cout << ( (ret) ? \"Yes\" : \"No\" ) << endl;\n\n    return 0;\n}\n\nbool solve(int a, int b)\n{\n    queue< i_i > q;\n    q.push(i_i(a, b));\n    used.assign(x, vb(y, false));\n    used[a][b] = true;\n    bool ret = true, stop = false;\n\n    while (!q.empty()) {\n        queue <i_i> nxt;\n        while (!q.empty()) {\n            int c = q.front().first, d = q.front().second;\n            q.pop();\n            rep(i, 4) {\n                int nx = c + dxy[i], ny = d + dxy[i+1];\n                if (nx < 0 || ny < 0 || x <= nx || y <= ny\n                        || used[nx][ny] ) {\n                    continue;\n                }\n                if (board[nx][ny] == '.') {\n                    nxt.push(i_i(nx, ny));\n                } else if (board[nx][ny] == '$') {\n                    ret = false;\n                    stop = true;\n                } else if (board[nx][ny] == '@') {\n                    stop = true;\n                } \n                used[nx][ny] = true;\n            }\n        }\n        if (stop) { return ret; }\n        q = nxt;\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state {\n  int y, x, d;\n  bool operator<(const state &s) const {\n    return d > s.d;\n  }\n};\n\nint H, W, SY, SX;\nchar S[300][300];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool visited[300][300];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  cin >> H >> W;\n  REP(i, 0, H) REP(j, 0, W) {\n    cin >> S[i][j];\n    if(S[i][j] == '%') {\n      SY = i;\n      SX = j;\n    }\n  }\n\n  REP(i, 0, H) REP(j, 0, W) visited[i][j] = false;\n  queue<state> q;\n  q.push((state) { SY, SX, 0 });\n\n  while(q.size()) {\n    state c = q.front();\n    q.pop();\n    if(visited[c.y][c.x]) continue;\n    visited[c.y][c.x] = true;\n    if(S[c.y][c.x] == '@') {\n      cout << \"Yes\" << endl;\n      break;\n    }\n    if(S[c.y][c.x] == '$') {\n      cout << \"No\" << endl;\n      break;\n    }\n    REP(i, 0, 4) {\n      if(isin(c.y + dd[i], c.x + dd[i + 1]) && S[c.y + dd[i]][c.x + dd[i + 1]] != '#' && !visited[c.y + dd[i]][c.x + dd[i + 1]]) {\n        q.push((state) { c.y + dd[i], c.x + dd[i + 1], c.d + 1 });\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \nint dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvector <string> board;\nvvb used;\nint x, y;\n\nint solve(int a, int b);\n\nsigned main()\n{\n    cin >> x >> y;\n    board.assign(x, \"\");\n\n    rep(i, x) {\n        cin >> board[i];\n    }\n\n    int pr = 0;\n    rep(i, x) {\n        rep(j, y) {\n            if (board[i][j] == '@') {\n                pr = solve(i, j);\n            }\n        }\n    }\n\n    bool ret = true;\n    rep(i, x) {\n        rep(j, y) {\n            if (board[i][j] == '$') {\n                if (solve(i, j) <= pr) {\n                    ret = false;\n                    break;\n                }\n            }\n        }\n    }\n    cout << ( (ret) ? \"Yes\" : \"No\" ) << endl;\n\n    return 0;\n}\n\nint solve(int a, int b)\n{\n    queue< i_i > q;\n    q.push(i_i(a, b));\n    used.assign(x, vb(y, false));\n    used[a][b] = true;\n    int ret = 0;\n\n    while (!q.empty()) {\n        ret++;\n        queue <i_i> nxt;\n        while (!q.empty()) {\n            int c = q.front().first, d = q.front().second;\n            q.pop();\n            rep(i, 4) {\n                int nx = c + dxy[i], ny = d + dxy[i+1];\n                if (nx < 0 || ny < 0 || x <= nx || y <= ny\n                        || used[nx][ny] ) {\n                    continue;\n                }\n                if (board[nx][ny] == '.') {\n                    nxt.push(i_i(nx, ny));\n                } else if (board[nx][ny] == '$') {\n                    nxt.push(i_i(nx, ny));\n                } else if (board[nx][ny] == '@') {\n                    nxt.push(i_i(nx, ny));\n                } else if (board[nx][ny] == '%') {\n                    return ret;\n                }\n                used[nx][ny] = true;\n            }\n        }\n        q = nxt;\n    }\n    return INF;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define SF scanf\n#define PF printf\n#define PB push_back\n#define MP make_pair\n#define mx 5000001\n#define MOD 1000000007\n#define INP          freopen(\"in.txt\", \"r\", stdin);\n#define OUT          freopen(\"out.txt\", \"w\", stdout);\n#define BOOST        std::ios_base::sync_with_stdio(false);\n\nchar st[210][210];\nint vis[210][210];\nint sz1,sz2,ns,mm;\nqueue<pair<int,int> >pq;\nqueue<pair<int,int> >pq2;\nint fx[]={1,-1,0,0};\nint fy[]={0,0,1,-1};\nint level[210][210];\nint lev[210][210];\nvoid bfs2()\n{\n\n    pair<int,int>pp;\n\n    pp=pq2.front();\n    int x=pp.first;\n    int y=pp.second;\n    lev[x][y]=0;\n    vis[x][y]=1;\n    while(!pq2.empty())\n    {\n        pp=pq2.front();\n        pq2.pop();\n        int p1=pp.first;\n        int p2=pp.second;\n        for(int p=0;p<4;p++)\n        {\n            int x=p1+fx[p];\n            int y=p2+fy[p];\n            if(x>0&&x<=sz1&&y>0&&y<=sz2&&vis[x][y]==0&&(st[x][y]=='.'||st[x][y]=='%'))\n            {\n\n                pq2.push(MP(x,y));\n                lev[x][y]=lev[p1][p2]+1;\n                vis[x][y]=1;\n            }\n\n\n        }\n    }\n}\n\nvoid bfs3(int i,int j)\n{\n    level[i][j]=0;\n    pair<int,int>pp;\n    vis[i][j]=1;\n    pq.push(MP(i,j));\n    while(!pq.empty())\n    {\n        pp=pq.front();\n        pq.pop();\n        int p1=pp.first;\n        int p2=pp.second;\n        for(int p=0;p<4;p++)\n        {\n            int x=p1+fx[p];\n            int y=p2+fy[p];\n            if(x>0&&x<=sz1&&y>0&&y<=sz2&&vis[x][y]==0&&(st[x][y]=='.'||st[x][y]=='%'))\n            {\n\n\n                level[x][y]=lg\u0016el[p1][p2]+1;\n                if(level[x][y]<lev[x][y]||lev[x][y]==0)\n                {\n                    pq.push(MP(x,y));\n                    vis[x][y]=1;\n                }\n\n            }\n\n\n        }\n    }\n}\nint main()\n{\n\n\n    ll n,t,i,j,n1,k,m,f=0,s=0,c=0,p=1,c1=0,p1=0,p2=0,res=0,c2,s1,s2,ss,pp,x,y,q;\n    string st1,st2;\n   // SF(\"%lld\",&n);\n\n\n    cin>>sz1>>sz2;\n    ns=1000000;\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            cin>>st[i][j];\n            if(st[i][j]=='%')\n            {\n                x=i,y=j;\n            }\n        }\n    }\n    memset(vis,0,sizeof(vis));\n    memset(lev,0,sizeof(lev));\n    memset(level,0,sizeof(level));\n\n\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            if(st[i][j]=='$')\n            {\n                pq2.push(MP(i,j));\n            }\n\n        }\n    }\n    if(!pq2.empty())\n    bfs2();\n    memset(vis,0,sizeof(vis));\n    memset(level,0,sizeof(level));\n    for(i=1;i<=sz1;i++)\n    {\n        for(j=1;j<=sz2;j++)\n        {\n            if(st[i][j]=='@')\n            {\n                bfs3(i,j);\n            }\n\n        }\n    }\n    if(level[x][y]==0||(lev[x][y]!=0&&lev[x][y]<=level[x][y]))\n    {\n        //cout<<level[x][y]<<\" \"<<lev[x][y]<<endl;\n        cout<<\"No\"<<endl;\n\n    }\n    else\n    {\n        //cout<<level[x][y]<<\" \"<<lev[x][y]<<endl;\n        cout<<\"Yes\"<<endl;\n    }\n\n\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4]={1, 0, 0, -1};\nint dy[4]={0, 1, -1, 0};\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  int sx,sy;\n  vector<vector<char> > map(h+2, vector<char>(w+2, '#'));\n  for(int i=1; i<=h; i++){\n    for(int j=1; j<=w; j++){\n      cin >> map[i][j];\n      if(map[i][j]=='%'){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n\n  queue<pair<int,pair<int,int> > > q;\n  q.push(make_pair(0, make_pair(sy,sx)));\n  int princess=1e9;\n  int soldier=1e9;\n  while(!q.empty()){\n    int step=q.front().first;\n    int y=q.front().second.first;\n    int x=q.front().second.second;\n    q.pop();\n    if(map[y][x]=='@'){\n      princess = step;\n    }\n    if(map[y][x]=='$'){\n      soldier = step;\n    }\n    map[y][x]='#';\n\n    for(int i=0; i<4; i++){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(map[ny][nx]!='#'){\n        q.push(make_pair(step+1, make_pair(ny,nx)));\n      }\n    }\n  }\n\n  if(princess<soldier){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <cstdio>\n#define INF 999999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s,\n    vector<Weight> &dist, vector<int> &prev) {\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, -1);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    for(auto &f:g[e.dst]) {\n      if (dist[f.dst] > e.weight+f.weight) {\n        dist[f.dst] = e.weight+f.weight;\n        Q.push(Edge(f.src, f.dst, e.weight+f.weight));\n      }\n    }\n  }\n}\n\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<string>v(H);\n\tfor(int i=0;i<H;i++)cin>>v[i];\n\tvector<int>soldiers;\n\tint start,princess=-1;\n\tGraph g(H*W);\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++){\n\t\tif(v[i][j]=='#')continue;\n\t\tint x=i*W+j,y,f;\n\t\tif(v[i][j]=='%')start=x;\n\t\tif(v[i][j]=='@')princess=x;\n\t\tif(v[i][j]=='$')soldiers.push_back(x);\n\t\tif(i<H-1){\n\t\t\ty=(i+1)*W+j;\n\t\t\tif(v[i+1][j]!='#')g[x].push_back(Edge(x,y,1)),g[y].push_back(Edge(y,x,1));\n\t\t}\n\t\tif(j<W-1){\n\t\t\ty=i*W+j+1;\n\t\t\tif(v[i][j+1]!='#')g[x].push_back(Edge(x,y,1)),g[y].push_back(Edge(y,x,1));\n\t\t}\n\t}\n\tvector<Weight> dist;\n\tvector<int> prev;\n\tshortestPath(g,start,dist,prev);\n\tWeight sol=INF;\n\tfor(int e:soldiers)sol=min(sol,dist[e]);\n\tputs(dist[princess]<sol ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int INF = numeric_limits<int>::max() / 2;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int h,w;cin>>h>>w;\n    vector<string> v(h);\n    int sx,sy,px,py;\n    for(int i=0;i<h;i++){\n        cin>>v[i];\n        for(int j=0;j<w;j++){\n            if(v[i][j]=='%'){\n                sx=i;sy=j;\n            }\n            else if(v[i][j]=='@'){\n                px=i;py=j;\n            }\n        }\n    }\n    vector<vector<int> > dis(300,vector<int>(300,INF));\n    dis[sx][sy]=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n    queue<P> q;\n    q.push(P(sx,sy));\n    while(!q.empty()){\n        P p=q.front();q.pop();\n        int x=p.first,y=p.second;\n        for(int i=0;i<4;i++){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx<0 || h<=nx || ny<0 || w<=ny) continue;\n            if(v[nx][ny]=='#') continue;\n            if(dis[nx][ny]!=INF) continue;\n            dis[nx][ny]=dis[x][y]+1;\n            q.push(P(nx,ny));\n        }\n    }\n    int pdis=dis[px][py];\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(v[i][j]!='$') continue;\n            if(dis[i][j]<=pdis){\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint H, W;\nint sx, sy;\nvector<string> s;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nvector<vector<int>> bfs() {\n    queue<pair<int, int>> que;\n    que.emplace(sx, sy);\n    vector<vector<int>> d(H, vector<int>(W, inf));\n    d[sx][sy] = 0;\n\n    while (!que.empty()) {\n        int x, y;\n        tie(x, y) = que.front(); que.pop();\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (inside(nx, ny) && d[nx][ny] == inf) {\n                d[nx][ny] = d[x][y] + 1;\n                que.emplace(nx, ny);\n            }\n        }\n    }\n\n    return d;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> H >> W;\n    s.resize(H);\n    rep(i, H) cin >> s[i];\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '%') {\n                sx = i, sy = j;\n            }\n        }\n    }\n\n    auto d = bfs();\n    int princess;\n    int soldier = inf;\n    rep(i, H) {\n        rep(j, W) {\n            if (s[i][j] == '@') {\n                princess = d[i][j];\n            }\n            if (s[i][j] == '$') {\n                soldier = min(soldier, d[i][j]);\n            }\n        }\n    }\n\n    cout << (princess < soldier ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<string>\n#include<ctype.h>\n#include<math.h>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<algorithm>\n#include<time.h>\nusing namespace std;\nvoid fre() { freopen(\"c://test//input.in\", \"r\", stdin); freopen(\"c://test//output.out\", \"w\", stdout); }\n#define MS(x, y) memset(x, y, sizeof(x))\n#define ls o<<1\n#define rs o<<1|1\ntypedef long long LL;\ntypedef unsigned long long UL;\ntypedef unsigned int UI;\ntemplate <class T1, class T2>inline void gmax(T1 &a, T2 b) { if (b > a)a = b; }\ntemplate <class T1, class T2>inline void gmin(T1 &a, T2 b) { if (b < a)a = b; }\nconst int N = 205, M = 0, Z = 1e9 + 7, inf = 0x3f3f3f3f;\ntemplate <class T1, class T2>inline void gadd(T1 &a, T2 b) { a = (a + b) % Z; }\nint casenum, casei;\nint n, m;\nchar s[N][N];\nstruct Q\n{\n\tint y, x;\n}q[N * N];\nint h, t;\nint f[N][N];\n\nvoid inq(int y, int x, int step)\n{\n\tif (y > n || y < 1 || x > m || x < 1 || s[y][x] == '#')return;\n\tif (step >= f[y][x])return;\n\tf[y][x] = step;\n\tq[t++] = { y,x };\n}\nconst int dy[4] = { -1,0,0,1 };\nconst int dx[4] = { 0,-1,1,0 };\nint edy, edx;\nint bfs()\n{\n\twhile (h < t)\n\t{\n\t\tint y = q[h].y;\n\t\tint x = q[h++].x;\n\t\tfor (int k = 0; k < 4; ++k)\n\t\t{\n\t\t\tinq(y + dy[k], x + dx[k], f[y][x] + 1);\n\t\t}\n\t}\n\treturn f[edy][edx];\n}\n\nint main()\n{\n\twhile(~scanf(\"%d%d\", &n, &m))\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%s\", s[i] + 1);\n\t\t}\n\n\t\tMS(f, 63);\n\t\th = t = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t{\n\t\t\t\tif (s[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tinq(i, j, 0);\n\t\t\t\t}\n\t\t\t\telse if (s[i][j] == '%')\n\t\t\t\t{\n\t\t\t\t\tedy = i;\n\t\t\t\t\tedx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dis1 = bfs();\n\n\t\tMS(f, 63);\n\t\th = t = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t{\n\t\t\t\tif (s[i][j] == '$')\n\t\t\t\t{\n\t\t\t\t\tinq(i, j, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dis2 = bfs();\n\n\t\tif (dis1 < dis2)\n\t\t{\n\t\t\tputs(\"Yes\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"No\");\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n【trick&&吐槽】\n\n\n【?意】\n\n\n【分析】\n\n\n【????度&&?化】\n\n\n【数据】\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> aa;\n\nchar s[210][210]; //地? \nint p[210][210];  //距? \nint k[210][210];  //到aa的映射 \nint t, x, y, x2, y2;      //士兵个数 公主坐? ?的坐? \nint h, w;\n\nvoid try1(int x, int y, int l)\n{\n\t//cout << x << \" \" << y << \" \" << l << endl;\n\tif (l >= 8) return;\n\tif (s[x][y] == '$' && aa[k[x][y]] > l)\n\t{\n\t\taa[k[x][y]] = l;\n\t}\n\tif (x - 1 >= 0 && s[x - 1][y] != '#' && l + 1 < p[x - 1][y])\n\t{\n\t\tp[x - 1][y] = l + 1;\n\t\ttry1(x - 1, y, l + 1);\n\t}\n\tif (x + 1 < h && s[x + 1][y] != '#' && l + 1 < p[x + 1][y])\n\t{\n\t\tp[x + 1][y] = l + 1;\n\t\ttry1(x + 1, y, l + 1);\n\t}\n\tif (y - 1 >= 0 && s[x][y - 1] != '#' && l + 1 < p[x][y - 1])\n\t{\n\t\tp[x][y - 1] = l + 1;\n\t\ttry1(x, y - 1, l + 1);\n\t}\n\tif (y + 1 < w && s[x][y + 1] != '#' && l + 1 < p[x][y + 1])\n\t{\n\t\tp[x][y + 1] = l + 1;\n\t\ttry1(x, y + 1, l + 1);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tint m = 80000;\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tcin >> s[i][j];\n\t\t\tif (s[i][j] == '@')\n\t\t\t{\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t\tif (s[i][j] == '$')\n\t\t    {\n\t\t    \taa.push_back(m);\n\t\t    \tk[i][j] = t;\n\t\t    \tt++;\n\t\t\t}\n\t\t\tif (s[i][j] == '%')\n\t\t\t{\n\t\t\t\tx2 = i;\n\t\t\t\ty2 = j;\n\t\t\t}\n\t\t\tp[i][j] = 80000;\n\t\t}\n\t\tgetchar();\n\t}\n\tif (t == 0)\n\t{\n\t\tcout << \"Yes\" << endl;\n\t\treturn 0;\n\t}\n\tp[x2][y2] = 0;\n\ttry1(x2, y2, 0);\n\tsort(aa.begin(), aa.end());\n\tif (aa[0] <= p[x][y])\n\t{\n\t\tcout << \"No\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int h, w; cin >> h >> w;\n    vector<string> field(h);\n    for(auto& e : field) cin >> e;\n\n    int sx, sy;\n    rep(y, h){\n        rep(x, w){\n            char c = field[y][x];\n            if(c == '%'){\n                sx = x, sy = y;\n            }\n        }\n    }\n\n    using Elem = tuple<int, int>;\n    queue<Elem> q;\n    q.push(Elem(sx, sy));\n    vector<vi> min_dist(h, vi(w, inf));\n    min_dist[sy][sx] = 0;\n    int pd = inf, sd = inf;\n    while(q.size()){\n        Elem cur = q.front(); q.pop();\n        int x, y; tie(x, y) = cur;\n\n        if(field[y][x] == '$'){\n            chmin(sd, min_dist[y][x]);\n        }\n        if(field[y][x] == '@'){\n            chmin(pd, min_dist[y][x]);\n        }\n\n        rep(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx < 0 or w <= nx or ny < 0 or h <= ny or field[ny][nx] == '#') continue;\n\n            if(chmin(min_dist[ny][nx], min_dist[y][x] + 1)){\n                q.push(Elem(nx, ny));\n            }\n        }\n    }\n\n    cout << (pd < sd ? \"Yes\":\"No\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\n#include <list>\nusing namespace std;\ntypedef long long ll;\nchar s[205][205];\nbool vis[205][205];\nbool visq[205][205];\nstruct aa\n{\n    int deep;\n    int x;\n    int y;\n};\nqueue<aa>p;\nqueue<aa>so;\nint dr[4] = {0,0,1,-1};\nint dc[4] = {-1,1,0,0};\nint n,m;\nbool judge(int x,int y)\n{\n    if(x < 0 || x >= n)return false;\n    if(y < 0 || y >= m)return false;\n    return true;\n}\nbool bfs()\n{\n    int deep = 0;\n    aa temp;\n    int tx,ty;\n    while(1)\n    {\n        while(!so.empty())\n        {\n            temp = so.front();\n            if(temp.deep != deep)\n            {\n                break;\n            }\n            so.pop();\n            for(int i = 0; i < 4; i ++)\n            {\n                tx = temp.x + dr[i];\n                ty = temp.y + dc[i];\n                if(judge(tx,ty) == true &&s[tx][ty] != '#'&& vis[tx][ty] == false)\n                {\n                    vis[tx][ty] = true;\n                    temp.x = tx,temp.y = ty,temp.deep += 1;\n                    if(s[temp.x][temp.y] == '%')return false;\n                    so.push(temp);\n                }\n            }\n        }\n        while(!p.empty())\n        {\n            temp = p.front();\n            if(temp.deep != deep)break;\n            p.pop();\n            for(int i = 0; i <4; i ++)\n            {\n                tx = temp.x + dr[i];\n                ty = temp.y + dc[i];\n                if(judge(tx,ty) == true &&s[tx][ty] != '#'&&visq[tx][ty] == false&& vis[tx][ty] == false)\n                {\n                    visq[tx][ty] = true;\n                    temp.x = tx,temp.y = ty,temp.deep += 1;\n                    if(s[temp.x][temp.y] == '%')return true;\n                    p.push(temp);\n                }\n            }\n        }\n        if(p.empty())return false;\n        deep ++;\n    }\n    return false;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 0; i < n; i ++)\n    {\n        scanf(\"%s\",&s[i]);\n    }\n    aa temp;\n    for(int i = 0; i < n; i ++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(s[i][j] == '@')\n            {\n                temp.x = i,temp.y =j,temp.deep = 0;\n                p.push(temp);\n                vis[i][j] = true;\n            }\n            else if(s[i][j] == '$')\n            {\n                temp.x = i,temp.y =j,temp.deep = 0;\n                so.push(temp);\n                visq[i][j] = true;\n            }\n        }\n    }\n    bool flag = bfs();\n    if(flag == true)\n    {\n        printf(\"Yes\\n\");\n    }\n    else\n    {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\n\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m;\nvs in;\nvvi d,dp;\nbool dfs(int a,int b,int c){\n\tif(dp[a][b]<c)return 0;\n\trep(i,4){\n\t\tint x=a+dx[i];\n\t\tint y=b+dy[i];\n\t\tif(x<0||y<0||x>=n||y>=m||in[x][y]=='#'||d[x][y]<=c+1||c+1>=dp[x][y])continue;\n\t\tif(in[x][y]=='%'){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t\treturn 1;\n\t\t}\n\t\tif(dfs(x,y,c+1))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vs(n);\n\trep(i,n)cin>>in[i];\n\tdp=vvi(n,vi(m,inf));\n\tpriority_queue<tp>que;\n\trep(i,n)rep(j,m)if(in[i][j]=='$'){\n\t\tque.push(tp(i,j,0));\n\t\tdp[i][j]=0;\n\t}\n\twhile(!que.empty()){\n\t\tint x,y,co;\n\t\ttie(x,y,co)=que.top();\n\t\tque.pop();\n\t\tif(dp[x][y]<co)continue;\n\t\trep(i,4){\n\t\t\tint nx=x+dx[i];\n\t\t\tint ny=y+dy[i];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#'||dp[nx][ny]<=co+1)continue;\n\t\t\tdp[nx][ny]=co+1;\n\t\t\tque.push(tp(nx,ny,co+1));\n\t\t}\n\t}\n\td=vvi(n,vi(m,inf));\n\trep(i,n)rep(j,m)if(in[i][j]=='@'){\n\t\td[i][j]=0;\n\t\tif(!dfs(i,j,0))cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y,z;\n};\nPoint operator-(const Point& a,const Point& b)\n{\n  Point ret={a.x-b.x,a.y-b.y,a.z-b.z};\n  return ret;\n}\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nPoint cross(Point a,Point b)\n{\n  Point ret={a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x};\n  return ret;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\nstring board[210];\nint H,W;\nint sx,sy;\nint gx,gy;\nint primin=inf;\nint solmin=inf;\nint d[210][210];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\ntypedef pair<int,int> P;\nvoid solve(int sy,int sx,char decide)\n{\n  queue<P> que;\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  que.push(P(sy,sx));\n  while(!que.empty())\n    {\n      P p=que.front();que.pop();\n      gy=p.first;\n      gx=p.second;\n      if(board[p.first][p.second]==decide) break;\n      for(int i=0;i<4;i++)\n\t{\n\t  int ny=p.first+dy[i];\n\t  int nx=p.second+dx[i];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#' || d[ny][nx]!=inf) continue;\n\t  que.push(P(ny,nx));\n\t  d[ny][nx]=d[p.first][p.second]+1;\n\t}\n    }\n  if(decide=='@') primin=min(primin,d[gy][gx]);\n  else if(decide=='$') solmin=min(solmin,d[gy][gx]);\n}\n\nint main(int argc,char const* argv[])\n{\n  cin >> H >> W;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  bool solex=false;\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='%')\n\t    {\n\t      sy=i,sx=j;\n\t    }\n\t  if(board[i][j]=='$') solex=true;\n\t}\n    }\n  solve(sy,sx,'@');\n  if(solex) solve(sy,sx,'$');\n  if(primin>=solmin){cout << \"No\" << endl;}\n  else{cout << \"Yes\" << endl;}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n/*\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2781\n\n????\\??????????????????????\n????????????????????????????\\???????????????§?????????????????????????????£???????????????????\\?????????????????????????????????????\n????????????????£???????????\\??????????????????????????????????????????????????????¢???????????????????????????????\\???????????????????\n?????????????????¨?????§??????????????????????±??????????????????°????????????????????¨??????\n\n ????´????????????????????????°???????????????????????¢????????£??????????????°?????????????????????????¨??????????????????????\n ???1??????????£?????\\????????????\\??§???????????????2?????????????£?????\\?????????\\????????¨?????§?????????????????????\n ???????????????????????????????????????????£???¨?????¶?????¨?????????????\\??????¨????£??????°?????£????????????????????????????????¨?????????\n ??°??????????????????????????????????????????????????????????????¨????????????????\\?????????????????????°???????????°???\n ????????¨????\\?????????????????????????????????¨?????§????????????????????????0?????\\??????????£?????????????\n\n ?\\??????¨??¨??????????£???????????????????????????????????????????????????????????????????????????°????\\??????¨????£????\n ??????????¬????????????????????????¨?????§???????????????????????????????\\??????¨????£?????°´?????\\??????????????´?????£??\\???????????????\n ?§?????????????????????????????????¨??????????????¨?????§??????????????????????\\??????¨????£??????????????????????????????¨?????§????????????\n ???????\\???????????????\\??????????????°???????£???????????????????????????£????????????????????¨?????£??????????\\?????????????????????????\n ?\\???????????????¨??????????£?????????????????????????????????????????????¨?????£???????????°??????????????°?????§???????????¨???????????§?????????\n\n ??????????£??????????????????????????????????????????£?????¨??????????\\????????????????????????¨?????§??????????????????????????¨????????°???\n ????????¨????\\???????????£?????????????????????¨?????§????????????????\\???????????£???????????????????????????°???????????¨????????°???\n ?\\?????????????????????¨?????§??????????\\?????????????????????????????????¨?????§????????????\n\n*/\ntypedef long long ll;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> masu(H + 2, vector<int>(W + 2, -1));\n\tint px, py;\n\tint hx, hy;\n\tvector<int> sx, sy;\n\t//initialize\n\tfor (int i = 1; i <= H;i++) {\n\t\tfor (int j = 1; j <= W;j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '%') {\n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\thx = i; hy = j;\n\t\t\t}\n\t\t\telse if (c == '.')masu[i][j] = 0;\n\t\t\telse if (c == '@') { \n\t\t\t\tmasu[i][j] = 0;\n\t\t\t\tpx = i; py = j;\n\t\t\t}\n\t\t\telse if (c == '$') sx.push_back(i), sy.push_back(j);\n\t\t}\n\t}\n\tvector<vector<int>> dist(H + 2, vector<int>(W + 2, (1 << 30)));\n\tqueue<pair<int, int>> q;\n\tq.push({ px,py });\n\tdist[px][py] = 0;\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second]+1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tint key = dist[hx][hy];\n\tdist = vector<vector<int>>(H + 2, vector<int>(W + 2, (1 << 30)));\n\tfor (int i = 0; i < sx.size();i++) {\n\t\tq.push({ sx[i],sy[i] });\n\t\tdist[sx[i]][sy[i]] = 0;\n\t}\n\twhile (!q.empty()) {\n\t\tauto n = q.front(); q.pop();\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint nx = n.first + dx[i], ny = n.second + dy[i];\n\t\t\tif (masu[nx][ny] == -1) continue;\n\t\t\tif (dist[nx][ny] > dist[n.first][n.second] + 1) {\n\t\t\t\tdist[nx][ny] = dist[n.first][n.second] + 1;\n\t\t\t\tq.push({ nx,ny });\n\t\t\t}\n\t\t}\n\t}\n\tcout << key << \" \" << dist[hx][hy] << endl;\n\tif (key >= dist[hx][hy]) {\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol,pri;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='$'){sol=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<h)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q1;\n  Q1.push(mk(mk(y,x),0));\n  while(!Q1.empty()){\n    pair<pair<int,int > ,int >a=Q1.front();Q1.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(s[yy][xx]=='@'){pri=a.second;break;}\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<h)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q1.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  if(pri<sol)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint h,w;\nstring s[200];\nbool used[200][200];\nbool nxt[200][200];\nbool ns[200][200];\nint d[]={0,1,0,-1,0};\nmain()\n{\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)used[i][j]=s[i][j]=='$';\n\twhile(1)\n\t{\n\t\tbool flag=false;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)ns[i][j]=nxt[i][j]=0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(!used[i][j])continue;\n\t\t\tnxt[i][j]=1;\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint x=i+d[r],y=j+d[r+1];\n\t\t\t\tif(x<0||x>=h||y<0||y>=w||s[x][y]=='#')continue;\n\t\t\t\tnxt[x][y]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)used[i][j]=nxt[i][j];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(s[i][j]!='@')continue;\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint x=i+d[r],y=j+d[r+1];\n\t\t\t\tif(x<0||x>=h||y<0||y>=w||s[x][y]=='#'||used[x][y])continue;\n\t\t\t\tif(s[x][y]=='%')\n\t\t\t\t{\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tns[x][y]=1;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t\tif(!used[i][j])ns[i][j]=1,flag=true;\n\t\t\ts[i][j]='.';\n\t\t}\n\t\tif(!flag)\n\t\t{\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)if(ns[i][j])s[i][j]='@';\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n\nint main(){\n  int H, W;\n  string m[200];\n  int dist[200][200];\n\n  cin >> H >> W;\n\n  queue<pair<int,int> > que, queP;\n\n  for (int i=0; i<H; i++) {\n    cin >> m[i];\n    for (int j=0; j<W; j++) {\n      if (m[i][j] == '$') que.push({i, j});\n      if (m[i][j] == '@') queP.push({i, j});\n      dist[i][j] = INF;\n    }\n  }\n\n  for(int i=0; que.size(); i++) {\n    queue<pair<int,int> > que2;\n\n    while(que.size()) {\n      auto p = que.front();\n      que.pop();\n      int y = p.first;\n      int x = p.second;\n\n      if (m[y][x] == '#') continue;\n      if (dist[y][x] < INF) continue;\n\n      dist[y][x] = i;\n\n      if (y > 0)   que2.push({y-1, x});\n      if (x > 0)   que2.push({y, x-1});\n      if (y+1 < H) que2.push({y+1, x});\n      if (x+1 < W) que2.push({y, x+1});\n    }\n\n    que = que2;\n  }\n\n  for(int i=0; queP.size(); i++) {\n    queue<pair<int,int> > que2;\n\n    while(queP.size()) {\n      auto p = queP.front();\n      queP.pop();\n      int y = p.first;\n      int x = p.second;\n\n      if (m[y][x] == '#') continue;\n      if (dist[y][x] <= i) continue;\n      dist[y][x] = -1;\n\n      if (m[y][x] == '%') {\n        puts(\"Yes\");\n        return 0;\n      }\n\n      if (y > 0)   que2.push({y-1, x});\n      if (x > 0)   que2.push({y, x-1});\n      if (y+1 < H) que2.push({y+1, x});\n      if (x+1 < W) que2.push({y, x+1});\n    }\n\n    queP = que2;\n  }\n\n\n  puts(\"No\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint dist[205][205];\nint x[205][205];bool y[205][205];\nint main(){\n\tint h,w;cin>>h>>w;int gx=0,gy=0,sx=0,sy=0;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tchar B;cin>>B;\n\t\t\tif(B=='%'){gx=i;gy=j;x[i][j]=1;}\n\t\t\tif(B=='$'){x[i][j]=1;y[i][j]=true;}\n\t\t\tif(B=='@'){sx=i;sy=j;x[i][j]=1;}\n\t\t\tif(B=='.'){x[i][j]=1;}\n\t\t}\n\t}\n\tfor(int i=0;i<205*205;i++)dist[i/205][i%205]=114514;\n\tqueue<pair<int,int>>Q;Q.push(make_pair(gx,gy));dist[gx][gy]=0;\n\twhile(!Q.empty()){\n\t\tint a1=Q.front().first,a2=Q.front().second;Q.pop();\n\t\tint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=a1+dx[i],cy=a2+dy[i];\n\t\t\tif(x[cx][cy]==0)continue;\n\t\t\tif(dist[cx][cy]>dist[a1][a2]+1){\n\t\t\t\tdist[cx][cy]=dist[a1][a2]+1;\n\t\t\t\tQ.push(make_pair(cx,cy));\n\t\t\t}\n\t\t}\n\t}\n\tint minx=114514;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(y[i][j]==true)minx=min(minx,dist[i][j]);\n\t\t}\n\t}\n\tif(dist[sx][sy]<minx)cout<<\"Yes\"<<endl;\n\telse{cout<<\"No\"<<endl;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 1e4;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n\tint x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n\tint temp;\n\t//printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n\t//labyrinth[y][x] = 3;\n\tvis[y][x] = true;\n\tif(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n\t{\n\t\tif(labyrinth[y][x-1] == goal)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x-1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n\t{\n\t\tif(labyrinth[y][x+1] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x+1,y,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n\t{\n\t\tif(labyrinth[y-1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y-1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\tif(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n\t{\n\t\tif(labyrinth[y+1][x] == 2)\n\t\t{\n\t\t\treturn cur_length+1;\n\t\t}\n\t\tif((temp = dfs(x,y+1,cur_length+1))<shortest)\n\t\t{\n\t\t\tshortest = temp;\n\t\t}\n\t}\n\treturn shortest;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t//freopen(\"1002.txt\",\"r\",stdin);\n\t//freopen(\"ans.txt\",\"w+\",stdout);\n\twhile(~scanf(\"%d%d\",&H,&W))\n\t{\n\t\ttf = true;\n\t\tscnt = 0;\n\t\tshortest = INF;\n\t\tmemset(labyrinth,-1,sizeof(labyrinth));\n\t\tgetchar();\n\t\tfor(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\twhile((ch = getchar())=='\\n');\n\t\t\t\tswitch(ch)\n\t\t\t\t{\n\t\t\t\tcase '@':\n\t\t\t\t\tprincess.x = j;\n\t\t\t\t\tprincess.y = i,labyrinth[i][j] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\tsoldier[scnt].x = j;\n\t\t\t\t\tsoldier[scnt++].y = i;\n\t\t\t\t\tlabyrinth[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tlabyrinth[i][j] = 2;\n\t\t\t\t\tescape.x = j;\n\t\t\t\t\tescape.y = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tlabyrinth[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis,false,sizeof(vis));\n\t\tgoal = 2;\n\t\tpshort = dfs(princess.x,princess.y,0);\n\t\t//printf(\"pshort:%d\\n\",pshort);\n\n\t\tgoal = 5;\n\t\tshortest = INF;\n\t\tmemset(vis,false,sizeof(vis));\n\t\teshort = dfs(escape.x,escape.y,0);\n\t\t//printf(\"eshort:%d\\n\",eshort);\n\t\tif(eshort<pshort)\n\t\t\tpshort = eshort;\n\t\t/*for(int i = 0; i<H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++ j)\n\t\t\t{\n\t\t\t\tif(i == princess.y&&j == princess.x)\n\t\t\t\t\tprintf(\"X\");\n\t\t\t\telse\n\t\t\t\tprintf(\"%d\",labyrinth[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(!scnt&&pshort!=INF)\n\t\t{\n\t\t\ttf = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pshort != INF)\n\t\t\t{\n\t\t\t\tgoal = 2;\n\t\t\t\tfor(int i = 0; i < scnt; ++i)\n\t\t\t\t{\n\t\t\t\t\tmemset(vis,false,sizeof(vis));\n\t\t\t\t\tshortest = INF;\n\t\t\t\t\tsshort = dfs(soldier[i].x,soldier[i].y,0);\n\t\t\t\t\t//printf(\"sshort:%d\\n\",sshort);\n\t\t\t\t\tif(sshort <= pshort)\n\t\t\t\t\t{\n\t\t\t\t\t\ttf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\ttf = false;\n\n\t\t}\n\t\tif(tf)\n\t\t{\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\n//const ll mod = 1000000007;\nll H, W;\nstring field[500];\nll sh, sw;\nll dh[4] = {1, -1, 0, 0};\nll dw[4] = {0, 0, 1, -1};\nll dist[500][500];\n\n\nint main() {\n    cin >> H >> W;\n    for(int h = 0; h < H; h++) {\n        cin >> field[h];\n        for(int w = 0; w < W; w++) {\n            if(field[h][w] == '%') {\n                sh = h;\n                sw = w;\n            }\n            dist[h][w] = INF;\n        }\n    }\n    dist[sh][sw] = 0;\n    queue<i_i> que;\n    que.push({sh, sw});\n    while(!que.empty()) {\n        auto tmp = que.front();\n        que.pop();\n        int fromh = tmp.first;\n        int fromw = tmp.second;\n        for(int k = 0; k < 4; k++) {\n            int toh = fromh + dh[k];\n            int tow = fromw + dw[k];\n            if(toh >= H or toh < 0) continue;\n            if(tow >= W or tow < 0) continue;\n            if(field[toh][tow] == '#') continue;\n            ll c = dist[fromh][fromw] + 1;\n            if(chmin(dist[toh][tow], c)) que.push({toh, tow});\n        }\n    }\n    ll q;\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if(field[h][w] == '@') q = dist[h][w];\n        }\n    }\n    string ans = \"Yes\";\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if(field[h][w] != '$') continue;\n            if(dist[h][w] <= q) ans = \"No\";\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntypedef std::pair<int,int> P;\n\nstruct State{\n  int depth;\n  int r,c;\n  State(int pr,int pc,int d):r(pr),c(pc),depth(d){}\n};\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  int h,w;\n  cin>>h>>w;\n  char map[202][202]={};\n\n  P princess;\n  P goal;\n  std::vector<P> soldier;\n\n  for(int c=0;c<=w+1;c++){\n    map[0][c]='#';\n    map[h+1][c]='#';\n  }\n\n\n\n  for(int r=1;r<=h;r++){\n    std::string s;\n    cin>>s;\n    map[r][0]='#';\n    for(int c=1;c<=w;c++){\n      map[r][c]=s[c-1];\n      if(map[r][c]=='@'){\n        princess=std::make_pair(r,c);\n      }else if(map[r][c]=='$'){\n        soldier.push_back(std::make_pair(r,c));\n      }else if(map[r][c]=='%'){\n        goal = std::make_pair(r, c);\n      }\n    }\n    map[r][w+1]='#';\n  }\n\n  bool p_visited[202][202]={};\n  p_visited[princess.first][princess.second]=true;\n\n  int princess_turn=0;\n  std::queue<State> q;\n  q.push(State(princess.first,princess.second,0));\n  while(!q.empty()){\n    State curr=q.front();\n    q.pop();\n    if(map[curr.r][curr.c]=='%'){\n      princess_turn=curr.depth;\n      break;\n    }\n    for(int vr=-1;vr<=1;vr++){\n      for(int vc=-1;vc<=1;vc++){\n\n        if(!((vr==0&&vc!=0)||(vc==0&&vr!=0))){\n          continue;\n        }\n\n        if(map[curr.r+vr][curr.c+vc]!='#'&&!p_visited[curr.r+vr][curr.c+vc]){\n          p_visited[curr.r+vr][curr.c+vc]=true;\n          q.push(State(curr.r+vr,curr.c+vc,curr.depth+1));\n        }\n\n      }\n    }\n  }\n\n  int min_turn=INT32_MAX/3;\n\n\n\n    std::queue<State> sq;\n\n    bool visited[202][202]={};\n    visited[goal.first][goal.second]=true;\n\n    int turn=INT32_MAX/3;\n    sq.push(State(goal.first,goal.second,0));\n    while(!sq.empty()){\n      State curr=sq.front();\n      sq.pop();\n      if(map[curr.r][curr.c]=='$'){\n        turn=curr.depth;\n        break;\n      }\n      for(int vr=-1;vr<=1;vr++){\n        for(int vc=-1;vc<=1;vc++){\n\n          if(!((vr==0&&vc!=0)||(vc==0&&vr!=0))){\n            continue;\n          }\n\n          if(map[curr.r+vr][curr.c+vc]!='#'&&!visited[curr.r+vr][curr.c+vc]){\n            visited[curr.r+vr][curr.c+vc]=true;\n            sq.push(State(curr.r+vr,curr.c+vc,curr.depth+1));\n          }\n\n        }\n      }\n    }\n\n    min_turn=std::min(min_turn,turn);\n\n\n  cout<<((princess_turn<min_turn)?\"Yes\":\"No\")<<endl;\n\n\n\n\n\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    memset(dis, -1, sizeof(dis));\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                q.push(next);\n            }\n        }\n    }\n    if(dis[goal.y][goal.x] == -1) return INF;\n    else return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n            //cout << p << ' ' << s << endl;;\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2001;\nconst int dx[] = {1,0,0,-1};\nconst int dy[] = {0,1,-1,0};\n\nint d[MAX_N][MAX_N];\nint e[MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h,w;\n    cin >> h >> w;\n    vs fd(h);\n    int si,sj;\n    vp vec;\n    rep(i,h){\n        cin >> fd[i];\n        rep(j,w){\n            if(fd[i][j] == '@'){\n                si = i,sj = j;\n            }else if(fd[i][j] == '$'){\n                vec.pb(P(i,j));\n            }\n        }\n    }\n    rep(i,h){\n        rep(j,w){\n            d[i][j] = INF;\n        }\n    }\n    queue<P> que;\n    rep(i,len(vec)){\n        que.push(P(vec[i]));\n        d[vec[i].fi][vec[i].se] = 0;\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nx = p.fi+dx[i],ny = p.se+dy[i];\n            if(0 <= nx && nx < h && 0 <= ny && ny < w && fd[nx][ny] != '#'){\n                if(d[nx][ny] > d[p.fi][p.se]+1){\n                    d[nx][ny] = d[p.fi][p.se]+1;\n                    que.push(P(nx,ny));\n                }\n            }\n        }\n    }\n    queue<P> q;\n    q.push(P(si,sj));\n    rep(i,h){\n        rep(j,w){\n            e[i][j] = INF;\n        }\n    }\n    e[si][sj] = 0;\n    while(!q.empty()){\n        P p = q.front();\n        q.pop();\n        rep(i,4){\n            int nx = p.fi+dx[i],ny = p.se+dy[i];\n            if(0 <= nx && nx < h && 0 <= ny && ny < w && fd[nx][ny] != '#' && d[nx][ny] > e[p.fi][p.se]+1){\n                if(e[nx][ny] > e[p.fi][p.se]+1){\n                    if(fd[nx][ny] == '%'){\n                        cout << \"Yes\\n\";\n                        return 0;\n                    }\n                    e[nx][ny] = e[p.fi][p.se]+1;\n                    q.push(P(nx,ny));\n                }\n            }\n        }\n    }\n    cout << \"No\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TDteam01\n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#include <iostream>  \n#include <string>  \n#include <vector>  \n#include <stack>    \n#include <cstdlib>  \n#include <cmath>  \n#include <set>  \n#include <list>  \n#include <deque>  \n#include <map>  \n#include <queue> \nusing namespace std;\n\nint H,W;\nchar t[200][200];\nint si,sj,ti,tj;\nint d[200][200];\nint di[]={-1,0,1,0};\nint dj[]={0,1,0,-1};\n \nint main(){\n\twhile(cin>>H>>W)\n\t{\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>t[i][j];\n\t\t\tif(t[i][j]=='@'){\n\t\t\t\tsi=i;\n\t\t\t\tsj=j;\n\t\t\t}\n\t\t\tif(t[i][j]=='%'){\n\t\t\t\tti=i;\n\t\t\t\ttj=j;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(d,1,sizeof(d));\n\td[ti][tj]=0;\n\tqueue<int> qi,qj;\n\tqi.push(ti);\n\tqj.push(tj);\n\twhile(!qi.empty()){\n\t\tint pi=qi.front();qi.pop();\n\t\tint pj=qj.front();qj.pop();\n\t\tfor(int dir=0;dir<4;dir++){\n\t\t\tint ni=pi+di[dir];\n\t\t\tint nj=pj+dj[dir];\n\t\t\tif(ni<0||nj<0||ni>=H||nj>=W)\n\t\t\t\tcontinue;\n\t\t\tif(t[ni][nj]=='#')\n\t\t\t\tcontinue;\n\t\t\tif(d[ni][nj]>d[pi][pj]+1){\n\t\t\t\td[ni][nj]=d[pi][pj]+1;\n\t\t\t\tqi.push(ni);\n\t\t\t\tqj.push(nj);\n\t\t\t}\n\t\t}\n\t}\n\tint dist=d[si][sj];\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t\tif(t[i][j]=='$')\n\t\t\t\tif(d[i][j]<=dist)\n\t\t\t\t\tdist=0;\n\tif(dist)\n\t\tcout<<\"Yes\"<<endl;\n\telse \n\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nint main () {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n\n  int h, w; cin>>h>>w;\n  vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};\n  vector<vector<char>> a(h, vector<char>(w));\n  pair<int, int> s, e;\n  map<pair<int, int>, bool> enemy;\n  map<pair<int, int>, bool> wall;\n  for(int i=0;i<h;++i) {\n    for(int j=0;j<w;++j) {\n      cin >> a[i][j];\n      pair<int, int> p = make_pair(i, j);\n      if(a[i][j] == '@') s = p;\n      else if(a[i][j] == '%') e = p;\n      else if(a[i][j] == '$') enemy[p] = true;\n      else if(a[i][j] == '#') wall[p] = true;\n    }\n  }\n\n  vector<vector<int>> d(h, vector<int>(w, INF));\n  queue<pair<int, int>> q;\n  map<pair<int, int>, bool> sel;\n  q.push(s);\n  sel[s] = true;\n  d[s.first][s.second] = 0;\n  while(!q.empty()) {\n    pair<int, int> now = q.front(); q.pop();\n    // cout << now.first << \":\" << now.second << endl;\n    for(int i=0;i<4;++i) {\n      pair<int, int> next = make_pair(now.first + dy[i], now.second + dx[i]);\n      if(0 <= next.first && next.first < h && 0 <= next.second && next.second < w && !wall[next] && !sel[next]) {\n        q.push(next);\n        sel[next] = true;\n        d[next.first][next.second] = d[now.first][now.second] + 1;\n      }\n    }\n  }\n\n  int d_prin = d[e.first][e.second];\n  int d_enemy = INF;\n\n  vector<vector<int>> de(h, vector<int>(w, INF));\n  map<pair<int, int>, bool> sele;\n  q.push(e);\n  sele[e] = true;\n  de[e.first][e.second] = 0;\n  while(!q.empty()) {\n    pair<int, int> now = q.front(); q.pop();\n    if(enemy[now]) {\n      d_enemy = de[now.first][now.second];\n      break;\n    }\n    for(int i=0;i<4;++i) {\n      pair<int, int> next = make_pair(now.first + dy[i], now.second + dx[i]);\n      if(0 <= next.first && next.first < h && 0 <= next.second && next.second < w && !wall[next] && !sele[next]) {\n        q.push(next);\n        sele[next] = true;\n        de[next.first][next.second] = de[now.first][now.second] + 1;\n      }\n    }\n  }\n\n  // cout << d_prin << \":\" << d_enemy << endl;\n  if(d_prin < d_enemy) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 2e2+2;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n    int x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n    int temp;\n    //printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n    //labyrinth[y][x] = 3;\n    vis[y][x] = true;\n    if(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n    {\n        if(labyrinth[y][x-1] == goal)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x-1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n    {\n        if(labyrinth[y][x+1] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x+1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n    {\n        if(labyrinth[y-1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y-1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n    {\n        if(labyrinth[y+1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y+1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    return shortest;\n}\n\nint main()\n{\n    //freopen(\"1002.txt\",\"r\",stdin);\n    //freopen(\"ans.txt\",\"w+\",stdout);\n    while(~scanf(\"%d%d\",&H,&W))\n    {\n        tf = true;\n        scnt = 0;\n        shortest = INF;\n        memset(labyrinth,-1,sizeof(labyrinth));\n        getchar();\n        for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                while((ch = getchar())=='\\n');\n                switch(ch)\n                {\n                case '@':\n                    princess.x = j;\n                    princess.y = i,labyrinth[i][j] = 5;\n                    break;\n                case '.':\n                    labyrinth[i][j] = 1;\n                    break;\n                case '$':\n                    soldier[scnt].x = j;\n                    soldier[scnt++].y = i;\n                    labyrinth[i][j] = 1;\n                    break;\n                case '%':\n                    labyrinth[i][j] = 2;\n                    escape.x = j;\n                    escape.y = i;\n                    break;\n                case '#':\n                    labyrinth[i][j] = 0;\n                    break;\n                }\n            }\n        }\n        memset(vis,false,sizeof(vis));\n        goal = 2;\n        pshort = dfs(princess.x,princess.y,0);\n        //printf(\"pshort:%d\\n\",pshort);\n\n        goal = 5;\n\n        memset(vis,false,sizeof(vis));\n        eshort = dfs(escape.x,escape.y,0);\n        //printf(\"eshort:%d\\n\",eshort);\n        if(eshort<pshort)\n            pshort = eshort;\n        /*for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                if(i == princess.y&&j == princess.x)\n                    printf(\"X\");\n                else\n                printf(\"%d\",labyrinth[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        if(!scnt&&pshort!=INF)\n        {\n            tf = true;\n        }\n        else\n        {\n            if(pshort != INF)\n            {\n                goal = 2;\n                for(int i = 0; i < scnt; ++i)\n                {\n                    memset(vis,false,sizeof(vis));\n                    shortest = INF;\n                    sshort = dfs(soldier[i].x,soldier[i].y,0);\n                    //printf(\"sshort:%d\\n\",sshort);\n                    if(sshort <= pshort)\n                    {\n                        tf = false;\n                        break;\n                    }\n                }\n\n            }\n            else\n                tf = false;\n\n        }\n        if(tf)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            printf(\"No\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint h,w;\nchar a[205][205];\nint visit[205][205];\nstruct Node {\n\tint x,y;\n}b[40005],s,e,temp,temp2;\nint xx[4]={1,0,-1,0};\nint yy[4]={0,1,0,-1};\nint bfs(Node s)\n{\n\tmemset(visit,0,sizeof(visit));\n\tqueue<Node>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ttemp=q.front();\n\t\tfor(int i=0;i<4;i++){\n\t\t\ttemp2.x=temp.x+xx[i];\n\t\t\ttemp2.y=temp.y+yy[i];\n\t\t\tif(temp2.x<0||temp.x>h||temp2.y<0||temp2.y>w||a[temp2.x][temp2.y]=='#'||visit[temp2.x][temp2.y]!=0) continue;\n\t\t\tq.push(temp2);\n\t\t\tvisit[temp2.x][temp2.y]=visit[temp.x][temp.y]+1;\n\t\t}\n\t\tq.pop();\n\t\tif(visit[e.x][e.y]!=0) break;\n\t}\n\treturn visit[e.x][e.y];\n}\nint main()\n{\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=0;i<h;i++)\n\t\tscanf(\"%s\",a[i]);\n\tint num=0;\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(a[i][j]=='@') {\n\t\t\t\ts.x=i; s.y=j;\n\t\t\t}\n\t\t\tif(a[i][j]=='%'){\n\t\t\t\te.x=i; e.y=j;\n\t\t\t}\n\t\t\tif(a[i][j]=='$'){\n\t\t\t\tnum++; b[num].x=i; b[num].y=j;\n\t\t\t}\n\t\t}\n\tif(num==0){\n\t\tprintf(\"Yes\\n\");\n\t}\n\telse{\n\t\tint ans=bfs(s);\n\t\tint flag=1;\n\t\tfor(int i=1;i<=num;i++){\n\t\t\tint temp=bfs(b[i]);\n\t\t\t\n\t\t\tif(temp<=ans) {\n\t\t\t\tflag=0; break;\n\t\t\t}\n\t\t}\n\t\tif(flag==1) printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n\t\n\t\n\t\n\t\n } "
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint h, w;\nstring s[200];\nint d[200][200];\n\nint main(){\n  cin >> h >> w;\n  rep(i, h) cin >> s[i];\n  int sx, sy;\n  rep(i, h) rep(j, w) if (s[i][j] == '%') sx = i, sy = j;\n  fill_n(*d, 200 * 200, inf);\n  queue<pair<int, int>> q;\n  d[sx][sy] = 0;\n  q.emplace(sx, sy);\n  while (q.size()){\n    int x, y;\n    tie(x, y) = q.front(), q.pop();\n    rep(i, 4){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n      if (s[nx][ny] == '#') continue;\n      if (d[nx][ny] > d[x][y] + 1){\n        d[nx][ny] = d[x][y] + 1;\n        q.emplace(nx, ny);\n      }\n    }\n  }\n  int a, b = inf;\n  rep(i, h) rep(j, w){\n    if (s[i][j] == '@') a = d[i][j];\n    if (s[i][j] == '$') chmin(b, d[i][j]);\n  }\n  cout << (a < b ? \"Yes\\n\" : \"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nchar map[205][205];\nint vis[205][205];\nint r,c,anx,any;\nint dis[4][2]= {{0,1},{0,-1},{1,0},{-1,0}};\nstruct Node\n{\n    int x;\n    int y;\n    Node(int xx,int yy)\n    {\n        x=xx;\n        y=yy;\n    }\n};\nint bfs(int x,int y)\n{\n\n    vis[x][y]=1;\n    queue<Node>Q;\n    while(!Q.empty())Q.pop();\n    Q.push(Node(x,y));\n    while(!Q.empty())\n    {\n        int nx=Q.front().x;\n        int ny=Q.front().y;\n        //cout<<nx<<\"---\"<<ny<<endl;\n        Q.pop();\n        for(int i=0; i<4; i++)\n        {\n\n            int xx=nx+dis[i][0];\n            int yy=ny+dis[i][1];\n            if(xx>=0&&xx<r&&yy>=0&&yy<c&&map[xx][yy]!='#'&&vis[xx][yy]==0)\n            {\n                 //cout<<\"==\"<<xx<<\"--\"<<yy<<endl;\n                vis[xx][yy]=vis[nx][ny]+1;\n                Q.push(Node(xx,yy));\n            }\n            if(vis[anx][any]>0)\n            {\n                return vis[anx][any]-1;\n            }\n        }\n\n    }\n    return -1;\n\n}\nint main()\n{\n\n    while(~scanf(\"%d%d\",&r,&c))\n    {\n        getchar();\n        vector<Node>V;\n        V.clear();\n        memset(vis,0,sizeof(vis));\n        int x,y;\n        for(int i=0; i<r; i++)\n        {\n            for(int j=0; j<c; j++)\n            {\n                scanf(\"%c\",&map[i][j]);\n                if(map[i][j]=='$')\n                {\n                    V.push_back(Node(i,j));\n                }\n                if(map[i][j]=='@')\n                {\n                    x=i;\n                    y=j;\n                }\n                if(map[i][j]=='%')\n                {\n                    anx=i;\n                    any=j;\n\n                }\n            }\n            if(i!=r-1)getchar();\n        }\n\n        if(V.size()==0)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            int flag=0;\n            int len1=bfs(x,y);\n            //cout<<len1<<endl;\n            for(int i=0;i<V.size();i++)\n            {\n                memset(vis,0,sizeof(vis));\n                int a=V[i].x;\n                int b=V[i].y;\n                if(bfs(a,b)>0&&bfs(a,b)<=len1)\n                {\n                    //cout<<bfs(a,b)<<endl;\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag)printf(\"No\\n\");\n            else\n               printf(\"Yes\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\nstruct s\n{\n    int x,y;\n} st,tmp,tmp1;\nqueue<s>q;\nchar a[205][205];\nint vis[205][205];\nint dx[10]= {0,0,1,-1};\nint dy[10]= {1,-1,0,0};\nint main()\n{\n    int aa,b,xx,yy;\n    while(scanf(\"%d %d\",&aa,&b)!=EOF)\n    {\n        int i,j;\n        for(i=0; i<aa; i++)\n        {\n            scanf(\"%s\",a[i]);\n            for(j=0; j<b; j++)\n            {\n                if(a[i][j]=='%')\n                {\n                    st.x=i;\n                    st.y=j;\n                }\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        memset(vis,0,sizeof(vis));\n        vis[st.x][st.y]=1;\n        q.push(st);\n        int z=0,zz=0;\n        while(!q.empty())\n        {\n            tmp=q.front();\n\n            q.pop();\n            for(i=0; i<4; i++)\n            {\n                xx=dx[i]+tmp.x;\n                yy=dy[i]+tmp.y;\n                if(vis[xx][yy]==0&&xx>=0&&xx<aa&&yy>=0&&yy<b&&a[xx][yy]!='#')\n                {\n                    tmp1.x=xx;\n                    tmp1.y=yy;\n                    vis[xx][yy]=vis[tmp.x][tmp.y]+1;\n                    if(z==0&&a[xx][yy]=='@')\n                        z=vis[xx][yy];\n                    if(zz==0&&a[xx][yy]=='$')\n                        zz=vis[xx][yy];\n                    q.push(tmp1);\n                }\n            }\n        }\n        if((z>0&&z<zz)||(zz==0))\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n            printf(\"No\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59(\n \n \n#define GRID_Y 300\n#define GRID_X 300\n#define WALL '#'\nint h,w;\nstring data[GRID_Y];\nvoid grid_bfs(int sy,int sx,int d[GRID_Y][GRID_X]){\n    bool used[GRID_Y][GRID_X];\n    rep(i,GRID_Y)rep(j,GRID_X)used[i][j]=false;\n    \n    rep(i,GRID_Y)rep(j,GRID_X)d[i][j]=INF;\n    d[sy][sx]=0;\n    \n    queue<pii> que;\n    que.push(pii(sy,sx));\n    while(que.size()){\n        int y=que.front().first, x=que.front().second;\n        que.pop();\n        if(used[y][x])continue;\n        used[y][x]=true;\n        \n        int dy[]={1,0,-1,0},dx[]={0,1,0,-1};\n        rep(i,4){\n            int ddy=y+dy[i],ddx=x+dx[i];\n            if(ddx<0||ddy<0||ddx>=w||ddy>=h||used[ddy][ddx]||data[ddy][ddx]==WALL)continue;\n            d[ddy][ddx]=d[y][x]+1;\n            que.push(pii(ddy,ddx));\n        }\n    }\n}\n \n \n \nint main(){\n    cin>>h>>w;\n    rep(i,h) cin>>data[i];\n    \n    pii goal,pr;\n    vector<pii> arm;\n    rep(i,h){\n        rep(j,w){\n            if( data[i][j]=='@' )pr   = pii(i,j);\n            if( data[i][j]=='%' )goal = pii(i,j);\n            if( data[i][j]=='$' )arm.pb( pii(i,j) );\n        }\n    }\n    int d[300][300];\n    grid_bfs(goal.first,goal.second,d);\n    \n \n    int prt = d[pr.first][pr.second];\n    int armt= INF;\n    \n    rep(i,arm.size()){\n        armt = min(armt, d[arm[i].first][arm[i].second] );\n    }\n \n    if(prt<armt)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    \n//    cout<<prt<<\" \"<<armt<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 2e2+2;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n    int x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n    int temp;\n    //printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n    //labyrinth[y][x] = 3;\n    vis[y][x] = true;\n    if(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n    {\n        if(labyrinth[y][x-1] == goal)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x-1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n    {\n        if(labyrinth[y][x+1] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x+1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n    {\n        if(labyrinth[y-1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y-1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n    {\n        if(labyrinth[y+1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y+1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    return shortest;\n}\n\nint main()\n{\n    //freopen(\"1002.txt\",\"r\",stdin);\n    //freopen(\"ans.txt\",\"w+\",stdout);\n    while(~scanf(\"%d%d\",&H,&W))\n    {\n        tf = true;\n        scnt = 0;\n        shortest = INF;\n        memset(labyrinth,-1,sizeof(labyrinth));\n        getchar();\n        for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                while((ch = getchar())=='\\n');\n                switch(ch)\n                {\n                case '@':\n                    princess.x = j;\n                    princess.y = i,labyrinth[i][j] = 5;\n                    break;\n                case '.':\n                    labyrinth[i][j] = 1;\n                    break;\n                case '$':\n                    soldier[scnt].x = j;\n                    soldier[scnt++].y = i;\n                    labyrinth[i][j] = 1;\n                    break;\n                case '%':\n                    labyrinth[i][j] = 2;\n                    escape.x = j;\n                    escape.y = i;\n                    break;\n                case '#':\n                    labyrinth[i][j] = 0;\n                    break;\n                }\n            }\n        }\n        memset(vis,false,sizeof(vis));\n        goal = 2;\n        pshort = dfs(princess.x,princess.y,0);\n        //printf(\"pshort:%d\\n\",pshort);\n\n        goal = 5;\n        shortest = INF;\n        memset(vis,false,sizeof(vis));\n        eshort = dfs(escape.x,escape.y,0);\n        //printf(\"eshort:%d\\n\",eshort);\n        if(eshort<pshort)\n            pshort = eshort;\n        /*for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                if(i == princess.y&&j == princess.x)\n                    printf(\"X\");\n                else\n                printf(\"%d\",labyrinth[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        if(!scnt&&pshort!=INF)\n        {\n            tf = true;\n        }\n        else\n        {\n            if(pshort != INF)\n            {\n                goal = 2;\n                for(int i = 0; i < scnt; ++i)\n                {\n                    memset(vis,false,sizeof(vis));\n                    shortest = INF;\n                    sshort = dfs(soldier[i].x,soldier[i].y,0);\n                    //printf(\"sshort:%d\\n\",sshort);\n                    if(sshort <= pshort)\n                    {\n                        tf = false;\n                        break;\n                    }\n                }\n\n            }\n            else\n                tf = false;\n\n        }\n        if(tf)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            printf(\"No\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <string>\n#include <vector>\n#include<functional>\n#include <set>\n#include <map>\n#include <climits>\n#define lson root<<1,l,mid\n#define rson root<<1|1,mid+1,r\n#define fi first\n#define se second\n#define ping(x,y) ((x-y)*(x-y))\n#define mst(x,y) ir(x,y,sizeof(x))\n#define mcp(x,y) memcpy(x,y,sizeof(y))\nusing namespace std;\n#define gamma 0.5772156649015328606065120\n#define MOD 1000000007\n#define inf 0x3f3f3f3f\n#define N 100005\n#define maxn 10005\ntypedef long long int LL;\nchar x[220][220];\nint bu[220][220];\nint pr[220][220];\nint f[5][5]={{1,0},{-1,0},{0,-1},{0,1}};\nqueue<pair<int,int > >qe;\npair<int,int > pa;\nint n,m;\nint a,b,c,d;\nvoid bfs(int i,int j)\n{\nint k;\n        qe.push(pair<int,int>(i,j));\n        while(!qe.empty())\n        {\n            pa=qe.front();\n            i=pa.fi;\n        j=pa.se;\n        for(k=0;k<4;k++)\n        {\n            int i1=i+f[k][0];\n            int j1=j+f[k][1];\n            if(i1>=0&&i1<n&&j1>=0&&j1<m)\n            {\n\n                if(bu[i1][j1]>bu[i][j]+1)\n                {\n                    bu[i1][j1]=bu[i][j]+1;\n                     if(x[i1][j1]=='.')\n           qe. push(pair<int,int>(i1,j1));\n                }\n            }\n        }\n            qe.pop();\n        }\n}\nint bfsp(int i,int j)\n{\n    int k;\n    qe. push(pair<int,int>(i,j));\n     while(!qe.empty())\n        {\n            i=qe.front().fi;\n        j=qe.front().se;\n        for(k=0;k<4;k++)\n        {\n            int i1=i+f[k][0];\n            int j1=j+f[k][1];\n            if(i1>=0&&i1<n&&j1>=0&&j1<m&&(x[i1][j1]=='.'||x[i1][j1]=='%'))\n            {\n\n                if((pr[i1][j1]>pr[i][j]+1)&&(bu[i1][j1]>min(pr[i][j]+1,pr[i1][j1])))\n                {\n                                         if(x[i1][j1]=='%')\n                    return 1;\n                    pr[i1][j1]=pr[i][j]+1;\n\n           qe. push(pair<int,int>(i1,j1));\n                }\n            }\n        }\n            qe.pop();\n        }\n        return 0;\n}\nint main()\n{\n    int i,j;\n    memset(bu,63,sizeof(bu));\n    memset(pr,63,sizeof(pr));\n    int lo=bu[0][0];\n    scanf(\"%d %d\",&n,&m);\ngetchar();\nfor(i=0;i<n;i++)\n    gets(x[i]);\n    int f=0;\n    for(i=0;i<n;i++)\n        for(j=0;j<m;j++)\n        {\n                if(x[i][j]=='$')\n            {\n                f=1;\n                bu[i][j]=0;\n                bfs(i,j);\n            }\n             else  if(x[i][j]=='%')\n            {\n                a=i,b=j;\n            }\n            else  if(x[i][j]=='@')\n            {\n                pr[i][j]=0;\n              c=i,d=j;\n            }\n        }\n       int s= bfsp(c,d);\n        if(s==1||f==0)\n        printf(\"Yes\\n\");\n        else\n                    printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    rep(i,N) rep(j,N) dis[i][j] = INF;\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == INF && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p) break;\n                q.push(next);\n            }\n        }\n    }\n    return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n        }\n    }\n    if(p < s) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n \ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n \nint H, W;\nint ey, ex;\nchar maps[201][201];\n \nint bfs1() {\n  bool used[201][201] = {{0}};\n  queue<Pip> q;\n  q.push(Pip(0, Pii(ey, ex)));\n  while ( !q.empty() ) {\n    Pip p = q.front(); q.pop();\n    int c = p.fr,  y = p.sc.fr, x = p.sc.sc;    \n \n    if ( maps[y][x] == '@' ) {\n      return c;\n    }\n \n    if ( used[y][x] ) continue;\n    used[y][x] = true;\n \n    Rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if ( ny < 0 || nx < 0 || ny >= H || nx >= W || maps[ny][nx] == '#' || maps[ny][nx] == '$' ) continue;\n      q.push(Pip(c+1, Pii(ny, nx)));\n    }\n  }\n \n  return INF;\n}\n \nint bfs2() {\n  bool used[201][201] = {{0}};\n  queue<Pip> q;\n  q.push(Pip(0, Pii(ey, ex)));\n  while ( !q.empty() ) {\n    Pip p = q.front(); q.pop();\n    int c = p.fr,  y = p.sc.fr, x = p.sc.sc;    \n \n    if ( maps[y][x] == '$' ) {\n      return c;\n    }\n \n    if ( used[y][x] ) continue;\n    used[y][x] = true;\n \n    Rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if ( ny < 0 || nx < 0 || ny >= H || nx >= W || maps[ny][nx] == '#' ) continue;\n      q.push(Pip(c+1, Pii(ny, nx)));\n    }\n  }\n \n  return INF;\n}\n \nsigned main() {\n  cin >> H >> W;\n  Rep(i, H) Rep(j, W) {\n    cin >> maps[i][j];\n    if ( maps[i][j] == '%' ) ey = i, ex = j;\n  }\n \n  if ( bfs1() < bfs2() ) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> m(h);\n\tREP(i,h) cin >> m[i];\n\tint sx, sy;\n\tREP(i,h) REP(j,w) if(m[i][j] == '%') {sx = i, sy = j;}\n\n\tVVI d(h,VI(w));\n\td[sx][sy] = 1;\n\tqueue<P> que;\n\tque.push(make_pair(sx, sy));\n\twhile (!que.empty()){\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tint i = p.first, j = p.second;\n\t\tint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n\t\tREP(k,4){\n\t\t\tint ii = i + dx[k], jj = j + dy[k];\n\t\t\tif (ii < 0 || jj < 0 || ii >= h || jj >= w) continue;\n\t\t\tif (m[ii][jj] == '#' || d[ii][jj] > 0) continue;\n\t\t\td[ii][jj] = d[i][j] + 1;\n\t\t\tque.push(make_pair(ii, jj));\n\t\t}\n\t}\n\tint p, s;\n\ts = 1e9;\n\tREP(i,h) REP(j,w){\n\t\tif (m[i][j] == '@') p = d[i][j];\n\t\tif (m[i][j] == '$') s = min(s, d[i][j]);\n\t}\n\tcout << (p < s ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint dist[2][300][300];\nvoid solve() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<string> inputs;\n\tREP(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tinputs.push_back(s);\n\t}\n\tqueue<pair<int, int>> next;\n\tREP(i,h) {\n\t\tREP(q, w) {\n\t\t\tif (inputs[i][q] == '@') {\n\t\t\t\tnext.push(mp(i, q));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdist[0][i][q] = 1e9;\n\t\t\t}\n\t\t}\n\t}\n\twhile (next.empty() == false) {\n\t\tpair<int, int> now = next.front();\n\t\tnext.pop();\n\t\tint dx[4] = { 1,-1,0,0 };\n\t\tREP(t, 4) {\n\t\t\tint x = now.first + dx[t];\n\t\t\tint y = now.second + dx[3 - t];\n\t\t\tif (x >= 0 && x < h && y >= 0 && y < w) {\n\t\t\t\tif (inputs[x][y] == '#') continue;\n\t\t\t\tif (dist[0][now.first][now.second] + 1< dist[0][x][y]){\n\t\t\t\t\tdist[0][x][y] = dist[0][now.first][now.second] + 1;\n\t\t\t\t\tnext.push(mp(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (inputs[i][q] == '$') {\n\t\t\t\tnext.push(mp(i, q));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdist[1][i][q] = 1e9;\n\t\t\t}\n\t\t}\n\t}\n\twhile (next.empty() == false) {\n\t\tpair<int, int> now = next.front();\n\t\tnext.pop();\n\t\tint dx[4] = { 1,-1,0,0 };\n\t\tREP(t, 4) {\n\t\t\tint x = now.first + dx[t];\n\t\t\tint y = now.second + dx[3 - t];\n\t\t\tif (x >= 0 && x < h && y >= 0 && y < w) {\n\t\t\t\tif (inputs[x][y] == '#') continue;\n\t\t\t\tif (dist[1][now.first][now.second] + 1 < dist[1][x][y]) {\n\t\t\t\t\tdist[1][x][y] = dist[1][now.first][now.second] + 1;\n\t\t\t\t\tnext.push(mp(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tif (inputs[i][q] == '%') {\n\t\t\t\tif (dist[0][i][q] < dist[1][i][q]) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconstexpr int dir[] = {1, 0, -1, 0, 1};\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n\n    auto in = [=](const int h, const int w) {\n        return h >= 0 and h < H and w >= 0 and w < W;\n    };\n\n    vector<vector<char>> field(H, vector<char>(W));\n    pii s;\n    pii g;\n    vector<pii> sol;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == '@') {\n                s = make_pair(i, j);\n                field[i][j] = '.';\n            } else if (field[i][j] == '%') {\n                g = make_pair(i, j);\n                field[i][j] = '.';\n            } else if (field[i][j] == '$') {\n                sol.push_back(make_pair(i, j));\n                field[i][j] = '.';\n            }\n        }\n    }\n    constexpr int INF = 1 << 30;\n    vector<vector<int>> dist(H, vector<int>(W, INF));\n    queue<pair<pii, int>> q;\n    dist[g.first][g.second] = 0;\n    q.push(make_pair(g, 0));\n    while (not q.empty()) {\n        const auto p = q.front();\n        q.pop();\n        for (int d = 0; d < 4; d++) {\n            const int newy = p.first.first + dir[d];\n            const int newx = p.first.second + dir[d + 1];\n            if (in(newy, newx) and field[newy][newx] == '.' and dist[newy][newx] == INF) {\n                dist[newy][newx] = p.second + 1;\n                q.push(make_pair(make_pair(newy, newx), p.second + 1));\n            }\n        }\n    }\n    for (const auto& pos : sol) {\n        if (dist[s.first][s.second] >= dist[pos.first][pos.second]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nstring maze[210];\nint d[210][210], dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}, h, w, gx, gy;\nint bfs(int sx, int sy) {\n\tqueue<PII> que;\n\tREP(i, h) REP(j, w) d[i][j] = INF;\n\tque.push(PII(sx, sy));\n\td[sy][sx] = 0;\n\twhile(que.size()) {\n\t\tPII p = que.front(); que.pop();\n\t\t//cout << p.first << \" \" << p.second << endl;\n\t\tif(p.first == gx && p.second == gy) break;\n\t\tREP(i, 4) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && maze[ny][nx] != '#' && d[ny][nx] == INF) {\n\t\t\t\tque.push(PII(nx, ny));\n\t\t\t\td[ny][nx] = d[p.second][p.first] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t/*REP(i, h) {\n\t\tREP(j, w) {\n\t\t\tcout << d[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn d[gy][gx];\n}\n\nsigned main(void)\n{\n\tcin >> h >> w;\n\tREP(i, h) cin >> maze[i];\n\n\tint py, px;\n\tVI sy, sx;\n\tREP(i, h) REP(j, w) {\n\t\tif(maze[i][j] == '@') {py = i; px = j;}\n\t\telse if(maze[i][j] == '$') {sy.PB(i); sx.PB(j);}\n\t\telse if(maze[i][j] == '%') {gy = i; gx = j;}\n\t}\n\n\tint p = bfs(px, py);\n\tint s = INF;\n\tREP(i, sx.size()) {\n\t\ts = min(s, bfs(sx[i], sy[i]));\n\t}\n\t//cout << p << \" \" << s << endl;\n\tif(s <= p) cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=0,pri=0;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w){\n    if(s[i][j]=='%')x=j,y=i;\n  }\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(pri&&pri<a.second)break;\n    if(s[yy][xx]=='$'){sol=a.second;}\n    if(s[yy][xx]=='@'){pri=a.second;}\n    if(sol)break;\n    r(i,4){\n      if(xx+dx[i]>=0&&xx+dx[i]<w&&yy+dy[i]>=0&&yy+dy[i]<h)\n        if(!b[yy+dy[i]][xx+dx[i]]&&s[yy+dy[i]][xx+dx[i]]!='#')\n          Q.push(mk(mk(yy+dy[i],xx+dx[i]),a.second+1));\n    }\n  }\n  if(sol==0)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint main(){\n  int h,w,x,y,sol=0,pri=0;\n  cin>>h>>w;\n  bool b[h][w];\n  string s[h];\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w)if(s[i][j]=='%')x=j,y=i;\n  r(i,h)r(j,w)b[i][j]=0;\n  queue<pair<pair<int,int>,int > >Q;\n  Q.push(mk(mk(y,x),0));\n  while(!Q.empty()){\n    pair<pair<int,int > ,int >a=Q.front();Q.pop();\n    int xx=a.first.second,yy=a.first.first;\n    b[yy][xx]=1;\n    if(pri&&pri<a.second)break;\n    if(s[yy][xx]=='$'){sol=a.second;}\n    if(s[yy][xx]=='@'){pri=a.second;}\n    if(sol)break;\n    r(i,4){\n      int x1=xx+dx[i],y1=yy+dy[i];\n      if(x1<0||x1>=w||y1<0||y1>=h||b[y1][x1]||s[y1][x1]=='#')continue;\n          Q.push(mk(mk(y1,x1),a.second+1));\n    }\n  }\n  if(sol==0)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint h,w;\n\tcin>>h>>w;\n\tvs a(h);\n\tfor(auto &i:a) cin>>i;\n\tqueue<pip> q;\n\tvvi b(h,vi(w,inf));\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tif(a[i][j]=='%'){\n\t\t\tq.push({0,{i,j}});\n\t\t\tb[i][j]=0;\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpip p=q.front();q.pop();\n\t\tint x=p.second.first,y=p.second.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=x+dx[i],cy=y+dy[i];\n\t\t\tif(cx>=0&&cx<h&&cy>=0&&cy<w&&a[cx][cy]!='#'&&b[cx][cy]==inf){\n\t\t\t\tq.push({p.first+1,{cx,cy}});\n\t\t\t\tb[cx][cy]=p.first+1;\n\t\t\t}\n\t\t}\n\t}\n\tint mn=inf,dis;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tif(a[i][j]=='@') dis=b[i][j];\n\t\tif(a[i][j]=='$') mn=min(mn,b[i][j]);\n\t}\n\tcout<<(dis<mn?\"Yes\":\"No\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint dx[4]={1, 0, 0,-1};\nint dy[4]={0, 1,-1, 0};\n\nstruct info{\n\tint y;\n\tint x;\n\tint dist;\n\tinfo(int y, int x, int d): y(y),x(x),dist(d){}\n};\n\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tvector<vector<char> > map(h+2, vector<char>(w+2, '#'));\n\tint sy, sx;\n\tfor(int i=1; i<=h; i++){\n\t\tfor(int j=1; j<=w; j++){\n\t\t\tcin >> map[i][j];\n\t\t\tif(map[i][j]=='%'){\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<info> q;\n\tq.push(info(sy, sx, 0));\n\tmap[sy][sx] = '#';\n\tint princess=-1, soldier=-1;\n\twhile(!q.empty()){\n\t\tint y=q.front().y;\n\t\tint x=q.front().x;\n\t\tint d=q.front().dist;\n\t\tq.pop();\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint ny=y+dy[i], nx=x+dx[i];\n\t\t\tif(map[ny][nx] != '#'){\n\t\t\t\tif(map[ny][nx]=='@'){\n\t\t\t\t\tprincess=d;\n\t\t\t\t}\n\t\t\t\tif(map[ny][nx]=='$' && soldier==-1){\n\t\t\t\t\tsoldier=d;\n\t\t\t\t}\n\t\t\t\tq.push(info(ny, nx, d+1));\n\t\t\t\tmap[ny][nx] = '#';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(soldier==-1 || princess < soldier){\n\t\tcout << \"Yes\" << endl;\n\t}else{\n\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nint H,W;\nint sx,sy,gx,gy;\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nint visited[210][210] = {};\nchar F[210][210];\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    cin >> H >> W;\n    queue<PP> Q;\n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n            cin >> F[i][j];\n            if(F[i][j]=='@'){\n                sx = i; sy = j;\n            }else if(F[i][j]=='%'){\n                gx = i; gy = j;\n            }else if(F[i][j]=='$'){\n                visited[i][j] = -1;\n                Q.push({{i,j},-1});\n            }\n        }\n    }\n    Q.push({{sx,sy},1});\n    while(!Q.empty()){\n        PP pp = Q.front(); Q.pop();\n        int x = pp.first.first,y = pp.first.second;\n        for(int i=0;i<4;i++){\n            int nx = x+dx[i],ny = y+dy[i];\n            if(!in(nx,ny) || visited[nx][ny]!=0 || F[nx][ny]=='#') continue;\n            visited[nx][ny] = pp.second;\n            Q.push({{nx,ny},pp.second});\n        }\n    }\n    cout << (visited[gx][gy]==1? \"Yes\":\"No\") << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int H,W; cin >> H >> W;\n    vector<string> f(H);\n    for (int i=0;i<H;++i) cin >> f[i];\n    int sx,sy;\n    for (int i=0;i<H;++i)\n        for (int j=0;j<W;++j)\n            if (f[i][j]=='%')\n                sx=i,sy=j;\n    vector<vector<int>> dist(H,vector<int>(W,-1));\n    queue<pair<int,int>> que;\n    dist[sx][sy]=0; que.emplace(sx,sy);\n    int princess,soldiar=INF;\n    while(!que.empty()){\n        auto p=que.front(); que.pop();\n        int x=p.first,y=p.second;\n        for (int i=0;i<4;++i){\n            int nx=x+dx[i],ny=y+dy[i];\n            if (nx<0||H<=nx||ny<0||W<=ny) continue;\n            if (f[nx][ny]=='#') continue;\n            if (dist[nx][ny]!=-1) continue;\n            dist[nx][ny]=dist[x][y]+1;\n            que.emplace(nx,ny);\n            if (f[nx][ny]=='@') princess=dist[nx][ny];\n            if (f[nx][ny]=='$') soldiar=min(soldiar,dist[nx][ny]);\n        }\n    }\n    cout << (princess<soldiar?\"Yes\":\"No\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tvector<string> v(H);\n\tfor (int i = 0; i < H; i++) cin >> v[i];\n\tint N = H * W;\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < H - 1; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == '$' || v[i + 1][j] == '$') continue;\n\t\t\tG[i * W + j].push_back(i * W + j + W);\n\t\t\tG[i * W + j + W].push_back(i * W + j);\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W - 1; j++) {\n\t\t\tif (v[i][j] == '#' || v[i][j + 1] == '#') continue;\n\t\t\tG[i * W + j].push_back(i * W + j + 1);\n\t\t\tG[i * W + j + 1].push_back(i * W + j);\n\t\t}\n\t}\n\tint s = -1, g = -1; vector<int> sol;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == '$') sol.push_back(i * W + j);\n\t\t\tif (v[i][j] == '@') s = i * W + j;\n\t\t\tif (v[i][j] == '%') g = i * W + j;\n\t\t}\n\t}\n\tvector<int> solt(N, 999999999);\n\tqueue<int> que1;\n\tfor (int i : sol) que1.push(i), solt[i] = 0;\n\twhile (!que1.empty()) {\n\t\tint u = que1.front(); que1.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (solt[i] == 999999999) {\n\t\t\t\tsolt[i] = solt[u] + 1;\n\t\t\t\tque1.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> dist(N, 999999999); dist[s] = 0;\n\tqueue<int> que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tint u = que2.front(); que2.pop();\n\t\tfor (int i : G[u]) {\n\t\t\tif (dist[i] == 999999999 && solt[i] > dist[u] + 1) {\n\t\t\t\tdist[i] = dist[u] + 1;\n\t\t\t\tque2.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (dist[g] != 999999999 ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4]={1, 0, 0, -1};\nint dy[4]={0, 1, -1, 0};\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  int sx,sy;\n  vector<vector<char> > map(h+2, vector<char>(w+2, '#'));\n  for(int i=1; i<=h; i++){\n    for(int j=1; j<=w; j++){\n      cin >> map[i][j];\n      if(map[i][j]=='%'){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n\n  queue<pair<int,pair<int,int> > > q;\n  q.push(make_pair(0, make_pair(sy,sx)));\n  map[sy][sx]='#';\n  int princess=1e9;\n  int soldier=1e9;\n  while(!q.empty()){\n    int step=q.front().first;\n    int y=q.front().second.first;\n    int x=q.front().second.second;\n    q.pop();\n    for(int i=0; i<4; i++){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(map[ny][nx]!='#'){\n        if(map[ny][nx]=='@') princess = step;\n        if(map[ny][nx]=='$') soldier = min(step, soldier);\n        map[ny][nx] = '#';\n        q.push(make_pair(step+1, make_pair(ny,nx)));\n      }\n    }\n  }\n\n  if(princess<soldier){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n//#define cin2(a,b) scanf(\"%d%lf\",&a,&b)\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dist(x1,y1,x2,y2) (x1-x2)*1LL*(x1-x2)+(y1-y2)*1LL*(y1-y2)\n#define ll long long\n#define db double\n#define ull unsigned ll\n#define lb lower_bound\n#define inf 1e9\n#define mp make_pair\n#define gcd(x,y) __gcd(x,y);\n#define pii pair<int,int>\n#define M 1000000007\n#define pi acos(-1)\n\n\nconst int mx = 202;\nint soldier[mx][mx],prince[mx][mx];\nchar s[mx][mx];\nint r, c;\nbool memo[mx][mx];;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\n\nbool process()\n{\n    int i,j,k;\n    queue<pair<pii,int> > q;\n    for(i=0;i<r;i++) {\n        for(j=0;j<c;j++) {\n            memo[i][j] = false;\n            soldier[i][j] = inf;\n            prince[i][j] = inf;\n            if(s[i][j]=='@') {\n                memo[i][j] = true;\n                q.push(mp(mp(i,j),0));\n                prince[i][j] = 0;\n            }\n        }\n    }\n    while(!q.empty()) {\n        pair<pii,int> tmp = q.front();\n        q.pop();\n        int x = tmp.first.first;\n        int y = tmp.first.second;\n        int v = tmp.second;\n        prince[x][y] = v;\n        for(i=0;i<4;i++) {\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if(tx<0||tx==r||ty<0||ty==c) continue;\n            if(memo[tx][ty]) continue;\n            if(s[tx][ty]=='#') continue;\n            memo[tx][ty] = true;\n            q.push(mp(mp(tx,ty),v+1));\n        }\n    }\n    while(!q.empty()) q.pop();\n    for(i=0;i<r;i++) {\n        for(j=0;j<c;j++) {\n            memo[i][j] = false;\n            if(s[i][j]=='$') {\n                memo[i][j] = true;\n                q.push(mp(mp(i,j),0));\n            }\n        }\n    }\n    while(!q.empty()) {\n        pair<pii,int> tmp = q.front();\n        q.pop();\n        int x = tmp.first.first;\n        int y = tmp.first.second;\n        int v = tmp.second;\n        soldier[x][y] = v;\n        for(i=0;i<4;i++) {\n            int tx = x + dx[i];\n            int ty = y + dy[i];\n            if(tx<0||tx==r||ty<0||ty==c) continue;\n            if(s[tx][ty]=='#') continue;\n            if(memo[tx][ty]) continue;\n            memo[tx][ty] = true;\n            q.push(mp(mp(tx,ty),v+1));\n        }\n    }\n\n    for(i=0;i<r;i++) {\n        //printf(\"%s\\n\",s[i]);\n        for(j=0;j<c;j++) {\n            if(s[i][j]=='%') {\n                //printf(\"i = %d j = %d\\n\",soldier[i][j],prince[i][j]);\n                return soldier[i][j]>prince[i][j];\n            }\n        }\n        //printf(\"\\n\");\n    }\n    return false;\n}\n\n\n\nint main()\n{\n    while(true) {\n        int i,j,k;\n        scanf(\"%d%d\",&r,&c);\n        for(i=0;i<r;i++) scanf(\"%s\",s[i]);\n\n        int ans = process();\n        if(ans) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n        break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef pair<int, int> pii;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n \nbool isRange(int nx, int ny, int w, int h){\n  return (0 <= nx and nx < w and\n          0 <= ny and ny < h);\n}\n \nvoid bfs(queue<vector<int> > &que, vector<vector<int> > &dist , vector<string> &grid){\n  int h = dist.size(), w = dist[0].size();\n  while(not que.empty()){\n    int c = que.front()[0];\n    int x = que.front()[1];\n    int y = que.front()[2];\n    que.pop();\n    for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(not isRange(nx, ny, w, h))continue;\n      if(c + 1 >= dist[ny][nx])continue;\n      if(grid[ny][nx] == '#')continue;\n      dist[ny][nx] = c + 1;\n      que.push(vector<int>{c + 1, nx, ny});\n    }\n  }\n}\n \nint main(){\n  int h, w;\n  std::cin >> h >> w;\n  vector<string> grid(h);\n  pii s, g;\n  set<pii> e;\n  vector<vector<int> > dist_p(h, vector<int>(w, 1e9));\n  vector<vector<int> > dist_e(h, vector<int>(w, 1e9));\n  for (int i = 0; i < h; i++) {\n    std::cin >> grid[i];\n    for (int j = 0; j < w; j++) {\n      if(grid[i][j] == '%')g = pii(j, i);\n      if(grid[i][j] == '@')s = pii(j, i);\n      if(grid[i][j] == '$')e.insert(pii(j, i));\n    }\n  }\n  queue<vector<int> > que;\n  que.push(vector<int>{0, s.first, s.second});\n  dist_p[s.second][s.first] = 0;\n  bfs(que, dist_p, grid);\n \n  for (auto pos: e){\n    dist_e[pos.second][pos.first] = 0;\n    que.push(vector<int>{0, pos.first, pos.second});\n  }\n  bfs(que, dist_e, grid);\n  \n  que.push(vector<int>{0, s.first, s.second});\n  vector< vector<bool> > visited(h, vector<bool>(w,false));\n  visited[s.second][s.first] = true;\n  while(not que.empty()){\n    int c = que.front()[0];\n    int x = que.front()[1];\n    int y = que.front()[2];\n    que.pop();\n    for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if(not isRange(nx, ny, w, h))continue;\n      if(dist_p[ny][nx] >= dist_e[ny][nx])continue;\n      if(grid[ny][nx] == '#')continue;\n      if(visited[ny][nx])continue;\n      visited[ny][nx] = true;\n      que.push(vector<int>{c + 1, nx, ny});\n    }\n  }\n  std::cout << ((visited[g.second][g.first])?\"Yes\":\"No\") << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\nint h,w;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,-1,0,1,0};\nbool fail[5001][200][200]; //iターン目で兵士のいる可能性のある場所\nint mincost[200][200];\ndeque<T> q;\n\nint main()\n{\n\tvector<string> mp;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tmp.push_back(s);\n\t}\n\tbool ans=false;\n\tfill(fail[0][0],fail[5001][0],false);\n\tfill(mincost[0],mincost[200],1e8-1);\n\t//初期配置を定める\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(mp[i][j]=='$')\n\t\t\t\tfail[0][i][j]=true;\n\t\t\tif(mp[i][j]=='@')\n\t\t\t{\n\t\t\t\tq.push_back(T(0,P(i,j)));\n\t\t\t\tmincost[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\t//兵士の移動パターンをすべて調べる\n\tfor(int k=1;k<1001;k++)\n\t{\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(fail[k-1][i][j])\n\t\t\t\t{\n\t\t\t\t\tfor(int l=0;l<5;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx=i+dx[l];\n\t\t\t\t\t\tint ny=j+dy[l];\n\t\t\t\t\t\tif(nx>=0 && nx<h && ny>=0 && ny<w && mp[nx][ny]!='#')\n\t\t\t\t\t\t\tfail[k][nx][ny]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// for(int i=0;i<h;i++)\n\t// {\n\t// \tfor(int j=0;j<w;j++)\n\t// \t{\n\t// \t\tif(fail[1000][i][j])\n\t// \t\t\tcout<<'$';\n\t// \t\telse\n\t// \t\t\tcout<<mp[i][j];\n\t// \t}\n\t// \tcout<<endl;\n\t// }\n\t//BFS\n\twhile(!q.empty())\n\t{\n\t\tT t=q.front();q.pop_front();\n\t\tP p=t.second;\n\t\tif(t.first==1000)\n\t\t\tcontinue;\n\t\tif(mp[p.first][p.second]=='%')\n\t\t{\n\t\t\tans=true;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nx=p.first+dx[i];\n\t\t\tint ny=p.second+dy[i];\n\t\t\tif(nx>=0 && nx<h && ny>=0 && ny<w && mp[nx][ny]!='#')\n\t\t\t{\n\t\t\t\tif(!fail[t.first+1][nx][ny] && mincost[nx][ny]==1e8-1)\n\t\t\t\t{\n\t\t\t\t\tq.push_back(T(t.first+1,P(nx,ny)));\n\t\t\t\t\tmincost[nx][ny]=t.first+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ans)\n\t\tcout<<\"Yes\"<<endl;\n\telse\n\t\tcout<<\"No\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\nint H, W;\nstring S[200];\nint v[200][200];\n\nbool bfs()\n{\n  queue< pair< int, int > > que;\n  memset(v, -1, sizeof(v));\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(S[i][j] == '%') {\n        que.emplace(j, i);\n        v[j][i] = 0;\n      }\n    }\n  }\n  int me = 1 << 30, enemy = 1 << 30;\n\n  while(!que.empty()) {\n    auto p = que.front();\n    que.pop();\n    if(S[p.second][p.first] == '@') me = v[p.first][p.second];\n    else if(S[p.second][p.first] == '$') enemy = min(enemy, v[p.first][p.second]);\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + vx[i], ny = p.second + vy[i];\n      if(nx < 0 || ny < 0 || nx >= W || ny >= H) continue;\n      if(S[ny][nx] == '#') continue;\n      if(~v[nx][ny]) continue;\n      v[nx][ny] = v[p.first][p.second] + 1;\n      que.emplace(nx, ny);\n    }\n  }\n  return (me < enemy);\n}\n\nint main()\n{\n  cin >> H >> W;\n  for(int i = 0; i < H; i++) cin >> S[i];\n  if(bfs()) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\n#define maxn 215\n#define ll long long\n\nchar s[maxn][maxn];\nbool vis[maxn][maxn];\n\nstruct node{\nint x,y;\nint k;\n};\n\nvector<node> sol;\nnode pr;\nnode sa;\nqueue<node> Q;\n\nint main(){\n    int h,w;\n    scanf(\"%d%d\",&h,&w);\n    getchar();\n    for(int i=0;i<h;i++)\n        scanf(\"%s\",s+i);\n    for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n        if(s[i][j]=='@') {\n            pr.x=i;pr.y=j;pr.k=0;\n        }\n        if(s[i][j]=='$'){\n            node so;\n            so.x=i;so.y=j;\n            so.k=1;\n            sol.push_back(so);\n        }\n        if(s[i][j]=='%'){\n            sa.x=i;\n            sa.y=j;\n            sa.k=0;\n        }\n    }\n    memset(vis,false,sizeof(vis));\n    for(int i=0;i<sol.size();i++){\n        Q.push(sol[i]);\n        vis[sol[i].x][sol[i].y]=true;\n    }\n    Q.push(pr);\n    vis[pr.x][pr.y]=true;\n    bool flag=false;\n    while(!Q.empty()){\n            node now=Q.front();\n            Q.pop();\n            int x=now.x;\n            int y=now.y;\n            if(x==sa.x&&y==sa.y){\n                if(now.k==0) flag=true;\n                else flag=false;\n                break;\n            }\n            if(x+1<h&&!vis[x+1][y]&&s[x+1][y]!='#'){\n                node ny=now;\n                ny.x++;\n                vis[x+1][y]=true;\n                Q.push(ny);\n            }\n            if(x-1>=0&&!vis[x-1][y]&&s[x-1][y]!='#'){\n                node ny=now;\n                ny.x--;\n                vis[x-1][y]=true;\n                Q.push(ny);\n            }\n            if(y-1>=0&&!vis[x][y-1]&&s[x][y-1]!='#'){\n                node ny=now;\n                ny.y--;\n                vis[x][y-1]=true;\n                Q.push(ny);\n            }\n            if(y+1<w&&!vis[x][y+1]&&s[x][y+1]!='#'){\n                node ny=now;\n                ny.y++;\n                vis[x][y+1]=true;\n                Q.push(ny);\n            }\n    }\n    if(flag) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstring>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M;\nchar mz[105][105];\nint mark[105][105];\nint ans=0;\nint armyans=0x3f3f3f3f;\nint dx[]= {-1,1,0,0};\nint dy[]= {0,0,-1,1};\nint BFS(int c,int l)\n{\n    memset(mark,0,sizeof(mark));\n    queue<P>que;\n    que.push(P(c,l));\n    while(!que.empty())\n    {\n        c=que.front().first,l=que.front().second;//Tmp=Queue.Top\n        if(mz[c][l]=='%')\n            return mark[c][l];//?束条件:找到?点\n        que.pop();\n        for(int i=0; i<4; i++) //状??展，列出下一?的所有可能状?\n        {\n            int x=c+dx[i];\n            int y=l+dy[i];\n            if(x<0||y<0||x>=N||y>=M)\n                continue;\n            if(!mark[x][y]&&mz[x][y]!='#')//状?合法，?生成新状?NEXT\n            {\n                mark[x][y]=mark[c][l]+1;//NEXT.STEP=Tmp.STEP+1\n                que.push(P(x,y));//加入?列\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&N,&M))\n    {\n        armyans=0x3f3f3f3f;\n        for(int i=0; i<N; i++)\n        {\n            scanf(\"%s\",mz[i]);\n        }\n        for(int i=0; i<N; i++)\n            for(int j=0; j<M; j++)\n            {\n                if(mz[i][j]=='@')\n                    ans=BFS(i,j);\n                if(mz[i][j]=='$')\n                    {\n                        int temp = BFS(i,j);\n                        armyans = min(temp,armyans);\n                    }\n            }\n        if(ans<armyans)\n            printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\nchar maze[250][250];\nint fire[250][250];\nint vis[250][250];\nint a[4]={0,0,1,-1};\nint b[4]={1,-1,0,0};\nint n,m;\nstruct node{\n\tint x,y,z;\n};\nqueue <node> q;\nint flag ;\nvoid bfs(){\n\twhile(!q.empty()){\n\t\tnode k = q.front();\n\t\tq.pop();\n\t\tint x1=k.x,y1=k.y,z=k.z;\n\t\tif(-z>fire[x1][y1]||fire[x1][y1]==0){\n\t\t\tfire[x1][y1]=-z;\n\t\t}\n\t\tfor(int i =0 ; i<4;i++){\n\t\t\tint x2 = x1 + a[i];\n\t\t\tint y2 = y1 + b[i];\n\t\t\tif(x2>=n||y2>=m||x2<0||y2<0||maze[x2][y2]=='#'||vis[x2][y2]==1) continue;\n\t\t\tvis[x2][y2] =1;\n\t\t\tnode l ;\n\t\t\tl.x=x2,l.y=y2,l.z=z+1;\n\t\t\tq.push(l);\n\t\t}\n\t}\n}\nvoid dfs(int x,int y,int z){\n\tif(maze[x][y]=='%'){\n\t\tflag= true;\n\t}\n\tfor(int i  = 0;i< 4;i++){\n\t\tint x2 =x+a[i];\n\t\tint y2 =y+b[i];\n\t\tif(x2>=n||y2>=m||x2<0||y2<0||maze[x2][y2]=='#'||vis[x2][y2]==1)continue;\n\t\tif(fire[x2][y2]==0||(z+1)<-fire[x2][y2]){\n\t\t\tvis[x][y]=1;\n\t\t\tdfs(x2,y2,z+1);\n\t\t}\n\t}\n}\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m)){\n\t\tflag = false;\n\t\tfor(int i = 0 ; i< n; i ++){\n\t\t\tscanf(\"%s\",maze[i]);\n\t\t}\n\t\tmemset(fire,0,sizeof(fire));\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j< m; j++){\n\t\t\t\tif(maze[i][j]=='$'){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\t\t\tvis[i][j] =1;\n\t\t\t\t\tnode k;\n\t\t\t\t\tk.x=i,k.y=j,k.z=1;\n\t\t\t\t\tq.push(k);\n\t\t\t\t\tbfs();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i =0 ;i<n;i++){\n\t\t\tfor(int j =0 ;j< m ;j++){\n\t\t\t\tif(maze[i][j]=='@'){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t\tdfs(i,j,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint r, c;\nint dx[]={0, 0, 1, -1};\nint dy[]={1, -1, 0, 0};\nchar str[205][205];\nint dis[205][205];\nint chk[205][205];\n\nvoid bfs(int i, int j){\n    int a, b, tx, ty;\n    queue< pair<int,int> > qu;\n    pair<int, int> p;\n    memset(chk, 0, sizeof chk);\n    for(a=0; a<r; ++a) for(b=0; b<c; ++b) dis[a][b]=4000005;\n    chk[i][j]=1;\n    qu.push(make_pair(i, j));\n    dis[i][j]=0;\n    while(!qu.empty()){\n        p=qu.front(); qu.pop();\n        for(a=0; a<4; ++a){\n            tx=dx[a]+p.first; ty=dy[a]+p.second;\n            if(tx>=0 && tx<r && ty>=0 && ty<c && !chk[tx][ty] && str[tx][ty]!='#'){\n                chk[tx][ty]=1;\n                dis[tx][ty]=dis[p.first][p.second]+1;\n                qu.push(make_pair(tx, ty));\n            }\n        }\n    }\n}\n\nint main(){\n    int i, j, k;\n    int m1, m2=4000005;\n    scanf(\"%d %d\", &r, &c);\n    for(i=0; i<r; ++i) scanf(\"%s\", str[i]);\n    for(i=0; i<r; ++i){\n        for(j=0; j<c; ++j){\n            if(str[i][j]=='\\%'){\n                bfs(i, j);\n                i=r; j=c;\n            }\n        }\n    }\n    for(i=0; i<r; ++i){\n        for(j=0; j<c; ++j){\n            if(str[i][j]=='@') m1=dis[i][j];\n            else if(str[i][j]=='$') m2=min(m2, dis[i][j]);\n        }\n    }\n\n    //cout << m1 << \" \" << m2 << endl;\n\n    if(m1<m2) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4]={1, 0, 0, -1};\nint dy[4]={0, 1, -1, 0};\n\nint main(){\n  int h,w;\n  cin >> h >> w;\n\n  int sx,sy;\n  vector<vector<char> > map(h+2, vector<char>(w+2, '#'));\n  for(int i=1; i<=h; i++){\n    for(int j=1; j<=w; j++){\n      cin >> map[i][j];\n      if(map[i][j]=='%'){\n        sy=i;\n        sx=j;\n      }\n    }\n  }\n\n  queue<pair<int,pair<int,int> > > q;\n  q.push(make_pair(0, make_pair(sy,sx)));\n  map[sy][sx]='#';\n  int princess=1e9;\n  int soldier=1e9;\n  while(!q.empty()){\n    int step=q.front().first;\n    int y=q.front().second.first;\n    int x=q.front().second.second;\n    q.pop();\n    for(int i=0; i<4; i++){\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(map[ny][nx]!='#'){\n        if(map[ny][nx]=='@') princess = step;\n        if(map[ny][nx]=='$') soldier = min(step, soldier);\n        map[ny][nx] = '#';\n        q.push(make_pair(step+1, make_pair(ny,nx)));\n      }\n    }\n  }\n\n  if(princess<soldier){\n    cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(i = 0; i<n; i++)\n#define repl(i,n) for(i = 1; i<=n; i++)\n\n#define sz(x)   (int)x.size()\n#define pb      push_back\n#define all(x)  x.begin(),e.end()\n#define uu      first\n#define vv  second\n#define mem(x,y) memset(x,y,sizeof(x))\n#define sdi(x) scanf(\"%d\",&x)\n#define sdii(x,y) scanf(\"%d %d\",&x,&y)\n#define sdiii(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sdl(x) scanf(\"%lld\",&x)\n#define sdll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define sdlll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define sds(x) scanf(\"%s\",s);\n#define pfi(x) printf(\"%d\\n\",x)\n#define pfii(x,y) printf(\"%d %d\\n\",x,y)\n#define pfiii(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define pfl(x) printf(\"%lld\\n\",x)\n#define pfll(x,y) printf(\"%lld %lld\\n\",x,y)\n#define pflll(x,y,z) printf(\"%lld %lld %lld\\n\",x,y,z)\n\n#define eps 1e-9\n#define OK  cerr<< \"OK\" << '\\n'\n#define DB(x) cerr << #x \" = \" << x << '\\n'\n\n#define FRE(i,a,b) for(i = a; i<=b; i++)\n#define FRL(i,a,b) for(i = a; i<b; i++)\n#define un(x) x.erase(unique(all(x)),x.end())\n#define sf(x) scanf(\"%d\",&x)\n#define sff(x,y) scanf(\"%d %d\",&x,&y)\n#define sfff(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sl(x) scanf(\"%lld\",&x)\n#define sll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define slll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define D(x)        cerr << #x \" = \" << x << '\\n'\n#define DBG         cerr << \"Hi\" << '\\n'\n#define PI          acose(-1.00)\n#define xx          first\n#define yy          second\n\ntypedef double db;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\ninline int setBit(int N, int pos) { return N=N|(1<<pos);}\ninline int resetBit(int N, int pos) {return N=N &~(1<<pos);}\ninline bool checkBit(int N, int pos) {return (bool) (N & (1<<pos));}\n\n\n int fx[] = {+0, +0, +1, -1, +1, -1, +1};\n int fy[] = {-1, +1, +0, +0, +1, -1, -1};\n\n#define MAX         200\n\nint R, C;\nchar A[MAX+10][MAX+10];\nqueue<pii> q;\nint distSol[MAX+10][MAX+10];\nbool vis[MAX+10][MAX+10];\n\nbool ok(pii a)\n{\n    if(a.xx >= 0 && a.xx <R && a.yy >= 0 && a.yy < C)\n        return true;\n    return false;\n}\n\nvoid bfs()\n{\n    while(!q.empty())\n    {\n        pii nw = q.front();\n        q.pop();\n        for(int i = 0; i<4; i++)\n        {\n            pii tmp = nw;\n            tmp.xx += fx[i];\n            tmp.yy += fy[i];\n            if(ok(tmp) && vis[tmp.xx][tmp.yy] == 0 && A[tmp.xx][tmp.yy] != '#')\n            {\n                distSol[tmp.xx][tmp.yy] = distSol[nw.xx][nw.yy] + 1;\n                vis[tmp.xx][tmp.yy] = true;\n                q.push(tmp);\n            }\n        }\n    }\n}\n\npii princess, dest;\n\nint dist[MAX+10][MAX+10];\nbool bfsPrincess()\n{\n    mem(vis,0);\n    vis[princess.xx][princess.yy] = true;\n    dist[princess.xx][princess.yy] = 0;\n    q.push(princess);\n    while(!q.empty())\n    {\n        pii nw = q.front();\n        q.pop();\n        for(int i = 0; i<4; i++)\n        {\n            pii tmp = nw;\n            tmp.xx += fx[i];\n            tmp.yy += fy[i];\n            int cur = dist[nw.xx][nw.yy] + 1;\n            if(ok(tmp) && vis[tmp.xx][tmp.yy] == 0 && A[tmp.xx][tmp.yy] != '#' && distSol[tmp.xx][tmp.yy] > cur)\n            {\n                dist[tmp.xx][tmp.yy] = cur;\n                vis[tmp.xx][tmp.yy] = true;\n                q.push(tmp);\n            }\n        }\n    }\n    if(vis[dest.xx][dest.yy])\n        return true;\n    return false;\n}\n\nint main()\n{\n    /// freopen(\"in.txt\", \"r\", stdin);\n    /// freopen(\"out.txt\", \"w\", stdout);\n    int i, j, cs, t;\n    mem(distSol,63);\n    sff(R,C);\n    FRL(i,0,R)\n        scanf(\"%s\",A[i]);\n    for(i = 0; i<R; i++)\n    {\n        for(j = 0; j<C; j++)\n        {\n            if(A[i][j] == '@')\n                princess = {i,j};\n            else if(A[i][j] == '%')\n                dest = {i,j};\n            else if(A[i][j] == '$')\n                q.push({i,j}),vis[i][j] = true, distSol[i][j] = 0;\n        }\n    }\n    bfs();\n//    for(int i = 0; i<R; i++)\n//    {\n//        for(int j = 0; j<C; j++)\n//            cout << distSol[i][j] << \" \" ;\n//        cout << endl;\n//    }\n    if(bfsPrincess())\n        printf(\"Yes\\n\");\n    else\n        printf(\"No\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n#define pii pair<int, int>\n#define tii tuple<int, int, int>\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nqueue<pii> que;\n\nint main(void){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for (int i = 0; i < h; i++) cin >> s[i];\n    vector<vector<int> > g(h, vector<int>(w, 1e9));\n    \n    int py, px, hy, hx;\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) \n        if (s[i][j] == '$') que.push(make_pair(i,j)), g[i][j] = 0;\n        else if (s[i][j] == '@') py = i, px = j;\n        else if (s[i][j] == '%') hy = i, hx = j;\n        else if (s[i][j] == '#') g[i][j] = -1;\n        \n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int ty = p.first, tx = p.second, node = g[ty][tx];\n        for (int i = 0; i < 4; i++) {\n            int ny = ty + dy[i];\n            int nx = tx + dx[i];\n            if (ny < 0 || ny >= h || nx < 0 || nx >= w || g[ny][nx] == -1) continue;\n            if (g[ny][nx] > node+1) {\n                g[ny][nx] = node+1;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    int sol = g[hy][hx];\n    \n    g[py][px] = 0;\n    que.push(make_pair(py,px));\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int ty = p.first, tx = p.second, node = g[ty][tx];\n        for (int i = 0; i < 4; i++) {\n            int ny = ty + dy[i];\n            int nx = tx + dx[i];\n            if (ny < 0 || ny >= h || nx < 0 || nx >= w || g[ny][nx] == -1) continue;\n            if (g[ny][nx] > node+1) {\n                g[ny][nx] = node+1;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n    if (sol == g[hy][hx]) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint h,w,mini[210][210];\nstring s[210];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nvoid bfs(int sx,int sy) {\n  rep(i,h) rep(j,w) mini[i][j] = INT_MAX;\n  deque<ii> deq;\n  deq.push_back(ii(sx,sy));\n  mini[sy][sx] = 0;\n  while( !deq.empty() ) {\n    ii cur = deq.front(); deq.pop_front();\n    rep(i,4) {\n      int nx = cur.first  + dx[i];\n      int ny = cur.second + dy[i];\n      if( !( 0 <= nx && nx < w && 0 <= ny && ny < h) ) continue;\n      if( s[ny][nx] == '#' ) continue;\n      if( mini[ny][nx] > mini[cur.second][cur.first] + 1 ) {\n        mini[ny][nx] = mini[cur.second][cur.first] + 1;\n        deq.push_back(ii(nx,ny));\n      }\n    }\n  }\n}\n\nvoid compute() {\n  int sx=-1,sy, gx=-1,gy;\n  vector<ii> vec;\n  rep(i,h) rep(j,w) {\n    if( s[i][j] == '@' ) sx = j, sy = i, s[i][j] = '.';\n    if( s[i][j] == '%' ) gx = j, gy = i;\n    if( s[i][j] == '$' ) vec.push_back(ii(j,i)), s[i][j] = '.';\n  }\n  bfs(gx,gy);\n  if( mini[sy][sx] == INT_MAX ) {\n    puts(\"No\");\n    return;\n  }\n  rep(i,(int)vec.size()) {\n    ii tmp = vec[i];\n    if( mini[sy][sx] >= mini[tmp.second][tmp.first] ) {\n      puts(\"No\");\n      return;\n    }\n  }\n  puts(\"Yes\");\n}\n\nint main() {\n  cin >> h >> w;\n  rep(i,h) cin >> s[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<bitset>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<list>\n#include<deque>\n#include<queue>\nusing namespace std;\nint n,H,W;\nconst int maxn = 2e2+2;\nconst int INF = 1e9;\nint labyrinth[maxn][maxn],scnt;\nint shortest;\nint pshort,sshort,eshort,goal;\nbool tf;\n\nstruct pt\n{\n    int x,y;\n} soldier[maxn],princess,escape;\nchar ch;\nbool vis[maxn][maxn];\n\nint dfs(int x,int y,int cur_length)\n{\n    int temp;\n    //printf(\"%d %d, H:%d W:%d\\n\",x,y,H,W);\n    //labyrinth[y][x] = 3;\n    vis[y][x] = true;\n    if(x>0&&labyrinth[y][x-1]&&!vis[y][x-1])\n    {\n        if(labyrinth[y][x-1] == goal)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x-1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(x<W-1&&labyrinth[y][x+1]&&!vis[y][x+1])\n    {\n        if(labyrinth[y][x+1] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x+1,y,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y>0&&labyrinth[y-1][x]&&!vis[y-1][x])\n    {\n        if(labyrinth[y-1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y-1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    if(y<H-1&&labyrinth[y+1][x]&&!vis[y+1][x])\n    {\n        if(labyrinth[y+1][x] == 2)\n        {\n            return cur_length+1;\n        }\n        if((temp = dfs(x,y+1,cur_length+1))<shortest)\n        {\n            shortest = temp;\n        }\n    }\n    return shortest;\n}\n\nint main()\n{\n    //freopen(\"1002.txt\",\"r\",stdin);\n    //freopen(\"ans.txt\",\"w+\",stdout);\n    while(~scanf(\"%d%d\",&H,&W))\n    {\n        tf = true;\n        scnt = 0;\n        shortest = INF;\n        memset(labyrinth,-1,sizeof(labyrinth));\n        getchar();\n        for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                while((ch = getchar())=='\\n');\n                switch(ch)\n                {\n                case '@':\n                    princess.x = j;\n                    princess.y = i,labyrinth[i][j] = 5;\n                    break;\n                case '.':\n                    labyrinth[i][j] = 1;\n                    break;\n                case '$':\n                    soldier[scnt].x = j;\n                    soldier[scnt++].y = i;\n                    labyrinth[i][j] = 1;\n                    break;\n                case '%':\n                    labyrinth[i][j] = 2;\n                    escape.x = j;\n                    escape.y = i;\n                    break;\n                case '#':\n                    labyrinth[i][j] = 0;\n                    break;\n                }\n            }\n        }\n        memset(vis,false,sizeof(vis));\n        goal = 2;\n        pshort = dfs(princess.x,princess.y,0);\n        //printf(\"pshort:%d\\n\",pshort);\n\n        goal = 5;\n\n        memset(vis,false,sizeof(vis));\n        eshort = dfs(escape.x,escape.y,0);\n        //printf(\"eshort:%d\\n\",eshort);\n        if(eshort<pshort)\n            pshort = eshort;\n        /*for(int i = 0; i<H; ++i)\n        {\n            for(int j = 0; j < W; ++ j)\n            {\n                if(i == princess.y&&j == princess.x)\n                    printf(\"X\");\n                else\n                printf(\"%d\",labyrinth[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        if(!scnt&&pshort!=INF)\n        {\n            tf = true;\n        }\n        else\n        {\n            if(pshort != INF)\n            {\n                goal = 2;\n                for(int i = 0; i < scnt; ++i)\n                {\n                    memset(vis,false,sizeof(vis));\n                    shortest = INF;\n                    sshort = dfs(soldier[i].x,soldier[i].y,0);\n                    //printf(\"sshort:%d\\n\",sshort);\n                    if(sshort <= pshort)\n                    {\n                        tf = false;\n                        break;\n                    }\n                }\n\n            }\n            else\n                tf = false;\n\n        }\n        if(tf)\n        {\n            printf(\"Yes\\n\");\n        }\n        else\n        {\n            printf(\"No\\n\");\n        }\n\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint h, w;\nchar s[210][210];\nint d[210][210];\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> h >> w;\n    int sy = 0, sx = 0;\n    rep(i, 0, h){\n        rep(j, 0, w){\n            cin >> s[i][j];\n            if(s[i][j] == '%'){\n                sy = i; sx = j;\n            }\n        }\n    }\n    rep(i, 0, h) rep(j, 0, w) d[i][j] = INF;\n    d[sy][sx] = 0;\n    queue<P> q;\n    q.push(P(sy, sx));\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n        int y = p.first;\n        int x = p.second;\n        rep(i, 0, 4){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(!contain(ny, nx) || d[ny][nx] != INF || s[ny][nx] == '#') continue;\n            d[ny][nx] = d[y][x] + 1;\n            q.push(P(ny, nx));\n        }\n    }\n    int MIN = INF, princess;\n    rep(i, 0, h){\n        rep(j, 0, w){\n            if(s[i][j] == '@') princess = d[i][j];\n            else if(s[i][j] == '$') chmin(MIN, d[i][j]);\n        }\n    }\n    if(princess < MIN) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <cstdio>\n    #include <string>\n    #include <cstring>\n    #include <deque>\n    #include <list>\n    #include <queue>\n    #include <stack>\n    #include <vector>\n    #include <utility>\n    #include <algorithm>\n    #include <map>\n    #include <set>\n    #include <complex>\n    #include <cmath>\n    #include <limits>\n    #include <climits>\n    #include <ctime>\n    #include <cassert>\n    using namespace std;\n     \n    #define rep(i,a,n) for(int i=a; i<n; i++)\n    #define repr(i,a,n) for(int i=a; i>=n; i--)\n    #define pb(a) push_back(a)\n    #define fr first\n    #define sc second\n    #define INF 999999999\n     \n    #define X real()\n    #define Y imag()\n    #define EPS (1e-10)\n    #define EQ(a,b) (abs((a) - (b)) < EPS)\n    #define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n    #define LE(n, m) ((n) < (m) + EPS)\n    #define LEQ(n, m) ((n) <= (m) + EPS)\n    #define GE(n, m) ((n) + EPS > (m))\n    #define GEQ(n, m) ((n) + EPS >= (m))\n     \n    typedef vector<int> VI;\n    typedef vector<VI> MAT;\n    typedef pair<int, int> pii;\n    typedef long long int ll;\n     \n    typedef complex<double> P;\n    typedef pair<P, P> L;\n    typedef pair<P, double> C;\n     \n    int dy[]={0, 0, 1, -1};\n    int dx[]={1, -1, 0, 0};\n    int const MOD = 1000000007;\n     \n    namespace std {\n        bool operator<(const P& a, const P& b) {\n            return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n        }\n    }\n     \n    char board[510][510];\n    bool isthrough[510][510];\n    int dist[510][510];\n     \n    int main() {\n        int H, W; cin >> H >> W;\n        memset(isthrough, false, sizeof(isthrough));\n        rep(i,0,H) rep(j,0,W) dist[i][j] = -1;\n        pii escape;\n        rep(i,0,H) rep(j,0,W) {\n            cin >> board[i][j];\n            if(board[i][j] == '%') {\n                escape.first = i;\n                escape.second = j;\n                dist[i][j] = 0;\n                isthrough[i][j] = true;\n            }\n        }\n     \n        int soldier = INF;\n        int princess;\n        queue<pii> q;\n        q.push(escape);\n        while(!q.empty()) {\n            pii t = q.front(); q.pop();\n            int x = t.fr, y = t.sc;\n            int prev = dist[x][y];\n            if(board[x][y] == '$') soldier = min(soldier, dist[x][y]);\n            if(board[x][y] == '@') princess = dist[x][y];\n            if(x != 0 && board[x-1][y] != '#' && !isthrough[x-1][y]) {\n                isthrough[x-1][y] = true;\n                dist[x-1][y] = prev + 1;\n                q.push(pii(x-1, y));\n            }\n            if(x != H-1 && board[x+1][y] != '#' && !isthrough[x+1][y]) {\n                isthrough[x+1][y] = true;\n                dist[x+1][y] = prev + 1;\n                q.push(pii(x+1, y));\n            }\n            if(y != 0 && board[x][y-1] != '#' && !isthrough[x][y-1]) {\n                isthrough[x][y-1] = true;\n                dist[x][y-1] = prev + 1;\n                q.push(pii(x, y-1));\n            }\n            if(y != W-1 && board[x][y+1] != '#' && !isthrough[x][y+1]) {\n                isthrough[x][y+1] = true;\n                dist[x][y+1] = prev + 1;\n                q.push(pii(x, y+1));\n            }\n        }\n     \n        if(princess < soldier) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <cstdio>\n//#include <cstdlib>\n//#include <cstring>\n//#include <cmath>\n//#include <string>\n//#include <algorithm>\n//#include <functional>\n//#include <set>\n//#include <map>\n//#include <queue>\n//#include <stack>\n//#include <vector>\n//\n//using namespace std;\n//const int maxn = 1000;\n//int k, sx, sy, ex, ey;\n//int vis[maxn][maxn];\n//int dirt[4][2] = {1,0,0,1,-1,0,0,-1};\n//struct node{\n//    int x, y, step;\n//};\n//\n//int judge(int x, int y)\n//{\n//    if(x < 0 || x >= h || y < 0 || y >= w)\n//        return 1 ;\n//    return vis[x][y];\n//}\n//\n//void bfs()\n//{\n//\n//    queue<node>q;\n//    node a, b, next;\n//    a.x = sx;\n//    a.y = sy;\n//    a.step = 0;\n//    q.push(a);\n//    vis[sx][sy] = 1;\n//    while(!q.empty()){\n//        b = q.front();\n//        q.pop();\n//        if(b.x == ex && b.y == ey){\n//            k = b.step;\n//            return;\n//        }\n//        for(int i = 0 ; i < 8 ; i++){\n//        next.x = b.x + dirt[i][0];\n//        next.y = b.y + dirt[i][1];\n//        if(judge(next.x, next.y)) continue;\n//        next.step = b.step + 1;\n//        q.push(next);\n//        vis[next.x][next.y] = 1;\n//        }\n//    }\n//}\n//\n//int main()\n//{\n//    char y1, y2, y3, y4;\n//    while(~scanf(\"%c%c %c%c\",&y1,&y2,&y3,&y4)){\n//    k = 0 ;\n//    memset(vis , 0 , sizeof(vis));\n//    sx = y1 - 'a' , sy = y2 - '1';\n//    ex = y3 - 'a' , ey = y4 - '1';\n//    bfs();\n//    printf(\"To get from %c%c to %c%c takes %d knight moves.\\n\", y1,y2,y3,y4,k);\n//    getchar();\n//    }\n//    return 0;\n//}\n\n\n\n\n\n\n\n\n\n\n\n\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn  =  202;\nint dirt[4][2] = {1,0,0,1,-1,0,0,-1};\nint sx,sy;\nint ex,ey;\nint h,w,k;\nchar mapp[maxn][maxn];\nint vis[maxn][maxn];\nstruct node\n{\n    int x,y,step;\n};\nbool judge1(int x,int y)\n{\n    if(x >= 0 && x < h && y >= 0 && y < w && mapp[x][y] != '#' && mapp[x][y] != '$'&& vis[x][y] == 0)\n        return 1;\n    return 0;\n}\n\nbool judge2(int x,int y)\n{\n    if(x >= 0 && x < h && y >= 0 && y < w && mapp[x][y] != '#' && vis[x][y] == 0)\n        return 1;\n    return 0;\n}\n\nint bfs1(int x, int y)\n{\n\n    queue<node>q;\n    node a, b, next;\n    a.x = x;\n    a.y = y;\n    a.step = 0;\n    q.push(a);\n    vis[x][y] = 1;\n    while(!q.empty()){\n        b = q.front();\n        q.pop();\n        if(b.x == ex && b.y == ey){\n            return b.step;\n        }\n        for(int i = 0 ; i < 4 ; i++){\n            next.x = b.x + dirt[i][0];\n            next.y = b.y + dirt[i][1];\n        if(!judge1(next.x, next.y)) continue;\n        next.step = b.step + 1;\n        q.push(next);\n        vis[next.x][next.y] = 1;\n        }\n    }\n    return 10000;\n}\n\nint bfs2(int x, int y)\n{\n\n    queue<node>q;\n    node a, b, next;\n    a.x = x;\n    a.y = y;\n    a.step = 0;\n    q.push(a);\n    vis[x][y] = 1;\n    while(!q.empty()){\n        b = q.front();\n        q.pop();\n        if(b.x == ex && b.y == ey){\n            return b.step;\n        }\n        for(int i = 0 ; i < 4 ; i++){\n            next.x = b.x + dirt[i][0];\n            next.y = b.y + dirt[i][1];\n        if(!judge2(next.x, next.y)) continue;\n        next.step = b.step + 1;\n        q.push(next);\n        vis[next.x][next.y] = 1;\n        }\n    }\n    return 10000;\n}\nint main()\n{\n    while(scanf(\"%d%d\",&h,&w)!=EOF){\n        memset(vis,0,sizeof(vis));\n        for(int i =0 ; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>mapp[i][j];\n                if(mapp[i][j] == '@'){\n                    sx = i;\n                    sy = j;\n                }\n                if(mapp[i][j] == '%'){\n                    ex = i;\n                    ey = j;\n                }\n            }\n        }\n        int maxx = 10000;\n        for(int i = 0 ; i < h; i++){\n            for(int j = 0; j < w; j++){\n                memset(vis,0,sizeof(vis));\n                if(mapp[i][j] == '$')\n                    maxx = min(maxx,bfs2(i,j));\n            }\n        }\n        memset(vis,0,sizeof(vis));\n        k = bfs1(sx, sy);\n        //cout << k << endl;\n        if(k == 10000){\n            cout<<\"No\"<<endl;\n            continue;\n        }\n        if(k>=maxx)\n            cout<<\"No\"<<endl;\n        else cout<<\"Yes\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int inf = 1 << 28;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nint n, m;\nvector<vector<int> > d;\nvector<string> vs;\n\nvoid bfs(int x, int y) {\n    queue<P> que;\n    que.push(P(x,y));\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        x = p.first;\n        y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && vs[nx][ny] != '#' && d[nx][ny] > d[x][y] + 1) {\n                d[nx][ny] = d[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n}\n\nint main() {\n    int sx, sy, gx, gy;\n    vector<int> sr, sc;\n    cin >> n >> m;\n    vs.resize(n);\n    for (auto& i : vs) cin >> i;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (vs[i][j] == '@') sx = i, sy = j;\n            if (vs[i][j] == '$') sr.push_back(i), sc.push_back(j);\n            if (vs[i][j] == '%') gx = i, gy = j;\n        }\n    }\n    d.resize(n);\n    for (auto& i : d) i.resize(m, inf);\n\n    for (int i = 0; i < sr.size(); i++) {\n        d[sr[i]][sc[i]] = 0;\n        bfs(sr[i], sc[i]);\n    }\n\n    queue<P> que;\n    que.push(P(sx,sy));\n    vector<vector<int> > dist(n, vector<int>(m,inf));\n    dist[sx][sy] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first;\n        int y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (0 <= nx && nx < n && 0 <= ny && ny < m && vs[nx][ny] != '#' \n                && dist[nx][ny] > dist[x][y] + 1 && dist[x][y] + 1 < d[nx][ny]) {\n                dist[nx][ny] = dist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n\n    cout << (dist[gx][gy] != inf ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nqueue<pair<int,int> > q;\nint n,m;\nint w[205][205];\nint d[205][205];\nint f[205][205];\nchar op;\nconst int dx[4] = {0,0,1,-1};\nconst int dy[4] = {1,-1,0,0};\nint sx,sy;\n\nvoid bfs(int x,int y)\n{\n\tpair<int,int> now,temp;\n\tnow = make_pair(x,y);\n\td[x][y] = 0;\n\tq.push(now);\n\tint nx,ny;\n\twhile (!q.empty())\n\t{\n\t\tnow = q.front();\n\t\tq.pop();\n\t\tx = now.first;\n\t\ty = now.second;\n\t\tfor (int i=0;i<4;i++)\n\t\t{\n\t\t\tnx = x+dx[i];\n\t\t\tny = y+dy[i];\n\t\t\tif (d[nx][ny] > d[x][y]+1 && w[nx][ny])\n\t\t\t{\n\t\t\t\td[nx][ny] = d[x][y]+1;\n\t\t\t\ttemp = make_pair(nx,ny);\n\t\t\t\tq.push(temp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool solve(int x,int y)\n{\n\tpair<int,int> now,temp;\n\tf[x][y] = 0;\n\tnow = make_pair(x,y);\n\tq.push(now);\n\tint nx,ny;\n\twhile (!q.empty())\n\t{\n\t\tnow = q.front();\n\t\tq.pop();\n\t\tx = now.first;\n\t\ty = now.second;\n\t\tif (w[x][y] == 5) return 1;\n\t\tfor (int i=0;i<4;i++)\n\t\t{\n\t\t\tnx = x+dx[i];\n\t\t\tny = y+dy[i];\n\t\t\tif (w[nx][ny] == 0 || f[nx][ny] != f[0][0]) continue;\n\t\t\tf[nx][ny] = f[x][y]+1;\n\t\t\tif (f[nx][ny] < d[nx][ny])\n\t\t\t{\n\t\t\t\ttemp = make_pair(nx,ny);\n\t\t\t\tq.push(temp);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(w,0,sizeof(w));\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(f,0x3f,sizeof(f));\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\" %c\",&op);\n\t\t\tif (op == '@')\n\t\t\t{\n\t\t\t\tw[i][j] = 4;\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t}\n\t\t\tif (op == '%')\n\t\t\t{\n\t\t\t\tw[i][j] = 5;\n\t\t\t}\n\t\t\tif (op == '$')\n\t\t\t{\n\t\t\t\tw[i][j] = 2;\n\t\t\t}\n\t\t\tif (op == '.')\n\t\t\t{\n\t\t\t\tw[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"n=%d m=%d\\n\",n,m);\n\tfor (int i=0;i<=n+1;i++)\n\t{\n\t\tfor (int j=0;j<=m+1;j++)\n\t\t\tprintf(\"%d\",w[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tif (w[i][j] == 2)\n\t\t\t{\n\t\t\t\tbfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (solve(sx,sy))\n\t{\n\t\tprintf(\"Yes\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { -1,0,1,0 };\nint d2[4] = { 0,1,0,-1 };\nint main() {\n\tint h, w; cin >> h >> w;\n\tchar pal[202][202];\n\trep(i, 202) {\n\t\trep(j, 202) {\n\t\t\tpal[i][j] = '#';\n\t\t}\n\t}\n\tstring s; P chk;\n\trep1(i, h) {\n\t\tcin >> s;\n\t\trep1(j, w) {\n\t\t\tpal[i][j] = s[j - 1];\n\t\t\tif (s[j - 1] == '%') {\n\t\t\t\tchk = { i,j };\n\t\t\t}\n\t\t}\n\t}\n\tint d[202][202];\n\trep(i, 202) {\n\t\trep(j, 202) {\n\t\t\td[i][j] = (int)MOD;\n\t\t}\n\t}\n\td[chk.first][chk.second] = 0;\n\tvector<P> v; int used[202][202] = {};\n\tv.push_back(chk);\n\twhile (!v.empty()) {\n\t\tint nx = v[0].first; int ny = v[0].second;\n\t\tv.erase(v.begin());\n\t\trep(i, 4) {\n\t\t\tif (used[nx + d1[i]][ny + d2[i]] == 0 && pal[nx + d1[i]][ny + d2[i]] != '#') {\n\t\t\t\tused[nx + d1[i]][ny + d2[i]] = 1;\n\t\t\t\tv.push_back({ nx + d1[i],ny + d2[i] });\n\t\t\t\td[nx + d1[i]][ny + d2[i]] = min(d[nx + d1[i]][ny + d2[i]], d[nx][ny] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt1; int cnt2 = (int)MOD;\n\trep1(i, h) {\n\t\trep1(j, w) {\n\t\t\tif (pal[i][j] == '@') {\n\t\t\t\tcnt1 = d[i][j];\n\t\t\t}\n\t\t\telse if (pal[i][j] == '$') {\n\t\t\t\tcnt2 = min(cnt2, d[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(cnt1>=cnt2){\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define ll long long\n#define ull unsigned long long\n#define pb push_back\n#define mem(arr,val)    memset(arr,val,sizeof(arr))\n#define mp make_pair\n#define pii pair<int,int>\n#define F first\n#define S second\n#define sz(x) (int)(x).size()\n#define nopos string::npos\n#define fr(i,a,b) for(i=a;i<=b;i++)\n#define frn(i,a,b) for(i=a;i>=b;i--)\nbool visited[500][500];\nint level[500][500],r,c,i,j,eR,eC,dx[]= {+1,-1,+0,+0},dy[]= {0,0,+1,-1};\nchar grid[500][500];\nint pR,pC;\n\nint bfs(int sr,int sc)\n{\n    int in;\n    queue<pii > q;\n    q.push({sr,sc});\n    level[sr][sc]=0;\n    visited[sr][sc]=1;\n\n    while(!q.empty())\n    {\n        pii u=q.front();\n        q.pop();\n\n        fr(in,0,3)\n        {\n            int vr=u.first+dx[in], vc=u.second+dy[in];\n            if(vr<0 || vr>=r || vc<0 || vc>=c)\n                continue;\n\n            if(!visited[vr][vc] && grid[vr][vc]!='#')\n            {\n                visited[vr][vc]=1;\n                q.push({vr,vc});\n                level[vr][vc]=level[u.first][u.second]+1;\n            }\n        }\n\n    }\n\n    return level[eR][eC];\n}\n\nint main()\n{\n    //freopen(\"d://i.txt\",\"r\",stdin);\n    //freopen(\"d://o.txt\",\"w\",stdout);\n    cin>>r>>c;\n\n    vector<pii > pos;\n\n    fr(i,0,r-1)\n    {\n        getchar();\n        fr(j,0,c-1)\n        {\n            scanf(\"%c\",&grid[i][j]);\n            if(grid[i][j]=='%')\n                eR=i, eC=j;\n            else if(grid[i][j]=='@')\n                pR=i, pC=j;\n        }\n    }\n//    fr(i,0,r-1)\n//    {\n//        fr(j,0,c-1)\n//        printf(\"%c \",grid[i][j]);\n//\n//        cout<<'\\n';\n//    }\n    int tim1=bfs(pR,pC),tim2=10000;\n\n    memset(visited,0,sizeof(visited));\n\n    bfs(eR,eC);\n\n    fr(i,0,r-1)\n     fr(j,0,c-1)\n      {\n          if(grid[i][j]=='$')\n          tim2=min(tim2,level[i][j]);\n      }\n\n    //cout<<tim1<<' '<<tim2<<'\\n';\n\n    printf(tim1<tim2?\"Yes\\n\":\"No\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int N = 200;\n\nstruct point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nchar m[N][N];\nint p = INF, s = INF;\n\nint bfs(int h, int w, point start, point goal){\n    int dis[N][N];\n    queue<point> q;\n    memset(dis, -1, sizeof(dis));\n\n    dis[start.y][start.x] = 0;\n    q.push(start);\n\n    point u;\n    while(!q.empty()){\n        u = q.front(); q.pop();\n        rep(i,4){\n            point next;\n            next.x = u.x + dx[i];\n            next.y = u.y + dy[i];\n            if(next.y >= h || next.y < 0 || next.x >= w || next.x < 0) continue;\n            if(dis[next.y][next.x] == -1 && m[next.y][next.x] != '#'){\n                dis[next.y][next.x] = dis[u.y][u.x] + 1;\n                if(dis[next.y][next.x] > p || dis[next.y][next.x] > s) break;\n                if(next.y == goal.y && next.x == goal.x) return dis[goal.y][goal.x];\n                q.push(next);\n            }\n        }\n    }\n    if(dis[goal.y][goal.x] == -1) return INF;\n    else return dis[goal.y][goal.x];\n}\n\n\nint main(){\n    int h, w;\n    point start, goal;\n    cin >> h >> w;\n    rep(i,h){\n        scanf(\"%s\", m[i]);\n        rep(j,w){\n            if(m[i][j] == '%') goal = {j, i};\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            if(m[i][j] == '@'){\n                start = {j, i};\n                p = bfs(h, w, start, goal);\n            } else if(m[i][j] == '$'){\n                start = {j, i};\n                s = min(bfs(h, w, start, goal), s);\n            }\n            //cout << p << ' ' << s << endl;;\n        }\n    }\n    if(p < s) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************************************************\n *                   BISMILLAHIR RAHMANIR RAHIM                  *\n *                           JU_Circavex                         *\n *****************************************************************/\n\n#include<bits/stdc++.h>\n\n//#include<algorithm>\n//#include<cstdio>\n//#include<sstream>\n//#include<cstdlib>\n//#include<cctype>\n//#include<cmath>\n//#include<set>\n//#include<queue>\n//#include<stack>\n//#include<list>\n//#include<iostream>\n//#include<fstream>\n//#include<numeric>\n//#include<string>\n//#include<vector>\n//#include<cstring>\n//#include<map>\n//#include<iterator>\n//#include<deque>\n//#include<climits>\n//#include<complex>\n\n#define S scanf\n#define P printf\n#define DI(X) int (X);             scanf(\"%d\", &X)\n#define DII(X, Y) int X, Y;        scanf(\"%d%d\", &X, &Y)\n#define DIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define DILL(X) LL (X); scanf(\"%lld\", &X)\n\n#define LL long long int\n#define ULL unsigned long long int\n#define D double\n\n#define all(a) a.begin(),a.end()\n#define X  first\n#define Y  second\n#define MP make_pair\n#define NL P(\"\\n\")\n\n#define PB(x)      push_back(x)\n#define PS(x)      push(x)\n#define sz()       size()\n#define UB         upper_bound\n#define LB         lower_bound\n#define countbit(x) __builtin_popcount(x)\n\n#define MEM(a,val) memset(a,val,sizeof(a));\n#define SET(a)     memset(a,-1,sizeof a)\n#define CLR(a)     memset(a,0,sizeof a)\n\nusing namespace std;\n\n\n#define ll long long int\n#define ull unsigned long long int\n#define inf (1<<30)\n#define linf (1LL<<62)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define f(i,n) for(i=0;i<n;i++)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define aov(a) a.begin(),a.end()\n#define pb push_back\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define pll pair< ll , ll >\n#define pii pair< int , int >\n#define mpr make_pair\n#define xx first\n#define yy second\n#define nl puts(\"\")\n//#define endl '\\n'\n#define dbg(x) cerr<<#x<<\" : \"<<x<<endl\n#define mpp make_pair\n#define SZ(x) (int)(x.size())\n#define fr(i,a,n) for(int i=a;i<=n;i++)\n\n//template <typename T> T BigMod (T b,T p,T m){if (p == 0) return 1;if (p%2 == 0){T s = BigMod(b,p/2,m);return ((s%m)*(s%m))%m;}return ((b%m)*(BigMod(b,p-1,m)%m))%m;}\n//template <typename T> T ModInv (T b,T m){return BigMod(b,m-2,m);}\n//template <typename T> T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}\n//template <typename T> LL isLeft(T a,T b,T c) { return (a.x-b.x)*(b.y-c.y)-(b.x-c.x)*(a.y-b.y); }\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\n//template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n//\n//int    Set(int N,int pos){ return N=N | (1<<pos);}\n//int  Reset(int N,int pos){return N= N & ~(1<<pos);}\n//bool Check(int N,int pos){return (bool)(N & (1<<pos));}\n\n#define VI  vector< int >\n#define VII vector< VI >\n#define VLL vector< LL >\n#define PII pair< int , int >\n#define PLL pair< LL , LL >\n#define VPI vector< PII >\n\n\n/// Hashing Bases & MOD\n///           0123456789\n#define Base1 10000019ULL\n#define Base2 10000079ULL\n#define Base3 10000103ULL\n#define MOD1  1000000007ULL\n#define MOD2  1000000009ULL\n#define MOD3  1000000021ULL\n#define LOGX  17\n#define FCIN  ios_base::sync_with_stdio(0); cin.tie(0)\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,+1,0,1,0,-1}; // Hexagonal Direction   **\n///int dy[]={-1,+1,1,0,-1,0}; //                       *#*\n///                                                     **\nint dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\nint ts, kk = 1;\n\n\n///         0123456789\n#define MX  10000001.0\n#define MD  1000000001.0\n#define MOD 1000000007\n#define eps 1e-9\n#define M   100000005\n#define MM  1010\n#define MD  1000000007LL\n\nint n,m;\nchar gr[205][205];\nint ds[205][205];\n\nvoid bfs(int u,int v)\n{\n    int i,x,y;\n    queue< int >qu;\n    qu.push( u );\n    qu.push( v );\n    ds[u][v]=0;\n\n    while(!qu.empty())\n    {\n        u=qu.front();qu.pop();\n        v=qu.front();qu.pop();\n\n        f(i,4)\n        {\n            x=u+dx[i];\n            y=v+dy[i];\n            if(x<0||y<0||x>=n||y>=m||gr[x][y]=='#')continue;\n            if( ds[x][y]>ds[u][v]+1 )\n            {\n                ds[x][y]=ds[u][v]+1;\n                qu.push(x);\n                qu.push(y);\n            }\n        }\n    }\n}\n\nbool chk(int u,int v)\n{\n    int i,x,y;\n    queue< int >qu;\n    qu.push( u );\n    qu.push( v );\n    qu.push( 0 );\n    ds[u][v]=0;\n\n    while(!qu.empty())\n    {\n        u=qu.front();qu.pop();\n        v=qu.front();qu.pop();\n        int d=qu.front();qu.pop();\n        if(gr[u][v]=='%')return 1;\n        f(i,4)\n        {\n            x=u+dx[i];\n            y=v+dy[i];\n            if(x<0||y<0||x>=n||y>=m||gr[x][y]=='#')continue;\n\n            if( d+1<ds[x][y] )\n            {\n                qu.push(x);\n                qu.push(y);\n                qu.push(d+1);\n                ds[x][y]=d+1;\n            }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int t,i,j,k;\n\n    sc2(n,m);\n    f(i,n)\n    {\n        scanf(\"%s\",gr[i]);\n        f(j,m)ds[i][j]=1000;\n    }\n    int sx,sy;\n    f(i,n)\n    {\n        f(j,m)\n        {\n            if(gr[i][j]=='$')\n            {\n                bfs(i,j);\n            }\n            else if(gr[i][j]=='@')\n                sx=i,sy=j;\n        }\n    }\n\n    if(chk(sx,sy))printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc, int cnt)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess, soldier;\n\n\tsoldier = 0x7fffff;\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif (map[r][c] == '@') princess = d, cnt--;\n\t\telse if (map[r][c] == '$') {\n\t\t\tif (soldier > d) soldier = d;\n\t\t\tcnt--;\n\t\t}\n\t\tif (!cnt) break;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn princess < soldier;\n}\n\nint main()\n{\n\tint r, c, sr, sc, cnt;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tcnt = 0;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t\telse if (map[r][c] == '$') cnt++;\n\t\t}\n\t}\n\n\tif (!cnt) puts(\"Yes\");\n\telse puts(dijkstra(sr, sc, cnt+1)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define ABS(a) ((a) > (0) ? (a) : -(a))\n#define ALLOC(size,type) ((type*) calloc ((size), sizeof (type)))\n\n#define POS(i, j) ((i) * w + (j))\n\nvoid run (void) {\n  i32 h, w;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &h, &w);\n  char *s = ALLOC (h * w + 1, char);\n  for (i32 i = 0; i < h; ++i) {\n    scanf (\"%s\", s + i * w);\n  }\n  i32 *q = ALLOC (h * w, i32);\n  i32 *d = ALLOC (h * w, i32);\n  for (i32 i = 0; i < h * w; ++i) {\n    d[i] = h * w;\n  }\n  i32 front = 0;\n  i32 last = 0;\n  for (i32 i =0; i < h * w; ++i) {\n    if (s[i] == '%') {\n      q[last++] = i;\n      d[i] = 0;\n    }\n  }\n  while (front < last) {\n    i32 v = q[front++];\n    i32 x = v / w;\n    i32 y = v % w;\n    i32 dir[4] = {1, 0, -1, 0};\n    for (i32 i = 0; i < 4; ++i) {\n      i32 nx = x + dir[i];\n      i32 ny = y + dir[i ^ 1];\n      if (!(0 <= nx && nx < h && 0 <= ny && ny < w && s[POS(nx, ny)] != '#' && d[POS(nx, ny)] > d[v] + 1)) continue;\n      d[POS(nx, ny)] = d[v] + 1;\n      q[last++] = POS(nx, ny);\n    }\n  }\n  i32 p = h * w;\n  i32 t = h * w;\n  for (i32 i = 0; i < h * w; ++i) {\n    if (s[i] == '@') {\n      p = d[i];\n    } else if (s[i] == '$') {\n      t = MIN(t, d[i]);\n    }\n  }\n  puts (p < t ? \"Yes\" : \"No\");\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nint main(){\n  int h,w,i,j,d[300][300],y[100010],x[100010],a,b=1e9+1,ny,nx,t,r;\n  char s[300][300];\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\" %c\",&s[i][j]);\n      if(s[i][j]=='%')s[y[0]=i][x[0]=j]='#';\n      d[i][j]=1e9;\n    }\n  }\n  d[y[0]][x[0]]=t=0;\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      ny=y[t]+Y[i];\n      nx=x[t]+X[i];\n      if(s[ny][nx]=='#'||ny<0||ny>=h||nx<0||nx>=w)continue;\n      d[ny][nx]=d[y[t]][x[t]]+1;\n      if(s[ny][nx]=='@')a=d[ny][nx];\n      if(s[ny][nx]=='$'&&b>d[ny][nx])b=d[ny][nx];\n      s[y[r]=ny][x[r]=nx]='#';\n      r++;\n    }\n  }\n  //printf(\"%d %d\\n\",a,b);\n  printf(\"%s\\n\",a>=b||a==1e9?\"No\":\"Yes\");\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MP(x, y) make_pair((x), (y))\n\nconst int MAX_HW = 200 + 5;\nconst int INF = 0x3f3f3f3f;\n\nconst int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint H, W;\nchar s[MAX_HW][MAX_HW];\n\nint sdd[MAX_HW][MAX_HW], pnd[MAX_HW][MAX_HW];\n\ninline bool mvable(int x, int y){\n\treturn !(x < 0 || x >= H || y < 0 || y >= W || s[x][y] == '#');\n}\n\nqueue<pair<int,int> > pnque, sdque;\ninline bool solve(){\n\tmemset(pnd, 0x3f, sizeof pnd);\n\tmemset(sdd, 0x3f, sizeof sdd);\n\tpair<int,int> hatch;\n\tfor (int i = 0; i < H; ++i){\n\t\tfor (int j = 0; j  < W; ++j){\n\t\t\tif (s[i][j] == '@'){\n\t\t\t\tpnque.push(MP(i, j));\n\t\t\t\tpnd[i][j] = 0;\n\t\t\t}\n\t\t\telse if (s[i][j] == '$'){\n\t\t\t\tsdque.push(MP(i, j));\n\t\t\t\tsdd[i][j] = 0;\n\t\t\t}\n\t\t\telse if (s[i][j] == '%'){\n\t\t\t\thatch = MP(i, j);\n\t\t\t}\n\t\t}\n\t}\n\t// calc pnd\n\twhile (!pnque.empty()){\n\t\tpair<int,int> p = pnque.front(); pnque.pop();\n\t\tint curd = pnd[p.first][p.second];\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tint nx = p.first + dir[i][0];\n\t\t\tint ny = p.second + dir[i][1];\n\t\t\tif (mvable(nx, ny) && pnd[nx][ny] == INF){\n\t\t\t\tpnd[nx][ny] = curd + 1;\n\t\t\t\tpnque.push(MP(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t// calc sdd\n\twhile (!sdque.empty()){\n\t\tpair<int,int> p = sdque.front(); sdque.pop();\n\t\tint curd = sdd[p.first][p.second];\n\t\tfor (int i = 0; i < 4; ++i){\n\t\t\tint nx = p.first + dir[i][0];\n\t\t\tint ny = p.second + dir[i][1];\n\t\t\tif (mvable(nx, ny) && sdd[nx][ny] == INF){\n\t\t\t\tsdd[nx][ny] = curd + 1;\n\t\t\t\tsdque.push(MP(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn pnd[hatch.first][hatch.second] < sdd[hatch.first][hatch.second];\n}\n\nint main(){\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) scanf(\" %s\", s[i]);\n\tbool ans = solve();\n\tprintf(\"%s\\n\", ans?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc, int cnt)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess, soldier;\n\n\tsoldier = 0x7fffff;\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif (map[r][c] == '@') princess = d;\n\t\telse if (map[r][c] == '$') {\n\t\t\tif (soldier > d) soldier = d;\n\t\t\tif (--cnt == 0) break;\n\t\t}\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn princess < soldier;\n}\n\nint main()\n{\n\tint r, c, sr, sc, cnt;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tcnt = 0;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t\telse if (map[r][c] == '$') cnt++;\n\t\t}\n\t}\n\n\tif (!cnt) puts(\"Yes\");\n\telse puts(dijkstra(sr, sc, cnt)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess = 0x7fffff;\n\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif      (map[r][c] == '@') princess = d;\n\t\telse if (map[r][c] == '$') {\n\t\t\tif (d > princess) return 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W ||\n\t\t\t\tmap[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint r, c, sr, sc;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) if (map[r][c] == '%') sr = r, sc = c;\n\t}\n\n\tputs(dijkstra(sr, sc)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc)\n{\n\tint i, r, c, nr, nc, d;\n\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif      (map[r][c] == '@') return 1;\n\t\telse if (map[r][c] == '$') break;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W ||\n\t\t\t\tmap[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint r, c, sr, sc;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) if (map[r][c] == '%') sr = r, sc = c;\n\t}\n\n\tputs(dijkstra(sr, sc)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess = 0x7fffff;\n\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif      (map[r][c] == '@') princess = d;\n\t\telse if (map[r][c] == '$') return d > princess;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W ||\n\t\t\t\tmap[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint r, c, sr, sc, f;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tf = 0, sr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tif (sr >= 0 && f) continue;\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t\telse if (map[r][c] == '$') f = 1;\n\t\t}\n\t}\n\n\tif (!f) puts(\"Yes\");\n\telse puts(dijkstra(sr, sc)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc, int cnt)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess, soldier;\n\n\tsoldier = 0x7fffff;\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif (map[r][c] == '@') princess = d, cnt--;\n\t\telse if (map[r][c] == '$') {\n\t\t\tif (soldier > d) soldier = d;\n\t\t\tcnt--;\n\t\t}\n\t\tif (!cnt) break;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W ||\n\t\t\t\tmap[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn princess < soldier;\n}\n\nint main()\n{\n\tint r, c, sr, sc, cnt;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tcnt = 0;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif (map[r][c] == '%') sr = r, sc = c;\n\t\t\telse if (map[r][c] == '$') cnt++;\n\t\t}\n\t}\n\n\tif (!cnt) puts(\"Yes\");\n\telse puts(dijkstra(sr, sc, cnt+1)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2781: Help the Princess!\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n\n#define QMAX 40000\ntypedef struct { int t, r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint H, W;\nchar map[203][203];\nchar mk[203][203];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc)\n{\n\tint i, r, c, nr, nc, d;\n\tint princess = 0x7fffff;\n\n\tqsize = 0;\n\tenq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, d = que[0].t, deq();\n\t\tif (mk[r][c]) continue;\n\t\tmk[r][c] = 1;\n\n\t\tif      (map[r][c] == '@') princess = d;\n\t\telse if (map[r][c] == '$') return d > princess;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W ||\n\t\t\t\tmap[nr][nc] == '#') continue;\n\t\t\tif (mk[nr][nc]) continue;\n\t\t\tenq(nr, nc, d+1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint r, c, sr, sc;\n\tchar buf[10];\n\n\tfgets(buf, 10, stdin), sscanf(buf, \"%d%d\", &H, &W);\n\tsr = -1;\n\tfor (r = 0; r < H; r++) {\n\t\tfgets(map[r], 203, stdin);\n\t\tif (sr >= 0) continue;\n\t\tfor (c = 0; c < W; c++) if (map[r][c] == '%') sr = r, sc = c;\n\t}\n\n\tputs(dijkstra(sr, sc)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HelpThePrincess solver = new HelpThePrincess();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HelpThePrincess {\n        int H;\n        int W;\n        Point goal;\n        HelpThePrincess.State[][] cell;\n\n        boolean inside(int h, int w) {\n            return 0 <= h && h < H && 0 <= w && w < W;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            H = in.nextInt();\n            W = in.nextInt();\n            String[] map = new String[H];\n            for (int i = 0; i < H; i++) {\n                map[i] = in.next();\n            }\n            cell = new HelpThePrincess.State[H][W];\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (map[i].charAt(j) == '#') {\n                        cell[i][j] = HelpThePrincess.State.wall;\n                    } else if (map[i].charAt(j) == '.') {\n                        cell[i][j] = HelpThePrincess.State.empty;\n                    } else if (map[i].charAt(j) == '@') {\n                        cell[i][j] = HelpThePrincess.State.prince;\n                    } else if (map[i].charAt(j) == '$') {\n                        cell[i][j] = HelpThePrincess.State.soldier;\n                    } else {\n                        cell[i][j] = HelpThePrincess.State.empty;\n                    }\n                    if (map[i].charAt(j) == '%') {\n                        goal = new Point(i, j);\n                    }\n                }\n            }\n            boolean ok = false;\n            int[] dx = new int[]{0, 0, -1, 1};\n            int[] dy = new int[]{-1, 1, 0, 0};\n            while (check()) {\n                HelpThePrincess.State[][] _cell = new HelpThePrincess.State[H][W];\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (cell[i][j].equals(HelpThePrincess.State.wall)) {\n                            _cell[i][j] = HelpThePrincess.State.wall;\n                        } else {\n                            _cell[i][j] = HelpThePrincess.State.empty;\n                        }\n                    }\n                }\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        for (int k = 0; k < 4; k++) {\n                            int nx = i + dx[k];\n                            int ny = j + dy[k];\n                            if (inside(nx, ny) && !_cell[nx][ny].equals(HelpThePrincess.State.wall) && (cell[i][j].equals(HelpThePrincess.State.prince) || cell[i][j].equals(HelpThePrincess.State.soldier))) {\n                                if (_cell[nx][ny].equals(HelpThePrincess.State.empty)) {\n                                    _cell[nx][ny] = cell[i][j];\n                                } else if (_cell[nx][ny].equals(HelpThePrincess.State.prince) && cell[i][j].equals(HelpThePrincess.State.soldier)) {\n                                    _cell[nx][ny] = cell[i][j];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (cell[goal.x][goal.y].equals(HelpThePrincess.State.prince)) {\n                    ok = true;\n                    break;\n                } else if (cell[goal.x][goal.y].equals(HelpThePrincess.State.soldier)) {\n                    break;\n                }\n                cell = _cell;\n            }\n            out.println(ok ? \"Yes\" : \"No\");\n        }\n\n        public boolean check() {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (cell[i][j].equals(HelpThePrincess.State.prince)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public enum State {\n            prince,\n            soldier,\n            wall,\n            empty,;\n        }\n\n        public class Point {\n            public int x;\n            public int y;\n\n            public Point(int _x, int _y) {\n                this.x = _x;\n                this.y = _y;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic int INF = (int)1e9 + 7;\n\tstatic int[] dx = {1,-1,0,0};\n\tstatic int[] dy = {0,0,1,-1};\n\tint H,W,start,goal;\n\tArrayList<Integer> soldiers;\n\tchar[][] map;\n\tint[][] minDistance;\n\n\tpublic boolean check(int y,int x){\n\t\tif(y < 0 || x < 0 || y >= H || x >= W)return false;\n\t\treturn true;\n\t}\n\n\tpublic void solve() {\n\t\tH = nextInt();\n\t\tW = nextInt();\n\n\t\tmap = new char[H][];\n\t\tsoldiers = new ArrayList<Integer>();\n\t\tfor(int i = 0;i < H;i++){\n\t\t\tmap[i] = next().toCharArray();\n\n\t\t\tfor(int j = 0;j < W;j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tstart = i * 1000 + j;\n\t\t\t\t}\n\n\t\t\t\tif(map[i][j] == '$'){\n\t\t\t\t\tsoldiers.add(i * 1000 + j);\n\t\t\t\t}\n\n\t\t\t\tif(map[i][j] == '%'){\n\t\t\t\t\tgoal = i * 1000 + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminDistance = new int[H][W];\n\t\tfor(int i = 0;i < H;i++){\n\t\t\tfor(int j = 0;j < W;j++){\n\t\t\t\tminDistance[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\t\tfor(int soldier : soldiers){\n\t\t\tint y = soldier / 1000;\n\t\t\tint x = soldier % 1000;\n\t\t\tminDistance[y][x] = 0;\n\t\t\tq.add(new int[]{soldier,0});\n\t\t}\n\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] qData = q.poll();\n\n\t\t\tint y = qData[0] / 1000;\n\t\t\tint x = qData[0] % 1000;\n\t\t\tint d = qData[1];\n\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint ny = dy[i] + y;\n\t\t\t\tint nx = dx[i] + x;\n\n\t\t\t\tif(!check(ny,nx))continue;\n\t\t\t\tif(minDistance[ny][nx] <= d + 1)continue;\n\t\t\t\tif(map[ny][nx] == '#')continue;\n\t\t\t\tminDistance[ny][nx] = d + 1;\n\t\t\t\tq.add(new int[]{ny * 1000 + nx,d + 1});\n\t\t\t}\n\t\t}\n\n\t\tminDistance[start / 1000][start % 1000] = 0;\n\t\tq.add(new int[]{start,0});\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] qData = q.poll();\n\n\t\t\tif(qData[0] == goal){\n\t\t\t\tout.println(\"Yes\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint y = qData[0] / 1000;\n\t\t\tint x = qData[0] % 1000;\n\t\t\tint d = qData[1];\n\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint ny = dy[i] + y;\n\t\t\t\tint nx = dx[i] + x;\n\n\t\t\t\tif(!check(ny,nx))continue;\n\t\t\t\tif(minDistance[ny][nx] <= d + 1)continue;\n\t\t\t\tif(map[ny][nx] == '#')continue;\n\t\t\t\tminDistance[ny][nx] = d + 1;\n\t\t\t\tq.add(new int[]{ny * 1000 + nx,d + 1});\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"No\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HelpThePrincess solver = new HelpThePrincess();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HelpThePrincess {\n        int H;\n        int W;\n        Point goal;\n        HelpThePrincess.State[][] cell;\n\n        boolean inside(int h, int w) {\n            return 0 <= h && h < H && 0 <= w && w < W;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            H = in.nextInt();\n            W = in.nextInt();\n            String[] map = new String[H];\n            for (int i = 0; i < H; i++) {\n                map[i] = in.next();\n            }\n            cell = new HelpThePrincess.State[H][W];\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (map[i].charAt(j) == '#') {\n                        cell[i][j] = HelpThePrincess.State.wall;\n                    } else if (map[i].charAt(j) == '.') {\n                        cell[i][j] = HelpThePrincess.State.empty;\n                    } else if (map[i].charAt(j) == '@') {\n                        cell[i][j] = HelpThePrincess.State.prince;\n                    } else if (map[i].charAt(j) == '$') {\n                        cell[i][j] = HelpThePrincess.State.soldier;\n                    } else {\n                        cell[i][j] = HelpThePrincess.State.empty;\n                    }\n                    if (map[i].charAt(j) == '%') {\n                        goal = new Point(i, j);\n                    }\n                }\n            }\n            boolean ok = false;\n            int[] dx = new int[]{0, 0, -1, 1};\n            int[] dy = new int[]{-1, 1, 0, 0};\n            while (check()) {\n                HelpThePrincess.State[][] _cell = new HelpThePrincess.State[H][W];\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        if (cell[i][j].equals(HelpThePrincess.State.wall)) {\n                            _cell[i][j] = HelpThePrincess.State.wall;\n                        } else {\n                            _cell[i][j] = HelpThePrincess.State.empty;\n                        }\n                    }\n                }\n                for (int i = 0; i < H; i++) {\n                    for (int j = 0; j < W; j++) {\n                        for (int k = 0; k < 4; k++) {\n                            int nx = i + dx[k];\n                            int ny = j + dy[k];\n                            if (inside(nx, ny) && !_cell[nx][ny].equals(HelpThePrincess.State.wall) && (cell[i][j].equals(HelpThePrincess.State.prince) || cell[i][j].equals(HelpThePrincess.State.soldier))) {\n                                if (_cell[nx][ny].equals(HelpThePrincess.State.empty)) {\n                                    _cell[nx][ny] = cell[i][j];\n                                } else if (_cell[nx][ny].equals(HelpThePrincess.State.prince) && cell[i][j].equals(HelpThePrincess.State.soldier)) {\n                                    _cell[nx][ny] = cell[i][j];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (cell[goal.x][goal.y].equals(HelpThePrincess.State.prince)) {\n                    ok = true;\n                    break;\n                } else if (cell[goal.x][goal.y].equals(HelpThePrincess.State.soldier)) {\n                    break;\n                }\n                cell = _cell;\n            }\n            out.println(ok ? \"YES\" : \"NO\");\n        }\n\n        public boolean check() {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (cell[i][j].equals(HelpThePrincess.State.prince)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public enum State {\n            prince,\n            soldier,\n            wall,\n            empty,;\n        }\n\n        public class Point {\n            public int x;\n            public int y;\n\n            public Point(int _x, int _y) {\n                this.x = _x;\n                this.y = _y;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.split.map(&:to_i)\na = [[?#] * (w + 2)] + (1..h).map { [?#] + gets.chomp.split(\"\") + [?#] } + [[?#] * (w + 2)]\n\nxs = ys = xp = yp = nil\nsoldiers = []\n(1..h).each do |y|\n  (1..w).each do |x|\n    if a[y][x] == ?#\n      next\n    elsif a[y][x] == ?%\n      xs, ys = x, y\n    elsif a[y][x] == ?@\n      xp, yp = x, y\n    elsif a[y][x] == ?$\n      soldiers << [x, y]\n    end\n    a[y][x] = ?.\n  end\nend\n\ndist = { [xs, ys] => 0 }\nqueue = [[xs, ys]]\nuntil queue.empty?\n  x, y = queue.shift\n  d = dist[[x, y]]\n  [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dx, dy|\n    u, v = x + dx, y + dy\n    next if a[v][u] == ?# or dist[[u, v]]\n    dist[[u, v]] = d + 1\n    queue << [u, v]\n  end\nend\n\nputs dist[[xp, yp]] < (soldiers.map {|x, y| dist[[x, y]]}.compact.min || Float::INFINITY) ? 'Yes' : 'No'\n\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nconst dy = [-1, 0, 1, 0];\nconst dx = [0, 1, 0, -1];\n\nvoid main() {\n    int H, W; readf(\"%d %d\\n\", &H, &W);\n    auto F = new string[H];\n    foreach (ref L; F) L = readln.chomp;\n\n    auto D = new int[][](H, W);\n    foreach (ref a; D) a[] = int.max / 2;\n\n    int sy, sx;\n    void init_yx() {\n        foreach (int i, L; F) {\n            foreach (int j, x; L) {\n                if (x == '%') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n        assert(false);\n    }\n    init_yx();\n\n    alias P = Tuple!(int, \"y\", int, \"x\");\n\n    D[sy][sx] = 0;\n    DList!P Q;\n    Q.insert(P(sy, sx));\n    while (! Q.empty) {\n        auto c = Q.front; Q.removeFront;\n        foreach (k; 0 .. 4) {\n            int ny = c.y + dy[k];\n            int nx = c.x + dx[k];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            if (D[ny][nx] <= D[c.y][c.x] + 1) continue;\n            D[ny][nx] = D[c.y][c.x] + 1;\n            Q.insert(P(ny, nx));\n        }\n    }\n\n    int soldier = int.max;\n    int princess = int.max;\n    foreach (i, L; F) {\n        foreach (j, x; L) {\n            if (x == '$') {\n                soldier = min(soldier, D[i][j]);\n            } else if (x == '@') {\n                princess = min(princess, D[i][j]);\n            }\n        }\n    }\n    writeln(princess < soldier ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "Python",
    "code": "import queue\n\ndi = [0,1,0,-1]\ndj = [1,0,-1,0]\n\nh, w = map(int, input().split())\nfield = [input() for i in range(h)]\npdist = [[1000]*w for i in range(h)]\nsdist = [[1000]*w for i in range(h)]\n\npque = queue.Queue()\nsque = queue.Queue()\nfor i,row in enumerate(field):\n    for j in range(w):\n        if row[j] is '@':\n            pque.put((i,j))\n            pdist[i][j] = 0\n            pi = i\n            pj = j\n        if row[j] is '$':\n            sque.put((i,j))\n            sdist[i][j] = 0\n        if row[j] is '%':\n            gi = i\n            gj = j\n\nwhile not sque.empty():\n    i,j = sque.get()\n    for k in range(4):\n        ni = i+di[k]\n        nj = j+dj[k]\n        if ni >=0 and ni < h and nj >= 0 and nj < w:\n            if (field[ni][nj] is not '#') and sdist[ni][nj] > sdist[i][j]+1:\n                sdist[ni][nj] = sdist[i][j]+1\n                sque.put((ni,nj))\n\nwhile not pque.empty():\n    i,j = pque.get()\n    for k in range(4):\n        ni = i+di[k]\n        nj = j+dj[k]\n        if ni >=0 and ni < h and nj >= 0 and nj < w:\n            if (field[ni][nj] is not '#') and pdist[ni][nj] > pdist[i][j]+1 and pdist[i][j]+1 < sdist[ni][nj]:\n                pdist[ni][nj] = pdist[i][j]+1\n                pque.put((ni,nj))\n\nif pdist[gi][gj] < 1000:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    h,w = LI()\n    mp = [S() for _ in range(h)]\n\n    def search(ss):\n        d = collections.defaultdict(lambda: inf)\n        q = []\n        for s in ss:\n            d[s] = 0\n            heapq.heappush(q, (0, s))\n        v = collections.defaultdict(bool)\n        while len(q):\n            k, u = heapq.heappop(q)\n            if v[u]:\n                continue\n            v[u] = True\n\n            for di,dj in dd:\n                ni = u[0] + di\n                nj = u[1] + dj\n                if ni < 0 or ni >= h or nj < 0 or nj >= w or mp[ni][nj] == '#':\n                    continue\n                uv = (ni, nj)\n                if v[uv]:\n                    continue\n                vd = k + 1\n                if d[uv] > vd:\n                    d[uv] = vd\n                    heapq.heappush(q, (vd, uv))\n\n        return d\n\n    ss = []\n    ps = None\n    es = None\n    for i in range(h):\n        for j in range(w):\n            if mp[i][j] == '$':\n                ss.append((i,j))\n            elif mp[i][j] == '@':\n                ps = (i,j)\n            elif mp[i][j] == '%':\n                es = (i,j)\n    pd = search(ss)\n    d = search([ps])\n    if d[es] < pd[es]:\n        return 'Yes'\n\n    return 'No'\n\n\nprint(main())\n\n\n"
  }
]