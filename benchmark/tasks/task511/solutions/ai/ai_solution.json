[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 50\n#define MAX_M 50\n#define MAX_K 10\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint N, M, K;\nchar grid[MAX_N][MAX_M];\nPoint princess, escape;\nPoint soldiers[MAX_K];\nint soldier_count;\n\nint dx[] = {0, 0, 1, -1, 0};\nint dy[] = {1, -1, 0, 0, 0};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != '#';\n}\n\nbool is_soldier_catch(Point p, Point soldiers[], int count) {\n    for (int i = 0; i < count; i++) {\n        if (p.x == soldiers[i].x && p.y == soldiers[i].y)\n            return true;\n    }\n    return false;\n}\n\nbool dfs(Point curr, Point soldiers[], int steps) {\n    if (steps > K) return false;\n    if (curr.x == escape.x && curr.y == escape.y) return true;\n    if (is_soldier_catch(curr, soldiers, soldier_count)) return false;\n\n    Point next_soldiers[MAX_K];\n    for (int move = 0; move < 5; move++) {\n        int nx = curr.x + dx[move];\n        int ny = curr.y + dy[move];\n\n        if (is_valid(nx, ny)) {\n            memcpy(next_soldiers, soldiers, sizeof(soldiers[0]) * soldier_count);\n\n            // Move soldiers\n            for (int i = 0; i < soldier_count; i++) {\n                int sx = next_soldiers[i].x;\n                int sy = next_soldiers[i].y;\n                int best_dist = abs(sx - nx) + abs(sy - ny);\n                int best_x = sx, best_y = sy;\n\n                for (int j = 0; j < 5; j++) {\n                    int nsx = sx + dx[j];\n                    int nsy = sy + dy[j];\n                    if (is_valid(nsx, nsy)) {\n                        int dist = abs(nsx - nx) + abs(nsy - ny);\n                        if (dist < best_dist) {\n                            best_dist = dist;\n                            best_x = nsx;\n                            best_y = nsy;\n                        }\n                    }\n                }\n                next_soldiers[i].x = best_x;\n                next_soldiers[i].y = best_y;\n            }\n\n            if (!is_soldier_catch((Point){nx, ny}, next_soldiers, soldier_count)) {\n                if (dfs((Point){nx, ny}, next_soldiers, steps + 1))\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'P') {\n                princess.x = i;\n                princess.y = j;\n            } else if (grid[i][j] == 'E') {\n                escape.x = i;\n                escape.y = j;\n            } else if (grid[i][j] == 'S') {\n                soldiers[soldier_count].x = i;\n                soldiers[soldier_count].y = j;\n                soldier_count++;\n            }\n        }\n    }\n\n    printf(\"%s\\n\", dfs(princess, soldiers, 0) ? \"YES\" : \"NO\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int steps;\n} Node;\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint dist_soldiers[MAX_SIZE][MAX_SIZE];\nint dist_princess[MAX_SIZE][MAX_SIZE];\nint rows, cols;\nPoint princess, escape;\nPoint soldiers[MAX_SIZE * MAX_SIZE];\nint soldier_count;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid bfs_soldiers() {\n    Node queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dist_soldiers[i][j] = INT_MAX;\n        }\n    }\n\n    for (int i = 0; i < soldier_count; i++) {\n        Point s = soldiers[i];\n        dist_soldiers[s.x][s.y] = 0;\n        queue[rear].pos = s;\n        queue[rear].steps = 0;\n        rear++;\n    }\n\n    while (front < rear) {\n        Node current = queue[front++];\n        for (int i = 0; i < 4; i++) {\n            int nx = current.pos.x + dx[i];\n            int ny = current.pos.y + dy[i];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != '#') {\n                if (dist_soldiers[nx][ny] > current.steps + 1) {\n                    dist_soldiers[nx][ny] = current.steps + 1;\n                    queue[rear].pos.x = nx;\n                    queue[rear].pos.y = ny;\n                    queue[rear].steps = dist_soldiers[nx][ny];\n                    rear++;\n                }\n            }\n        }\n    }\n}\n\nint bfs_princess() {\n    Node queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            dist_princess[i][j] = -1;\n        }\n    }\n\n    dist_princess[princess.x][princess.y] = 0;\n    queue[rear].pos = princess;\n    queue[rear].steps = 0;\n    rear++;\n\n    while (front < rear) {\n        Node current = queue[front++];\n        if (current.pos.x == escape.x && current.pos.y == escape.y) {\n            return 1;\n        }\n        for (int i = 0; i < 4; i++) {\n            int nx = current.pos.x + dx[i];\n            int ny = current.pos.y + dy[i];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != '#') {\n                if (dist_princess[nx][ny] == -1 && (current.steps + 1) < dist_soldiers[nx][ny]) {\n                    dist_princess[nx][ny] = current.steps + 1;\n                    queue[rear].pos.x = nx;\n                    queue[rear].pos.y = ny;\n                    queue[rear].steps = dist_princess[nx][ny];\n                    rear++;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    soldier_count = 0;\n\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'P') {\n                princess.x = i;\n                princess.y = j;\n            } else if (grid[i][j] == 'E') {\n                escape.x = i;\n                escape.y = j;\n            } else if (grid[i][j] == 'S') {\n                soldiers[soldier_count].x = i;\n                soldiers[soldier_count].y = j;\n                soldier_count++;\n            }\n        }\n    }\n\n    bfs_soldiers();\n    if (bfs_princess()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> grid(h);\n    Point princess(-1, -1), escape(-1, -1);\n    vector<Point> soldiers;\n\n    for (int i = 0; i < h; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < w; ++j) {\n            if (grid[i][j] == 'P') {\n                princess = Point(i, j);\n            } else if (grid[i][j] == 'E') {\n                escape = Point(i, j);\n            } else if (grid[i][j] == 'S') {\n                soldiers.emplace_back(i, j);\n            }\n        }\n    }\n\n    vector<vector<int>> soldier_dist(h, vector<int>(w, INT_MAX));\n    queue<Point> q;\n    for (auto &s : soldiers) {\n        soldier_dist[s.x][s.y] = 0;\n        q.push(s);\n    }\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    while (!q.empty()) {\n        Point p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && grid[nx][ny] != '#' && soldier_dist[nx][ny] == INT_MAX) {\n                soldier_dist[nx][ny] = soldier_dist[p.x][p.y] + 1;\n                q.push(Point(nx, ny));\n            }\n        }\n    }\n\n    vector<vector<int>> princess_dist(h, vector<int>(w, INT_MAX));\n    princess_dist[princess.x][princess.y] = 0;\n    q.push(princess);\n\n    while (!q.empty()) {\n        Point p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && grid[nx][ny] != '#' && princess_dist[nx][ny] == INT_MAX) {\n                princess_dist[nx][ny] = princess_dist[p.x][p.y] + 1;\n                q.push(Point(nx, ny));\n            }\n        }\n    }\n\n    bool can_escape = false;\n    if (princess_dist[escape.x][escape.y] < soldier_dist[escape.x][escape.y]) {\n        can_escape = true;\n    } else {\n        q.push(escape);\n        vector<vector<bool>> visited(h, vector<bool>(w, false));\n        visited[escape.x][escape.y] = true;\n        while (!q.empty()) {\n            Point p = q.front();\n            q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && grid[nx][ny] != '#' && !visited[nx][ny]) {\n                    if (princess_dist[nx][ny] < soldier_dist[nx][ny]) {\n                        can_escape = true;\n                        break;\n                    }\n                    visited[nx][ny] = true;\n                    q.push(Point(nx, ny));\n                }\n            }\n            if (can_escape) break;\n        }\n    }\n\n    cout << (can_escape ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class PrincessEscape {\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n\n    public static boolean canEscape(char[][] grid) {\n        int rows = grid.length;\n        if (rows == 0) return false;\n        int cols = grid[0].length;\n\n        Queue<int[]> princessQueue = new LinkedList<>();\n        Queue<int[]> soldiersQueue = new LinkedList<>();\n        int[][] princessTime = new int[rows][cols];\n        int[][] soldiersTime = new int[rows][cols];\n        boolean[][] visited = new boolean[rows][cols];\n\n        // Initialize queues and time grids\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                princessTime[i][j] = -1;\n                soldiersTime[i][j] = -1;\n                if (grid[i][j] == 'P') {\n                    princessQueue.add(new int[]{i, j});\n                    princessTime[i][j] = 0;\n                } else if (grid[i][j] == 'S') {\n                    soldiersQueue.add(new int[]{i, j});\n                    soldiersTime[i][j] = 0;\n                }\n            }\n        }\n\n        // BFS for soldiers\n        while (!soldiersQueue.isEmpty()) {\n            int[] current = soldiersQueue.poll();\n            int x = current[0];\n            int y = current[1];\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != '#' && soldiersTime[nx][ny] == -1) {\n                    soldiersTime[nx][ny] = soldiersTime[x][y] + 1;\n                    soldiersQueue.add(new int[]{nx, ny});\n                }\n            }\n        }\n\n        // BFS for princess\n        while (!princessQueue.isEmpty()) {\n            int[] current = princessQueue.poll();\n            int x = current[0];\n            int y = current[1];\n\n            if (grid[x][y] == 'E') {\n                return true;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != '#' && !visited[nx][ny]) {\n                    int nextTime = princessTime[x][y] + 1;\n                    if (soldiersTime[nx][ny] == -1 || nextTime < soldiersTime[nx][ny]) {\n                        princessTime[nx][ny] = nextTime;\n                        visited[nx][ny] = true;\n                        princessQueue.add(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:00:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 0, 1, -1, 0};\n    private static final int[] dy = {1, -1, 0, 0, 0};\n\n    public static boolean canEscape(char[][] grid, int[] princess, int[] soldiers) {\n        int m = grid.length, n = grid[0].length;\n        boolean[][][] visited = new boolean[m][n][1 << soldiers.length];\n        Queue<State> queue = new LinkedList<>();\n\n        int startState = 0;\n        for (int i = 0; i < soldiers.length; i += 2) {\n            startState |= (soldiers[i] << (i / 2 * 4)) | (soldiers[i + 1] << (i / 2 * 4 + 2));\n        }\n\n        queue.offer(new State(princess[0], princess[1], startState, 0));\n        visited[princess[0]][princess[1]][startState] = true;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (grid[current.x][current.y] == 'E') {\n                return true;\n            }\n\n            for (int d = 0; d < 5; d++) {\n                int nx = current.x + dx[d];\n                int ny = current.y + dy[d];\n                int newState = current.state;\n\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') {\n                    continue;\n                }\n\n                // Move soldiers optimally\n                for (int i = 0; i < soldiers.length; i += 2) {\n                    int sx = soldiers[i], sy = soldiers[i + 1];\n                    int targetX = nx, targetY = ny;\n\n                    if (Math.abs(sx - nx) + Math.abs(sy - ny) > 1) {\n                        int bestDist = Integer.MAX_VALUE;\n                        for (int sd = 0; sd < 5; sd++) {\n                            int nsx = sx + dx[sd], nsy = sy + dy[sd];\n                            if (nsx >= 0 && nsx < m && nsy >= 0 && nsy < n && grid[nsx][nsy] != '#') {\n                                int dist = Math.abs(nsx - nx) + Math.abs(nsy - ny);\n                                if (dist < bestDist) {\n                                    bestDist = dist;\n                                    targetX = nsx;\n                                    targetY = nsy;\n                                }\n                            }\n                        }\n                    }\n\n                    newState = (newState & ~(15 << (i / 2 * 4))) | \n                               ((targetX << (i / 2 * 4)) | (targetY << (i / 2 * 4 + 2)));\n                }\n\n                // Check if princess is caught\n                boolean caught = false;\n                for (int i = 0; i < soldiers.length; i += 2) {\n                    int sx = (newState >> (i / 2 * 4)) & 3;\n                    int sy = (newState >> (i / 2 * 4 + 2)) & 3;\n                    if (sx == nx && sy == ny) {\n                        caught = true;\n                        break;\n                    }\n                }\n\n                if (caught) continue;\n\n                if (!visited[nx][ny][newState]) {\n                    visited[nx][ny][newState] = true;\n                    queue.offer(new State(nx, ny, newState, current.moves + 1));\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private static class State {\n        int x, y, state, moves;\n        State(int x, int y, int state, int moves) {\n            this.x = x;\n            this.y = y;\n            this.state = state;\n            this.moves = moves;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:00:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1, 0};\nconst int dy[] = {1, -1, 0, 0, 0};\n\nstruct State {\n    int px, py, sx, sy;\n    bool operator==(const State& other) const {\n        return px == other.px && py == other.py && sx == other.sx && sy == other.sy;\n    }\n};\n\nclass Solution {\npublic:\n    bool canEscape(vector<vector<char>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        State start;\n        \n        // Find initial positions\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'P') {\n                    start.px = i;\n                    start.py = j;\n                }\n                if (grid[i][j] == 'S') {\n                    start.sx = i;\n                    start.sy = j;\n                }\n            }\n        }\n        \n        queue<State> q;\n        set<State> visited;\n        q.push(start);\n        visited.insert(start);\n        \n        while (!q.empty()) {\n            State curr = q.front();\n            q.pop();\n            \n            // Check if princess escaped\n            if (grid[curr.px][curr.py] == 'E') return true;\n            \n            // Try princess moves\n            for (int pd = 0; pd < 5; pd++) {\n                int npx = curr.px + dx[pd];\n                int npy = curr.py + dy[pd];\n                \n                // Check princess move validity\n                if (npx < 0 || npx >= m || npy < 0 || npy >= n || grid[npx][npy] == '#') continue;\n                \n                // Try soldier moves\n                for (int sd = 0; sd < 5; sd++) {\n                    int nsx = curr.sx + dx[sd];\n                    int nsy = curr.sy + dy[sd];\n                    \n                    // Check soldier move validity\n                    if (nsx < 0 || nsx >= m || nsy < 0 || nsy >= n || grid[nsx][nsy] == '#') continue;\n                    \n                    State next{npx, npy, nsx, nsy};\n                    \n                    // Check if princess is caught\n                    if (npx == nsx && npy == nsy) continue;\n                    \n                    // Add to queue if not visited\n                    if (visited.find(next) == visited.end()) {\n                        q.push(next);\n                        visited.insert(next);\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<char>> grid = {\n        {'.','.','.','.','#'},\n        {'#','#','#','S','E'},\n        {'.','.','P','.','.'}\n    };\n    \n    cout << (sol.canEscape(grid) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef is_escapable(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Parse grid for initial positions\n    princess_pos = None\n    soldiers = []\n    escape_pos = None\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'P':\n                princess_pos = (r, c)\n            elif grid[r][c] == 'S':\n                soldiers.append((r, c))\n            elif grid[r][c] == 'E':\n                escape_pos = (r, c)\n    \n    def is_valid_position(r, c, visited, grid):\n        return 0 <= r < rows and 0 <= c < cols and grid[r][c] != '#' and (r, c) not in visited\n\n    # BFS to calculate minimum time to capture for each cell\n    soldier_times = [[float('inf')] * cols for _ in range(rows)]\n    soldier_queue = deque(soldiers)\n    for r, c in soldiers:\n        soldier_times[r][c] = 0\n        \n    while soldier_queue:\n        r, c = soldier_queue.popleft()\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid_position(nr, nc, set(), grid) and soldier_times[nr][nc] == float('inf'):\n                soldier_times[nr][nc] = soldier_times[r][c] + 1\n                soldier_queue.append((nr, nc))\n\n    # BFS for the princess to check for escape\n    princess_queue = deque([(princess_pos[0], princess_pos[1], 0)])\n    visited = set([princess_pos])\n    \n    while princess_queue:\n        r, c, t = princess_queue.popleft()\n        \n        if (r, c) == escape_pos and t < soldier_times[r][c]:\n            return True\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid_position(nr, nc, visited, grid) and t + 1 < soldier_times[nr][nc]:\n                visited.add((nr, nc))\n                princess_queue.append((nr, nc, t + 1))\n    \n    return False\n\n# Example usage (test case)\ngrid = [\n    ['#', '#', '#', '#', '#', '#'],\n    ['#', 'P', ' ', ' ', 'S', '#'],\n    ['#', ' ', '#', ' ', 'E', '#'],\n    ['#', 'S', ' ', ' ', ' ', '#'],\n    ['#', '#', '#', '#', '#', '#']\n]\n\nprint(is_escapable(grid))  # Output: Depends on provided grid",
    "timestamp": "2025-08-13 08:22:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class PrincessEscape {\n\n    private static final int[] DIRECTIONS = {-1, 0, 1, 0, -1};\n\n    static class Position {\n        int row, col;\n\n        Position(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    public static boolean canPrincessEscape(char[][] grid, Position princessStart, Position escapeHatch, Position[] soldiers) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        Queue<Position> princessQueue = new LinkedList<>();\n        Queue<Position> soldierQueue = new LinkedList<>();\n\n        boolean[][] princessVisited = new boolean[rows][cols];\n        boolean[][] soldierVisited = new boolean[rows][cols];\n\n        princessQueue.offer(princessStart);\n        princessVisited[princessStart.row][princessStart.col] = true;\n\n        for (Position soldier : soldiers) {\n            soldierQueue.offer(soldier);\n            soldierVisited[soldier.row][soldier.col] = true;\n        }\n\n        while (!princessQueue.isEmpty()) {\n            int soldierQueueSize = soldierQueue.size();\n            for (int i = 0; i < soldierQueueSize; i++) {\n                Position currentSoldier = soldierQueue.poll();\n\n                for (int d = 0; d < 4; d++) {\n                    int newRow = currentSoldier.row + DIRECTIONS[d];\n                    int newCol = currentSoldier.col + DIRECTIONS[d + 1];\n\n                    if (isValidMove(newRow, newCol, rows, cols, grid, soldierVisited)) {\n                        soldierVisited[newRow][newCol] = true;\n                        soldierQueue.offer(new Position(newRow, newCol));\n                    }\n                }\n            }\n\n            int princessQueueSize = princessQueue.size();\n            for (int i = 0; i < princessQueueSize; i++) {\n                Position currentPrincess = princessQueue.poll();\n\n                if (currentPrincess.row == escapeHatch.row && currentPrincess.col == escapeHatch.col) {\n                    return true;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newRow = currentPrincess.row + DIRECTIONS[d];\n                    int newCol = currentPrincess.col + DIRECTIONS[d + 1];\n\n                    if (isValidMove(newRow, newCol, rows, cols, grid, princessVisited) && !soldierVisited[newRow][newCol]) {\n                        princessVisited[newRow][newCol] = true;\n                        princessQueue.offer(new Position(newRow, newCol));\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isValidMove(int row, int col, int rows, int cols, char[][] grid, boolean[][] visited) {\n        return row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] == '.' && !visited[row][col];\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {\n            {'.', '.', '.', '#'},\n            {'.', '#', '.', '.'},\n            {'.', '.', '.', '#'},\n            {'.', '#', '#', '.'}};\n        \n        Position princessStart = new Position(0, 0);\n        Position escapeHatch = new Position(3, 3);\n        Position[] soldiers = {new Position(1, 2), new Position(2, 2)};\n\n        boolean result = canPrincessEscape(grid, princessStart, escapeHatch, soldiers);\n        System.out.println(result ? \"Princess can escape!\" : \"Princess can't escape!\");\n    }\n}",
    "timestamp": "2025-08-13 08:22:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 100\n#define INF (MAXN * MAXN)\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint n, m;\nchar grid[MAXN][MAXN];\nint distPrincess[MAXN][MAXN];\nint distSoldier[MAXN][MAXN];\nPoint princessStart, escapeHatch;\nPoint soldierStart[MAXN * MAXN];\nint soldierCount;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nvoid bfs(Point start, int dist[MAXN][MAXN]) {\n    bool visited[MAXN][MAXN] = {false};\n    Point queue[MAXN * MAXN];\n    int front = 0, back = 0;\n\n    queue[back++] = start;\n    visited[start.x][start.y] = true;\n    dist[start.x][start.y] = 0;\n\n    while (front < back) {\n        Point cur = queue[front++];\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = cur.x + dx[dir];\n            int ny = cur.y + dy[dir];\n            if (isValid(nx, ny) && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dist[nx][ny] = dist[cur.x][cur.y] + 1;\n                queue[back++] = (Point){nx, ny};\n            }\n        }\n    }\n}\n\nbool canEscape() {\n    bfs(princessStart, distPrincess);\n  \n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            distSoldier[i][j] = INF;\n  \n    for (int i = 0; i < soldierCount; ++i)\n        bfs(soldierStart[i], distSoldier);\n\n    return distPrincess[escapeHatch.x][escapeHatch.y] < distSoldier[escapeHatch.x][escapeHatch.y];\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'P')\n                princessStart = (Point){i, j};\n            else if (grid[i][j] == 'E')\n                escapeHatch = (Point){i, j};\n            else if (grid[i][j] == 'S')\n                soldierStart[soldierCount++] = (Point){i, j};\n        }\n    }\n\n    if (canEscape()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:22:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef can_princess_escape(grid: List[List[str]], princess_pos: Tuple[int, int], soldiers_pos: List[Tuple[int, int]], escape_hatch: Tuple[int, int]) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]\n    \n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and grid[x][y] != '#'\n    \n    def bfs():\n        visited = set()\n        queue = deque([(princess_pos, soldiers_pos, 0)])\n        \n        while queue:\n            (px, py), curr_soldiers, turn = queue.popleft()\n            \n            if (px, py) == escape_hatch:\n                return True\n            \n            state = ((px, py), tuple(sorted(curr_soldiers)))\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            for dx, dy in directions:\n                new_px, new_py = px + dx, py + dy\n                \n                if is_valid_move(new_px, new_py):\n                    new_soldiers = []\n                    is_caught = False\n                    \n                    for sx, sy in curr_soldiers:\n                        best_soldier_move = None\n                        min_dist = float('inf')\n                        \n                        for sdx, sdy in directions:\n                            new_sx, new_sy = sx + sdx, sy + sdy\n                            if is_valid_move(new_sx, new_sy):\n                                dist = abs(new_sx - new_px) + abs(new_sy - new_py)\n                                if dist < min_dist:\n                                    min_dist = dist\n                                    best_soldier_move = (new_sx, new_sy)\n                        \n                        if best_soldier_move is None:\n                            best_soldier_move = (sx, sy)\n                        \n                        new_soldiers.append(best_soldier_move)\n                        \n                        if best_soldier_move == (new_px, new_py):\n                            is_caught = True\n                    \n                    if not is_caught:\n                        queue.append(((new_px, new_py), new_soldiers, turn + 1))\n        \n        return False\n    \n    return bfs()",
    "timestamp": "2025-08-13 08:22:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    R, C = map(int, sys.stdin.readline().split())\n    grid = []\n    princess = None\n    soldiers = []\n    escape = None\n    for i in range(R):\n        line = sys.stdin.readline().strip()\n        grid.append(line)\n        for j in range(C):\n            if line[j] == 'P':\n                princess = (i, j)\n            elif line[j] == 'S':\n                soldiers.append((i, j))\n            elif line[j] == 'E':\n                escape = (i, j)\n    \n    # Precompute soldier distances\n    soldier_dist = [[-1 for _ in range(C)] for _ in range(R)]\n    q = deque()\n    for (i, j) in soldiers:\n        soldier_dist[i][j] = 0\n        q.append((i, j))\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    while q:\n        i, j = q.popleft()\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < R and 0 <= nj < C and grid[ni][nj] != '#' and soldier_dist[ni][nj] == -1:\n                soldier_dist[ni][nj] = soldier_dist[i][j] + 1\n                q.append((ni, nj))\n    \n    # BFS for princess\n    princess_dist = [[-1 for _ in range(C)] for _ in range(R)]\n    q = deque()\n    pi, pj = princess\n    princess_dist[pi][pj] = 0\n    q.append((pi, pj))\n    found = False\n    \n    while q:\n        i, j = q.popleft()\n        if (i, j) == escape:\n            found = True\n            break\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < R and 0 <= nj < C and grid[ni][nj] != '#':\n                new_dist = princess_dist[i][j] + 1\n                if (soldier_dist[ni][nj] == -1 or new_dist < soldier_dist[ni][nj]) and princess_dist[ni][nj] == -1:\n                    princess_dist[ni][nj] = new_dist\n                    q.append((ni, nj))\n    \n    print(\"YES\" if found else \"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 08:22:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nvector<Point> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nbool isValid(int x, int y, int R, int C, const vector<vector<char>> &grid) {\n    return x >= 0 && x < R && y >= 0 && y < C && grid[x][y] != '#';\n}\n\nbool canEscape(const vector<vector<char>> &grid, int R, int C, Point princess, Point escape, vector<Point> soldiers) {\n    vector<vector<int>> princessDist(R, vector<int>(C, numeric_limits<int>::max()));\n    princessDist[princess.x][princess.y] = 0;\n\n    queue<Point> pq;\n    pq.push(princess);\n\n    while (!pq.empty()) {\n        Point p = pq.front(); pq.pop();\n\n        for (const auto &dir : directions) {\n            int nx = p.x + dir.x;\n            int ny = p.y + dir.y;\n\n            if (isValid(nx, ny, R, C, grid) && princessDist[nx][ny] > princessDist[p.x][p.y] + 1) {\n                princessDist[nx][ny] = princessDist[p.x][p.y] + 1;\n                pq.push({nx, ny});\n            }\n        }\n    }\n\n    vector<vector<int>> soldierDist(R, vector<int>(C, numeric_limits<int>::max()));\n    queue<Point> sq;\n\n    for (const auto &soldier : soldiers) {\n        soldierDist[soldier.x][soldier.y] = 0;\n        sq.push(soldier);\n    }\n\n    while (!sq.empty()) {\n        Point s = sq.front(); sq.pop();\n\n        for (const auto &dir : directions) {\n            int nx = s.x + dir.x;\n            int ny = s.y + dir.y;\n\n            if (isValid(nx, ny, R, C, grid) && soldierDist[nx][ny] > soldierDist[s.x][s.y] + 1) {\n                soldierDist[nx][ny] = soldierDist[s.x][s.y] + 1;\n                sq.push({nx, ny});\n            }\n        }\n    }\n\n    return princessDist[escape.x][escape.y] < soldierDist[escape.x][escape.y];\n}\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n\n    vector<vector<char>> grid(R, vector<char>(C));\n    Point princess, escape;\n    vector<Point> soldiers;\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'P') {\n                princess = {i, j};\n            } else if (grid[i][j] == 'E') {\n                escape = {i, j};\n            } else if (grid[i][j] == 'S') {\n                soldiers.push_back({i, j});\n            }\n        }\n    }\n\n    if (canEscape(grid, R, C, princess, escape, soldiers)) {\n        cout << \"SUCCESS\\n\";\n    } else {\n        cout << \"FAILURE\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:22"
  }
]