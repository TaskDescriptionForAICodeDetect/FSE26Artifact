[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int volume;\n} Usage;\n\nint compare(const void *a, const void *b) {\n    Usage *u1 = (Usage *)a;\n    Usage *u2 = (Usage *)b;\n    return u1->start - u2->start;\n}\n\nint main() {\n    int L, N;\n    while (scanf(\"%d %d\", &L, &N) != EOF) {\n        Usage *usages = malloc(N * sizeof(Usage));\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d %d %d\", &usages[i].start, &usages[i].end, &usages[i].volume);\n        }\n        \n        qsort(usages, N, sizeof(Usage), compare);\n        \n        int max_speed = 0;\n        for (int i = 0; i < N; i++) {\n            int total_volume = 0;\n            int current_time = usages[i].start;\n            for (int j = 0; j <= i; j++) {\n                if (usages[j].end > current_time) {\n                    int overlap_start = (usages[j].start > current_time) ? usages[j].start : current_time;\n                    int overlap_end = (usages[j].end < usages[i].end) ? usages[j].end : usages[i].end;\n                    if (overlap_start < overlap_end) {\n                        total_volume += usages[j].volume * (overlap_end - overlap_start);\n                    }\n                }\n            }\n            int required_speed = (total_volume + L - 1) / L;\n            if (required_speed > max_speed) {\n                max_speed = required_speed;\n            }\n        }\n        \n        printf(\"%d\\n\", max_speed);\n        free(usages);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n    int rate;\n};\n\nbool compareIntervals(const Interval &a, const Interval &b) {\n    return a.start < b.start;\n}\n\nint computeMinPumpSpeed(int L, vector<Interval> &intervals) {\n    sort(intervals.begin(), intervals.end(), compareIntervals);\n    int maxDeficit = 0;\n    int current = L;\n\n    for (const auto &interval : intervals) {\n        int duration = interval.end - interval.start;\n        current -= interval.rate * duration;\n        if (current < 0) {\n            maxDeficit = max(maxDeficit, -current);\n        }\n    }\n\n    if (maxDeficit == 0) {\n        return 0;\n    }\n\n    int low = 1;\n    int high = maxDeficit;\n    int result = maxDeficit;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        bool possible = true;\n        current = L;\n\n        for (const auto &interval : intervals) {\n            int duration = interval.end - interval.start;\n            current += mid * duration;\n            current -= interval.rate * duration;\n            if (current < 0) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N; ++i) {\n        int L, M;\n        cin >> L >> M;\n        vector<Interval> intervals(M);\n        for (int j = 0; j < M; ++j) {\n            cin >> intervals[j].start >> intervals[j].end >> intervals[j].rate;\n        }\n        cout << computeMinPumpSpeed(L, intervals) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WaterTank {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        for (int i = 0; i < N; i++) {\n            int L = scanner.nextInt();\n            int M = scanner.nextInt();\n            int[] t = new int[M];\n            int[] l = new int[M];\n            for (int j = 0; j < M; j++) {\n                t[j] = scanner.nextInt();\n                l[j] = scanner.nextInt();\n            }\n            \n            double low = 0.0;\n            double high = 1e18;\n            double ans = 0.0;\n            \n            for (int iter = 0; iter < 100; iter++) {\n                double mid = (low + high) / 2.0;\n                boolean possible = true;\n                double current = L;\n                \n                for (int j = 0; j < M; j++) {\n                    double dt = (j == 0) ? t[j] : t[j] - t[j - 1];\n                    current += dt * mid;\n                    current -= l[j];\n                    if (current < 0) {\n                        possible = false;\n                        break;\n                    }\n                    if (current > L) {\n                        current = L;\n                    }\n                }\n                \n                if (possible) {\n                    ans = mid;\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n            System.out.printf(\"%.7f\\n\", ans);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:13:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WaterTankPump {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDatasets = scanner.nextInt();\n\n        for (int dataset = 1; dataset <= numDatasets; dataset++) {\n            int L = scanner.nextInt();\n            int numUsagePeriods = scanner.nextInt();\n            \n            List<int[]> usagePeriods = new ArrayList<>();\n            for (int i = 0; i < numUsagePeriods; i++) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                int volume = scanner.nextInt();\n                usagePeriods.add(new int[]{start, end, volume});\n            }\n\n            double minPumpSpeed = calculateMinPumpSpeed(L, usagePeriods);\n            System.out.printf(\"Dataset %d: %.2f\\n\", dataset, minPumpSpeed);\n        }\n        scanner.close();\n    }\n\n    private static double calculateMinPumpSpeed(int tankCapacity, List<int[]> usagePeriods) {\n        Collections.sort(usagePeriods, (a, b) -> a[0] - b[0]);\n        \n        double currentLevel = tankCapacity;\n        double maxPumpSpeed = 0;\n\n        for (int[] period : usagePeriods) {\n            int start = period[0];\n            int end = period[1];\n            int volumeUsed = period[2];\n            int duration = end - start;\n\n            double requiredSpeed = (volumeUsed + (tankCapacity - currentLevel)) / duration;\n            maxPumpSpeed = Math.max(maxPumpSpeed, requiredSpeed);\n            currentLevel = tankCapacity - volumeUsed;\n        }\n\n        return maxPumpSpeed;\n    }\n}",
    "timestamp": "2025-08-05 21:13:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n\n#define MAX_EVENTS 1000\n\ntypedef struct {\n    int start;\n    int end;\n    double volume;\n} WaterUsage;\n\ndouble calculate_min_pump_speed(int tank_capacity, WaterUsage* usage_events, int num_events) {\n    double max_deficit = 0.0;\n    \n    for (int i = 0; i < num_events; i++) {\n        double current_deficit = 0.0;\n        for (int j = 0; j < num_events; j++) {\n            if (usage_events[j].start <= usage_events[i].start && \n                usage_events[j].end > usage_events[i].start) {\n                int overlap_start = usage_events[i].start;\n                int overlap_end = (usage_events[j].end < usage_events[i].end) ? \n                                   usage_events[j].end : usage_events[i].end;\n                current_deficit += usage_events[j].volume * (overlap_end - overlap_start);\n            }\n        }\n        \n        double potential_deficit = current_deficit - tank_capacity;\n        if (potential_deficit > max_deficit) {\n            max_deficit = potential_deficit;\n        }\n    }\n    \n    return (max_deficit > 0) ? (max_deficit / (double)1) : 0;\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n    \n    for (int dataset = 0; dataset < num_datasets; dataset++) {\n        int tank_capacity, num_events;\n        scanf(\"%d %d\", &tank_capacity, &num_events);\n        \n        WaterUsage usage_events[MAX_EVENTS];\n        for (int i = 0; i < num_events; i++) {\n            scanf(\"%d %d %lf\", &usage_events[i].start, &usage_events[i].end, &usage_events[i].volume);\n        }\n        \n        double min_pump_speed = calculate_min_pump_speed(tank_capacity, usage_events, num_events);\n        printf(\"%.2f\\n\", min_pump_speed);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\ndouble calculateMinPumpSpeed(int tankCapacity, const vector<vector<int>>& schedule) {\n    vector<pair<int, double>> events;\n    \n    for (const auto& interval : schedule) {\n        int startTime = interval[0];\n        int endTime = interval[1];\n        double volumePerTime = interval[2];\n        \n        events.push_back({startTime, volumePerTime});\n        events.push_back({endTime, -volumePerTime});\n    }\n    \n    sort(events.begin(), events.end());\n    \n    double currentVolume = tankCapacity;\n    double maxNegativeVolume = 0;\n    double currentLoad = 0;\n    \n    for (const auto& event : events) {\n        currentLoad += event.second;\n        currentVolume += currentLoad;\n        \n        maxNegativeVolume = min(maxNegativeVolume, currentVolume);\n    }\n    \n    return max(0.0, -maxNegativeVolume / (events.back().first - events[0].first));\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n    \n    cout << fixed << setprecision(3);\n    \n    for (int dataset = 1; dataset <= numDatasets; ++dataset) {\n        int tankCapacity, numIntervals;\n        cin >> tankCapacity >> numIntervals;\n        \n        vector<vector<int>> schedule(numIntervals, vector<int>(3));\n        \n        for (int i = 0; i < numIntervals; ++i) {\n            cin >> schedule[i][0] >> schedule[i][1] >> schedule[i][2];\n        }\n        \n        double minPumpSpeed = calculateMinPumpSpeed(tankCapacity, schedule);\n        \n        cout << \"Dataset \" << dataset << \": \" << minPumpSpeed << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_pump_speed(datasets):\n    results = []\n    for data in datasets:\n        # Extract tank capacity and schedule from dataset\n        capacity = data['capacity']\n        schedule = data['schedule']\n\n        # Determine the max time based on schedule points\n        max_time = max(end for _, end, _ in schedule)\n        \n        # Initialize water usage at each time unit\n        water_usage = [0] * (max_time + 1)\n        \n        # Record water usage for each time unit in the schedule\n        for start, end, volume in schedule:\n            for t in range(start, end):\n                water_usage[t] += volume\n\n        # Determine the minimum pump speed needed\n        cur_water = capacity\n        max_needed = 0\n        for t in range(max_time):\n            needed = water_usage[t]\n            max_needed = max(max_needed, needed - cur_water)\n            cur_water -= needed\n            cur_water = max(cur_water, 0)\n\n        results.append(max(max_needed, 0))\n        \n    for result in results:\n        print(result)\n\n# Example of how to use this function with datasets\ndatasets = [\n    {'capacity': 100, 'schedule': [(1, 5, 20), (10, 15, 30)]},\n    {'capacity': 50, 'schedule': [(0, 10, 10), (5, 10, 20)]}\n]\n\nmin_pump_speed(datasets)",
    "timestamp": "2025-08-13 05:30:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WaterTankSolution {\n    static class Event implements Comparable<Event> {\n        int time;\n        int type; // +1 for start, -1 for end\n        int usage;\n\n        Event(int time, int type, int usage) {\n            this.time = time;\n            this.type = type;\n            this.usage = usage;\n        }\n\n        @Override\n        public int compareTo(Event other) {\n            if (this.time != other.time)\n                return Integer.compare(this.time, other.time);\n            return Integer.compare(this.type, other.type); // End should come after start if times are equal\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int numDatasets = sc.nextInt();\n        \n        for (int dataset = 0; dataset < numDatasets; dataset++) {\n            int L = sc.nextInt();\n            int N = sc.nextInt();\n            List<Event> events = new ArrayList<>();\n            \n            for (int i = 0; i < N; i++) {\n                int start = sc.nextInt();\n                int end = sc.nextInt();\n                int volumePerUnit = sc.nextInt();\n                \n                events.add(new Event(start, 1, volumePerUnit));\n                events.add(new Event(end, -1, volumePerUnit));\n            }\n            \n            Collections.sort(events);\n            int currentUsage = 0;\n            int maxUsage = 0;\n            \n            for (Event event : events) {\n                if (event.type == 1) {\n                    currentUsage += event.usage;\n                } else {\n                    currentUsage -= event.usage;\n                }\n                maxUsage = Math.max(maxUsage, currentUsage);\n            }\n            \n            double requiredSupplySpeed = (double) maxUsage;\n            System.out.printf(\"%.6f%n\", requiredSupplySpeed);\n        }\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 05:30:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_EVENTS 1000\n\ntypedef struct {\n    int time;\n    int volume_change;\n} Event;\n\nint compareEvents(const void *a, const void *b) {\n    return ((Event *)a)->time - ((Event *)b)->time;\n}\n\nvoid solveDataset(int L, int n, int schedules[][3]) {\n    Event events[MAX_EVENTS * 2];\n    int eventCount = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        int start = schedules[i][0];\n        int end = schedules[i][1];\n        int volume_per_time_unit = schedules[i][2];\n\n        events[eventCount++] = (Event){start, -volume_per_time_unit};\n        events[eventCount++] = (Event){end, volume_per_time_unit};\n    }\n\n    qsort(events, eventCount, sizeof(Event), compareEvents);\n\n    int current_volume = L;\n    int max_suction = 0;\n    int current_suction = 0;\n    int last_time = events[0].time;\n\n    for (int i = 0; i < eventCount; ++i) {\n        int time_difference = events[i].time - last_time;\n        current_volume += current_suction * time_difference;\n\n        if (events[i].time != last_time) {\n            if (current_volume < 0) {\n                max_suction = -1;\n                break;\n            }\n        }\n\n        current_suction += events[i].volume_change;\n        if (-current_suction > max_suction) {\n            max_suction = -current_suction;\n        }\n\n        last_time = events[i].time;\n    }\n\n    printf(\"%d\\n\", max_suction);\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        int L, n;\n        scanf(\"%d %d\", &L, &n);\n        \n        int schedules[MAX_EVENTS][3];\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d %d\", &schedules[i][0], &schedules[i][1], &schedules[i][2]);\n        }\n        \n        solveDataset(L, n, schedules);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:30:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_min_pump_speed(tank_capacity, schedule):\n    max_deficit = 0\n    current_level = tank_capacity\n    \n    for start, end, usage_rate in schedule:\n        water_used = usage_rate * (end - start)\n        current_level -= water_used\n        \n        max_deficit = max(max_deficit, -current_level)\n    \n    return max_deficit / len(schedule)\n\ndef main():\n    num_datasets = int(input())\n    \n    for _ in range(num_datasets):\n        tank_capacity = int(input())\n        num_intervals = int(input())\n        \n        schedule = []\n        for _ in range(num_intervals):\n            start, end, usage_rate = map(int, input().split())\n            schedule.append((start, end, usage_rate))\n        \n        min_pump_speed = calculate_min_pump_speed(tank_capacity, schedule)\n        print(f\"{min_pump_speed:.3f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:30:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input_lines = sys.stdin.read().splitlines()\n    idx = 0\n    while idx < len(input_lines):\n        N, L = map(int, input_lines[idx].split())\n        idx += 1\n        events = []\n        for _ in range(N):\n            s, e, w = map(int, input_lines[idx].split())\n            events.append((s, w))\n            events.append((e, -w))\n            idx += 1\n        events.sort()\n        current_water = L\n        max_deficit = 0\n        prev_time = 0\n        for time, delta in events:\n            elapsed = time - prev_time\n            current_water -= max_deficit * elapsed\n            if current_water < 0:\n                # Need to increase the pump speed\n                additional_speed = (-current_water + elapsed - 1) // elapsed\n                max_deficit += additional_speed\n                current_water += additional_speed * elapsed\n            prev_time = time\n            if delta > 0:\n                # Usage starts\n                max_deficit += delta\n            else:\n                # Usage ends\n                max_deficit += delta\n        print(max_deficit)\n\nsolve()",
    "timestamp": "2025-08-13 05:30:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Usage {\n    int start;\n    int end;\n    int volume;\n};\n\nbool compareUsage(const Usage& a, const Usage& b) {\n    return a.start < b.start;\n}\n\nint main() {\n    int datasets;\n    std::cin >> datasets;\n\n    while (datasets--) {\n        int L, n;\n        std::cin >> L >> n;\n        std::vector<Usage> schedule(n);\n\n        for (int i = 0; i < n; ++i) {\n            std::cin >> schedule[i].start >> schedule[i].end >> schedule[i].volume;\n        }\n\n        std::sort(schedule.begin(), schedule.end(), compareUsage);\n\n        int current_time = 0, current_volume = L;\n        int min_supply = 0;\n\n        for (Usage& usage : schedule) {\n            if (current_time < usage.start) {\n                current_volume = std::min(L, current_volume + min_supply * (usage.start - current_time));\n                current_time = usage.start;\n            }\n\n            for (int t = usage.start; t < usage.end; ++t) {\n                current_volume -= usage.volume;\n                if (current_volume < 0) {\n                    min_supply = std::max(min_supply, usage.volume + (-current_volume));\n                    current_volume = 0;\n                }\n                current_volume += min_supply;\n                current_time++;\n            }\n        }\n\n        std::cout << min_supply << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:38"
  }
]