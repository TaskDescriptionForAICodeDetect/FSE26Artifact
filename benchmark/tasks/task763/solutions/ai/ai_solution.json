[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n\ntypedef long long ll;\n\nll modInverse(ll a, ll m) {\n    ll m0 = m, t, q;\n    ll x0 = 0, x1 = 1;\n    \n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        q = a / m;\n        t = m;\n        \n        m = a % m;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0) x1 += m0;\n    \n    return x1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int size = 1 << N;\n    double prob[size];\n    \n    for (int i = 0; i < size; i++) {\n        scanf(\"%lf\", &prob[i]);\n    }\n    \n    double expected[size];\n    memset(expected, 0, sizeof(expected));\n    \n    for (int target = 0; target < size; target++) {\n        double currExpected = 0;\n        int* visited = calloc(size, sizeof(int));\n        \n        for (int start = 0; start < size; start++) {\n            int current = start;\n            int steps = 0;\n            \n            while (!visited[current]) {\n                visited[current] = 1;\n                \n                for (int v = 0; v < size; v++) {\n                    int next = current ^ v;\n                    currExpected += prob[v] * (steps + 1);\n                    current = next;\n                    steps++;\n                }\n            }\n        }\n        \n        free(visited);\n        expected[target] = currExpected / size;\n    }\n    \n    for (int i = 0; i < size; i++) {\n        ll P = (ll)(expected[i] * MOD);\n        ll Q = MOD;\n        ll R = (modInverse(Q, P) * P) % MOD;\n        printf(\"%lld\\n\", R);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAXN 20\n#define MAXS (1 << MAXN)\n\nint N, S;\nint A[MAXS], sumA;\nint inv_sumA;\nint f[MAXS], g[MAXS], h[MAXS];\n\nint add(int a, int b) {\n    a += b;\n    return a >= MOD ? a - MOD : a;\n}\n\nint sub(int a, int b) {\n    a -= b;\n    return a < 0 ? a + MOD : a;\n}\n\nint mul(int a, int b) {\n    return (long long)a * b % MOD;\n}\n\nint pow_mod(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) res = mul(res, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid fwht(int *a, int n, int inv) {\n    for (int len = 1; len < n; len <<= 1) {\n        for (int i = 0; i < n; i += len << 1) {\n            for (int j = 0; j < len; j++) {\n                int u = a[i + j], v = a[i + j + len];\n                a[i + j] = add(u, v);\n                a[i + j + len] = sub(u, v);\n            }\n        }\n    }\n    if (inv == -1) {\n        int inv_n = pow_mod(n, MOD - 2);\n        for (int i = 0; i < n; i++) {\n            a[i] = mul(a[i], inv_n);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    S = 1 << N;\n    sumA = 0;\n    for (int i = 0; i < S; i++) {\n        scanf(\"%d\", &A[i]);\n        sumA = add(sumA, A[i]);\n    }\n    inv_sumA = pow_mod(sumA, MOD - 2);\n    for (int i = 0; i < S; i++) {\n        A[i] = mul(A[i], inv_sumA);\n    }\n\n    for (int i = 1; i < S; i++) {\n        h[i] = MOD - 1;\n    }\n    h[0] = S - 1;\n\n    fwht(h, S, 1);\n    fwht(A, S, 1);\n\n    for (int i = 0; i < S; i++) {\n        if (A[i] == 1) {\n            g[i] = 0;\n        } else {\n            g[i] = mul(h[i], pow_mod(sub(1, A[i]), MOD - 2));\n        }\n    }\n\n    fwht(g, S, -1);\n\n    int offset = g[0];\n    for (int i = 0; i < S; i++) {\n        printf(\"%d\\n\", sub(g[i], offset));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modpow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a) {\n    return modpow(a, MOD - 2);\n}\n\nvoid xor_fwt(vector<long long> &a, bool inv) {\n    int n = a.size();\n    for (int k = 1; k < n; k <<= 1) {\n        for (int i = 0; i < n; i += 2 * k) {\n            for (int j = 0; j < k; ++j) {\n                long long x = a[i + j];\n                long long y = a[i + j + k];\n                a[i + j] = (x + y) % MOD;\n                a[i + j + k] = (x - y + MOD) % MOD;\n            }\n        }\n    }\n    if (inv) {\n        long long inv_n = modinv(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = a[i] * inv_n % MOD;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    int size = 1 << N;\n    vector<long long> A(size);\n    long long sum = 0;\n    for (int i = 0; i < size; ++i) {\n        cin >> A[i];\n        sum += A[i];\n    }\n    sum %= MOD;\n    long long inv_sum = modinv(sum);\n    for (int i = 0; i < size; ++i) {\n        A[i] = A[i] * inv_sum % MOD;\n    }\n\n    vector<long long> S(size);\n    S[0] = 1;\n    xor_fwt(A, false);\n    xor_fwt(S, false);\n\n    vector<long long> E(size);\n    for (int i = 0; i < size; ++i) {\n        if (A[i] == 1) {\n            E[i] = 0;\n        } else {\n            E[i] = (MOD - 1) * modinv((1 - A[i] + MOD) % MOD) % MOD;\n        }\n    }\n    xor_fwt(E, true);\n\n    long long E0 = E[0];\n    for (int i = 0; i < size; ++i) {\n        E[i] = (E[i] - E0 + MOD) % MOD;\n    }\n\n    for (int i = 0; i < size; ++i) {\n        cout << E[i] << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    static long powMod(long x, long n) {\n        long res = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) res = res * x % MOD;\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    static void fwhtXor(long[] a, boolean inverse) {\n        int n = a.length;\n        for (int len = 2; len <= n; len <<= 1) {\n            int half = len / 2;\n            for (int i = 0; i < n; i += len) {\n                for (int j = 0; j < half; j++) {\n                    long u = a[i + j];\n                    long v = a[i + j + half];\n                    a[i + j] = (u + v) % MOD;\n                    a[i + j + half] = (u - v + MOD) % MOD;\n                }\n            }\n        }\n        if (inverse) {\n            long inv = powMod(n, MOD - 2);\n            for (int i = 0; i < n; i++) {\n                a[i] = a[i] * inv % MOD;\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        int size = 1 << N;\n        long[] A = new long[size];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        long sum = 0;\n        for (int i = 0; i < size; i++) {\n            A[i] = Integer.parseInt(st.nextToken());\n            sum += A[i];\n        }\n        sum %= MOD;\n        long invSum = powMod(sum, MOD - 2);\n        for (int i = 0; i < size; i++) {\n            A[i] = A[i] * invSum % MOD;\n        }\n\n        long[] f = new long[size];\n        fwhtXor(A, false);\n        f[0] = 0;\n        for (int i = 1; i < size; i++) {\n            long denom = (1 - A[i] + MOD) % MOD;\n            if (denom == 0) {\n                f[i] = -1;\n            } else {\n                f[i] = powMod(denom, MOD - 2);\n            }\n        }\n        fwhtXor(f, true);\n\n        long total = 0;\n        for (int i = 0; i < size; i++) {\n            total = (total + f[i]) % MOD;\n        }\n        total = total * powMod(size, MOD - 2) % MOD;\n        long offset = (f[0] - total + MOD) % MOD;\n        for (int i = 0; i < size; i++) {\n            long res = (f[i] - offset + MOD) % MOD;\n            System.out.println(res);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:51:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static final int MOD = 998244353;\n    \n    public static void solve(int N, int X) {\n        int M = 1 << N;\n        double[] expectation = new double[M];\n        expectation[X] = 0;\n        \n        for (int mask = 0; mask < M; mask++) {\n            if (mask == X) continue;\n            \n            double prob = 1.0 / M;\n            double totalExpect = 0;\n            \n            for (int v = 0; v < M; v++) {\n                int newMask = mask ^ v;\n                totalExpect += expectation[newMask] + 1;\n            }\n            \n            expectation[mask] = totalExpect / M;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            long P = (long) (expectation[i] * M);\n            long Q = M;\n            long R = modInverse(Q, MOD);\n            R = (R * P) % MOD;\n            System.out.println(R);\n        }\n    }\n    \n    static long modInverse(long a, long m) {\n        long m0 = m;\n        long y = 0, x = 1;\n        \n        if (m == 1) return 0;\n        \n        while (a > 1) {\n            long q = a / m;\n            long t = m;\n            \n            m = a % m;\n            a = t;\n            t = y;\n            \n            y = x - q * y;\n            x = t;\n        }\n        \n        if (x < 0) x += m0;\n        return x;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int X = Integer.parseInt(st.nextToken());\n        \n        solve(N, X);\n    }\n}",
    "timestamp": "2025-08-05 22:51:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 998244353;\nconst int MAXN = 20;\n\nll modInverse(ll a, ll m) {\n    ll m0 = m;\n    ll y = 0, x = 1;\n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        ll q = a / m;\n        ll t = m;\n        m = a % m, a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += m0;\n    return x;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<double> prob(1 << N);\n    for (int i = 0; i < (1 << N); i++) {\n        cin >> prob[i];\n    }\n    \n    vector<double> expected(1 << N, 0);\n    expected[0] = 0;\n    \n    for (int i = 1; i < (1 << N); i++) {\n        double sum = 0;\n        for (int j = 0; j < (1 << N); j++) {\n            int newState = i ^ j;\n            sum += prob[j] * (expected[newState] + 1);\n        }\n        expected[i] = sum / (1 - prob[i]);\n    }\n    \n    for (int i = 0; i < (1 << N); i++) {\n        ll P = round(expected[i] * (1LL << 60));\n        ll Q = 1LL << 60;\n        ll G = __gcd(P, Q);\n        P /= G;\n        Q /= G;\n        \n        ll inv = modInverse(Q, MOD);\n        ll R = (P * inv) % MOD;\n        \n        cout << R << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 998244353\n\ndef mod_inv(a, mod):\n    return pow(a, mod-2, mod)\n\ndef solve(N, A):\n    M = 1 << N\n    sum_A = sum(A) % MOD\n    inv_sum_A = mod_inv(sum_A, MOD)\n\n    E = [0] * M\n    for i in range(1, M):\n        denominator = (MOD + sum_A - A[i]) % MOD\n        inv_denominator = mod_inv(denominator, MOD)\n        E[i] = ((sum_A * inv_denominator % MOD - 1 + MOD) % MOD * inv_sum_A % MOD)\n        \n    results = []\n    for i in range(M):\n        P = E[i] * sum_A % MOD\n        Q = (sum_A - A[i]) % MOD\n        R = P * mod_inv(Q, MOD) % MOD\n        results.append(R)\n    \n    for result in results:\n        print(result)\n\n# Example usage:\nN = 3\nA = [1, 1, 1, 1, 1, 1, 1, 1]\nsolve(N, A)",
    "timestamp": "2025-08-13 12:41:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RandomNumberGenerator {\n    static final int MOD = 998244353;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int size = 1 << N;\n        \n        int[] A = new int[size];\n        for (int i = 0; i < size; i++) {\n            A[i] = scanner.nextInt();\n        }\n\n        long[] expectedOps = new long[size];\n        expectedOps[0] = 0; // Base case: If X is 0, no more operations are needed.\n\n        for (int i = 1; i < size; i++) {\n            long sumProbability = 0;\n            long expectedSum = 0;\n            for (int j = 0; j < size; j++) {\n                int xorIndex = i ^ j;\n                long probability = A[j];\n                sumProbability += probability;\n                expectedSum += probability * (expectedOps[xorIndex] + 1);\n            }\n            expectedOps[i] = expectedSum * modInverse(sumProbability, MOD) % MOD;\n        }\n\n        for (int i = 0; i < size; i++) {\n            System.out.println(expectedOps[i]);\n        }\n    }\n\n    private static long modInverse(long a, int mod) {\n        long m0 = mod, y = 0, x = 1;\n        if (mod == 1) return 0;\n        while (a > 1) {\n            long q = a / mod;\n            long t = mod;\n            mod = a % mod;\n            a = t;\n            t = y;\n            y = x - q * y;\n            x = t;\n        }\n        if (x < 0) x += m0;\n        return x;\n    }\n}",
    "timestamp": "2025-08-13 12:41:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n#define MAXN (20)\n\nlong long modInverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int size = 1 << N;\n    long long A[size], expected[size];\n    \n    for (int i = 0; i < size; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n    \n    for (int i = 0; i < size; i++) {\n        A[i] %= MOD;\n        if (A[i] == 0) A[i] = MOD;\n    }\n\n    for (int i = 0; i < size; i++) {\n        expected[i] = 0;\n    }\n    \n    expected[0] = 0;\n    for (int i = 1; i < size; i++) {\n        long long sumProb = 0;\n        for (int j = 0; j < size; j++) {\n            sumProb += A[j];\n            sumProb %= MOD;\n        }\n        \n        long long denominator = (sumProb - A[0] + MOD) % MOD;\n        expected[i] = 0;\n        \n        for (int j = 0; j < size; j++) {\n            if (j == 0) continue;\n            int xorIndex = i ^ j;\n            long long val = (A[j] * (expected[xorIndex] + 1)) % MOD;\n            expected[i] = (expected[i] + val) % MOD;\n        }\n        \n        expected[i] = (expected[i] * modInverse(denominator, MOD)) % MOD;\n    }\n    \n    for (int i = 0; i < size; i++) {\n        printf(\"%lld\\n\", expected[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:41:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 998244353;\nconst int MAXN = 21;\n\nint N;\nstd::vector<int> A;\nstd::vector<int> E;\n\nint modInverse(int a, int m) {\n    int m0 = m, t, q;\n    int x0 = 0, x1 = 1;\n\n    if (m == 1) return 0;\n\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m;\n        a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n\n    if (x1 < 0) x1 += m0;\n\n    return x1;\n}\n\nint main() {\n    std::cin >> N;\n    A.resize(1 << N);\n    E.resize(1 << N, MOD);\n\n    for (int i = 0; i < (1 << N); ++i) {\n        std::cin >> A[i];\n    }\n\n    E[0] = 0;\n    for (int i = 1; i < (1 << N); ++i) {\n        int num = 0, den = MOD - A[i];\n        for (int j = 0; j < (1 << N); ++j) {\n            num = (num + (((j & i) == j) ? A[j] : 0) * E[j]) % MOD;\n        }\n        den = modInverse(den, MOD);\n        E[i] = ((num + MOD) * den) % MOD;\n    }\n\n    for (int i = 0; i < (1 << N); ++i) {\n        std::cout << E[i] << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:41:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N):\n    MOD = 998244353\n    \n    def mul_inv(a, m):\n        def egcd(a, b):\n            if a == 0:\n                return b, 0, 1\n            else:\n                g, y, x = egcd(b % a, a)\n                return g, x - (b // a) * y, y\n        \n        g, x, _ = egcd(a, m)\n        if g != 1:\n            raise Exception('Modular inverse does not exist')\n        else:\n            return x % m\n\n    A = [0] * (1 << N)\n    for i in range(1 << N):\n        A[i] = 1 / (1 << N)\n    \n    # Solve expected time to reach each state\n    E = [float('inf')] * (1 << N)\n    E[0] = 0\n    \n    for rep in range(1 << N):\n        for x in range(1 << N):\n            if E[x] == float('inf'):\n                continue\n            for v in range(1 << N):\n                nx = x ^ v\n                if E[nx] > E[x] + 1:\n                    E[nx] = E[x] + 1\n\n    result = []\n    for i in range(1 << N):\n        if E[i] == float('inf'):\n            result.append(0)\n        else:\n            numerator = int(E[i] * (1 << N))\n            denominator = 1 << N\n            \n            inv = mul_inv(denominator, MOD)\n            R = (numerator * inv) % MOD\n            result.append(R)\n    \n    return result\n\ndef main():\n    N = int(input())\n    result = solve(N)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:41:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    size = 1 << N\n    A = list(map(int, input[ptr:ptr+size]))\n    ptr += size\n    \n    sum_A = sum(A) % MOD\n    inv_sum = pow(sum_A, MOD-2, MOD)\n    P = [a * inv_sum % MOD for a in A]\n    \n    # Fast Walsh-Hadamard Transform (XOR)\n    fwht = P.copy()\n    n = size\n    h = 1\n    while h < n:\n        for i in range(0, n, h*2):\n            for j in range(i, i+h):\n                x = fwht[j]\n                y = fwht[j + h]\n                fwht[j] = (x + y) % MOD\n                fwht[j + h] = (x - y) % MOD\n        h *= 2\n    \n    # Compute S\n    S = [0] * size\n    for i in range(1, size):\n        denom = (1 - fwht[i]) % MOD\n        if denom == 0:\n            S[i] = 0\n        else:\n            S[i] = pow(denom, MOD-2, MOD)\n    \n    # Inverse FWHT\n    h = 1\n    inv_2 = pow(2, MOD-2, MOD)\n    inv_size = pow(size, MOD-2, MOD)\n    while h < n:\n        for i in range(0, n, h*2):\n            for j in range(i, i+h):\n                x = S[j]\n                y = S[j + h]\n                S[j] = (x + y) * inv_2 % MOD\n                S[j + h] = (x - y) * inv_2 % MOD\n        h *= 2\n    \n    total = S[0]\n    res = []\n    for i in range(size):\n        if i == 0:\n            res.append(0)\n        else:\n            ans = (total - S[i]) % MOD\n            res.append(ans)\n    \n    print('\\n'.join(map(str, res)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:41:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const mod = 998244353;\n\nfunction modInv(a, mod) {\n    let m0 = mod, t, q;\n    let x0 = 0, x1 = 1;\n    if (mod === 1) return 0;\n    while (a > 1) {\n        q = Math.floor(a / mod);\n        t = mod;\n        mod = a % mod;\n        a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nfunction calculateExpectedOperations(N, A) {\n    const size = 1 << N;\n    let E = Array(size).fill(0);\n    E[0] = 0;\n    for (let x = 1; x < size; x++) {\n        let sumProb = 0;\n        for (let v = 0; v < size; v++) {\n            let nextX = x ^ v;\n            E[x] = (E[x] + A[v] * (1 + E[nextX])) % mod;\n            sumProb = (sumProb + A[v]) % mod;\n        }\n        const sumProbInv = modInv(sumProb, mod);\n        E[x] = (E[x] * sumProbInv) % mod;\n    }\n    return E;\n}\n\nfunction main(N, A) {\n    const E = calculateExpectedOperations(N, A);\n    E.forEach(e => console.log(e));\n}\n\n// Example Usage: \n// N = 2, Sequence A = [1, 2, 3, 4] (probabilities)\n// main(2, [1, 2, 3, 4]);",
    "timestamp": "2025-08-13 12:41:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, P, Q) {\n    const MOD = 998244353n;\n    const M = 1n << BigInt(N);\n    \n    const prob = new Array(Number(M)).fill(0).map(() => 0n);\n    for (let j = 0; j < M; j++) {\n        prob[j] = 1n;\n    }\n    \n    const expect = new Array(Number(M)).fill(0).map(() => 0n);\n    \n    for (let i = 0; i < M; i++) {\n        let sum = 0n;\n        let sq_sum = 0n;\n        \n        for (let j = 0; j < M; j++) {\n            const newX = i ^ j;\n            sum += prob[j];\n            sq_sum += prob[j] * prob[j];\n        }\n        \n        const p = sum;\n        const q = M;\n        \n        expect[i] = (p * modInverse(q, MOD)) % MOD;\n    }\n    \n    return expect[P] * modInverse(Q, MOD) % MOD;\n}\n\nfunction modInverse(a, m) {\n    a = BigInt(a);\n    m = BigInt(m);\n    \n    function egcd(a, b) {\n        if (b === 0n) return [a, 1n, 0n];\n        const [g, x, y] = egcd(b, a % b);\n        return [g, y, x - (a / b) * y];\n    }\n    \n    const [g, x] = egcd(a, m);\n    return ((x % m) + m) % m;\n}",
    "timestamp": "2025-08-13 12:42:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(/\\s+/);\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const size = 1 << N;\n    const A = [];\n    for (let i = 0; i < size; i++) {\n        A.push(parseInt(input[ptr++], 10));\n    }\n\n    // Compute sum of A and check if it's zero (should not happen per problem statement)\n    const sumA = A.reduce((acc, val) => (acc + val) % MOD, 0);\n    const invSumA = powMod(sumA, MOD - 2, MOD);\n    const P = A.map(a => (a * invSumA) % MOD);\n\n    // Compute the FWT of P\n    const fw = [...P];\n    for (let i = 0; i < N; i++) {\n        for (let mask = 0; mask < size; mask++) {\n            if (mask & (1 << i)) {\n                const x = fw[mask ^ (1 << i)];\n                const y = fw[mask];\n                fw[mask ^ (1 << i)] = (x + y) % MOD;\n                fw[mask] = (x - y + MOD) % MOD;\n            }\n        }\n    }\n\n    // Compute the FWT of E\n    const fwE = new Array(size).fill(0);\n    for (let mask = 0; mask < size; mask++) {\n        if (mask === 0) {\n            fwE[mask] = 0;\n        } else {\n            const denom = (1 - fw[mask] + MOD) % MOD;\n            if (denom === 0) {\n                // No solution, but problem states it's finite\n                fwE[mask] = 0;\n            } else {\n                const invDenom = powMod(denom, MOD - 2, MOD);\n                fwE[mask] = (MOD - 1) * invDenom % MOD;\n            }\n        }\n    }\n\n    // Inverse FWT to get E\n    const E = [...fwE];\n    for (let i = 0; i < N; i++) {\n        for (let mask = 0; mask < size; mask++) {\n            if (mask & (1 << i)) {\n                const x = E[mask ^ (1 << i)];\n                const y = E[mask];\n                E[mask ^ (1 << i)] = (x + y) % MOD;\n                E[mask] = (x - y + MOD) % MOD;\n            }\n        }\n    }\n\n    const invSize = powMod(size, MOD - 2, MOD);\n    for (let i = 0; i < size; i++) {\n        E[i] = E[i] * invSize % MOD;\n    }\n\n    // Compute E[0]\n    let E0 = 0;\n    for (let i = 0; i < size; i++) {\n        E0 = (E0 + E[i]) % MOD;\n    }\n    E0 = E0 * invSize % MOD;\n    E0 = (E[0] - E0 + MOD) % MOD;\n\n    // Adjust E\n    for (let i = 0; i < size; i++) {\n        E[i] = (E[i] - E0 + MOD) % MOD;\n    }\n\n    // Output the result\n    console.log(E.join('\\n'));\n}\n\nfunction powMod(a, b, mod) {\n    let res = 1;\n    a = a % mod;\n    while (b > 0) {\n        if (b % 2 === 1) {\n            res = res * a % mod;\n        }\n        a = a * a % mod;\n        b = Math.floor(b / 2);\n    }\n    return res;\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:42:25"
  }
]